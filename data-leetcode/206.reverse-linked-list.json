[
    {
        "title": "Zigzag Conversion",
        "question_content": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);\n\n&nbsp;\nExample 1:\n\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n\nExample 2:\n\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\nExample 3:\n\nInput: s = \"A\", numRows = 1\nOutput: \"A\"\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 1000\n\ts consists of English letters (lower-case and upper-case), ',' and '.'.\n\t1 <= numRows <= 1000",
        "solutions": [
            {
                "id": 3403,
                "title": "easy-to-understand-java-solution",
                "content": "Create nRows StringBuffers, and keep collecting characters from original string to corresponding StringBuffer. Just take care of your index to keep them in bound.\\n\\n    public String convert(String s, int nRows) {\\n        char[] c = s.toCharArray();\\n        int len = c.length;\\n        StringBuffer[] sb = new StringBuffer[nRows];\\n        for (int i = 0; i < sb.length; i++) sb[i] = new StringBuffer();\\n        \\n        int i = 0;\\n        while (i < len) {\\n            for (int idx = 0; idx < nRows && i < len; idx++) // vertically down\\n                sb[idx].append(c[i++]);\\n            for (int idx = nRows-2; idx >= 1 && i < len; idx--) // obliquely up\\n                sb[idx].append(c[i++]);\\n        }\\n        for (int idx = 1; idx < sb.length; idx++)\\n            sb[0].append(sb[idx]);\\n        return sb[0].toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Create nRows StringBuffers, and keep collecting characters from original string to corresponding StringBuffer. Just take care of your index to keep them in bound.\\n\\n    public String convert(String s, int nRows) {\\n        char[] c = s.toCharArray();\\n        int len = c.length;\\n        StringBuffer[] sb = new StringBuffer[nRows];\\n        for (int i = 0; i < sb.length; i++) sb[i] = new StringBuffer();\\n        \\n        int i = 0;\\n        while (i < len) {\\n            for (int idx = 0; idx < nRows && i < len; idx++) // vertically down\\n                sb[idx].append(c[i++]);\\n            for (int idx = nRows-2; idx >= 1 && i < len; idx--) // obliquely up\\n                sb[idx].append(c[i++]);\\n        }\\n        for (int idx = 1; idx < sb.length; idx++)\\n            sb[0].append(sb[idx]);\\n        return sb[0].toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3404,
                "title": "python-o-n-solution-in-96ms-99-43",
                "content": "    class Solution(object):\\n        def convert(self, s, numRows):\\n            \"\"\"\\n            :type s: str\\n            :type numRows: int\\n            :rtype: str\\n            \"\"\"\\n            if numRows == 1 or numRows >= len(s):\\n                return s\\n    \\n            L = [''] * numRows\\n            index, step = 0, 1\\n    \\n            for x in s:\\n                L[index] += x\\n                if index == 0:\\n                    step = 1\\n                elif index == numRows -1:\\n                    step = -1\\n                index += step\\n    \\n            return ''.join(L)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def convert(self, s, numRows):\\n            \"\"\"\\n            :type s: str\\n            :type numRows: int\\n            :rtype: str\\n            \"\"\"\\n            if numRows == 1 or numRows >= len(s):\\n                return s\\n    \\n            L = [''] * numRows\\n            index, step = 0, 1\\n    \\n            for x in s:\\n                L[index] += x\\n                if index == 0:\\n                    step = 1\\n                elif index == numRows -1:\\n                    step = -1\\n                index += step\\n    \\n            return ''.join(L)",
                "codeTag": "Java"
            },
            {
                "id": 3435,
                "title": "if-you-are-confused-with-zigzag-pattern-come-and-see",
                "content": "    /*n=numRows\\n    \\u0394=2n-2    1                           2n-1                         4n-3\\n    \\u0394=        2                     2n-2  2n                    4n-4   4n-2\\n    \\u0394=        3               2n-3        2n+1              4n-5       .\\n    \\u0394=        .           .               .               .            .\\n    \\u0394=        .       n+2                 .           3n               .\\n    \\u0394=        n-1 n+1                     3n-3    3n-1                 5n-5\\n    \\u0394=2n-2    n                           3n-2                         5n-4\\n    */\\nthat's the zigzag pattern the question asked!\\nBe careful with nR=1 && nR=2\\n\\n----------\\n\\n\\n----------\\n\\n\\n----------\\n\\n\\n----------\\n\\n\\n----------\\n\\n\\n----------\\n\\n\\n----------\\n\\n\\n----------\\n\\n\\nmy 16ms code in c++:\\n\\n    class Solution {\\n    public:\\n        string convert(string s, int numRows) {\\n            string result=\"\";\\n            if(numRows==1)\\n    \\t\\t\\treturn s;\\n            int step1,step2;\\n            int len=s.size();\\n            for(int i=0;i<numRows;++i){\\n                step1=(numRows-i-1)*2;\\n                step2=(i)*2;\\n                int pos=i;\\n                if(pos<len)\\n                    result+=s.at(pos);\\n                while(1){\\n                    pos+=step1;\\n                    if(pos>=len)\\n                        break;\\n    \\t\\t\\t\\tif(step1)\\n    \\t\\t\\t\\t\\tresult+=s.at(pos);\\n                    pos+=step2;\\n                    if(pos>=len)\\n                        break;\\n    \\t\\t\\t\\tif(step2)\\n    \\t\\t\\t\\t\\tresult+=s.at(pos);\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string convert(string s, int numRows) {\\n            string result=\"\";\\n            if(numRows==1)\\n    \\t\\t\\treturn s;\\n            int step1,step2;\\n            int len=s.size();\\n            for(int i=0;i<numRows;++i){\\n                step1=(numRows-i-1)*2;\\n                step2=(i)*2;\\n                int pos=i;\\n                if(pos<len)\\n                    result+=s.at(pos);\\n                while(1){\\n                    pos+=step1;\\n                    if(pos>=len)\\n                        break;\\n    \\t\\t\\t\\tif(step1)\\n    \\t\\t\\t\\t\\tresult+=s.at(pos);\\n                    pos+=step2;\\n                    if(pos>=len)\\n                        break;\\n    \\t\\t\\t\\tif(step2)\\n    \\t\\t\\t\\t\\tresult+=s.at(pos);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3134053,
                "title": "c-faster-than-95-easy-understanding-clean-concise-code",
                "content": "\\n\\n\\n\\n**PLEASE DO UPVOTE!!!!!**\\n\\n**Connect with Me on Linkedin -> https://www.linkedin.com/in/md-kamran-55b98521a/**\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n\\n    string convert(string s, int numRows) {\\n    \\n    if(numRows <= 1) return s;\\n\\n    vector<string>v(numRows, \"\"); \\n\\n    int j = 0, dir = -1;\\n\\n    for(int i = 0; i < s.length(); i++)\\n    {\\n\\n        if(j == numRows - 1 || j == 0) dir *= (-1); \\n\\t\\t \\n        v[j] += s[i];\\n\\n        if(dir == 1) j++;\\n\\n        else j--;\\n    }\\n\\n    string res;\\n\\n    for(auto &it : v) res += it; \\n\\n    return res;\\n\\n    }\\n};\\n\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n\\n    string convert(string s, int numRows) {\\n    \\n    if(numRows <= 1) return s;\\n\\n    vector<string>v(numRows, \"\"); \\n\\n    int j = 0, dir = -1;\\n\\n    for(int i = 0; i < s.length(); i++)\\n    {\\n\\n        if(j == numRows - 1 || j == 0) dir *= (-1); \\n\\t\\t \\n        v[j] += s[i];\\n\\n        if(dir == 1) j++;\\n\\n        else j--;\\n    }\\n\\n    string res;\\n\\n    for(auto &it : v) res += it; \\n\\n    return res;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465,
                "title": "share-simple-c-solution",
                "content": "The problem statement itself is unclear for many. Especially for 2-row case. \"ABCD\", 2 --> \"ACBD\". The confusion most likely is from the character placement. I would like to extend it a little bit to make ZigZag easy understood.\\n\\nThe example can be written as follow:\\n\\n1. P.......A........H.......N\\n2. ..A..P....L..S....I...I....G\\n3. ....Y.........I........R\\n\\nTherefore, <ABCD, 2> can be arranged as:\\n\\n 1. A....C\\n 2. ...B....D\\n\\nMy simple accepted code:\\n\\n    string convert(string s, int nRows) {\\n        \\n        if (nRows <= 1)\\n            return s;\\n    \\n        const int len = (int)s.length();\\n        string *str = new string[nRows];\\n    \\n        int row = 0, step = 1;\\n        for (int i = 0; i < len; ++i)\\n        {\\n            str[row].push_back(s[i]);\\n    \\n            if (row == 0)\\n                step = 1;\\n            else if (row == nRows - 1)\\n                step = -1;\\n    \\n            row += step;\\n        }\\n    \\n        s.clear();\\n        for (int j = 0; j < nRows; ++j)\\n        {\\n            s.append(str[j]);\\n        }\\n    \\n        delete[] str;\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "The problem statement itself is unclear for many. Especially for 2-row case. \"ABCD\", 2 --> \"ACBD\". The confusion most likely is from the character placement. I would like to extend it a little bit to make ZigZag easy understood.\\n\\nThe example can be written as follow:\\n\\n1. P.......A........H.......N\\n2. ..A..P....L..S....I...I....G\\n3. ....Y.........I........R\\n\\nTherefore, <ABCD, 2> can be arranged as:\\n\\n 1. A....C\\n 2. ...B....D\\n\\nMy simple accepted code:\\n\\n    string convert(string s, int nRows) {\\n        \\n        if (nRows <= 1)\\n            return s;\\n    \\n        const int len = (int)s.length();\\n        string *str = new string[nRows];\\n    \\n        int row = 0, step = 1;\\n        for (int i = 0; i < len; ++i)\\n        {\\n            str[row].push_back(s[i]);\\n    \\n            if (row == 0)\\n                step = 1;\\n            else if (row == nRows - 1)\\n                step = -1;\\n    \\n            row += step;\\n        }\\n    \\n        s.clear();\\n        for (int j = 0; j < nRows; ++j)\\n        {\\n            s.append(str[j]);\\n        }\\n    \\n        delete[] str;\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 817306,
                "title": "very-simple-and-intuitive-o-n-python-solution-with-explanation",
                "content": "In this question the most important thing is getting the pattern correct. It is very easy to go down the wrong path and spend 10 minutes trying to figure out how to make a complicated algorithm work when a very easy one would suffice.\\n\\n> Thinking process\\n\\n1. First I looked at the problem and thought about how the printed pattern looked like it would be mapped out on a matrix. I wrote out the number of \"main\" columns and then the number of \"middle\" columns\\n    ```\\n    P           I         N\\n    A      L    S     I   G\\n    Y    A      H    R\\n    P           I\\n    ------------------------\\n    4     2     4     2   2(*)\\n    ``` \\n    The last line is 2 only because the word ends, but we can see that the pattern is `4-2-4-2-4-...`. When drawing it out for `numRows = 3`, the pattern became \\n\\n     ```\\n    P         A         H         N\\n    A    P    L    S    I    I    G\\n    Y         I         R\\n    ---------------------------------\\n    3    1    3    1    3    1    2(*)\\n    ``` \\n    Again we can see the pattern is `3-1-3-1-3-...`\\n\\n    So the pattern of \"main\" rows to \"mid\" rows is `n, n-2, n, n-2, ...`\\n\\n    When I tried to build an algorithm for this pattern I got stuck. How would I make the index move up `n`, then down `n-2` without confusing myself or missing edge cases?\\n2. Next I tried to write out the row of each letter in the string. For numRows = 4, it became:\\n   ```\\n   P  A  Y  P  A  L  I  S  H  I  R  I  N  G\\n   -----------------------------------------\\n   1  2  3  4  3  2  1  2  3  4  3  2  1  2\\n   ```\\n   For numRows = 3, it became:\\n    ```\\n   P  A  Y  P  A  L  I  S  H  I  R  I  N  G\\n   -----------------------------------------\\n   1  2  3  2  1  2  3  2  1  2  3  2  1  2\\n   ```\\n\\n   This is where I found the correct pattern. Basically instead of worrying about \"main\" rows vs. \"mid\" rows, it easily maps into moving the index from 1 -> numRows, and then from numRows -> 1. We don\\'t even need to think about a matrix and worrying about rows vs. columns.\\n\\n> Algorithm\\n\\nAt first I thought about how to make the different rows as strings. How would I make `row1`, `row2`, `row3`? Sure if there were only a few rows I could hardcode them, but then how would I be able to add the character to each row easily? It is too difficult, so I thought using an array would be much better. \\n\\nThen I thought how would we make sure that we are going up and down in the correct pattern? The easiest way was to use a `going_up` flag to make sure to switch the direction of the index.\\n\\nLastly the only thing to check was edge cases, which by this point was pretty easy with a simple run through of the algorithm.\\n\\n> Code:\\n\\n```py\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1:\\n            return s\\n            \\n        row_arr = [\"\"] * numRows\\n        row_idx = 1\\n        going_up = True\\n\\n        for ch in s:\\n            row_arr[row_idx-1] += ch\\n            if row_idx == numRows:\\n                going_up = False\\n            elif row_idx == 1:\\n                going_up = True\\n            \\n            if going_up:\\n                row_idx += 1\\n            else:\\n                row_idx -= 1\\n        \\n        return \"\".join(row_arr)\\n```\\n\\n> Time & Space Complexity\\n\\nTime: `O(n)`\\n- We run through the whole string once: `O(n)`\\n  - everything we do inside the for loop: `O(1)`\\n- Finally we join the whole array int a string: `O(n)`\\n\\nSpace: `O(n)`\\n- We are creating a new array: `O(n)`\\n- We are using join to put it back into a string: `O(n)`",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    P           I         N\\n    A      L    S     I   G\\n    Y    A      H    R\\n    P           I\\n    ------------------------\\n    4     2     4     2   2(*)\\n    ```\n```\\n    P         A         H         N\\n    A    P    L    S    I    I    G\\n    Y         I         R\\n    ---------------------------------\\n    3    1    3    1    3    1    2(*)\\n    ```\n```\\n   P  A  Y  P  A  L  I  S  H  I  R  I  N  G\\n   -----------------------------------------\\n   1  2  3  4  3  2  1  2  3  4  3  2  1  2\\n   ```\n```\\n   P  A  Y  P  A  L  I  S  H  I  R  I  N  G\\n   -----------------------------------------\\n   1  2  3  2  1  2  3  2  1  2  3  2  1  2\\n   ```\n```py\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1:\\n            return s\\n            \\n        row_arr = [\"\"] * numRows\\n        row_idx = 1\\n        going_up = True\\n\\n        for ch in s:\\n            row_arr[row_idx-1] += ch\\n            if row_idx == numRows:\\n                going_up = False\\n            elif row_idx == 1:\\n                going_up = True\\n            \\n            if going_up:\\n                row_idx += 1\\n            else:\\n                row_idx -= 1\\n        \\n        return \"\".join(row_arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453,
                "title": "java-solution-easy-and-clear-interesting-approach",
                "content": "    public class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows<=1)return s;\\n        StringBuilder[] sb=new StringBuilder[numRows];\\n        for(int i=0;i<sb.length;i++){\\n            sb[i]=new StringBuilder(\"\");   //init every sb element **important step!!!!\\n        }\\n        int incre=1;\\n        int index=0;\\n        for(int i=0;i<s.length();i++){\\n            sb[index].append(s.charAt(i));\\n            if(index==0){incre=1;}\\n            if(index==numRows-1){incre=-1;}\\n            index+=incre;\\n        }\\n        String re=\"\";\\n        for(int i=0;i<sb.length;i++){\\n            re+=sb[i];\\n        }\\n        return re.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows<=1)return s;\\n        StringBuilder[] sb=new StringBuilder[numRows];\\n        for(int i=0;i<sb.length;i++){\\n            sb[i]=new StringBuilder(\"\");   //init every sb element **important step!!!!\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3417,
                "title": "a-10-lines-one-pass-o-n-time-o-1-space-accepted-solution-with-detailed-explantation",
                "content": " The distribution of the elements is period. \\n\\n    P   A   H   N\\n    A P L S I I G\\n    Y   I   R\\nFor example, the following has 4 periods(cycles):\\n\\n    P   | A   | H   | N\\n    A P | L S | I I | G\\n    Y   | I   | R   |\\n\\nThe size of every period is defined as \"cycle\"\\n\\n    cycle = (2*nRows - 2), except nRows == 1.\\n\\nIn this example,  (2*nRows - 2) = 4. \\n\\nIn every period, every row has 2 elements, except the first row and the last row.\\n\\nSuppose the current row is i, the index of the first element is j:\\n\\n    j = i + cycle*k, k = 0, 1, 2, ...\\n\\nThe index of the second element is secondJ:\\n\\n    secondJ = (j - i) + cycle - i\\n\\n (j-i) is the start of current period, (j-i) + cycle is the start of next period.\\n\\n\\n    string convert(string s, int nRows) {\\n            if(nRows <= 1) return s;\\n            string result = \"\";\\n            //the size of a cycle(period)\\n            int cycle = 2 * nRows - 2;\\n            for(int i = 0; i < nRows; ++i)\\n            {\\n                for(int j = i; j < s.length(); j = j + cycle){\\n                   result = result + s[j];\\n                   int secondJ = (j - i) + cycle - i;\\n                   if(i != 0 && i != nRows-1 && secondJ < s.length())\\n                       result = result + s[secondJ];\\n                }\\n            }\\n            return result;\\n        }",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": " The distribution of the elements is period. \\n\\n    P   A   H   N\\n    A P L S I I G\\n    Y   I   R\\nFor example, the following has 4 periods(cycles):\\n\\n    P   | A   | H   | N\\n    A P | L S | I I | G\\n    Y   | I   | R   |\\n\\nThe size of every period is defined as \"cycle\"\\n\\n    cycle = (2*nRows - 2), except nRows == 1.\\n\\nIn this example,  (2*nRows - 2) = 4. \\n\\nIn every period, every row has 2 elements, except the first row and the last row.\\n\\nSuppose the current row is i, the index of the first element is j:\\n\\n    j = i + cycle*k, k = 0, 1, 2, ...\\n\\nThe index of the second element is secondJ:\\n\\n    secondJ = (j - i) + cycle - i\\n\\n (j-i) is the start of current period, (j-i) + cycle is the start of next period.\\n\\n\\n    string convert(string s, int nRows) {\\n            if(nRows <= 1) return s;\\n            string result = \"\";\\n            //the size of a cycle(period)\\n            int cycle = 2 * nRows - 2;\\n            for(int i = 0; i < nRows; ++i)\\n            {\\n                for(int j = i; j < s.length(); j = j + cycle){\\n                   result = result + s[j];\\n                   int secondJ = (j - i) + cycle - i;\\n                   if(i != 0 && i != nRows-1 && secondJ < s.length())\\n                       result = result + s[secondJ];\\n                }\\n            }\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3133966,
                "title": "easy-explanation-with-pics-and-video-java-c-python",
                "content": "![image](https://assets.leetcode.com/users/images/fdf22375-8354-4cb7-adb0-cef316e39a2d_1675385332.2793877.png)\\n\\n\\nThings become clear with the above image.\\n\\n# Intuition:\\n1. Just look at the top row what is the difference b/w each char i.e A and I and I and Q = 8\\n            5*2-2 == numberOf rows *2 - 2 (The corner elements are excluded).\\nSimilarly for each row i.e B and J the diff is 8, C and K is 8\\n2. The interesting part comes when the char in the diagnoal has to be added, but even this has a pattern\\n\\t\\n\\tThere will be no char in between for row 0 and row n.\\n\\tThere can be only one diagonal char and the diagonal diff is original diff -2 at each step or diff - (rowNumber*2);\\n\\n# Approach\\n\\n1. Create an empty StringBuilder which is our ans.\\n2.  Calculate the diff = numRows*2 -2;\\n3. Iterate over 0 to rowNumber in a for loop  \\nThe first char will be row number or i (append to String)\\n4. Write a while loop in the above for loop :\\n5. The first char will be row number or i (append to String)\\n6. Calculate the diagonalDiff if any and append to the String.\\n7. Increase the index by diff and return ans.\\n\\n\\nhttps://youtu.be/YwU8pENP-vw\\n# If you find this useful\\n![image](https://assets.leetcode.com/users/images/2ffb3a66-a5d4-4df4-b5d2-d87bb7059594_1675386290.4900236.jpeg)\\n\\n```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows == 1) {\\n            return s;\\n        }\\n        \\n        StringBuilder answer = new StringBuilder();\\n        int n = s.length();\\n        int diff = 2 * (numRows - 1);\\n        int diagonalDiff = diff;\\n        int secondIndex;\\n        int index;\\n        for (int i = 0; i < numRows; i++) {\\n            index = i;\\n\\n            while (index < n) {\\n                answer.append(s.charAt(index));\\n                if (i != 0 && i != numRows - 1) {\\n                    diagonalDiff = diff-2*i;\\n                    secondIndex = index + diagonalDiff;\\n                    \\n                    if (secondIndex < n) {\\n                        answer.append(s.charAt(secondIndex));\\n                    }\\n                }\\n                index += diff;\\n            }\\n        }\\n        \\n        return answer.toString();\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if (numRows == 1) {\\n            return s;\\n        }\\n        \\n        stringstream answer;\\n        int n = s.length();\\n        int diff = 2 * (numRows - 1);\\n        int diagonalDiff = diff;\\n        int secondIndex;\\n        int index;\\n        for (int i = 0; i < numRows; i++) {\\n            index = i;\\n\\n            while (index < n) {\\n                answer << s[index];\\n                if (i != 0 && i != numRows - 1) {\\n                    diagonalDiff = diff-2*i;\\n                    secondIndex = index + diagonalDiff;\\n                    \\n                    if (secondIndex < n) {\\n                        answer << s[secondIndex];\\n                    }\\n                }\\n                index += diff;\\n            }\\n        }\\n        \\n        return answer.str();\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1:\\n            return s\\n        answer = \\'\\'\\n        n = len(s)\\n        diff = 2 * (numRows - 1)\\n        diagonal_diff = diff\\n        second_index = 0\\n        index = 0\\n        for i in range(numRows):\\n            index = i\\n            while index < n:\\n                answer += s[index]\\n                if i != 0 and i != numRows - 1:\\n                    diagonal_diff = diff - 2 * i\\n                    second_index = index + diagonal_diff\\n                    if second_index < n:\\n                        answer += s[second_index]\\n                index += diff\\n        return answer\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows == 1) {\\n            return s;\\n        }\\n        \\n        StringBuilder answer = new StringBuilder();\\n        int n = s.length();\\n        int diff = 2 * (numRows - 1);\\n        int diagonalDiff = diff;\\n        int secondIndex;\\n        int index;\\n        for (int i = 0; i < numRows; i++) {\\n            index = i;\\n\\n            while (index < n) {\\n                answer.append(s.charAt(index));\\n                if (i != 0 && i != numRows - 1) {\\n                    diagonalDiff = diff-2*i;\\n                    secondIndex = index + diagonalDiff;\\n                    \\n                    if (secondIndex < n) {\\n                        answer.append(s.charAt(secondIndex));\\n                    }\\n                }\\n                index += diff;\\n            }\\n        }\\n        \\n        return answer.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if (numRows == 1) {\\n            return s;\\n        }\\n        \\n        stringstream answer;\\n        int n = s.length();\\n        int diff = 2 * (numRows - 1);\\n        int diagonalDiff = diff;\\n        int secondIndex;\\n        int index;\\n        for (int i = 0; i < numRows; i++) {\\n            index = i;\\n\\n            while (index < n) {\\n                answer << s[index];\\n                if (i != 0 && i != numRows - 1) {\\n                    diagonalDiff = diff-2*i;\\n                    secondIndex = index + diagonalDiff;\\n                    \\n                    if (secondIndex < n) {\\n                        answer << s[secondIndex];\\n                    }\\n                }\\n                index += diff;\\n            }\\n        }\\n        \\n        return answer.str();\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1:\\n            return s\\n        answer = \\'\\'\\n        n = len(s)\\n        diff = 2 * (numRows - 1)\\n        diagonal_diff = diff\\n        second_index = 0\\n        index = 0\\n        for i in range(numRows):\\n            index = i\\n            while index < n:\\n                answer += s[index]\\n                if i != 0 and i != numRows - 1:\\n                    diagonal_diff = diff - 2 * i\\n                    second_index = index + diagonal_diff\\n                    if second_index < n:\\n                        answer += s[second_index]\\n                index += diff\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628318,
                "title": "python-solution-template-method-with-explanation",
                "content": "```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        template = list(range(numRows)) + list(range(numRows - 2, 0, -1))\\n\\n        result = [\\'\\'] * numRows\\n        for i, char in enumerate(s):\\n            result[template[i % len(template)]] += char\\n        return \\'\\'.join(result)\\n```\\n![image](https://assets.leetcode.com/users/images/f9b864b4-59fe-452a-83cc-57ae58c1dc74_1664383447.7802014.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        template = list(range(numRows)) + list(range(numRows - 2, 0, -1))\\n\\n        result = [\\'\\'] * numRows\\n        for i, char in enumerate(s):\\n            result[template[i % len(template)]] += char\\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837185,
                "title": "100-solution-explained-with-visualization-to-the-code",
                "content": "[https://youtu.be/EWZWiG750FI]()",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "[https://youtu.be/EWZWiG750FI]()",
                "codeTag": "Unknown"
            },
            {
                "id": 920510,
                "title": "c-8ms-90-very-easy-for-understand-with-commentaries",
                "content": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans;\\n        vector <string> tmp(numRows);                                                         //create strings for each row\\n        int i=0, n=s.size();\\n        while(i<n){                                      \\n            for(int j=0;j<numRows && i<n; j++, i++) tmp[j] += s[i];               //add for our strings character when we move down\\n            for(int j=numRows - 2;j>0 && i<n; j--, i++) tmp[j] += s[i];            //add for our strings character when we move up exept first and last string\\n        }\\n        for(int j=0;j<numRows; j++) ans += tmp[j];                                       //combain together our strings\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans;\\n        vector <string> tmp(numRows);                                                         //create strings for each row\\n        int i=0, n=s.size();\\n        while(i<n){                                      \\n            for(int j=0;j<numRows && i<n; j++, i++) tmp[j] += s[i];               //add for our strings character when we move down\\n            for(int j=numRows - 2;j>0 && i<n; j--, i++) tmp[j] += s[i];            //add for our strings character when we move up exept first and last string\\n        }\\n        for(int j=0;j<numRows; j++) ans += tmp[j];                                       //combain together our strings\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 124059,
                "title": "thinking-process-java-python",
                "content": "> characters in s are put zigzag in order\\n> ->  characters in a row maintain their relative order in s\\n> -> for each character in s, we figure out its row number and append to corresponding row data structure\\n\\n\\n>We start at row 0, move down until we hit row numRows - 1\\n>the move up until we hit row 0.\\n> `diff` helps manage increment and decrement of `curRow`.\\n\\n****\\n> Java\\n```\\n    public String convert(String s, int numRows) {\\n        if (numRows <= 1) return s;\\n        \\n        // Each element in rows represent a row.\\n        StringBuilder[] rows = new StringBuilder[numRows];\\n        for (int i = 0; i < numRows; i++)\\n            rows[i] = new StringBuilder();\\n        \\n        int curRow = 0; // Current row number.\\n        int diff = 1; // 1 downwards, -1 upwards.\\n        \\n        for (char ch : s.toCharArray()) {\\n            rows[curRow].append(ch);\\n            // Opposite moving direction.\\n            if (curRow == numRows - 1 ) diff = -1;\\n            else if (curRow == 0) diff = 1;\\n        \\n            curRow += diff;\\n        }\\n        \\n        // Format result.\\n        StringBuilder result = new StringBuilder();\\n        for (StringBuilder row : rows) {\\n            result.append(row);\\n        } \\n        \\n        return result.toString();\\n    }\\n```\\n> Python\\n```\\n  def convert(self, s, numRows):\\n    if numRows == 1:\\n      return s\\n    \\n    curRow, step = 0, 1\\n    rows = [\\'\\'] * numRows\\n      \\n    for ch in s:\\n      rows[curRow] += ch\\n      if curRow == numRows - 1:\\n        step = -1\\n      elif curRow == 0:\\n        step = 1\\n      curRow += step\\n\\n    return \\'\\'.join(rows)\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public String convert(String s, int numRows) {\\n        if (numRows <= 1) return s;\\n        \\n        // Each element in rows represent a row.\\n        StringBuilder[] rows = new StringBuilder[numRows];\\n        for (int i = 0; i < numRows; i++)\\n            rows[i] = new StringBuilder();\\n        \\n        int curRow = 0; // Current row number.\\n        int diff = 1; // 1 downwards, -1 upwards.\\n        \\n        for (char ch : s.toCharArray()) {\\n            rows[curRow].append(ch);\\n            // Opposite moving direction.\\n            if (curRow == numRows - 1 ) diff = -1;\\n            else if (curRow == 0) diff = 1;\\n        \\n            curRow += diff;\\n        }\\n        \\n        // Format result.\\n        StringBuilder result = new StringBuilder();\\n        for (StringBuilder row : rows) {\\n            result.append(row);\\n        } \\n        \\n        return result.toString();\\n    }\\n```\n```\\n  def convert(self, s, numRows):\\n    if numRows == 1:\\n      return s\\n    \\n    curRow, step = 0, 1\\n    rows = [\\'\\'] * numRows\\n      \\n    for ch in s:\\n      rows[curRow] += ch\\n      if curRow == numRows - 1:\\n        step = -1\\n      elif curRow == 0:\\n        step = 1\\n      curRow += step\\n\\n    return \\'\\'.join(rows)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3980,
                "title": "c-code-the-problem-is-solved-very-easy",
                "content": "class Solution {\\npublic:\\n    string convert(string s, int nRows) {\\n        \\n\\n\\n        if(nRows==1)\\n            return s;\\n        \\n        int y=0;\\n        bool flag= true;\\n        string sArray[nRows];\\n        for(int i=0;i<nRows;i++)\\n            sArray[i]=\"\";\\n        \\n        for(int i=0;i<s.length();i++){\\n            \\n            sArray[y]+=s[i];\\n            \\n            if(y==0){\\n                flag=true;\\n            }\\n            if(y==nRows-1){\\n                flag=false;\\n            }\\n            \\n            if(flag==true){\\n                y++;\\n            }else{\\n                y--;\\n            }\\n            \\n\\n        }\\n\\n        string ret=\"\";\\n        \\n        for(int i=0;i<nRows;i++){\\n            ret+=sArray[i];\\n        }\\n        \\n        return ret;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string convert(string s, int nRows) {\\n        \\n\\n\\n        if(nRows==1)\\n            return s;\\n        \\n        int y=0;\\n        bool flag= true;\\n        string sArray[nRows];\\n        for(int i=0;i<nRows;i++)\\n            sArray[i]=\"\";\\n        \\n        for(int i=0;i<s.length();i++){\\n            \\n            sArray[y]+=s[i];\\n            \\n            if(y==0){\\n                flag=true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3522,
                "title": "intuitive-javascript-solution",
                "content": "\\nIt's easier to look at the problem with visualizations. What we need to do here is to break down the input string in zigzag fashion and recompose row by row. \\n- ```convert('ABCDEF', 2)``` returns ```'ACEBDF'```\\n```\\n    Row 1 ->  A   C   E\\n    Row 2 ->    B   D   F\\n```\\n- ```convert('ABCDEF', 3)``` returns ```'AEBDFC'```\\n```\\n    Row 1 ->  A       E\\n    Row 2 ->    B   D   F\\n    Row 3 ->      C\\n```\\n- ```convert('ABCDEF', 4)``` returns ```'ABFCED'```\\n```\\n    Row 1 ->  A\\n    Row 2 ->    B       F\\n    Row 3 ->      C   E\\n    Row 4 ->        D\\n```\\n```\\nvar convert = function(s, numRows) {\\n    // return original string if can't zigzag\\n    if (numRows === 1 || s.length < numRows) return s;\\n\\n    let rows = []\\n    let converted = '';\\n    let reverse = false;\\n    let count = 0\\n\\n    // prepare rows\\n    for (let i = 0; i < numRows; i++) rows[i] = [];\\n    // reverse the push flow when reaching turning points\\n    for (let i = 0; i < s.length; i++) {\\n        rows[count].push(s[i]);\\n        reverse ? count-- : count++;\\n        if (count === numRows - 1 || count === 0) reverse = !reverse;\\n    }\\n    // put together converted string\\n    return rows.reduce((converted, cur) => converted + cur.join(''), '');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```convert('ABCDEF', 2)```\n```'ACEBDF'```\n```\\n    Row 1 ->  A   C   E\\n    Row 2 ->    B   D   F\\n```\n```convert('ABCDEF', 3)```\n```'AEBDFC'```\n```\\n    Row 1 ->  A       E\\n    Row 2 ->    B   D   F\\n    Row 3 ->      C\\n```\n```convert('ABCDEF', 4)```\n```'ABFCED'```\n```\\n    Row 1 ->  A\\n    Row 2 ->    B       F\\n    Row 3 ->      C   E\\n    Row 4 ->        D\\n```\n```\\nvar convert = function(s, numRows) {\\n    // return original string if can't zigzag\\n    if (numRows === 1 || s.length < numRows) return s;\\n\\n    let rows = []\\n    let converted = '';\\n    let reverse = false;\\n    let count = 0\\n\\n    // prepare rows\\n    for (let i = 0; i < numRows; i++) rows[i] = [];\\n    // reverse the push flow when reaching turning points\\n    for (let i = 0; i < s.length; i++) {\\n        rows[count].push(s[i]);\\n        reverse ? count-- : count++;\\n        if (count === numRows - 1 || count === 0) reverse = !reverse;\\n    }\\n    // put together converted string\\n    return rows.reduce((converted, cur) => converted + cur.join(''), '');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1597244,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        guard s.count > 1 && numRows > 1 else { return s }\\n        \\n        var lines = [[Character]](repeating: [], count: numRows)\\n        var idx = 0\\n        var flag = false\\n        \\n        for ch in s {\\n            lines[idx].append(ch)\\n            idx += flag ? -1 : 1\\n            guard idx == -1 || idx == numRows else { continue }\\n            idx += flag ? 2 : -2\\n            flag.toggle()\\n        }\\n        return lines.map { String($0) }.joined()\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.convert(\"PAYPALISHIRING\", 3)\\n        XCTAssertEqual(value, \"PAHNAPLSIIGYIR\")\\n    }\\n    \\n    // P     I    N\\n    // A   L S  I G\\n    // Y A   H R\\n    // P     I\\n    func test1() {\\n        let value = solution.convert(\"PAYPALISHIRING\", 4)\\n        XCTAssertEqual(value, \"PINALSIGYAHRPI\")\\n    }\\n    \\n    func test2() {\\n        let value = solution.convert(\"A\", 1)\\n        XCTAssertEqual(value, \"A\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        guard s.count > 1 && numRows > 1 else { return s }\\n        \\n        var lines = [[Character]](repeating: [], count: numRows)\\n        var idx = 0\\n        var flag = false\\n        \\n        for ch in s {\\n            lines[idx].append(ch)\\n            idx += flag ? -1 : 1\\n            guard idx == -1 || idx == numRows else { continue }\\n            idx += flag ? 2 : -2\\n            flag.toggle()\\n        }\\n        return lines.map { String($0) }.joined()\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.convert(\"PAYPALISHIRING\", 3)\\n        XCTAssertEqual(value, \"PAHNAPLSIIGYIR\")\\n    }\\n    \\n    // P     I    N\\n    // A   L S  I G\\n    // Y A   H R\\n    // P     I\\n    func test1() {\\n        let value = solution.convert(\"PAYPALISHIRING\", 4)\\n        XCTAssertEqual(value, \"PINALSIGYAHRPI\")\\n    }\\n    \\n    func test2() {\\n        let value = solution.convert(\"A\", 1)\\n        XCTAssertEqual(value, \"A\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134126,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=4D_2z5oCqEc&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=3) if you are interested.\\n\\n**Python**\\n\\n```py\\n# simulate and add each character to the corresponding row\\n# go down -> reach bottom -> go up -> reach top -> go down ...\\nclass Solution:\\n    def convert(self, s: str, n: int) -> str:\\n        # edge case\\n        if n == 1: return s\\n        rows = [\\'\\' for _ in range(n)]\\n        # j is the index to track which rows a character should be added to\\n        # d is the direction: -1 means go up, 1 means go down\\n        j, d = 0, 1\\n        for i in range(len(s)):\\n            # add the current character to corresponding row\\n            rows[j] += s[i]\\n            # if it reaches to the last row, we need to go up\\n            if j == n - 1: d = -1\\n            # if it reaches to the first row, we need to go down\\n            elif j == 0: d = 1\\n            # move j pointer\\n            j += d;\\n        # rows would look like below in the first example\\n        # [\\'PAHN\\', \\'APLSIIG\\', \\'YIR\\']\\n        # we use join to build the final answer\\n        return \\'\\'.join(rows)\\n```\\n\\n**C++ (Modified from Dev_1)**\\n\\n```cpp\\n// simulate and add each character to the corresponding row\\n// go down -> reach bottom -> go up -> reach top -> go down ...\\nclass Solution {\\npublic:\\n    string convert(string s, int n) {\\n        // edge case\\n        if (n == 1) return s;\\n        vector<string> rows(n);\\n        // j is the index to track which rows a character should be added to\\n        // d is the direction: -1 means go up, 1 means go down\\n        int j = 0, d = 1;\\n        for (int i = 0; i < s.size(); i++) {\\n            // add the current character to corresponding row\\n            rows[j] += s[i];\\n            // if it reaches to the last row, we need to go up\\n            if(j == n - 1) d = -1;\\n            // if it reaches to the first row, we need to go down\\n            else if(j == 0) d = 1;\\n            // move j pointer\\n            j += d;\\n        }\\n        // rows would look like below in the first example\\n        // [\\'PAHN\\', \\'APLSIIG\\', \\'YIR\\']\\n        // we use `accumulate` to build the final answer (in C++ 20, it takes O(n) only)\\n        return accumulate(rows.begin(), rows.end(), string{});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```py\\n# simulate and add each character to the corresponding row\\n# go down -> reach bottom -> go up -> reach top -> go down ...\\nclass Solution:\\n    def convert(self, s: str, n: int) -> str:\\n        # edge case\\n        if n == 1: return s\\n        rows = [\\'\\' for _ in range(n)]\\n        # j is the index to track which rows a character should be added to\\n        # d is the direction: -1 means go up, 1 means go down\\n        j, d = 0, 1\\n        for i in range(len(s)):\\n            # add the current character to corresponding row\\n            rows[j] += s[i]\\n            # if it reaches to the last row, we need to go up\\n            if j == n - 1: d = -1\\n            # if it reaches to the first row, we need to go down\\n            elif j == 0: d = 1\\n            # move j pointer\\n            j += d;\\n        # rows would look like below in the first example\\n        # [\\'PAHN\\', \\'APLSIIG\\', \\'YIR\\']\\n        # we use join to build the final answer\\n        return \\'\\'.join(rows)\\n```\n```cpp\\n// simulate and add each character to the corresponding row\\n// go down -> reach bottom -> go up -> reach top -> go down ...\\nclass Solution {\\npublic:\\n    string convert(string s, int n) {\\n        // edge case\\n        if (n == 1) return s;\\n        vector<string> rows(n);\\n        // j is the index to track which rows a character should be added to\\n        // d is the direction: -1 means go up, 1 means go down\\n        int j = 0, d = 1;\\n        for (int i = 0; i < s.size(); i++) {\\n            // add the current character to corresponding row\\n            rows[j] += s[i];\\n            // if it reaches to the last row, we need to go up\\n            if(j == n - 1) d = -1;\\n            // if it reaches to the first row, we need to go down\\n            else if(j == 0) d = 1;\\n            // move j pointer\\n            j += d;\\n        }\\n        // rows would look like below in the first example\\n        // [\\'PAHN\\', \\'APLSIIG\\', \\'YIR\\']\\n        // we use `accumulate` to build the final answer (in C++ 20, it takes O(n) only)\\n        return accumulate(rows.begin(), rows.end(), string{});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333761,
                "title": "rust-0ms-4ms",
                "content": "![image](https://assets.leetcode.com/users/obliquemotion/image_1563649130.png)\\n\\n\\n```rust\\nimpl Solution {\\n    pub fn convert(s: String, num_rows: i32) -> String {\\n        let mut zigzags: Vec<_> = (0..num_rows)\\n            .chain((1..num_rows-1).rev())\\n            .cycle()\\n            .zip(s.chars())\\n            .collect();\\n        zigzags.sort_by_key(|&(row, _)| row);\\n        zigzags.into_iter()\\n            .map(|(_, c)| c)\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn convert(s: String, num_rows: i32) -> String {\\n        let mut zigzags: Vec<_> = (0..num_rows)\\n            .chain((1..num_rows-1).rev())\\n            .cycle()\\n            .zip(s.chars())\\n            .collect();\\n        zigzags.sort_by_key(|&(row, _)| row);\\n        zigzags.into_iter()\\n            .map(|(_, c)| c)\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819,
                "title": "two-ways-of-o-n-solutions-one-follows-the-order-of-input-string-and-other-follows-the-order-of-output-string",
                "content": "Both the algorithms are of O(n) time complexity as every character in the input string is **traversed only once**.\\nIn the first version of algorithm, the output string's string buffer get populated based on the output string order i.e, **string builder gets populated incrementally from 0 to size-1**.\\n\\n    0             6            12             18\\n\\n    1       5     7      11    13       17    19\\n \\n    2    4        8  10        14  16         20\\n\\n    3             9            15             21 \\n\\n\\nIn the above sample case the number of rows is 4, when the first iteration is completed the locations **0,1,2,3 of the string builder gets filled with the locations 0,6,12,18 of the input string** it goes on further for other three rows.\\n\\n    public class Solution {\\n        public String convert(String s, int nRows) {\\n            if (nRows == 1)\\n                return s;\\n            StringBuilder strBuilder = new StringBuilder();\\n            int borderRowStep = 2 * nRows - 2;\\n            for (int i = 0; i < nRows; i++) {\\n                if (i == 0 || i == nRows - 1) {\\n                    for (int j = i; j < s.length(); j = j + borderRowStep) {\\n                        strBuilder.append(s.charAt(j));\\n                    }\\n                } else {\\n                    int j = i;\\n                    boolean flag = true;\\n                    int insideRowLargeStep = 2 * (nRows - 1 - i);\\n                    int insideRowSmallStep = borderRowStep - insideRowLargeStep;\\n                    while (j < s.length()) {\\n                       strBuilder.append(s.charAt(j));\\n                        if (flag)\\n                            j = j + insideRowLargeStep;\\n                        else\\n                            j = j + insideRowSmallStep;\\n                        flag = !flag;\\n                    }\\n                }\\n            }\\n            return strBuilder.toString();\\n        \\n    }\\n    }\\n\\nIn the second version of algorithm string buffer is filled in the order of input string  i.e, the **string buffer gets filled in the zig zag order**, when the first iteration of the outer while loop completes the locations **0,5,11,17 in string builder gets filled with the locations 0,1,2,3, from the input string**\\n\\n    class Solution{\\n    public String convert(String s, int nRows) {\\n        char[] c = s.toCharArray();\\n        int len = c.length;\\n        StringBuffer[] sb = new StringBuffer[nRows];\\n        for (int z=0; z < sb.length; z++) sb[z] = new StringBuffer();\\n        int k=0;\\n        while (k < len) {\\n            for (int zigZagIndex = 0; zigZagIndex < nRows && k < len; zigZagIndex++) // vertically down\\n                sb[zigZagIndex].append(c[k++]);\\n            for (int zigZagIndex = nRows-2; zigZagIndex >= 1 && k < len; zigZagIndex--) // obliquely up\\n                sb[zigZagIndex].append(c[k++]);\\n        }\\n        for (int index = 1; index < sb.length; index++)\\n            sb[0].append(sb[index]);\\n        return sb[0].toString();\\n    }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String convert(String s, int nRows) {\\n            if (nRows == 1)\\n                return s;\\n            StringBuilder strBuilder = new StringBuilder();\\n            int borderRowStep = 2 * nRows - 2;\\n            for (int i = 0; i < nRows; i++) {\\n                if (i == 0 || i == nRows - 1) {\\n                    for (int j = i; j < s.length(); j = j + borderRowStep) {\\n                        strBuilder.append(s.charAt(j));\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 791453,
                "title": "90-faster-and-90-less-space-explanation",
                "content": "The idea is to go up and down the zigzag\\n\\n```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows < 2:\\n            return s\\n        i = 0\\n        res = [\"\"]*numRows      # We will fill in each line in the zigzag\\n        for letter in s:\\n            if i == numRows-1:  # If this is the last line in the zigzag we go up\\n                grow = False\\n            elif i == 0:        #Otherwise we go down\\n                grow = True \\n            res[i] += letter    #Add the letter to its row\\n            i = (i+1) if grow else i-1  # We increment (add 1) if grow is True, \\n\\t\\t\\t                            # and decrement otherwise\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n        return \"\".join(res)     # return the joined rows\\n```\\n\\nDo you like my solution?",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows < 2:\\n            return s\\n        i = 0\\n        res = [\"\"]*numRows      # We will fill in each line in the zigzag\\n        for letter in s:\\n            if i == numRows-1:  # If this is the last line in the zigzag we go up\\n                grow = False\\n            elif i == 0:        #Otherwise we go down\\n                grow = True \\n            res[i] += letter    #Add the letter to its row\\n            i = (i+1) if grow else i-1  # We increment (add 1) if grow is True, \\n\\t\\t\\t                            # and decrement otherwise\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n        return \"\".join(res)     # return the joined rows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830,
                "title": "what-does-zigzag-means",
                "content": "The case that provided is a special case which we can easily handle.\\n\\nWhen there are more than 3 rows, what does zigzag mean?\\n\\n    A        F\\n\\n    B  E   G\\n\\n    C       H\\n\\n    D       I",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 231612,
                "title": "java-solution-beats-94",
                "content": "The idea is simple:\\nI\\'ve calculated the formula that identifies the order of characters in zigzag.\\nHere is an example for numRows = 4 (just contiguous numbers instead letters):\\n![image](https://assets.leetcode.com/users/olsh/image_1549226655.png)\\n\\n1st row : 1,7,13  (or  1, 1+2*(4-1), 1+2*(4-1)+2*(4-1) = **1+k*2(n-1)**)\\n2nd row: 2,6,8,12,14 (or 2, 2+2*(4-2), 2+2*(4-2)+2*(2-1),2+2*(4-2)+2*(2-1)+2*(4-2), .... **2+2(n-2) + 2(2-1)**)\\n3th row:3,5,9,11,15 (or 3, 3+2(n-3), 3+2(n-3)+2*(3-1), ... **3+2(n-3) + 2(3-1)**)\\n4th row:4,10,16 (or 4, 4+2(4-1), 4+2(4-1)+2(4-1), ... **4+k*2(4-1)**)\\nSo general formula will look like this:\\n![image](https://assets.leetcode.com/users/olsh/image_1549228342.png)\\n\\nThe whole code snippet:\\n**ind** - means what character (at what position in input string) we append to builder at current iteration.\\n```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows==1)return s;\\n        StringBuilder builder = new StringBuilder();\\n        for (int i=1;i<=numRows;i++){\\n            int ind = i-1;\\n            boolean up = true;\\n            while (ind < s.length()){\\n                builder.append(s.charAt(ind));\\n                if (i==1){\\n                    ind += 2*(numRows-i);\\n                } else if (i==numRows){\\n                    ind += 2*(i-1);\\n                } else {\\n                    ind += up ? 2*(numRows-i) : 2*(i-1);\\n                    up=!up;\\n                }\\n            }\\n        }\\n        return builder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows==1)return s;\\n        StringBuilder builder = new StringBuilder();\\n        for (int i=1;i<=numRows;i++){\\n            int ind = i-1;\\n            boolean up = true;\\n            while (ind < s.length()){\\n                builder.append(s.charAt(ind));\\n                if (i==1){\\n                    ind += 2*(numRows-i);\\n                } else if (i==numRows){\\n                    ind += 2*(i-1);\\n                } else {\\n                    ind += up ? 2*(numRows-i) : 2*(i-1);\\n                    up=!up;\\n                }\\n            }\\n        }\\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744,
                "title": "a-simple-python-solution-97ms-8-lines",
                "content": "    def convert(self, s, nRows):\\n        if nRows==1:\\n            return s\\n        period= 2*(nRows -1)\\n        lines=[\"\" for i in range(nRows)]\\n        d={} # dict remainder:line\\n        for i in xrange(period):\\n            if i<nRows:\\n                d[i]=i\\n            else:\\n    \\t        d[i]=period-i\\n\\n        for i in xrange(len(s)):\\n            lines[ d[i%period] ] +=s[i]\\n    \\n        return \"\".join(lines)\\n\\nThe idea is to use the remainder (index%period) to determine which line the character at the given index will be. The period is calculated first based on nRows. A dictionary with remainder:line as key:value is then created (this can also be done with a list or a tuple). Once these are done, we simply go through s, assign each character to its new line, and then combine these lines to get the converted string.\\n\\nThe code can be further shortened to 8 lines by using dict comprehension:  \\n\\n       d={i:i if i<nRows else (period-i) for i in xrange(period)}\\n\\n<br>\\n\\n    def convert(self, s, nRows):\\n        if nRows==1:\\n            return s\\n        period= 2*(nRows -1)\\n        lines=[\"\" for i in range(nRows)]\\n        d={i:i if i<nRows else (period-i) for i in xrange(period)}\\n\\n        for i in xrange(len(s)):\\n            lines[ d[i%period] ] +=s[i]\\n    \\n        return \"\".join(lines)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def convert(self, s, nRows):\\n        if nRows==1:\\n            return s\\n        period= 2*(nRows -1)\\n        lines=[\"\" for i in range(nRows)]\\n        d={} # dict remainder:line\\n        for i in xrange(period):\\n            if i<nRows:\\n                d[i]=i\\n            else:\\n    \\t        d[i]=period-i\\n\\n        for i in xrange(len(s)):\\n            lines[ d[i%period] ] +=s[i]\\n    \\n        return \"\".join(lines)\\n\\nThe idea is to use the remainder (index%period) to determine which line the character at the given index will be. The period is calculated first based on nRows. A dictionary with remainder:line as key:value is then created (this can also be done with a list or a tuple). Once these are done, we simply go through s, assign each character to its new line, and then combine these lines to get the converted string.\\n\\nThe code can be further shortened to 8 lines by using dict comprehension:  \\n\\n       d={i:i if i<nRows else (period-i) for i in xrange(period)}\\n\\n<br>\\n\\n    def convert(self, s, nRows):\\n        if nRows==1:\\n            return s\\n        period= 2*(nRows -1)\\n        lines=[\"\" for i in range(nRows)]\\n        d={i:i if i<nRows else (period-i) for i in xrange(period)}\\n\\n        for i in xrange(len(s)):\\n            lines[ d[i%period] ] +=s[i]\\n    \\n        return \"\".join(lines)",
                "codeTag": "Python3"
            },
            {
                "id": 416860,
                "title": "6-5-line-javascript-solution",
                "content": "## Understand The Problem\\n\\nFirst we look at the example with 4 rows and notice the order in which the rows are populated, particularly the way it goes down and then up again.\\n\\n|              | c0       | c1  | c2  |\\n| -----------: | -------- | --- | --- |\\n| \\uD83D\\uDC49 **row 0** | **P** \\uD83D\\uDC48 |     |     |\\n|        row 1 |          |     |     |\\n|        row 2 |          |     |     |\\n|        row 3 |          |     |     |\\n\\nRows: `0`\\n\\n|              | c0       | c1  | c2  |\\n| -----------: | -------- | --- | --- |\\n|        row 0 | P        |     |     |\\n| \\uD83D\\uDC49 **row 1** | **A** \\uD83D\\uDC48 |     |     |\\n|        row 2 |          |     |     |\\n|        row 3 |          |     |     |\\n\\nRows: `0, 1`\\n\\n|              | c0       | c1  | c2  |\\n| -----------: | -------- | --- | --- |\\n|        row 0 | P        |     |     |\\n|        row 1 | A        |     |     |\\n| \\uD83D\\uDC49 **row 2** | **Y** \\uD83D\\uDC48 |     |     |\\n|        row 3 |          |     |     |\\n\\nRows: `0, 1, 2`\\n\\n|              | c0       | c1  | c2  |\\n| -----------: | -------- | --- | --- |\\n|        row 0 | P        |     |     |\\n|        row 1 | A        |     |     |\\n|        row 2 | Y        |     |     |\\n| \\uD83D\\uDC49 **row 3** | **P** \\uD83D\\uDC48 |     |     |\\n\\nRows: `0, 1, 2, 3`\\n\\n|              | c0  | c1       | c2  |\\n| -----------: | --- | -------- | --- |\\n|        row 0 | P   |          |     |\\n|        row 1 | A   |          |     |\\n| \\uD83D\\uDC49 **row 2** | Y   | **A** \\uD83D\\uDC48 |     |\\n|        row 3 | P   |          |     |\\n\\nRows: `0, 1, 2, 3, 2`\\n\\n|              | c0  | c1  | c2       |\\n| -----------: | --- | --- | -------- |\\n|        row 0 | P   |     |          |\\n| \\uD83D\\uDC49 **row 1** | A   |     | **L** \\uD83D\\uDC48 |\\n|        row 2 | Y   | A   |          |\\n|        row 3 | P   |     |          |\\n\\nRows: `0, 1, 2, 3, 2, 1`\\n\\nAnd then, if we kept going, we\\'d see that the sequence of rows repeats at this point.\\n\\n## Make a Plan\\n\\nLoop through the given string and store each letter in a separate sequece for each row, as determined by the zigzag sequence. Then combine those row sequences together into a new string.\\n\\n## Pseudocode It\\n\\n1. Make an array with the zigzag sequence\\n2. Make an array with as many strings as we need rows\\n3. Append the characters to the row strings in zigzag sequence\\n4. Join the row strings in the array together\\n\\n## Code It\\n\\nThe 4 lines of pseudocode we wrote above become 5 lines of actual code below, but it all still makes sense\\n\\n> Runtime: **88 ms**, faster than _98.05%_ of JavaScript online submissions\\n> Memory Usage: **48.4 MB**, less than _13.00%_ of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {number} numRows\\n * @return {string}\\n */\\nconst convert = (s, numRows) => {\\n  // 1. Make an array with the zigzag sequence\\n  const zigzag = [...new Array(numRows).keys()];\\n  zigzag.push(...zigzag.slice(1, -1).reverse());\\n  // 2. Make an array with as many strings as we need rows\\n  const rows = new Array(numRows).fill(\\'\\');\\n  // 3. Append the characters to the row strings in zigzag sequence\\n  [...s].forEach((c, i) => (rows[zigzag[i % zigzag.length]] += c));\\n  // 4. Join the row strings in the array together\\n  return rows.join(\\'\\');\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @param {number} numRows\\n * @return {string}\\n */\\nconst convert = (s, numRows) => {\\n  // 1. Make an array with the zigzag sequence\\n  const zigzag = [...new Array(numRows).keys()];\\n  zigzag.push(...zigzag.slice(1, -1).reverse());\\n  // 2. Make an array with as many strings as we need rows\\n  const rows = new Array(numRows).fill(\\'\\');\\n  // 3. Append the characters to the row strings in zigzag sequence\\n  [...s].forEach((c, i) => (rows[zigzag[i % zigzag.length]] += c));\\n  // 4. Join the row strings in the array together\\n  return rows.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332885,
                "title": "c-simple-and-clean-solution-10-short-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if (numRows == 1) return s;\\n        \\n        vector<string> v(min(numRows, int(s.size())), \"\");\\n        // direction -1 is down, 1 is up\\n        int direction = -1, idx = 0;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            v[idx] += s[i];\\n            idx += direction == -1 ? 1 : -1;\\n            if (idx == 0 || idx == numRows - 1) direction = -direction;\\n        }\\n        \\n        string res = \"\";\\n        for (auto a : v) res += a;\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if (numRows == 1) return s;\\n        \\n        vector<string> v(min(numRows, int(s.size())), \"\");\\n        // direction -1 is down, 1 is up\\n        int direction = -1, idx = 0;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            v[idx] += s[i];\\n            idx += direction == -1 ? 1 : -1;\\n            if (idx == 0 || idx == numRows - 1) direction = -direction;\\n        }\\n        \\n        string res = \"\";\\n        for (auto a : v) res += a;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707,
                "title": "8ms-c-solution-easy-to-understand",
                "content": "    char* convert(char* s, int numRows) {\\n    int n=strlen(s);\\n    char* a;\\n    int k=0;\\n    if(numRows==1 || n<=numRows)return s;\\n    for(int i=0;i<numRows;i++)\\n    {\\n        for(int j=i;j<n;j+=2*(numRows-1))\\n        {\\n            a[k++]=s[j];\\n            if(i!=0 && i!=numRows-1)\\n            {\\n              int t=j+2*(numRows-1)-2*i;\\n              if(t<n)\\n              a[k++]=s[t];\\n            }\\n        }\\n    }\\n    a[k]='\\\\0';\\n       return a;\\n}",
                "solutionTags": [],
                "code": "    char* convert(char* s, int numRows) {\\n    int n=strlen(s);\\n    char* a;\\n    int k=0;\\n    if(numRows==1 || n<=numRows)return s;\\n    for(int i=0;i<numRows;i++)\\n    {\\n        for(int j=i;j<n;j+=2*(numRows-1))\\n        {\\n            a[k++]=s[j];\\n            if(i!=0 && i!=numRows-1)\\n            {\\n              int t=j+2*(numRows-1)-2*i;\\n              if(t<n)\\n              a[k++]=s[t];\\n            }\\n        }\\n    }\\n    a[k]='\\\\0';\\n       return a;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3489525,
                "title": "c-java-python-javascript-easy-to-understand-solution-with-explanation",
                "content": "\\n# Intuition:\\nThe problem asks to convert a given string into a zigzag pattern with a given number of rows, and then read the converted string row by row. One way to approach the problem is to simulate the process of converting the given string into the zigzag pattern by iterating over the string and filling each row in the pattern.\\n\\n# Approach:\\nWe can use two nested loops, one for iterating over the rows, and one for iterating over the characters in each row. We can also use a variable to keep track of the length of each cycle, which is 2 * numRows - 2 in this case. In each iteration, we can add the character to the corresponding row in the pattern, and also add the corresponding character in the next cycle if it exists.\\n\\n- For each row, we need to skip characters for the first and last row, as there is no corresponding character in the next cycle.\\n- For the rows in between, we need to add the corresponding character in the next cycle.\\n- We can use a string variable to store the converted string, and return it at the end.\\n# Complexity:\\n\\n- Time Complexity: O(n), where n is the length of the input string. We iterate over each character in the string once.\\n- Space Complexity: O(n), where n is the length of the input string. We use a string variable to store the converted string, which takes O(n) space.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n   string convert(string s, int numRows) {\\n        if (numRows == 1) {\\n            return s;\\n        }\\n        string result;\\n        int n = s.length();\\n        int cycleLen = 2 * numRows - 2;\\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = 0; j + i < n; j += cycleLen) {\\n                result += s[j + i];\\n                if (i != 0 && i != numRows - 1 && j + cycleLen - i < n) {\\n                    result += s[j + cycleLen - i];\\n                }\\n            }\\n        }\\n        return result;\\n    }       \\n};\\n```\\n\\n---\\n# Java\\n```\\npublic class Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows == 1) {\\n            return s;\\n        }\\n        StringBuilder result = new StringBuilder();\\n        int n = s.length();\\n        int cycleLen = 2 * numRows - 2;\\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = 0; j + i < n; j += cycleLen) {\\n                result.append(s.charAt(j + i));\\n                if (i != 0 && i != numRows - 1 && j + cycleLen - i < n) {\\n                    result.append(s.charAt(j + cycleLen - i));\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        if numRows == 1:\\n            return s\\n        result = \\'\\'\\n        n = len(s)\\n        cycleLen = 2 * numRows - 2\\n        for i in range(numRows):\\n            for j in range(0, n - i, cycleLen):\\n                result += s[j + i]\\n                if i != 0 and i != numRows - 1 and j + cycleLen - i < n:\\n                    result += s[j + cycleLen - i]\\n        return result\\n\\n```\\n---\\n# JavaScript\\n```\\nvar convert = function(s, numRows) {\\n    if (numRows === 1) {\\n        return s;\\n    }\\n    let result = \\'\\';\\n    const n = s.length;\\n    const cycleLen = 2 * numRows - 2;\\n    for (let i = 0; i < numRows; i++) {\\n        for (let j = 0; j + i < n; j += cycleLen) {\\n            result += s[j + i];\\n            if (i !== 0 && i !== numRows - 1 && j + cycleLen - i < n) {\\n                result += s[j + cycleLen - i];\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string convert(string s, int numRows) {\\n        if (numRows == 1) {\\n            return s;\\n        }\\n        string result;\\n        int n = s.length();\\n        int cycleLen = 2 * numRows - 2;\\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = 0; j + i < n; j += cycleLen) {\\n                result += s[j + i];\\n                if (i != 0 && i != numRows - 1 && j + cycleLen - i < n) {\\n                    result += s[j + cycleLen - i];\\n                }\\n            }\\n        }\\n        return result;\\n    }       \\n};\\n```\n```\\npublic class Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows == 1) {\\n            return s;\\n        }\\n        StringBuilder result = new StringBuilder();\\n        int n = s.length();\\n        int cycleLen = 2 * numRows - 2;\\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = 0; j + i < n; j += cycleLen) {\\n                result.append(s.charAt(j + i));\\n                if (i != 0 && i != numRows - 1 && j + cycleLen - i < n) {\\n                    result.append(s.charAt(j + cycleLen - i));\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        if numRows == 1:\\n            return s\\n        result = \\'\\'\\n        n = len(s)\\n        cycleLen = 2 * numRows - 2\\n        for i in range(numRows):\\n            for j in range(0, n - i, cycleLen):\\n                result += s[j + i]\\n                if i != 0 and i != numRows - 1 and j + cycleLen - i < n:\\n                    result += s[j + cycleLen - i]\\n        return result\\n\\n```\n```\\nvar convert = function(s, numRows) {\\n    if (numRows === 1) {\\n        return s;\\n    }\\n    let result = \\'\\';\\n    const n = s.length;\\n    const cycleLen = 2 * numRows - 2;\\n    for (let i = 0; i < numRows; i++) {\\n        for (let j = 0; j + i < n; j += cycleLen) {\\n            result += s[j + i];\\n            if (i !== 0 && i !== numRows - 1 && j + cycleLen - i < n) {\\n                result += s[j + cycleLen - i];\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135411,
                "title": "c-easy-explanation-in-hindi",
                "content": "[https://youtu.be/EhhKnzTRDoI](Watch)\\n**Watch this video for the better explanation of the code.**\\n\\n\\nAlso you can **SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81** this channel for the daily leetcode challange solution.\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\nIf you find my solution helpful please upvote it.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows<2) return s;\\n       int t[numRows][s.size()];\\n       memset(t,-1, sizeof(t));\\n        string ans;\\n\\n        for(int i=0, changer=1, row=0; i<s.size(); i++){\\n            \\n            t[row][i]= s[i];\\n            if(row==numRows-1) changer =-1;\\n            if(row==0) changer=1;\\n            row= row+ changer;\\n\\n        }\\n\\n       for(int i=0; i<numRows; i++){\\n           for(int j=0; j<s.size();j++){\\n               if(t[i][j]!=-1)ans.push_back(t[i][j]);\\n           }\\n       }\\n\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows<2) return s;\\n       int t[numRows][s.size()];\\n       memset(t,-1, sizeof(t));\\n        string ans;\\n\\n        for(int i=0, changer=1, row=0; i<s.size(); i++){\\n            \\n            t[row][i]= s[i];\\n            if(row==numRows-1) changer =-1;\\n            if(row==0) changer=1;\\n            row= row+ changer;\\n\\n        }\\n\\n       for(int i=0; i<numRows; i++){\\n           for(int j=0; j<s.size();j++){\\n               if(t[i][j]!=-1)ans.push_back(t[i][j]);\\n           }\\n       }\\n\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736,
                "title": "my-easy-read-python-solution",
                "content": "Consume the numRows is 5,we see the zigzag pattern like this:\\n\\n    0        8\\n    1     7  9\\n    2   6   10\\n    3 5     11\\n    4       12...\\n\\nwe can see the numbers 0~7 is a small pattern in here,if we divide 8 we can get same number in other small patterns.like \\n0%8 = 0; 8%8 = 0  \\n1%8 = 1; 9%8 = 1\\nso we can use this feature and filter them into rows we store.and this is my code:\\n\\n    class Solution(object):\\n        def convert(self, s, numRows):\\n            \"\"\"\\n            :type s: str\\n            :type numRows: int\\n            :rtype: str\\n            \"\"\"\\n            if numRows == 1: return s\\n            rows = [''] * numRows\\n            num = (numRows-1)*2\\n            for i, item in enumerate(s):\\n                if i % num >= numRows:\\n                    rows[(num - i % num) % numRows] += item\\n                else:\\n                    rows[i % num] += item\\n            return ''.join(rows)",
                "solutionTags": [],
                "code": "Consume the numRows is 5,we see the zigzag pattern like this:\\n\\n    0        8\\n    1     7  9\\n    2   6   10\\n    3 5     11\\n    4       12...\\n\\nwe can see the numbers 0~7 is a small pattern in here,if we divide 8 we can get same number in other small patterns.like \\n0%8 = 0; 8%8 = 0  \\n1%8 = 1; 9%8 = 1\\nso we can use this feature and filter them into rows we store.and this is my code:\\n\\n    class Solution(object):\\n        def convert(self, s, numRows):\\n            \"\"\"\\n            :type s: str\\n            :type numRows: int\\n            :rtype: str\\n            \"\"\"\\n            if numRows == 1: return s\\n            rows = [''] * numRows\\n            num = (numRows-1)*2\\n            for i, item in enumerate(s):\\n                if i % num >= numRows:\\n                    rows[(num - i % num) % numRows] += item\\n                else:\\n                    rows[i % num] += item\\n            return ''.join(rows)",
                "codeTag": "Java"
            },
            {
                "id": 2419775,
                "title": "python-c-java-simple-solution-beginner-level-solution-faster-than-100-memory-usage-less",
                "content": "*Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.*\\n________________________________________________________________________________________________________________________\\n________________________________________________________________________________________________________________________\\n\\n**Q6. The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)**\\n    \\n\\t\\n1.First I looked at the problem and thought about how the printed pattern looked like it would be mapped out on a matrix. I wrote out the number of \"main\" columns and then the number of \"middle\" columns.\\n```\\nP           I         N\\nA      L    S     I   G\\nY    A      H    R\\nP           I\\n------------------------\\n4     2     4     2   2(*)\\n```\\nThe last line is 2 only because the word ends, but we can see that the pattern is 4-2-4-2-4-.... When drawing it out for numRows = 3, the pattern became\\n\\n```\\nP         A         H         N\\nA    P    L    S    I    I    G\\nY         I         R\\n---------------------------------\\n3    1    3    1    3    1    2(*)\\n```\\nAgain we can see the pattern is 3-1-3-1-3-...\\n\\nSo the pattern of \"main\" rows to \"mid\" rows is n, n-2, n, n-2, ...\\n\\nWhen I tried to build an algorithm for this pattern I got stuck. How would I make the index move up n, then down n-2 without confusing myself or missing edge cases.\\n\\n**CODE:**\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Java Code** :\\n**Runtime:**  2 ms, faster than 100.00% of Java online submissions for Zigzag Conversion.\\n```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n    if(numRows==1) return s;\\n    int x = 2 * (numRows-1); \\n    int len = s.length();\\n    char[] c = new char[len];\\n    int k =0;\\n    for(int i=0; i < numRows; i++)\\n    {\\n        for(int j=i;j<len;j=j+x)\\n        {\\n            c[k++] = s.charAt(j);\\n            if(i>0 && i<numRows-1 && j+x-2*i < len)\\n            {\\n                   c[k++] = s.charAt(j+x-2*i); \\n            }\\n        }\\n    }\\n    return new String(c);\\n}\\n}\\n\\n```\\n**Runtime:**  2ms\\n**Memory Usage:**  42.4MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        curr=(2*numRows)-2\\n        res=\"\"\\n        for i in range(numRows):\\n            j=0\\n            while i+j<len(s):   \\n                res+=s[j+i]\\n                sec=(j-i)+curr\\n                if i!=0 and i!=numRows-1 and sec<len(s):\\n                    res+=s[sec]\\n                j+=curr\\n        return res\\n```\\n**Runtime:**  125 ms\\n**Memory Usage:**  14.2 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n\\n```\\nlass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string res = \"\";\\n        if(numRows == 1) return s;\\n        for(int i = 0; i < numRows; i++){\\n            bool step = true;\\n            for(int j = i; j < s.length();){\\n                res += s[j];\\n                if (i == 0 || i == numRows - 1){\\n                    j += 2*(numRows - 1);\\n                    continue;\\n                }\\n                j += step ? 2*(numRows - i - 1) : 2 * i; \\n                step = !step;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Runtime:**  12ms\\n**Memory Usage:**  8.3 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nP           I         N\\nA      L    S     I   G\\nY    A      H    R\\nP           I\\n------------------------\\n4     2     4     2   2(*)\\n```\n```\\nP         A         H         N\\nA    P    L    S    I    I    G\\nY         I         R\\n---------------------------------\\n3    1    3    1    3    1    2(*)\\n```\n```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n    if(numRows==1) return s;\\n    int x = 2 * (numRows-1); \\n    int len = s.length();\\n    char[] c = new char[len];\\n    int k =0;\\n    for(int i=0; i < numRows; i++)\\n    {\\n        for(int j=i;j<len;j=j+x)\\n        {\\n            c[k++] = s.charAt(j);\\n            if(i>0 && i<numRows-1 && j+x-2*i < len)\\n            {\\n                   c[k++] = s.charAt(j+x-2*i); \\n            }\\n        }\\n    }\\n    return new String(c);\\n}\\n}\\n\\n```\n```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        curr=(2*numRows)-2\\n        res=\"\"\\n        for i in range(numRows):\\n            j=0\\n            while i+j<len(s):   \\n                res+=s[j+i]\\n                sec=(j-i)+curr\\n                if i!=0 and i!=numRows-1 and sec<len(s):\\n                    res+=s[sec]\\n                j+=curr\\n        return res\\n```\n```\\nlass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string res = \"\";\\n        if(numRows == 1) return s;\\n        for(int i = 0; i < numRows; i++){\\n            bool step = true;\\n            for(int j = i; j < s.length();){\\n                res += s[j];\\n                if (i == 0 || i == numRows - 1){\\n                    j += 2*(numRows - 1);\\n                    continue;\\n                }\\n                j += step ? 2*(numRows - i - 1) : 2 * i; \\n                step = !step;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566,
                "title": "a-fast-javascript-implementation",
                "content": "``` javascript\\nvar convert = function(s, numRows) {\\n    var result = [];\\n    var step = 1, index = 0;\\n    for(var i = 0; i < s.length; i++){\\n        if(result[index] === undefined){//'undefined' will be put into string without this\\n            result[index] = '';\\n        }\\n        result[index] += s[i];\\n        if(index === 0){\\n            step = 1;\\n        }else if(index === numRows - 1){\\n            step = -1;\\n        }\\n        index += step;\\n    }\\n    return result.join('');\\n};",
                "solutionTags": [],
                "code": "``` javascript\\nvar convert = function(s, numRows) {\\n    var result = [];\\n    var step = 1, index = 0;\\n    for(var i = 0; i < s.length; i++){\\n        if(result[index] === undefined){//'undefined' will be put into string without this\\n            result[index] = '';\\n        }\\n        result[index] += s[i];\\n        if(index === 0){\\n            step = 1;\\n        }else if(index === numRows - 1){\\n            step = -1;\\n        }\\n        index += step;\\n    }\\n    return result.join('');\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3134883,
                "title": "python3-68ms",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/7355fe80-b411-48ef-8793-ad7991645e93_1675406149.6565611.png)\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!\\n# Code\\n```\\nclass Solution:\\n    def convert(self, s: str, n: int) -> str:\\n        if(n==1):\\n            return s\\n        ans=[\"\" for i in range(n)]\\n        x=0\\n        bl=True\\n        for i in range(len(s)):\\n            if(bl and x==n):\\n                bl=False\\n                x-=1\\n            if(not bl and x==0):\\n                x+=1\\n                bl=True\\n            if(bl):\\n                ans[x]+=s[i]\\n                x+=1\\n            else:\\n                x-=1\\n                ans[x]+=s[i]\\n        s=\"\"\\n        for i in ans:\\n            s+=i\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convert(self, s: str, n: int) -> str:\\n        if(n==1):\\n            return s\\n        ans=[\"\" for i in range(n)]\\n        x=0\\n        bl=True\\n        for i in range(len(s)):\\n            if(bl and x==n):\\n                bl=False\\n                x-=1\\n            if(not bl and x==0):\\n                x+=1\\n                bl=True\\n            if(bl):\\n                ans[x]+=s[i]\\n                x+=1\\n            else:\\n                x-=1\\n                ans[x]+=s[i]\\n        s=\"\"\\n        for i in ans:\\n            s+=i\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539220,
                "title": "java-tc-o-n-sc-o-n-optimized-row-by-row-solution",
                "content": "**Creating result string Row-by-Row**\\n```java\\n/**\\n * Visit Row by Row\\n *\\n * Time Complexity: O(2 * N) = O(N)\\n *\\n * Space Complexity: O(N)\\n *\\n * R = Number of rows. N = Length of input string\\n */\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (s == null || numRows <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = s.length();\\n        if (numRows == 1 || len <= numRows) {\\n            return s;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        int cycleLen = 2 * numRows - 2;\\n\\n        /**\\n         * First Row:   0,      2N-2,               4N-4,               ...\\n         * Last Row:    N-1,    2N-2+(N-1),         5N-5+(N-1),         ...\\n         * ith Row:     i,      2N-2-i, 2N-2+i,     4N-4-i, 4N-4+i,     ...\\n         */\\n\\n        for (int j = 0; j < numRows; j++) {\\n            for (int i = 0; i + j < len; i += cycleLen) {\\n                sb.append(s.charAt(i + j));\\n                if (j != 0 && j != numRows - 1 && i + cycleLen - j < len) {\\n                    sb.append(s.charAt(i + cycleLen - j));\\n                }\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n---\\n**Using string buffer for each row. Simulating ZigZag Traversal**\\n\\n```java\\n/**\\n * Using string buffer for each row. Simulating ZigZag Traversal\\n *\\n * Time Complexity: O(R + 3*N) = O(R+N)\\n *\\n * Space Complexity: O(R + N)\\n *\\n * R = Number of rows. N = Length of input string\\n */\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (s == null || numRows <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = s.length();\\n        if (numRows == 1 || len <= numRows) {\\n            return s;\\n        }\\n\\n        StringBuilder[] sbs = new StringBuilder[numRows];\\n        for (int j = 0; j < numRows; j++) {\\n            sbs[j] = new StringBuilder();\\n        }\\n\\n        int i = 0;\\n        while (i < len) {\\n            for (int j = 0; j < numRows && i < len; j++) {\\n                sbs[j].append(s.charAt(i++));\\n            }\\n            for (int j = numRows - 2; j >= 1 & i < len; j--) {\\n                sbs[j].append(s.charAt(i++));\\n            }\\n        }\\n\\n        for (int j = 1; j < numRows; j++) {\\n            sbs[0].append(sbs[j]);\\n        }\\n\\n        return sbs[0].toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```java\\n/**\\n * Visit Row by Row\\n *\\n * Time Complexity: O(2 * N) = O(N)\\n *\\n * Space Complexity: O(N)\\n *\\n * R = Number of rows. N = Length of input string\\n */\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (s == null || numRows <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = s.length();\\n        if (numRows == 1 || len <= numRows) {\\n            return s;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        int cycleLen = 2 * numRows - 2;\\n\\n        /**\\n         * First Row:   0,      2N-2,               4N-4,               ...\\n         * Last Row:    N-1,    2N-2+(N-1),         5N-5+(N-1),         ...\\n         * ith Row:     i,      2N-2-i, 2N-2+i,     4N-4-i, 4N-4+i,     ...\\n         */\\n\\n        for (int j = 0; j < numRows; j++) {\\n            for (int i = 0; i + j < len; i += cycleLen) {\\n                sb.append(s.charAt(i + j));\\n                if (j != 0 && j != numRows - 1 && i + cycleLen - j < len) {\\n                    sb.append(s.charAt(i + cycleLen - j));\\n                }\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```\n```java\\n/**\\n * Using string buffer for each row. Simulating ZigZag Traversal\\n *\\n * Time Complexity: O(R + 3*N) = O(R+N)\\n *\\n * Space Complexity: O(R + N)\\n *\\n * R = Number of rows. N = Length of input string\\n */\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (s == null || numRows <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = s.length();\\n        if (numRows == 1 || len <= numRows) {\\n            return s;\\n        }\\n\\n        StringBuilder[] sbs = new StringBuilder[numRows];\\n        for (int j = 0; j < numRows; j++) {\\n            sbs[j] = new StringBuilder();\\n        }\\n\\n        int i = 0;\\n        while (i < len) {\\n            for (int j = 0; j < numRows && i < len; j++) {\\n                sbs[j].append(s.charAt(i++));\\n            }\\n            for (int j = numRows - 2; j >= 1 & i < len; j--) {\\n                sbs[j].append(s.charAt(i++));\\n            }\\n        }\\n\\n        for (int j = 1; j < numRows; j++) {\\n            sbs[0].append(sbs[j]);\\n        }\\n\\n        return sbs[0].toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328613,
                "title": "c-solution-time-o-n",
                "content": "**The example can be written as follow:**\\n\\n**1.P.......A........H.......N\\n2..A..P....L..S....I...I....G\\n3....Y.........I........R**\\n\\nIterate through ss from left to right, appending each character to the appropriate row. The appropriate row can be tracked using two variables: the current row and the current direction.\\n\\nThe current direction changes only when we moved up to the topmost row or moved down to the bottommost row.\\n\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int row) {\\n        if(row==1){\\n            return s;\\n        }\\n        vector<string>nums(row);\\n        bool down= false;\\n        int j=0;\\n        for(int i=0;i<s.size();i++){\\n            nums[j].push_back(s[i]);\\n            if(j==row-1){\\n                down=false;\\n            }\\n            else if(j==0){\\n                down=true;\\n            }\\n            if(down==true){\\n                j++;\\n            }\\n            else j--;\\n        }\\n    string ans=\"\";\\n    for(auto i:nums){\\n        ans+=i;\\n    }\\n        return ans;\\n}\\n};\\n```\\nIf you like the solution upvote it and encourage me.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int row) {\\n        if(row==1){\\n            return s;\\n        }\\n        vector<string>nums(row);\\n        bool down= false;\\n        int j=0;\\n        for(int i=0;i<s.size();i++){\\n            nums[j].push_back(s[i]);\\n            if(j==row-1){\\n                down=false;\\n            }\\n            else if(j==0){\\n                down=true;\\n            }\\n            if(down==true){\\n                j++;\\n            }\\n            else j--;\\n        }\\n    string ans=\"\";\\n    for(auto i:nums){\\n        ans+=i;\\n    }\\n        return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557400,
                "title": "easy-solution-with-explanation-hand-written",
                "content": "**Explanation :**\\n* As you can see in this picture we have to convert given string into a ZigZag form with the given row.\\n* Starting index is always 0 so i have taken ```startIndex``` variable and initialize with zero.\\n* And Created  ```idx``` variable to get current index characher in ```ans``` string.\\n* As you can observe in the given row the next index is always comes at ```idx += row + (row - 2)``` , so i used this formula. when ```startIndex = 0 or startIndex = row - 1``` then we don\\'t need to take between character\\'s.\\n* and for when ```startIndex is between 1 and row-2``` we have to take between character\\'s.\\n* and you can observe there is a difference between middle character and next columns character is two and  it by two always by row wise. So i have taken ```count``` variable to count their difference.\\n* For the first time we have to always take columns characher an then middle character so for this condition i have used ```flag``` logic.\\n* if our curret index ie. ```idx``` is reached out off index then i just increased ```startIndex``` by 1 and ```idx = startIndex``` and also increase ```count``` variable by 2\\n\\n\\nI hope you understand my explanation.\\nIf any Doubts or Suggestions Put in Comments..\\n\\nPlease **UpVote**, if it helps a little to you **:)**\\n![image](https://assets.leetcode.com/users/images/ae428ffd-34ec-40b3-837a-b09c9aeb528a_1662804646.7966483.jpeg)\\n\\n**Solution :**\\n```\\n    def convert(self, s, row):\\n        n = len(s)\\n        if n <= row:   #this is base contions if row is greater than the length of string. so just return string\\n            return s\\n        ans, startIndex, idx, flag, count = \\'\\', 0, 0, 0, 2\\n        for i in range(n):\\n            if startIndex == 0 or startIndex == row-1:\\n                ans += s[idx]\\n                idx += row + (row - 2)\\n                if i == n-1: break\\n                if idx > n - 1 or idx <= 0:  #this another or condition is for when we have given two length string and row is 1 \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t#then for the second time that idx value goes to -ve that\\'s why it is written\\n                    startIndex += 1\\n                    idx = startIndex\\n            else:\\n                if flag == 0:\\n                    ans += s[idx]\\n                    flag = 1\\n                    idx += row + (row - 2) - count\\n                else:\\n                    ans += s[idx]\\n                    idx += count\\n                    flag = 0\\n                if idx > n-1 or idx <= 0:\\n                    startIndex += 1\\n                    idx, flag = startIndex, 0\\n                    count += 2\\n        return ans\\n```\\n**UpVote :)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```startIndex```\n```idx```\n```ans```\n```idx += row + (row - 2)```\n```startIndex = 0 or startIndex = row - 1```\n```startIndex is between 1 and row-2```\n```count```\n```flag```\n```idx```\n```startIndex```\n```idx = startIndex```\n```count```\n```\\n    def convert(self, s, row):\\n        n = len(s)\\n        if n <= row:   #this is base contions if row is greater than the length of string. so just return string\\n            return s\\n        ans, startIndex, idx, flag, count = \\'\\', 0, 0, 0, 2\\n        for i in range(n):\\n            if startIndex == 0 or startIndex == row-1:\\n                ans += s[idx]\\n                idx += row + (row - 2)\\n                if i == n-1: break\\n                if idx > n - 1 or idx <= 0:  #this another or condition is for when we have given two length string and row is 1 \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t#then for the second time that idx value goes to -ve that\\'s why it is written\\n                    startIndex += 1\\n                    idx = startIndex\\n            else:\\n                if flag == 0:\\n                    ans += s[idx]\\n                    flag = 1\\n                    idx += row + (row - 2) - count\\n                else:\\n                    ans += s[idx]\\n                    idx += count\\n                    flag = 0\\n                if idx > n-1 or idx <= 0:\\n                    startIndex += 1\\n                    idx, flag = startIndex, 0\\n                    count += 2\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1492755,
                "title": "c-easy-to-understand-with-explanation-clean-code",
                "content": "**Algorithm:**\\n\\n1) Create a vector of n strings, initialise all strings with \"\".\\n\\n2) Initialize direction as +1 (\"down\") and row as 0. The \\n   direction indicates whether we need to move up or \\n   down in rows. \\n   \\n3) Traverse the input string, do following for every\\n   character.\\n   \\n   a) Push current character to string of current row.\\n   b) If row number is n-1, then change direction to -1 (\\'up\\')\\n   c) If row number is 0, then change direction to +1 (\\'down\\')\\n   d) Update row by adding direction to it.\\n   \\n4. Create a string to store the final answer, initialise it with \"\", \\n\\ttraverse the vector of strings and concatenate all the strings. \\n\\n5. Return this concatenated string.\\n\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        \\n        vector <string> temp(numRows, \"\");\\n        int row = 0, direction = 1;\\n        string ans = \"\";\\n        \\n        if(numRows == 1)\\n            return s;\\n        \\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            temp[row] += s[i];\\n            \\n            if(row == numRows - 1)\\n                direction = -1;\\n            if(row == 0)\\n                direction = 1;\\n            \\n            row += direction;\\n            \\n        }     \\n        \\n        for(int i = 0; i < numRows; i++)\\n        {\\n            ans += temp[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        \\n        vector <string> temp(numRows, \"\");\\n        int row = 0, direction = 1;\\n        string ans = \"\";\\n        \\n        if(numRows == 1)\\n            return s;\\n        \\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            temp[row] += s[i];\\n            \\n            if(row == numRows - 1)\\n                direction = -1;\\n            if(row == 0)\\n                direction = 1;\\n            \\n            row += direction;\\n            \\n        }     \\n        \\n        for(int i = 0; i < numRows; i++)\\n        {\\n            ans += temp[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150628,
                "title": "11-line-easy-to-understand-c-solution-with-explanation",
                "content": "```C++\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows <= 1) return s;\\n        vector<string> db (numRows, \"\");\\n        for(int i = 0,row = 0,step = 1;i < s.size();i++){\\n            db[row] += s[i];\\n            if(row == 0) step = 1;\\n            if(row == numRows - 1) step = -1;\\n            row += step;\\n        }\\n        string ret;\\n        for(auto d:db) ret+=d;\\n        return ret;\\n    }\\n};\\n```\\nThe idea is taken from this [post](https://leetcode.com/problems/zigzag-conversion/discuss/3465/Share-simple-C++-solution).\\nWe re-construct the zigzag pattern into a string vector `db` by omitting all the spaces. For example,\\n```C++\\nP   A   H   N                                               db[0] PAHN\\nA P L S I I G   (omit all the spaces)---->                  db[1] APLSIIG\\nY   I   R                                                   db[2] YIG\\n```\\nThus, after converting the zigzag pattern into a simpler form, the only issue remainning is which row `s[i]` should lie in . We set `step` to do this.",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows <= 1) return s;\\n        vector<string> db (numRows, \"\");\\n        for(int i = 0,row = 0,step = 1;i < s.size();i++){\\n            db[row] += s[i];\\n            if(row == 0) step = 1;\\n            if(row == numRows - 1) step = -1;\\n            row += step;\\n        }\\n        string ret;\\n        for(auto d:db) ret+=d;\\n        return ret;\\n    }\\n};\\n```\n```C++\\nP   A   H   N                                               db[0] PAHN\\nA P L S I I G   (omit all the spaces)---->                  db[1] APLSIIG\\nY   I   R                                                   db[2] YIG\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869,
                "title": "12ms-c-solution-in-o-1-space-with-detailed-explanation",
                "content": "    class Solution {\\n    public:\\n        string convert(string s, int numRows) {\\n            string result = \"\";\\n            \\n            // simple cases that could be inferred easily\\n            if (s.size() <= numRows || numRows == 1) return s;\\n            \\n            // colIndex represents the \"straight column\" index (PAY or ALI in the example)\\n            int colIndex = 0;\\n            \\n            // append result row by row\\n            for (int i = 0; i < numRows; i++) {\\n                \\n                // for each row, the first character is in the ith position of s;\\n                result += s[i];\\n                \\n                // 2*numRows - 2 is the increment amount between two straight columns\\n                // i is the current location in this column\\n                // so colIndex is now the position of character of the same position in the next \"straight column\"\\n                colIndex = i + 2*numRows - 2;\\n                \\n                // 2*numRows - 2 - i is the position of the character in the \"tilted column\" (P or S or I in the example)\\n                // use colIndex - 2 * i (same value) because we need to increment this value every time\\n                // while there is still character in the \"tilted column\":\\n                while (colIndex - 2 * i < s.size()) {\\n                    \\n                    // if it is the first or the last row, tilted column overlaps the straight column, ignore!\\n                    if (i != 0 && i != numRows - 1) {\\n                        // first: append the character in the tilted column\\n                        result += s[colIndex - 2 * i];\\n                    }\\n                    \\n                    // second: append the character in the straight column in the same row only if this position exists\\n                    if (colIndex < s.size()) {\\n                        result += s[colIndex];\\n                    }\\n                    \\n                    // increment colIndex to the next column\\n                    colIndex += 2*numRows - 2;\\n                }\\n            }\\n            return result;\\n        }\\n     };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string convert(string s, int numRows) {\\n            string result = \"\";\\n            \\n            // simple cases that could be inferred easily\\n            if (s.size() <= numRows || numRows == 1) return s;\\n            \\n            // colIndex represents the \"straight column\" index (PAY or ALI in the example)\\n            int colIndex = 0;\\n            \\n            // append result row by row\\n            for (int i = 0; i < numRows; i++) {\\n                \\n                // for each row, the first character is in the ith position of s;\\n                result += s[i];\\n                \\n                // 2*numRows - 2 is the increment amount between two straight columns\\n                // i is the current location in this column\\n                // so colIndex is now the position of character of the same position in the next \"straight column\"\\n                colIndex = i + 2*numRows - 2;\\n                \\n                // 2*numRows - 2 - i is the position of the character in the \"tilted column\" (P or S or I in the example)\\n                // use colIndex - 2 * i (same value) because we need to increment this value every time\\n                // while there is still character in the \"tilted column\":\\n                while (colIndex - 2 * i < s.size()) {\\n                    \\n                    // if it is the first or the last row, tilted column overlaps the straight column, ignore!\\n                    if (i != 0 && i != numRows - 1) {\\n                        // first: append the character in the tilted column\\n                        result += s[colIndex - 2 * i];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3769,
                "title": "o-n-clean-java-solution-with-explaination",
                "content": "The solution computes the next element in each row one by one. Take 4 rows for example. In the first row, the gap between each \"column\" element is (4-1)*2 = 6. In the second row, there is another element between each pair of \"column\" elements and it separate the gap to two parts. A variable offset is used to track the position of the separator.  \\n\\nIn the second row, initially offset equals gap - row_index*2 = 6-1*2 = 4. The first element in the second row is s[1], the second one is s[1+offset] = s[5]. Then offset becomes gap-offset = 6-4 = 2. So the third element is s[5+offset] = s[7]. In fact, the offset for the next element is always equal to the gap - offset of the previous element.\\n\\nUsing the method we could get the elements of each row. Be careful that in the first and the last row, there is no element between the \"column\" elements so we need to avoid inserting duplicate elements (when offset is 0).\\n\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        int gap = (numRows-1)<<1;\\n        StringBuilder result = new StringBuilder();\\n        for(int i=0; i<numRows; i++) {\\n            int current = i;\\n            int offset = gap - (i<<1);\\n            while(current<s.length()) {\\n                if( offset != 0 ) { \\n                    // avoid inserting duplicate elements\\n                    // in the first and the last row\\n                    result.append(s.charAt(current));\\n\\n                    current += offset;\\n                }\\n                offset = gap-offset;\\n            }\\n        }\\n        \\n        return result.toString();\\n    }",
                "solutionTags": [],
                "code": "The solution computes the next element in each row one by one. Take 4 rows for example. In the first row, the gap between each \"column\" element is (4-1)*2 = 6. In the second row, there is another element between each pair of \"column\" elements and it separate the gap to two parts. A variable offset is used to track the position of the separator.  \\n\\nIn the second row, initially offset equals gap - row_index*2 = 6-1*2 = 4. The first element in the second row is s[1], the second one is s[1+offset] = s[5]. Then offset becomes gap-offset = 6-4 = 2. So the third element is s[5+offset] = s[7]. In fact, the offset for the next element is always equal to the gap - offset of the previous element.\\n\\nUsing the method we could get the elements of each row. Be careful that in the first and the last row, there is no element between the \"column\" elements so we need to avoid inserting duplicate elements (when offset is 0).\\n\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        int gap = (numRows-1)<<1;\\n        StringBuilder result = new StringBuilder();\\n        for(int i=0; i<numRows; i++) {\\n            int current = i;\\n            int offset = gap - (i<<1);\\n            while(current<s.length()) {\\n                if( offset != 0 ) { \\n                    // avoid inserting duplicate elements\\n                    // in the first and the last row\\n                    result.append(s.charAt(current));\\n\\n                    current += offset;\\n                }\\n                offset = gap-offset;\\n            }\\n        }\\n        \\n        return result.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 354390,
                "title": "python3-mod-to-calculate-the-pattern-with-explanation",
                "content": "```\\ns = \"PAYPALISHIRING\"\\nnumRow = 3\\n        \"\"\"\\n        p (0)      a(4)      h(8)         n(12)\\n        a (1) p(3) l(5) s(7) i(9) i(11)  g(13)\\n        y (2)      i(6)      r(10)\\n        \"\"\"\\n# There is a pattern consists 4 elements as below:\\n\\t\\t\"\"\"\\n        p (0)     \\n        a (1)  p(3) \\n        y (2)     \\n        \"\"\"\\n# The ith element can be mapping into this pattern by i%pattern_length:\\nThe first line: 0 % 4 = 4 % 4 = 8 % 4 = 12 % 4 =0\\n\"\"\"\\n p (0)      a(4)      h(8)         n(12)\\n\"\"\"\\nThe second line: there is 2 type pattern:\\na: 1 % 4 = 5 % 4 = 9 % 4 = 13 % 4 = 1\\nb: 3 % 4 = 7 % 4 = 11 % 4 = 3\\nSo here we need an extra mapping to deal with these 2 situations.\\n1 = 4 - 3 is key to combine these two situation into one.\\n d={i:i if i<numRows else (period-i) for i in range(period)}\\n\"\"\"\\na (1) p(3) l(5) s(7) i(9) i(11)  g(13)\\n\"\"\"\\nThe third line:\\n2 % 4 = 6 % 4 = 10  % 4 = 2\\n\"\"\"\\n y (2)      i(6)      r(10)\\n\"\"\"\\n```\\n\\n```\\nPeriod 4\\nd =  {0: 0, 1: 1, 2: 2, 3: 1}\\ni =  0   i%period =  0\\nlines: [\\'P\\', \\'\\', \\'\\']\\ni =  1   i%period =  1\\nlines: [\\'P\\', \\'A\\', \\'\\']\\ni =  2   i%period =  2\\nlines: [\\'P\\', \\'A\\', \\'Y\\']\\ni =  3   i%period =  3\\nlines: [\\'P\\', \\'AP\\', \\'Y\\']\\ni =  4   i%period =  0\\nlines: [\\'PA\\', \\'AP\\', \\'Y\\']\\ni =  5   i%period =  1\\nlines: [\\'PA\\', \\'APL\\', \\'Y\\']\\ni =  6   i%period =  2\\nlines: [\\'PA\\', \\'APL\\', \\'YI\\']\\ni =  7   i%period =  3\\nlines: [\\'PA\\', \\'APLS\\', \\'YI\\']\\ni =  8   i%period =  0\\nlines: [\\'PAH\\', \\'APLS\\', \\'YI\\']\\ni =  9   i%period =  1\\nlines: [\\'PAH\\', \\'APLSI\\', \\'YI\\']\\ni =  10   i%period =  2\\nlines: [\\'PAH\\', \\'APLSI\\', \\'YIR\\']\\ni =  11   i%period =  3\\nlines: [\\'PAH\\', \\'APLSII\\', \\'YIR\\']\\ni =  12   i%period =  0\\nlines: [\\'PAHN\\', \\'APLSII\\', \\'YIR\\']\\ni =  13   i%period =  1\\nlines: [\\'PAHN\\', \\'APLSIIG\\', \\'YIR\\']\\n```\\n\\n```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        \"\"\"\\n        p (0)      a(4)      h(9)         n(13)\\n        a (1) p(3) l(6) s(8) i(10) i(12)  g(14)\\n        y (2)      i(7)      r(11)\\n        \"\"\"\\n        if numRows==1:return s\\n        period= 2*(numRows -1)\\n        d={i:i if i<numRows else (period-i) for i in range(period)}\\n        lines=[\"\" for i in range(numRows)]\\n        for i in range(len(s)):\\n            lines[d[i%period]] +=s[i]\\n        return \"\".join(lines)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ns = \"PAYPALISHIRING\"\\nnumRow = 3\\n        \"\"\"\\n        p (0)      a(4)      h(8)         n(12)\\n        a (1) p(3) l(5) s(7) i(9) i(11)  g(13)\\n        y (2)      i(6)      r(10)\\n        \"\"\"\\n# There is a pattern consists 4 elements as below:\\n\\t\\t\"\"\"\\n        p (0)     \\n        a (1)  p(3) \\n        y (2)     \\n        \"\"\"\\n# The ith element can be mapping into this pattern by i%pattern_length:\\nThe first line: 0 % 4 = 4 % 4 = 8 % 4 = 12 % 4 =0\\n\"\"\"\\n p (0)      a(4)      h(8)         n(12)\\n\"\"\"\\nThe second line: there is 2 type pattern:\\na: 1 % 4 = 5 % 4 = 9 % 4 = 13 % 4 = 1\\nb: 3 % 4 = 7 % 4 = 11 % 4 = 3\\nSo here we need an extra mapping to deal with these 2 situations.\\n1 = 4 - 3 is key to combine these two situation into one.\\n d={i:i if i<numRows else (period-i) for i in range(period)}\\n\"\"\"\\na (1) p(3) l(5) s(7) i(9) i(11)  g(13)\\n\"\"\"\\nThe third line:\\n2 % 4 = 6 % 4 = 10  % 4 = 2\\n\"\"\"\\n y (2)      i(6)      r(10)\\n\"\"\"\\n```\n```\\nPeriod 4\\nd =  {0: 0, 1: 1, 2: 2, 3: 1}\\ni =  0   i%period =  0\\nlines: [\\'P\\', \\'\\', \\'\\']\\ni =  1   i%period =  1\\nlines: [\\'P\\', \\'A\\', \\'\\']\\ni =  2   i%period =  2\\nlines: [\\'P\\', \\'A\\', \\'Y\\']\\ni =  3   i%period =  3\\nlines: [\\'P\\', \\'AP\\', \\'Y\\']\\ni =  4   i%period =  0\\nlines: [\\'PA\\', \\'AP\\', \\'Y\\']\\ni =  5   i%period =  1\\nlines: [\\'PA\\', \\'APL\\', \\'Y\\']\\ni =  6   i%period =  2\\nlines: [\\'PA\\', \\'APL\\', \\'YI\\']\\ni =  7   i%period =  3\\nlines: [\\'PA\\', \\'APLS\\', \\'YI\\']\\ni =  8   i%period =  0\\nlines: [\\'PAH\\', \\'APLS\\', \\'YI\\']\\ni =  9   i%period =  1\\nlines: [\\'PAH\\', \\'APLSI\\', \\'YI\\']\\ni =  10   i%period =  2\\nlines: [\\'PAH\\', \\'APLSI\\', \\'YIR\\']\\ni =  11   i%period =  3\\nlines: [\\'PAH\\', \\'APLSII\\', \\'YIR\\']\\ni =  12   i%period =  0\\nlines: [\\'PAHN\\', \\'APLSII\\', \\'YIR\\']\\ni =  13   i%period =  1\\nlines: [\\'PAHN\\', \\'APLSIIG\\', \\'YIR\\']\\n```\n```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        \"\"\"\\n        p (0)      a(4)      h(9)         n(13)\\n        a (1) p(3) l(6) s(8) i(10) i(12)  g(14)\\n        y (2)      i(7)      r(11)\\n        \"\"\"\\n        if numRows==1:return s\\n        period= 2*(numRows -1)\\n        d={i:i if i<numRows else (period-i) for i in range(period)}\\n        lines=[\"\" for i in range(numRows)]\\n        for i in range(len(s)):\\n            lines[d[i%period]] +=s[i]\\n        return \"\".join(lines)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544,
                "title": "my-ez-understanding-c-solution",
                "content": "    string convert(string s, int numRows) \\n    {\\n        if(numRows==1)return s;\\n        string t;\\n        vector<string> vec(numRows,\"\");\\n        int i=0,j=0;\\n        while(i<s.length())\\n        {\\n            while(j<numRows-1&&i<s.length())\\n            {\\n                vec[j++] += s[i++];\\n            }\\n            while(j>0&&i<s.length())\\n            {\\n                vec[j--] += s[i++];\\n            }\\n        }\\n        for(auto i=vec.begin();i!=vec.end();i++)\\n        {\\n            t += *i;\\n        }\\n        return t;\\n    }",
                "solutionTags": [],
                "code": "    string convert(string s, int numRows) \\n    {\\n        if(numRows==1)return s;\\n        string t;\\n        vector<string> vec(numRows,\"\");\\n        int i=0,j=0;\\n        while(i<s.length())\\n        {\\n            while(j<numRows-1&&i<s.length())\\n            {\\n                vec[j++] += s[i++];\\n            }\\n            while(j>0&&i<s.length())\\n            {\\n                vec[j--] += s[i++];\\n            }\\n        }\\n        for(auto i=vec.begin();i!=vec.end();i++)\\n        {\\n            t += *i;\\n        }\\n        return t;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3134436,
                "title": "c-easy-solution-no-extra-space-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || No Extra Space Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFGCD Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/BynVKvLt/shared\" frameBorder=\"0\" width=\"800\" height=\"660\"></iframe>\\n\\n\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "## **\\u2705\\u2705C++ || No Extra Space Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFGCD Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/BynVKvLt/shared\" frameBorder=\"0\" width=\"800\" height=\"660\"></iframe>\\n\\n\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 473034,
                "title": "analytical-js-solution-peaks-at-68ms-99-85-and-38mb-94-4",
                "content": "Looking at the case of input\\n**String: \"PAYPALISHIRING\"**\\n**numRows: 4**\\n```\\n// P     I    N\\n// A   L S  I G\\n// Y A   H R\\n// P     I\\n```\\nObservation:\\n- Looking at just the first group (\"PIN\"), the difference in values between the letter index is 6.\\n- Looking at the second group (\"ALSIG\"), however, the difference is a pattern of 4, then 2 (a total of 6)\\n- The third (\"YAHR\") is the opposite pattern of 2, then 4 (also a total of 6)\\n- The last group (\"PI\") is again just a difference of 6 like the first group.\\n\\nGeneralizing these values, we get a pair of \\'differences\\'\\nGroup 1: [6, 0]\\nGroup 2: [4, 2]\\nGroup 3: [2, 4]\\nGroup 4: [0, 6]\\n\\nMy approach then is to iterate through **s** (\"PAYPALISHIRING\") *numRows* (4) times, capturing each letter according to the pattern of the given group.\\n```\\nGroup 1:\\n1     1     1\\nPAYPALISHIRING\\n// result: \"PIN\"\\n\\nGroup 2:\\n 2   2 2   2 2\\nPAYPALISHIRING\\n// result: \"PINALSIG\"\\n\\nGroup 3:\\n  3 3   3 3\\nPAYPALISHIRING\\n// result: \"PINALSIGYAHR\"\\nGroup 4:\\n   4     4\\nPAYPALISHIRING\\n// result: \"PINALSIGYAHRPI\"\\n```\\n\\nMany have already noted that the numRows and the frequency period have the relationship of:\\nperiod = (numRows * 2) - 2\\n\\nAnother note is that the difference pairs are diametrically opposed and **change in value by 2** as the pairs progress.  So for the case of input\\n**String: \"PAYPALISHIRING\"**\\n**numRows: 5**\\n```\\n// P       H\\n// A     S I\\n// Y   I   R\\n// P L     I G\\n// A       N\\n```\\nPeriod = (numRows * 2) - 2 => (5 * 2) - 2 => 10 - 2 => 8\\nThe difference pairs would look like:\\nGroup 1: [8, 0]\\nGroup 2: [6, 2]\\nGroup 3: [4, 4]\\nGroup 4: [2, 6]\\nGroup 5: [0, 8]\\n\\nIn the cases of the **first** and **last** groups, a letter should not be added to the result if they are the points in the string that **zig** or **zag**, i.e. don\\'t add a letter to the result string if a difference is value 0 such as [8, 0] or [0, 8].\\n\\nCode Implementation:\\n```\\n// \\nvar convert = function(s, numRows) {\\n  /* base case since 1 * 2 - 2 = 0 */\\n  if (numRows === 1) return s\\n  \\n  let result = \"\"\\n  let period = numRows * 2 - 2\\n  let diff1 = period, diff2 = 0\\n\\n  for (let i = 0; i < numRows; i++) {\\n\\t/* every group begins at the ith letter of \\'s\\' */\\n    let currStrIdx = i\\n\\t\\n\\t/* Used a flag to signify which of the diff pair should increment the index (defaulted to first) */\\n    let useFirst = true\\n\\t\\n\\t/* handles each group */\\n\\twhile (currStrIdx < s.length) {\\n\\t\\n\\t  /* If diff1 is 0, stay as diff 2, or if diff2 is 0, stay as diff1, otherwise no change */\\n\\t  useFirst = diff2 === 0 ? true : diff1 === 0 ? false : useFirst\\n\\t  \\n\\t  /* add current letter to result string */\\n      result += s[currStrIdx]\\n\\t  \\n\\t  /* increment the index to the next position in \\'s\\' based on diff pair pattern */\\n      useFirst ? currStrIdx += diff1 : currStrIdx += diff2\\n\\t  \\n\\t  /* switch between first or second of diff pairs */\\n      useFirst = !useFirst\\n    }\\n    \\n\\t/* after each pass, decrement diff1 by 2 and increment diff2 by 2 */\\n    diff1 -= 2\\n    diff2 += 2\\n  }\\n  \\n  return result\\n}\\n```\\n\\nTime Complexity: O(n)\\nSince the function iterates through each letter of the given string only once (albeit in different groups), it makes a single pass and is linear to size of the input.\\n\\nSpace Complexity: O(n)\\nSince the Result string ultimately is the same size as the input, the space used grows with the size of the input linearly.\\n\\nThanks for reading.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// P     I    N\\n// A   L S  I G\\n// Y A   H R\\n// P     I\\n```\n```\\nGroup 1:\\n1     1     1\\nPAYPALISHIRING\\n// result: \"PIN\"\\n\\nGroup 2:\\n 2   2 2   2 2\\nPAYPALISHIRING\\n// result: \"PINALSIG\"\\n\\nGroup 3:\\n  3 3   3 3\\nPAYPALISHIRING\\n// result: \"PINALSIGYAHR\"\\nGroup 4:\\n   4     4\\nPAYPALISHIRING\\n// result: \"PINALSIGYAHRPI\"\\n```\n```\\n// P       H\\n// A     S I\\n// Y   I   R\\n// P L     I G\\n// A       N\\n```\n```\\n// \\nvar convert = function(s, numRows) {\\n  /* base case since 1 * 2 - 2 = 0 */\\n  if (numRows === 1) return s\\n  \\n  let result = \"\"\\n  let period = numRows * 2 - 2\\n  let diff1 = period, diff2 = 0\\n\\n  for (let i = 0; i < numRows; i++) {\\n\\t/* every group begins at the ith letter of \\'s\\' */\\n    let currStrIdx = i\\n\\t\\n\\t/* Used a flag to signify which of the diff pair should increment the index (defaulted to first) */\\n    let useFirst = true\\n\\t\\n\\t/* handles each group */\\n\\twhile (currStrIdx < s.length) {\\n\\t\\n\\t  /* If diff1 is 0, stay as diff 2, or if diff2 is 0, stay as diff1, otherwise no change */\\n\\t  useFirst = diff2 === 0 ? true : diff1 === 0 ? false : useFirst\\n\\t  \\n\\t  /* add current letter to result string */\\n      result += s[currStrIdx]\\n\\t  \\n\\t  /* increment the index to the next position in \\'s\\' based on diff pair pattern */\\n      useFirst ? currStrIdx += diff1 : currStrIdx += diff2\\n\\t  \\n\\t  /* switch between first or second of diff pairs */\\n      useFirst = !useFirst\\n    }\\n    \\n\\t/* after each pass, decrement diff1 by 2 and increment diff2 by 2 */\\n    diff1 -= 2\\n    diff2 += 2\\n  }\\n  \\n  return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3134579,
                "title": "c-beats-99-easy-understanding-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- calculate how many increments you have to do to get to the next row element \\n- after calculating we found that no of jumps for rows other than the top and bottom rows is diffrent \\n- So use the diffrent formula for middle rows \\n- Rest is easy just keep check if the incements are in range\\n\\n# :) up-Vote if it Helps\\n# Complexity\\n- Time complexity:  O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if (numRows == 1) return s;\\n        string ans = \"\";\\n        for (int i = 0; i < numRows; i++) {\\n            int jumps = 2 * (numRows - 1);  //no of jumps to do for reaching the next element of row\\n            for (int j = i; j < s.length(); j += jumps) {   // increment j always by jumps\\n                ans += s[j];\\n                int midJumps = j + jumps - 2 * i;   // jumps for middle rows \\n                if (i > 0 && i < numRows - 1 && midJumps < s.length())  // check if middle jumps are in range\\n                    ans += s[midJumps];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if (numRows == 1) return s;\\n        string ans = \"\";\\n        for (int i = 0; i < numRows; i++) {\\n            int jumps = 2 * (numRows - 1);  //no of jumps to do for reaching the next element of row\\n            for (int j = i; j < s.length(); j += jumps) {   // increment j always by jumps\\n                ans += s[j];\\n                int midJumps = j + jumps - 2 * i;   // jumps for middle rows \\n                if (i > 0 && i < numRows - 1 && midJumps < s.length())  // check if middle jumps are in range\\n                    ans += s[midJumps];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765121,
                "title": "python-zigzag",
                "content": "```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        curr=(2*numRows)-2\\n        res=\"\"\\n        for i in range(numRows):\\n            j=0\\n            while i+j<len(s):   \\n                res+=s[j+i]\\n                sec=(j-i)+curr\\n                if i!=0 and i!=numRows-1 and sec<len(s):\\n                    res+=s[sec]\\n                j+=curr\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        curr=(2*numRows)-2\\n        res=\"\"\\n        for i in range(numRows):\\n            j=0\\n            while i+j<len(s):   \\n                res+=s[j+i]\\n                sec=(j-i)+curr\\n                if i!=0 and i!=numRows-1 and sec<len(s):\\n                    res+=s[sec]\\n                j+=curr\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266353,
                "title": "runtime-beats-95-70-memory-beats-92-43-explained-js-solution",
                "content": "# Intuition\\nRepeating patterns are mostly related to modulo operation.\\n\\n# Approach\\nLet\\'s work on the string \"representation\" using 4 rows.\\n\\n```\\nR        E        O   \\nE     S  N     I  N\\nP  E     T  T \\nR        A\\n```\\n\\nLet\\'s say we have *n = 4* rows.\\n\\n- The first row includes the characters R, E and O which have the indexes 0, 6 and 12 respectively. \\n- The second row includes the characters E, S, N, I and N which have the indexes 1, 5, 7, 11 and 13 respectively.\\n- The third row includes the characters P, E, T and T which have the indexes 2, 4, 8 and 12 respectively.\\n- Finally, the last row includes the characters R and A which have the indexes 3 and 9 respectively.\\n\\nAfter looking at the first row, it can be seen that the reminder is 0 when we divide each number by 6. This means that, we can divide the string into pieces of 6 and each piece will have a common pattern.\\n\\n\\n---\\n\\n\\n\\n```\\n// Piece 1\\n\\nR           \\nE     S  \\nP  E      \\nR       \\n```\\n```\\n// Piece 2\\n\\nE           \\nN     I  \\nT  T \\nA  \\n```\\n\\n```\\n// Piece 3\\n\\nO\\nN\\n\\n \\n```\\n\\n\\n---\\n\\n\\n\\nNow, let\\'s work on the first piece only.\\n\\n```\\n// Piece 1\\n\\nR           \\nE     S  \\nP  E      \\nR       \\n```\\n\\n- Indexes of the first row: [0] -> 0 % 6 = 0\\n- Indexes of the second row: [1,5] -> 1 % 6 = 1, 5 % 6 = 5\\n- Indexes of the third row: [2,4] -> 2 % 6 = 2, 4 % 6 = 4\\n- Indexes of the last row: [3] -> 3 % 6 = 3\\n\\n\\n---\\n\\n\\n\\n# **The final rule** \\n\\nLet *x* be the index of a character at row of index *y*. \\nLet *z* be the length of the repeating piece. \\n\\nFor all x, x % z is either y or (z-y).\\nWhich also means y is either x % z or (z - (x % y)).\\n\\n---\\n\\n# Validation\\n\\nNow, let\\'s look at the big picture again where z = 6.\\n\\n-- FIRST ROW --\\n\\nz = 6\\ny = 0\\nCharacter indexes: [0,6,12]\\n\\nfor x = 0, 0 % 6 = 0 where y = 0\\nfor x = 6, 6 % 6 = 0 where y = 0\\nfor x = 12, 12 % 6 = 0 where y = 0\\n\\n\\n-- SECOND ROW --\\n\\nz = 6\\ny = 1\\nCharacter indexes: [1,5,7,11,13]\\n\\nfor x = 1, 1 % 6 = 1 where y = 1\\nfor x = 5, 5 % 6 = 5 where (z - y) = 5\\nfor x = 7, 7 % 6 = 1 where y = 1\\nfor x = 11, 11 % 6 = 5 where (z - y) = 5\\nfor x = 13, 13 % 6 = 1 where y = 1\\n\\n.\\n.\\n.\\n\\n\\n# Complexity\\n- Time complexity:\\nRuntime 72 ms **Beats 95.70%** \\n\\n- Space complexity:\\nMemory 45.3 MB **Beats 92.43%**\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} numRows\\n * @return {string}\\n */\\nvar convert = function(s, numRows) {\\n    if(numRows < 2){\\n        return s;\\n    }\\n\\n    const divisor = (numRows - 1) * 2;\\n    const rows = Array(numRows).fill(\"\");\\n\\n    for(let dividend = 0; dividend < s.length; dividend++){\\n        const mod =  dividend % divisor;\\n        const rowIndex = mod < numRows ? mod : divisor - mod;\\n\\n        rows[rowIndex] += s[dividend];\\n    }\\n\\n    return rows.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nR        E        O   \\nE     S  N     I  N\\nP  E     T  T \\nR        A\\n```\n```\\n// Piece 1\\n\\nR           \\nE     S  \\nP  E      \\nR       \\n```\n```\\n// Piece 2\\n\\nE           \\nN     I  \\nT  T \\nA  \\n```\n```\\n// Piece 3\\n\\nO\\nN\\n\\n \\n```\n```\\n// Piece 1\\n\\nR           \\nE     S  \\nP  E      \\nR       \\n```\n```\\n/**\\n * @param {string} s\\n * @param {number} numRows\\n * @return {string}\\n */\\nvar convert = function(s, numRows) {\\n    if(numRows < 2){\\n        return s;\\n    }\\n\\n    const divisor = (numRows - 1) * 2;\\n    const rows = Array(numRows).fill(\"\");\\n\\n    for(let dividend = 0; dividend < s.length; dividend++){\\n        const mod =  dividend % divisor;\\n        const rowIndex = mod < numRows ? mod : divisor - mod;\\n\\n        rows[rowIndex] += s[dividend];\\n    }\\n\\n    return rows.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3133851,
                "title": "94-javascript-fast-very-very-easy-to-understand-solution-with-video-explanation-en-kr",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nEnglish video!\\n\\nhttps://youtu.be/9vEjTg1d6NE\\n\\nKorean video!\\n\\nhttps://youtu.be/VSRxC8MPc20\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} numRows\\n * @return {string}\\n */\\nvar convert = function(s, numRows) {\\n    let res = [];\\n    let count = 0;\\n    let up = true;\\n    for(let i =0; i<s.length;i++){\\n\\n        if(!res[count]) res[count] = []\\n        res[count].push(s[i])\\n\\n        count = up ? count+1 : count-1\\n        \\n        if(count+1 == numRows) up = false;\\n        else if(count == 0) up = true;\\n    }\\n    let result = \\'\\'\\n    for(let i of res){\\n        result += i.join(\\'\\')\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} numRows\\n * @return {string}\\n */\\nvar convert = function(s, numRows) {\\n    let res = [];\\n    let count = 0;\\n    let up = true;\\n    for(let i =0; i<s.length;i++){\\n\\n        if(!res[count]) res[count] = []\\n        res[count].push(s[i])\\n\\n        count = up ? count+1 : count-1\\n        \\n        if(count+1 == numRows) up = false;\\n        else if(count == 0) up = true;\\n    }\\n    let result = \\'\\'\\n    for(let i of res){\\n        result += i.join(\\'\\')\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981941,
                "title": "simple-o-n-solution-in-typescript-98-89-99-33",
                "content": "# Intuition\\nThe result is a merge of k strings, where k = numRows.\\nWe are making those strings by oscilating from the top to the bottom and extending them with consecutive string element.\\n\\n# Example\\nnumRows = 3, string = PAYPALISHIRING\\n\\nStep1: Create an array of size 3 with empty strings. `rows = [\\'\\', \\'\\', \\'\\'];`The functon result will be the merge of those array items.\\n\\nStep2: Iterate and extend those strings in oscilating order with consecutive string element.\\n\\nWe will be extending strings using indexes: `0,1,2,1,0,1,2,1,0,1...` \\n\\n```\\n1) rows = [\\'P\\', \\'\\', \\'\\'];\\n2) rows = [\\'P\\', \\'A\\', \\'\\'];\\n3) rows = [\\'P\\', \\'A\\', \\'Y\\'];\\n4) rows = [\\'P\\', \\'AP\\', \\'Y\\'];\\n5) rows = [\\'PA\\', \\'AP\\', \\'Y\\'];\\n6) rows = [\\'PA\\', \\'APL\\', \\'Y\\'];\\n7) rows = [\\'PA\\', \\'APL\\', \\'YI\\'];\\n8) rows = [\\'PA\\', \\'APLS\\', \\'YI\\'];\\n9) rows = [\\'PAH\\', \\'APLS\\', \\'YI\\'];\\n10) rows = [\\'PAH\\', \\'APLSI\\', \\'YI\\'];\\n11) rows = [\\'PAH\\', \\'APLSI\\', \\'YIR\\'];\\n12) rows = [\\'PAH\\', \\'APLSII\\', \\'YIR\\'];\\n13) rows = [\\'PAHN\\', \\'APLSII\\', \\'YIR\\'];\\n14) rows = [\\'PAHN\\', \\'APLSIIG\\', \\'YIR\\'];\\n```\\n\\nStep 3: Return joined array elements - `PAHNAPLSIIGYIR`\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunction convert(s: string, numRows: number): string {\\n    if (numRows === 1) return s;\\n\\n    const rows = new Array(numRows).fill(\\'\\');\\n\\n    let currRow = -1;\\n    let ascending = true;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        currRow += ascending ? 1 : -1;\\n        rows[currRow] += s[i];\\n\\n        if (currRow === numRows - 1) {\\n            ascending = false;\\n        } else if (currRow === 0) {\\n            ascending = true;\\n        }\\n    }\\n\\n    return rows.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n1) rows = [\\'P\\', \\'\\', \\'\\'];\\n2) rows = [\\'P\\', \\'A\\', \\'\\'];\\n3) rows = [\\'P\\', \\'A\\', \\'Y\\'];\\n4) rows = [\\'P\\', \\'AP\\', \\'Y\\'];\\n5) rows = [\\'PA\\', \\'AP\\', \\'Y\\'];\\n6) rows = [\\'PA\\', \\'APL\\', \\'Y\\'];\\n7) rows = [\\'PA\\', \\'APL\\', \\'YI\\'];\\n8) rows = [\\'PA\\', \\'APLS\\', \\'YI\\'];\\n9) rows = [\\'PAH\\', \\'APLS\\', \\'YI\\'];\\n10) rows = [\\'PAH\\', \\'APLSI\\', \\'YI\\'];\\n11) rows = [\\'PAH\\', \\'APLSI\\', \\'YIR\\'];\\n12) rows = [\\'PAH\\', \\'APLSII\\', \\'YIR\\'];\\n13) rows = [\\'PAHN\\', \\'APLSII\\', \\'YIR\\'];\\n14) rows = [\\'PAHN\\', \\'APLSIIG\\', \\'YIR\\'];\\n```\n```\\nfunction convert(s: string, numRows: number): string {\\n    if (numRows === 1) return s;\\n\\n    const rows = new Array(numRows).fill(\\'\\');\\n\\n    let currRow = -1;\\n    let ascending = true;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        currRow += ascending ? 1 : -1;\\n        rows[currRow] += s[i];\\n\\n        if (currRow === numRows - 1) {\\n            ascending = false;\\n        } else if (currRow === 0) {\\n            ascending = true;\\n        }\\n    }\\n\\n    return rows.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734210,
                "title": "c-solution-with-explanation",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- If numRow=1 then we\\u2019ll return the original string.\\n- Else we\\u2019ll count a step variable for the first and last row. These 2 will only have one direction.\\n    \\n    ```\\n    P   | A   | H   | N\\n    A P | L S | I I | G\\n    Y   | I   | R   |\\n    ```\\n    \\n- For `s[0]=P` & `s[2]=Y` , first & last row elements we need to iterate `2 * numRows - 2` times to get the next element of this row.\\n- Ans for any other row we have to go `down \\u2192 top` & `top \\u2192 down`, s[1] to s[3] & s[3] to s[5].\\n- For this, we are taking a bool variable flag to access if it\\u2019s a top iteration or down.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans;\\n        if (numRows == 1) return s;\\n        \\n        int step = 2 * numRows - 2;\\n        \\n        for(int i=0; i<numRows; i++){\\n            if(i==0 || i==numRows-1){\\n                for(int j=i; j<s.size(); j+=step){\\n                     ans.push_back(s[j]);\\n                }\\n            }\\n            \\n            else{\\n                int j = i;\\n                bool flag = true;\\n                int step1 = 2 * (numRows - 1 - i);\\n                int step2 = step - step1;\\n\\n                while (j < s.length()) {\\n                    ans.push_back(s[j]);\\n                    if (flag)\\n                        j = j + step1;\\n                    else\\n                        j = j + step2;\\n                    flag = !flag;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    P   | A   | H   | N\\n    A P | L S | I I | G\\n    Y   | I   | R   |\\n    ```\n```cpp\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans;\\n        if (numRows == 1) return s;\\n        \\n        int step = 2 * numRows - 2;\\n        \\n        for(int i=0; i<numRows; i++){\\n            if(i==0 || i==numRows-1){\\n                for(int j=i; j<s.size(); j+=step){\\n                     ans.push_back(s[j]);\\n                }\\n            }\\n            \\n            else{\\n                int j = i;\\n                bool flag = true;\\n                int step1 = 2 * (numRows - 1 - i);\\n                int step2 = step - step1;\\n\\n                while (j < s.length()) {\\n                    ans.push_back(s[j]);\\n                    if (flag)\\n                        j = j + step1;\\n                    else\\n                        j = j + step2;\\n                    flag = !flag;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667,
                "title": "better-than-97-88-o-n-java-solution-easy-to-understand",
                "content": "    public String convert(String s, int numRows) {\\n        if(numRows==1) return s;\\n        int x = 2 * (numRows-1); // distance between pipes |/|/|...\\n        int len = s.length();\\n        char[] c = new char[len];\\n        int k =0;\\n        for(int i=0; i < numRows; i++)\\n        {\\n            for(int j=i;j<len;j=j+x)\\n            {\\n                c[k++] = s.charAt(j);\\n                if(i>0 && i<numRows-1 && j+x-2*i < len)\\n                {\\n                       c[k++] = s.charAt(j+x-2*i); // extra character between pipes\\n                }\\n            }\\n        }\\n        return new String(c);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String convert(String s, int numRows) {\\n        if(numRows==1) return s;\\n        int x = 2 * (numRows-1); // distance between pipes |/|/|...\\n        int len = s.length();\\n        char[] c = new char[len];\\n        int k =0;\\n        for(int i=0; i < numRows; i++)\\n        {\\n            for(int j=i;j<len;j=j+x)\\n            {\\n                c[k++] = s.charAt(j);\\n                if(i>0 && i<numRows-1 && j+x-2*i < len)\\n                {\\n                       c[k++] = s.charAt(j+x-2*i); // extra character between pipes\\n                }\\n            }\\n        }\\n        return new String(c);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3733,
                "title": "cleanest-c-code-until-now-in-5-lines",
                "content": "    string convert(string s, int numRows) {\\n            if(numRows==1) return s;\\n            vector<string> p(numRows,\"\");\\n            int size=2*numRows-2;\\n            for(int i=0;i<s.size();i++) p[abs(numRows-1-i%size)]+=s[i];\\n            return accumulate( p.rbegin(), p.rend(), string(\"\") );\\n        }",
                "solutionTags": [],
                "code": "    string convert(string s, int numRows) {\\n            if(numRows==1) return s;\\n            vector<string> p(numRows,\"\");\\n            int size=2*numRows-2;\\n            for(int i=0;i<s.size();i++) p[abs(numRows-1-i%size)]+=s[i];\\n            return accumulate( p.rbegin(), p.rend(), string(\"\") );\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3683,
                "title": "almost-most-simple-and-intuitive-solution-c-with-clear-algo-description",
                "content": "    case 1: if(numRows==1 || s.size()<=numRows) return s;\\n    case 2: generate numRows sequences, join them sequentially, all indices less than s.size().\\n    \\tstepcount=(numRows-1)*2, for i= 0 to numRows-1, the ith sequence, first is s[i], \\n    \\t2a. for 0th and n-1 th sequence, the step equal to stepcount\\n    \\t2b. for other, sum of two successive step equal to stepcount,\\n    \\t\\tthe odd one is stepcount-(i*2), the even one is (i*2)\\n\\n// below code essentially follows the above algo.\\n\\n    class Solution {\\n    public:\\n        string convert(string s, int numRows) {\\n            if(numRows<2 || s.size()<=numRows) return s;\\n            string res(s.size(),0);\\n            char *p=&res[0];\\n            for(int i=0, j,k, step=(numRows-1)*2;i<numRows;++i) {\\n                if(i==0 || i==numRows-1) \\n                    for(j=i;j<s.size();j+=step) *p++=s[j];\\n                else\\n                    for(j=i, k=i<<1;j<s.size();k=step-k,j+=k) *p++=s[j];\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string convert(string s, int numRows) {\\n            if(numRows<2 || s.size()<=numRows) return s;\\n            string res(s.size(),0);\\n            char *p=&res[0];\\n            for(int i=0, j,k, step=(numRows-1)*2;i<numRows;++i) {\\n                if(i==0 || i==numRows-1) \\n                    for(j=i;j<s.size();j+=step) *p++=s[j];\\n                else\\n                    for(j=i, k=i<<1;j<s.size();k=step-k,j+=k) *p++=s[j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3918,
                "title": "solution-sharing-c-23ms",
                "content": "        class Solution {\\n    public:\\n        string convert(string s, int nRows) {\\n        //Analysis: the problem is convert a serial string to a Zig-Zag pattern\\n        //[0,1,2,3,4,5,6,7,8,9,...,N] with row m;\\n        //0                 2m-2                4m-4\\n        //1            2m-3 2m-1           4m-3\\n        //...      ...      ...      ...\\n        //m-2   m           3m-4  3m-2\\n        //m-1               3m-3\\n        //so the algorithm is basically an algebra converting of the indexes.\\n        //[s.length/(2m-2)]\\n        //[0,2m-2,4m-4,...,1,2m-3,2m-1]\\n        string result;\\n        int i,j;\\n        int len=s.length();\\n        if (nRows==1) return s;\\n        for (i=0;i<nRows;i++){\\n            //for each row in the Zig-Zag graph\\n            //for the first and last row:\\n            //[0,2m-2,4m-4,6m-6.....,]\\n            //[m-1,3m-3,5m-5]\\n            //for the middle rows\\n            //[i,2m-2-i,2m-2+i,4m-4-i,4m-4+i....]\\n            j=0;\\n            while (j<len+i){\\n                if (i<nRows-1 && i>0 && j>i){\\n                    result+=s.at(j-i);\\n                }\\n                if ((i+j)<len){\\n                    result+=s.at(j+i);\\n                }\\n                j+=2*nRows-2;\\n            }\\n        }\\n        return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string convert(string s, int nRows) {\\n        //Analysis: the problem is convert a serial string to a Zig-Zag pattern\\n        //[0,1,2,3,4,5,6,7,8,9,...,N] with row m;\\n        //0                 2m-2                4m-4\\n        //1            2m-3 2m-1           4m-3\\n        //...      ...      ...      ...\\n        //m-2   m           3m-4  3m-2\\n        //m-1               3m-3\\n        //so the algorithm is basically an algebra converting of the indexes.\\n        //[s.length/(2m-2)]\\n        //[0,2m-2,4m-4,...,1,2m-3,2m-1]\\n        string result;\\n        int i,j;\\n        int len=s.length();\\n        if (nRows==1) return s;\\n        for (i=0;i<nRows;i++){\\n            //for each row in the Zig-Zag graph\\n            //for the first and last row:\\n            //[0,2m-2,4m-4,6m-6.....,]\\n            //[m-1,3m-3,5m-5]\\n            //for the middle rows\\n            //[i,2m-2-i,2m-2+i,4m-4-i,4m-4+i....]\\n            j=0;\\n            while (j<len+i){\\n                if (i<nRows-1 && i>0 && j>i){\\n                    result+=s.at(j-i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3963,
                "title": "two-python-code-straight-forward-use-slice-and-neat-use-itertools",
                "content": "    class Solution:\\n    # @return a string\\n    def convert(self, s, n):\\n        res = [[] for _ in range(n)]\\n        i = 0\\n        try:\\n            while True:\\n                for r in res:\\n                    r.append(s[i])\\n                    i += 1\\n                for r in res[-2:0:-1]:\\n                    r.append(s[i])\\n                    i += 1\\n        except IndexError:\\n            return ''.join(''.join(r) for r in res)\\n\\nHere's a neat one\\n\\n    class Solution:\\n    # @return a string\\n    def convert(self, s, n):\\n        idx = itertools.chain(range(n), range(n-2, 0, -1))\\n        res = [[] for _ in range(n)]\\n        for char, i in zip(s, itertools.cycle(idx)):\\n            res[i].append(char)\\n        return ''.join(''.join(r) for r in res)",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @return a string\\n    def convert(self, s, n):\\n        res = [[] for _ in range(n)]\\n        i = 0\\n        try:\\n            while True:\\n                for r in res:\\n                    r.append(s[i])\\n                    i += 1\\n                for r in res[-2:0:-1]:\\n                    r.append(s[i])\\n                    i += 1\\n        except IndexError:\\n            return ''.join(''.join(r) for r in res)\\n\\nHere's a neat one\\n\\n    class Solution:\\n    # @return a string\\n    def convert(self, s, n):\\n        idx = itertools.chain(range(n), range(n-2, 0, -1))\\n        res = [[] for _ in range(n)]\\n        for char, i in zip(s, itertools.cycle(idx)):\\n            res[i].append(char)\\n        return ''.join(''.join(r) for r in res)",
                "codeTag": "Java"
            },
            {
                "id": 3531,
                "title": "share-my-java-solution-with-comments",
                "content": "    public String convert(String s, int nRows) {\\n        int len = s.length();\\n        if(len<=nRows||nRows<=1) return s; //such condition can't form the zigzag route.\\n        \\n        StringBuilder[] result = new StringBuilder[nRows]; //string buffer array to hold each row's result\\n        \\n        //initialize the string buffer\\n        for(int i = 0; i < result.length; i++){\\n            result[i] = new StringBuilder();\\n        }\\n        \\n        //divide the groups into chunks with size (nRows*2-2).\\n        int chunk = nRows*2-2; //3->4, 4->6, 5->7, etc.\\n        \\n        for(int i = 0; i < len; i++){\\n            int group = i%chunk; //get the index of the element in the chunk\\n            \\n            //if they are less then nRows, this element is vertically aligned from top to buttom\\n            if(group<nRows){\\n                result[group].append(s.charAt(i));\\n            }\\n            //otherwise, it falls onto the slope in reversed direction\\n            else{\\n                result[chunk-group].append(s.charAt(i));\\n            }\\n        }\\n        \\n        //combine the groups into final array.\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < nRows; i++){\\n            sb.append(result[i].toString());\\n        }\\n        return sb.toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String convert(String s, int nRows) {\\n        int len = s.length();\\n        if(len<=nRows||nRows<=1) return s; //such condition can't form the zigzag route.\\n        \\n        StringBuilder[] result = new StringBuilder[nRows]; //string buffer array to hold each row's result\\n        \\n        //initialize the string buffer\\n        for(int i = 0; i < result.length; i++){\\n            result[i] = new StringBuilder();\\n        }\\n        \\n        //divide the groups into chunks with size (nRows*2-2).\\n        int chunk = nRows*2-2; //3->4, 4->6, 5->7, etc.\\n        \\n        for(int i = 0; i < len; i++){\\n            int group = i%chunk; //get the index of the element in the chunk\\n            \\n            //if they are less then nRows, this element is vertically aligned from top to buttom\\n            if(group<nRows){\\n                result[group].append(s.charAt(i));\\n            }\\n            //otherwise, it falls onto the slope in reversed direction\\n            else{\\n                result[chunk-group].append(s.charAt(i));\\n            }\\n        }\\n        \\n        //combine the groups into final array.\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < nRows; i++){\\n            sb.append(result[i].toString());\\n        }\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3134729,
                "title": "putta-easy-solution-c-faster-than-100-nothing-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows == 1) return s;\\n        string ans= \"\";\\n        for(int i=0;i<numRows;i++){\\n            int nextindex = (numRows-1)*2;\\n            for(int j=i;j<s.size();j += nextindex){\\n                ans += s[j];\\n                int temp = j+nextindex-2*i;\\n                if( i != 0 && i!= numRows-1 && temp < s.size()){\\n                    ans += s[temp]; \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows == 1) return s;\\n        string ans= \"\";\\n        for(int i=0;i<numRows;i++){\\n            int nextindex = (numRows-1)*2;\\n            for(int j=i;j<s.size();j += nextindex){\\n                ans += s[j];\\n                int temp = j+nextindex-2*i;\\n                if( i != 0 && i!= numRows-1 && temp < s.size()){\\n                    ans += s[temp]; \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109167,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows==1) return s;\\n        bool down=true;\\n        string arr[numRows];\\n        int row=0;\\n        for(int i=0; i<s.size(); i++) {\\n            arr[row].push_back(s[i]);\\n            if(row==numRows-1) down=false;\\n            else if (row==0) down=true;\\n            if(down) row++;\\n            else row--;\\n        }\\n        string res=\"\";\\n        for(int i=0; i<numRows; i++) {\\n            res += arr[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows==1) return s;\\n        bool down=true;\\n        string arr[numRows];\\n        int row=0;\\n        for(int i=0; i<s.size(); i++) {\\n            arr[row].push_back(s[i]);\\n            if(row==numRows-1) down=false;\\n            else if (row==0) down=true;\\n            if(down) row++;\\n            else row--;\\n        }\\n        string res=\"\";\\n        for(int i=0; i<numRows; i++) {\\n            res += arr[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780150,
                "title": "javascript-solution-faster-than-91-90-of-javascript-submissions",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number} numRows\\n * @return {string}\\n */\\nvar convert = function(s, numRows) {\\n    if (numRows === 1) return s;\\n    const arraySolution = new Array(numRows).fill(\"\");\\n    let row = 0, step;\\n    for (let index = 0; index < s.length; index++){\\n        arraySolution[row] += s[index];\\n        if (row === 0) step = 1;\\n        if (row === numRows - 1) step = -1;\\n        row += step;\\n    }\\n    return arraySolution.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} numRows\\n * @return {string}\\n */\\nvar convert = function(s, numRows) {\\n    if (numRows === 1) return s;\\n    const arraySolution = new Array(numRows).fill(\"\");\\n    let row = 0, step;\\n    for (let index = 0; index < s.length; index++){\\n        arraySolution[row] += s[index];\\n        if (row === 0) step = 1;\\n        if (row === numRows - 1) step = -1;\\n        row += step;\\n    }\\n    return arraySolution.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648498,
                "title": "java-solution",
                "content": "```\\n public String convert(String s, int numRows) {\\n        \\n        if(numRows == 1 || s.length() <= numRows ) return s;\\n\\n\\t\\tString result = \"\";\\n\\n\\t\\tfor (int i = 1; i <= numRows; i++) {\\n\\t\\t\\t// first row\\n\\n\\t\\t\\tif (i == 1) {\\n\\t\\t\\t\\tint jump = 0;\\n\\n\\t\\t\\t\\twhile (jump < s.length()) {\\n\\t\\t\\t\\t\\tresult = result + s.charAt(jump);\\n\\t\\t\\t\\t\\tint next = (numRows - 2) * 2 + 1;\\n\\t\\t\\t\\t\\tjump = jump + next + 1; // nextelement\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (i != numRows) {\\n\\n\\t\\t\\t\\tboolean isJump = true;\\n\\t\\t\\t\\tint jump = i - 1;\\n\\t\\t\\t\\tresult = result + s.charAt(jump);\\n\\t\\t\\t\\twhile (jump < s.length()) {\\n\\t\\t\\t\\t\\tif (isJump) {\\n\\t\\t\\t\\t\\t\\tjump = jump + (numRows - i - 1) * 2 + 1 + 1;\\n\\n\\t\\t\\t\\t\\t\\tif (jump < s.length())\\n\\t\\t\\t\\t\\t\\t\\tresult = result + s.charAt(jump);\\n\\t\\t\\t\\t\\t\\tisJump = false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tjump = jump + (i - 1 - 1) * 2 + 1 + 1;\\n\\n\\t\\t\\t\\t\\t\\tif (jump < s.length())\\n\\t\\t\\t\\t\\t\\t\\tresult = result + s.charAt(jump);\\n\\t\\t\\t\\t\\t\\tisJump = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// last row\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint jump = i - 1;\\n\\t\\t\\t\\twhile (jump < s.length()) {\\n\\t\\t\\t\\t\\tresult = result + s.charAt(jump);\\n\\t\\t\\t\\t\\tint next = (numRows - 2) * 2 + 1;\\n\\t\\t\\t\\t\\tjump = jump + next + 1; // nextelement\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn result;\\n        \\n    }\\n    \\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n public String convert(String s, int numRows) {\\n        \\n        if(numRows == 1 || s.length() <= numRows ) return s;\\n\\n\\t\\tString result = \"\";\\n\\n\\t\\tfor (int i = 1; i <= numRows; i++) {\\n\\t\\t\\t// first row\\n\\n\\t\\t\\tif (i == 1) {\\n\\t\\t\\t\\tint jump = 0;\\n\\n\\t\\t\\t\\twhile (jump < s.length()) {\\n\\t\\t\\t\\t\\tresult = result + s.charAt(jump);\\n\\t\\t\\t\\t\\tint next = (numRows - 2) * 2 + 1;\\n\\t\\t\\t\\t\\tjump = jump + next + 1; // nextelement\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (i != numRows) {\\n\\n\\t\\t\\t\\tboolean isJump = true;\\n\\t\\t\\t\\tint jump = i - 1;\\n\\t\\t\\t\\tresult = result + s.charAt(jump);\\n\\t\\t\\t\\twhile (jump < s.length()) {\\n\\t\\t\\t\\t\\tif (isJump) {\\n\\t\\t\\t\\t\\t\\tjump = jump + (numRows - i - 1) * 2 + 1 + 1;\\n\\n\\t\\t\\t\\t\\t\\tif (jump < s.length())\\n\\t\\t\\t\\t\\t\\t\\tresult = result + s.charAt(jump);\\n\\t\\t\\t\\t\\t\\tisJump = false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tjump = jump + (i - 1 - 1) * 2 + 1 + 1;\\n\\n\\t\\t\\t\\t\\t\\tif (jump < s.length())\\n\\t\\t\\t\\t\\t\\t\\tresult = result + s.charAt(jump);\\n\\t\\t\\t\\t\\t\\tisJump = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// last row\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint jump = i - 1;\\n\\t\\t\\t\\twhile (jump < s.length()) {\\n\\t\\t\\t\\t\\tresult = result + s.charAt(jump);\\n\\t\\t\\t\\t\\tint next = (numRows - 2) * 2 + 1;\\n\\t\\t\\t\\t\\tjump = jump + next + 1; // nextelement\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn result;\\n        \\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1737114,
                "title": "the-easiest-solution-with-only-three-variables-95",
                "content": "```\\nvar convert = function(s, numRows) {\\n    const rows = []; // where string in each row stored\\n    let row = 0, step = 1; \\n    \\n    for (let i = 0; i < s.length; i++) {\\n        rows[row] = rows[row] ? rows[row] + s[i] : s[i]; // add the char to current row string\\n        \\n        row += step;  // update the row\\n        if (row === numRows - 1 || row === 0) step *= -1; // if it hit the border, turn the direction\\n    }\\n    \\n    return rows.join(\\'\\') // join all the rows and return\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar convert = function(s, numRows) {\\n    const rows = []; // where string in each row stored\\n    let row = 0, step = 1; \\n    \\n    for (let i = 0; i < s.length; i++) {\\n        rows[row] = rows[row] ? rows[row] + s[i] : s[i]; // add the char to current row string\\n        \\n        row += step;  // update the row\\n        if (row === numRows - 1 || row === 0) step *= -1; // if it hit the border, turn the direction\\n    }\\n    \\n    return rows.join(\\'\\') // join all the rows and return\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427621,
                "title": "python-solution-with-step-by-step-walk-through-beats-95",
                "content": "```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        if numRows == 1:\\n            return s\\n        \\n\\t\\t# Store all levels as arr inside a larger levels arr\\n        levels = []\\n        for n in range(numRows):\\n            levels.append([])\\n\\n        # Iterate through letters of the string\\n\\t\\t# For each letter, append it to the level that corresponds to the level variable below\\n\\t\\t# Add step to level to increase/decrease level\\n        level = 0\\n        step = 1\\n        \\n        for letter in s:\\n            levels[level].append(letter)\\n            level += step\\n            \\n\\t\\t\\t# Step turns negative when we reach the last level\\n\\t\\t\\t# Step turns positive when we reach the top level\\n            if level == 0 or level == numRows-1:\\n                step *= -1\\n        \\n\\t\\t# Convert the list of letter into strings\\n        for level, string in enumerate(levels):\\n            levels[level] = \\'\\'.join(string)\\n           \\n        return \\'\\'.join(levels)\\n```\\n\\n## Example: \\nstring = \\'hello\\' \\nnumRows = 3 \\n\\n**Iteration #1** \\n\\t- append current letter to current level\\n\\t- increment level by step\\n```\\n\\tlevel = 0 \\n\\tstep = 1\\n\\tstring = \\'(h)ello\\'\\n\\t\\n\\tlevels = [\\n\\t\\t\\t\\t[],    # Level One  <- current level\\n\\t\\t\\t\\t[],    # Level Two\\n\\t\\t\\t\\t[]     # Level Three\\n\\t\\t\\t]\\n```\\n**Iteration #2**\\n \\t- append current letter to current level\\n\\t- increment level by step\\n```  \\n\\t   level = 1\\n\\t   step = 1\\n\\t   string = \\'h(e)llo\\'\\n      \\n\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'h\\'],     # Level One \\n\\t\\t\\t\\t\\t[],        # Level Two <- current level\\n\\t\\t\\t\\t\\t[]         # Level Three\\n\\t\\t\\t\\t]\\n```\\n**Iteration #3**\\n\\t- append current letter to current level\\n\\t- increment level by step\\t\\n\\t- Current level is max level depth\\n\\t      -> So begin going up levels (step *= -1)\\n```\\n\\t   level = 2\\n\\t   step = 1\\n\\t\\t            \\n\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'h\\'],     # Level One \\n\\t\\t\\t\\t\\t[\\'e\\'],     # Level Two \\n\\t\\t\\t\\t\\t[]         # Level Three <- current level\\n\\t\\t\\t\\t]\\n\\t\\t\\n\\t\\tstring = \\'he(l)lo\\'\\n```\\n**Iteration #4**\\n\\t- append current letter to current level\\n\\t- increment level by step (-1)\\n```\\n\\t    level = 1\\n\\t    step = -1\\n\\t\\tstring = \\'hel(l)o\\'            \\n\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'h\\'],       # Level One \\n\\t\\t\\t\\t\\t[\\'e\\'],       # Level Two  <- current level\\n\\t\\t\\t\\t\\t[\\'l\\']        # Level Three \\n\\t\\t\\t\\t]\\n```\\n**Iteration #5**\\n\\t- append current letter to current level\\n\\t- increment level by step (-1)\\n```\\n\\t   level = 0\\n\\t   step = -1\\n\\t   string = \\'hell(o)\\'     \\n\\t   \\n\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'h\\'],         # Level One    <- current level\\n\\t\\t\\t\\t\\t[\\'e\\', \\'l\\'],    # Level Two\\n\\t\\t\\t\\t\\t[\\'l\\']          # Level Three \\n\\t\\t\\t\\t]\\n```\\n**Iteration #6**\\n\\t- append current letter to current level\\n\\t- increment level by step (-1)\\n```\\n\\t   level = 0\\n\\t   step = -1\\n\\t   string = \\'hello\\'\\n\\t            \\n\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'h\\', \\'o\\'],    # Level One    <- current level\\n\\t\\t\\t\\t\\t[\\'e\\', \\'l\\'],    # Level Two\\n\\t\\t\\t\\t\\t[\\'l\\']          # Level Three \\n\\t\\t\\t\\t]\\n\\t\\t\\n```\\n**Done with string iteration, time to create an answer**\\nFinal levels array looks like: \\n```\\n\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'h\\', \\'o\\'],    # Level One\\n\\t\\t\\t\\t\\t[\\'e\\', \\'l\\'],    # Level Two\\n\\t\\t\\t\\t\\t[\\'l\\']          # Level Three \\n\\t\\t\\t\\t]\\n```\\nJoin letters inside each level together as a level string:\\n\\n\\t\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'ho\\'],    # Level One\\n\\t\\t\\t\\t\\t[\\'el\\'],    # Level Two\\n\\t\\t\\t\\t\\t[\\'l\\']      # Level Three \\n\\t\\t\\t\\t]\\n\\t\\t\\n\\t\\t\\nJoin all level strings together:\\n\\n\\t\\tanswer = \\'hoell\\'\\n\\t\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        if numRows == 1:\\n            return s\\n        \\n\\t\\t# Store all levels as arr inside a larger levels arr\\n        levels = []\\n        for n in range(numRows):\\n            levels.append([])\\n\\n        # Iterate through letters of the string\\n\\t\\t# For each letter, append it to the level that corresponds to the level variable below\\n\\t\\t# Add step to level to increase/decrease level\\n        level = 0\\n        step = 1\\n        \\n        for letter in s:\\n            levels[level].append(letter)\\n            level += step\\n            \\n\\t\\t\\t# Step turns negative when we reach the last level\\n\\t\\t\\t# Step turns positive when we reach the top level\\n            if level == 0 or level == numRows-1:\\n                step *= -1\\n        \\n\\t\\t# Convert the list of letter into strings\\n        for level, string in enumerate(levels):\\n            levels[level] = \\'\\'.join(string)\\n           \\n        return \\'\\'.join(levels)\\n```\n```\\n\\tlevel = 0 \\n\\tstep = 1\\n\\tstring = \\'(h)ello\\'\\n\\t\\n\\tlevels = [\\n\\t\\t\\t\\t[],    # Level One  <- current level\\n\\t\\t\\t\\t[],    # Level Two\\n\\t\\t\\t\\t[]     # Level Three\\n\\t\\t\\t]\\n```\n```  \\n\\t   level = 1\\n\\t   step = 1\\n\\t   string = \\'h(e)llo\\'\\n      \\n\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'h\\'],     # Level One \\n\\t\\t\\t\\t\\t[],        # Level Two <- current level\\n\\t\\t\\t\\t\\t[]         # Level Three\\n\\t\\t\\t\\t]\\n```\n```\\n\\t   level = 2\\n\\t   step = 1\\n\\t\\t            \\n\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'h\\'],     # Level One \\n\\t\\t\\t\\t\\t[\\'e\\'],     # Level Two \\n\\t\\t\\t\\t\\t[]         # Level Three <- current level\\n\\t\\t\\t\\t]\\n\\t\\t\\n\\t\\tstring = \\'he(l)lo\\'\\n```\n```\\n\\t    level = 1\\n\\t    step = -1\\n\\t\\tstring = \\'hel(l)o\\'            \\n\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'h\\'],       # Level One \\n\\t\\t\\t\\t\\t[\\'e\\'],       # Level Two  <- current level\\n\\t\\t\\t\\t\\t[\\'l\\']        # Level Three \\n\\t\\t\\t\\t]\\n```\n```\\n\\t   level = 0\\n\\t   step = -1\\n\\t   string = \\'hell(o)\\'     \\n\\t   \\n\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'h\\'],         # Level One    <- current level\\n\\t\\t\\t\\t\\t[\\'e\\', \\'l\\'],    # Level Two\\n\\t\\t\\t\\t\\t[\\'l\\']          # Level Three \\n\\t\\t\\t\\t]\\n```\n```\\n\\t   level = 0\\n\\t   step = -1\\n\\t   string = \\'hello\\'\\n\\t            \\n\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'h\\', \\'o\\'],    # Level One    <- current level\\n\\t\\t\\t\\t\\t[\\'e\\', \\'l\\'],    # Level Two\\n\\t\\t\\t\\t\\t[\\'l\\']          # Level Three \\n\\t\\t\\t\\t]\\n\\t\\t\\n```\n```\\n\\t\\tlevels = [\\n\\t\\t\\t\\t\\t[\\'h\\', \\'o\\'],    # Level One\\n\\t\\t\\t\\t\\t[\\'e\\', \\'l\\'],    # Level Two\\n\\t\\t\\t\\t\\t[\\'l\\']          # Level Three \\n\\t\\t\\t\\t]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421453,
                "title": "easy-to-understand-c-solution-8ms-beats-93",
                "content": "Runtime: 8 ms, faster than 93.78% of C++ online submissions for ZigZag Conversion.\\nMemory Usage: 12.7 MB, less than 46.29% of C++ online submissions for ZigZag Conversion.\\n\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        \\n        if(numRows <= 1)\\n            return s;\\n        \\n        string res = \"\";\\n        vector<string> pattern(numRows, \"\");\\n        int row = 0;\\n        int down = 1;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            pattern[row].push_back(s[i]);\\n            \\n            if(row == 0)\\n                down = 1;\\n            else if(row == numRows - 1)\\n                down = -1;\\n            \\n            row += down;\\n        }\\n        \\n        for(string row : pattern)\\n            res += row;\\n        return res; \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        \\n        if(numRows <= 1)\\n            return s;\\n        \\n        string res = \"\";\\n        vector<string> pattern(numRows, \"\");\\n        int row = 0;\\n        int down = 1;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            pattern[row].push_back(s[i]);\\n            \\n            if(row == 0)\\n                down = 1;\\n            else if(row == numRows - 1)\\n                down = -1;\\n            \\n            row += down;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 213905,
                "title": "c-solution-with-12-ms-and-14-lines-strong-readability",
                "content": "**My thought:**\\n1.Create an vector to hold the string representing each line;\\n2.Create a cursor that can be moved up and down(like \\'W\\',down-up-down-up);\\n3.Inserts the letter into the string indicated by the cursor;\\n4.Concatenates all substrings into a single string.\\n\\n**Here is my code:**\\n```\\nstring convert(string s, int numRows) {\\n\\tif (numRows == 1)return s;\\n\\tvector<string> subStr(numRows);\\n\\tbool isDescending = false;\\n\\tint i = 0;\\n\\tfor (const auto e : s){\\n\\t\\tsubStr[i] += e;\\n\\t\\tif(i == 0 || i == numRows - 1) isDescending = !isDescending;\\n\\t\\tisDescending ? ++i : --i;\\n\\t}\\n\\tstring resStr;\\n\\tfor (const auto& str : subStr) resStr += str;\\n\\treturn resStr;\\n}\\n```\\n**Hope this helps.**",
                "solutionTags": [],
                "code": "```\\nstring convert(string s, int numRows) {\\n\\tif (numRows == 1)return s;\\n\\tvector<string> subStr(numRows);\\n\\tbool isDescending = false;\\n\\tint i = 0;\\n\\tfor (const auto e : s){\\n\\t\\tsubStr[i] += e;\\n\\t\\tif(i == 0 || i == numRows - 1) isDescending = !isDescending;\\n\\t\\tisDescending ? ++i : --i;\\n\\t}\\n\\tstring resStr;\\n\\tfor (const auto& str : subStr) resStr += str;\\n\\treturn resStr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207857,
                "title": "rust",
                "content": "```\\nfn convert(string: &str, num_rows: i32) -> String {\\n    let num_rows = num_rows as usize;\\n\\n    if num_rows < 2 {\\n        return string.into();\\n    }\\n\\n    let mut strings = vec![String::new(); num_rows];\\n\\n    let mut i = 0;\\n    let mut down = true;\\n\\n    for c in string.chars() {\\n        strings[i].push(c);\\n        i = if down { i + 1 } else { i - 1 };\\n        down = down == (i > 0 && i < num_rows - 1);\\n    }\\n\\n    strings.concat()\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfn convert(string: &str, num_rows: i32) -> String {\\n    let num_rows = num_rows as usize;\\n\\n    if num_rows < 2 {\\n        return string.into();\\n    }\\n\\n    let mut strings = vec![String::new(); num_rows];\\n\\n    let mut i = 0;\\n    let mut down = true;\\n\\n    for c in string.chars() {\\n        strings[i].push(c);\\n        i = if down { i + 1 } else { i - 1 };\\n        down = down == (i > 0 && i < num_rows - 1);\\n    }\\n\\n    strings.concat()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4075001,
                "title": "video-step-by-step-visualization-and-explanation",
                "content": "https://youtu.be/ytSl-K4xo3w\\n\\nThe key to solving this problem is to understand that we assign characters to rows by <i>oscillating</i> between the top and bottom rows.  In other words, if we traversed the string and looked at which row each character belonged to (let\\u2019s say numRows is 3), the pattern would be 1 2 3 2 1 2 3 2 1.. so the first character goes in row 1, the second character goes in rows 2, the third character goes in row 3 - which is the bottom row - so now you go back up to row 2, then row 1.\\n\\nTo represent the rows, we\\u2019ll use a 2D array named `rows`, where each inner list represents a row.  We then use a variable called `index` that will oscillate between the top and bottom rows and assign characters to rows.\\n\\nWe\\u2019ll control the direction that index moves by using a variable called `step`.  `step` will either be 1 or -1, where a value of 1 means we need to increment the index (so move DOWN a row) and a value of -1 means we need to decrement the index (move UP a row).  Whenever we reach either the first or last row, we\\'ll switch the direction to move `index` in the opposite direction.\\n\\nA common mistake I see is creating a 1D list and initializing an empty string for each row.  Then, instead of appending to a list, each character is added by using string concatenation.  While this works, this is not O(n) because strings are immutable.  In other words, string concatenation  allocates new memory and copies over each character from both strings to create an entirely new string.  That means that the string concatenation runs in O(n), so the overall algorithm runs in O(n<sup>2</sup>) time.\\n\\nInstead, by using lists (since lists are mutable), appending to a list runs in constant time - or more precisely, the amortized complexity of appending to a list is constant.  So that allows everything inside the loop to run in constant time, so the algorithm now runs in O(n) time.  \\n\\n# Code\\n```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        if numRows == 1 or numRows >= len(s):\\n            return s\\n        \\n        rows = [[] for row in range(numRows)]\\n        index = 0\\n        step = -1\\n        for char in s:\\n            rows[index].append(char)\\n            if index == 0:\\n                step = 1\\n            elif index == numRows - 1:\\n                step = -1\\n            index += step\\n\\n        for i in range(numRows):\\n            rows[i] = \\'\\'.join(rows[i])\\n        return \\'\\'.join(rows)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        if numRows == 1 or numRows >= len(s):\\n            return s\\n        \\n        rows = [[] for row in range(numRows)]\\n        index = 0\\n        step = -1\\n        for char in s:\\n            rows[index].append(char)\\n            if index == 0:\\n                step = 1\\n            elif index == numRows - 1:\\n                step = -1\\n            index += step\\n\\n        for i in range(numRows):\\n            rows[i] = \\'\\'.join(rows[i])\\n        return \\'\\'.join(rows)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135865,
                "title": "python3-49-ms-faster-than-95-18-of-python3",
                "content": "```\\ndef convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1:\\n            return s\\n        zigzag = [\\'\\' for _ in range(numRows)]\\n        row = 0\\n        step = 1\\n        for c in s:\\n            zigzag[row] += c\\n            if row == numRows-1:\\n                step = -1\\n            elif row == 0:\\n                step = 1\\n            row += step\\n        return \\'\\'.join(zigzag)\\n```\\nThe code implements a solution to the problem of converting a given string into a zigzag pattern using a specified number of rows. The steps involved are as follows:\\n\\n1. Check if the number of rows is 1. If so, return the input string as is, as there\\'s no zigzag pattern to be formed.\\n1. Initialize an empty list, called \"zigzag\", with \"numRows\" number of empty strings. This list will store the zigzag pattern of the input string.\\n1. Initialize two variables, \"row\" and \"step\", both set to 0. \"row\" will be used to keep track of the current row that we\\'re adding characters to, while \"step\" will determine the direction in which we\\'re adding characters.\\n1. Loop through each character in the input string \"s\".\\n1. Add the current character to the \"zigzag\" list, at the current row.\\n1. Update the value of \"step\" based on the current row. If \"row\" is equal to \"numRows - 1\", set \"step\" to -1, which will cause the next character to be added to the previous row. If \"row\" is equal to 0, set \"step\" to 1, which will cause the next character to be added to the next row.\\n1. Update the value of \"row\" by adding \"step\".\\n1. Repeat steps 5-7 for each character in the input string \"s\".\\n1. After the loop, join all the strings in the \"zigzag\" list together and return the result as the final zigzag pattern of the input string.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\ndef convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1:\\n            return s\\n        zigzag = [\\'\\' for _ in range(numRows)]\\n        row = 0\\n        step = 1\\n        for c in s:\\n            zigzag[row] += c\\n            if row == numRows-1:\\n                step = -1\\n            elif row == 0:\\n                step = 1\\n            row += step\\n        return \\'\\'.join(zigzag)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3133843,
                "title": "daily-leetcoding-challenge-february-day-3",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/zigzag-conversion/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/zigzag-conversion/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2549281,
                "title": "c-simple-solution-easy-to-understand-codesoup",
                "content": "Here\\'s a full write up of the problem explained step by step\\nhttps://imsudip.hashnode.dev/leetcode-question-6\\n\\n> I recently started this blog where I will post writeup for daily leetcode problems.\\nsupport me by checking it out and share your views on it\\n\\n**Upvote if you want me to continue making this type of content for the coding community**\\n\\n## Solution: \\n### Approach: \\nAfter looking at the question, I thought of using a 2D array to store the characters in the zigzag pattern. But, I realized that it would be a waste of space. So, I thought of using a vector of strings to store the characters in the zigzag pattern. I used a boolean variable `goingDown` to keep track of the direction of the zigzag pattern. If `goingDown` is true, then I increment the row number. If `goingDown` is false, then I decrement the row number. I used a for loop to iterate through the string `s`. I used a if-else statement to check if the row number is `0` or `numRows - 1`. If it is, then I change the value of `goingDown`. I used a for loop to iterate through the vector of strings and append the characters to the string `ans`. I returned the string `ans`.\\n\\n<br>Now, we can write the code:\\n### Code:\\n```c\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    string convert(string s, int numRows)\\n    {\\n        if (numRows == 1)\\n        {\\n            return s;\\n        }\\n        vector<string> rows(min(numRows, int(s.size())));\\n        int curRow = 0;\\n        bool goingDown = false;\\n        for (char c : s)\\n        {\\n            rows[curRow] += c;\\n            if (curRow == 0 || curRow == numRows - 1)\\n            {\\n                goingDown = !goingDown;\\n            }\\n            curRow += goingDown ? 1 : -1;\\n        }\\n        string ans;\\n        for (string row : rows)\\n        {\\n            ans += row;\\n        }\\n        return ans;\\n    }\\n};\\n\\nint main()\\n{\\n    Solution s;\\n    cout << s.convert(\"PAYPALISHIRING\", 3) << endl;\\n    return 0;\\n}\\n```\\n\\n\\n### Complexity Analysis: <br> \\nTime Complexity: **O(n)**<br>\\nSpace Complexity:**O(n)**<br>\\n**Hope this helps!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    string convert(string s, int numRows)\\n    {\\n        if (numRows == 1)\\n        {\\n            return s;\\n        }\\n        vector<string> rows(min(numRows, int(s.size())));\\n        int curRow = 0;\\n        bool goingDown = false;\\n        for (char c : s)\\n        {\\n            rows[curRow] += c;\\n            if (curRow == 0 || curRow == numRows - 1)\\n            {\\n                goingDown = !goingDown;\\n            }\\n            curRow += goingDown ? 1 : -1;\\n        }\\n        string ans;\\n        for (string row : rows)\\n        {\\n            ans += row;\\n        }\\n        return ans;\\n    }\\n};\\n\\nint main()\\n{\\n    Solution s;\\n    cout << s.convert(\"PAYPALISHIRING\", 3) << endl;\\n    return 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1037294,
                "title": "c-very-easy-to-understand-solution",
                "content": "When we convert the string into ZigZag, we can divide each group of characters into periods, with size of `2 * numRows - 2`\\n```\\nPAYPALISHIRING\\nperiodSize = 4\\n\\nP   | A   | H   | N\\nA P | L S | I I | G\\nY   | I   | R   |\\n```\\n\\nIf we correspond each character from the ZigZag pattern to the characters in the original string, we can observe the following:\\n```\\nROW 1 OF ZIGZAG\\n\\nP A Y P A L I S H I R  I  N  G\\n^       ^       ^         ^\\n0 1 2 3 4 5 6 7 8 9 10 11 12 13\\n\\nP   | A   | H   | N\\n```\\nThe corresponding characters of row 1 to the original string starts from `s[0]`, `s[4]`, `s[8]`... Meaning the increment is 4 for row 1, which is the `periodSize`. This happens in the last row as well.\\n\\n```\\nROW 2 OF ZIGZAG\\n\\nP A Y P A L I S H I R  I  N  G\\n  ^   ^   ^   ^   ^    ^     ^\\n0 1 2 3 4 5 6 7 8 9 10 11 12 13\\n\\nA P | L S | I I | G\\n```\\nFor row 2, the characters are `s[1]`, `s[3]`, `s[5]`...\\nThe increment in row 2 is 2.\\n\\nWhat about other `numRows`? Let\\'s have look at what is the case with row 2 in `numRows = 4`.\\n```\\nnumRows = 4\\nperiodSize = 6\\n\\nP A Y P A L I S H I R  I  N  G\\n  ^       ^   ^        ^     ^\\n0 1 2 3 4 5 6 7 8 9 10 11 12 13\\n\\n  P   | I   | N\\n> A L | S I | G\\n  Y A | H R |\\n  P   | I   |\\n```\\nYou can see that the **first and last row** has increment of `periodSize = 6`, \\nThe **second row** has two increments, which is **alternating between 4 and 2**.\\nThe **third row** also has two increments, which is **alternating between 2 and 4**.\\n\\nWe can draw the following conclusion: **there are two increments for each row `i`, such that**\\n```\\nint inc1 = periodSize - (i * 2);\\nint inc2 = periodSize - inc1;\\n```\\n\\nWith this in mind, we can now write the code. Below is my solution:\\n```cpp\\nstring convert(string s, int numRows) {\\n\\n\\tif (numRows == 1) {  // If numRows is 1, there is no change\\n\\t\\treturn s;\\n\\t}\\n\\n\\tstring ret;\\n\\tint periodSize = 2 * numRows - 2;\\n\\n\\tfor(int i = 0; i < numRows; i++) {  // Iterate row by row\\n\\t\\tint inc1 = periodSize - (i * 2);\\n\\t\\tint inc2 = periodSize - inc1;\\n\\t\\tint j = i;\\n\\n\\t\\twhile(j < s.length()) {\\n\\t\\t\\tif (inc1 != 0 && j < s.length()) { // Avoid adding repeated characters when inc1 is 0\\n\\t\\t\\t\\tret += s[j];\\n\\t\\t\\t\\tj += inc1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (inc2 != 0 && j < s.length()) {  // Avoid adding repeated characters when inc2 is 0\\n\\t\\t\\t\\tret += s[j];\\n\\t\\t\\t\\tj += inc2;\\n\\t\\t\\t}   \\n\\t\\t}\\n\\t}\\n\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nPAYPALISHIRING\\nperiodSize = 4\\n\\nP   | A   | H   | N\\nA P | L S | I I | G\\nY   | I   | R   |\\n```\n```\\nROW 1 OF ZIGZAG\\n\\nP A Y P A L I S H I R  I  N  G\\n^       ^       ^         ^\\n0 1 2 3 4 5 6 7 8 9 10 11 12 13\\n\\nP   | A   | H   | N\\n```\n```\\nROW 2 OF ZIGZAG\\n\\nP A Y P A L I S H I R  I  N  G\\n  ^   ^   ^   ^   ^    ^     ^\\n0 1 2 3 4 5 6 7 8 9 10 11 12 13\\n\\nA P | L S | I I | G\\n```\n```\\nnumRows = 4\\nperiodSize = 6\\n\\nP A Y P A L I S H I R  I  N  G\\n  ^       ^   ^        ^     ^\\n0 1 2 3 4 5 6 7 8 9 10 11 12 13\\n\\n  P   | I   | N\\n> A L | S I | G\\n  Y A | H R |\\n  P   | I   |\\n```\n```\\nint inc1 = periodSize - (i * 2);\\nint inc2 = periodSize - inc1;\\n```\n```cpp\\nstring convert(string s, int numRows) {\\n\\n\\tif (numRows == 1) {  // If numRows is 1, there is no change\\n\\t\\treturn s;\\n\\t}\\n\\n\\tstring ret;\\n\\tint periodSize = 2 * numRows - 2;\\n\\n\\tfor(int i = 0; i < numRows; i++) {  // Iterate row by row\\n\\t\\tint inc1 = periodSize - (i * 2);\\n\\t\\tint inc2 = periodSize - inc1;\\n\\t\\tint j = i;\\n\\n\\t\\twhile(j < s.length()) {\\n\\t\\t\\tif (inc1 != 0 && j < s.length()) { // Avoid adding repeated characters when inc1 is 0\\n\\t\\t\\t\\tret += s[j];\\n\\t\\t\\t\\tj += inc1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (inc2 != 0 && j < s.length()) {  // Avoid adding repeated characters when inc2 is 0\\n\\t\\t\\t\\tret += s[j];\\n\\t\\t\\t\\tj += inc2;\\n\\t\\t\\t}   \\n\\t\\t}\\n\\t}\\n\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3397,
                "title": "easy-to-understand-solution",
                "content": "For a moment ignore the case where there is just one row or where there is more rows than the length of the string.\\n\\nNow we can simply make a vector which will be initialized to the number of rows. We can traverse the string and add elements across this vector. When we are at the beginning or end of the vector, we simply change directions.\\n\\nWhen we are done traversing the entire string, we simply concatenate all of the strings in our vector.\\n\\nIn both of the edge cases, we just return the original string.\\n\\n```\\nstring convert(string s, int numRows) {\\n\\t\\n\\n\\tif (numRows > s.length() || numRows==1) { // handle edge cases\\n\\t\\treturn s;\\n\\t}\\n    \\n    vector<string> words(numRows);\\n\\tint i = 0;\\n\\tint d = -1;\\n\\tint j = 0;\\n\\n\\twhile (i < s.length()) {\\t\\t\\n\\t\\twords[j] += s[i];\\n\\t\\td = (j == 0 || j == (numRows - 1)) ? -d : d;\\n\\t\\tj += d;\\n\\t\\ti++;\\t\\t\\n\\t}\\n\\n\\tstring result=\"\";\\n\\tfor (string w : words) {\\n\\t\\tresult += w;\\n\\t}\\n\\n\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring convert(string s, int numRows) {\\n\\t\\n\\n\\tif (numRows > s.length() || numRows==1) { // handle edge cases\\n\\t\\treturn s;\\n\\t}\\n    \\n    vector<string> words(numRows);\\n\\tint i = 0;\\n\\tint d = -1;\\n\\tint j = 0;\\n\\n\\twhile (i < s.length()) {\\t\\t\\n\\t\\twords[j] += s[i];\\n\\t\\td = (j == 0 || j == (numRows - 1)) ? -d : d;\\n\\t\\tj += d;\\n\\t\\ti++;\\t\\t\\n\\t}\\n\\n\\tstring result=\"\";\\n\\tfor (string w : words) {\\n\\t\\tresult += w;\\n\\t}\\n\\n\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476,
                "title": "c-13-lines",
                "content": "A shorter version of this [post](https://discuss.leetcode.com/topic/4502/share-simple-c-solution).\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows == 1) return s;\\n        vector<string>v(numRows, \"\");\\n        int d = 1;\\n        int row = 0;\\n        for(auto c: s){\\n            v[row].push_back(c);\\n            row += d;\\n            if(row == numRows - 1) d = -1;\\n            if(row == 0) d = 1;\\n        }\\n        string res;\\n        for(auto x: v) res.append(x);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows == 1) return s;\\n        vector<string>v(numRows, \"\");\\n        int d = 1;\\n        int row = 0;\\n        for(auto c: s){\\n            v[row].push_back(c);\\n            row += d;\\n            if(row == numRows - 1) d = -1;\\n            if(row == 0) d = 1;\\n        }\\n        string res;\\n        for(auto x: v) res.append(x);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802,
                "title": "clean-ac-java-solution-very-short",
                "content": "    public class Solution {\\n        public String convert(String s, int numRows) {\\n            if (s == null || s.length() == 0 || s.length() <= numRows || numRows == 1) return s;\\n            List<List<Character>> resList = new ArrayList<List<Character>>();\\n            for (int i = 0; i < numRows; i++) {\\n                resList.add(new ArrayList<Character>());\\n            }\\n            for (int i = 0; i < s.length(); i++) {\\n                int indexInGroup = i % (2 * numRows - 2);\\n                int indexInList = indexInGroup < numRows ? indexInGroup : 2 * numRows - 2 - indexInGroup;\\n                resList.get(indexInList).add(s.charAt(i));\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            for (List<Character> list : resList) {\\n                for (Character c : list) {\\n                    sb.append(c);\\n                }\\n            }\\n            return sb.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String convert(String s, int numRows) {\\n            if (s == null || s.length() == 0 || s.length() <= numRows || numRows == 1) return s;\\n            List<List<Character>> resList = new ArrayList<List<Character>>();\\n            for (int i = 0; i < numRows; i++) {\\n                resList.add(new ArrayList<Character>());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3928,
                "title": "my-simple-java-solution",
                "content": "    public class Solution {\\n        public String convert(String s, int nRows) {\\n            \\n            if(nRows <=1)\\n                return s;\\n           \\n           StringBuilder[] r = new StringBuilder[nRows];\\n           for( int i=0; i<nRows; i++ )\\n               r[i] = new StringBuilder();\\n           \\n            int base = nRows+nRows-2;\\n            char[] toks = s.toCharArray();\\n            for(int i = 0; i < toks.length; i++)\\n            {\\n                int t = i % base;\\n                if(t < nRows)\\n                {\\n                    r[t].append(toks[i]);\\n                }\\n                else\\n                {\\n                    r[base-t].append(toks[i]);\\n                }\\n            }\\n            \\n            for( int i = 1; i<nRows; i++ )\\n                r[0].append( r[i] );\\n            return r[0].toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String convert(String s, int nRows) {\\n            \\n            if(nRows <=1)\\n                return s;\\n           \\n           StringBuilder[] r = new StringBuilder[nRows];\\n           for( int i=0; i<nRows; i++ )\\n               r[i] = new StringBuilder();\\n           \\n            int base = nRows+nRows-2;\\n            char[] toks = s.toCharArray();\\n            for(int i = 0; i < toks.length; i++)\\n            {\\n                int t = i % base;\\n                if(t < nRows)\\n                {\\n                    r[t].append(toks[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3137493,
                "title": "easy-to-unerstand-c-code-100-fast",
                "content": "# Intuition\\nJust create a vector of strings and make the zigzag patter in that vector, after doing that we just need to append those stings and return the ans.\\n\\n# Approach\\ncreate a vector of strings,use a while loop to iterate over the string\\nin first itteration just keep adding the character from the string to respective string in the vector i.e v[i].push_back(s[a]),a++ (where i is the number of rows in incresing order and a is the current character),\\nin the same while loop we itterate string again but from the back from\\nn-2 t0 1 (i--),and add this character to their respective string i.e \\nv[i].push_back(s[a]),a++ .on all these loops we add a condition on iterator over string to not go over s.lenth(),if iterator goes over s.length() we break the loop and return string ans. \\n\\n# Complexity\\n- Time complexity:\\no(n);\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        \\n     vector <string> v(numRows);\\n\\n    int n=s.length();\\n    int a=0;\\n    if(numRows==1){\\n        return s;\\n    }\\n    while(a<n){\\n    \\n    for(int i=0;i<numRows;i++){\\n        if(a<n){v[i].push_back(s[a]);\\n        a++;\\n        }else{\\n            break;\\n        }\\n    }\\n    for(int i=numRows-2;i>0;i--){\\n     if(a<n){\\n         v[i].push_back(s[a]);\\n     a++;\\n     }else{\\n         break;\\n     }\\n    }\\n    }\\n    string ans=\"\";\\n\\n    for(int i=0;i<v.size();i++){\\n        for(int j=0;j<v[i].size();j++){\\n            ans.push_back(v[i][j]);\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        \\n     vector <string> v(numRows);\\n\\n    int n=s.length();\\n    int a=0;\\n    if(numRows==1){\\n        return s;\\n    }\\n    while(a<n){\\n    \\n    for(int i=0;i<numRows;i++){\\n        if(a<n){v[i].push_back(s[a]);\\n        a++;\\n        }else{\\n            break;\\n        }\\n    }\\n    for(int i=numRows-2;i>0;i--){\\n     if(a<n){\\n         v[i].push_back(s[a]);\\n     a++;\\n     }else{\\n         break;\\n     }\\n    }\\n    }\\n    string ans=\"\";\\n\\n    for(int i=0;i<v.size();i++){\\n        for(int j=0;j<v[i].size();j++){\\n            ans.push_back(v[i][j]);\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133953,
                "title": "c-video-solution",
                "content": "# Intuition & Approach\\nhttps://youtu.be/eulmedmDLGw\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if (numRows == 1)\\n            return s;\\n        \\n        vector<string> rows(numRows);\\n        bool moveDown = true;\\n        int rowIdx = 0;\\n        \\n        for (auto &ch : s) {\\n            rows[rowIdx] += ch;\\n            \\n            if (rowIdx == numRows - 1)\\n                moveDown = false;\\n            else if (rowIdx == 0)\\n                moveDown = true;\\n\\n            rowIdx += (moveDown ? 1 : -1);\\n        }\\n\\n        string ret = \"\";\\n        for (int i = 0; i < numRows; ++i)\\n            ret += rows[i];\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if (numRows == 1)\\n            return s;\\n        \\n        vector<string> rows(numRows);\\n        bool moveDown = true;\\n        int rowIdx = 0;\\n        \\n        for (auto &ch : s) {\\n            rows[rowIdx] += ch;\\n            \\n            if (rowIdx == numRows - 1)\\n                moveDown = false;\\n            else if (rowIdx == 0)\\n                moveDown = true;\\n\\n            rowIdx += (moveDown ? 1 : -1);\\n        }\\n\\n        string ret = \"\";\\n        for (int i = 0; i < numRows; ++i)\\n            ret += rows[i];\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133912,
                "title": "python3-c-generate-row-pattern-and-merge-array",
                "content": "**Python3**\\n\\nGenerate the row number pattern for the string which is ... fwd, rev, fwd, etc\\n0,1,2...n, [n-1, ... 1],0,1,2,3  .. n\\n```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        rr = range(numRows)\\n        pattern = list(rr) + list(range(numRows-2, 0, -1))\\n        times = math.ceil(len(s)/len(pattern))\\n        patterns = pattern*times\\n        \\n        arr = [\"\" for _ in rr] \\n\\n        for a,b in zip(patterns, s):\\n            arr[a] += b\\n        \\n        return \"\".join(arr)\\n```\\n**C++**\\n\\nA slighly different solution but depending on the same logic of patterns fwd,rev, etc\\n\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        int S = s.length(), index = 0, alen = S > numRows ? S : numRows, direction=1; \\n        string vs[alen+1], ans;\\n        \\n        for (int i = 0; i < S; i++) {\\n            vs[index] += s[i];\\n            if (index == numRows-1 || index == 0) {\\n                direction = 1 - direction;\\n            }\\n            if (!direction) {\\n                index += 1;\\n            } else { \\n                index -= 1;\\n            }\\n            \\n        }\\n        for (int i = 0; i <= alen; i++) {\\n            ans += vs[i];\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        rr = range(numRows)\\n        pattern = list(rr) + list(range(numRows-2, 0, -1))\\n        times = math.ceil(len(s)/len(pattern))\\n        patterns = pattern*times\\n        \\n        arr = [\"\" for _ in rr] \\n\\n        for a,b in zip(patterns, s):\\n            arr[a] += b\\n        \\n        return \"\".join(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051666,
                "title": "easy-to-understand-just-do-zigzag-traversal-o-n-time",
                "content": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        StringBuilder[] sb = new StringBuilder[numRows];\\n        for(int i = 0; i < numRows; i++)\\n            sb[i] = new StringBuilder();\\n        \\n        int i = 0, n = s.length();\\n        while(i < n) {\\n            for(int j = 0; j < numRows && i < n; j++)\\n                sb[j].append(s.charAt(i++));\\n            for(int j = numRows - 2; j > 0 && i < n; j--)\\n                sb[j].append(s.charAt(i++));\\n        }\\n        \\n        return String.join(\"\", sb);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        StringBuilder[] sb = new StringBuilder[numRows];\\n        for(int i = 0; i < numRows; i++)\\n            sb[i] = new StringBuilder();\\n        \\n        int i = 0, n = s.length();\\n        while(i < n) {\\n            for(int j = 0; j < numRows && i < n; j++)\\n                sb[j].append(s.charAt(i++));\\n            for(int j = numRows - 2; j > 0 && i < n; j--)\\n                sb[j].append(s.charAt(i++));\\n        }\\n        \\n        return String.join(\"\", sb);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010621,
                "title": "normal-c-implementation",
                "content": "Video Link - https://youtu.be/l-IyeXhawUY\\n\\n```\\n/*n=numRows\\n\\u0394=2n-2    1                           2n-1                         4n-3\\n\\u0394=        2                     2n-2  2n                    4n-4   4n-2\\n\\u0394=        3               2n-3        2n+1              4n-5       .\\n\\u0394=        .           .               .               .            .\\n\\u0394=        .       n+2                 .           3n               .\\n\\u0394=        n-1 n+1                     3n-3    3n-1                 5n-5\\n\\u0394=2n-2    n                           3n-2                         5n-4\\n*/\\n```\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<string> v(numRows, \"\");\\n        int i =0;\\n        int n = s.length();\\n        while(i<n){\\n            \\n            for(int j =0; j<numRows && i<n; j++ ){\\n                v[j].push_back(s[i++]);\\n            }\\n            \\n            for(int j =numRows-2; j>=1 && i<n; j--){\\n                v[j].push_back(s[i++]);\\n            }\\n        }\\n        \\n        string res =\"\";\\n        for(auto i : v){\\n            res+=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*n=numRows\\n\\u0394=2n-2    1                           2n-1                         4n-3\\n\\u0394=        2                     2n-2  2n                    4n-4   4n-2\\n\\u0394=        3               2n-3        2n+1              4n-5       .\\n\\u0394=        .           .               .               .            .\\n\\u0394=        .       n+2                 .           3n               .\\n\\u0394=        n-1 n+1                     3n-3    3n-1                 5n-5\\n\\u0394=2n-2    n                           3n-2                         5n-4\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<string> v(numRows, \"\");\\n        int i =0;\\n        int n = s.length();\\n        while(i<n){\\n            \\n            for(int j =0; j<numRows && i<n; j++ ){\\n                v[j].push_back(s[i++]);\\n            }\\n            \\n            for(int j =numRows-2; j>=1 && i<n; j--){\\n                v[j].push_back(s[i++]);\\n            }\\n        }\\n        \\n        string res =\"\";\\n        for(auto i : v){\\n            res+=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936825,
                "title": "easy-o-n-js-solution",
                "content": "```\\nvar convert = function(s, numRows) {\\n    // We go down row by row and come back up row by row \\n    // We repeat this process until we have visited all letters\\n    let matrix = new Array(numRows).fill(\"\");\\n    let idx = 0;\\n    while (idx < s.length) {\\n        for (let i = 0; i < numRows; i++) { // appends the vertical letters\\n            if (idx >= s.length) break;\\n            matrix[i] += s[idx];\\n            idx++;\\n        }\\n        for (let i = numRows-2; i > 0; i--) { // append the letters in diagonal except the top and bottom (which have already been appended by the previous for loop)\\n            if (idx >= s.length) break;\\n            matrix[i] += s[idx];\\n            idx++;\\n        }       \\n    }\\n    return matrix.join(\"\");\\n    // Time Complexity: O(N), N = length of s\\n    // Space Complexity: O(N), matrix contains N elements\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar convert = function(s, numRows) {\\n    // We go down row by row and come back up row by row \\n    // We repeat this process until we have visited all letters\\n    let matrix = new Array(numRows).fill(\"\");\\n    let idx = 0;\\n    while (idx < s.length) {\\n        for (let i = 0; i < numRows; i++) { // appends the vertical letters\\n            if (idx >= s.length) break;\\n            matrix[i] += s[idx];\\n            idx++;\\n        }\\n        for (let i = numRows-2; i > 0; i--) { // append the letters in diagonal except the top and bottom (which have already been appended by the previous for loop)\\n            if (idx >= s.length) break;\\n            matrix[i] += s[idx];\\n            idx++;\\n        }       \\n    }\\n    return matrix.join(\"\");\\n    // Time Complexity: O(N), N = length of s\\n    // Space Complexity: O(N), matrix contains N elements\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 649837,
                "title": "java-solution-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/chuanqiu/image_1590340999.png)\\n\\n```\\n/*\\nmain idea: build number = numRows array to store each line of s; then put them together.\\nkey : do \"Z\" type order; by set  a direction variable, when i is 0 or numRows-1 for array[i], change direction(-direction);\\n\\n*/\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if(s==null ||s.length()==0||numRows <2) return s;\\n        //store each row char\\n        StringBuilder[] array = new StringBuilder[numRows];\\n        for(int i = 0; i<array.length; i++){\\n            array[i] = new StringBuilder();            \\n        }\\n        \\n        //do z type order\\n        int direction = 1;//initial increase order\\n        int index = 0; //index of different arrays\\n        for(char ch : s.toCharArray()){//traverse each char of s\\n            array[index].append(ch);\\n            index += direction;\\n            if(index ==0 || index == numRows -1) direction = -direction;// if need to change dir\\n        }\\n        //connect in order \\n        StringBuilder res = new StringBuilder();\\n        for(int j =0 ;j< array.length;j++) res.append(array[j]);\\n        \\n        return res.toString() ;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nmain idea: build number = numRows array to store each line of s; then put them together.\\nkey : do \"Z\" type order; by set  a direction variable, when i is 0 or numRows-1 for array[i], change direction(-direction);\\n\\n*/\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if(s==null ||s.length()==0||numRows <2) return s;\\n        //store each row char\\n        StringBuilder[] array = new StringBuilder[numRows];\\n        for(int i = 0; i<array.length; i++){\\n            array[i] = new StringBuilder();            \\n        }\\n        \\n        //do z type order\\n        int direction = 1;//initial increase order\\n        int index = 0; //index of different arrays\\n        for(char ch : s.toCharArray()){//traverse each char of s\\n            array[index].append(ch);\\n            index += direction;\\n            if(index ==0 || index == numRows -1) direction = -direction;// if need to change dir\\n        }\\n        //connect in order \\n        StringBuilder res = new StringBuilder();\\n        for(int j =0 ;j< array.length;j++) res.append(array[j]);\\n        \\n        return res.toString() ;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753,
                "title": "12-lines-concise-and-easy-understand-c-solution",
                "content": "    class Solution {\\n    public:\\n        string convert(string s, int numRows) {\\n            string strs[numRows];\\n            if(numRows <= 1) return s;\\n            int row = 0, step = 1;\\n            for(int i = 0 ; i < s.size(); i++){\\n                strs[row].push_back(s[i]);\\n                if(row == numRows - 1) step = -1;\\n                if(row == 0) step = 1;\\n                row += step;\\n            }\\n            string res = \"\";\\n            for(auto str : strs) res = res + str;\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string convert(string s, int numRows) {\\n            string strs[numRows];\\n            if(numRows <= 1) return s;\\n            int row = 0, step = 1;\\n            for(int i = 0 ; i < s.size(); i++){\\n                strs[row].push_back(s[i]);\\n                if(row == numRows - 1) step = -1;\\n                if(row == 0) step = 1;\\n                row += step;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3799,
                "title": "my-python-solution",
                "content": "    def convert(self, s, numRows):\\n        if numRows <= 1:\\n            return s\\n\\n        lines = [\"\" for i in range(numRows)]\\n        index, step = 0, 1\\n\\n        for i in s:\\n            lines[index] += i\\n            index += step\\n            if index == 0 or index == numRows - 1:\\n                step = -step\\n        \\n        return \"\".join(lines)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def convert(self, s, numRows):\\n        if numRows <= 1:\\n            return s\\n\\n        lines = [\"\" for i in range(numRows)]\\n        index, step = 0, 1\\n\\n        for i in s:\\n            lines[index] += i\\n            index += step\\n            if index == 0 or index == numRows - 1:\\n                step = -step\\n        \\n        return \"\".join(lines)",
                "codeTag": "Python3"
            },
            {
                "id": 3805,
                "title": "sharing-a-pretty-easy-java-solution",
                "content": "    public String convert(String s, int numRows) {\\n            StringBuilder res = new StringBuilder();\\n            StringBuilder[] sb = new StringBuilder[numRows];\\n            for(int i=0;i<sb.length;i++)    sb[i] = new StringBuilder();\\n            int i=0;\\n            while(i<s.length()){\\n                for(int n=0;n<numRows&&i<s.length();n++) sb[n].append(s.charAt(i++));\\n                for(int n=0;n<numRows-2&&i<s.length();n++)    sb[numRows-2-n].append(s.charAt(i++));\\n            }\\n            for(StringBuilder b: sb)    res.append(b);\\n            return res.toString();\\n        }\\nUnlike normal solution with i+=(numRows-i)*2-2 through line by line foreach i in numRows-1, but also with the last need to be the same gap as first line, this solution traverse as the order of input, and create a StringBuilder array for it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String convert(String s, int numRows) {\\n            StringBuilder res = new StringBuilder();\\n            StringBuilder[] sb = new StringBuilder[numRows];\\n            for(int i=0;i<sb.length;i++)    sb[i] = new StringBuilder();\\n            int i=0;\\n            while(i<s.length()){\\n                for(int n=0;n<numRows&&i<s.length();n++) sb[n].append(s.charAt(i++));\\n                for(int n=0;n<numRows-2&&i<s.length();n++)    sb[numRows-2-n].append(s.charAt(i++));\\n            }\\n            for(StringBuilder b: sb)    res.append(b);\\n            return res.toString();\\n        }\\nUnlike normal solution with i+=(numRows-i)*2-2 through line by line foreach i in numRows-1, but also with the last need to be the same gap as first line, this solution traverse as the order of input, and create a StringBuilder array for it.",
                "codeTag": "Unknown"
            },
            {
                "id": 3852,
                "title": "simpe-accepted-java-code",
                "content": "        public class Solution {\\n        public String convert(String s, int numRows) {\\n            String []lines=new String[numRows];\\n    \\t\\tfor (int i=0;i<numRows;i++){\\n    \\t\\t\\tlines[i]=\"\";\\n    \\t\\t}\\n    \\t\\tchar []a=s.toCharArray();\\n    \\t\\tint dir=-1;\\n    \\t\\tint row=0;\\n    \\t\\tfor (int i=0;i<a.length;i++){\\n    \\t\\t\\tlines[row]+=a[i];\\n    \\t\\t\\tif(row==0 || row==numRows-1)\\n    \\t\\t\\t\\tdir*=-1;\\n    \\t\\t\\trow+=dir;\\n    \\t\\t\\trow%=numRows;\\n    \\t\\t}\\n    \\t\\t\\t\\n    \\t\\tString res=\"\";\\n    \\t\\tfor (String line : lines)\\n    \\t\\t\\tres+=line;\\n    \\t\\treturn res;\\n    \\t\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String convert(String s, int numRows) {\\n            String []lines=new String[numRows];\\n    \\t\\tfor (int i=0;i<numRows;i++){\\n    \\t\\t\\tlines[i]=\"\";\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3882,
                "title": "simple-intuitive-c-code",
                "content": "the idea behind the code is very intuitive and easy to understand: store every character zigzagly in an array of strings which represent different rows. more importantly, you don't have to draw several cases to find the pattern. the down side is that it uses some extra space. but still O(n) space\\n\\n    class Solution {\\n    public:\\n        string convert(string s, int numRows) {\\n            if (s == \"\" || numRows == 1) return s;\\n            vector<string> vecstr(numRows);\\n            string res;\\n            int bounce = 0, direct = 1;\\n            for (int i = 0; i<=s.size()-1; ++i) {\\n                vecstr[bounce].push_back(s[i]);\\n                if (bounce == numRows-1) direct = -1;\\n                else if (bounce == 0) direct = 1;\\n                bounce += direct;\\n            }\\n            for (int i = 0; i<=numRows-1; ++i) res += vecstr[i];\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string convert(string s, int numRows) {\\n            if (s == \"\" || numRows == 1) return s;\\n            vector<string> vecstr(numRows);\\n            string res;\\n            int bounce = 0, direct = 1;\\n            for (int i = 0; i<=s.size()-1; ++i) {\\n                vecstr[bounce].push_back(s[i]);\\n                if (bounce == numRows-1) direct = -1;\\n                else if (bounce == 0) direct = 1;\\n                bounce += direct;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3881,
                "title": "fast-and-simple-solution-in-c-o-n-22ms",
                "content": "    ///nRows:2\\n    ///1,   3,  5   step: 2\\n    ///2,   4,  6   step: 2\\n    ///\\n    ///nRows:3\\n    ///1,       5,      9   step:   4\\n    ///2,   4,  6,  8,  10  step:2      2\\n    ///3,       7,      11  step:   4\\n    ///\\n    ///nRows:4\\n    ///1,           7,          13  step:   6\\n    ///2,       6,  8,      12, 14  step:4      2\\n    ///3,   5       9,  11,     15  step:2      4\\n    ///4,           10,         16  step:   6\\n    ///\\n    ///nRows:5\\n    ///1,               9,              17  step:   8\\n    ///2,           8,  10,         16, 18  step:6      2\\n    ///3,       7,      11,     15,     19  step:4      4\\n    ///4,   6,          12, 14,         20  step:2      6\\n    ///5,               13,             21  step:    8\\n    ///\\n    class Solution {\\n    public:\\n        string convert(string s, int nRows) {\\n            size_t len = s.size();\\n            if (nRows <= 1 || nRows >= len) { // Handle Special Case.\\n                return s;\\n            }\\n            const char* str = s.c_str();\\n            string* retval = new string();\\n            size_t maxStep = (nRows - 1) * 2;\\n            for (int r = 0; r < nRows; ++r) {\\n                size_t pos = r;\\n                if (0 == r || nRows - 1 == r) { // First Row And Last Row.\\n                    while (pos < len) {\\n                        retval->push_back(str[pos]);\\n                        pos += maxStep;\\n                    }\\n                } else { // Rows In The Middle.\\n                    size_t step = 2 * r;\\n                    while (pos < len) {\\n                        retval->push_back(str[pos]);\\n                        step = maxStep - step;\\n                        pos += step;\\n                    }\\n                }\\n            }\\n            return *retval;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string convert(string s, int nRows) {\\n            size_t len = s.size();\\n            if (nRows <= 1 || nRows >= len) { // Handle Special Case.\\n                return s;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3734,
                "title": "c-solution-with-expl-on-memory-limit-exceeded-error-many-of-you-might-come-across",
                "content": " The cycle is 2*nRow -2.\\n Then from row to row, get the char with the cycle and also read the in-between char\\n\\n For example, ith row, the first value is s[i], the next should be s[i+cycle], then find the middle char, from the current index j,  j-i returns to the 0th row, and j-i +cycle get the next point at the 0th row, this value minus i will give the middle index,  so it is j+cycle -2*i\\n\\nNote: the memory limit exceeded error, is caused by the corner situation, where cycle=1. Pitch this out first.\\n\\n\\n\\n  \\n\\n     string convert(string s, int nRows) {\\n            \\n            int cycle=2*nRows -2;\\n            // pop the cycle=1 situation\\n            if(cycle<2)\\n            {\\n                return s;\\n            }\\n            string res;\\n            \\n            for(int i=0;i<nRows;++i)\\n            {\\n                for(int j=i;j<s.size();j+=cycle)\\n                {\\n                    res.push_back(s[j]);\\n                    \\n                    if(i>0 && i!=nRows-1 && (j+cycle-2*i <s.size()))\\n                    {\\n                        res.push_back(s[j+cycle-2*i]);\\n                    }\\n                }\\n                \\n            }\\n            \\n            return res;\\n            \\n        }",
                "solutionTags": [],
                "code": " The cycle is 2*nRow -2.\\n Then from row to row, get the char with the cycle and also read the in-between char\\n\\n For example, ith row, the first value is s[i], the next should be s[i+cycle], then find the middle char, from the current index j,  j-i returns to the 0th row, and j-i +cycle get the next point at the 0th row, this value minus i will give the middle index,  so it is j+cycle -2*i\\n\\nNote: the memory limit exceeded error, is caused by the corner situation, where cycle=1. Pitch this out first.\\n\\n\\n\\n  \\n\\n     string convert(string s, int nRows) {\\n            \\n            int cycle=2*nRows -2;\\n            // pop the cycle=1 situation\\n            if(cycle<2)\\n            {\\n                return s;\\n            }\\n            string res;\\n            \\n            for(int i=0;i<nRows;++i)\\n            {\\n                for(int j=i;j<s.size();j+=cycle)\\n                {\\n                    res.push_back(s[j]);\\n                    \\n                    if(i>0 && i!=nRows-1 && (j+cycle-2*i <s.size()))\\n                    {\\n                        res.push_back(s[j+cycle-2*i]);\\n                    }\\n                }\\n                \\n            }\\n            \\n            return res;\\n            \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 4025,
                "title": "a-double-for-loop-code-with-o-n",
                "content": "seemd to be optimal, any comments?    \\n\\n\\n    public class Solution {\\n            public String convert(String s, int nRows) {\\n                int n = s.length();\\n                String str = new String();\\n                str=\"\";\\n                int space1 = 2*(nRows-1);\\n                int space2 =space1;\\n                if(nRows==1)\\n                return s;\\n                \\n                for(int i=0;i<nRows;i++){\\n                    for(int j=i;j<n;j=j+space1){\\n                        str+=s.charAt(j);\\n                        if(j+space2<n&&space2<space1&&space2>0)\\n                        str+=s.charAt(j+space2);\\n                    }\\n                    \\n                    space2-=2;\\n                    \\n                }\\n                \\n                return str;    \\n                    \\n                \\n                \\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public String convert(String s, int nRows) {\\n                int n = s.length();\\n                String str = new String();\\n                str=\"\";\\n                int space1 = 2*(nRows-1);\\n                int space2 =space1;\\n                if(nRows==1)\\n                return s;\\n                \\n                for(int i=0;i<nRows;i++){\\n                    for(int j=i;j<n;j=j+space1){\\n                        str+=s.charAt(j);\\n                        if(j+space2<n&&space2<space1&&space2>0)\\n                        str+=s.charAt(j+space2);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3994,
                "title": "expected-output-of-abcde-4",
                "content": "Hi,\\n   In the Zig Zag problem the expected output for ABCDE,4 is given as ABCED but I feel that it should be AEBCD. Could someone help me with this? Can someone clarify how to deal with even and odd number of rows? My Approach to the question is to make a matrix of the positions and then \"string\" them together.\\nSo for example if the input is `ABC,2` the matrix structure is expected to look like:\\n\\n     0  1\\n    0 A C\\n    1 B <blank>\\n\\nAlso in the example, `PAYPALISHIRING,3` stated in the problem itself, can be visualized as \\n\\n         0 1 2 3 4 5 6 \\n       0 P   A   H   N\\n       1 A P L S I I G\\n       2 Y   I   R\\n\\nMy question is in the even columns (0 ,2,4 etc) the number of entries is fixed by the second argument of the problem. Whereas the entries in the odd columns(1,3 etc) is ambiguous to me. In the above example the first P is placed at location (1,1) the other slots are blank.\\n\\nIf the same test case were to be modified as `PAYPALISHIRING,4` How would the matrix look like?\\n\\n         0 1 2 3 4 5 6 \\n       0 P ?  \\n       1 A ?\\n       2 Y ? \\n       3 P ?\\n\\nWhere would the next character come? Where would the blank spaces come? How is that decision made? Or is this a cumbersome approach?",
                "solutionTags": [],
                "code": "Hi,\\n   In the Zig Zag problem the expected output for ABCDE,4 is given as ABCED but I feel that it should be AEBCD. Could someone help me with this? Can someone clarify how to deal with even and odd number of rows? My Approach to the question is to make a matrix of the positions and then \"string\" them together.\\nSo for example if the input is `ABC,2` the matrix structure is expected to look like:\\n\\n     0  1\\n    0 A C\\n    1 B <blank>\\n\\nAlso in the example, `PAYPALISHIRING,3` stated in the problem itself, can be visualized as \\n\\n         0 1 2 3 4 5 6 \\n       0 P   A   H   N\\n       1 A P L S I I G\\n       2 Y   I   R\\n\\nMy question is in the even columns (0 ,2,4 etc) the number of entries is fixed by the second argument of the problem. Whereas the entries in the odd columns(1,3 etc) is ambiguous to me. In the above example the first P is placed at location (1,1) the other slots are blank.\\n\\nIf the same test case were to be modified as `PAYPALISHIRING,4` How would the matrix look like?\\n\\n         0 1 2 3 4 5 6 \\n       0 P ?  \\n       1 A ?\\n       2 Y ? \\n       3 P ?\\n\\nWhere would the next character come? Where would the blank spaces come? How is that decision made? Or is this a cumbersome approach?",
                "codeTag": "Unknown"
            },
            {
                "id": 4051564,
                "title": "simple-o-n-python-solution-for-zigzag-strings",
                "content": "# Intuition\\nThink of it like bouncing a ball: it goes down, hits the floor, and bounces back up. This is like our zigzag pattern with the string.\\n\\n# Approach\\n1. If we only have one row or more rows than letters, just give back the original word.\\n2. I used a jump thing to know if I should go up or down. If I\\'m at the top, I\\'ll go down. If I\\'m at the bottom, I\\'ll go up.\\n3. For each letter in the word, I put it in the right row and then decide if I should move up or down next.\\n4. After placing all the letters, I put all the rows together for the final word.\\n\\n# Complexity\\n- Time complexity:\\nIt\\'s pretty quick. It goes through the word once, so $$O(n)$$.\\n\\n- Space complexity:\\nI saved space. I only made room for the letters in the word, so $$O(n)$$ space.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        if numRows == 1 or numRows >= len(s):\\n            return s\\n        result = [\\'\\'] * numRows\\n        row, jump = 0, 1\\n\\n        for char in s:\\n            result[row] += char\\n            if row == 0:\\n                jump = 1\\n            elif row == numRows - 1:\\n                jump = -1\\n            row += jump\\n        \\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        if numRows == 1 or numRows >= len(s):\\n            return s\\n        result = [\\'\\'] * numRows\\n        row, jump = 0, 1\\n\\n        for char in s:\\n            result[row] += char\\n            if row == 0:\\n                jump = 1\\n            elif row == numRows - 1:\\n                jump = -1\\n            row += jump\\n        \\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136657,
                "title": "java-solution-simple-logic-runtime-7ms",
                "content": "# Approach\\nI follows simple logic to iterate over the string and store the characters in a ZigZag way. \\nMeaning : We will take an array of size `numRows` and we will store each characters in each of the array element by traversing the array in a top to down and vice-versa manner. \\n\\nExample : \\n\\n`string` : PAYPALISHIRING\\n`numRows` : 3\\n\\n\\nWe will store as :\\n`0th Index`:PAHN\\n`1st Index`:APLSIIG\\n`2nd Index`:YIR\\n\\nWe will iterate over the array as : 0,1,2,1,0,1,2,1,0,1,2,......\\n\\nThen by appending all the string elements, we\\'ll get our answer.\\nIn the program, I have used StringBuilder which is better than simple string concatenation.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        StringBuilder[] arr = new StringBuilder[numRows];\\n        int k = 0;\\n        boolean mode = true;\\n        for(int i = 0; i < numRows; i++){\\n            arr[i] = new StringBuilder(\"\");\\n        }\\n        for(int j = 0; j < s.length(); j++){\\n            if(mode){\\n                arr[k++].append(s.charAt(j));\\n            }\\n            else{\\n                arr[k--].append(s.charAt(j));\\n            }\\n            if(k == numRows){\\n                k = numRows - 2;\\n                mode = false;\\n            }\\n            if(k == -1){\\n                k = (k+2) % numRows;\\n                mode = true;\\n            }\\n        }\\n        StringBuilder ans = new StringBuilder(\"\");\\n        for(StringBuilder i : arr){\\n            ans.append(i.toString());\\n        }\\n        return ans.toString();\\n    }\\n}\\n\\n```\\n\\nI hope my approach is clear :)\\n\\nDo suggest me If any improvements or better approach is possible.\\n\\nThank You\\n\\n\\nPLEASE DO UPVOTE!! :)\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        StringBuilder[] arr = new StringBuilder[numRows];\\n        int k = 0;\\n        boolean mode = true;\\n        for(int i = 0; i < numRows; i++){\\n            arr[i] = new StringBuilder(\"\");\\n        }\\n        for(int j = 0; j < s.length(); j++){\\n            if(mode){\\n                arr[k++].append(s.charAt(j));\\n            }\\n            else{\\n                arr[k--].append(s.charAt(j));\\n            }\\n            if(k == numRows){\\n                k = numRows - 2;\\n                mode = false;\\n            }\\n            if(k == -1){\\n                k = (k+2) % numRows;\\n                mode = true;\\n            }\\n        }\\n        StringBuilder ans = new StringBuilder(\"\");\\n        for(StringBuilder i : arr){\\n            ans.append(i.toString());\\n        }\\n        return ans.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026668,
                "title": "readable-java-code",
                "content": "****Bold****# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\npublic String convert(String s, int numRows) {\\n    if(numRows<=1)return s;\\n    StringBuilder[] sb=new StringBuilder[numRows];\\n    for(int i=0;i<sb.length;i++){\\n        sb[i]=new StringBuilder(\"\");//init every sb element *important steps!!!\\n    }\\n    int incre=1;\\n    int index=0;\\n    for(int i=0;i<s.length();i++){\\n        sb[index].append(s.charAt(i));\\n        if(index==0){incre=1;}\\n        if(index==numRows-1){incre=-1;}\\n        index+=incre;\\n    }\\n    String re=\"\";\\n        for(int i=0;i<sb.length;i++){\\n            re+=sb[i];\\n         }\\n        return re.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\npublic String convert(String s, int numRows) {\\n    if(numRows<=1)return s;\\n    StringBuilder[] sb=new StringBuilder[numRows];\\n    for(int i=0;i<sb.length;i++){\\n        sb[i]=new StringBuilder(\"\");//init every sb element *important steps!!!\\n    }\\n    int incre=1;\\n    int index=0;\\n    for(int i=0;i<s.length();i++){\\n        sb[index].append(s.charAt(i));\\n        if(index==0){incre=1;}\\n        if(index==numRows-1){incre=-1;}\\n        index+=incre;\\n    }\\n    String re=\"\";\\n        for(int i=0;i<sb.length;i++){\\n            re+=sb[i];\\n         }\\n        return re.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944737,
                "title": "simple-java-sol",
                "content": "\\n```\\nclass Solution {\\npublic String convert(String s, int numRows) {\\n    if(numRows==1) return s;\\n    int x = 2 * (numRows-1); // distance between pipes |/|/|...\\n    int len = s.length();\\n    char[] c = new char[len];\\n    int k =0;\\n    for(int i=0; i < numRows; i++)\\n    {\\n        for(int j=i;j<len;j=j+x)\\n        {\\n            c[k++] = s.charAt(j);\\n            if(i>0 && i<numRows-1 && j+x-2*i < len)\\n            {\\n                   c[k++] = s.charAt(j+x-2*i); // extra character between pipes\\n            }\\n        }\\n    }\\n    return new String(c);\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic String convert(String s, int numRows) {\\n    if(numRows==1) return s;\\n    int x = 2 * (numRows-1); // distance between pipes |/|/|...\\n    int len = s.length();\\n    char[] c = new char[len];\\n    int k =0;\\n    for(int i=0; i < numRows; i++)\\n    {\\n        for(int j=i;j<len;j=j+x)\\n        {\\n            c[k++] = s.charAt(j);\\n            if(i>0 && i<numRows-1 && j+x-2*i < len)\\n            {\\n                   c[k++] = s.charAt(j+x-2*i); // extra character between pipes\\n            }\\n        }\\n    }\\n    return new String(c);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743573,
                "title": "java-solutions",
                "content": "public class Solution {\\n    public String convert(String s, int nRows) {\\n        String[] helper = new String[nRows];\\n        for (int i = 0; i < nRows; i ++){\\n            helper[i] = \"\";\\n        }\\n        int row = 0;\\n        int delta = 1;\\n        for (int i = 0; i < s.length(); i ++){\\n            char c = s.charAt(i);\\n            helper[row] += c;\\n            if (row == nRows - 1){\\n                delta = -1;\\n            }\\n            else if (row == 0){\\n                delta = 1;\\n            }\\n            row = row + delta;\\n            row = Math.max(0, row);\\n        }//for\\n        String result = \"\";\\n        for (int i = 0; i < nRows && s.length() > 0; i ++){\\n            result += helper[i];\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String convert(String s, int nRows) {\\n        String[] helper = new String[nRows];\\n        for (int i = 0; i < nRows; i ++){\\n            helper[i] = \"\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2401192,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 :- Brute Force, Using Array Of String***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string convert(string str, int numRows) {\\n        \\n        int n = str.size();\\n        \\n        // edge case\\n        \\n        if(numRows == 1)\\n            return str;\\n      \\n        bool down = false;\\n        \\n        vector<string> arr(numRows, \"\");\\n        \\n        int curr_row = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // push into the corresponding row\\n            \\n            arr[curr_row].push_back(str[i]);\\n            \\n            // change the direction\\n            \\n            if(curr_row == 0 || curr_row == numRows - 1)\\n            {\\n                down = !down;\\n            }\\n            \\n            // if down == true, move downward\\n            \\n            if(down)\\n            {\\n                curr_row++;\\n            }\\n            \\n            // if down == false, move upward\\n            \\n            else\\n            {\\n                curr_row--;\\n            }     \\n        }\\n        \\n        // build the res\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < numRows; i++)\\n        {\\n            res += arr[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string str, int numRows) {\\n        \\n        int n = str.size();\\n        \\n        // edge case\\n        \\n        if(numRows == 1)\\n            return str;\\n      \\n        bool down = false;\\n        \\n        vector<string> arr(numRows, \"\");\\n        \\n        int curr_row = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // push into the corresponding row\\n            \\n            arr[curr_row].push_back(str[i]);\\n            \\n            // change the direction\\n            \\n            if(curr_row == 0 || curr_row == numRows - 1)\\n            {\\n                down = !down;\\n            }\\n            \\n            // if down == true, move downward\\n            \\n            if(down)\\n            {\\n                curr_row++;\\n            }\\n            \\n            // if down == false, move upward\\n            \\n            else\\n            {\\n                curr_row--;\\n            }     \\n        }\\n        \\n        // build the res\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < numRows; i++)\\n        {\\n            res += arr[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348327,
                "title": "simple-c-python-java-javascript-here",
                "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2262823,
                "title": "rust-o-n-elevator-thinking-time-100-faster",
                "content": "Think this as an elevator and each row is the floor of a building. Whenever the elevator reaches the top floor or the ground floor, it will redirect. \\n```\\nimpl Solution {\\n pub fn convert(s: String, num_rows: i32) -> String {\\n  let mut floors: Vec<String> = vec![String::from(\"\"); num_rows as usize];\\n\\n  if num_rows < 2 {\\n   return s.into();\\n  }\\n\\n  let mut floor = 0;\\n  let mut down: bool = true;\\n\\n  for c in s.chars() {\\n   floors[floor as usize].push(c);\\n   floor += if down { 1 } else { -1 };\\n   down = down == (floor > 0 && floor < num_rows - 1);\\n  }\\n\\n  floors.concat()\\n }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n pub fn convert(s: String, num_rows: i32) -> String {\\n  let mut floors: Vec<String> = vec![String::from(\"\"); num_rows as usize];\\n\\n  if num_rows < 2 {\\n   return s.into();\\n  }\\n\\n  let mut floor = 0;\\n  let mut down: bool = true;\\n\\n  for c in s.chars() {\\n   floors[floor as usize].push(c);\\n   floor += if down { 1 } else { -1 };\\n   down = down == (floor > 0 && floor < num_rows - 1);\\n  }\\n\\n  floors.concat()\\n }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2082706,
                "title": "c-new-method-easy-to-follow",
                "content": "```\\nPLEASE UPVOTE IF THIS HELPED YOU : )\\n```\\nFor row 1 and row N,  elements are at a difference of 2*(n-1) in terms of index values from the original string.\\ne.g for  numRows = 4 \"PAYPALISHIRING\"\\n```\\n0          6          12\\n1      5   7      11  13\\n2  4       8  10\\n3          9 \\n```\\nAbove is a representation of zig zag pattern in terms of indexes in the provided string.\\n\\nThe difference between columns in a row which do not consist of diagonal elements form a series with a difference of **2*n-1** between each element in series.\\nin above example, the difference between columns which do not contain diagonal elements is:\\n2*(4-1) = 2*3 = 6,  e.g \\n**Row 1**    0,  6(0+6),  12(6+6)\\n**Row 2**   1,  7(1+6),  13(7+6)\\n**Row 3**   2,  8(2+6)\\n\\n\\t\\t \\nNow for diagonal elements, the difference between each diagonal element in a row is\\nalso the same as above , i.e 2*(n-1) \\ne.g For the following diagonal series :\\nIn **row 2** ( 5, 11 ) difference is 6.\\nIn **row 3**  ( 4, 10 ) difference is 6.\\n\\nNow we know that the difference is same for any two consecutive diagonal elements ( 5, 11 in row 2) or non-diagonal elements ( 6, 12 in row 1).\\n\\nThe only thing we need to calculate is the first non diagonal element (like 5 in row 2,  4 in row 3 etc.) This can be calculated by adding the following difference to the first non diagonal element in the row : \\n\\n**(The difference in Non diagonal series(i.e 0,6,12  or 1,7,13 or 2,8) ) - 2*(currentRow - 1)**\\n\\nso for diagonal series in row 1 (i.e 5,11) if we just initialize this row with the first element of this series and keep on adding the diagonal series difference, we will get this series.\\n\\n**So in conclusion what we have to do is :**\\n\\n1) For row 1 and row N, initialize the row with element at index [row-1]\\n2) For other rows , initialize the row with element at index [row -1] and  element at index    [ (row-1) + {(The difference in non diagonal series(i.e 0,6,12  or 1,7,13 or 2,8) ) - 2*(currentRow - 1)} ]\\n3) Now we find add the series difference (2*(n-1)) alternatively to the first(non-diagonal) element and second element\\ne.g for row 2, initialize it with  1 and 5\\n\\t\\t\\tKeep on adding the difference, i.e 6 , first to 1 then to 5\\n\\t\\t\\tWe get, 1,  5,  7(1+6), 11(5+6), 13(7+6)\\n\\n4) Make checks that index dont exceed (Total length - difference)\\n\\n**C++ CODE**\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int n) {\\n        if(n==1 || s.size()<=n || s.size()==1 || s.size()==2){\\n            return s;\\n        }\\n        int l = s.size();\\n        string ans = \"\";\\n        int diff = 2 * (n - 1);\\n\\n        // row loop\\n        for (int i = 1; i <= n; i++)\\n        {\\n            ans.push_back(s[i - 1]);\\n            if (i == 1 || i == n)\\n            {\\n                int x = i - 1;\\n                while (x < l - diff)\\n                {\\n                    x += diff;\\n                    ans.push_back(s[x]);\\n                }\\n            }\\n            else\\n            {\\n                int new_Diff = diff - 2 * (i - 1);\\n                int p1 = i - 1;\\n                int p2 = p1 + new_Diff;\\n                if (p1 > l - 1 || p2 > l - 1)\\n                {\\n                    continue;\\n                }\\n                ans.push_back(s[p2]);\\n                bool flag = true;\\n                while (p2 < l - diff || p1 < l - diff)\\n                {\\n                    if (p1 < l-diff && flag == true)\\n                    {\\n                        p1 += diff;\\n                        ans.push_back(s[p1]);\\n                        flag = false;\\n                    }\\n                    if (p2 < l-diff && flag == false)\\n                    {\\n                        p2 += diff;\\n                        ans.push_back(s[p2]);\\n                        flag = true;\\n                    }\\n                }\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nPLEASE UPVOTE IF THIS HELPED YOU : )\\n```\n```\\n0          6          12\\n1      5   7      11  13\\n2  4       8  10\\n3          9 \\n```\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int n) {\\n        if(n==1 || s.size()<=n || s.size()==1 || s.size()==2){\\n            return s;\\n        }\\n        int l = s.size();\\n        string ans = \"\";\\n        int diff = 2 * (n - 1);\\n\\n        // row loop\\n        for (int i = 1; i <= n; i++)\\n        {\\n            ans.push_back(s[i - 1]);\\n            if (i == 1 || i == n)\\n            {\\n                int x = i - 1;\\n                while (x < l - diff)\\n                {\\n                    x += diff;\\n                    ans.push_back(s[x]);\\n                }\\n            }\\n            else\\n            {\\n                int new_Diff = diff - 2 * (i - 1);\\n                int p1 = i - 1;\\n                int p2 = p1 + new_Diff;\\n                if (p1 > l - 1 || p2 > l - 1)\\n                {\\n                    continue;\\n                }\\n                ans.push_back(s[p2]);\\n                bool flag = true;\\n                while (p2 < l - diff || p1 < l - diff)\\n                {\\n                    if (p1 < l-diff && flag == true)\\n                    {\\n                        p1 += diff;\\n                        ans.push_back(s[p1]);\\n                        flag = false;\\n                    }\\n                    if (p2 < l-diff && flag == false)\\n                    {\\n                        p2 += diff;\\n                        ans.push_back(s[p2]);\\n                        flag = true;\\n                    }\\n                }\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980759,
                "title": "java-c-python-javascript-kotlin-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Java***\\n```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows==1)return s;\\n        StringBuilder builder = new StringBuilder();\\n        for (int i=1;i<=numRows;i++){\\n            int ind = i-1;\\n            boolean up = true;\\n            while (ind < s.length()){\\n                builder.append(s.charAt(ind));\\n                if (i==1){\\n                    ind += 2*(numRows-i);\\n                } else if (i==numRows){\\n                    ind += 2*(i-1);\\n                } else {\\n                    ind += up ? 2*(numRows-i) : 2*(i-1);\\n                    up=!up;\\n                }\\n            }\\n        }\\n        return builder.toString();\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans;\\n        vector <string> tmp(numRows);                                                         //create strings for each row\\n        int i=0, n=s.size();\\n        while(i<n){                                      \\n            for(int j=0;j<numRows && i<n; j++, i++) tmp[j] += s[i];               //add for our strings character when we move down\\n            for(int j=numRows - 2;j>0 && i<n; j--, i++) tmp[j] += s[i];            //add for our strings character when we move up exept first and last string\\n        }\\n        for(int j=0;j<numRows; j++) ans += tmp[j];                                       //combain together our strings\\n        return ans;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        if numRows == 1 or numRows >= len(s):\\n            return s\\n\\n        L = [\\'\\'] * numRows\\n        index, step = 0, 1\\n\\n        for x in s:\\n            L[index] += x\\n            if index == 0:\\n                step = 1\\n            elif index == numRows -1:\\n                step = -1\\n            index += step\\n\\n        return \\'\\'.join(L)\\n```\\n\\n***JavaScript***\\n```\\nvar convert = function(s, numRows) {\\n  let result = [];\\n  let row = 0;\\n  let goingUp = false;\\n  for (let i = 0; i < s.length; i++) {\\n    result[row] = (result[row] || \\'\\') + s[i]; // append letter to active row\\n    if (goingUp) {\\n      row--;\\n      if (row === 0) goingUp = false; // reverse direction if goingUp and reaching top\\n    } else {\\n      row++;\\n      if (row === numRows - 1) goingUp = true; // reverse direction after reaching bottom\\n    }\\n    \\n  }\\n  return result.join(\\'\\');\\n};\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n    fun convert(s: String, numRows: Int): String {\\n    val rows = MutableList(numRows) { \"\" }\\n    var idx = 0\\n    first@ while (true) {\\n        for (iMod in 0 until numRows) {\\n            rows[iMod] = rows[iMod] + s[idx++]\\n            if (idx == s.length) break@first\\n        }\\n        for (iMod in numRows - 2  downTo  1) {\\n            rows[iMod] = rows[iMod] + s[idx++]\\n            if (idx == s.length) break@first\\n        }\\n    }\\n    return rows.joinToString(\"\")\\n}\\n}\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows==1)return s;\\n        StringBuilder builder = new StringBuilder();\\n        for (int i=1;i<=numRows;i++){\\n            int ind = i-1;\\n            boolean up = true;\\n            while (ind < s.length()){\\n                builder.append(s.charAt(ind));\\n                if (i==1){\\n                    ind += 2*(numRows-i);\\n                } else if (i==numRows){\\n                    ind += 2*(i-1);\\n                } else {\\n                    ind += up ? 2*(numRows-i) : 2*(i-1);\\n                    up=!up;\\n                }\\n            }\\n        }\\n        return builder.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans;\\n        vector <string> tmp(numRows);                                                         //create strings for each row\\n        int i=0, n=s.size();\\n        while(i<n){                                      \\n            for(int j=0;j<numRows && i<n; j++, i++) tmp[j] += s[i];               //add for our strings character when we move down\\n            for(int j=numRows - 2;j>0 && i<n; j--, i++) tmp[j] += s[i];            //add for our strings character when we move up exept first and last string\\n        }\\n        for(int j=0;j<numRows; j++) ans += tmp[j];                                       //combain together our strings\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        if numRows == 1 or numRows >= len(s):\\n            return s\\n\\n        L = [\\'\\'] * numRows\\n        index, step = 0, 1\\n\\n        for x in s:\\n            L[index] += x\\n            if index == 0:\\n                step = 1\\n            elif index == numRows -1:\\n                step = -1\\n            index += step\\n\\n        return \\'\\'.join(L)\\n```\n```\\nvar convert = function(s, numRows) {\\n  let result = [];\\n  let row = 0;\\n  let goingUp = false;\\n  for (let i = 0; i < s.length; i++) {\\n    result[row] = (result[row] || \\'\\') + s[i]; // append letter to active row\\n    if (goingUp) {\\n      row--;\\n      if (row === 0) goingUp = false; // reverse direction if goingUp and reaching top\\n    } else {\\n      row++;\\n      if (row === numRows - 1) goingUp = true; // reverse direction after reaching bottom\\n    }\\n    \\n  }\\n  return result.join(\\'\\');\\n};\\n```\n```\\nclass Solution {\\n    fun convert(s: String, numRows: Int): String {\\n    val rows = MutableList(numRows) { \"\" }\\n    var idx = 0\\n    first@ while (true) {\\n        for (iMod in 0 until numRows) {\\n            rows[iMod] = rows[iMod] + s[idx++]\\n            if (idx == s.length) break@first\\n        }\\n        for (iMod in numRows - 2  downTo  1) {\\n            rows[iMod] = rows[iMod] + s[idx++]\\n            if (idx == s.length) break@first\\n        }\\n    }\\n    return rows.joinToString(\"\")\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290602,
                "title": "simple-solution-using-math-observation",
                "content": "Solved using one simple observation about how index should be incremented\\nNo weird cases, no nested if statements, no boolean flags\\n```c++\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string result;\\n        if (numRows == 1){\\n            return s;\\n        }\\n        for (int row = 0; row < numRows; row++){\\n            int i = row;\\n            while (i < s.length()){\\n                result.push_back(s[i]);\\n                i += (numRows - i % (numRows - 1) - 1) * 2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string result;\\n        if (numRows == 1){\\n            return s;\\n        }\\n        for (int row = 0; row < numRows; row++){\\n            int i = row;\\n            while (i < s.length()){\\n                result.push_back(s[i]);\\n                i += (numRows - i % (numRows - 1) - 1) * 2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587347,
                "title": "golang-0ms-faster-than-100-of-submissions",
                "content": "\\n```\\nfunc convert(s string, numRows int) string {\\n\\tif numRows <= 1 {\\n\\t\\treturn s\\n\\t}\\n\\n\\t// character distance between columns\\n\\tcolStep := numRows + numRows - 2\\n\\n\\t// result\\n\\tss := make([]uint8, len(s), len(s))\\n\\t// fill result with dots to make debugging easier\\n\\t//for i := 0; i < len(ss); i++ {\\n\\t//\\tss[i] = \\'.\\'\\n\\t//}\\n\\n\\t// diagStep is distance from column to diagonal value.\\n\\t// Reduces by two for each row\\n\\tdiagStep := colStep - 2\\n\\n\\t// i = position to write to in ss\\n\\ti := 0\\n\\tfor row := 0; row < numRows; row = row + 1 {\\n\\t\\t// does this row have diagonal cells?\\n\\t\\tdiag := row > 0 && row < numRows-1\\n\\t\\tfor j := row; j < len(ss); j += colStep {\\n\\t\\t\\tss[i] = s[j] // column value\\n\\t\\t\\ti += 1\\n\\t\\t\\tif diag && j+diagStep < len(s) {\\n\\t\\t\\t\\tss[i] = s[j+diagStep] // diagonal value\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif diag {\\n\\t\\t\\tdiagStep -= 2\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(ss)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc convert(s string, numRows int) string {\\n\\tif numRows <= 1 {\\n\\t\\treturn s\\n\\t}\\n\\n\\t// character distance between columns\\n\\tcolStep := numRows + numRows - 2\\n\\n\\t// result\\n\\tss := make([]uint8, len(s), len(s))\\n\\t// fill result with dots to make debugging easier\\n\\t//for i := 0; i < len(ss); i++ {\\n\\t//\\tss[i] = \\'.\\'\\n\\t//}\\n\\n\\t// diagStep is distance from column to diagonal value.\\n\\t// Reduces by two for each row\\n\\tdiagStep := colStep - 2\\n\\n\\t// i = position to write to in ss\\n\\ti := 0\\n\\tfor row := 0; row < numRows; row = row + 1 {\\n\\t\\t// does this row have diagonal cells?\\n\\t\\tdiag := row > 0 && row < numRows-1\\n\\t\\tfor j := row; j < len(ss); j += colStep {\\n\\t\\t\\tss[i] = s[j] // column value\\n\\t\\t\\ti += 1\\n\\t\\t\\tif diag && j+diagStep < len(s) {\\n\\t\\t\\t\\tss[i] = s[j+diagStep] // diagonal value\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif diag {\\n\\t\\t\\tdiagStep -= 2\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(ss)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451523,
                "title": "simple-functional-c-solution-with-explanation-o-n",
                "content": "**Code should be self-explanatory, further explanation is below**\\n```\\npublic class Solution {\\n\\n\\t///Generates an infinite sequence oscillating between two numbers\\n\\t///<example>(1,4): [1,2,3,4,3,2,1,2,3,4,...]</example>\\n\\tpublic static IEnumerable<int> InfiniteOscillator(int start, int end)\\n\\t{\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tfor (int i = start; i <= end; i++)  yield return i;   //[start..end]\\n\\t\\t\\tfor (int i = end - 1; i > start; i--) yield return i; //[end-1..start-1], backwards excluding start and end\\n\\t\\t}\\n\\t}\\n\\t\\n\\t//The zigzag pattern moves down the rows to the bottom, then back up to the top and repeats\\n\\t//Capture the pattern for a given rowCount\\n\\tpublic static IEnumerable<int> ZigZagRowIndexGenerator(int rowCount) => InfiniteOscillator(1, rowCount);\\n\\n\\tpublic string Convert(string s, int numRows)\\n\\t{\\n\\t\\t//Generate an infinite sequence representing the row index in the zigzag seqeuence\\n\\t\\t//Example: numRows: 3 -> [1,2,3,2,1,2,3,...]\\n\\t\\tvar rowIndexGenerator = ZigZagRowIndexGenerator(numRows);\\n\\n\\t\\t//For each character, obtain the row index\\n\\t\\t//(\"SUPER\", count: 3) -> [(S,1) (U,2) (P,3) (E,2) (R,1)]\\n\\t\\tvar indexedByRow = s.Zip(rowIndexGenerator, Tuple.Create).ToList();\\n\\n\\t\\t//Bucket the input \\n\\t\\t//[(S,1) (U,2) (P,3) (E,2) (R,1)] -> { 1:[\\'S\\',\\'R\\'], 2:[\\'U\\',\\'E\\'], 3:[\\'P\\'] }\\n\\t\\tvar bucketedByRow = indexedByRow.ToLookup(x => x.Item2, x => x.Item1);\\n\\n\\t\\t//Loop through each of the buckets above and iterate the contents, providing the data in per-row order\\n\\t\\tStringBuilder ret = new StringBuilder();\\n\\t\\tfor(int row = 1; row <= numRows; row++)\\n\\t\\t{\\n\\t\\t    //The characters for the provided row index in original order (or empty if none exist)\\n\\t\\t    char[] charsForRow = bucketedByRow[row].ToArray();\\n\\t\\t\\tret.Append(charsForRow);\\n\\t\\t}\\n\\t\\treturn ret.ToString();\\n\\t\\t//OR:\\n\\t\\t//return new string(Enumerable.Range(1, numRows).SelectMany(x => bucketedByRow[x]).ToArray());\\n\\t}\\n}\\n```\\n\\n**ZigZag Structure**\\nA zigzag is a repeating pattern, its structure only depends on the numRows parameter:\\n\\n**numRows: 3**\\n```\\n1   1   1 \\n2 4 2 4   \\n3   3     \\n```\\n**numRows: 4**\\n```\\n1     1      1\\n2   6 2    6\\n3 5   3  5\\n4     4\\n```\\n----\\n\\nWe can break the pattern down further if we want to obtain the row index of the sequence. It turns out to oscillate from 1..numRows..2\\n\\n**numRows: 3**\\n```\\n1   1   1 \\n2 2 2 2   \\n3   3     \\n```\\n**Repeating: [1,2,3,2]**\\n\\n----\\n\\n**numRows: 4**\\n```\\n1     1      1\\n2   2 2    2\\n3 3   3  3\\n4     4\\n```\\n**Repeating: [1,2,3,4,3,2]**\\n\\n----\\n\\nAssume the sequence above is infinite, if we iterate this at the same time as the string, we get a list of tuples: **[(character, rowIndex)]**\\n\\n**[1,2,3,2,...] + \"SUPER\" -> [(S,1) (U,2) (P,3) (E,2) (R,1)]**\\n\\nNow we want to iterate this collection by the row index, then by the order in the collection to get from **[(S,1) (U,2) (P,3) (E,2) (R,1)]** to **\"SRUEP\"**\\n\\nWe need to perform a sort by row index on the above collection (and the sort must be stable). Comparison-based sorts are O(n log n), but as the number of buckets is small and known, we can use an O(numRows) bucket sort approximation:\\n\\n**[(S,1) (U,2) (P,3) (E,2) (R,1)] -> { 1:[\\'S\\',\\'R\\'], 2:[\\'U\\',\\'E\\'], 3:[\\'P\\'] }**\\n\\nAnd finally, by iterating the buckets in order and combining the results:\\n\\n**(1: \\'S\\' + \\'R\\') + (2: \\'U\\' +\\'E\\') + (3: \\'P\\') -> SRUEP**",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n\\t///Generates an infinite sequence oscillating between two numbers\\n\\t///<example>(1,4): [1,2,3,4,3,2,1,2,3,4,...]</example>\\n\\tpublic static IEnumerable<int> InfiniteOscillator(int start, int end)\\n\\t{\\n\\t\\twhile (true)\\n\\t\\t{\\n\\t\\t\\tfor (int i = start; i <= end; i++)  yield return i;   //[start..end]\\n\\t\\t\\tfor (int i = end - 1; i > start; i--) yield return i; //[end-1..start-1], backwards excluding start and end\\n\\t\\t}\\n\\t}\\n\\t\\n\\t//The zigzag pattern moves down the rows to the bottom, then back up to the top and repeats\\n\\t//Capture the pattern for a given rowCount\\n\\tpublic static IEnumerable<int> ZigZagRowIndexGenerator(int rowCount) => InfiniteOscillator(1, rowCount);\\n\\n\\tpublic string Convert(string s, int numRows)\\n\\t{\\n\\t\\t//Generate an infinite sequence representing the row index in the zigzag seqeuence\\n\\t\\t//Example: numRows: 3 -> [1,2,3,2,1,2,3,...]\\n\\t\\tvar rowIndexGenerator = ZigZagRowIndexGenerator(numRows);\\n\\n\\t\\t//For each character, obtain the row index\\n\\t\\t//(\"SUPER\", count: 3) -> [(S,1) (U,2) (P,3) (E,2) (R,1)]\\n\\t\\tvar indexedByRow = s.Zip(rowIndexGenerator, Tuple.Create).ToList();\\n\\n\\t\\t//Bucket the input \\n\\t\\t//[(S,1) (U,2) (P,3) (E,2) (R,1)] -> { 1:[\\'S\\',\\'R\\'], 2:[\\'U\\',\\'E\\'], 3:[\\'P\\'] }\\n\\t\\tvar bucketedByRow = indexedByRow.ToLookup(x => x.Item2, x => x.Item1);\\n\\n\\t\\t//Loop through each of the buckets above and iterate the contents, providing the data in per-row order\\n\\t\\tStringBuilder ret = new StringBuilder();\\n\\t\\tfor(int row = 1; row <= numRows; row++)\\n\\t\\t{\\n\\t\\t    //The characters for the provided row index in original order (or empty if none exist)\\n\\t\\t    char[] charsForRow = bucketedByRow[row].ToArray();\\n\\t\\t\\tret.Append(charsForRow);\\n\\t\\t}\\n\\t\\treturn ret.ToString();\\n\\t\\t//OR:\\n\\t\\t//return new string(Enumerable.Range(1, numRows).SelectMany(x => bucketedByRow[x]).ToArray());\\n\\t}\\n}\\n```\n```\\n1   1   1 \\n2 4 2 4   \\n3   3     \\n```\n```\\n1     1      1\\n2   6 2    6\\n3 5   3  5\\n4     4\\n```\n```\\n1   1   1 \\n2 2 2 2   \\n3   3     \\n```\n```\\n1     1      1\\n2   2 2    2\\n3 3   3  3\\n4     4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209313,
                "title": "c-o-n-solution-16ms-very-concise",
                "content": "The zigzag print always goes down ```numRows-1``` times and then up ```numRows-1``` times. The next multiple of ```numRows-1``` is the next pivot, so starting from each row, add twice that distance to go to the next character in the row.\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if (numRows == 1) return s;\\n        string ans = \"\";\\n        for (int i=0; i<numRows; i++) {\\n            int j=i;\\n            while (j < s.size()) {\\n                ans.push_back(s[j]);\\n                j += 2*(numRows-1 - (j % (numRows-1)));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```numRows-1```\n```numRows-1```\n```numRows-1```\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if (numRows == 1) return s;\\n        string ans = \"\";\\n        for (int i=0; i<numRows; i++) {\\n            int j=i;\\n            while (j < s.size()) {\\n                ans.push_back(s[j]);\\n                j += 2*(numRows-1 - (j % (numRows-1)));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596,
                "title": "easy-understand-solution-by-python",
                "content": "my python solution\\nidea:\\n```\\n0 _ _ _ _ _ 6     => 6,6,6...\\n_ 1 _ _ _ 5 _ 7  => (6-2), (6-4), (6-2) ...\\n_ _ 2 _ 4 _ _ _ 8 => (6-4), (6-2), (6-4) ...\\n_ _ _ 3 _ _ _ _ _ 9 =>6,6,6,6\\n```\\n```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        strLen = len(s)\\n        if numRows == 1 or strLen == 1 or strLen == 0:\\n            return s\\n\\n        ans = ''\\n        l = 2 * (numRows - 1)\\n        for i in range(numRows):\\n            j = i\\n            r = i * 2\\n            while j < strLen:\\n                ans += s[j]\\n                # first and last\\n                if i == 0 or i == numRows - 1:\\n                    j += l\\n                else:\\n                    r = l - r\\n                    j += r\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n0 _ _ _ _ _ 6     => 6,6,6...\\n_ 1 _ _ _ 5 _ 7  => (6-2), (6-4), (6-2) ...\\n_ _ 2 _ 4 _ _ _ 8 => (6-4), (6-2), (6-4) ...\\n_ _ _ 3 _ _ _ _ _ 9 =>6,6,6,6\\n```\n```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        strLen = len(s)\\n        if numRows == 1 or strLen == 1 or strLen == 0:\\n            return s\\n\\n        ans = ''\\n        l = 2 * (numRows - 1)\\n        for i in range(numRows):\\n            j = i\\n            r = i * 2\\n            while j < strLen:\\n                ans += s[j]\\n                # first and last\\n                if i == 0 or i == numRows - 1:\\n                    j += l\\n                else:\\n                    r = l - r\\n                    j += r\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623,
                "title": "python-solution-o-n-with-picture-to-understand",
                "content": "Hello guys,it's my first time to post my code and  I'd like do something helpful to you  :)\\n\\nAt first, we think about this question. If we paint the characters in our paper one by one, for a certain length and numrows.the showing just like a saw\\n![0_1470974866774_1 (2).png](/uploads/files/1470974871164-1-2.png) \\nIn this picture, every line means a word of output string. and the formulation is about the index and which word the character belongs to.\\n\\nSecondly, we serialize every word to the left and we can draw a saw like this.![0_1470974286263_2.png](/uploads/files/1470974290134-2.png) \\n\\n\\nThirdly,we map each character to wordlist[0->n-1], which means the character belongs to.\\nFor each s'index i, we can mod to (2n-2)  for getting his position to certatin the belonging word.\\n\\nTo certain which word one character belongs to,we should dicuss the different situtation. For the index i, when i<=(n-1), means the direction of i is up to down straightly. Oppositely, when i >(n-1), the i is down to up sideling. But, all we do is get the position of i , so we should do something to distinguish this.\\n\\nThe code like this:\\n```\\np = i%(2*n-2) \\nif p>(n-1): \\n\\tp=(2*n-2)-p                \\nelse: \\n\\tp=p \\n```\\n\\nLastly, we statistics the word list and just output the result is fine.\\nSo, the code will be like this \\n```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        if numRows==1:\\n    \\t\\treturn s\\n    \\tlength=len(s)\\n    \\twordlist=[\"\"]*numRows\\n    \\tcharclass=[0]*length\\n    \\tfor i in range(length):\\n    \\t\\tcharclass[i] = i%(2*numRows-2)\\n    \\t\\tif charclass[i] > numRows-1:\\n    \\t\\t\\tcharclass[i]=2*numRows-2-charclass[i] \\n    \\tfor i in range(length):\\n    \\t\\twordlist[charclass[i]]+=(s[i])\\n    \\treturn \"\".join(wordlist)\\n'''\\n```\\nIt costs some time to think about the arrangement of the characters. But for one thing important is that  when we get the length and numrows, the arrangement is settled.We just to find out the align and mapping information is fine.\\nThe algorithms time complexity is O(N)  and space complexity is O(N) too.",
                "solutionTags": [],
                "code": "```\\np = i%(2*n-2) \\nif p>(n-1): \\n\\tp=(2*n-2)-p                \\nelse: \\n\\tp=p \\n```\n```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        if numRows==1:\\n    \\t\\treturn s\\n    \\tlength=len(s)\\n    \\twordlist=[\"\"]*numRows\\n    \\tcharclass=[0]*length\\n    \\tfor i in range(length):\\n    \\t\\tcharclass[i] = i%(2*numRows-2)\\n    \\t\\tif charclass[i] > numRows-1:\\n    \\t\\t\\tcharclass[i]=2*numRows-2-charclass[i] \\n    \\tfor i in range(length):\\n    \\t\\twordlist[charclass[i]]+=(s[i])\\n    \\treturn \"\".join(wordlist)\\n'''\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601,
                "title": "in-fact-this-is-a-math-problem-java-code",
                "content": "    public String convert(String s, int numRows) {\\n        if (numRows <= 1) {\\n            return s;\\n        }\\n        int n = s.length();\\n        int step = 2 * numRows - 2;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = i; j < n; j += step) {\\n                sb.append(s.charAt(j));\\n                if (i != 0 && i != numRows - 1 && j + step - 2 * i < n) {\\n                    sb.append(s.charAt(j + step - 2 * i));\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }",
                "solutionTags": [],
                "code": "    public String convert(String s, int numRows) {\\n        if (numRows <= 1) {\\n            return s;\\n        }\\n        int n = s.length();\\n        int step = 2 * numRows - 2;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = i; j < n; j += step) {\\n                sb.append(s.charAt(j));\\n                if (i != 0 && i != numRows - 1 && j + step - 2 * i < n) {\\n                    sb.append(s.charAt(j + step - 2 * i));\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3704,
                "title": "7ms-java-solution",
                "content": "    public class Solution {\\n        public String convert(String s, int numRows) {\\n            if (numRows == 1) {\\n                return s;\\n            }\\n            StringBuilder builder = new StringBuilder();\\n            int adder = 2*numRows-2;\\n            for (int i=0; i<s.length(); i+=adder) {\\n                builder.append(s.charAt(i));\\n            }\\n            for (int i=1; i<numRows-1; ++i) {\\n                int j=i;\\n                while(j<s.length()) {\\n                    builder.append(s.charAt(j));\\n                    int next = 2*numRows-2*i-2+j;\\n                    if (next < s.length())\\n                        builder.append(s.charAt(next));\\n                    else {\\n                        break;\\n                    }\\n                    j += adder;\\n                }\\n            }\\n            for (int i=numRows-1; i<s.length(); i+=adder) {\\n                builder.append(s.charAt(i));\\n            }\\n            return builder.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String convert(String s, int numRows) {\\n            if (numRows == 1) {\\n                return s;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3785,
                "title": "my-16ms-c-solution",
                "content": "    string convert(string s, int numRows) {\\n    \\tif(numRows ==1 || numRows> s.size()) return s;\\n\\n    \\tint i=1,j=0,k=0,dis=(numRows-1)*2;\\n    \\tstring res=\"\";\\n    \\n    \\twhile(i<=numRows){\\n    \\t\\tj=i-1;\\n    \\t\\tif(i==numRows||i==1){\\n    \\t\\t\\twhile(j<s.size()){\\n    \\t\\t\\t\\tres += s[j];\\n    \\t\\t\\t\\tj+=dis;\\n    \\t\\t\\t}\\n    \\t\\t\\ti++;\\n    \\t\\t}else{ \\n    \\t\\t\\tk=(i-1)*2;\\n    \\t\\t\\twhile(j<s.size()){\\n    \\t\\t\\t\\tres += s[j];\\n    \\t\\t\\t\\tk = dis-k;\\n    \\t\\t\\t\\tj += k;\\n    \\t\\t\\t}\\n    \\t\\t\\ti++;\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "    string convert(string s, int numRows) {\\n    \\tif(numRows ==1 || numRows> s.size()) return s;\\n\\n    \\tint i=1,j=0,k=0,dis=(numRows-1)*2;\\n    \\tstring res=\"\";\\n    \\n    \\twhile(i<=numRows){\\n    \\t\\tj=i-1;\\n    \\t\\tif(i==numRows||i==1){\\n    \\t\\t\\twhile(j<s.size()){\\n    \\t\\t\\t\\tres += s[j];\\n    \\t\\t\\t\\tj+=dis;\\n    \\t\\t\\t}\\n    \\t\\t\\ti++;\\n    \\t\\t}else{ \\n    \\t\\t\\tk=(i-1)*2;\\n    \\t\\t\\twhile(j<s.size()){\\n    \\t\\t\\t\\tres += s[j];\\n    \\t\\t\\t\\tk = dis-k;\\n    \\t\\t\\t\\tj += k;\\n    \\t\\t\\t}\\n    \\t\\t\\ti++;\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3867,
                "title": "12ms-c-solution-easy-to-understand",
                "content": "    string convert(string s, int numRows) {\\n        std::string ans(s.size(),'0');\\n        char* p = &ans[0];\\n        int part_len = 2*numRows - 2;\\n        if(numRows == 1 || s.size() == 0) return s;\\n        for(int i=0; i<numRows; ++i)\\n        {\\n            if(i == 0 || i == numRows -1)\\n                for(int j=i; j<s.size(); j+= part_len) *(p++) = s[j];\\n            else\\n            {\\n                int offset = 2 * i;\\n                for(int j=i; j<s.size(); offset=part_len-offset,j+= offset) *(p++) = s[j];\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    string convert(string s, int numRows) {\\n        std::string ans(s.size(),'0');\\n        char* p = &ans[0];\\n        int part_len = 2*numRows - 2;\\n        if(numRows == 1 || s.size() == 0) return s;\\n        for(int i=0; i<numRows; ++i)\\n        {\\n            if(i == 0 || i == numRows -1)\\n                for(int j=i; j<s.size(); j+= part_len) *(p++) = s[j];\\n            else\\n            {\\n                int offset = 2 * i;\\n                for(int j=i; j<s.size(); offset=part_len-offset,j+= offset) *(p++) = s[j];\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3922,
                "title": "my-simple-java-solution",
                "content": "    public class Solution {\\n    public String convert( String s, int nRows ){\\n        if( nRows == 1 )    return s;\\n\\t\\tStringBuilder[] res = new StringBuilder[nRows];\\n\\t\\tfor( int i=0; i<nRows; i++ )\\n\\t\\t\\tres[i] = new StringBuilder();\\n\\t\\tint loop = 2 * nRows-2;\\n\\t\\tint mid = nRows-1;\\n\\t\\tfor( int i=0; i<s.length(); i++ )\\n\\t\\t\\tres[ mid - Math.abs( i % loop - mid ) ].append(s.charAt(i));\\n\\t\\tfor( int i = 1; i<nRows; i++ )\\n\\t\\t\\tres[0].append( res[i] );\\n\\t\\treturn res[0].toString();\\n\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String convert( String s, int nRows ){\\n        if( nRows == 1 )    return s;\\n\\t\\tStringBuilder[] res = new StringBuilder[nRows];\\n\\t\\tfor( int i=0; i<nRows; i++ )\\n\\t\\t\\tres[i] = new StringBuilder();\\n\\t\\tint loop = 2 * nRows-2;\\n\\t\\tint mid = nRows-1;\\n\\t\\tfor( int i=0; i<s.length(); i++ )\\n\\t\\t\\tres[ mid - Math.abs( i % loop - mid ) ].append(s.charAt(i));\\n\\t\\tfor( int i = 1; i<nRows; i++ )\\n\\t\\t\\tres[0].append( res[i] );\\n\\t\\treturn res[0].toString();\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3991,
                "title": "a-straightforward-python-solution",
                "content": "    def convert(s, nRows):\\n        if nRows == 1:\\n            return s\\n        down = True\\n        strings = [\"\"] * nRows\\n        # go through the string and append letters one by one\\n        lpos = 0\\n        for letter in s:\\n            strings[lpos] += letter\\n            if lpos == nRows - 1:\\n                lpos -= 1\\n                down = False\\n            elif lpos == 0:\\n                lpos = 1\\n                down = True\\n            elif down:\\n                lpos += 1\\n            else:\\n                lpos -= 1\\n        return \"\".join(strings)\\n\\nThe idea is very simple: how do you as a human solve this problem? By going through the letters and following the zigzag pattern. So I'm keeping two extra variables: one boolean *down*, to see whether I'm going up or down, and one counter *lpos*, which I'm changing manually. Example: if *nRows = 5*, then *lpos* iterates through 0 1 2 3 4 3 2 1 0 1 2 3 4 3 2... etc. Like a zigzag!",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def convert(s, nRows):\\n        if nRows == 1:\\n            return s\\n        down = True\\n        strings = [\"\"] * nRows\\n        # go through the string and append letters one by one\\n        lpos = 0\\n        for letter in s:\\n            strings[lpos] += letter\\n            if lpos == nRows - 1:\\n                lpos -= 1\\n                down = False\\n            elif lpos == 0:\\n                lpos = 1\\n                down = True\\n            elif down:\\n                lpos += 1\\n            else:\\n                lpos -= 1\\n        return \"\".join(strings)\\n\\nThe idea is very simple: how do you as a human solve this problem? By going through the letters and following the zigzag pattern. So I'm keeping two extra variables: one boolean *down*, to see whether I'm going up or down, and one counter *lpos*, which I'm changing manually. Example: if *nRows = 5*, then *lpos* iterates through 0 1 2 3 4 3 2 1 0 1 2 3 4 3 2... etc. Like a zigzag!",
                "codeTag": "Python3"
            },
            {
                "id": 4009709,
                "title": "beginner-friendly-and-easy-to-understand-approach-but-still-beats-78",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can follow the array approach\\neg: PAYPALISHIRING\\nhere num of rows is 3, so we have 3 arrays\\narray1: pahn\\narray2:aplsiig\\narray3:yir\\n\\nso to divide this,i have used two variables j(acts as index to which array)\\nand direction(decides whether to move up or down)\\n\\n\\nnext step is to merge this array\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows == 1 || numRows >= s.length()) {\\n            return s;\\n        }\\n        StringBuilder[] strings = new StringBuilder[numRows];\\n        for(int i=0;i<numRows;i++)\\n        {\\n            strings[i] = new StringBuilder();\\n        }\\n        int j =0;\\n        int direction =1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            strings[j].append(s.charAt(i));\\n            if(j==0)\\n            {\\n                direction = 1;\\n            }\\n            if(j == numRows-1)\\n            {\\n                direction = -1;\\n            }\\n            j +=direction;\\n        }\\n        StringBuilder result = new StringBuilder();\\n        for (StringBuilder sb : strings) {\\n            result.append(sb);\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows == 1 || numRows >= s.length()) {\\n            return s;\\n        }\\n        StringBuilder[] strings = new StringBuilder[numRows];\\n        for(int i=0;i<numRows;i++)\\n        {\\n            strings[i] = new StringBuilder();\\n        }\\n        int j =0;\\n        int direction =1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            strings[j].append(s.charAt(i));\\n            if(j==0)\\n            {\\n                direction = 1;\\n            }\\n            if(j == numRows-1)\\n            {\\n                direction = -1;\\n            }\\n            j +=direction;\\n        }\\n        StringBuilder result = new StringBuilder();\\n        for (StringBuilder sb : strings) {\\n            result.append(sb);\\n        }\\n\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485845,
                "title": "java-solution-for-zig-zag-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can observe that the resulting zig-zag pattern consists of numRows rows, and each row contains a certain number of characters from the given string s. The pattern starts with the first character of s in the top-left corner and moves diagonally down until it reaches the last row, and then it moves diagonally up towards the top-right corner. The process continues until all characters of s have been included in the zig-zag pattern.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If the number of rows numRows is 1, return the string s as it is since there will be only one row in this case.\\n- Create a StringBuilder sb to store the resulting zig-zag pattern.\\n- Initialize the step variable to 2 * numRows - 2, which is the distance between two consecutive characters in the same row.\\n- For each row from 0 to numRows - 1:\\n1. If the row is the first or the last row, add characters to the StringBuilder by skipping characters in intervals of the step size.\\n2. If the row is not the first or the last row, add characters to the StringBuilder by alternating between two step sizes (one for moving up and the other for moving down) until the end of the string is reached.\\n- Return the resulting string from the StringBuilder.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given solution is O(n), where n is the length of the input string s. This is because we iterate over each character of s exactly once and perform constant time operations for each character.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the given solution is O(n), where n is the length of the input string s. This is because we create a StringBuilder sb of length n to store the resulting zig-zag pattern. The additional space used by other variables is constant and does not depend on the length of the input string.\\n\\n# Code\\n```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows == 1)\\n            return s;\\n        StringBuilder sb = new StringBuilder();\\n        // step\\n        int step = 2 * numRows - 2;\\n        for (int i = 0; i < numRows; i++)\\n        {\\n            //first & last rows\\n            if (i == 0 || i == numRows - 1) \\n            {\\n                for (int j = i; j < s.length(); j = j + step) \\n                {\\n                    sb.append(s.charAt(j));\\n                }\\n                //middle rows\\n            }\\n            else \\n            {\\n                int j = i;\\n                boolean flag = true;\\n                int step1 = 2 * (numRows - 1 - i);\\n                int step2 = step - step1;\\n                while (j < s.length()) \\n                {\\n                    sb.append(s.charAt(j));\\n                    if (flag)\\n                        j = j + step1;\\n                    else\\n                        j = j + step2;\\n                    flag = !flag;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows == 1)\\n            return s;\\n        StringBuilder sb = new StringBuilder();\\n        // step\\n        int step = 2 * numRows - 2;\\n        for (int i = 0; i < numRows; i++)\\n        {\\n            //first & last rows\\n            if (i == 0 || i == numRows - 1) \\n            {\\n                for (int j = i; j < s.length(); j = j + step) \\n                {\\n                    sb.append(s.charAt(j));\\n                }\\n                //middle rows\\n            }\\n            else \\n            {\\n                int j = i;\\n                boolean flag = true;\\n                int step1 = 2 * (numRows - 1 - i);\\n                int step2 = step - step1;\\n                while (j < s.length()) \\n                {\\n                    sb.append(s.charAt(j));\\n                    if (flag)\\n                        j = j + step1;\\n                    else\\n                        j = j + step2;\\n                    flag = !flag;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245250,
                "title": "c-solution-explained",
                "content": "# Approach\\nApproach 1):\\nOne could basically create numRows arrays of maximum (input string length / numRows + 1) elements and iteratively store the characters in those arrays.\\nAn example is:\\ns = \"ABCDE\", numRows = 3 -> 3 arrays :\\narr[0][0] = \\'A\\' -> incrementing until reaching numRows - 1\\narr[1][0] = \\'B\\'\\narr[2][0] = \\'C\\' -> now decrementing until reaching 0\\narr[1][0] = \\'D\\'\\narr[0][0] = \\'E\\'\\n\\nafter that, simply read each whole array starting from 0 up to arr[numRows - 1] in order to get the result.\\n\\nThis solution is probably simpler to understand but surely slower.\\n\\n\\nApproach 2) -- used in the solution below --\\nTrying to recognize a common pattern in each element of a certain level (think the level as the straight line that connects multiple elements on the same row).\\nConsider the example below:\\n\\n0_____8  \\n1___7__9\\n2__6\\n3_5\\n4\\n\\nwe see that we will have to print the sequence 0,8,1,7,9,2,6,3,5,4\\nIn order to go from 0 to 8 we need to add 8, which can be seen as numRows (5) * 2 - 2 (minus 2 because else we would be counting 4 and 0 two times).\\n\\nOther example:\\n0__4\\n1_3\\n2\\n\\nIn order to go from 0 to 4 we need to count 4 positions, which is also seen as numRows (3 in our case) * 2 - 2.\\n\\nNow, let\\'s go back to the previous example; having found the correlation between 0 and 8, now we need to find it for 1,7,9. Starting from 1, we need to add 6, which is exactly 8 (the number we had to add before) - 2 (because now we are not counting 0 and 8). What is now the correlation between 7 and 9? Exactly 2 (value subtracted from 8). \\nGoing on, 2 and 6 differ by 4 (again 6 - 2) and if there was also a 10th element, it would differ from 6 by 4 (2 + 2). 3 and 5 differ from 4 - 2 = 2 and so on.\\n\\n\\n\\nSolution below better explained:\\n- we get the length of the input string\\n- we allocate a dynamic array of chars of the same number of elements of the string + 1 (for string terminator character)\\n- initialize a and b (variables to add to j in order to get the values on the same level) -> if there is 1 character only b would be 0, so in that case we initialize it to 1\\n- for(i) -> i is the variable that goes from 0 to numRows - 1 and scans all the levels (in our ex. : level 0 is: 0 8, level 1 is 1 7 9, ...)\\n- j is set equal to i at the beginning (so it takes the values  0,1,2,3,4)\\n- change tells us if we need to add a or b to j (ex. from 1 to 7 we need to add 6 = b, but from 7 to 9 we need to add 2 = a)\\n- while(j): we will stop when j is greater than the length of the input string\\n- if(): alternatively add a or b; in case a is 0 or b is 0 we don\\'t want to count the character 2 times (we would add 0 to j and count s[j] two times) -> add a,b based on the one which is not 0 (if a is 0 add b, if b is zero add a)\\n- subtract 2 from b and add 2 to a (b goes from 8 (0->8) to 6 (1->7) and a goes to 2 (7->9))\\n- don\\'t forget to put the string terminator -> res[count] = 0; \\n- return the result\\n\\n\\n# Code\\n```\\nint str_len(char* s)\\n{\\n    int len = 0;\\n    while(s[len] != 0)\\n    {\\n        len++;\\n    }\\n\\n    return len;\\n}\\n\\nchar * convert(char * s, int numRows){\\n    int len = str_len(s);\\n    char* res = (char*)malloc(len * sizeof(char) + 1);\\n\\n    int a = 0;\\n    int b = numRows * 2 - 2 > 0 ? numRows * 2 - 2: 1;\\n    int count = 0;\\n\\n    for(int i = 0; i < numRows; i++)\\n    {\\n        int j = i;\\n        \\n        int change = 0;\\n        while(j < len)\\n        {\\n            res[count++] = s[j];\\n            \\n            if(change && a != 0 || !b)\\n            {\\n                j += a;\\n                change = 0;\\n            }\\n            else\\n            {\\n                j += b;\\n                change = 1;\\n            }\\n        }\\n\\n        a+=2;\\n        b-=2;\\n    }\\n    res[count] = 0;\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint str_len(char* s)\\n{\\n    int len = 0;\\n    while(s[len] != 0)\\n    {\\n        len++;\\n    }\\n\\n    return len;\\n}\\n\\nchar * convert(char * s, int numRows){\\n    int len = str_len(s);\\n    char* res = (char*)malloc(len * sizeof(char) + 1);\\n\\n    int a = 0;\\n    int b = numRows * 2 - 2 > 0 ? numRows * 2 - 2: 1;\\n    int count = 0;\\n\\n    for(int i = 0; i < numRows; i++)\\n    {\\n        int j = i;\\n        \\n        int change = 0;\\n        while(j < len)\\n        {\\n            res[count++] = s[j];\\n            \\n            if(change && a != 0 || !b)\\n            {\\n                j += a;\\n                change = 0;\\n            }\\n            else\\n            {\\n                j += b;\\n                change = 1;\\n            }\\n        }\\n\\n        a+=2;\\n        b-=2;\\n    }\\n    res[count] = 0;\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3144684,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int nRows) {\\n        if(nRows <= 1)\\n         return s;\\n        string result = \"\";\\n        int cycle = 2 * nRows - 2;\\n        for(int i = 0; i < nRows; ++i)\\n        {\\n            for(int j = i; j < s.length(); j = j + cycle){\\n               result = result + s[j];\\n               int secondJ = (j - i) + cycle - i;\\n               if(i != 0 && i != nRows-1 && secondJ < s.length())\\n                   result = result + s[secondJ];\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int nRows) {\\n        if(nRows <= 1)\\n         return s;\\n        string result = \"\";\\n        int cycle = 2 * nRows - 2;\\n        for(int i = 0; i < nRows; ++i)\\n        {\\n            for(int j = i; j < s.length(); j = j + cycle){\\n               result = result + s[j];\\n               int secondJ = (j - i) + cycle - i;\\n               if(i != 0 && i != nRows-1 && secondJ < s.length())\\n                   result = result + s[secondJ];\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136532,
                "title": "c-easy-and-simple-solution-using-2d-array",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n# Complexity\\n- Time complexity:\\nO(numRows*n)\\n\\n- Space complexity:\\nO(numRows*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows<2) return s;\\n        vector<vector<char>>ans(numRows,vector<char>(s.length(),\\'0\\'));\\n        int row=0,c=1;\\n        for(int i=0;i<s.length();i++){\\n          ans[row][i]=s[i];\\n          if(row==numRows-1) c=-1;\\n          if(row==0) c=1;\\n          row+=c;\\n        }\\n        string res=\"\";\\n        for(auto i : ans){\\n            for(auto j : i){\\n                if(j!=\\'0\\')\\n                    res+=j;\\n            } \\n            \\n        }\\n        return res;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows<2) return s;\\n        vector<vector<char>>ans(numRows,vector<char>(s.length(),\\'0\\'));\\n        int row=0,c=1;\\n        for(int i=0;i<s.length();i++){\\n          ans[row][i]=s[i];\\n          if(row==numRows-1) c=-1;\\n          if(row==0) c=1;\\n          row+=c;\\n        }\\n        string res=\"\";\\n        for(auto i : ans){\\n            for(auto j : i){\\n                if(j!=\\'0\\')\\n                    res+=j;\\n            } \\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136168,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n       List<List<Character>> l=new ArrayList<>();\\n       if(numRows==1)return s;\\n       for(int i=0;i<numRows;i++)\\n       {\\n           l.add(new ArrayList<>());\\n       } \\n       int row=0;\\n       int t=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           l.get(row).add(s.charAt(i));\\n           if(t==0)row++;\\n           else row--;\\n           if(row==0||row==numRows-1)t=t==0?1:0;\\n       }\\n       String res=\"\";\\n       for(List l1:l)\\n       {\\n           for(int i=0;i<l1.size();i++)res+=(\"\"+l1.get(i));\\n       }\\n      // System.out.println(l);\\n       return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n       List<List<Character>> l=new ArrayList<>();\\n       if(numRows==1)return s;\\n       for(int i=0;i<numRows;i++)\\n       {\\n           l.add(new ArrayList<>());\\n       } \\n       int row=0;\\n       int t=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           l.get(row).add(s.charAt(i));\\n           if(t==0)row++;\\n           else row--;\\n           if(row==0||row==numRows-1)t=t==0?1:0;\\n       }\\n       String res=\"\";\\n       for(List l1:l)\\n       {\\n           for(int i=0;i<l1.size();i++)res+=(\"\"+l1.get(i));\\n       }\\n      // System.out.println(l);\\n       return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135775,
                "title": "python-simple-solution-46-ms-beats-97",
                "content": "# Intuition\\nk goes up and down so we add current letter to the right substring\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def convert(self, s: str, n: int) -> str:\\n        if n == 1:\\n            return s\\n\\n        a = [\\'\\']*n\\n        k = index = 0\\n\\n        for letter in s:\\n            a[k%n] += letter\\n\\n            if k == n-1:\\n                index = 1\\n            if k == 0:\\n                index = 0\\n            k = k+1 if index == 0 else k-1\\n\\n        result = a[0]\\n        for i in a[1:]:\\n            result += i\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convert(self, s: str, n: int) -> str:\\n        if n == 1:\\n            return s\\n\\n        a = [\\'\\']*n\\n        k = index = 0\\n\\n        for letter in s:\\n            a[k%n] += letter\\n\\n            if k == n-1:\\n                index = 1\\n            if k == 0:\\n                index = 0\\n            k = k+1 if index == 0 else k-1\\n\\n        result = a[0]\\n        for i in a[1:]:\\n            result += i\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135511,
                "title": "python3-50ms-very-simple-solution-detailed-explained",
                "content": "# Intuition\\n**![Capture.PNG](https://assets.leetcode.com/users/images/c777de6f-78d4-4daa-b97d-14a9b04c4ae0_1675446391.282558.png)**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Zig-zag traversal is simple level order string traversal.**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- we have to travers in level order, and our $$level-threshold$$ is $$numRows$$.\\n- travers over $$length-of-string$$ and initial level is $$0$$.\\n- increment level by 1 in each iteration\\n- if we reach at last level according to numRows then $$traverse backwards$$ and decrement level by 1.\\n- put current alphabet from string s to it\\'s respective level\\n- this all operation happens in $$O(n)$$ times.\\n- now $$concatenate-all-characters$$ from level array and return, this also happens in $$O(n)$$ time.\\n# Complexity\\n- Time complexity: $$O(2n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n+c)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1:\\n            return s\\n        ans = [[] for _ in range(numRows)]\\n        level = 0\\n        answer = \"\"\\n        forward = True\\n        for i in range(len(s)):\\n            ans[level].append(s[i])\\n            if forward:\\n                level += 1\\n            if not forward:\\n                level -= 1\\n            if level > numRows - 1:\\n                level -= 2\\n                forward = False\\n            if level < 0:\\n                level += 2\\n                forward = True\\n        for i in ans:\\n            for j in i:\\n                answer += j\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1:\\n            return s\\n        ans = [[] for _ in range(numRows)]\\n        level = 0\\n        answer = \"\"\\n        forward = True\\n        for i in range(len(s)):\\n            ans[level].append(s[i])\\n            if forward:\\n                level += 1\\n            if not forward:\\n                level -= 1\\n            if level > numRows - 1:\\n                level -= 2\\n                forward = False\\n            if level < 0:\\n                level += 2\\n                forward = True\\n        for i in ans:\\n            for j in i:\\n                answer += j\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135446,
                "title": "simple-java-c-easy-readable-beginners-100-working",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\npublic String convert(String s, int numRows) {\\n    if(numRows<=1)return s;\\n    StringBuilder[] sb=new StringBuilder[numRows];\\n    for(int i=0;i<sb.length;i++){\\n        sb[i]=new StringBuilder(\"\");//init every sb element *important steps!!!\\n    }\\n    int incre=1;\\n    int index=0;\\n    for(int i=0;i<s.length();i++){\\n        sb[index].append(s.charAt(i));\\n        if(index==0){incre=1;}\\n        if(index==numRows-1){incre=-1;}\\n        index+=incre;\\n    }\\n    String re=\"\";\\n        for(int i=0;i<sb.length;i++){\\n            re+=sb[i];\\n         }\\n        return re.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\npublic String convert(String s, int numRows) {\\n    if(numRows<=1)return s;\\n    StringBuilder[] sb=new StringBuilder[numRows];\\n    for(int i=0;i<sb.length;i++){\\n        sb[i]=new StringBuilder(\"\");//init every sb element *important steps!!!\\n    }\\n    int incre=1;\\n    int index=0;\\n    for(int i=0;i<s.length();i++){\\n        sb[index].append(s.charAt(i));\\n        if(index==0){incre=1;}\\n        if(index==numRows-1){incre=-1;}\\n        index+=incre;\\n    }\\n    String re=\"\";\\n        for(int i=0;i<sb.length;i++){\\n            re+=sb[i];\\n         }\\n        return re.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135359,
                "title": "easy-c-solution-in-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nobserve pattern row wise \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfrom pattern we can see after every 2(n-1) elments, the next element  will come for first and last row and there is one centre element b/w 2 consecutive elements of other rows ;\\nso we push element row wise \\nwith alternate long and a short jump ;\\nfor short jump 2*row elements decreses;\\n2*(n-1)-2*row; \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    string convert(string s, int n) {\\n     string ans=\"\";\\n     int i=1;\\n     int j=0,f=0;\\n     int jmp=2*n-2;//long jump condition\\n     bool centre=true;\\n     \\nif(n==1 || s.size()<=n)return s;\\n//loop for first row\\nwhile(f<s.size()){\\n    ans.push_back(s[f]);\\n    f+=jmp;\\n     }\\n     //loop for between rows \\n     while(i<n-1){\\n         j=i;\\n         centre = true;\\n         ans.push_back(s[i]);\\n         //loop to push a row\\n     while(j<s.size())\\n     {\\n     if(centre){\\n     if(j+jmp-2*i<s.size())//short jump condition for centre element \\n     ans.push_back(s[j+jmp-2*i]);\\n    centre=false;\\n    }\\n    else\\n    {\\n    j+=jmp; //long jump similar to first and last row \\n    if(j<s.size())\\n    ans.push_back(s[j]);\\n    centre=true;\\n    }\\n  }\\n i++;\\n }\\n\\nf=n-1;\\n//loop for last row\\nwhile(f<s.size())\\n{\\n    ans.push_back(s[f]);\\n    f+=jmp;\\n}\\nreturn ans;\\n} \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string convert(string s, int n) {\\n     string ans=\"\";\\n     int i=1;\\n     int j=0,f=0;\\n     int jmp=2*n-2;//long jump condition\\n     bool centre=true;\\n     \\nif(n==1 || s.size()<=n)return s;\\n//loop for first row\\nwhile(f<s.size()){\\n    ans.push_back(s[f]);\\n    f+=jmp;\\n     }\\n     //loop for between rows \\n     while(i<n-1){\\n         j=i;\\n         centre = true;\\n         ans.push_back(s[i]);\\n         //loop to push a row\\n     while(j<s.size())\\n     {\\n     if(centre){\\n     if(j+jmp-2*i<s.size())//short jump condition for centre element \\n     ans.push_back(s[j+jmp-2*i]);\\n    centre=false;\\n    }\\n    else\\n    {\\n    j+=jmp; //long jump similar to first and last row \\n    if(j<s.size())\\n    ans.push_back(s[j]);\\n    centre=true;\\n    }\\n  }\\n i++;\\n }\\n\\nf=n-1;\\n//loop for last row\\nwhile(f<s.size())\\n{\\n    ans.push_back(s[f]);\\n    f+=jmp;\\n}\\nreturn ans;\\n} \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134192,
                "title": "python-well-explanation-simple-easy",
                "content": "![explanision.PNG](https://assets.leetcode.com/users/images/39ed3cd5-0c1e-4353-af74-777a021ecdcb_1675392805.2104511.png)\\nI solved this problem using index of each character in string `s`\\n###  The first and last rows:\\nI find sequence of numbers that, each element is greater than the one before it by 6 (add) `2*numRows - 2`,\\n### The others rows:\\nThere are two numbers, the difference between them is fixed and repeated every `numRows`,\\nThe first number, like the one I mentioned before, is greater than the one before it by 6 (add) `2*numRows - 2`.\\nThe second is greater than the first by this equation: `index = j + add - 2*i`, `j: index of character`, `i: number of row`.\\nAnd then I add every character using these equations in string `word` \\n\\n# Code\\n```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        if numRows == 1:\\n            return s\\n        word = \"\"\\n        add = 2*numRows - 2\\n        n = len(s)\\n        for i in range(numRows):\\n            if i == 0 or i == numRows-1:\\n                for j in range(i,n,add):\\n                    word += s[j]\\n            else:\\n                for j in range(i,n,add):\\n                    word += s[j]\\n                    index = j + add - 2*i\\n                    if index < n:\\n                        word += s[index]\\n                    \\n        return word\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        if numRows == 1:\\n            return s\\n        word = \"\"\\n        add = 2*numRows - 2\\n        n = len(s)\\n        for i in range(numRows):\\n            if i == 0 or i == numRows-1:\\n                for j in range(i,n,add):\\n                    word += s[j]\\n            else:\\n                for j in range(i,n,add):\\n                    word += s[j]\\n                    index = j + add - 2*i\\n                    if index < n:\\n                        word += s[index]\\n                    \\n        return word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133926,
                "title": "0ms-dumb-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n# Code\\n```\\nimpl Solution {\\n    pub fn convert(s: String, num_rows: i32) -> String {\\n        if num_rows == 1 { return s; }\\n        let mut results: Vec<String> = vec![String::new();num_rows as usize];\\n        let mut letters = s.chars();\\n\\n        let mut index:usize = 0;\\n        let mut direction:bool = true;\\n\\n        while let Some(letter) = letters.next(){\\n            results[index].push(letter);\\n            if direction { index += 1; } else { index -= 1;}\\n\\n            if index != num_rows as usize && index != usize::MAX { continue; }\\n            \\n            direction = !direction;\\n            if direction { index += 2; } else { index -= 2;}\\n        }\\n\\n        for index in 1..num_rows as usize {\\n            let temp = &results[index].clone();\\n            results[0].push_str(temp);\\n        }\\n        results[0].clone()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn convert(s: String, num_rows: i32) -> String {\\n        if num_rows == 1 { return s; }\\n        let mut results: Vec<String> = vec![String::new();num_rows as usize];\\n        let mut letters = s.chars();\\n\\n        let mut index:usize = 0;\\n        let mut direction:bool = true;\\n\\n        while let Some(letter) = letters.next(){\\n            results[index].push(letter);\\n            if direction { index += 1; } else { index -= 1;}\\n\\n            if index != num_rows as usize && index != usize::MAX { continue; }\\n            \\n            direction = !direction;\\n            if direction { index += 2; } else { index -= 2;}\\n        }\\n\\n        for index in 1..num_rows as usize {\\n            let temp = &results[index].clone();\\n            results[0].push_str(temp);\\n        }\\n        results[0].clone()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3133918,
                "title": "fastest-clean-code-o-1-extra-space-easy-to-understand-o-n-time",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int row) {\\n        if(row==1)return s;\\n\\n        string ans;\\n        int p=0,n=s.length();\\n\\n        // row=0\\n        while(p<n){\\n            ans.push_back(s[p]);\\n            p += (row-1)*2;\\n        }\\n\\n        //middle rows\\n        for(int i=1 ; i<row-1 ; i++){\\n            p = i;\\n            bool down=true;\\n            while(p<n){\\n                ans.push_back(s[p]);\\n                if(down){\\n                    p += (row-1-i)*2;\\n                }\\n                else{\\n                    p += i*2;\\n                }\\n                down = !down;\\n            }\\n        }\\n\\n        // last row\\n        p=row-1;\\n        while(p<n){\\n            ans.push_back(s[p]);\\n            p += (row-1)*2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int row) {\\n        if(row==1)return s;\\n\\n        string ans;\\n        int p=0,n=s.length();\\n\\n        // row=0\\n        while(p<n){\\n            ans.push_back(s[p]);\\n            p += (row-1)*2;\\n        }\\n\\n        //middle rows\\n        for(int i=1 ; i<row-1 ; i++){\\n            p = i;\\n            bool down=true;\\n            while(p<n){\\n                ans.push_back(s[p]);\\n                if(down){\\n                    p += (row-1-i)*2;\\n                }\\n                else{\\n                    p += i*2;\\n                }\\n                down = !down;\\n            }\\n        }\\n\\n        // last row\\n        p=row-1;\\n        while(p<n){\\n            ans.push_back(s[p]);\\n            p += (row-1)*2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049344,
                "title": "c-such-an-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows==1) return s;\\n        bool down=true;\\n        string arr[numRows];\\n        int row=0;\\n        for(int i=0; i<s.size(); i++) {\\n            arr[row].push_back(s[i]);\\n            if(row==numRows-1) down=false;\\n            else if (row==0) down=true;\\n            if(down) row++;\\n            else row--;\\n        }\\n        string res=\"\";\\n        for(int i=0; i<numRows; i++) {\\n            res += arr[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows==1) return s;\\n        bool down=true;\\n        string arr[numRows];\\n        int row=0;\\n        for(int i=0; i<s.size(); i++) {\\n            arr[row].push_back(s[i]);\\n            if(row==numRows-1) down=false;\\n            else if (row==0) down=true;\\n            if(down) row++;\\n            else row--;\\n        }\\n        string res=\"\";\\n        for(int i=0; i<numRows; i++) {\\n            res += arr[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876713,
                "title": "easiest-straight-forward-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string convert(string &s, int numRows) {\\n        int n = s.size();\\n        if(numRows <= 1) return s;\\n        string ans = \"\";\\n        vector<string> out(numRows);\\n        int crow = 0, dir = 1;  //1->going down 2->going up\\n        for(int i = 0; i < n; i++) {\\n            out[crow].push_back(s[i]);\\n            // if hit the turning point, change direction\\n            if(crow == 0) dir = 1;\\n            else if((crow+1) == numRows) dir = 2;\\n            // inc or dec row depending upon the turning pt direction\\n            if(dir == 1) crow++;\\n            else crow--;        \\n            \\n        }\\n\\n        for(auto &str: out) ans += str;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string &s, int numRows) {\\n        int n = s.size();\\n        if(numRows <= 1) return s;\\n        string ans = \"\";\\n        vector<string> out(numRows);\\n        int crow = 0, dir = 1;  //1->going down 2->going up\\n        for(int i = 0; i < n; i++) {\\n            out[crow].push_back(s[i]);\\n            // if hit the turning point, change direction\\n            if(crow == 0) dir = 1;\\n            else if((crow+1) == numRows) dir = 2;\\n            // inc or dec row depending upon the turning pt direction\\n            if(dir == 1) crow++;\\n            else crow--;        \\n            \\n        }\\n\\n        for(auto &str: out) ans += str;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777917,
                "title": "java-easy-solution-arraylist-stringbuilder",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        ArrayList<StringBuilder> list=new ArrayList<>();\\n        for(int i=0;i<numRows;i++){\\n            list.add(new StringBuilder());\\n        }\\n        int c=0;\\n        while(c<s.length()){\\n            for(int i=0;i<numRows && c<s.length() ;i++,c++){\\n                list.get(i).append(s.charAt(c));\\n            }\\n            for(int i=numRows-2;i>=1 && c<s.length();i--,c++){\\n                list.get(i).append(s.charAt(c));\\n            }\\n        }\\n        String ans=\"\";\\n        for(int i=0;i<numRows;i++){\\n            String str=new String(list.get(i));\\n            ans=ans+str;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n***Please Upvote if you like the solution*** \\n***Happy Coding :)***\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        ArrayList<StringBuilder> list=new ArrayList<>();\\n        for(int i=0;i<numRows;i++){\\n            list.add(new StringBuilder());\\n        }\\n        int c=0;\\n        while(c<s.length()){\\n            for(int i=0;i<numRows && c<s.length() ;i++,c++){\\n                list.get(i).append(s.charAt(c));\\n            }\\n            for(int i=numRows-2;i>=1 && c<s.length();i--,c++){\\n                list.get(i).append(s.charAt(c));\\n            }\\n        }\\n        String ans=\"\";\\n        for(int i=0;i<numRows;i++){\\n            String str=new String(list.get(i));\\n            ans=ans+str;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744632,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<string> answer(numRows,\"\");\\n        if(numRows==1) return s;\\n        int index = 0;\\n        int ptr = 0;\\n        int size = s.size();\\n        while(index < size){\\n            int i;\\n            for(i=index;i<index+numRows;i++){\\n                if(i<=size-1){\\n                    answer[ptr] += s[i];\\n                    ptr++;\\n                }else break;\\n            }\\n            index = i; ptr-=2;\\n            while(index<size && ptr>0){\\n                answer[ptr] += s[index];\\n                index++;\\n                ptr--;\\n            }\\n        }\\n        string final_string = \"\";\\n        for(auto item:answer){\\n            cout<<item<<\" \";\\n            final_string += item;\\n        }\\n        \\n        return final_string;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<string> answer(numRows,\"\");\\n        if(numRows==1) return s;\\n        int index = 0;\\n        int ptr = 0;\\n        int size = s.size();\\n        while(index < size){\\n            int i;\\n            for(i=index;i<index+numRows;i++){\\n                if(i<=size-1){\\n                    answer[ptr] += s[i];\\n                    ptr++;\\n                }else break;\\n            }\\n            index = i; ptr-=2;\\n            while(index<size && ptr>0){\\n                answer[ptr] += s[index];\\n                index++;\\n                ptr--;\\n            }\\n        }\\n        string final_string = \"\";\\n        for(auto item:answer){\\n            cout<<item<<\" \";\\n            final_string += item;\\n        }\\n        \\n        return final_string;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2500707,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=kv9cej4Ljuw",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=kv9cej4Ljuw",
                "codeTag": "Unknown"
            },
            {
                "id": 2364205,
                "title": "simple-c-python-java-javascript-here",
                "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2008824,
                "title": "python-o-n-with-period",
                "content": "The biggest part of this solution, is to understand, with which period each letter appears in zigzag. Let me explain.\\n\\nIn the image below, string *PAYPALISHIRING* is represented. Red circles are indexes of layers.\\n![image](https://assets.leetcode.com/users/images/d27beff7-be10-461c-96f0-cc64d46f8725_1651697596.7328937.png)\\n\\nWe can see, that the distance between purple and yellow circles is always the same. And it equals `numRows * 2 - 3`. I\\'ve figured out this formula, just drawing pictures with different number of layers. It is illustrated in the image above.\\n![image](https://assets.leetcode.com/users/images/9d3255ef-6901-4767-97b5-4cdede0612c9_1651697917.8858163.png)\\n\\nNow we also can see, that in one period (purple rectangle), there are always two characters on the same row. Not counting the bottom layer, of course. And the distance between those two characters equals  `(numRows - idx) * 2 - 3`, where index is taken from the red circles from the top image. Now, the best part. \\n\\nKnowing distance between chars in one period, and the length of the period. We can find indexes of all the characters on these layers. It is easier to understand it from a picture. There are provided calculation for the 2nd layer.  Then we have to handle a couple of edge cases, and that\\'s it! \\n![image](https://assets.leetcode.com/users/images/da9299e8-237e-47f7-89be-7b73e9b467bd_1651698445.9717364.png)\\n\\n\\n```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        zero_period = numRows * 2 - 3\\n\\n        def collect_chars_by_level(idx: int) -> str:\\n            iter_value = (numRows - idx) * 2 - 3\\n            chars_by_level = \\'\\'\\n\\n            while idx < len(s):\\n                chars_by_level += s[idx]\\n                if idx + iter_value + 1 < len(s) and iter_value != -1 and iter_value != zero_period:\\n                    chars_by_level += s[idx + iter_value + 1]\\n\\n                idx = idx + 1 if zero_period == -1 else idx + zero_period + 1\\n\\n            return chars_by_level\\n\\n        chars = \\'\\'\\n        for curr_row_idx in range(numRows):\\n            chars += collect_chars_by_level(idx=curr_row_idx)\\n\\n        return chars\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        zero_period = numRows * 2 - 3\\n\\n        def collect_chars_by_level(idx: int) -> str:\\n            iter_value = (numRows - idx) * 2 - 3\\n            chars_by_level = \\'\\'\\n\\n            while idx < len(s):\\n                chars_by_level += s[idx]\\n                if idx + iter_value + 1 < len(s) and iter_value != -1 and iter_value != zero_period:\\n                    chars_by_level += s[idx + iter_value + 1]\\n\\n                idx = idx + 1 if zero_period == -1 else idx + zero_period + 1\\n\\n            return chars_by_level\\n\\n        chars = \\'\\'\\n        for curr_row_idx in range(numRows):\\n            chars += collect_chars_by_level(idx=curr_row_idx)\\n\\n        return chars\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896588,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        guard numRows > 1 else { return s }\\n        var rows: [[Character]] = []\\n        var res = \"\"\\n\\n        for _ in 0..<numRows { rows.append([]) }\\n\\n        for (i, c) in s.enumerated() {\\n            let index = i % (numRows + numRows - 2)\\n            if index < numRows {\\n                rows[index].append(c)\\n            } else {\\n                rows[index - 2 * (index - numRows + 1)].append(c)\\n            }\\n        }\\n\\n        for row in rows {\\n            for c in row { res += String(c) }\\n        }\\n\\n        return res\\n    }\\n\\n}\\n\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        guard numRows > 1 else { return s }\\n        var rows: [[Character]] = []\\n        var res = \"\"\\n\\n        for _ in 0..<numRows { rows.append([]) }\\n\\n        for (i, c) in s.enumerated() {\\n            let index = i % (numRows + numRows - 2)\\n            if index < numRows {\\n                rows[index].append(c)\\n            } else {\\n                rows[index - 2 * (index - numRows + 1)].append(c)\\n            }\\n        }\\n\\n        for row in rows {\\n            for c in row { res += String(c) }\\n        }\\n\\n        return res\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760114,
                "title": "java-solution-with-explanation",
                "content": "Iterate through every row \\nfor first and last row, we need to add 2*numRows-2 to get the next element\\nfor rows between first and last, it follows a sequence first 2*numRows-2-2*i and then 2*i is added to get the next element\\n![image](https://assets.leetcode.com/users/images/ad1880fb-d042-4f45-abcb-baebf1635d7f_1644479800.7959855.png)\\n\\n```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        int constant = numRows - 2 + numRows;\\n        StringBuilder str = new StringBuilder();\\n        if( s.length() <= 2 || numRows == 1) return s;\\n        for( int i = 0 ; i  < numRows; i++ )\\n        {\\n            boolean oddTurn = false;\\n            for( int j = i ; j < s.length();)\\n            {\\n                str.append( s.charAt(j) );\\n                \\n                if( i == 0 || i == ( numRows - 1 ))\\n                        j += constant;\\n                else\\n                        j += ( oddTurn ? 2*i: constant-2*i );\\n                \\n                oddTurn =!oddTurn;    \\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```\\nPlease **upvote** if you found it useful\\n\\nTimeComplexity = O(numRows*len(s))",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        int constant = numRows - 2 + numRows;\\n        StringBuilder str = new StringBuilder();\\n        if( s.length() <= 2 || numRows == 1) return s;\\n        for( int i = 0 ; i  < numRows; i++ )\\n        {\\n            boolean oddTurn = false;\\n            for( int j = i ; j < s.length();)\\n            {\\n                str.append( s.charAt(j) );\\n                \\n                if( i == 0 || i == ( numRows - 1 ))\\n                        j += constant;\\n                else\\n                        j += ( oddTurn ? 2*i: constant-2*i );\\n                \\n                oddTurn =!oddTurn;    \\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364816,
                "title": "zigzag-conversion-any-language-very-simple-fast-and-easy-to-understand",
                "content": "PLEASE UPVOTE THIS POST, IF IT HELPED.\\n```\\nif (numRows === 1) return s;\\n    let result = Array(numRows).fill(\\'\\');   //create array; [\"\",\"\",\"\"]//if numofrows = 3,\\n                                           //it will create 3strings(rows) inside array.\\n    let row = 0;\\n    let k = 1;\\n    for (const c of s) {     //simply - looping over every char of the string.\\n        result[row] = result[row] + c;  //put it in corresponding row.   \\n        if( row === numRows-1) k = -1;  // IF(IF AND ONLY IF) row reached last row, then k = -1. From now on, row will go backwards(or upwards(visually in mind)).\\n        if(row === 0) k = 1;//if row reached 0 again, then k = 1, and start from the first row again(meaning k will be 1, until this condition gets applied again)\\n        row = row + k*1;         \\n    }\\n    return result.join(\\'\\'); //return the joined strings(or rows).\\n```",
                "solutionTags": [],
                "code": "```\\nif (numRows === 1) return s;\\n    let result = Array(numRows).fill(\\'\\');   //create array; [\"\",\"\",\"\"]//if numofrows = 3,\\n                                           //it will create 3strings(rows) inside array.\\n    let row = 0;\\n    let k = 1;\\n    for (const c of s) {     //simply - looping over every char of the string.\\n        result[row] = result[row] + c;  //put it in corresponding row.   \\n        if( row === numRows-1) k = -1;  // IF(IF AND ONLY IF) row reached last row, then k = -1. From now on, row will go backwards(or upwards(visually in mind)).\\n        if(row === 0) k = 1;//if row reached 0 again, then k = 1, and start from the first row again(meaning k will be 1, until this condition gets applied again)\\n        row = row + k*1;         \\n    }\\n    return result.join(\\'\\'); //return the joined strings(or rows).\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1274361,
                "title": "easy-c-solution-90-faster",
                "content": "**If you like it then please upvote**\\n```\\nstring convert(string s, int numRows) {\\n        \\n        int n = s.length();\\n        if(numRows<=1||n<=1){\\n            return s;\\n        }\\n        int row = 0;\\n        int i = 0;\\n        string *str =new string[numRows];   \\n        while(row<numRows&&i<n){\\n            str[row].push_back(s[i]);\\n            i++;row++;\\n        }\\n        int step=0;\\n        while(i<n){\\n            if(step==0){\\n                row=numRows-2;\\n                while(row>=0&&i<n){\\n                    str[row].push_back(s[i]);\\n                    i++;\\n                    row--;\\n                }\\n                step=1;\\n            }\\n            else{\\n                row=1;\\n                while(row<numRows&&i<n){\\n                    str[row].push_back(s[i]);\\n                    i++;\\n                    row++;\\n                }\\n                step=0;\\n            }\\n        }\\n        \\n        string c = \"\";\\n        row=0;\\n        while(row<numRows){\\n            c+=str[row];\\n            row++;\\n        }\\n        return c;\\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\nstring convert(string s, int numRows) {\\n        \\n        int n = s.length();\\n        if(numRows<=1||n<=1){\\n            return s;\\n        }\\n        int row = 0;\\n        int i = 0;\\n        string *str =new string[numRows];   \\n        while(row<numRows&&i<n){\\n            str[row].push_back(s[i]);\\n            i++;row++;\\n        }\\n        int step=0;\\n        while(i<n){\\n            if(step==0){\\n                row=numRows-2;\\n                while(row>=0&&i<n){\\n                    str[row].push_back(s[i]);\\n                    i++;\\n                    row--;\\n                }\\n                step=1;\\n            }\\n            else{\\n                row=1;\\n                while(row<numRows&&i<n){\\n                    str[row].push_back(s[i]);\\n                    i++;\\n                    row++;\\n                }\\n                step=0;\\n            }\\n        }\\n        \\n        string c = \"\";\\n        row=0;\\n        while(row<numRows){\\n            c+=str[row];\\n            row++;\\n        }\\n        return c;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1094221,
                "title": "python-o-n-only-52-ms-crazy",
                "content": "```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n      if numRows == 1:\\n        return s\\n      strlist = []\\n      for i in range(numRows):\\n        strlist.append(\"\")\\n      count = 0\\n      for i in s:\\n        if count==0:\\n          flag = 1\\n        if count == numRows-1:\\n          flag = -1\\n        strlist[count] += i\\n        count += flag\\n      res = \"\"\\n      for i in strlist:\\n        res += i\\n      return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n      if numRows == 1:\\n        return s\\n      strlist = []\\n      for i in range(numRows):\\n        strlist.append(\"\")\\n      count = 0\\n      for i in s:\\n        if count==0:\\n          flag = 1\\n        if count == numRows-1:\\n          flag = -1\\n        strlist[count] += i\\n        count += flag\\n      res = \"\"\\n      for i in strlist:\\n        res += i\\n      return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047936,
                "title": "clear-kotlin-solution",
                "content": "Steps:\\n- We create a `StringBuilder` per row, since knowing the row for a character will be just enough to reconstitute the new string.\\n- We compute the length of a \"zigzag\", or in other words the length of a \"down-and-up\".\\n- We get the position of each letter according to that zigzag length: it\\'s either the position inside the zigzag (going down) or it\\'s the zigzag length minus the position (coming back up).\\n- Best is to draw the indices next to the letters on a piece of paper to get things clarified.\\n\\n```\\nfun convert(s: String, numRows: Int): String {\\n\\tval rows = Array(numRows) { StringBuilder() }\\n\\tval zigzagLength = maxOf(1, 2 * numRows - 2)\\n\\n\\tfor (i in s.indices) {\\n\\t\\tval position = i % zigzagLength\\n\\t\\tval row = when {\\n\\t\\t\\tposition < numRows -> position\\n\\t\\t\\telse -> zigzagLength - position\\n\\t\\t}\\n\\t\\trows[row].append(s[i])\\n\\t}\\n\\n\\treturn rows.joinToString(\"\")\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun convert(s: String, numRows: Int): String {\\n\\tval rows = Array(numRows) { StringBuilder() }\\n\\tval zigzagLength = maxOf(1, 2 * numRows - 2)\\n\\n\\tfor (i in s.indices) {\\n\\t\\tval position = i % zigzagLength\\n\\t\\tval row = when {\\n\\t\\t\\tposition < numRows -> position\\n\\t\\t\\telse -> zigzagLength - position\\n\\t\\t}\\n\\t\\trows[row].append(s[i])\\n\\t}\\n\\n\\treturn rows.joinToString(\"\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 731274,
                "title": "simple-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1)return s;\\n        \\n        Map<Integer,StringBuilder> map = new HashMap<>();\\n        \\n        boolean incr = true;\\n        int pos = 0;\\n        \\n        for(char c  : s.toCharArray()){\\n            \\n           if(pos == numRows)incr = false;\\n           if(pos == 1)incr = true;\\n            \\n            if(incr)pos++;\\n            else pos--;\\n            \\n            if(!map.containsKey(pos)){\\n                map.put(pos,new StringBuilder());\\n            }\\n            \\n            map.get(pos).append(c);\\n            \\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(Map.Entry<Integer,StringBuilder> entry : map.entrySet()){\\n            sb.append(entry.getValue());\\n        }\\n        \\n      return sb.toString();  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1)return s;\\n        \\n        Map<Integer,StringBuilder> map = new HashMap<>();\\n        \\n        boolean incr = true;\\n        int pos = 0;\\n        \\n        for(char c  : s.toCharArray()){\\n            \\n           if(pos == numRows)incr = false;\\n           if(pos == 1)incr = true;\\n            \\n            if(incr)pos++;\\n            else pos--;\\n            \\n            if(!map.containsKey(pos)){\\n                map.put(pos,new StringBuilder());\\n            }\\n            \\n            map.get(pos).append(c);\\n            \\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(Map.Entry<Integer,StringBuilder> entry : map.entrySet()){\\n            sb.append(entry.getValue());\\n        }\\n        \\n      return sb.toString();  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544020,
                "title": "java-solution-with-explanation",
                "content": "To: rearrange string by zigzag and read line by line\\n\\nThis is equivilent to: put characters with same new Row No. together in order\\n\\nSo we only need to get the new Row No. for each char and combine them \\n\\nIntroduce a variable \"up\" to mark the up/down trend would be very convenient.\\n\\nTip: when `numRows == 1`, we have to return `s` else would have ArrayIndexOutOfBoundsException\\n\\n```\\npublic String convert(String s, int numRows) {\\n\\tif (numRows == 1) return s;\\n\\tStringBuilder[] builder = new StringBuilder[numRows + 1];\\n\\tfor (int i = 0; i < builder.length; i++) builder[i] = new StringBuilder(\"\"); \\n\\n\\tint row = 1, col = 1;\\n\\tboolean up = false;\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tbuilder[row].append(c);\\n\\t\\tif (row == numRows) up = true; // we need to change direction to go up\\n\\t\\tif (row == 1) up = false; // we need to change direction to go down\\n\\t\\tif (up) {\\n\\t\\t\\trow--;\\n\\t\\t\\tcol++;\\n\\t\\t} else {\\n\\t\\t\\trow++;\\n\\t\\t}\\n\\t}\\n\\n\\tString res = \"\";\\n\\tfor (int i = 1; i < builder.length; i++) res += new String(builder[i]);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String convert(String s, int numRows) {\\n\\tif (numRows == 1) return s;\\n\\tStringBuilder[] builder = new StringBuilder[numRows + 1];\\n\\tfor (int i = 0; i < builder.length; i++) builder[i] = new StringBuilder(\"\"); \\n\\n\\tint row = 1, col = 1;\\n\\tboolean up = false;\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tbuilder[row].append(c);\\n\\t\\tif (row == numRows) up = true; // we need to change direction to go up\\n\\t\\tif (row == 1) up = false; // we need to change direction to go down\\n\\t\\tif (up) {\\n\\t\\t\\trow--;\\n\\t\\t\\tcol++;\\n\\t\\t} else {\\n\\t\\t\\trow++;\\n\\t\\t}\\n\\t}\\n\\n\\tString res = \"\";\\n\\tfor (int i = 1; i < builder.length; i++) res += new String(builder[i]);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 429769,
                "title": "easy-understanding-solution-o-n-99",
                "content": "by [Michelle\\u5C0F\\u68A6\\u60F3\\u5BB6](https://youtu.be/re-WQ14s-Kg).\\n\\nOriginal Python version\\n```python\\ndef convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1 or numRows >= len(s):\\n            return s\\n        \\n        row, step = 0, 0\\n        res = [\\'\\'] * len(s)\\n        \\n        for c in s:\\n            res[row] += c\\n            \\n            if row == 0:\\n                step = 1\\n            elif row == numRows - 1:\\n                step = -1\\n                \\n            row += step\\n        \\n        return \"\".join(res)\\n```\\n\\nJava version\\n```java\\npublic String convert(String s, int numRows) {\\n        if (numRows == 1 || numRows >= s.length()) return s;  \\n        \\n        char[] chars = s.toCharArray();\\n        StringBuilder[] zigzag = new StringBuilder[numRows];\\n        \\n        int row = 0;\\n        int step = 0;\\n        \\n        for (char c : chars) {\\n            if (zigzag[row] == null) {\\n                zigzag[row] = new StringBuilder();\\n            }\\n            zigzag[row].append(c);\\n            \\n            if (row == 0) {\\n                step = 1;\\n            } else if (row == numRows - 1) {\\n                step = -1;\\n            }\\n            \\n            row += step;\\n        }\\n        \\n        StringBuilder res = new StringBuilder(s.length());\\n        for (StringBuilder sb : zigzag) {\\n            res.append(sb);\\n        }\\n        return res.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```python\\ndef convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1 or numRows >= len(s):\\n            return s\\n        \\n        row, step = 0, 0\\n        res = [\\'\\'] * len(s)\\n        \\n        for c in s:\\n            res[row] += c\\n            \\n            if row == 0:\\n                step = 1\\n            elif row == numRows - 1:\\n                step = -1\\n                \\n            row += step\\n        \\n        return \"\".join(res)\\n```\n```java\\npublic String convert(String s, int numRows) {\\n        if (numRows == 1 || numRows >= s.length()) return s;  \\n        \\n        char[] chars = s.toCharArray();\\n        StringBuilder[] zigzag = new StringBuilder[numRows];\\n        \\n        int row = 0;\\n        int step = 0;\\n        \\n        for (char c : chars) {\\n            if (zigzag[row] == null) {\\n                zigzag[row] = new StringBuilder();\\n            }\\n            zigzag[row].append(c);\\n            \\n            if (row == 0) {\\n                step = 1;\\n            } else if (row == numRows - 1) {\\n                step = -1;\\n            }\\n            \\n            row += step;\\n        }\\n        \\n        StringBuilder res = new StringBuilder(s.length());\\n        for (StringBuilder sb : zigzag) {\\n            res.append(sb);\\n        }\\n        return res.toString();\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 363853,
                "title": "python-o-n-space-and-time-detail-explanation-turtle-code",
                "content": "1) skipping trails include cases when: (return original input string)\\n\\t- numRows = 1\\n\\t- string length < 2\\n2) main algorithm\\n\\t- thinking of an array with numRows elements, each element will be a row of zigzag\\n\\t- note that each element will be a string, where we can **add char to end of such string by doing string + char**\\n\\t- variable **index** and **step** will indicate which row to put current char and which row we heading to next\\n\\t- **Given input: paypalishiring, 4**\\n\\t\\t- for each individual char in our input: Do following\\n\\t\\t\\t- **add char to the end of the string at index**\\n\\t\\t\\t- **if index = 0: set step to 1 (going down the row)**\\n\\t\\t\\t- **if index = numRows: set step to -1, (going back up the row)**\\n\\t\\t\\t- **update index by step**\\n\\n\\n# A quick simulation of the algorithm\\n**Given input: paypalishiring, 4**\\n**Zigzag Structure:**\\n```\\nP     I    N\\nA   L S  I G\\nY A   H R\\nP     I\\n```\\n\\nFirst we start at top row travel to bottom row, we will encounter the first 4 char \\'P A Y P\\'\\nput these 4 char into each element in our solution array:\\n```\\nans = [\\'P\\', \\'A\\', \\'Y\\', \\'P\\']\\n```\\n\\nNext we start at the bottom row, traveling to the top row, we can do this by having step = -1:\\n```\\n# for char \\'A\\': add to row 3 ====> ans = [\\'P\\', \\'A\\', \\'YA\\', \\'P\\']\\n# for char \\'L\\': add to row 2 ====> ans = [\\'P\\', \\'AL\\', \\'YA\\', \\'P\\']\\n# for char \\'I\\': add to row 1 ====> ans = [\\'PI\\', \\'AL\\', \\'YA\\', \\'P\\']\\n```\\n\\nFrom top row to bottom row:\\n```\\n# for char \\'S\\': add to row 2 ====> ans = [\\'PI\\', \\'AS\\', \\'YA\\', \\'P\\']\\n# for char \\'H\\': add to row 3 ====> ans = [\\'PI\\', \\'AS\\', \\'YAH\\', \\'P\\']\\n# for char \\'I\\': add to row 4 ====> ans = [\\'PI\\', \\'AS\\', \\'YAH\\', \\'PI\\']\\n```\\n\\nFrom bottom row to top row:\\n```\\n# for char \\'R\\': add to row 3 ====> ans = [\\'PI\\', \\'AS\\', \\'YAHR\\', \\'PI\\']\\n# for char \\'I\\': add to row 2 ====> ans = [\\'PI\\', \\'ASI\\', \\'YAHR\\', \\'PI\\']\\n# for char \\'N\\': add to row 1 ====> ans = [\\'PIN\\', \\'ASI\\', \\'YAHR\\', \\'PI\\']\\n```\\n\\nFinally:\\n```\\n# add \\'G\\' to row 2 ====> ans = [\\'PIN\\', \\'ASIG\\', \\'YAHR\\', \\'PI\\']\\n# convert to string we got :  \\'PINASIGYAHRPI\\'\\n```\\n\\n**Time and space complexity analysis:**\\n- we are looping through the string once, so the time complexity is **O(n)**, for n to be the length of input string.\\n- we are having array ans to hold our zigzag output, so it will have n characters, thus space complexity is also **O(n)**.\\n\\n**Python Code:**\\n```\\ndef convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1 or len(s) < 2:\\n            return s\\n        else:\\n            ans = [\\'\\']*numRows\\n            index, step = 0, 1\\n\\n            for char in s:\\n                ans[index] += char\\n                if index == 0:\\n                    step = 1\\n                elif index == numRows-1:\\n                    step = -1\\n                index += step\\n                \\n            return \\'\\'.join(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nP     I    N\\nA   L S  I G\\nY A   H R\\nP     I\\n```\n```\\nans = [\\'P\\', \\'A\\', \\'Y\\', \\'P\\']\\n```\n```\\n# for char \\'A\\': add to row 3 ====> ans = [\\'P\\', \\'A\\', \\'YA\\', \\'P\\']\\n# for char \\'L\\': add to row 2 ====> ans = [\\'P\\', \\'AL\\', \\'YA\\', \\'P\\']\\n# for char \\'I\\': add to row 1 ====> ans = [\\'PI\\', \\'AL\\', \\'YA\\', \\'P\\']\\n```\n```\\n# for char \\'S\\': add to row 2 ====> ans = [\\'PI\\', \\'AS\\', \\'YA\\', \\'P\\']\\n# for char \\'H\\': add to row 3 ====> ans = [\\'PI\\', \\'AS\\', \\'YAH\\', \\'P\\']\\n# for char \\'I\\': add to row 4 ====> ans = [\\'PI\\', \\'AS\\', \\'YAH\\', \\'PI\\']\\n```\n```\\n# for char \\'R\\': add to row 3 ====> ans = [\\'PI\\', \\'AS\\', \\'YAHR\\', \\'PI\\']\\n# for char \\'I\\': add to row 2 ====> ans = [\\'PI\\', \\'ASI\\', \\'YAHR\\', \\'PI\\']\\n# for char \\'N\\': add to row 1 ====> ans = [\\'PIN\\', \\'ASI\\', \\'YAHR\\', \\'PI\\']\\n```\n```\\n# add \\'G\\' to row 2 ====> ans = [\\'PIN\\', \\'ASIG\\', \\'YAHR\\', \\'PI\\']\\n# convert to string we got :  \\'PINASIGYAHRPI\\'\\n```\n```\\ndef convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1 or len(s) < 2:\\n            return s\\n        else:\\n            ans = [\\'\\']*numRows\\n            index, step = 0, 1\\n\\n            for char in s:\\n                ans[index] += char\\n                if index == 0:\\n                    step = 1\\n                elif index == numRows-1:\\n                    step = -1\\n                index += step\\n                \\n            return \\'\\'.join(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 295830,
                "title": "share-java-solution-40ms-memory-99",
                "content": "\\n```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows == 1) {\\n            return s;\\n        }\\n        StringBuilder sb = new StringBuilder(s.length());\\n        int n = numRows -1;\\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = i, k = 0; j < s.length(); j += 2, k++) {\\n                if (k % n == 0) {\\n                    sb.append(s.charAt(j));\\n                    continue;\\n                }\\n                if ((i + k) % n == 0) {\\n                    sb.append(s.charAt(j));\\n                    continue;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/dangerous1990/image_1558343393.png)\\n* **k** index of column\\n* **i** index of row\\n* n = numRows -1\\n*  **j** index of string\\n\\nwhen k=0,4 k%n=0,\\n5,6,7 (i+k)%n=0\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        if (numRows == 1) {\\n            return s;\\n        }\\n        StringBuilder sb = new StringBuilder(s.length());\\n        int n = numRows -1;\\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = i, k = 0; j < s.length(); j += 2, k++) {\\n                if (k % n == 0) {\\n                    sb.append(s.charAt(j));\\n                    continue;\\n                }\\n                if ((i + k) % n == 0) {\\n                    sb.append(s.charAt(j));\\n                    continue;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290913,
                "title": "c-100-speed-beat-100-memory-beat",
                "content": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        \\n        if (numRows <= 1) { return s; }\\n        \\n        int aRowLen[numRows];\\n        char aRowChar[numRows][s.size() / (numRows - 1) + 2];\\n        \\n        memset(aRowLen, 0, sizeof(aRowLen));\\n        memset(aRowChar, 0, sizeof(aRowChar));\\n        \\n        int aRow = 0;\\n        int aCol = 0;\\n        \\n        int i = 0;\\n        bool aVertical = true;\\n        while (i < s.size()) {\\n            \\n            if (aVertical) {\\n                \\n                aRowChar[aRow][aRowLen[aRow]++] = s[i];\\n                \\n                aRow++;\\n                if (aRow > (numRows - 1)) {\\n                    aRow = (numRows - 1);\\n                    aVertical = false;\\n                }\\n            } else {\\n                \\n                aRow -= 1;\\n                aRowChar[aRow][aRowLen[aRow]++] = s[i];\\n                \\n                if (aRow <= 0) {\\n                    aRow = 1;\\n                    aVertical = true;\\n                }\\n            }\\n            ++i;\\n        }\\n        \\n        string aResult;\\n        for (int aRow=0;aRow<numRows;aRow++) {\\n            aResult += string(aRowChar[aRow]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nNot sure if RnG plays in to speed rolls, might be faster on some runs. Basically, we have 3 copies of the data floating around, but do not allocate more memory than needed (except for maybe a partial subset of the \"rows\")",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        \\n        if (numRows <= 1) { return s; }\\n        \\n        int aRowLen[numRows];\\n        char aRowChar[numRows][s.size() / (numRows - 1) + 2];\\n        \\n        memset(aRowLen, 0, sizeof(aRowLen));\\n        memset(aRowChar, 0, sizeof(aRowChar));\\n        \\n        int aRow = 0;\\n        int aCol = 0;\\n        \\n        int i = 0;\\n        bool aVertical = true;\\n        while (i < s.size()) {\\n            \\n            if (aVertical) {\\n                \\n                aRowChar[aRow][aRowLen[aRow]++] = s[i];\\n                \\n                aRow++;\\n                if (aRow > (numRows - 1)) {\\n                    aRow = (numRows - 1);\\n                    aVertical = false;\\n                }\\n            } else {\\n                \\n                aRow -= 1;\\n                aRowChar[aRow][aRowLen[aRow]++] = s[i];\\n                \\n                if (aRow <= 0) {\\n                    aRow = 1;\\n                    aVertical = true;\\n                }\\n            }\\n            ++i;\\n        }\\n        \\n        string aResult;\\n        for (int aRow=0;aRow<numRows;aRow++) {\\n            aResult += string(aRowChar[aRow]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202682,
                "title": "c-solution-beats-100",
                "content": "```c\\nchar* convert(char* s, int numRows) {\\n    if (numRows == 1) {\\n        return s;\\n    }\\n    int len = strlen(s);\\n    char *buf = (char *) malloc(sizeof(char) * (len + 1));\\n    int i = 0;\\n    for (int row = 0; row < numRows; row++) {\\n        int step = (numRows - 1) * 2;\\n        int j = 0;\\n        while (j + row < len) {\\n            buf[i++] = s[j + row];\\n            j += step;\\n            if (row > 0 && row < numRows - 1 && j - row < len) {\\n                buf[i++] = s[j - row];\\n            }\\n        }\\n    }\\n    buf[len] = \\'\\\\0\\';\\n    return buf;\\n}\\n```",
                "solutionTags": [],
                "code": "```c\\nchar* convert(char* s, int numRows) {\\n    if (numRows == 1) {\\n        return s;\\n    }\\n    int len = strlen(s);\\n    char *buf = (char *) malloc(sizeof(char) * (len + 1));\\n    int i = 0;\\n    for (int row = 0; row < numRows; row++) {\\n        int step = (numRows - 1) * 2;\\n        int j = 0;\\n        while (j + row < len) {\\n            buf[i++] = s[j + row];\\n            j += step;\\n            if (row > 0 && row < numRows - 1 && j - row < len) {\\n                buf[i++] = s[j - row];\\n            }\\n        }\\n    }\\n    buf[len] = \\'\\\\0\\';\\n    return buf;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197612,
                "title": "python-beatiful-5-lines-of-code-which-hit-100-percentile",
                "content": "```\\nfrom itertools import chain, cycle\\n\\nclass Solution(object):\\n    def convert(self, s, N):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        lines = [\\'\\'] * N\\n        levels = chain(range(N), range(N - 2, 0, -1))        \\n        for i, s in zip(cycle(levels), s):\\n            lines[i] += s\\n            \\n        return \\'\\'.join(lines)\\n```\\n\\nPlease vote, I will add full explanation if this topic will hit at least 5 points.",
                "solutionTags": [],
                "code": "```\\nfrom itertools import chain, cycle\\n\\nclass Solution(object):\\n    def convert(self, s, N):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        lines = [\\'\\'] * N\\n        levels = chain(range(N), range(N - 2, 0, -1))        \\n        for i, s in zip(cycle(levels), s):\\n            lines[i] += s\\n            \\n        return \\'\\'.join(lines)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151388,
                "title": "javascript-solution",
                "content": "```js\\nfunction convert(s, numRows) {\\n  if (numRows === 1) {\\n    return s;\\n  }\\n\\n  const N = s.length;\\n  const arr = [...Array(numRows)].map(r => []);\\n\\n  for (let i = 0; i < N; i++) {\\n    const pos = i % (2*numRows-2);\\n    const ii = pos < numRows ? pos : 2*numRows-2-pos;\\n    arr[ii].push(s[i]);\\n  }\\n\\n  return arr.map(r => r.join(\\'\\')).join(\\'\\');\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction convert(s, numRows) {\\n  if (numRows === 1) {\\n    return s;\\n  }\\n\\n  const N = s.length;\\n  const arr = [...Array(numRows)].map(r => []);\\n\\n  for (let i = 0; i < N; i++) {\\n    const pos = i % (2*numRows-2);\\n    const ii = pos < numRows ? pos : 2*numRows-2-pos;\\n    arr[ii].push(s[i]);\\n  }\\n\\n  return arr.map(r => r.join(\\'\\')).join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 122056,
                "title": "go-solution",
                "content": "```\\nfunc convert(s string, numRows int) string {\\n   length := len(s)\\n\\n    bufferSlice := make([]bytes.Buffer, numRows)\\n\\n  for i := 0; i < len(bufferSlice); i++ {\\n\\t  var buffer bytes.Buffer\\n\\t  bufferSlice[i] = buffer\\n  }\\n   i := 0\\n  for i < length {\\n  \\t  for index := 0; index < numRows && i < length; index++ {\\n\\t\\t  bufferSlice[index].WriteString(string(s[i]))\\n  \\t  \\t   i++\\n\\t  }\\n\\t  for index := numRows - 2; index >= 1 && i < length; index-- {\\n\\t\\t  bufferSlice[index].WriteString(string(s[i]))\\n\\t  \\ti++\\n\\t  }\\n  }\\n  for index := 1; index < len(bufferSlice); index++{\\n\\t  bufferSlice[0].WriteString(bufferSlice[index].String())\\n  }\\n  return bufferSlice[0].String()\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc convert(s string, numRows int) string {\\n   length := len(s)\\n\\n    bufferSlice := make([]bytes.Buffer, numRows)\\n\\n  for i := 0; i < len(bufferSlice); i++ {\\n\\t  var buffer bytes.Buffer\\n\\t  bufferSlice[i] = buffer\\n  }\\n   i := 0\\n  for i < length {\\n  \\t  for index := 0; index < numRows && i < length; index++ {\\n\\t\\t  bufferSlice[index].WriteString(string(s[i]))\\n  \\t  \\t   i++\\n\\t  }\\n\\t  for index := numRows - 2; index >= 1 && i < length; index-- {\\n\\t\\t  bufferSlice[index].WriteString(string(s[i]))\\n\\t  \\ti++\\n\\t  }\\n  }\\n  for index := 1; index < len(bufferSlice); index++{\\n\\t  bufferSlice[0].WriteString(bufferSlice[index].String())\\n  }\\n  return bufferSlice[0].String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587,
                "title": "java-quick-o-n-w-explanation",
                "content": "The trick to solving this problem is pattern recognition. Using the original String of \"PAYPALISHIRING\" and a variable number of rows, you can begin to see a pattern evolve. Values in brackets are the respective indexes of the String, \"Step\" represents the index mutation taken each iteration with a comma separating alternating values:\\n\\n3 rows:\\n```\\nP A H N <-(0,4,8...)Step=4\\nAPLSIIG <-(1,3,5...)Step=2\\nY I R   <-(2,6,10...)Step=4\\n```\\n\\n4 rows:\\n```\\nP  I  N <-(0,6,12...)Step=6\\nA LS IG <-(1,5,7...)Step=4,2\\nYA HR   <-(2,4,8...)Step=2,4\\nP  I    <-(3,9,15...)Step=6\\n```\\n\\n5 rows:\\n```\\nP   H <-(0,8,16...)Step=8\\nA  SI <-(1,7,9...)Step=6,2\\nY I R <-(2,6,10...)Step=4\\nPL  IG<-(3,5,11...)Step=2,6\\nA   N <-(4,12...)Step=8\\n```\\n\\nFrom this pattern you can deduce three things:\\n1) The \"original\" step taken is equal to (numRows * 2) - 2. This is only not true when numRows = 1.\\n2) The \"first\" step taken on each step decrements by 2 from the original step each iteration until it equals 0, at which point the original step is restored (i.e this is the last row). For example, 8->6->4->2->0(8). You can use the given row count starting at 0, i, to calculate this quickly using originalStep - (i * 2). This will only be untrue on the last step.\\n3) The alternating steps can be calculated by taking the absolute value of the current step and subtracting the original step from it. For example using the second row of the \"5 rows\" example, abs(6-8) = 2, abs(2-8) = 6, and so forth.\\n\\nMy solution:\\n\\n```\\n    public String convert(String s, int numRows) {\\n        if(numRows < 2 || numRows >= s.length()) return s;\\n        StringBuilder sb = new StringBuilder(s.length());\\n        int origStep = numRows * 2 - 2;\\n        int step = origStep;\\n        for(int i = 0; i < numRows; i++){\\n            step = i == numRows - 1 ? origStep : origStep - i * 2;\\n            int curr = i;\\n            while(curr < s.length()){\\n                sb.append(s.charAt(curr));\\n                curr += step;\\n                int temp = Math.abs(step - origStep);\\n                step = temp == 0 ? origStep : temp; //First/last rows\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nP A H N <-(0,4,8...)Step=4\\nAPLSIIG <-(1,3,5...)Step=2\\nY I R   <-(2,6,10...)Step=4\\n```\n```\\nP  I  N <-(0,6,12...)Step=6\\nA LS IG <-(1,5,7...)Step=4,2\\nYA HR   <-(2,4,8...)Step=2,4\\nP  I    <-(3,9,15...)Step=6\\n```\n```\\nP   H <-(0,8,16...)Step=8\\nA  SI <-(1,7,9...)Step=6,2\\nY I R <-(2,6,10...)Step=4\\nPL  IG<-(3,5,11...)Step=2,6\\nA   N <-(4,12...)Step=8\\n```\n```\\n    public String convert(String s, int numRows) {\\n        if(numRows < 2 || numRows >= s.length()) return s;\\n        StringBuilder sb = new StringBuilder(s.length());\\n        int origStep = numRows * 2 - 2;\\n        int step = origStep;\\n        for(int i = 0; i < numRows; i++){\\n            step = i == numRows - 1 ? origStep : origStep - i * 2;\\n            int curr = i;\\n            while(curr < s.length()){\\n                sb.append(s.charAt(curr));\\n                curr += step;\\n                int temp = Math.abs(step - origStep);\\n                step = temp == 0 ? origStep : temp; //First/last rows\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3700,
                "title": "8-lines-python-code-using-mod",
                "content": "    class Solution(object):\\n    def convert(self, s, numRows):\\n        if numRows <2: return s\\n        n, m, i = len(s),numRows+numRows-2, 0\\n        rows = ['']*numRows\\n        while i < n:\\n            r = min(i%m, m-i%m)\\n            rows[r] += s[i]\\n            i += 1\\n        return ''.join(rows)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def convert(self, s, numRows):\\n        if numRows <2: return s\\n        n, m, i = len(s),numRows+numRows-2, 0\\n        rows = ['']*numRows\\n        while i < n:\\n            r = min(i%m, m-i%m)\\n            rows[r] += s[i]\\n            i += 1\\n        return ''.join(rows)",
                "codeTag": "Java"
            },
            {
                "id": 3706,
                "title": "a-short-c-o-n-time-o-n-space-solution",
                "content": "    public class Solution {\\n        public string Convert(string s, int numRows) {\\n            if (numRows==1)\\n                return s;\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 0; i < numRows; i++){\\n                int increment = i * 2;\\n                for(int j=i; j<s.Length; j+=increment!=0?increment:numRows*2-2){\\n                    sb.Append(s[j]);\\n                    increment = numRows*2-2 - increment;\\n                }\\n            }\\n            return sb.ToString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public string Convert(string s, int numRows) {\\n            if (numRows==1)\\n                return s;\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 0; i < numRows; i++){\\n                int increment = i * 2;\\n                for(int j=i; j<s.Length; j+=increment!=0?increment:numRows*2-2){\\n                    sb.Append(s[j]);\\n                    increment = numRows*2-2 - increment;\\n                }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567156,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1785574,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1785511,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1567157,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1785317,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1785539,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1785565,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1565933,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1566065,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1566233,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1567156,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1785574,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1785511,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1567157,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1785317,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1785539,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1785565,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1565933,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1566065,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1566233,
                "content": [
                    {
                        "username": "waitingtodie",
                        "content": "No details of what is required at all - it's almost like this:\\ngiven a string Idonthaveaclue, convert it to wtfareyoutalkingabout, and oh yes do it in a zig zag pattern. good luck.\\n\\nWhen you have to spend more time working out the spec than working on the problem, it's a sign of a bad question."
                    },
                    {
                        "username": "sunil-9",
                        "content": "A zigzag pattern is a specific geometric pattern characterized by a series of diagonal lines that alternate in direction, typically forming a \"zig\" and a \"zag\" shape. It\\'s not a random pattern; rather, it follows a structured and repeating sequence of movements. In the given question, the pattern is created by placing characters in rows, and the characters move diagonally between rows in a specific sequence."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Bro this is really simple problem. Don\\'t know why people hate it so much! problem is solved in only a loop."
                    },
                    {
                        "username": "ankush920",
                        "content": "love you bro :)"
                    },
                    {
                        "username": "somendrasingh019",
                        "content": "[@codeblaze_](/codeblaze_)  BUT PAYPALISHIRING \\uD83E\\uDD23"
                    },
                    {
                        "username": "iamtanmayag",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02true bruh\\n"
                    },
                    {
                        "username": "khess13",
                        "content": "this one made me feel dumb. I think you have to read it vertical first, then up diagonally, down again.\\n\\nEXAMPLEWORD\\nrow = 4\\n\\n1  E          E\\n2  X      L W\\n3  A   P    O  D\\n4  M         R\\n\\nrip these letters and spacing"
                    },
                    {
                        "username": "user8296H",
                        "content": "HAHAH :)"
                    },
                    {
                        "username": "c_v_s",
                        "content": "When Paypal don\\'t want to hire you : )"
                    },
                    {
                        "username": "lafllamme",
                        "content": "bro on god same thought hahahaha wtf is this pattern"
                    },
                    {
                        "username": "Manish_1001",
                        "content": "Ironically, Paypal is laying off "
                    },
                    {
                        "username": "jatinchoubey_19",
                        "content": "Damnn!!! All this time, i was reading it as \"Paypal i shiring\" HAHA"
                    },
                    {
                        "username": "sushi27",
                        "content": "In question, we need to convert the string in zig-zag pattern i.e. think we have 2D array with row n and no limit of column and write the given string in this format\nFirst go from top to down writing each character, then go to next column but one above row until you reach top row. And follow this pattern repeatedly.\nPattern (row = 5)\n```\n1                  9                      17\n2             8    10               16   18                24\n3       7          11         15         19          23 \n4   6              12   14               20    22\n5                 13                    21\n```"
                    },
                    {
                        "username": "mohitosri",
                        "content": "thanks bro,  now it is clear that how will be the question\\'s output ."
                    },
                    {
                        "username": "AgusCloud",
                        "content": "thank you, your comment was more useful than the request"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nIt will be a good idea  if you provide a detailed test case when there is a 'Run time error'. This will ease the things to debug, especially when the code runs perfectly fine on local machines but not on Leet Code.\\n\\nThanks."
                    },
                    {
                        "username": "S-U-M-I-T",
                        "content": "in such cases just print the input data you can try that on local machines and fix it \\nfor example in this case you have input int row, and String str \\nthen just print it like the following\\nclass Solution {\\n      public String convert(int row, String str){\\n          System.out.println(\"row-> \"+row+\" str-> \"+str);\\n          ..................\\n          .......\\n          ....\\n     }\\n}\\nthis way you can see it will print it in std output of leetcode just try that in your local machine and it will fix the problem "
                    },
                    {
                        "username": "diabloexodia",
                        "content": "try directly returning the string if R=1"
                    },
                    {
                        "username": "hendrywiranto",
                        "content": "try print something to stdout, it showed the TC on me"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don\\'t think too much, use a 2D array to generate the pattern first, and then join characters of each row. Sometimes naive version works best"
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        if(numRows == 1) return s;\\n        String[] strArr = s.split(\"\");\\n        String ans = \"\";\\n        for(int i = 0; i < numRows; i++) {\\n            int j = i;\\n            while(j < strArr.length) {\\n                ans += strArr[j];\\n                if(!(i == j || i == 0 || i == numRows - 1)) {\\n                    j = j + 2 * i;\\n                    if(j < strArr.length) {\\n                        ans += strArr[j];\\n                    }\\n                }\\n                if(i < numRows - 1)\\n                    j = j + 2*(numRows - i - 1);\\n                else\\n                    j = j + 2*(numRows - 1);\\n            }\\n            // System.out.println(ans);\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Subhan_11",
                        "content": "i did the same but time limits exceeds"
                    },
                    {
                        "username": "rotem250297",
                        "content": "I always get Time Limit Exceeded\\nthis is my solution:\\n\\ndef convert(self, s, numRows):\\n        \"\"\"\\n        :type s: str\\n        :type numRows: int\\n        :rtype: str\\n        \"\"\"\\n        new_s=\"\"\\n        matrix = np.zeros((numRows,len(s)),dtype=str)\\n        i=0\\n        j=0\\n        k=0\\n        \\n        while k<len(s):\\n            matrix[i][j]=s[k]\\n            if i+1==numRows:\\n                while i>0:\\n                    i-=1\\n                    j+=1\\n                    k+=1\\n                    matrix[i][j]=s[k]\\n            else:        \\n                i+=1\\n                k+=1\\n\\n        for row in matrix:\\n            new_s+=\\'\\'.join(row)\\n        return new_s"
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@armagan979](/armagan979) You can add the edge case at the top\\n if(numRows === 1) return s;\\n\\ncheck out my code in JS.\\n///////////////////////////////////////////////code starts////////////////////////////////////////////\\nvar convert = function(s, numRows) {\\n    \\n    if(numRows === 1) return s;\\n    let zigZagArr = [];\\n    for(let i = 0; i < numRows; i++) {\\n        zigZagArr.push([]);\\n    };\\n\\n    let row = 0;\\n    let column = 0;\\n    let i = 0;\\n    let goUp = false;\\n    while(i < s.length) {\\n        if(!goUp) {\\n           [row, i] = goDown(row, column, i);\\n           goUp = !goUp;\\n           column++;\\n        } else {\\n            [row,column, i] = goUpD(row,column,i);\\n            goUp = !goUp;\\n        }\\n    }\\n\\n    function goUpD(r,c,i) {\\n        while(r > -1 && i < s.length) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            c++;\\n            r--;\\n        }\\n        r = 1;\\n        c = c - 1;\\n        return [r,c,i];\\n    }\\n\\n    function goDown(r,c,i) {\\n        while(r < numRows) {\\n            zigZagArr[r][c] = s[i];\\n            i++;\\n            r++;\\n        }\\n\\n        r = numRows - 2;\\n        return [r,i];\\n    }\\n\\n    zigZagArr = zigZagArr.map((arr) => {\\n        return arr.filter((char) => {\\n            return char !== undefined;\\n        });\\n    });\\n    \\n    let result = \\'\\';\\n    for(let i = 0; i < zigZagArr.length; i++) {\\n        result += zigZagArr[i].join(\\'\\');\\n    };\\n\\n    return result;\\n};\\n////////////////////////////////////////////////code ends/////////////////////////////////////////"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) think it might be the \"edge\" cases, i.e. when numRows is 1 or s.length <= numRows ; for me those gave time limit exceeded. Hope you managed to solve it in the mean time :)"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee)  there must be some error in your code\\n"
                    },
                    {
                        "username": "armagan979",
                        "content": "//could you help here.. not understanding what is wring here.\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "i did it exactly that but it gives me tle, which is sad : ("
                    },
                    {
                        "username": "b0968760387",
                        "content": "Alien problem again today haha "
                    },
                    {
                        "username": "bk_3497",
                        "content": "I am ignoring this question for a long time."
                    },
                    {
                        "username": "Hemant3112",
                        "content": "I too was ignoring it but it was coming infront of my eyes many many times so i though let scramble our mind in this question \\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@devhindo](/devhindo) i suggest giving up at this point LMAO, see a solution"
                    },
                    {
                        "username": "devhindo",
                        "content": "I got like 20 wrong submissions"
                    },
                    {
                        "username": "vigneshm",
                        "content": "I see a lot of answers specific to the code, but I'm trying to understand what it generally means in LeetCode OJ"
                    },
                    {
                        "username": "haishenjun",
                        "content": "What should be the pattern of \"ABC\", 2?\\n\\nI suppose it to be \\n\\nA\\nB C\\n\\nand return \"ABC\".\\n\\nWhy is the answer \"ACB\"?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s like:\\n\\nA C\\nB"
                    },
                    {
                        "username": "AHCoding",
                        "content": "The pattern would be \\nA C\\nB\\nSo first we would read A then C then B that is why the answer is \\'ACB\\'. I understand the question and the task but I am unable to code, Plus I also figured out the n-Notation of the first layer step which is steps = n + (n -2)... if you know what I mean..."
                    },
                    {
                        "username": "Yanderuri",
                        "content": "The C is supposed to be on the first row. Since BC is on the \"diagonal\" shooting backup."
                    },
                    {
                        "username": "ayushkumartiwari468",
                        "content": "you typed it wrongly the pattern would be\\nA C\\nB"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "When u fill 1 col acc to the row no. like r = 2 here. it fills here first \nA\n|\nB\nthen move up to next col for same style of fillings untill the chars r not empty in gievn string. so it goes up like this\n```\nA   C\n|  /\nB / \n```"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "ACB is correct. You fill up every row and then move to the next column starting at the first row again. \\nRow 1: A C\\nRow 2: B\\n\\nJoining row 1 and 2 would then lead to -> ACB "
                    },
                    {
                        "username": "knitin",
                        "content": "Zig Zag Pattern \\n A  C \\n B\\nFirst write full column than Bottom to Up Diagonal .\\n"
                    },
                    {
                        "username": "meeshaw",
                        "content": "If the number of rows is 2, there is no intermittent diagonal rows => C goes to the top row => ACB"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "[@ittan](/ittan)   and how, exactly, did you determine which row the C should be written on?"
                    },
                    {
                        "username": "skrehbiel",
                        "content": "According to the specification given, when the numRows is even, the pattern writes to the higher-numbered center row first.  So Haishenjun is correct.   They gave the example shape (but I'm using numbers instead of the string):\n1________7\n2_____6__8\n3__5_____9\n4_________\n\nso according to their example, the pattern\n1___3\n2\nwould be wrong, because the 5 is on the lower row than the 6.\n\nSince we're given no specs whatsoever on the pattern, we can only infer it to be\n1\n2___3\n\nThere are two competing interpretations we could make.   One interpretation is that when numRows is even, always use the bottom-center row first, as in the example output.   The other possibility is that the rule just mentioned does not apply to the border rows, but then writing the 3 on the top or bottom row would also be wrong.   (and Leetcode expects to charge a membership fee for this junk?)\n\nMaybe if they bothered to define the question, I could give a better answer!  \n\n(by the way, this is a great test of whether you want to work for an employer or not - if they blame you for not being a mind-reader, then you probably don't want the job anyway!)"
                    },
                    {
                        "username": "ittan",
                        "content": "ACB is correct \\nSo basically string ABC with 2 numRows will give a string in below form\\nA C\\nB \\n\\nand not \\nA\\nB C \\nas you have mentioned in your comment"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "pattern is like :\\n|  /|  /|\\n|/  |/  |\\n\\nSo ABC, 2 will be\\nA  C\\nB\\n\\nYou can\\'t put them like \\n|    |\\n| _ |   and so on..\\n"
                    },
                    {
                        "username": "arthertz",
                        "content": "You are not quite right, it will begin to go up again after hitting the \"floor\" with B\n\nSo it will look like this:\nA C\nB\n\nThen it will read \"ACB\" as stated."
                    },
                    {
                        "username": "ank031100",
                        "content": "here the pattern is like\n\nA _  E\nB D\nC _\n\nfor s = ABCDE and r =3\nso first go down in that column and then come up but in that process each column will have only one char.\n\nso for ABC and r=3\nA  C\nB  \n\nand ans = ACB"
                    },
                    {
                        "username": "xuyi_sg",
                        "content": "I\\u2018m so confused about the qeustion description, please help me clarify. \\nIf no one answers, I have to look at your answers instead of to solve by meself first. And that will be sad. \\n\\nSuppose the input string is always \"ABCDEFGHIJKLMN\".\\n\\n**Case 1:**\\n\\nIf rowNum = 2, what does the zig zag pattern look like? Should C, D and G be inline with the first row or the section row ?\\n\\n\\nACDFGIJLM\\n\\nB[]E[]H[]K[]N\\n\\n**Case 2:**\\n\\nif rowNum = 4, what does the zig zag pattern look like? How many characters should be placed in the odd columns (suppose index starts from 0)? If there is only one character, same question as case 1, which row should this one character be inline with? \\n\\nA[]G[]M\\n\\nBEHKN\\n\\nCFIL\\n\\nD[]J[]\\n\\n**Case 3:**\\n\\nif rowNum = 5, how many columns should be between the adjacent two 5-row columns to make the shape like \"Z\"? Is it still only one or three (as shown below)?\\n\\nA[][][]I[]        \\n\\nBF[][]JN         \\n\\nC[]GK[]\\n\\nD[][]HL[]\\n\\nE[][][]M[]"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Suppose the input string is always \"ABCDEFGHIJKLMN\".\\n According to\\xA0my understanding, your case 1 is correct.\\n\\nCase 2:\\nif rowNum = 4, \\n\\nA[][]G[][]M\\n\\nB[]FH[]LN\\n\\nCE[]IK[][]\\n\\nD[][]J[][][]\\n\\nCase 3:\\nif rowNum = 5, \\n\\nA[][][]I[]\\n\\nB[][]HJ[]\\n\\nC[]GK[]\\n\\nDF[][]LN\\n\\nE[][][]M[]"
                    }
                ]
            },
            {
                "id": 1566731,
                "content": [
                    {
                        "username": "vikaslinux",
                        "content": "Please provide a testcase when number of rows is 6 and 7.Actually the problem is not so clear to me."
                    },
                    {
                        "username": "shutdown-r",
                        "content": "[@hanupreeti_jain](/hanupreeti_jain) Thank you this helps"
                    },
                    {
                        "username": "hanupreeti_jain",
                        "content": "If you consider the indices of a 0 indexed string this is how the pattern would look\\n\\nFor rows = 6:\\n0________10 ________________20\\n1_____9__11____________19__21\\n2___8____12_________18_____22\\n3__7_____13______17________23\\n4_6______14__16____________24\\n5________15_________________25\\n\\nFor rows = 7:\\n0_______________12_____________________24\\n1__________11__13_________________23__25\\n2_______10_____14_____________22______26\\n3_____9_________15_________21_________27\\n4___8___________16_____20_____________28\\n5_7_____________17_19_________________29\\n6_______________18_____________________30"
                    },
                    {
                        "username": "zwsjink",
                        "content": "Strange, I got wrong answer, but the expected and output are exactly the same.!!!\\n\\nInput:\\t\"AB\", 2\\nOutput:\\t\"AB\"\\nExpected:\\t\"AB\"\\n\\nSomeone could explain it for me?"
                    },
                    {
                        "username": "GrosRat",
                        "content": "same help :\\'(\\n"
                    },
                    {
                        "username": "_FelixSun_",
                        "content": "I submitted the code and failed on the case (\"ABCD\", 2), shoudn't the ZigZag strings be\\n\\n{A  C  D}       | or |        {A  ... D}\\n\\n\\n{B  ......}      | or |        {B  C....} \\n\\nSo the answer should be either \"ACDB\" or \"ADBC\", but how could the expected answer is \"ACBD\"?"
                    },
                    {
                        "username": "LeetcodeProtector",
                        "content": "![alt text](https://i.imgur.com/QfbsjUh.png)\\n![alt text](https://i.imgur.com/RZpkxDZ.png)\\n\\nThings changed pretty quickly. "
                    },
                    {
                        "username": "PARILAKSHYA",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "thetoon",
                        "content": "The description better be changed to reflex the reality to \"PAYPALISFIRING\"."
                    },
                    {
                        "username": "DexterHines",
                        "content": "Of all the questions I never wanted to see on leetcode daily this one had the crown and ofc leetcode would choose it out of its 2000+ question list"
                    },
                    {
                        "username": "EmmettHou",
                        "content": "just find the law in transformed partten for each column \\n\\n![image](https://assets.leetcode.com/users/emmetthou/image_1567133746.png)\\n"
                    },
                    {
                        "username": "shyamvenkat007",
                        "content": "Can you explain on this process a bit more briefly?"
                    },
                    {
                        "username": "BibhuPala",
                        "content": "Input: s = \"PAHNAPLSIIGYIR\", numRows = 3\\nGiven the string which is read row-wise generate the original string?\\n\\nOutput: \"PAYPALISHIRING\""
                    },
                    {
                        "username": "hellendspiel",
                        "content": "Yea i dont get it too.... "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript  here: \\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "hxu",
                        "content": "A\\n\\nB C\\n\\n--> ABC\\n\\ncorrect me! I wasn't able pass this simple case, however, I believe this the right output."
                    },
                    {
                        "username": "akashkumar200",
                        "content": "it is in zig zag so\\nA C\\nB\\nand if it is ABCD, the answer should be\\nA C\\nB D"
                    }
                ]
            },
            {
                "id": 1570984,
                "content": [
                    {
                        "username": "vikaslinux",
                        "content": "Please provide a testcase when number of rows is 6 and 7.Actually the problem is not so clear to me."
                    },
                    {
                        "username": "shutdown-r",
                        "content": "[@hanupreeti_jain](/hanupreeti_jain) Thank you this helps"
                    },
                    {
                        "username": "hanupreeti_jain",
                        "content": "If you consider the indices of a 0 indexed string this is how the pattern would look\\n\\nFor rows = 6:\\n0________10 ________________20\\n1_____9__11____________19__21\\n2___8____12_________18_____22\\n3__7_____13______17________23\\n4_6______14__16____________24\\n5________15_________________25\\n\\nFor rows = 7:\\n0_______________12_____________________24\\n1__________11__13_________________23__25\\n2_______10_____14_____________22______26\\n3_____9_________15_________21_________27\\n4___8___________16_____20_____________28\\n5_7_____________17_19_________________29\\n6_______________18_____________________30"
                    },
                    {
                        "username": "zwsjink",
                        "content": "Strange, I got wrong answer, but the expected and output are exactly the same.!!!\\n\\nInput:\\t\"AB\", 2\\nOutput:\\t\"AB\"\\nExpected:\\t\"AB\"\\n\\nSomeone could explain it for me?"
                    },
                    {
                        "username": "GrosRat",
                        "content": "same help :\\'(\\n"
                    },
                    {
                        "username": "_FelixSun_",
                        "content": "I submitted the code and failed on the case (\"ABCD\", 2), shoudn't the ZigZag strings be\\n\\n{A  C  D}       | or |        {A  ... D}\\n\\n\\n{B  ......}      | or |        {B  C....} \\n\\nSo the answer should be either \"ACDB\" or \"ADBC\", but how could the expected answer is \"ACBD\"?"
                    },
                    {
                        "username": "LeetcodeProtector",
                        "content": "![alt text](https://i.imgur.com/QfbsjUh.png)\\n![alt text](https://i.imgur.com/RZpkxDZ.png)\\n\\nThings changed pretty quickly. "
                    },
                    {
                        "username": "PARILAKSHYA",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "thetoon",
                        "content": "The description better be changed to reflex the reality to \"PAYPALISFIRING\"."
                    },
                    {
                        "username": "DexterHines",
                        "content": "Of all the questions I never wanted to see on leetcode daily this one had the crown and ofc leetcode would choose it out of its 2000+ question list"
                    },
                    {
                        "username": "EmmettHou",
                        "content": "just find the law in transformed partten for each column \\n\\n![image](https://assets.leetcode.com/users/emmetthou/image_1567133746.png)\\n"
                    },
                    {
                        "username": "shyamvenkat007",
                        "content": "Can you explain on this process a bit more briefly?"
                    },
                    {
                        "username": "BibhuPala",
                        "content": "Input: s = \"PAHNAPLSIIGYIR\", numRows = 3\\nGiven the string which is read row-wise generate the original string?\\n\\nOutput: \"PAYPALISHIRING\""
                    },
                    {
                        "username": "hellendspiel",
                        "content": "Yea i dont get it too.... "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript  here: \\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "hxu",
                        "content": "A\\n\\nB C\\n\\n--> ABC\\n\\ncorrect me! I wasn't able pass this simple case, however, I believe this the right output."
                    },
                    {
                        "username": "akashkumar200",
                        "content": "it is in zig zag so\\nA C\\nB\\nand if it is ABCD, the answer should be\\nA C\\nB D"
                    }
                ]
            },
            {
                "id": 1567790,
                "content": [
                    {
                        "username": "vikaslinux",
                        "content": "Please provide a testcase when number of rows is 6 and 7.Actually the problem is not so clear to me."
                    },
                    {
                        "username": "shutdown-r",
                        "content": "[@hanupreeti_jain](/hanupreeti_jain) Thank you this helps"
                    },
                    {
                        "username": "hanupreeti_jain",
                        "content": "If you consider the indices of a 0 indexed string this is how the pattern would look\\n\\nFor rows = 6:\\n0________10 ________________20\\n1_____9__11____________19__21\\n2___8____12_________18_____22\\n3__7_____13______17________23\\n4_6______14__16____________24\\n5________15_________________25\\n\\nFor rows = 7:\\n0_______________12_____________________24\\n1__________11__13_________________23__25\\n2_______10_____14_____________22______26\\n3_____9_________15_________21_________27\\n4___8___________16_____20_____________28\\n5_7_____________17_19_________________29\\n6_______________18_____________________30"
                    },
                    {
                        "username": "zwsjink",
                        "content": "Strange, I got wrong answer, but the expected and output are exactly the same.!!!\\n\\nInput:\\t\"AB\", 2\\nOutput:\\t\"AB\"\\nExpected:\\t\"AB\"\\n\\nSomeone could explain it for me?"
                    },
                    {
                        "username": "GrosRat",
                        "content": "same help :\\'(\\n"
                    },
                    {
                        "username": "_FelixSun_",
                        "content": "I submitted the code and failed on the case (\"ABCD\", 2), shoudn't the ZigZag strings be\\n\\n{A  C  D}       | or |        {A  ... D}\\n\\n\\n{B  ......}      | or |        {B  C....} \\n\\nSo the answer should be either \"ACDB\" or \"ADBC\", but how could the expected answer is \"ACBD\"?"
                    },
                    {
                        "username": "LeetcodeProtector",
                        "content": "![alt text](https://i.imgur.com/QfbsjUh.png)\\n![alt text](https://i.imgur.com/RZpkxDZ.png)\\n\\nThings changed pretty quickly. "
                    },
                    {
                        "username": "PARILAKSHYA",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "thetoon",
                        "content": "The description better be changed to reflex the reality to \"PAYPALISFIRING\"."
                    },
                    {
                        "username": "DexterHines",
                        "content": "Of all the questions I never wanted to see on leetcode daily this one had the crown and ofc leetcode would choose it out of its 2000+ question list"
                    },
                    {
                        "username": "EmmettHou",
                        "content": "just find the law in transformed partten for each column \\n\\n![image](https://assets.leetcode.com/users/emmetthou/image_1567133746.png)\\n"
                    },
                    {
                        "username": "shyamvenkat007",
                        "content": "Can you explain on this process a bit more briefly?"
                    },
                    {
                        "username": "BibhuPala",
                        "content": "Input: s = \"PAHNAPLSIIGYIR\", numRows = 3\\nGiven the string which is read row-wise generate the original string?\\n\\nOutput: \"PAYPALISHIRING\""
                    },
                    {
                        "username": "hellendspiel",
                        "content": "Yea i dont get it too.... "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript  here: \\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "hxu",
                        "content": "A\\n\\nB C\\n\\n--> ABC\\n\\ncorrect me! I wasn't able pass this simple case, however, I believe this the right output."
                    },
                    {
                        "username": "akashkumar200",
                        "content": "it is in zig zag so\\nA C\\nB\\nand if it is ABCD, the answer should be\\nA C\\nB D"
                    }
                ]
            },
            {
                "id": 1785787,
                "content": [
                    {
                        "username": "vikaslinux",
                        "content": "Please provide a testcase when number of rows is 6 and 7.Actually the problem is not so clear to me."
                    },
                    {
                        "username": "shutdown-r",
                        "content": "[@hanupreeti_jain](/hanupreeti_jain) Thank you this helps"
                    },
                    {
                        "username": "hanupreeti_jain",
                        "content": "If you consider the indices of a 0 indexed string this is how the pattern would look\\n\\nFor rows = 6:\\n0________10 ________________20\\n1_____9__11____________19__21\\n2___8____12_________18_____22\\n3__7_____13______17________23\\n4_6______14__16____________24\\n5________15_________________25\\n\\nFor rows = 7:\\n0_______________12_____________________24\\n1__________11__13_________________23__25\\n2_______10_____14_____________22______26\\n3_____9_________15_________21_________27\\n4___8___________16_____20_____________28\\n5_7_____________17_19_________________29\\n6_______________18_____________________30"
                    },
                    {
                        "username": "zwsjink",
                        "content": "Strange, I got wrong answer, but the expected and output are exactly the same.!!!\\n\\nInput:\\t\"AB\", 2\\nOutput:\\t\"AB\"\\nExpected:\\t\"AB\"\\n\\nSomeone could explain it for me?"
                    },
                    {
                        "username": "GrosRat",
                        "content": "same help :\\'(\\n"
                    },
                    {
                        "username": "_FelixSun_",
                        "content": "I submitted the code and failed on the case (\"ABCD\", 2), shoudn't the ZigZag strings be\\n\\n{A  C  D}       | or |        {A  ... D}\\n\\n\\n{B  ......}      | or |        {B  C....} \\n\\nSo the answer should be either \"ACDB\" or \"ADBC\", but how could the expected answer is \"ACBD\"?"
                    },
                    {
                        "username": "LeetcodeProtector",
                        "content": "![alt text](https://i.imgur.com/QfbsjUh.png)\\n![alt text](https://i.imgur.com/RZpkxDZ.png)\\n\\nThings changed pretty quickly. "
                    },
                    {
                        "username": "PARILAKSHYA",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "thetoon",
                        "content": "The description better be changed to reflex the reality to \"PAYPALISFIRING\"."
                    },
                    {
                        "username": "DexterHines",
                        "content": "Of all the questions I never wanted to see on leetcode daily this one had the crown and ofc leetcode would choose it out of its 2000+ question list"
                    },
                    {
                        "username": "EmmettHou",
                        "content": "just find the law in transformed partten for each column \\n\\n![image](https://assets.leetcode.com/users/emmetthou/image_1567133746.png)\\n"
                    },
                    {
                        "username": "shyamvenkat007",
                        "content": "Can you explain on this process a bit more briefly?"
                    },
                    {
                        "username": "BibhuPala",
                        "content": "Input: s = \"PAHNAPLSIIGYIR\", numRows = 3\\nGiven the string which is read row-wise generate the original string?\\n\\nOutput: \"PAYPALISHIRING\""
                    },
                    {
                        "username": "hellendspiel",
                        "content": "Yea i dont get it too.... "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript  here: \\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "hxu",
                        "content": "A\\n\\nB C\\n\\n--> ABC\\n\\ncorrect me! I wasn't able pass this simple case, however, I believe this the right output."
                    },
                    {
                        "username": "akashkumar200",
                        "content": "it is in zig zag so\\nA C\\nB\\nand if it is ABCD, the answer should be\\nA C\\nB D"
                    }
                ]
            },
            {
                "id": 1785543,
                "content": [
                    {
                        "username": "vikaslinux",
                        "content": "Please provide a testcase when number of rows is 6 and 7.Actually the problem is not so clear to me."
                    },
                    {
                        "username": "shutdown-r",
                        "content": "[@hanupreeti_jain](/hanupreeti_jain) Thank you this helps"
                    },
                    {
                        "username": "hanupreeti_jain",
                        "content": "If you consider the indices of a 0 indexed string this is how the pattern would look\\n\\nFor rows = 6:\\n0________10 ________________20\\n1_____9__11____________19__21\\n2___8____12_________18_____22\\n3__7_____13______17________23\\n4_6______14__16____________24\\n5________15_________________25\\n\\nFor rows = 7:\\n0_______________12_____________________24\\n1__________11__13_________________23__25\\n2_______10_____14_____________22______26\\n3_____9_________15_________21_________27\\n4___8___________16_____20_____________28\\n5_7_____________17_19_________________29\\n6_______________18_____________________30"
                    },
                    {
                        "username": "zwsjink",
                        "content": "Strange, I got wrong answer, but the expected and output are exactly the same.!!!\\n\\nInput:\\t\"AB\", 2\\nOutput:\\t\"AB\"\\nExpected:\\t\"AB\"\\n\\nSomeone could explain it for me?"
                    },
                    {
                        "username": "GrosRat",
                        "content": "same help :\\'(\\n"
                    },
                    {
                        "username": "_FelixSun_",
                        "content": "I submitted the code and failed on the case (\"ABCD\", 2), shoudn't the ZigZag strings be\\n\\n{A  C  D}       | or |        {A  ... D}\\n\\n\\n{B  ......}      | or |        {B  C....} \\n\\nSo the answer should be either \"ACDB\" or \"ADBC\", but how could the expected answer is \"ACBD\"?"
                    },
                    {
                        "username": "LeetcodeProtector",
                        "content": "![alt text](https://i.imgur.com/QfbsjUh.png)\\n![alt text](https://i.imgur.com/RZpkxDZ.png)\\n\\nThings changed pretty quickly. "
                    },
                    {
                        "username": "PARILAKSHYA",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "thetoon",
                        "content": "The description better be changed to reflex the reality to \"PAYPALISFIRING\"."
                    },
                    {
                        "username": "DexterHines",
                        "content": "Of all the questions I never wanted to see on leetcode daily this one had the crown and ofc leetcode would choose it out of its 2000+ question list"
                    },
                    {
                        "username": "EmmettHou",
                        "content": "just find the law in transformed partten for each column \\n\\n![image](https://assets.leetcode.com/users/emmetthou/image_1567133746.png)\\n"
                    },
                    {
                        "username": "shyamvenkat007",
                        "content": "Can you explain on this process a bit more briefly?"
                    },
                    {
                        "username": "BibhuPala",
                        "content": "Input: s = \"PAHNAPLSIIGYIR\", numRows = 3\\nGiven the string which is read row-wise generate the original string?\\n\\nOutput: \"PAYPALISHIRING\""
                    },
                    {
                        "username": "hellendspiel",
                        "content": "Yea i dont get it too.... "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript  here: \\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "hxu",
                        "content": "A\\n\\nB C\\n\\n--> ABC\\n\\ncorrect me! I wasn't able pass this simple case, however, I believe this the right output."
                    },
                    {
                        "username": "akashkumar200",
                        "content": "it is in zig zag so\\nA C\\nB\\nand if it is ABCD, the answer should be\\nA C\\nB D"
                    }
                ]
            },
            {
                "id": 1785310,
                "content": [
                    {
                        "username": "vikaslinux",
                        "content": "Please provide a testcase when number of rows is 6 and 7.Actually the problem is not so clear to me."
                    },
                    {
                        "username": "shutdown-r",
                        "content": "[@hanupreeti_jain](/hanupreeti_jain) Thank you this helps"
                    },
                    {
                        "username": "hanupreeti_jain",
                        "content": "If you consider the indices of a 0 indexed string this is how the pattern would look\\n\\nFor rows = 6:\\n0________10 ________________20\\n1_____9__11____________19__21\\n2___8____12_________18_____22\\n3__7_____13______17________23\\n4_6______14__16____________24\\n5________15_________________25\\n\\nFor rows = 7:\\n0_______________12_____________________24\\n1__________11__13_________________23__25\\n2_______10_____14_____________22______26\\n3_____9_________15_________21_________27\\n4___8___________16_____20_____________28\\n5_7_____________17_19_________________29\\n6_______________18_____________________30"
                    },
                    {
                        "username": "zwsjink",
                        "content": "Strange, I got wrong answer, but the expected and output are exactly the same.!!!\\n\\nInput:\\t\"AB\", 2\\nOutput:\\t\"AB\"\\nExpected:\\t\"AB\"\\n\\nSomeone could explain it for me?"
                    },
                    {
                        "username": "GrosRat",
                        "content": "same help :\\'(\\n"
                    },
                    {
                        "username": "_FelixSun_",
                        "content": "I submitted the code and failed on the case (\"ABCD\", 2), shoudn't the ZigZag strings be\\n\\n{A  C  D}       | or |        {A  ... D}\\n\\n\\n{B  ......}      | or |        {B  C....} \\n\\nSo the answer should be either \"ACDB\" or \"ADBC\", but how could the expected answer is \"ACBD\"?"
                    },
                    {
                        "username": "LeetcodeProtector",
                        "content": "![alt text](https://i.imgur.com/QfbsjUh.png)\\n![alt text](https://i.imgur.com/RZpkxDZ.png)\\n\\nThings changed pretty quickly. "
                    },
                    {
                        "username": "PARILAKSHYA",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "thetoon",
                        "content": "The description better be changed to reflex the reality to \"PAYPALISFIRING\"."
                    },
                    {
                        "username": "DexterHines",
                        "content": "Of all the questions I never wanted to see on leetcode daily this one had the crown and ofc leetcode would choose it out of its 2000+ question list"
                    },
                    {
                        "username": "EmmettHou",
                        "content": "just find the law in transformed partten for each column \\n\\n![image](https://assets.leetcode.com/users/emmetthou/image_1567133746.png)\\n"
                    },
                    {
                        "username": "shyamvenkat007",
                        "content": "Can you explain on this process a bit more briefly?"
                    },
                    {
                        "username": "BibhuPala",
                        "content": "Input: s = \"PAHNAPLSIIGYIR\", numRows = 3\\nGiven the string which is read row-wise generate the original string?\\n\\nOutput: \"PAYPALISHIRING\""
                    },
                    {
                        "username": "hellendspiel",
                        "content": "Yea i dont get it too.... "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript  here: \\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "hxu",
                        "content": "A\\n\\nB C\\n\\n--> ABC\\n\\ncorrect me! I wasn't able pass this simple case, however, I believe this the right output."
                    },
                    {
                        "username": "akashkumar200",
                        "content": "it is in zig zag so\\nA C\\nB\\nand if it is ABCD, the answer should be\\nA C\\nB D"
                    }
                ]
            },
            {
                "id": 1572970,
                "content": [
                    {
                        "username": "vikaslinux",
                        "content": "Please provide a testcase when number of rows is 6 and 7.Actually the problem is not so clear to me."
                    },
                    {
                        "username": "shutdown-r",
                        "content": "[@hanupreeti_jain](/hanupreeti_jain) Thank you this helps"
                    },
                    {
                        "username": "hanupreeti_jain",
                        "content": "If you consider the indices of a 0 indexed string this is how the pattern would look\\n\\nFor rows = 6:\\n0________10 ________________20\\n1_____9__11____________19__21\\n2___8____12_________18_____22\\n3__7_____13______17________23\\n4_6______14__16____________24\\n5________15_________________25\\n\\nFor rows = 7:\\n0_______________12_____________________24\\n1__________11__13_________________23__25\\n2_______10_____14_____________22______26\\n3_____9_________15_________21_________27\\n4___8___________16_____20_____________28\\n5_7_____________17_19_________________29\\n6_______________18_____________________30"
                    },
                    {
                        "username": "zwsjink",
                        "content": "Strange, I got wrong answer, but the expected and output are exactly the same.!!!\\n\\nInput:\\t\"AB\", 2\\nOutput:\\t\"AB\"\\nExpected:\\t\"AB\"\\n\\nSomeone could explain it for me?"
                    },
                    {
                        "username": "GrosRat",
                        "content": "same help :\\'(\\n"
                    },
                    {
                        "username": "_FelixSun_",
                        "content": "I submitted the code and failed on the case (\"ABCD\", 2), shoudn't the ZigZag strings be\\n\\n{A  C  D}       | or |        {A  ... D}\\n\\n\\n{B  ......}      | or |        {B  C....} \\n\\nSo the answer should be either \"ACDB\" or \"ADBC\", but how could the expected answer is \"ACBD\"?"
                    },
                    {
                        "username": "LeetcodeProtector",
                        "content": "![alt text](https://i.imgur.com/QfbsjUh.png)\\n![alt text](https://i.imgur.com/RZpkxDZ.png)\\n\\nThings changed pretty quickly. "
                    },
                    {
                        "username": "PARILAKSHYA",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "thetoon",
                        "content": "The description better be changed to reflex the reality to \"PAYPALISFIRING\"."
                    },
                    {
                        "username": "DexterHines",
                        "content": "Of all the questions I never wanted to see on leetcode daily this one had the crown and ofc leetcode would choose it out of its 2000+ question list"
                    },
                    {
                        "username": "EmmettHou",
                        "content": "just find the law in transformed partten for each column \\n\\n![image](https://assets.leetcode.com/users/emmetthou/image_1567133746.png)\\n"
                    },
                    {
                        "username": "shyamvenkat007",
                        "content": "Can you explain on this process a bit more briefly?"
                    },
                    {
                        "username": "BibhuPala",
                        "content": "Input: s = \"PAHNAPLSIIGYIR\", numRows = 3\\nGiven the string which is read row-wise generate the original string?\\n\\nOutput: \"PAYPALISHIRING\""
                    },
                    {
                        "username": "hellendspiel",
                        "content": "Yea i dont get it too.... "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript  here: \\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "hxu",
                        "content": "A\\n\\nB C\\n\\n--> ABC\\n\\ncorrect me! I wasn't able pass this simple case, however, I believe this the right output."
                    },
                    {
                        "username": "akashkumar200",
                        "content": "it is in zig zag so\\nA C\\nB\\nand if it is ABCD, the answer should be\\nA C\\nB D"
                    }
                ]
            },
            {
                "id": 1569423,
                "content": [
                    {
                        "username": "vikaslinux",
                        "content": "Please provide a testcase when number of rows is 6 and 7.Actually the problem is not so clear to me."
                    },
                    {
                        "username": "shutdown-r",
                        "content": "[@hanupreeti_jain](/hanupreeti_jain) Thank you this helps"
                    },
                    {
                        "username": "hanupreeti_jain",
                        "content": "If you consider the indices of a 0 indexed string this is how the pattern would look\\n\\nFor rows = 6:\\n0________10 ________________20\\n1_____9__11____________19__21\\n2___8____12_________18_____22\\n3__7_____13______17________23\\n4_6______14__16____________24\\n5________15_________________25\\n\\nFor rows = 7:\\n0_______________12_____________________24\\n1__________11__13_________________23__25\\n2_______10_____14_____________22______26\\n3_____9_________15_________21_________27\\n4___8___________16_____20_____________28\\n5_7_____________17_19_________________29\\n6_______________18_____________________30"
                    },
                    {
                        "username": "zwsjink",
                        "content": "Strange, I got wrong answer, but the expected and output are exactly the same.!!!\\n\\nInput:\\t\"AB\", 2\\nOutput:\\t\"AB\"\\nExpected:\\t\"AB\"\\n\\nSomeone could explain it for me?"
                    },
                    {
                        "username": "GrosRat",
                        "content": "same help :\\'(\\n"
                    },
                    {
                        "username": "_FelixSun_",
                        "content": "I submitted the code and failed on the case (\"ABCD\", 2), shoudn't the ZigZag strings be\\n\\n{A  C  D}       | or |        {A  ... D}\\n\\n\\n{B  ......}      | or |        {B  C....} \\n\\nSo the answer should be either \"ACDB\" or \"ADBC\", but how could the expected answer is \"ACBD\"?"
                    },
                    {
                        "username": "LeetcodeProtector",
                        "content": "![alt text](https://i.imgur.com/QfbsjUh.png)\\n![alt text](https://i.imgur.com/RZpkxDZ.png)\\n\\nThings changed pretty quickly. "
                    },
                    {
                        "username": "PARILAKSHYA",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "thetoon",
                        "content": "The description better be changed to reflex the reality to \"PAYPALISFIRING\"."
                    },
                    {
                        "username": "DexterHines",
                        "content": "Of all the questions I never wanted to see on leetcode daily this one had the crown and ofc leetcode would choose it out of its 2000+ question list"
                    },
                    {
                        "username": "EmmettHou",
                        "content": "just find the law in transformed partten for each column \\n\\n![image](https://assets.leetcode.com/users/emmetthou/image_1567133746.png)\\n"
                    },
                    {
                        "username": "shyamvenkat007",
                        "content": "Can you explain on this process a bit more briefly?"
                    },
                    {
                        "username": "BibhuPala",
                        "content": "Input: s = \"PAHNAPLSIIGYIR\", numRows = 3\\nGiven the string which is read row-wise generate the original string?\\n\\nOutput: \"PAYPALISHIRING\""
                    },
                    {
                        "username": "hellendspiel",
                        "content": "Yea i dont get it too.... "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript  here: \\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "hxu",
                        "content": "A\\n\\nB C\\n\\n--> ABC\\n\\ncorrect me! I wasn't able pass this simple case, however, I believe this the right output."
                    },
                    {
                        "username": "akashkumar200",
                        "content": "it is in zig zag so\\nA C\\nB\\nand if it is ABCD, the answer should be\\nA C\\nB D"
                    }
                ]
            },
            {
                "id": 1567751,
                "content": [
                    {
                        "username": "vikaslinux",
                        "content": "Please provide a testcase when number of rows is 6 and 7.Actually the problem is not so clear to me."
                    },
                    {
                        "username": "shutdown-r",
                        "content": "[@hanupreeti_jain](/hanupreeti_jain) Thank you this helps"
                    },
                    {
                        "username": "hanupreeti_jain",
                        "content": "If you consider the indices of a 0 indexed string this is how the pattern would look\\n\\nFor rows = 6:\\n0________10 ________________20\\n1_____9__11____________19__21\\n2___8____12_________18_____22\\n3__7_____13______17________23\\n4_6______14__16____________24\\n5________15_________________25\\n\\nFor rows = 7:\\n0_______________12_____________________24\\n1__________11__13_________________23__25\\n2_______10_____14_____________22______26\\n3_____9_________15_________21_________27\\n4___8___________16_____20_____________28\\n5_7_____________17_19_________________29\\n6_______________18_____________________30"
                    },
                    {
                        "username": "zwsjink",
                        "content": "Strange, I got wrong answer, but the expected and output are exactly the same.!!!\\n\\nInput:\\t\"AB\", 2\\nOutput:\\t\"AB\"\\nExpected:\\t\"AB\"\\n\\nSomeone could explain it for me?"
                    },
                    {
                        "username": "GrosRat",
                        "content": "same help :\\'(\\n"
                    },
                    {
                        "username": "_FelixSun_",
                        "content": "I submitted the code and failed on the case (\"ABCD\", 2), shoudn't the ZigZag strings be\\n\\n{A  C  D}       | or |        {A  ... D}\\n\\n\\n{B  ......}      | or |        {B  C....} \\n\\nSo the answer should be either \"ACDB\" or \"ADBC\", but how could the expected answer is \"ACBD\"?"
                    },
                    {
                        "username": "LeetcodeProtector",
                        "content": "![alt text](https://i.imgur.com/QfbsjUh.png)\\n![alt text](https://i.imgur.com/RZpkxDZ.png)\\n\\nThings changed pretty quickly. "
                    },
                    {
                        "username": "PARILAKSHYA",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "thetoon",
                        "content": "The description better be changed to reflex the reality to \"PAYPALISFIRING\"."
                    },
                    {
                        "username": "DexterHines",
                        "content": "Of all the questions I never wanted to see on leetcode daily this one had the crown and ofc leetcode would choose it out of its 2000+ question list"
                    },
                    {
                        "username": "EmmettHou",
                        "content": "just find the law in transformed partten for each column \\n\\n![image](https://assets.leetcode.com/users/emmetthou/image_1567133746.png)\\n"
                    },
                    {
                        "username": "shyamvenkat007",
                        "content": "Can you explain on this process a bit more briefly?"
                    },
                    {
                        "username": "BibhuPala",
                        "content": "Input: s = \"PAHNAPLSIIGYIR\", numRows = 3\\nGiven the string which is read row-wise generate the original string?\\n\\nOutput: \"PAYPALISHIRING\""
                    },
                    {
                        "username": "hellendspiel",
                        "content": "Yea i dont get it too.... "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript  here: \\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "hxu",
                        "content": "A\\n\\nB C\\n\\n--> ABC\\n\\ncorrect me! I wasn't able pass this simple case, however, I believe this the right output."
                    },
                    {
                        "username": "akashkumar200",
                        "content": "it is in zig zag so\\nA C\\nB\\nand if it is ABCD, the answer should be\\nA C\\nB D"
                    }
                ]
            },
            {
                "id": 1567791,
                "content": [
                    {
                        "username": "vikaslinux",
                        "content": "Please provide a testcase when number of rows is 6 and 7.Actually the problem is not so clear to me."
                    },
                    {
                        "username": "shutdown-r",
                        "content": "[@hanupreeti_jain](/hanupreeti_jain) Thank you this helps"
                    },
                    {
                        "username": "hanupreeti_jain",
                        "content": "If you consider the indices of a 0 indexed string this is how the pattern would look\\n\\nFor rows = 6:\\n0________10 ________________20\\n1_____9__11____________19__21\\n2___8____12_________18_____22\\n3__7_____13______17________23\\n4_6______14__16____________24\\n5________15_________________25\\n\\nFor rows = 7:\\n0_______________12_____________________24\\n1__________11__13_________________23__25\\n2_______10_____14_____________22______26\\n3_____9_________15_________21_________27\\n4___8___________16_____20_____________28\\n5_7_____________17_19_________________29\\n6_______________18_____________________30"
                    },
                    {
                        "username": "zwsjink",
                        "content": "Strange, I got wrong answer, but the expected and output are exactly the same.!!!\\n\\nInput:\\t\"AB\", 2\\nOutput:\\t\"AB\"\\nExpected:\\t\"AB\"\\n\\nSomeone could explain it for me?"
                    },
                    {
                        "username": "GrosRat",
                        "content": "same help :\\'(\\n"
                    },
                    {
                        "username": "_FelixSun_",
                        "content": "I submitted the code and failed on the case (\"ABCD\", 2), shoudn't the ZigZag strings be\\n\\n{A  C  D}       | or |        {A  ... D}\\n\\n\\n{B  ......}      | or |        {B  C....} \\n\\nSo the answer should be either \"ACDB\" or \"ADBC\", but how could the expected answer is \"ACBD\"?"
                    },
                    {
                        "username": "LeetcodeProtector",
                        "content": "![alt text](https://i.imgur.com/QfbsjUh.png)\\n![alt text](https://i.imgur.com/RZpkxDZ.png)\\n\\nThings changed pretty quickly. "
                    },
                    {
                        "username": "PARILAKSHYA",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "thetoon",
                        "content": "The description better be changed to reflex the reality to \"PAYPALISFIRING\"."
                    },
                    {
                        "username": "DexterHines",
                        "content": "Of all the questions I never wanted to see on leetcode daily this one had the crown and ofc leetcode would choose it out of its 2000+ question list"
                    },
                    {
                        "username": "EmmettHou",
                        "content": "just find the law in transformed partten for each column \\n\\n![image](https://assets.leetcode.com/users/emmetthou/image_1567133746.png)\\n"
                    },
                    {
                        "username": "shyamvenkat007",
                        "content": "Can you explain on this process a bit more briefly?"
                    },
                    {
                        "username": "BibhuPala",
                        "content": "Input: s = \"PAHNAPLSIIGYIR\", numRows = 3\\nGiven the string which is read row-wise generate the original string?\\n\\nOutput: \"PAYPALISHIRING\""
                    },
                    {
                        "username": "hellendspiel",
                        "content": "Yea i dont get it too.... "
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript  here: \\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "hxu",
                        "content": "A\\n\\nB C\\n\\n--> ABC\\n\\ncorrect me! I wasn't able pass this simple case, however, I believe this the right output."
                    },
                    {
                        "username": "akashkumar200",
                        "content": "it is in zig zag so\\nA C\\nB\\nand if it is ABCD, the answer should be\\nA C\\nB D"
                    }
                ]
            },
            {
                "id": 1566730,
                "content": [
                    {
                        "username": "bill19",
                        "content": "I'm not quite understand what is ZipZag means in this question. For example, what are rules to generate the ZipZag format of a String, what the pattern looks like when there are 4 rows, 5 rows, etc."
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "If you clearly read, and understand the question, it clearly states that, we have to traverse the string in a zig-zag form, which means, \\nFOR  \"ZIG\" just print r elements;\\nFOR  \"ZAG\" just print r-2 elements;\\n\\nBRUTE FORCE:\\n\\nEXAMPLE:  \\nSTRING = \"PAYPALISHIRING\"\\nR = 3\\n\\nFOR ZIG: if you simply store \"R\" elements in a 2d matrix like this:\\n[P]\\n[A]\\n[Y]\\n\\nand \\nFOR ZAG: if you store \"R-2\" elements in a 2d matrix from bottom to top like this:\\n\\n[P     ]\\n[A, P ]\\n[Y     ]\\n\\nand repeat the process for whole string.\\n\\nitr2:\\n[P      A]\\n[A  P  L]\\n[Y       I]\\n\\nitr3:\\n[P      A    ]\\n[A  P  L  S]\\n[Y       I    ]\\n\\nitr4:\\n[P      A      H]\\n[A  P  L  S   I ]\\n[Y       I       R]\\n\\nitr5:\\n[P      A      H   ]\\n[A  P  L  S   I   I]\\n[Y       I       R   ]\\n\\nitr6:\\n[P      A      H      N]\\n[A  P  L  S   I   I   G]\\n[Y       I       R        ]\\n\\nIf you understand this, try another optimized version. \\n\\nIf you still confused, try running for different number of rows."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Video Solution\\nhttps://nileshblog.tech/humix/video/f239ef5c145b049977c4fb8707654e1219d33372b4304f6571a4c43b40a4942c"
                    },
                    {
                        "username": "umangthusoo1995",
                        "content": "my code is Accepted while Running the test case shown in \"last executed input\" but fails when submitting. can anyone tell the reason"
                    },
                    {
                        "username": "danel_danel",
                        "content": "If you submit the same solution  many times then the site will report differnet runtime and memory usage :)"
                    },
                    {
                        "username": "sonnyrajagopalan",
                        "content": "Am I the only person scratching my head about zig zag conversion? The problem states little to no indication of what happens when numRows is not 3, not to mention if there is only character in the middle or something else. Terrible and not at all fun problem."
                    },
                    {
                        "username": "azhall",
                        "content": "First of all, lacking examples out the a-hole.  An even zig-zag?\\nSo I fail on this TC:\\nstring = \"ABC\"\\nnumRows = 2\\nexpected result: \"ACB\"\\n\\nOk, so mentally I'm picturing\\nA C \\nB\\n\\nSo I throw in a fix, only to fail on \\nstring = \"ABCDE\"\\nnumRows = 4\\nexpected result: \"ABCED\"\\n\\nABCED?? Are you fucking with me??  \\n\\nA E\\nB\\nC\\nD\\n\\n/rage quit"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "Maybe I am too dumb to experience the essence of this problem, but I am really confused that there are thousand ways of playing with a string. What knowledge or skill does this problem want to test us? If I meet this problem in an interview, I will ask for another one, or  just quit."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1823113,
                "content": [
                    {
                        "username": "bill19",
                        "content": "I'm not quite understand what is ZipZag means in this question. For example, what are rules to generate the ZipZag format of a String, what the pattern looks like when there are 4 rows, 5 rows, etc."
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "If you clearly read, and understand the question, it clearly states that, we have to traverse the string in a zig-zag form, which means, \\nFOR  \"ZIG\" just print r elements;\\nFOR  \"ZAG\" just print r-2 elements;\\n\\nBRUTE FORCE:\\n\\nEXAMPLE:  \\nSTRING = \"PAYPALISHIRING\"\\nR = 3\\n\\nFOR ZIG: if you simply store \"R\" elements in a 2d matrix like this:\\n[P]\\n[A]\\n[Y]\\n\\nand \\nFOR ZAG: if you store \"R-2\" elements in a 2d matrix from bottom to top like this:\\n\\n[P     ]\\n[A, P ]\\n[Y     ]\\n\\nand repeat the process for whole string.\\n\\nitr2:\\n[P      A]\\n[A  P  L]\\n[Y       I]\\n\\nitr3:\\n[P      A    ]\\n[A  P  L  S]\\n[Y       I    ]\\n\\nitr4:\\n[P      A      H]\\n[A  P  L  S   I ]\\n[Y       I       R]\\n\\nitr5:\\n[P      A      H   ]\\n[A  P  L  S   I   I]\\n[Y       I       R   ]\\n\\nitr6:\\n[P      A      H      N]\\n[A  P  L  S   I   I   G]\\n[Y       I       R        ]\\n\\nIf you understand this, try another optimized version. \\n\\nIf you still confused, try running for different number of rows."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Video Solution\\nhttps://nileshblog.tech/humix/video/f239ef5c145b049977c4fb8707654e1219d33372b4304f6571a4c43b40a4942c"
                    },
                    {
                        "username": "umangthusoo1995",
                        "content": "my code is Accepted while Running the test case shown in \"last executed input\" but fails when submitting. can anyone tell the reason"
                    },
                    {
                        "username": "danel_danel",
                        "content": "If you submit the same solution  many times then the site will report differnet runtime and memory usage :)"
                    },
                    {
                        "username": "sonnyrajagopalan",
                        "content": "Am I the only person scratching my head about zig zag conversion? The problem states little to no indication of what happens when numRows is not 3, not to mention if there is only character in the middle or something else. Terrible and not at all fun problem."
                    },
                    {
                        "username": "azhall",
                        "content": "First of all, lacking examples out the a-hole.  An even zig-zag?\\nSo I fail on this TC:\\nstring = \"ABC\"\\nnumRows = 2\\nexpected result: \"ACB\"\\n\\nOk, so mentally I'm picturing\\nA C \\nB\\n\\nSo I throw in a fix, only to fail on \\nstring = \"ABCDE\"\\nnumRows = 4\\nexpected result: \"ABCED\"\\n\\nABCED?? Are you fucking with me??  \\n\\nA E\\nB\\nC\\nD\\n\\n/rage quit"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "Maybe I am too dumb to experience the essence of this problem, but I am really confused that there are thousand ways of playing with a string. What knowledge or skill does this problem want to test us? If I meet this problem in an interview, I will ask for another one, or  just quit."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1570943,
                "content": [
                    {
                        "username": "bill19",
                        "content": "I'm not quite understand what is ZipZag means in this question. For example, what are rules to generate the ZipZag format of a String, what the pattern looks like when there are 4 rows, 5 rows, etc."
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "If you clearly read, and understand the question, it clearly states that, we have to traverse the string in a zig-zag form, which means, \\nFOR  \"ZIG\" just print r elements;\\nFOR  \"ZAG\" just print r-2 elements;\\n\\nBRUTE FORCE:\\n\\nEXAMPLE:  \\nSTRING = \"PAYPALISHIRING\"\\nR = 3\\n\\nFOR ZIG: if you simply store \"R\" elements in a 2d matrix like this:\\n[P]\\n[A]\\n[Y]\\n\\nand \\nFOR ZAG: if you store \"R-2\" elements in a 2d matrix from bottom to top like this:\\n\\n[P     ]\\n[A, P ]\\n[Y     ]\\n\\nand repeat the process for whole string.\\n\\nitr2:\\n[P      A]\\n[A  P  L]\\n[Y       I]\\n\\nitr3:\\n[P      A    ]\\n[A  P  L  S]\\n[Y       I    ]\\n\\nitr4:\\n[P      A      H]\\n[A  P  L  S   I ]\\n[Y       I       R]\\n\\nitr5:\\n[P      A      H   ]\\n[A  P  L  S   I   I]\\n[Y       I       R   ]\\n\\nitr6:\\n[P      A      H      N]\\n[A  P  L  S   I   I   G]\\n[Y       I       R        ]\\n\\nIf you understand this, try another optimized version. \\n\\nIf you still confused, try running for different number of rows."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Video Solution\\nhttps://nileshblog.tech/humix/video/f239ef5c145b049977c4fb8707654e1219d33372b4304f6571a4c43b40a4942c"
                    },
                    {
                        "username": "umangthusoo1995",
                        "content": "my code is Accepted while Running the test case shown in \"last executed input\" but fails when submitting. can anyone tell the reason"
                    },
                    {
                        "username": "danel_danel",
                        "content": "If you submit the same solution  many times then the site will report differnet runtime and memory usage :)"
                    },
                    {
                        "username": "sonnyrajagopalan",
                        "content": "Am I the only person scratching my head about zig zag conversion? The problem states little to no indication of what happens when numRows is not 3, not to mention if there is only character in the middle or something else. Terrible and not at all fun problem."
                    },
                    {
                        "username": "azhall",
                        "content": "First of all, lacking examples out the a-hole.  An even zig-zag?\\nSo I fail on this TC:\\nstring = \"ABC\"\\nnumRows = 2\\nexpected result: \"ACB\"\\n\\nOk, so mentally I'm picturing\\nA C \\nB\\n\\nSo I throw in a fix, only to fail on \\nstring = \"ABCDE\"\\nnumRows = 4\\nexpected result: \"ABCED\"\\n\\nABCED?? Are you fucking with me??  \\n\\nA E\\nB\\nC\\nD\\n\\n/rage quit"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "Maybe I am too dumb to experience the essence of this problem, but I am really confused that there are thousand ways of playing with a string. What knowledge or skill does this problem want to test us? If I meet this problem in an interview, I will ask for another one, or  just quit."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1573242,
                "content": [
                    {
                        "username": "bill19",
                        "content": "I'm not quite understand what is ZipZag means in this question. For example, what are rules to generate the ZipZag format of a String, what the pattern looks like when there are 4 rows, 5 rows, etc."
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "If you clearly read, and understand the question, it clearly states that, we have to traverse the string in a zig-zag form, which means, \\nFOR  \"ZIG\" just print r elements;\\nFOR  \"ZAG\" just print r-2 elements;\\n\\nBRUTE FORCE:\\n\\nEXAMPLE:  \\nSTRING = \"PAYPALISHIRING\"\\nR = 3\\n\\nFOR ZIG: if you simply store \"R\" elements in a 2d matrix like this:\\n[P]\\n[A]\\n[Y]\\n\\nand \\nFOR ZAG: if you store \"R-2\" elements in a 2d matrix from bottom to top like this:\\n\\n[P     ]\\n[A, P ]\\n[Y     ]\\n\\nand repeat the process for whole string.\\n\\nitr2:\\n[P      A]\\n[A  P  L]\\n[Y       I]\\n\\nitr3:\\n[P      A    ]\\n[A  P  L  S]\\n[Y       I    ]\\n\\nitr4:\\n[P      A      H]\\n[A  P  L  S   I ]\\n[Y       I       R]\\n\\nitr5:\\n[P      A      H   ]\\n[A  P  L  S   I   I]\\n[Y       I       R   ]\\n\\nitr6:\\n[P      A      H      N]\\n[A  P  L  S   I   I   G]\\n[Y       I       R        ]\\n\\nIf you understand this, try another optimized version. \\n\\nIf you still confused, try running for different number of rows."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Video Solution\\nhttps://nileshblog.tech/humix/video/f239ef5c145b049977c4fb8707654e1219d33372b4304f6571a4c43b40a4942c"
                    },
                    {
                        "username": "umangthusoo1995",
                        "content": "my code is Accepted while Running the test case shown in \"last executed input\" but fails when submitting. can anyone tell the reason"
                    },
                    {
                        "username": "danel_danel",
                        "content": "If you submit the same solution  many times then the site will report differnet runtime and memory usage :)"
                    },
                    {
                        "username": "sonnyrajagopalan",
                        "content": "Am I the only person scratching my head about zig zag conversion? The problem states little to no indication of what happens when numRows is not 3, not to mention if there is only character in the middle or something else. Terrible and not at all fun problem."
                    },
                    {
                        "username": "azhall",
                        "content": "First of all, lacking examples out the a-hole.  An even zig-zag?\\nSo I fail on this TC:\\nstring = \"ABC\"\\nnumRows = 2\\nexpected result: \"ACB\"\\n\\nOk, so mentally I'm picturing\\nA C \\nB\\n\\nSo I throw in a fix, only to fail on \\nstring = \"ABCDE\"\\nnumRows = 4\\nexpected result: \"ABCED\"\\n\\nABCED?? Are you fucking with me??  \\n\\nA E\\nB\\nC\\nD\\n\\n/rage quit"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "Maybe I am too dumb to experience the essence of this problem, but I am really confused that there are thousand ways of playing with a string. What knowledge or skill does this problem want to test us? If I meet this problem in an interview, I will ask for another one, or  just quit."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1572744,
                "content": [
                    {
                        "username": "bill19",
                        "content": "I'm not quite understand what is ZipZag means in this question. For example, what are rules to generate the ZipZag format of a String, what the pattern looks like when there are 4 rows, 5 rows, etc."
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "If you clearly read, and understand the question, it clearly states that, we have to traverse the string in a zig-zag form, which means, \\nFOR  \"ZIG\" just print r elements;\\nFOR  \"ZAG\" just print r-2 elements;\\n\\nBRUTE FORCE:\\n\\nEXAMPLE:  \\nSTRING = \"PAYPALISHIRING\"\\nR = 3\\n\\nFOR ZIG: if you simply store \"R\" elements in a 2d matrix like this:\\n[P]\\n[A]\\n[Y]\\n\\nand \\nFOR ZAG: if you store \"R-2\" elements in a 2d matrix from bottom to top like this:\\n\\n[P     ]\\n[A, P ]\\n[Y     ]\\n\\nand repeat the process for whole string.\\n\\nitr2:\\n[P      A]\\n[A  P  L]\\n[Y       I]\\n\\nitr3:\\n[P      A    ]\\n[A  P  L  S]\\n[Y       I    ]\\n\\nitr4:\\n[P      A      H]\\n[A  P  L  S   I ]\\n[Y       I       R]\\n\\nitr5:\\n[P      A      H   ]\\n[A  P  L  S   I   I]\\n[Y       I       R   ]\\n\\nitr6:\\n[P      A      H      N]\\n[A  P  L  S   I   I   G]\\n[Y       I       R        ]\\n\\nIf you understand this, try another optimized version. \\n\\nIf you still confused, try running for different number of rows."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Video Solution\\nhttps://nileshblog.tech/humix/video/f239ef5c145b049977c4fb8707654e1219d33372b4304f6571a4c43b40a4942c"
                    },
                    {
                        "username": "umangthusoo1995",
                        "content": "my code is Accepted while Running the test case shown in \"last executed input\" but fails when submitting. can anyone tell the reason"
                    },
                    {
                        "username": "danel_danel",
                        "content": "If you submit the same solution  many times then the site will report differnet runtime and memory usage :)"
                    },
                    {
                        "username": "sonnyrajagopalan",
                        "content": "Am I the only person scratching my head about zig zag conversion? The problem states little to no indication of what happens when numRows is not 3, not to mention if there is only character in the middle or something else. Terrible and not at all fun problem."
                    },
                    {
                        "username": "azhall",
                        "content": "First of all, lacking examples out the a-hole.  An even zig-zag?\\nSo I fail on this TC:\\nstring = \"ABC\"\\nnumRows = 2\\nexpected result: \"ACB\"\\n\\nOk, so mentally I'm picturing\\nA C \\nB\\n\\nSo I throw in a fix, only to fail on \\nstring = \"ABCDE\"\\nnumRows = 4\\nexpected result: \"ABCED\"\\n\\nABCED?? Are you fucking with me??  \\n\\nA E\\nB\\nC\\nD\\n\\n/rage quit"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "Maybe I am too dumb to experience the essence of this problem, but I am really confused that there are thousand ways of playing with a string. What knowledge or skill does this problem want to test us? If I meet this problem in an interview, I will ask for another one, or  just quit."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1570977,
                "content": [
                    {
                        "username": "bill19",
                        "content": "I'm not quite understand what is ZipZag means in this question. For example, what are rules to generate the ZipZag format of a String, what the pattern looks like when there are 4 rows, 5 rows, etc."
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "If you clearly read, and understand the question, it clearly states that, we have to traverse the string in a zig-zag form, which means, \\nFOR  \"ZIG\" just print r elements;\\nFOR  \"ZAG\" just print r-2 elements;\\n\\nBRUTE FORCE:\\n\\nEXAMPLE:  \\nSTRING = \"PAYPALISHIRING\"\\nR = 3\\n\\nFOR ZIG: if you simply store \"R\" elements in a 2d matrix like this:\\n[P]\\n[A]\\n[Y]\\n\\nand \\nFOR ZAG: if you store \"R-2\" elements in a 2d matrix from bottom to top like this:\\n\\n[P     ]\\n[A, P ]\\n[Y     ]\\n\\nand repeat the process for whole string.\\n\\nitr2:\\n[P      A]\\n[A  P  L]\\n[Y       I]\\n\\nitr3:\\n[P      A    ]\\n[A  P  L  S]\\n[Y       I    ]\\n\\nitr4:\\n[P      A      H]\\n[A  P  L  S   I ]\\n[Y       I       R]\\n\\nitr5:\\n[P      A      H   ]\\n[A  P  L  S   I   I]\\n[Y       I       R   ]\\n\\nitr6:\\n[P      A      H      N]\\n[A  P  L  S   I   I   G]\\n[Y       I       R        ]\\n\\nIf you understand this, try another optimized version. \\n\\nIf you still confused, try running for different number of rows."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Video Solution\\nhttps://nileshblog.tech/humix/video/f239ef5c145b049977c4fb8707654e1219d33372b4304f6571a4c43b40a4942c"
                    },
                    {
                        "username": "umangthusoo1995",
                        "content": "my code is Accepted while Running the test case shown in \"last executed input\" but fails when submitting. can anyone tell the reason"
                    },
                    {
                        "username": "danel_danel",
                        "content": "If you submit the same solution  many times then the site will report differnet runtime and memory usage :)"
                    },
                    {
                        "username": "sonnyrajagopalan",
                        "content": "Am I the only person scratching my head about zig zag conversion? The problem states little to no indication of what happens when numRows is not 3, not to mention if there is only character in the middle or something else. Terrible and not at all fun problem."
                    },
                    {
                        "username": "azhall",
                        "content": "First of all, lacking examples out the a-hole.  An even zig-zag?\\nSo I fail on this TC:\\nstring = \"ABC\"\\nnumRows = 2\\nexpected result: \"ACB\"\\n\\nOk, so mentally I'm picturing\\nA C \\nB\\n\\nSo I throw in a fix, only to fail on \\nstring = \"ABCDE\"\\nnumRows = 4\\nexpected result: \"ABCED\"\\n\\nABCED?? Are you fucking with me??  \\n\\nA E\\nB\\nC\\nD\\n\\n/rage quit"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "Maybe I am too dumb to experience the essence of this problem, but I am really confused that there are thousand ways of playing with a string. What knowledge or skill does this problem want to test us? If I meet this problem in an interview, I will ask for another one, or  just quit."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1570980,
                "content": [
                    {
                        "username": "bill19",
                        "content": "I'm not quite understand what is ZipZag means in this question. For example, what are rules to generate the ZipZag format of a String, what the pattern looks like when there are 4 rows, 5 rows, etc."
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "If you clearly read, and understand the question, it clearly states that, we have to traverse the string in a zig-zag form, which means, \\nFOR  \"ZIG\" just print r elements;\\nFOR  \"ZAG\" just print r-2 elements;\\n\\nBRUTE FORCE:\\n\\nEXAMPLE:  \\nSTRING = \"PAYPALISHIRING\"\\nR = 3\\n\\nFOR ZIG: if you simply store \"R\" elements in a 2d matrix like this:\\n[P]\\n[A]\\n[Y]\\n\\nand \\nFOR ZAG: if you store \"R-2\" elements in a 2d matrix from bottom to top like this:\\n\\n[P     ]\\n[A, P ]\\n[Y     ]\\n\\nand repeat the process for whole string.\\n\\nitr2:\\n[P      A]\\n[A  P  L]\\n[Y       I]\\n\\nitr3:\\n[P      A    ]\\n[A  P  L  S]\\n[Y       I    ]\\n\\nitr4:\\n[P      A      H]\\n[A  P  L  S   I ]\\n[Y       I       R]\\n\\nitr5:\\n[P      A      H   ]\\n[A  P  L  S   I   I]\\n[Y       I       R   ]\\n\\nitr6:\\n[P      A      H      N]\\n[A  P  L  S   I   I   G]\\n[Y       I       R        ]\\n\\nIf you understand this, try another optimized version. \\n\\nIf you still confused, try running for different number of rows."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Video Solution\\nhttps://nileshblog.tech/humix/video/f239ef5c145b049977c4fb8707654e1219d33372b4304f6571a4c43b40a4942c"
                    },
                    {
                        "username": "umangthusoo1995",
                        "content": "my code is Accepted while Running the test case shown in \"last executed input\" but fails when submitting. can anyone tell the reason"
                    },
                    {
                        "username": "danel_danel",
                        "content": "If you submit the same solution  many times then the site will report differnet runtime and memory usage :)"
                    },
                    {
                        "username": "sonnyrajagopalan",
                        "content": "Am I the only person scratching my head about zig zag conversion? The problem states little to no indication of what happens when numRows is not 3, not to mention if there is only character in the middle or something else. Terrible and not at all fun problem."
                    },
                    {
                        "username": "azhall",
                        "content": "First of all, lacking examples out the a-hole.  An even zig-zag?\\nSo I fail on this TC:\\nstring = \"ABC\"\\nnumRows = 2\\nexpected result: \"ACB\"\\n\\nOk, so mentally I'm picturing\\nA C \\nB\\n\\nSo I throw in a fix, only to fail on \\nstring = \"ABCDE\"\\nnumRows = 4\\nexpected result: \"ABCED\"\\n\\nABCED?? Are you fucking with me??  \\n\\nA E\\nB\\nC\\nD\\n\\n/rage quit"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "Maybe I am too dumb to experience the essence of this problem, but I am really confused that there are thousand ways of playing with a string. What knowledge or skill does this problem want to test us? If I meet this problem in an interview, I will ask for another one, or  just quit."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1570983,
                "content": [
                    {
                        "username": "bill19",
                        "content": "I'm not quite understand what is ZipZag means in this question. For example, what are rules to generate the ZipZag format of a String, what the pattern looks like when there are 4 rows, 5 rows, etc."
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "If you clearly read, and understand the question, it clearly states that, we have to traverse the string in a zig-zag form, which means, \\nFOR  \"ZIG\" just print r elements;\\nFOR  \"ZAG\" just print r-2 elements;\\n\\nBRUTE FORCE:\\n\\nEXAMPLE:  \\nSTRING = \"PAYPALISHIRING\"\\nR = 3\\n\\nFOR ZIG: if you simply store \"R\" elements in a 2d matrix like this:\\n[P]\\n[A]\\n[Y]\\n\\nand \\nFOR ZAG: if you store \"R-2\" elements in a 2d matrix from bottom to top like this:\\n\\n[P     ]\\n[A, P ]\\n[Y     ]\\n\\nand repeat the process for whole string.\\n\\nitr2:\\n[P      A]\\n[A  P  L]\\n[Y       I]\\n\\nitr3:\\n[P      A    ]\\n[A  P  L  S]\\n[Y       I    ]\\n\\nitr4:\\n[P      A      H]\\n[A  P  L  S   I ]\\n[Y       I       R]\\n\\nitr5:\\n[P      A      H   ]\\n[A  P  L  S   I   I]\\n[Y       I       R   ]\\n\\nitr6:\\n[P      A      H      N]\\n[A  P  L  S   I   I   G]\\n[Y       I       R        ]\\n\\nIf you understand this, try another optimized version. \\n\\nIf you still confused, try running for different number of rows."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Video Solution\\nhttps://nileshblog.tech/humix/video/f239ef5c145b049977c4fb8707654e1219d33372b4304f6571a4c43b40a4942c"
                    },
                    {
                        "username": "umangthusoo1995",
                        "content": "my code is Accepted while Running the test case shown in \"last executed input\" but fails when submitting. can anyone tell the reason"
                    },
                    {
                        "username": "danel_danel",
                        "content": "If you submit the same solution  many times then the site will report differnet runtime and memory usage :)"
                    },
                    {
                        "username": "sonnyrajagopalan",
                        "content": "Am I the only person scratching my head about zig zag conversion? The problem states little to no indication of what happens when numRows is not 3, not to mention if there is only character in the middle or something else. Terrible and not at all fun problem."
                    },
                    {
                        "username": "azhall",
                        "content": "First of all, lacking examples out the a-hole.  An even zig-zag?\\nSo I fail on this TC:\\nstring = \"ABC\"\\nnumRows = 2\\nexpected result: \"ACB\"\\n\\nOk, so mentally I'm picturing\\nA C \\nB\\n\\nSo I throw in a fix, only to fail on \\nstring = \"ABCDE\"\\nnumRows = 4\\nexpected result: \"ABCED\"\\n\\nABCED?? Are you fucking with me??  \\n\\nA E\\nB\\nC\\nD\\n\\n/rage quit"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "Maybe I am too dumb to experience the essence of this problem, but I am really confused that there are thousand ways of playing with a string. What knowledge or skill does this problem want to test us? If I meet this problem in an interview, I will ask for another one, or  just quit."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1567775,
                "content": [
                    {
                        "username": "bill19",
                        "content": "I'm not quite understand what is ZipZag means in this question. For example, what are rules to generate the ZipZag format of a String, what the pattern looks like when there are 4 rows, 5 rows, etc."
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "If you clearly read, and understand the question, it clearly states that, we have to traverse the string in a zig-zag form, which means, \\nFOR  \"ZIG\" just print r elements;\\nFOR  \"ZAG\" just print r-2 elements;\\n\\nBRUTE FORCE:\\n\\nEXAMPLE:  \\nSTRING = \"PAYPALISHIRING\"\\nR = 3\\n\\nFOR ZIG: if you simply store \"R\" elements in a 2d matrix like this:\\n[P]\\n[A]\\n[Y]\\n\\nand \\nFOR ZAG: if you store \"R-2\" elements in a 2d matrix from bottom to top like this:\\n\\n[P     ]\\n[A, P ]\\n[Y     ]\\n\\nand repeat the process for whole string.\\n\\nitr2:\\n[P      A]\\n[A  P  L]\\n[Y       I]\\n\\nitr3:\\n[P      A    ]\\n[A  P  L  S]\\n[Y       I    ]\\n\\nitr4:\\n[P      A      H]\\n[A  P  L  S   I ]\\n[Y       I       R]\\n\\nitr5:\\n[P      A      H   ]\\n[A  P  L  S   I   I]\\n[Y       I       R   ]\\n\\nitr6:\\n[P      A      H      N]\\n[A  P  L  S   I   I   G]\\n[Y       I       R        ]\\n\\nIf you understand this, try another optimized version. \\n\\nIf you still confused, try running for different number of rows."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Video Solution\\nhttps://nileshblog.tech/humix/video/f239ef5c145b049977c4fb8707654e1219d33372b4304f6571a4c43b40a4942c"
                    },
                    {
                        "username": "umangthusoo1995",
                        "content": "my code is Accepted while Running the test case shown in \"last executed input\" but fails when submitting. can anyone tell the reason"
                    },
                    {
                        "username": "danel_danel",
                        "content": "If you submit the same solution  many times then the site will report differnet runtime and memory usage :)"
                    },
                    {
                        "username": "sonnyrajagopalan",
                        "content": "Am I the only person scratching my head about zig zag conversion? The problem states little to no indication of what happens when numRows is not 3, not to mention if there is only character in the middle or something else. Terrible and not at all fun problem."
                    },
                    {
                        "username": "azhall",
                        "content": "First of all, lacking examples out the a-hole.  An even zig-zag?\\nSo I fail on this TC:\\nstring = \"ABC\"\\nnumRows = 2\\nexpected result: \"ACB\"\\n\\nOk, so mentally I'm picturing\\nA C \\nB\\n\\nSo I throw in a fix, only to fail on \\nstring = \"ABCDE\"\\nnumRows = 4\\nexpected result: \"ABCED\"\\n\\nABCED?? Are you fucking with me??  \\n\\nA E\\nB\\nC\\nD\\n\\n/rage quit"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "Maybe I am too dumb to experience the essence of this problem, but I am really confused that there are thousand ways of playing with a string. What knowledge or skill does this problem want to test us? If I meet this problem in an interview, I will ask for another one, or  just quit."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1567764,
                "content": [
                    {
                        "username": "bill19",
                        "content": "I'm not quite understand what is ZipZag means in this question. For example, what are rules to generate the ZipZag format of a String, what the pattern looks like when there are 4 rows, 5 rows, etc."
                    },
                    {
                        "username": "programmer-buddy",
                        "content": "If you clearly read, and understand the question, it clearly states that, we have to traverse the string in a zig-zag form, which means, \\nFOR  \"ZIG\" just print r elements;\\nFOR  \"ZAG\" just print r-2 elements;\\n\\nBRUTE FORCE:\\n\\nEXAMPLE:  \\nSTRING = \"PAYPALISHIRING\"\\nR = 3\\n\\nFOR ZIG: if you simply store \"R\" elements in a 2d matrix like this:\\n[P]\\n[A]\\n[Y]\\n\\nand \\nFOR ZAG: if you store \"R-2\" elements in a 2d matrix from bottom to top like this:\\n\\n[P     ]\\n[A, P ]\\n[Y     ]\\n\\nand repeat the process for whole string.\\n\\nitr2:\\n[P      A]\\n[A  P  L]\\n[Y       I]\\n\\nitr3:\\n[P      A    ]\\n[A  P  L  S]\\n[Y       I    ]\\n\\nitr4:\\n[P      A      H]\\n[A  P  L  S   I ]\\n[Y       I       R]\\n\\nitr5:\\n[P      A      H   ]\\n[A  P  L  S   I   I]\\n[Y       I       R   ]\\n\\nitr6:\\n[P      A      H      N]\\n[A  P  L  S   I   I   G]\\n[Y       I       R        ]\\n\\nIf you understand this, try another optimized version. \\n\\nIf you still confused, try running for different number of rows."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Video Solution\\nhttps://nileshblog.tech/humix/video/f239ef5c145b049977c4fb8707654e1219d33372b4304f6571a4c43b40a4942c"
                    },
                    {
                        "username": "umangthusoo1995",
                        "content": "my code is Accepted while Running the test case shown in \"last executed input\" but fails when submitting. can anyone tell the reason"
                    },
                    {
                        "username": "danel_danel",
                        "content": "If you submit the same solution  many times then the site will report differnet runtime and memory usage :)"
                    },
                    {
                        "username": "sonnyrajagopalan",
                        "content": "Am I the only person scratching my head about zig zag conversion? The problem states little to no indication of what happens when numRows is not 3, not to mention if there is only character in the middle or something else. Terrible and not at all fun problem."
                    },
                    {
                        "username": "azhall",
                        "content": "First of all, lacking examples out the a-hole.  An even zig-zag?\\nSo I fail on this TC:\\nstring = \"ABC\"\\nnumRows = 2\\nexpected result: \"ACB\"\\n\\nOk, so mentally I'm picturing\\nA C \\nB\\n\\nSo I throw in a fix, only to fail on \\nstring = \"ABCDE\"\\nnumRows = 4\\nexpected result: \"ABCED\"\\n\\nABCED?? Are you fucking with me??  \\n\\nA E\\nB\\nC\\nD\\n\\n/rage quit"
                    },
                    {
                        "username": "uncle_cat",
                        "content": "Maybe I am too dumb to experience the essence of this problem, but I am really confused that there are thousand ways of playing with a string. What knowledge or skill does this problem want to test us? If I meet this problem in an interview, I will ask for another one, or  just quit."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1568781,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "devhindo",
                        "content": "That problem was a nightmare"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "Divide the problem in subsections and try to find out the pattern in the given matrix."
                    },
                    {
                        "username": "S_Basu",
                        "content": "# \\uD83D\\uDE30\\uD83D\\uDE25\\uD83E\\uDD75\\uD83E\\uDD2F\\uD83D\\uDE24\\uD83E\\uDD2F\\nThis question made me go through all of the above...\\nUntil FINALLY!!!\\n# \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "ck439105",
                        "content": "Why my keyboard\\'s keys are not working on this problem??im very anxious."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Paypal is hiring & Google is firing \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "You will be hired in PAYPAL if you solve this .\\nLOL"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Nice, daily question which has number of dislikes almost two times more than likes. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think they probably updated it since those dislikes, I wouldn\\'t know what there is to dislike about this one. pretty straightforward puzzle"
                    },
                    {
                        "username": "yonifra",
                        "content": "This was a very nice question! Once you understand the logic behind the zigzagging it\\'s actually not to hard to code the solution for this. For me, it was basically running \"up and down\" the number of rows, creating a map of each row and its letters, and then combining it all together"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast C++ || Java || Python || JavaScript Solution \\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1786520,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "devhindo",
                        "content": "That problem was a nightmare"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "Divide the problem in subsections and try to find out the pattern in the given matrix."
                    },
                    {
                        "username": "S_Basu",
                        "content": "# \\uD83D\\uDE30\\uD83D\\uDE25\\uD83E\\uDD75\\uD83E\\uDD2F\\uD83D\\uDE24\\uD83E\\uDD2F\\nThis question made me go through all of the above...\\nUntil FINALLY!!!\\n# \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "ck439105",
                        "content": "Why my keyboard\\'s keys are not working on this problem??im very anxious."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Paypal is hiring & Google is firing \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "You will be hired in PAYPAL if you solve this .\\nLOL"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Nice, daily question which has number of dislikes almost two times more than likes. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think they probably updated it since those dislikes, I wouldn\\'t know what there is to dislike about this one. pretty straightforward puzzle"
                    },
                    {
                        "username": "yonifra",
                        "content": "This was a very nice question! Once you understand the logic behind the zigzagging it\\'s actually not to hard to code the solution for this. For me, it was basically running \"up and down\" the number of rows, creating a map of each row and its letters, and then combining it all together"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast C++ || Java || Python || JavaScript Solution \\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1786452,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "devhindo",
                        "content": "That problem was a nightmare"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "Divide the problem in subsections and try to find out the pattern in the given matrix."
                    },
                    {
                        "username": "S_Basu",
                        "content": "# \\uD83D\\uDE30\\uD83D\\uDE25\\uD83E\\uDD75\\uD83E\\uDD2F\\uD83D\\uDE24\\uD83E\\uDD2F\\nThis question made me go through all of the above...\\nUntil FINALLY!!!\\n# \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "ck439105",
                        "content": "Why my keyboard\\'s keys are not working on this problem??im very anxious."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Paypal is hiring & Google is firing \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "You will be hired in PAYPAL if you solve this .\\nLOL"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Nice, daily question which has number of dislikes almost two times more than likes. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think they probably updated it since those dislikes, I wouldn\\'t know what there is to dislike about this one. pretty straightforward puzzle"
                    },
                    {
                        "username": "yonifra",
                        "content": "This was a very nice question! Once you understand the logic behind the zigzagging it\\'s actually not to hard to code the solution for this. For me, it was basically running \"up and down\" the number of rows, creating a map of each row and its letters, and then combining it all together"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast C++ || Java || Python || JavaScript Solution \\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1786409,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "devhindo",
                        "content": "That problem was a nightmare"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "Divide the problem in subsections and try to find out the pattern in the given matrix."
                    },
                    {
                        "username": "S_Basu",
                        "content": "# \\uD83D\\uDE30\\uD83D\\uDE25\\uD83E\\uDD75\\uD83E\\uDD2F\\uD83D\\uDE24\\uD83E\\uDD2F\\nThis question made me go through all of the above...\\nUntil FINALLY!!!\\n# \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "ck439105",
                        "content": "Why my keyboard\\'s keys are not working on this problem??im very anxious."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Paypal is hiring & Google is firing \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "You will be hired in PAYPAL if you solve this .\\nLOL"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Nice, daily question which has number of dislikes almost two times more than likes. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think they probably updated it since those dislikes, I wouldn\\'t know what there is to dislike about this one. pretty straightforward puzzle"
                    },
                    {
                        "username": "yonifra",
                        "content": "This was a very nice question! Once you understand the logic behind the zigzagging it\\'s actually not to hard to code the solution for this. For me, it was basically running \"up and down\" the number of rows, creating a map of each row and its letters, and then combining it all together"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast C++ || Java || Python || JavaScript Solution \\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1785985,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "devhindo",
                        "content": "That problem was a nightmare"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "Divide the problem in subsections and try to find out the pattern in the given matrix."
                    },
                    {
                        "username": "S_Basu",
                        "content": "# \\uD83D\\uDE30\\uD83D\\uDE25\\uD83E\\uDD75\\uD83E\\uDD2F\\uD83D\\uDE24\\uD83E\\uDD2F\\nThis question made me go through all of the above...\\nUntil FINALLY!!!\\n# \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "ck439105",
                        "content": "Why my keyboard\\'s keys are not working on this problem??im very anxious."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Paypal is hiring & Google is firing \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "You will be hired in PAYPAL if you solve this .\\nLOL"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Nice, daily question which has number of dislikes almost two times more than likes. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think they probably updated it since those dislikes, I wouldn\\'t know what there is to dislike about this one. pretty straightforward puzzle"
                    },
                    {
                        "username": "yonifra",
                        "content": "This was a very nice question! Once you understand the logic behind the zigzagging it\\'s actually not to hard to code the solution for this. For me, it was basically running \"up and down\" the number of rows, creating a map of each row and its letters, and then combining it all together"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast C++ || Java || Python || JavaScript Solution \\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1785952,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "devhindo",
                        "content": "That problem was a nightmare"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "Divide the problem in subsections and try to find out the pattern in the given matrix."
                    },
                    {
                        "username": "S_Basu",
                        "content": "# \\uD83D\\uDE30\\uD83D\\uDE25\\uD83E\\uDD75\\uD83E\\uDD2F\\uD83D\\uDE24\\uD83E\\uDD2F\\nThis question made me go through all of the above...\\nUntil FINALLY!!!\\n# \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "ck439105",
                        "content": "Why my keyboard\\'s keys are not working on this problem??im very anxious."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Paypal is hiring & Google is firing \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "You will be hired in PAYPAL if you solve this .\\nLOL"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Nice, daily question which has number of dislikes almost two times more than likes. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think they probably updated it since those dislikes, I wouldn\\'t know what there is to dislike about this one. pretty straightforward puzzle"
                    },
                    {
                        "username": "yonifra",
                        "content": "This was a very nice question! Once you understand the logic behind the zigzagging it\\'s actually not to hard to code the solution for this. For me, it was basically running \"up and down\" the number of rows, creating a map of each row and its letters, and then combining it all together"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast C++ || Java || Python || JavaScript Solution \\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1785932,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "devhindo",
                        "content": "That problem was a nightmare"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "Divide the problem in subsections and try to find out the pattern in the given matrix."
                    },
                    {
                        "username": "S_Basu",
                        "content": "# \\uD83D\\uDE30\\uD83D\\uDE25\\uD83E\\uDD75\\uD83E\\uDD2F\\uD83D\\uDE24\\uD83E\\uDD2F\\nThis question made me go through all of the above...\\nUntil FINALLY!!!\\n# \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "ck439105",
                        "content": "Why my keyboard\\'s keys are not working on this problem??im very anxious."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Paypal is hiring & Google is firing \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "You will be hired in PAYPAL if you solve this .\\nLOL"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Nice, daily question which has number of dislikes almost two times more than likes. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think they probably updated it since those dislikes, I wouldn\\'t know what there is to dislike about this one. pretty straightforward puzzle"
                    },
                    {
                        "username": "yonifra",
                        "content": "This was a very nice question! Once you understand the logic behind the zigzagging it\\'s actually not to hard to code the solution for this. For me, it was basically running \"up and down\" the number of rows, creating a map of each row and its letters, and then combining it all together"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast C++ || Java || Python || JavaScript Solution \\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1785821,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "devhindo",
                        "content": "That problem was a nightmare"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "Divide the problem in subsections and try to find out the pattern in the given matrix."
                    },
                    {
                        "username": "S_Basu",
                        "content": "# \\uD83D\\uDE30\\uD83D\\uDE25\\uD83E\\uDD75\\uD83E\\uDD2F\\uD83D\\uDE24\\uD83E\\uDD2F\\nThis question made me go through all of the above...\\nUntil FINALLY!!!\\n# \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "ck439105",
                        "content": "Why my keyboard\\'s keys are not working on this problem??im very anxious."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Paypal is hiring & Google is firing \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "You will be hired in PAYPAL if you solve this .\\nLOL"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Nice, daily question which has number of dislikes almost two times more than likes. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think they probably updated it since those dislikes, I wouldn\\'t know what there is to dislike about this one. pretty straightforward puzzle"
                    },
                    {
                        "username": "yonifra",
                        "content": "This was a very nice question! Once you understand the logic behind the zigzagging it\\'s actually not to hard to code the solution for this. For me, it was basically running \"up and down\" the number of rows, creating a map of each row and its letters, and then combining it all together"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast C++ || Java || Python || JavaScript Solution \\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1750325,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "devhindo",
                        "content": "That problem was a nightmare"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "Divide the problem in subsections and try to find out the pattern in the given matrix."
                    },
                    {
                        "username": "S_Basu",
                        "content": "# \\uD83D\\uDE30\\uD83D\\uDE25\\uD83E\\uDD75\\uD83E\\uDD2F\\uD83D\\uDE24\\uD83E\\uDD2F\\nThis question made me go through all of the above...\\nUntil FINALLY!!!\\n# \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "ck439105",
                        "content": "Why my keyboard\\'s keys are not working on this problem??im very anxious."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Paypal is hiring & Google is firing \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "You will be hired in PAYPAL if you solve this .\\nLOL"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Nice, daily question which has number of dislikes almost two times more than likes. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think they probably updated it since those dislikes, I wouldn\\'t know what there is to dislike about this one. pretty straightforward puzzle"
                    },
                    {
                        "username": "yonifra",
                        "content": "This was a very nice question! Once you understand the logic behind the zigzagging it\\'s actually not to hard to code the solution for this. For me, it was basically running \"up and down\" the number of rows, creating a map of each row and its letters, and then combining it all together"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast C++ || Java || Python || JavaScript Solution \\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1576669,
                "content": [
                    {
                        "username": "_NileshRaut",
                        "content": "Simple C++ | Python | Java | JavaScript here:\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    },
                    {
                        "username": "devhindo",
                        "content": "That problem was a nightmare"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "Divide the problem in subsections and try to find out the pattern in the given matrix."
                    },
                    {
                        "username": "S_Basu",
                        "content": "# \\uD83D\\uDE30\\uD83D\\uDE25\\uD83E\\uDD75\\uD83E\\uDD2F\\uD83D\\uDE24\\uD83E\\uDD2F\\nThis question made me go through all of the above...\\nUntil FINALLY!!!\\n# \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "ck439105",
                        "content": "Why my keyboard\\'s keys are not working on this problem??im very anxious."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "Paypal is hiring & Google is firing \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "You will be hired in PAYPAL if you solve this .\\nLOL"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Nice, daily question which has number of dislikes almost two times more than likes. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think they probably updated it since those dislikes, I wouldn\\'t know what there is to dislike about this one. pretty straightforward puzzle"
                    },
                    {
                        "username": "yonifra",
                        "content": "This was a very nice question! Once you understand the logic behind the zigzagging it\\'s actually not to hard to code the solution for this. For me, it was basically running \"up and down\" the number of rows, creating a map of each row and its letters, and then combining it all together"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast C++ || Java || Python || JavaScript Solution \\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-zigzag-conversion-solution-c-java-python-javascript-swift-typescript/"
                    }
                ]
            },
            {
                "id": 1576644,
                "content": [
                    {
                        "username": "prathamruhela",
                        "content": "![image](https://assets.leetcode.com/users/images/93642a6e-2a52-441d-890a-2a1980c6a6eb_1650466312.4305205.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/3b038ccb-619b-4868-8726-11a5856d0c23_1632762605.835226.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3fe42fb0-9706-4dfe-a361-49129b0dfebd_1632762610.1210344.png)\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/73c7601e-b033-47fb-8ef8-5de8a708fa35_1625176545.550314.png)\\n\\n![image](https://assets.leetcode.com/users/images/33c8e974-b1cd-45ad-97f3-4a91ec2c49ed_1625176551.957508.png)\\n"
                    },
                    {
                        "username": "erkangxu",
                        "content": "I\\'ve got this follow up in my interview by a thoughtful Interviewer.\\nThink this kind of conversion is a encryption method. \\nHow do you convert the encrypted string back to it\\'s clear text form?"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/\\n"
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/"
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "I think this question's description is not clear enough.  \\n\\nWhat if the number of rows is 4? How will the second column be like?"
                    },
                    {
                        "username": "trycatch",
                        "content": "How come convert(\"ABC\", 2) is ACB not ABC?"
                    },
                    {
                        "username": "stamen3054",
                        "content": "Why the result is not ABC?\\n\\nShouldn't the even line have a blank, so the first line should be A_, and the second line should be BC?"
                    }
                ]
            },
            {
                "id": 1576534,
                "content": [
                    {
                        "username": "prathamruhela",
                        "content": "![image](https://assets.leetcode.com/users/images/93642a6e-2a52-441d-890a-2a1980c6a6eb_1650466312.4305205.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/3b038ccb-619b-4868-8726-11a5856d0c23_1632762605.835226.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3fe42fb0-9706-4dfe-a361-49129b0dfebd_1632762610.1210344.png)\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/73c7601e-b033-47fb-8ef8-5de8a708fa35_1625176545.550314.png)\\n\\n![image](https://assets.leetcode.com/users/images/33c8e974-b1cd-45ad-97f3-4a91ec2c49ed_1625176551.957508.png)\\n"
                    },
                    {
                        "username": "erkangxu",
                        "content": "I\\'ve got this follow up in my interview by a thoughtful Interviewer.\\nThink this kind of conversion is a encryption method. \\nHow do you convert the encrypted string back to it\\'s clear text form?"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/\\n"
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/"
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "I think this question's description is not clear enough.  \\n\\nWhat if the number of rows is 4? How will the second column be like?"
                    },
                    {
                        "username": "trycatch",
                        "content": "How come convert(\"ABC\", 2) is ACB not ABC?"
                    },
                    {
                        "username": "stamen3054",
                        "content": "Why the result is not ABC?\\n\\nShouldn't the even line have a blank, so the first line should be A_, and the second line should be BC?"
                    }
                ]
            },
            {
                "id": 1575791,
                "content": [
                    {
                        "username": "prathamruhela",
                        "content": "![image](https://assets.leetcode.com/users/images/93642a6e-2a52-441d-890a-2a1980c6a6eb_1650466312.4305205.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/3b038ccb-619b-4868-8726-11a5856d0c23_1632762605.835226.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3fe42fb0-9706-4dfe-a361-49129b0dfebd_1632762610.1210344.png)\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/73c7601e-b033-47fb-8ef8-5de8a708fa35_1625176545.550314.png)\\n\\n![image](https://assets.leetcode.com/users/images/33c8e974-b1cd-45ad-97f3-4a91ec2c49ed_1625176551.957508.png)\\n"
                    },
                    {
                        "username": "erkangxu",
                        "content": "I\\'ve got this follow up in my interview by a thoughtful Interviewer.\\nThink this kind of conversion is a encryption method. \\nHow do you convert the encrypted string back to it\\'s clear text form?"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/\\n"
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/"
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "I think this question's description is not clear enough.  \\n\\nWhat if the number of rows is 4? How will the second column be like?"
                    },
                    {
                        "username": "trycatch",
                        "content": "How come convert(\"ABC\", 2) is ACB not ABC?"
                    },
                    {
                        "username": "stamen3054",
                        "content": "Why the result is not ABC?\\n\\nShouldn't the even line have a blank, so the first line should be A_, and the second line should be BC?"
                    }
                ]
            },
            {
                "id": 1575478,
                "content": [
                    {
                        "username": "prathamruhela",
                        "content": "![image](https://assets.leetcode.com/users/images/93642a6e-2a52-441d-890a-2a1980c6a6eb_1650466312.4305205.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/3b038ccb-619b-4868-8726-11a5856d0c23_1632762605.835226.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3fe42fb0-9706-4dfe-a361-49129b0dfebd_1632762610.1210344.png)\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/73c7601e-b033-47fb-8ef8-5de8a708fa35_1625176545.550314.png)\\n\\n![image](https://assets.leetcode.com/users/images/33c8e974-b1cd-45ad-97f3-4a91ec2c49ed_1625176551.957508.png)\\n"
                    },
                    {
                        "username": "erkangxu",
                        "content": "I\\'ve got this follow up in my interview by a thoughtful Interviewer.\\nThink this kind of conversion is a encryption method. \\nHow do you convert the encrypted string back to it\\'s clear text form?"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/\\n"
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/"
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "I think this question's description is not clear enough.  \\n\\nWhat if the number of rows is 4? How will the second column be like?"
                    },
                    {
                        "username": "trycatch",
                        "content": "How come convert(\"ABC\", 2) is ACB not ABC?"
                    },
                    {
                        "username": "stamen3054",
                        "content": "Why the result is not ABC?\\n\\nShouldn't the even line have a blank, so the first line should be A_, and the second line should be BC?"
                    }
                ]
            },
            {
                "id": 1574667,
                "content": [
                    {
                        "username": "prathamruhela",
                        "content": "![image](https://assets.leetcode.com/users/images/93642a6e-2a52-441d-890a-2a1980c6a6eb_1650466312.4305205.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/3b038ccb-619b-4868-8726-11a5856d0c23_1632762605.835226.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3fe42fb0-9706-4dfe-a361-49129b0dfebd_1632762610.1210344.png)\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/73c7601e-b033-47fb-8ef8-5de8a708fa35_1625176545.550314.png)\\n\\n![image](https://assets.leetcode.com/users/images/33c8e974-b1cd-45ad-97f3-4a91ec2c49ed_1625176551.957508.png)\\n"
                    },
                    {
                        "username": "erkangxu",
                        "content": "I\\'ve got this follow up in my interview by a thoughtful Interviewer.\\nThink this kind of conversion is a encryption method. \\nHow do you convert the encrypted string back to it\\'s clear text form?"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/\\n"
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/"
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "I think this question's description is not clear enough.  \\n\\nWhat if the number of rows is 4? How will the second column be like?"
                    },
                    {
                        "username": "trycatch",
                        "content": "How come convert(\"ABC\", 2) is ACB not ABC?"
                    },
                    {
                        "username": "stamen3054",
                        "content": "Why the result is not ABC?\\n\\nShouldn't the even line have a blank, so the first line should be A_, and the second line should be BC?"
                    }
                ]
            },
            {
                "id": 1574033,
                "content": [
                    {
                        "username": "prathamruhela",
                        "content": "![image](https://assets.leetcode.com/users/images/93642a6e-2a52-441d-890a-2a1980c6a6eb_1650466312.4305205.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/3b038ccb-619b-4868-8726-11a5856d0c23_1632762605.835226.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3fe42fb0-9706-4dfe-a361-49129b0dfebd_1632762610.1210344.png)\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/73c7601e-b033-47fb-8ef8-5de8a708fa35_1625176545.550314.png)\\n\\n![image](https://assets.leetcode.com/users/images/33c8e974-b1cd-45ad-97f3-4a91ec2c49ed_1625176551.957508.png)\\n"
                    },
                    {
                        "username": "erkangxu",
                        "content": "I\\'ve got this follow up in my interview by a thoughtful Interviewer.\\nThink this kind of conversion is a encryption method. \\nHow do you convert the encrypted string back to it\\'s clear text form?"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/\\n"
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/"
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "I think this question's description is not clear enough.  \\n\\nWhat if the number of rows is 4? How will the second column be like?"
                    },
                    {
                        "username": "trycatch",
                        "content": "How come convert(\"ABC\", 2) is ACB not ABC?"
                    },
                    {
                        "username": "stamen3054",
                        "content": "Why the result is not ABC?\\n\\nShouldn't the even line have a blank, so the first line should be A_, and the second line should be BC?"
                    }
                ]
            },
            {
                "id": 1573842,
                "content": [
                    {
                        "username": "prathamruhela",
                        "content": "![image](https://assets.leetcode.com/users/images/93642a6e-2a52-441d-890a-2a1980c6a6eb_1650466312.4305205.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/3b038ccb-619b-4868-8726-11a5856d0c23_1632762605.835226.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3fe42fb0-9706-4dfe-a361-49129b0dfebd_1632762610.1210344.png)\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/73c7601e-b033-47fb-8ef8-5de8a708fa35_1625176545.550314.png)\\n\\n![image](https://assets.leetcode.com/users/images/33c8e974-b1cd-45ad-97f3-4a91ec2c49ed_1625176551.957508.png)\\n"
                    },
                    {
                        "username": "erkangxu",
                        "content": "I\\'ve got this follow up in my interview by a thoughtful Interviewer.\\nThink this kind of conversion is a encryption method. \\nHow do you convert the encrypted string back to it\\'s clear text form?"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/\\n"
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/"
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "I think this question's description is not clear enough.  \\n\\nWhat if the number of rows is 4? How will the second column be like?"
                    },
                    {
                        "username": "trycatch",
                        "content": "How come convert(\"ABC\", 2) is ACB not ABC?"
                    },
                    {
                        "username": "stamen3054",
                        "content": "Why the result is not ABC?\\n\\nShouldn't the even line have a blank, so the first line should be A_, and the second line should be BC?"
                    }
                ]
            },
            {
                "id": 1570979,
                "content": [
                    {
                        "username": "prathamruhela",
                        "content": "![image](https://assets.leetcode.com/users/images/93642a6e-2a52-441d-890a-2a1980c6a6eb_1650466312.4305205.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/3b038ccb-619b-4868-8726-11a5856d0c23_1632762605.835226.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3fe42fb0-9706-4dfe-a361-49129b0dfebd_1632762610.1210344.png)\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/73c7601e-b033-47fb-8ef8-5de8a708fa35_1625176545.550314.png)\\n\\n![image](https://assets.leetcode.com/users/images/33c8e974-b1cd-45ad-97f3-4a91ec2c49ed_1625176551.957508.png)\\n"
                    },
                    {
                        "username": "erkangxu",
                        "content": "I\\'ve got this follow up in my interview by a thoughtful Interviewer.\\nThink this kind of conversion is a encryption method. \\nHow do you convert the encrypted string back to it\\'s clear text form?"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/\\n"
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/"
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "I think this question's description is not clear enough.  \\n\\nWhat if the number of rows is 4? How will the second column be like?"
                    },
                    {
                        "username": "trycatch",
                        "content": "How come convert(\"ABC\", 2) is ACB not ABC?"
                    },
                    {
                        "username": "stamen3054",
                        "content": "Why the result is not ABC?\\n\\nShouldn't the even line have a blank, so the first line should be A_, and the second line should be BC?"
                    }
                ]
            },
            {
                "id": 1570978,
                "content": [
                    {
                        "username": "prathamruhela",
                        "content": "![image](https://assets.leetcode.com/users/images/93642a6e-2a52-441d-890a-2a1980c6a6eb_1650466312.4305205.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/3b038ccb-619b-4868-8726-11a5856d0c23_1632762605.835226.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3fe42fb0-9706-4dfe-a361-49129b0dfebd_1632762610.1210344.png)\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/73c7601e-b033-47fb-8ef8-5de8a708fa35_1625176545.550314.png)\\n\\n![image](https://assets.leetcode.com/users/images/33c8e974-b1cd-45ad-97f3-4a91ec2c49ed_1625176551.957508.png)\\n"
                    },
                    {
                        "username": "erkangxu",
                        "content": "I\\'ve got this follow up in my interview by a thoughtful Interviewer.\\nThink this kind of conversion is a encryption method. \\nHow do you convert the encrypted string back to it\\'s clear text form?"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/\\n"
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/"
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "I think this question's description is not clear enough.  \\n\\nWhat if the number of rows is 4? How will the second column be like?"
                    },
                    {
                        "username": "trycatch",
                        "content": "How come convert(\"ABC\", 2) is ACB not ABC?"
                    },
                    {
                        "username": "stamen3054",
                        "content": "Why the result is not ABC?\\n\\nShouldn't the even line have a blank, so the first line should be A_, and the second line should be BC?"
                    }
                ]
            },
            {
                "id": 1570981,
                "content": [
                    {
                        "username": "prathamruhela",
                        "content": "![image](https://assets.leetcode.com/users/images/93642a6e-2a52-441d-890a-2a1980c6a6eb_1650466312.4305205.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/3b038ccb-619b-4868-8726-11a5856d0c23_1632762605.835226.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3fe42fb0-9706-4dfe-a361-49129b0dfebd_1632762610.1210344.png)\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/73c7601e-b033-47fb-8ef8-5de8a708fa35_1625176545.550314.png)\\n\\n![image](https://assets.leetcode.com/users/images/33c8e974-b1cd-45ad-97f3-4a91ec2c49ed_1625176551.957508.png)\\n"
                    },
                    {
                        "username": "erkangxu",
                        "content": "I\\'ve got this follow up in my interview by a thoughtful Interviewer.\\nThink this kind of conversion is a encryption method. \\nHow do you convert the encrypted string back to it\\'s clear text form?"
                    },
                    {
                        "username": "msn_user",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/\\n"
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'s good explanation and code in C++/Java/Python with comments:\\nhttps://www.techiedelight.com/print-string-in-zig-zag-form-k-rows/"
                    },
                    {
                        "username": "zhugejunwei",
                        "content": "I think this question's description is not clear enough.  \\n\\nWhat if the number of rows is 4? How will the second column be like?"
                    },
                    {
                        "username": "trycatch",
                        "content": "How come convert(\"ABC\", 2) is ACB not ABC?"
                    },
                    {
                        "username": "stamen3054",
                        "content": "Why the result is not ABC?\\n\\nShouldn't the even line have a blank, so the first line should be A_, and the second line should be BC?"
                    }
                ]
            },
            {
                "id": 1570982,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nOnce the code is accepted, the previous wrong submissions code reflects the correct code but not the wrong one. This is not useful if we want to look at the wrong code and debug it at later point of time.\\n\\nCould you please correct this?\\n\\nthanks."
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "Here goes solution without 2D array\n\nclass Solution {\n    public String convert(String s, int numRows) {\n        if(numRows == 1) return s;\n        String[] strArr = s.split(\"\");\n        String ans = \"\";\n        for(int i = 0; i < numRows; i++) {\n            int j = i;\n            while(j < strArr.length) {\n                ans += strArr[j];\n                if(!(i == j || i == 0 || i == numRows - 1)) {\n                    j = j + 2 * i;\n                    if(j < strArr.length) {\n                        ans += strArr[j];\n                    }\n                }\n                if(i < numRows - 1)\n                    j = j + 2*(numRows - i - 1);\n                else\n                    j = j + 2*(numRows - 1);\n            }\n            // System.out.println(ans);\n        }\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "can anyone explain me, what is wrong here?\n\nvar convert = function(s, numRows) {\n    console.log(s)\n    var arr=new Array(numRows).fill([]);\n    console.log(arr,arr[0])\n    var pos=0;\n    for(var i=0;i<s.length;i++)\n    {\n        arr[pos].push(s[i]);\n        pos=pos+1;\n        if(pos==numRows)\n        {\n            pos=0;\n        }\n    }\n    console.log(arr)\n};"
                    },
                    {
                        "username": "Cydraech",
                        "content": "I really like the problem, but sadly the wording is very unlucky. An easier explanation of the zig zag pattern would make this problem much better. A visual representation of it would\\'ve gone a long way."
                    },
                    {
                        "username": "harikrishna8121999",
                        "content": "\\nHint 1:\\nTo grasp the significance of the positions of elements in the output, it\\'s essential to recognize their relationship with the numRows parameter. Consider the following example:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\n\\nIn this case, let\\'s examine the difference between the first element \\'P\\' and the next element \\'I\\' in the output, which is 6. This difference corresponds to 2 times (numRows - 1), where (numRows - 1) equals 2*(4-1).\\n\\nHint 2:\\nThe calculation of the difference in positions changes when there are diagonal elements in the matrix. For instance:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\nExplanation:\\n\\n```\\nP     I    N\\nA   L S  I G\\nY A   H R\\nP     I\\n```\\n\\nIn the first and last rows, where there are no diagonal elements, the difference between element positions remains 2 times (numRows - 1). However, in the other rows, where diagonal elements are present, a different logic should be applied to calculate the diagonal difference."
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "hey guys , the zigzag thing works like this\\n\\nstring: \"PAYPALISHIRING\"\\nstart mapping the characters from top to bottom in a column. \\nfirst column:\\nP\\nA\\nY\\n\\nnow move upwards in a zigzag manner and when you reach the first row, start moving top to bottom again, and repeat until characters end.\\n1):\\nP\\nA P (move zigzag)\\nY\\n\\n2):\\nP      A\\nA  P  L   I\\nY       I\\n"
                    },
                    {
                        "username": "nikolacincovic73",
                        "content": "Easy task, terrible explanation.\\nFor starters, first testcase might be less confusing if printed like this\\n\\nrow 0 || P              A               H               N\\nrow 1 ||     A      P       L      S       I        I       G\\nrow 2 ||         Y               I                R\\n\\nIf you read the letters by rows you will get \"PAHN\"+\"APLSIIG\"+\"YIR\"=\"PAHNAPLSIIGYIR\"\\n\\nBasically you make counter variable to remember what row are you currently in (starting from 0).\\nYou put next character from input string into that row, update counter value so you\\'re in next row and keep doing that until you\\'ve reached the end of input string.\\nKeep in mind that each time you get to the first or last row you switch direction of moving.\\nJoin all rows and you get the solution.\\n"
                    },
                    {
                        "username": "satendra_04",
                        "content": " buthie bdfjbuekb  jefiuhneui jbdufhiogvhe badiufhioser bfirehfiehriof ifrherhg ufoeir ieruhgoier and convert it into zigzag fashion"
                    },
                    {
                        "username": "sapercq",
                        "content": "Java solution 2ms (faster than 99.9)\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/3978572/faster-then-99-89-solution-43-78memory-loop-java/"
                    },
                    {
                        "username": "udayleetco",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        int x=s.length();\\n        char arr[][]=new char[numRows][x];\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                arr[i][j]=\\'@\\';\\n            }\\n        }int k=0;\\n        int l=0;\\n        while(k<x){\\n        char t=s.charAt(k);\\n         for(int i=0;i<n-1;i++){\\n             arr[k][l]=t;\\n             k++;\\n         }\\n         l++;\\n         for(int j=n-2;j>1;j--){\\n          \\n             arr[k][l]=t;\\n                k--;\\n         }\\n        }\\n        String st=\"\";\\n     for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                if (arr[i][j] !=\\'@\\'){\\n                  st+=arr[i][j];\\n                }\\n            }\\n        }\\n        return st;\\n        }\\n    }\\nwhats the error ?"
                    }
                ]
            },
            {
                "id": 2076223,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nOnce the code is accepted, the previous wrong submissions code reflects the correct code but not the wrong one. This is not useful if we want to look at the wrong code and debug it at later point of time.\\n\\nCould you please correct this?\\n\\nthanks."
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "Here goes solution without 2D array\n\nclass Solution {\n    public String convert(String s, int numRows) {\n        if(numRows == 1) return s;\n        String[] strArr = s.split(\"\");\n        String ans = \"\";\n        for(int i = 0; i < numRows; i++) {\n            int j = i;\n            while(j < strArr.length) {\n                ans += strArr[j];\n                if(!(i == j || i == 0 || i == numRows - 1)) {\n                    j = j + 2 * i;\n                    if(j < strArr.length) {\n                        ans += strArr[j];\n                    }\n                }\n                if(i < numRows - 1)\n                    j = j + 2*(numRows - i - 1);\n                else\n                    j = j + 2*(numRows - 1);\n            }\n            // System.out.println(ans);\n        }\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "can anyone explain me, what is wrong here?\n\nvar convert = function(s, numRows) {\n    console.log(s)\n    var arr=new Array(numRows).fill([]);\n    console.log(arr,arr[0])\n    var pos=0;\n    for(var i=0;i<s.length;i++)\n    {\n        arr[pos].push(s[i]);\n        pos=pos+1;\n        if(pos==numRows)\n        {\n            pos=0;\n        }\n    }\n    console.log(arr)\n};"
                    },
                    {
                        "username": "Cydraech",
                        "content": "I really like the problem, but sadly the wording is very unlucky. An easier explanation of the zig zag pattern would make this problem much better. A visual representation of it would\\'ve gone a long way."
                    },
                    {
                        "username": "harikrishna8121999",
                        "content": "\\nHint 1:\\nTo grasp the significance of the positions of elements in the output, it\\'s essential to recognize their relationship with the numRows parameter. Consider the following example:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\n\\nIn this case, let\\'s examine the difference between the first element \\'P\\' and the next element \\'I\\' in the output, which is 6. This difference corresponds to 2 times (numRows - 1), where (numRows - 1) equals 2*(4-1).\\n\\nHint 2:\\nThe calculation of the difference in positions changes when there are diagonal elements in the matrix. For instance:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\nExplanation:\\n\\n```\\nP     I    N\\nA   L S  I G\\nY A   H R\\nP     I\\n```\\n\\nIn the first and last rows, where there are no diagonal elements, the difference between element positions remains 2 times (numRows - 1). However, in the other rows, where diagonal elements are present, a different logic should be applied to calculate the diagonal difference."
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "hey guys , the zigzag thing works like this\\n\\nstring: \"PAYPALISHIRING\"\\nstart mapping the characters from top to bottom in a column. \\nfirst column:\\nP\\nA\\nY\\n\\nnow move upwards in a zigzag manner and when you reach the first row, start moving top to bottom again, and repeat until characters end.\\n1):\\nP\\nA P (move zigzag)\\nY\\n\\n2):\\nP      A\\nA  P  L   I\\nY       I\\n"
                    },
                    {
                        "username": "nikolacincovic73",
                        "content": "Easy task, terrible explanation.\\nFor starters, first testcase might be less confusing if printed like this\\n\\nrow 0 || P              A               H               N\\nrow 1 ||     A      P       L      S       I        I       G\\nrow 2 ||         Y               I                R\\n\\nIf you read the letters by rows you will get \"PAHN\"+\"APLSIIG\"+\"YIR\"=\"PAHNAPLSIIGYIR\"\\n\\nBasically you make counter variable to remember what row are you currently in (starting from 0).\\nYou put next character from input string into that row, update counter value so you\\'re in next row and keep doing that until you\\'ve reached the end of input string.\\nKeep in mind that each time you get to the first or last row you switch direction of moving.\\nJoin all rows and you get the solution.\\n"
                    },
                    {
                        "username": "satendra_04",
                        "content": " buthie bdfjbuekb  jefiuhneui jbdufhiogvhe badiufhioser bfirehfiehriof ifrherhg ufoeir ieruhgoier and convert it into zigzag fashion"
                    },
                    {
                        "username": "sapercq",
                        "content": "Java solution 2ms (faster than 99.9)\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/3978572/faster-then-99-89-solution-43-78memory-loop-java/"
                    },
                    {
                        "username": "udayleetco",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        int x=s.length();\\n        char arr[][]=new char[numRows][x];\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                arr[i][j]=\\'@\\';\\n            }\\n        }int k=0;\\n        int l=0;\\n        while(k<x){\\n        char t=s.charAt(k);\\n         for(int i=0;i<n-1;i++){\\n             arr[k][l]=t;\\n             k++;\\n         }\\n         l++;\\n         for(int j=n-2;j>1;j--){\\n          \\n             arr[k][l]=t;\\n                k--;\\n         }\\n        }\\n        String st=\"\";\\n     for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                if (arr[i][j] !=\\'@\\'){\\n                  st+=arr[i][j];\\n                }\\n            }\\n        }\\n        return st;\\n        }\\n    }\\nwhats the error ?"
                    }
                ]
            },
            {
                "id": 2073869,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nOnce the code is accepted, the previous wrong submissions code reflects the correct code but not the wrong one. This is not useful if we want to look at the wrong code and debug it at later point of time.\\n\\nCould you please correct this?\\n\\nthanks."
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "Here goes solution without 2D array\n\nclass Solution {\n    public String convert(String s, int numRows) {\n        if(numRows == 1) return s;\n        String[] strArr = s.split(\"\");\n        String ans = \"\";\n        for(int i = 0; i < numRows; i++) {\n            int j = i;\n            while(j < strArr.length) {\n                ans += strArr[j];\n                if(!(i == j || i == 0 || i == numRows - 1)) {\n                    j = j + 2 * i;\n                    if(j < strArr.length) {\n                        ans += strArr[j];\n                    }\n                }\n                if(i < numRows - 1)\n                    j = j + 2*(numRows - i - 1);\n                else\n                    j = j + 2*(numRows - 1);\n            }\n            // System.out.println(ans);\n        }\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "can anyone explain me, what is wrong here?\n\nvar convert = function(s, numRows) {\n    console.log(s)\n    var arr=new Array(numRows).fill([]);\n    console.log(arr,arr[0])\n    var pos=0;\n    for(var i=0;i<s.length;i++)\n    {\n        arr[pos].push(s[i]);\n        pos=pos+1;\n        if(pos==numRows)\n        {\n            pos=0;\n        }\n    }\n    console.log(arr)\n};"
                    },
                    {
                        "username": "Cydraech",
                        "content": "I really like the problem, but sadly the wording is very unlucky. An easier explanation of the zig zag pattern would make this problem much better. A visual representation of it would\\'ve gone a long way."
                    },
                    {
                        "username": "harikrishna8121999",
                        "content": "\\nHint 1:\\nTo grasp the significance of the positions of elements in the output, it\\'s essential to recognize their relationship with the numRows parameter. Consider the following example:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\n\\nIn this case, let\\'s examine the difference between the first element \\'P\\' and the next element \\'I\\' in the output, which is 6. This difference corresponds to 2 times (numRows - 1), where (numRows - 1) equals 2*(4-1).\\n\\nHint 2:\\nThe calculation of the difference in positions changes when there are diagonal elements in the matrix. For instance:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\nExplanation:\\n\\n```\\nP     I    N\\nA   L S  I G\\nY A   H R\\nP     I\\n```\\n\\nIn the first and last rows, where there are no diagonal elements, the difference between element positions remains 2 times (numRows - 1). However, in the other rows, where diagonal elements are present, a different logic should be applied to calculate the diagonal difference."
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "hey guys , the zigzag thing works like this\\n\\nstring: \"PAYPALISHIRING\"\\nstart mapping the characters from top to bottom in a column. \\nfirst column:\\nP\\nA\\nY\\n\\nnow move upwards in a zigzag manner and when you reach the first row, start moving top to bottom again, and repeat until characters end.\\n1):\\nP\\nA P (move zigzag)\\nY\\n\\n2):\\nP      A\\nA  P  L   I\\nY       I\\n"
                    },
                    {
                        "username": "nikolacincovic73",
                        "content": "Easy task, terrible explanation.\\nFor starters, first testcase might be less confusing if printed like this\\n\\nrow 0 || P              A               H               N\\nrow 1 ||     A      P       L      S       I        I       G\\nrow 2 ||         Y               I                R\\n\\nIf you read the letters by rows you will get \"PAHN\"+\"APLSIIG\"+\"YIR\"=\"PAHNAPLSIIGYIR\"\\n\\nBasically you make counter variable to remember what row are you currently in (starting from 0).\\nYou put next character from input string into that row, update counter value so you\\'re in next row and keep doing that until you\\'ve reached the end of input string.\\nKeep in mind that each time you get to the first or last row you switch direction of moving.\\nJoin all rows and you get the solution.\\n"
                    },
                    {
                        "username": "satendra_04",
                        "content": " buthie bdfjbuekb  jefiuhneui jbdufhiogvhe badiufhioser bfirehfiehriof ifrherhg ufoeir ieruhgoier and convert it into zigzag fashion"
                    },
                    {
                        "username": "sapercq",
                        "content": "Java solution 2ms (faster than 99.9)\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/3978572/faster-then-99-89-solution-43-78memory-loop-java/"
                    },
                    {
                        "username": "udayleetco",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        int x=s.length();\\n        char arr[][]=new char[numRows][x];\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                arr[i][j]=\\'@\\';\\n            }\\n        }int k=0;\\n        int l=0;\\n        while(k<x){\\n        char t=s.charAt(k);\\n         for(int i=0;i<n-1;i++){\\n             arr[k][l]=t;\\n             k++;\\n         }\\n         l++;\\n         for(int j=n-2;j>1;j--){\\n          \\n             arr[k][l]=t;\\n                k--;\\n         }\\n        }\\n        String st=\"\";\\n     for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                if (arr[i][j] !=\\'@\\'){\\n                  st+=arr[i][j];\\n                }\\n            }\\n        }\\n        return st;\\n        }\\n    }\\nwhats the error ?"
                    }
                ]
            },
            {
                "id": 2065785,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nOnce the code is accepted, the previous wrong submissions code reflects the correct code but not the wrong one. This is not useful if we want to look at the wrong code and debug it at later point of time.\\n\\nCould you please correct this?\\n\\nthanks."
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "Here goes solution without 2D array\n\nclass Solution {\n    public String convert(String s, int numRows) {\n        if(numRows == 1) return s;\n        String[] strArr = s.split(\"\");\n        String ans = \"\";\n        for(int i = 0; i < numRows; i++) {\n            int j = i;\n            while(j < strArr.length) {\n                ans += strArr[j];\n                if(!(i == j || i == 0 || i == numRows - 1)) {\n                    j = j + 2 * i;\n                    if(j < strArr.length) {\n                        ans += strArr[j];\n                    }\n                }\n                if(i < numRows - 1)\n                    j = j + 2*(numRows - i - 1);\n                else\n                    j = j + 2*(numRows - 1);\n            }\n            // System.out.println(ans);\n        }\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "can anyone explain me, what is wrong here?\n\nvar convert = function(s, numRows) {\n    console.log(s)\n    var arr=new Array(numRows).fill([]);\n    console.log(arr,arr[0])\n    var pos=0;\n    for(var i=0;i<s.length;i++)\n    {\n        arr[pos].push(s[i]);\n        pos=pos+1;\n        if(pos==numRows)\n        {\n            pos=0;\n        }\n    }\n    console.log(arr)\n};"
                    },
                    {
                        "username": "Cydraech",
                        "content": "I really like the problem, but sadly the wording is very unlucky. An easier explanation of the zig zag pattern would make this problem much better. A visual representation of it would\\'ve gone a long way."
                    },
                    {
                        "username": "harikrishna8121999",
                        "content": "\\nHint 1:\\nTo grasp the significance of the positions of elements in the output, it\\'s essential to recognize their relationship with the numRows parameter. Consider the following example:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\n\\nIn this case, let\\'s examine the difference between the first element \\'P\\' and the next element \\'I\\' in the output, which is 6. This difference corresponds to 2 times (numRows - 1), where (numRows - 1) equals 2*(4-1).\\n\\nHint 2:\\nThe calculation of the difference in positions changes when there are diagonal elements in the matrix. For instance:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\nExplanation:\\n\\n```\\nP     I    N\\nA   L S  I G\\nY A   H R\\nP     I\\n```\\n\\nIn the first and last rows, where there are no diagonal elements, the difference between element positions remains 2 times (numRows - 1). However, in the other rows, where diagonal elements are present, a different logic should be applied to calculate the diagonal difference."
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "hey guys , the zigzag thing works like this\\n\\nstring: \"PAYPALISHIRING\"\\nstart mapping the characters from top to bottom in a column. \\nfirst column:\\nP\\nA\\nY\\n\\nnow move upwards in a zigzag manner and when you reach the first row, start moving top to bottom again, and repeat until characters end.\\n1):\\nP\\nA P (move zigzag)\\nY\\n\\n2):\\nP      A\\nA  P  L   I\\nY       I\\n"
                    },
                    {
                        "username": "nikolacincovic73",
                        "content": "Easy task, terrible explanation.\\nFor starters, first testcase might be less confusing if printed like this\\n\\nrow 0 || P              A               H               N\\nrow 1 ||     A      P       L      S       I        I       G\\nrow 2 ||         Y               I                R\\n\\nIf you read the letters by rows you will get \"PAHN\"+\"APLSIIG\"+\"YIR\"=\"PAHNAPLSIIGYIR\"\\n\\nBasically you make counter variable to remember what row are you currently in (starting from 0).\\nYou put next character from input string into that row, update counter value so you\\'re in next row and keep doing that until you\\'ve reached the end of input string.\\nKeep in mind that each time you get to the first or last row you switch direction of moving.\\nJoin all rows and you get the solution.\\n"
                    },
                    {
                        "username": "satendra_04",
                        "content": " buthie bdfjbuekb  jefiuhneui jbdufhiogvhe badiufhioser bfirehfiehriof ifrherhg ufoeir ieruhgoier and convert it into zigzag fashion"
                    },
                    {
                        "username": "sapercq",
                        "content": "Java solution 2ms (faster than 99.9)\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/3978572/faster-then-99-89-solution-43-78memory-loop-java/"
                    },
                    {
                        "username": "udayleetco",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        int x=s.length();\\n        char arr[][]=new char[numRows][x];\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                arr[i][j]=\\'@\\';\\n            }\\n        }int k=0;\\n        int l=0;\\n        while(k<x){\\n        char t=s.charAt(k);\\n         for(int i=0;i<n-1;i++){\\n             arr[k][l]=t;\\n             k++;\\n         }\\n         l++;\\n         for(int j=n-2;j>1;j--){\\n          \\n             arr[k][l]=t;\\n                k--;\\n         }\\n        }\\n        String st=\"\";\\n     for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                if (arr[i][j] !=\\'@\\'){\\n                  st+=arr[i][j];\\n                }\\n            }\\n        }\\n        return st;\\n        }\\n    }\\nwhats the error ?"
                    }
                ]
            },
            {
                "id": 2057171,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nOnce the code is accepted, the previous wrong submissions code reflects the correct code but not the wrong one. This is not useful if we want to look at the wrong code and debug it at later point of time.\\n\\nCould you please correct this?\\n\\nthanks."
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "Here goes solution without 2D array\n\nclass Solution {\n    public String convert(String s, int numRows) {\n        if(numRows == 1) return s;\n        String[] strArr = s.split(\"\");\n        String ans = \"\";\n        for(int i = 0; i < numRows; i++) {\n            int j = i;\n            while(j < strArr.length) {\n                ans += strArr[j];\n                if(!(i == j || i == 0 || i == numRows - 1)) {\n                    j = j + 2 * i;\n                    if(j < strArr.length) {\n                        ans += strArr[j];\n                    }\n                }\n                if(i < numRows - 1)\n                    j = j + 2*(numRows - i - 1);\n                else\n                    j = j + 2*(numRows - 1);\n            }\n            // System.out.println(ans);\n        }\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "can anyone explain me, what is wrong here?\n\nvar convert = function(s, numRows) {\n    console.log(s)\n    var arr=new Array(numRows).fill([]);\n    console.log(arr,arr[0])\n    var pos=0;\n    for(var i=0;i<s.length;i++)\n    {\n        arr[pos].push(s[i]);\n        pos=pos+1;\n        if(pos==numRows)\n        {\n            pos=0;\n        }\n    }\n    console.log(arr)\n};"
                    },
                    {
                        "username": "Cydraech",
                        "content": "I really like the problem, but sadly the wording is very unlucky. An easier explanation of the zig zag pattern would make this problem much better. A visual representation of it would\\'ve gone a long way."
                    },
                    {
                        "username": "harikrishna8121999",
                        "content": "\\nHint 1:\\nTo grasp the significance of the positions of elements in the output, it\\'s essential to recognize their relationship with the numRows parameter. Consider the following example:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\n\\nIn this case, let\\'s examine the difference between the first element \\'P\\' and the next element \\'I\\' in the output, which is 6. This difference corresponds to 2 times (numRows - 1), where (numRows - 1) equals 2*(4-1).\\n\\nHint 2:\\nThe calculation of the difference in positions changes when there are diagonal elements in the matrix. For instance:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\nExplanation:\\n\\n```\\nP     I    N\\nA   L S  I G\\nY A   H R\\nP     I\\n```\\n\\nIn the first and last rows, where there are no diagonal elements, the difference between element positions remains 2 times (numRows - 1). However, in the other rows, where diagonal elements are present, a different logic should be applied to calculate the diagonal difference."
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "hey guys , the zigzag thing works like this\\n\\nstring: \"PAYPALISHIRING\"\\nstart mapping the characters from top to bottom in a column. \\nfirst column:\\nP\\nA\\nY\\n\\nnow move upwards in a zigzag manner and when you reach the first row, start moving top to bottom again, and repeat until characters end.\\n1):\\nP\\nA P (move zigzag)\\nY\\n\\n2):\\nP      A\\nA  P  L   I\\nY       I\\n"
                    },
                    {
                        "username": "nikolacincovic73",
                        "content": "Easy task, terrible explanation.\\nFor starters, first testcase might be less confusing if printed like this\\n\\nrow 0 || P              A               H               N\\nrow 1 ||     A      P       L      S       I        I       G\\nrow 2 ||         Y               I                R\\n\\nIf you read the letters by rows you will get \"PAHN\"+\"APLSIIG\"+\"YIR\"=\"PAHNAPLSIIGYIR\"\\n\\nBasically you make counter variable to remember what row are you currently in (starting from 0).\\nYou put next character from input string into that row, update counter value so you\\'re in next row and keep doing that until you\\'ve reached the end of input string.\\nKeep in mind that each time you get to the first or last row you switch direction of moving.\\nJoin all rows and you get the solution.\\n"
                    },
                    {
                        "username": "satendra_04",
                        "content": " buthie bdfjbuekb  jefiuhneui jbdufhiogvhe badiufhioser bfirehfiehriof ifrherhg ufoeir ieruhgoier and convert it into zigzag fashion"
                    },
                    {
                        "username": "sapercq",
                        "content": "Java solution 2ms (faster than 99.9)\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/3978572/faster-then-99-89-solution-43-78memory-loop-java/"
                    },
                    {
                        "username": "udayleetco",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        int x=s.length();\\n        char arr[][]=new char[numRows][x];\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                arr[i][j]=\\'@\\';\\n            }\\n        }int k=0;\\n        int l=0;\\n        while(k<x){\\n        char t=s.charAt(k);\\n         for(int i=0;i<n-1;i++){\\n             arr[k][l]=t;\\n             k++;\\n         }\\n         l++;\\n         for(int j=n-2;j>1;j--){\\n          \\n             arr[k][l]=t;\\n                k--;\\n         }\\n        }\\n        String st=\"\";\\n     for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                if (arr[i][j] !=\\'@\\'){\\n                  st+=arr[i][j];\\n                }\\n            }\\n        }\\n        return st;\\n        }\\n    }\\nwhats the error ?"
                    }
                ]
            },
            {
                "id": 2050816,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nOnce the code is accepted, the previous wrong submissions code reflects the correct code but not the wrong one. This is not useful if we want to look at the wrong code and debug it at later point of time.\\n\\nCould you please correct this?\\n\\nthanks."
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "Here goes solution without 2D array\n\nclass Solution {\n    public String convert(String s, int numRows) {\n        if(numRows == 1) return s;\n        String[] strArr = s.split(\"\");\n        String ans = \"\";\n        for(int i = 0; i < numRows; i++) {\n            int j = i;\n            while(j < strArr.length) {\n                ans += strArr[j];\n                if(!(i == j || i == 0 || i == numRows - 1)) {\n                    j = j + 2 * i;\n                    if(j < strArr.length) {\n                        ans += strArr[j];\n                    }\n                }\n                if(i < numRows - 1)\n                    j = j + 2*(numRows - i - 1);\n                else\n                    j = j + 2*(numRows - 1);\n            }\n            // System.out.println(ans);\n        }\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "can anyone explain me, what is wrong here?\n\nvar convert = function(s, numRows) {\n    console.log(s)\n    var arr=new Array(numRows).fill([]);\n    console.log(arr,arr[0])\n    var pos=0;\n    for(var i=0;i<s.length;i++)\n    {\n        arr[pos].push(s[i]);\n        pos=pos+1;\n        if(pos==numRows)\n        {\n            pos=0;\n        }\n    }\n    console.log(arr)\n};"
                    },
                    {
                        "username": "Cydraech",
                        "content": "I really like the problem, but sadly the wording is very unlucky. An easier explanation of the zig zag pattern would make this problem much better. A visual representation of it would\\'ve gone a long way."
                    },
                    {
                        "username": "harikrishna8121999",
                        "content": "\\nHint 1:\\nTo grasp the significance of the positions of elements in the output, it\\'s essential to recognize their relationship with the numRows parameter. Consider the following example:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\n\\nIn this case, let\\'s examine the difference between the first element \\'P\\' and the next element \\'I\\' in the output, which is 6. This difference corresponds to 2 times (numRows - 1), where (numRows - 1) equals 2*(4-1).\\n\\nHint 2:\\nThe calculation of the difference in positions changes when there are diagonal elements in the matrix. For instance:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\nExplanation:\\n\\n```\\nP     I    N\\nA   L S  I G\\nY A   H R\\nP     I\\n```\\n\\nIn the first and last rows, where there are no diagonal elements, the difference between element positions remains 2 times (numRows - 1). However, in the other rows, where diagonal elements are present, a different logic should be applied to calculate the diagonal difference."
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "hey guys , the zigzag thing works like this\\n\\nstring: \"PAYPALISHIRING\"\\nstart mapping the characters from top to bottom in a column. \\nfirst column:\\nP\\nA\\nY\\n\\nnow move upwards in a zigzag manner and when you reach the first row, start moving top to bottom again, and repeat until characters end.\\n1):\\nP\\nA P (move zigzag)\\nY\\n\\n2):\\nP      A\\nA  P  L   I\\nY       I\\n"
                    },
                    {
                        "username": "nikolacincovic73",
                        "content": "Easy task, terrible explanation.\\nFor starters, first testcase might be less confusing if printed like this\\n\\nrow 0 || P              A               H               N\\nrow 1 ||     A      P       L      S       I        I       G\\nrow 2 ||         Y               I                R\\n\\nIf you read the letters by rows you will get \"PAHN\"+\"APLSIIG\"+\"YIR\"=\"PAHNAPLSIIGYIR\"\\n\\nBasically you make counter variable to remember what row are you currently in (starting from 0).\\nYou put next character from input string into that row, update counter value so you\\'re in next row and keep doing that until you\\'ve reached the end of input string.\\nKeep in mind that each time you get to the first or last row you switch direction of moving.\\nJoin all rows and you get the solution.\\n"
                    },
                    {
                        "username": "satendra_04",
                        "content": " buthie bdfjbuekb  jefiuhneui jbdufhiogvhe badiufhioser bfirehfiehriof ifrherhg ufoeir ieruhgoier and convert it into zigzag fashion"
                    },
                    {
                        "username": "sapercq",
                        "content": "Java solution 2ms (faster than 99.9)\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/3978572/faster-then-99-89-solution-43-78memory-loop-java/"
                    },
                    {
                        "username": "udayleetco",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        int x=s.length();\\n        char arr[][]=new char[numRows][x];\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                arr[i][j]=\\'@\\';\\n            }\\n        }int k=0;\\n        int l=0;\\n        while(k<x){\\n        char t=s.charAt(k);\\n         for(int i=0;i<n-1;i++){\\n             arr[k][l]=t;\\n             k++;\\n         }\\n         l++;\\n         for(int j=n-2;j>1;j--){\\n          \\n             arr[k][l]=t;\\n                k--;\\n         }\\n        }\\n        String st=\"\";\\n     for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                if (arr[i][j] !=\\'@\\'){\\n                  st+=arr[i][j];\\n                }\\n            }\\n        }\\n        return st;\\n        }\\n    }\\nwhats the error ?"
                    }
                ]
            },
            {
                "id": 2050704,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nOnce the code is accepted, the previous wrong submissions code reflects the correct code but not the wrong one. This is not useful if we want to look at the wrong code and debug it at later point of time.\\n\\nCould you please correct this?\\n\\nthanks."
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "Here goes solution without 2D array\n\nclass Solution {\n    public String convert(String s, int numRows) {\n        if(numRows == 1) return s;\n        String[] strArr = s.split(\"\");\n        String ans = \"\";\n        for(int i = 0; i < numRows; i++) {\n            int j = i;\n            while(j < strArr.length) {\n                ans += strArr[j];\n                if(!(i == j || i == 0 || i == numRows - 1)) {\n                    j = j + 2 * i;\n                    if(j < strArr.length) {\n                        ans += strArr[j];\n                    }\n                }\n                if(i < numRows - 1)\n                    j = j + 2*(numRows - i - 1);\n                else\n                    j = j + 2*(numRows - 1);\n            }\n            // System.out.println(ans);\n        }\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "can anyone explain me, what is wrong here?\n\nvar convert = function(s, numRows) {\n    console.log(s)\n    var arr=new Array(numRows).fill([]);\n    console.log(arr,arr[0])\n    var pos=0;\n    for(var i=0;i<s.length;i++)\n    {\n        arr[pos].push(s[i]);\n        pos=pos+1;\n        if(pos==numRows)\n        {\n            pos=0;\n        }\n    }\n    console.log(arr)\n};"
                    },
                    {
                        "username": "Cydraech",
                        "content": "I really like the problem, but sadly the wording is very unlucky. An easier explanation of the zig zag pattern would make this problem much better. A visual representation of it would\\'ve gone a long way."
                    },
                    {
                        "username": "harikrishna8121999",
                        "content": "\\nHint 1:\\nTo grasp the significance of the positions of elements in the output, it\\'s essential to recognize their relationship with the numRows parameter. Consider the following example:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\n\\nIn this case, let\\'s examine the difference between the first element \\'P\\' and the next element \\'I\\' in the output, which is 6. This difference corresponds to 2 times (numRows - 1), where (numRows - 1) equals 2*(4-1).\\n\\nHint 2:\\nThe calculation of the difference in positions changes when there are diagonal elements in the matrix. For instance:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\nExplanation:\\n\\n```\\nP     I    N\\nA   L S  I G\\nY A   H R\\nP     I\\n```\\n\\nIn the first and last rows, where there are no diagonal elements, the difference between element positions remains 2 times (numRows - 1). However, in the other rows, where diagonal elements are present, a different logic should be applied to calculate the diagonal difference."
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "hey guys , the zigzag thing works like this\\n\\nstring: \"PAYPALISHIRING\"\\nstart mapping the characters from top to bottom in a column. \\nfirst column:\\nP\\nA\\nY\\n\\nnow move upwards in a zigzag manner and when you reach the first row, start moving top to bottom again, and repeat until characters end.\\n1):\\nP\\nA P (move zigzag)\\nY\\n\\n2):\\nP      A\\nA  P  L   I\\nY       I\\n"
                    },
                    {
                        "username": "nikolacincovic73",
                        "content": "Easy task, terrible explanation.\\nFor starters, first testcase might be less confusing if printed like this\\n\\nrow 0 || P              A               H               N\\nrow 1 ||     A      P       L      S       I        I       G\\nrow 2 ||         Y               I                R\\n\\nIf you read the letters by rows you will get \"PAHN\"+\"APLSIIG\"+\"YIR\"=\"PAHNAPLSIIGYIR\"\\n\\nBasically you make counter variable to remember what row are you currently in (starting from 0).\\nYou put next character from input string into that row, update counter value so you\\'re in next row and keep doing that until you\\'ve reached the end of input string.\\nKeep in mind that each time you get to the first or last row you switch direction of moving.\\nJoin all rows and you get the solution.\\n"
                    },
                    {
                        "username": "satendra_04",
                        "content": " buthie bdfjbuekb  jefiuhneui jbdufhiogvhe badiufhioser bfirehfiehriof ifrherhg ufoeir ieruhgoier and convert it into zigzag fashion"
                    },
                    {
                        "username": "sapercq",
                        "content": "Java solution 2ms (faster than 99.9)\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/3978572/faster-then-99-89-solution-43-78memory-loop-java/"
                    },
                    {
                        "username": "udayleetco",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        int x=s.length();\\n        char arr[][]=new char[numRows][x];\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                arr[i][j]=\\'@\\';\\n            }\\n        }int k=0;\\n        int l=0;\\n        while(k<x){\\n        char t=s.charAt(k);\\n         for(int i=0;i<n-1;i++){\\n             arr[k][l]=t;\\n             k++;\\n         }\\n         l++;\\n         for(int j=n-2;j>1;j--){\\n          \\n             arr[k][l]=t;\\n                k--;\\n         }\\n        }\\n        String st=\"\";\\n     for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                if (arr[i][j] !=\\'@\\'){\\n                  st+=arr[i][j];\\n                }\\n            }\\n        }\\n        return st;\\n        }\\n    }\\nwhats the error ?"
                    }
                ]
            },
            {
                "id": 2047636,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nOnce the code is accepted, the previous wrong submissions code reflects the correct code but not the wrong one. This is not useful if we want to look at the wrong code and debug it at later point of time.\\n\\nCould you please correct this?\\n\\nthanks."
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "Here goes solution without 2D array\n\nclass Solution {\n    public String convert(String s, int numRows) {\n        if(numRows == 1) return s;\n        String[] strArr = s.split(\"\");\n        String ans = \"\";\n        for(int i = 0; i < numRows; i++) {\n            int j = i;\n            while(j < strArr.length) {\n                ans += strArr[j];\n                if(!(i == j || i == 0 || i == numRows - 1)) {\n                    j = j + 2 * i;\n                    if(j < strArr.length) {\n                        ans += strArr[j];\n                    }\n                }\n                if(i < numRows - 1)\n                    j = j + 2*(numRows - i - 1);\n                else\n                    j = j + 2*(numRows - 1);\n            }\n            // System.out.println(ans);\n        }\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "can anyone explain me, what is wrong here?\n\nvar convert = function(s, numRows) {\n    console.log(s)\n    var arr=new Array(numRows).fill([]);\n    console.log(arr,arr[0])\n    var pos=0;\n    for(var i=0;i<s.length;i++)\n    {\n        arr[pos].push(s[i]);\n        pos=pos+1;\n        if(pos==numRows)\n        {\n            pos=0;\n        }\n    }\n    console.log(arr)\n};"
                    },
                    {
                        "username": "Cydraech",
                        "content": "I really like the problem, but sadly the wording is very unlucky. An easier explanation of the zig zag pattern would make this problem much better. A visual representation of it would\\'ve gone a long way."
                    },
                    {
                        "username": "harikrishna8121999",
                        "content": "\\nHint 1:\\nTo grasp the significance of the positions of elements in the output, it\\'s essential to recognize their relationship with the numRows parameter. Consider the following example:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\n\\nIn this case, let\\'s examine the difference between the first element \\'P\\' and the next element \\'I\\' in the output, which is 6. This difference corresponds to 2 times (numRows - 1), where (numRows - 1) equals 2*(4-1).\\n\\nHint 2:\\nThe calculation of the difference in positions changes when there are diagonal elements in the matrix. For instance:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\nExplanation:\\n\\n```\\nP     I    N\\nA   L S  I G\\nY A   H R\\nP     I\\n```\\n\\nIn the first and last rows, where there are no diagonal elements, the difference between element positions remains 2 times (numRows - 1). However, in the other rows, where diagonal elements are present, a different logic should be applied to calculate the diagonal difference."
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "hey guys , the zigzag thing works like this\\n\\nstring: \"PAYPALISHIRING\"\\nstart mapping the characters from top to bottom in a column. \\nfirst column:\\nP\\nA\\nY\\n\\nnow move upwards in a zigzag manner and when you reach the first row, start moving top to bottom again, and repeat until characters end.\\n1):\\nP\\nA P (move zigzag)\\nY\\n\\n2):\\nP      A\\nA  P  L   I\\nY       I\\n"
                    },
                    {
                        "username": "nikolacincovic73",
                        "content": "Easy task, terrible explanation.\\nFor starters, first testcase might be less confusing if printed like this\\n\\nrow 0 || P              A               H               N\\nrow 1 ||     A      P       L      S       I        I       G\\nrow 2 ||         Y               I                R\\n\\nIf you read the letters by rows you will get \"PAHN\"+\"APLSIIG\"+\"YIR\"=\"PAHNAPLSIIGYIR\"\\n\\nBasically you make counter variable to remember what row are you currently in (starting from 0).\\nYou put next character from input string into that row, update counter value so you\\'re in next row and keep doing that until you\\'ve reached the end of input string.\\nKeep in mind that each time you get to the first or last row you switch direction of moving.\\nJoin all rows and you get the solution.\\n"
                    },
                    {
                        "username": "satendra_04",
                        "content": " buthie bdfjbuekb  jefiuhneui jbdufhiogvhe badiufhioser bfirehfiehriof ifrherhg ufoeir ieruhgoier and convert it into zigzag fashion"
                    },
                    {
                        "username": "sapercq",
                        "content": "Java solution 2ms (faster than 99.9)\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/3978572/faster-then-99-89-solution-43-78memory-loop-java/"
                    },
                    {
                        "username": "udayleetco",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        int x=s.length();\\n        char arr[][]=new char[numRows][x];\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                arr[i][j]=\\'@\\';\\n            }\\n        }int k=0;\\n        int l=0;\\n        while(k<x){\\n        char t=s.charAt(k);\\n         for(int i=0;i<n-1;i++){\\n             arr[k][l]=t;\\n             k++;\\n         }\\n         l++;\\n         for(int j=n-2;j>1;j--){\\n          \\n             arr[k][l]=t;\\n                k--;\\n         }\\n        }\\n        String st=\"\";\\n     for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                if (arr[i][j] !=\\'@\\'){\\n                  st+=arr[i][j];\\n                }\\n            }\\n        }\\n        return st;\\n        }\\n    }\\nwhats the error ?"
                    }
                ]
            },
            {
                "id": 2036293,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nOnce the code is accepted, the previous wrong submissions code reflects the correct code but not the wrong one. This is not useful if we want to look at the wrong code and debug it at later point of time.\\n\\nCould you please correct this?\\n\\nthanks."
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "Here goes solution without 2D array\n\nclass Solution {\n    public String convert(String s, int numRows) {\n        if(numRows == 1) return s;\n        String[] strArr = s.split(\"\");\n        String ans = \"\";\n        for(int i = 0; i < numRows; i++) {\n            int j = i;\n            while(j < strArr.length) {\n                ans += strArr[j];\n                if(!(i == j || i == 0 || i == numRows - 1)) {\n                    j = j + 2 * i;\n                    if(j < strArr.length) {\n                        ans += strArr[j];\n                    }\n                }\n                if(i < numRows - 1)\n                    j = j + 2*(numRows - i - 1);\n                else\n                    j = j + 2*(numRows - 1);\n            }\n            // System.out.println(ans);\n        }\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "can anyone explain me, what is wrong here?\n\nvar convert = function(s, numRows) {\n    console.log(s)\n    var arr=new Array(numRows).fill([]);\n    console.log(arr,arr[0])\n    var pos=0;\n    for(var i=0;i<s.length;i++)\n    {\n        arr[pos].push(s[i]);\n        pos=pos+1;\n        if(pos==numRows)\n        {\n            pos=0;\n        }\n    }\n    console.log(arr)\n};"
                    },
                    {
                        "username": "Cydraech",
                        "content": "I really like the problem, but sadly the wording is very unlucky. An easier explanation of the zig zag pattern would make this problem much better. A visual representation of it would\\'ve gone a long way."
                    },
                    {
                        "username": "harikrishna8121999",
                        "content": "\\nHint 1:\\nTo grasp the significance of the positions of elements in the output, it\\'s essential to recognize their relationship with the numRows parameter. Consider the following example:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\n\\nIn this case, let\\'s examine the difference between the first element \\'P\\' and the next element \\'I\\' in the output, which is 6. This difference corresponds to 2 times (numRows - 1), where (numRows - 1) equals 2*(4-1).\\n\\nHint 2:\\nThe calculation of the difference in positions changes when there are diagonal elements in the matrix. For instance:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\nExplanation:\\n\\n```\\nP     I    N\\nA   L S  I G\\nY A   H R\\nP     I\\n```\\n\\nIn the first and last rows, where there are no diagonal elements, the difference between element positions remains 2 times (numRows - 1). However, in the other rows, where diagonal elements are present, a different logic should be applied to calculate the diagonal difference."
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "hey guys , the zigzag thing works like this\\n\\nstring: \"PAYPALISHIRING\"\\nstart mapping the characters from top to bottom in a column. \\nfirst column:\\nP\\nA\\nY\\n\\nnow move upwards in a zigzag manner and when you reach the first row, start moving top to bottom again, and repeat until characters end.\\n1):\\nP\\nA P (move zigzag)\\nY\\n\\n2):\\nP      A\\nA  P  L   I\\nY       I\\n"
                    },
                    {
                        "username": "nikolacincovic73",
                        "content": "Easy task, terrible explanation.\\nFor starters, first testcase might be less confusing if printed like this\\n\\nrow 0 || P              A               H               N\\nrow 1 ||     A      P       L      S       I        I       G\\nrow 2 ||         Y               I                R\\n\\nIf you read the letters by rows you will get \"PAHN\"+\"APLSIIG\"+\"YIR\"=\"PAHNAPLSIIGYIR\"\\n\\nBasically you make counter variable to remember what row are you currently in (starting from 0).\\nYou put next character from input string into that row, update counter value so you\\'re in next row and keep doing that until you\\'ve reached the end of input string.\\nKeep in mind that each time you get to the first or last row you switch direction of moving.\\nJoin all rows and you get the solution.\\n"
                    },
                    {
                        "username": "satendra_04",
                        "content": " buthie bdfjbuekb  jefiuhneui jbdufhiogvhe badiufhioser bfirehfiehriof ifrherhg ufoeir ieruhgoier and convert it into zigzag fashion"
                    },
                    {
                        "username": "sapercq",
                        "content": "Java solution 2ms (faster than 99.9)\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/3978572/faster-then-99-89-solution-43-78memory-loop-java/"
                    },
                    {
                        "username": "udayleetco",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        int x=s.length();\\n        char arr[][]=new char[numRows][x];\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                arr[i][j]=\\'@\\';\\n            }\\n        }int k=0;\\n        int l=0;\\n        while(k<x){\\n        char t=s.charAt(k);\\n         for(int i=0;i<n-1;i++){\\n             arr[k][l]=t;\\n             k++;\\n         }\\n         l++;\\n         for(int j=n-2;j>1;j--){\\n          \\n             arr[k][l]=t;\\n                k--;\\n         }\\n        }\\n        String st=\"\";\\n     for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                if (arr[i][j] !=\\'@\\'){\\n                  st+=arr[i][j];\\n                }\\n            }\\n        }\\n        return st;\\n        }\\n    }\\nwhats the error ?"
                    }
                ]
            },
            {
                "id": 2030972,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nOnce the code is accepted, the previous wrong submissions code reflects the correct code but not the wrong one. This is not useful if we want to look at the wrong code and debug it at later point of time.\\n\\nCould you please correct this?\\n\\nthanks."
                    },
                    {
                        "username": "divyanshu08jan",
                        "content": "Here goes solution without 2D array\n\nclass Solution {\n    public String convert(String s, int numRows) {\n        if(numRows == 1) return s;\n        String[] strArr = s.split(\"\");\n        String ans = \"\";\n        for(int i = 0; i < numRows; i++) {\n            int j = i;\n            while(j < strArr.length) {\n                ans += strArr[j];\n                if(!(i == j || i == 0 || i == numRows - 1)) {\n                    j = j + 2 * i;\n                    if(j < strArr.length) {\n                        ans += strArr[j];\n                    }\n                }\n                if(i < numRows - 1)\n                    j = j + 2*(numRows - i - 1);\n                else\n                    j = j + 2*(numRows - 1);\n            }\n            // System.out.println(ans);\n        }\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "can anyone explain me, what is wrong here?\n\nvar convert = function(s, numRows) {\n    console.log(s)\n    var arr=new Array(numRows).fill([]);\n    console.log(arr,arr[0])\n    var pos=0;\n    for(var i=0;i<s.length;i++)\n    {\n        arr[pos].push(s[i]);\n        pos=pos+1;\n        if(pos==numRows)\n        {\n            pos=0;\n        }\n    }\n    console.log(arr)\n};"
                    },
                    {
                        "username": "Cydraech",
                        "content": "I really like the problem, but sadly the wording is very unlucky. An easier explanation of the zig zag pattern would make this problem much better. A visual representation of it would\\'ve gone a long way."
                    },
                    {
                        "username": "harikrishna8121999",
                        "content": "\\nHint 1:\\nTo grasp the significance of the positions of elements in the output, it\\'s essential to recognize their relationship with the numRows parameter. Consider the following example:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\n\\nIn this case, let\\'s examine the difference between the first element \\'P\\' and the next element \\'I\\' in the output, which is 6. This difference corresponds to 2 times (numRows - 1), where (numRows - 1) equals 2*(4-1).\\n\\nHint 2:\\nThe calculation of the difference in positions changes when there are diagonal elements in the matrix. For instance:\\n\\nInput: s = \"PAYPALISHIRING\", numRows = 4\\nOutput: \"PINALSIGYAHRPI\"\\nExplanation:\\n\\n```\\nP     I    N\\nA   L S  I G\\nY A   H R\\nP     I\\n```\\n\\nIn the first and last rows, where there are no diagonal elements, the difference between element positions remains 2 times (numRows - 1). However, in the other rows, where diagonal elements are present, a different logic should be applied to calculate the diagonal difference."
                    },
                    {
                        "username": "Haseeeb1",
                        "content": "hey guys , the zigzag thing works like this\\n\\nstring: \"PAYPALISHIRING\"\\nstart mapping the characters from top to bottom in a column. \\nfirst column:\\nP\\nA\\nY\\n\\nnow move upwards in a zigzag manner and when you reach the first row, start moving top to bottom again, and repeat until characters end.\\n1):\\nP\\nA P (move zigzag)\\nY\\n\\n2):\\nP      A\\nA  P  L   I\\nY       I\\n"
                    },
                    {
                        "username": "nikolacincovic73",
                        "content": "Easy task, terrible explanation.\\nFor starters, first testcase might be less confusing if printed like this\\n\\nrow 0 || P              A               H               N\\nrow 1 ||     A      P       L      S       I        I       G\\nrow 2 ||         Y               I                R\\n\\nIf you read the letters by rows you will get \"PAHN\"+\"APLSIIG\"+\"YIR\"=\"PAHNAPLSIIGYIR\"\\n\\nBasically you make counter variable to remember what row are you currently in (starting from 0).\\nYou put next character from input string into that row, update counter value so you\\'re in next row and keep doing that until you\\'ve reached the end of input string.\\nKeep in mind that each time you get to the first or last row you switch direction of moving.\\nJoin all rows and you get the solution.\\n"
                    },
                    {
                        "username": "satendra_04",
                        "content": " buthie bdfjbuekb  jefiuhneui jbdufhiogvhe badiufhioser bfirehfiehriof ifrherhg ufoeir ieruhgoier and convert it into zigzag fashion"
                    },
                    {
                        "username": "sapercq",
                        "content": "Java solution 2ms (faster than 99.9)\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/3978572/faster-then-99-89-solution-43-78memory-loop-java/"
                    },
                    {
                        "username": "udayleetco",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        int x=s.length();\\n        char arr[][]=new char[numRows][x];\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                arr[i][j]=\\'@\\';\\n            }\\n        }int k=0;\\n        int l=0;\\n        while(k<x){\\n        char t=s.charAt(k);\\n         for(int i=0;i<n-1;i++){\\n             arr[k][l]=t;\\n             k++;\\n         }\\n         l++;\\n         for(int j=n-2;j>1;j--){\\n          \\n             arr[k][l]=t;\\n                k--;\\n         }\\n        }\\n        String st=\"\";\\n     for(int i=0;i<n;i++){\\n            for(int j=0;j<x;j++){\\n                if (arr[i][j] !=\\'@\\'){\\n                  st+=arr[i][j];\\n                }\\n            }\\n        }\\n        return st;\\n        }\\n    }\\nwhats the error ?"
                    }
                ]
            },
            {
                "id": 2030461,
                "content": [
                    {
                        "username": "jordan222",
                        "content": "This was a great first problem to get back into LeetCode."
                    },
                    {
                        "username": "Klinag",
                        "content": "On leetCode shows that I have an unknown simbol in my answer, when i test it on my IDE answers mathes. Help please\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I feel that it\\'s a pretty good problem once you understand what\\'s being asked"
                    },
                    {
                        "username": "jaydeepsolanki4567",
                        "content": " char * convert(char * s, int numRows)\\n{\\n    char *str=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0;\\n    for (int i=0; i<numRows; i++)\\n    {\\n        for(int j=i;j<strlen(s); j++)\\n        {\\n            if((j+i)%((numRows-1)*2)==0 || (j-i)%((numRows-1)*2)==0)\\n            {\\n            str[k++]=s[j];\\n            }\\n        }\\n    }\\n    return str;\\n}\\n\\nwhy my solution is throwing an error: \"heap-buffer-overflow\" ? while it\\'s working perfectly fine on VScode."
                    },
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level tbh "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "piotr-ginal",
                        "content": "can someone please tell me why this problem has so many dislikes?"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n\\n    int solve(string s,int row) {\\n        if(row==1) {\\n            return s.size();\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        while(index<n) {\\n            index++;\\n            i++;\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        return j+1;\\n    }\\n\\n    string convert(string s, int row) {\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        vector<vector<char>>v(row,vector<char>(solve(s,row),\\'0\\'));\\n        if(row==1) {\\n            return s;\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        v[0][0]=s[0];\\n        while(index<n) {\\n            index++;\\n            i++;\\n            v[i][j]=s[index];\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    v[i][j]=s[index];\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        string ans=\"\";\\n        for(auto i:v) {\\n            for(auto j:i) {\\n                if(j!=\\'0\\') {\\n                    ans.push_back(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t post solutions in discussion. that\\'s what the solution tab is for"
                    },
                    {
                        "username": "shlok4112000",
                        "content": "If you are trying to print this zigzag pattern then saving the string in a 2D array in the given format is a viable solution. So for that:\\nMaximum number of columns required will always  = int ( ( len(s) + 1) / 2)"
                    },
                    {
                        "username": "cp_wallah",
                        "content": "one of the worst wording and explanantion of  a question"
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "yeah it doesn\\'t really tell you that there are no zigs, only zags, so you have to read it vertically then diagonally, not diagonally all the way through"
                    },
                    {
                        "username": "tonynin1",
                        "content": "Spend a whole day to solve this problem, but then i realize it\\'s not an usual problem :) 100% depend on your creativity"
                    }
                ]
            },
            {
                "id": 2029642,
                "content": [
                    {
                        "username": "jordan222",
                        "content": "This was a great first problem to get back into LeetCode."
                    },
                    {
                        "username": "Klinag",
                        "content": "On leetCode shows that I have an unknown simbol in my answer, when i test it on my IDE answers mathes. Help please\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I feel that it\\'s a pretty good problem once you understand what\\'s being asked"
                    },
                    {
                        "username": "jaydeepsolanki4567",
                        "content": " char * convert(char * s, int numRows)\\n{\\n    char *str=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0;\\n    for (int i=0; i<numRows; i++)\\n    {\\n        for(int j=i;j<strlen(s); j++)\\n        {\\n            if((j+i)%((numRows-1)*2)==0 || (j-i)%((numRows-1)*2)==0)\\n            {\\n            str[k++]=s[j];\\n            }\\n        }\\n    }\\n    return str;\\n}\\n\\nwhy my solution is throwing an error: \"heap-buffer-overflow\" ? while it\\'s working perfectly fine on VScode."
                    },
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level tbh "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "piotr-ginal",
                        "content": "can someone please tell me why this problem has so many dislikes?"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n\\n    int solve(string s,int row) {\\n        if(row==1) {\\n            return s.size();\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        while(index<n) {\\n            index++;\\n            i++;\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        return j+1;\\n    }\\n\\n    string convert(string s, int row) {\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        vector<vector<char>>v(row,vector<char>(solve(s,row),\\'0\\'));\\n        if(row==1) {\\n            return s;\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        v[0][0]=s[0];\\n        while(index<n) {\\n            index++;\\n            i++;\\n            v[i][j]=s[index];\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    v[i][j]=s[index];\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        string ans=\"\";\\n        for(auto i:v) {\\n            for(auto j:i) {\\n                if(j!=\\'0\\') {\\n                    ans.push_back(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t post solutions in discussion. that\\'s what the solution tab is for"
                    },
                    {
                        "username": "shlok4112000",
                        "content": "If you are trying to print this zigzag pattern then saving the string in a 2D array in the given format is a viable solution. So for that:\\nMaximum number of columns required will always  = int ( ( len(s) + 1) / 2)"
                    },
                    {
                        "username": "cp_wallah",
                        "content": "one of the worst wording and explanantion of  a question"
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "yeah it doesn\\'t really tell you that there are no zigs, only zags, so you have to read it vertically then diagonally, not diagonally all the way through"
                    },
                    {
                        "username": "tonynin1",
                        "content": "Spend a whole day to solve this problem, but then i realize it\\'s not an usual problem :) 100% depend on your creativity"
                    }
                ]
            },
            {
                "id": 2027882,
                "content": [
                    {
                        "username": "jordan222",
                        "content": "This was a great first problem to get back into LeetCode."
                    },
                    {
                        "username": "Klinag",
                        "content": "On leetCode shows that I have an unknown simbol in my answer, when i test it on my IDE answers mathes. Help please\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I feel that it\\'s a pretty good problem once you understand what\\'s being asked"
                    },
                    {
                        "username": "jaydeepsolanki4567",
                        "content": " char * convert(char * s, int numRows)\\n{\\n    char *str=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0;\\n    for (int i=0; i<numRows; i++)\\n    {\\n        for(int j=i;j<strlen(s); j++)\\n        {\\n            if((j+i)%((numRows-1)*2)==0 || (j-i)%((numRows-1)*2)==0)\\n            {\\n            str[k++]=s[j];\\n            }\\n        }\\n    }\\n    return str;\\n}\\n\\nwhy my solution is throwing an error: \"heap-buffer-overflow\" ? while it\\'s working perfectly fine on VScode."
                    },
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level tbh "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "piotr-ginal",
                        "content": "can someone please tell me why this problem has so many dislikes?"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n\\n    int solve(string s,int row) {\\n        if(row==1) {\\n            return s.size();\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        while(index<n) {\\n            index++;\\n            i++;\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        return j+1;\\n    }\\n\\n    string convert(string s, int row) {\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        vector<vector<char>>v(row,vector<char>(solve(s,row),\\'0\\'));\\n        if(row==1) {\\n            return s;\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        v[0][0]=s[0];\\n        while(index<n) {\\n            index++;\\n            i++;\\n            v[i][j]=s[index];\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    v[i][j]=s[index];\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        string ans=\"\";\\n        for(auto i:v) {\\n            for(auto j:i) {\\n                if(j!=\\'0\\') {\\n                    ans.push_back(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t post solutions in discussion. that\\'s what the solution tab is for"
                    },
                    {
                        "username": "shlok4112000",
                        "content": "If you are trying to print this zigzag pattern then saving the string in a 2D array in the given format is a viable solution. So for that:\\nMaximum number of columns required will always  = int ( ( len(s) + 1) / 2)"
                    },
                    {
                        "username": "cp_wallah",
                        "content": "one of the worst wording and explanantion of  a question"
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "yeah it doesn\\'t really tell you that there are no zigs, only zags, so you have to read it vertically then diagonally, not diagonally all the way through"
                    },
                    {
                        "username": "tonynin1",
                        "content": "Spend a whole day to solve this problem, but then i realize it\\'s not an usual problem :) 100% depend on your creativity"
                    }
                ]
            },
            {
                "id": 2026473,
                "content": [
                    {
                        "username": "jordan222",
                        "content": "This was a great first problem to get back into LeetCode."
                    },
                    {
                        "username": "Klinag",
                        "content": "On leetCode shows that I have an unknown simbol in my answer, when i test it on my IDE answers mathes. Help please\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I feel that it\\'s a pretty good problem once you understand what\\'s being asked"
                    },
                    {
                        "username": "jaydeepsolanki4567",
                        "content": " char * convert(char * s, int numRows)\\n{\\n    char *str=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0;\\n    for (int i=0; i<numRows; i++)\\n    {\\n        for(int j=i;j<strlen(s); j++)\\n        {\\n            if((j+i)%((numRows-1)*2)==0 || (j-i)%((numRows-1)*2)==0)\\n            {\\n            str[k++]=s[j];\\n            }\\n        }\\n    }\\n    return str;\\n}\\n\\nwhy my solution is throwing an error: \"heap-buffer-overflow\" ? while it\\'s working perfectly fine on VScode."
                    },
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level tbh "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "piotr-ginal",
                        "content": "can someone please tell me why this problem has so many dislikes?"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n\\n    int solve(string s,int row) {\\n        if(row==1) {\\n            return s.size();\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        while(index<n) {\\n            index++;\\n            i++;\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        return j+1;\\n    }\\n\\n    string convert(string s, int row) {\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        vector<vector<char>>v(row,vector<char>(solve(s,row),\\'0\\'));\\n        if(row==1) {\\n            return s;\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        v[0][0]=s[0];\\n        while(index<n) {\\n            index++;\\n            i++;\\n            v[i][j]=s[index];\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    v[i][j]=s[index];\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        string ans=\"\";\\n        for(auto i:v) {\\n            for(auto j:i) {\\n                if(j!=\\'0\\') {\\n                    ans.push_back(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t post solutions in discussion. that\\'s what the solution tab is for"
                    },
                    {
                        "username": "shlok4112000",
                        "content": "If you are trying to print this zigzag pattern then saving the string in a 2D array in the given format is a viable solution. So for that:\\nMaximum number of columns required will always  = int ( ( len(s) + 1) / 2)"
                    },
                    {
                        "username": "cp_wallah",
                        "content": "one of the worst wording and explanantion of  a question"
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "yeah it doesn\\'t really tell you that there are no zigs, only zags, so you have to read it vertically then diagonally, not diagonally all the way through"
                    },
                    {
                        "username": "tonynin1",
                        "content": "Spend a whole day to solve this problem, but then i realize it\\'s not an usual problem :) 100% depend on your creativity"
                    }
                ]
            },
            {
                "id": 2024321,
                "content": [
                    {
                        "username": "jordan222",
                        "content": "This was a great first problem to get back into LeetCode."
                    },
                    {
                        "username": "Klinag",
                        "content": "On leetCode shows that I have an unknown simbol in my answer, when i test it on my IDE answers mathes. Help please\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I feel that it\\'s a pretty good problem once you understand what\\'s being asked"
                    },
                    {
                        "username": "jaydeepsolanki4567",
                        "content": " char * convert(char * s, int numRows)\\n{\\n    char *str=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0;\\n    for (int i=0; i<numRows; i++)\\n    {\\n        for(int j=i;j<strlen(s); j++)\\n        {\\n            if((j+i)%((numRows-1)*2)==0 || (j-i)%((numRows-1)*2)==0)\\n            {\\n            str[k++]=s[j];\\n            }\\n        }\\n    }\\n    return str;\\n}\\n\\nwhy my solution is throwing an error: \"heap-buffer-overflow\" ? while it\\'s working perfectly fine on VScode."
                    },
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level tbh "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "piotr-ginal",
                        "content": "can someone please tell me why this problem has so many dislikes?"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n\\n    int solve(string s,int row) {\\n        if(row==1) {\\n            return s.size();\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        while(index<n) {\\n            index++;\\n            i++;\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        return j+1;\\n    }\\n\\n    string convert(string s, int row) {\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        vector<vector<char>>v(row,vector<char>(solve(s,row),\\'0\\'));\\n        if(row==1) {\\n            return s;\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        v[0][0]=s[0];\\n        while(index<n) {\\n            index++;\\n            i++;\\n            v[i][j]=s[index];\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    v[i][j]=s[index];\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        string ans=\"\";\\n        for(auto i:v) {\\n            for(auto j:i) {\\n                if(j!=\\'0\\') {\\n                    ans.push_back(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t post solutions in discussion. that\\'s what the solution tab is for"
                    },
                    {
                        "username": "shlok4112000",
                        "content": "If you are trying to print this zigzag pattern then saving the string in a 2D array in the given format is a viable solution. So for that:\\nMaximum number of columns required will always  = int ( ( len(s) + 1) / 2)"
                    },
                    {
                        "username": "cp_wallah",
                        "content": "one of the worst wording and explanantion of  a question"
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "yeah it doesn\\'t really tell you that there are no zigs, only zags, so you have to read it vertically then diagonally, not diagonally all the way through"
                    },
                    {
                        "username": "tonynin1",
                        "content": "Spend a whole day to solve this problem, but then i realize it\\'s not an usual problem :) 100% depend on your creativity"
                    }
                ]
            },
            {
                "id": 2020721,
                "content": [
                    {
                        "username": "jordan222",
                        "content": "This was a great first problem to get back into LeetCode."
                    },
                    {
                        "username": "Klinag",
                        "content": "On leetCode shows that I have an unknown simbol in my answer, when i test it on my IDE answers mathes. Help please\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I feel that it\\'s a pretty good problem once you understand what\\'s being asked"
                    },
                    {
                        "username": "jaydeepsolanki4567",
                        "content": " char * convert(char * s, int numRows)\\n{\\n    char *str=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0;\\n    for (int i=0; i<numRows; i++)\\n    {\\n        for(int j=i;j<strlen(s); j++)\\n        {\\n            if((j+i)%((numRows-1)*2)==0 || (j-i)%((numRows-1)*2)==0)\\n            {\\n            str[k++]=s[j];\\n            }\\n        }\\n    }\\n    return str;\\n}\\n\\nwhy my solution is throwing an error: \"heap-buffer-overflow\" ? while it\\'s working perfectly fine on VScode."
                    },
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level tbh "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "piotr-ginal",
                        "content": "can someone please tell me why this problem has so many dislikes?"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n\\n    int solve(string s,int row) {\\n        if(row==1) {\\n            return s.size();\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        while(index<n) {\\n            index++;\\n            i++;\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        return j+1;\\n    }\\n\\n    string convert(string s, int row) {\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        vector<vector<char>>v(row,vector<char>(solve(s,row),\\'0\\'));\\n        if(row==1) {\\n            return s;\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        v[0][0]=s[0];\\n        while(index<n) {\\n            index++;\\n            i++;\\n            v[i][j]=s[index];\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    v[i][j]=s[index];\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        string ans=\"\";\\n        for(auto i:v) {\\n            for(auto j:i) {\\n                if(j!=\\'0\\') {\\n                    ans.push_back(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t post solutions in discussion. that\\'s what the solution tab is for"
                    },
                    {
                        "username": "shlok4112000",
                        "content": "If you are trying to print this zigzag pattern then saving the string in a 2D array in the given format is a viable solution. So for that:\\nMaximum number of columns required will always  = int ( ( len(s) + 1) / 2)"
                    },
                    {
                        "username": "cp_wallah",
                        "content": "one of the worst wording and explanantion of  a question"
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "yeah it doesn\\'t really tell you that there are no zigs, only zags, so you have to read it vertically then diagonally, not diagonally all the way through"
                    },
                    {
                        "username": "tonynin1",
                        "content": "Spend a whole day to solve this problem, but then i realize it\\'s not an usual problem :) 100% depend on your creativity"
                    }
                ]
            },
            {
                "id": 2019735,
                "content": [
                    {
                        "username": "jordan222",
                        "content": "This was a great first problem to get back into LeetCode."
                    },
                    {
                        "username": "Klinag",
                        "content": "On leetCode shows that I have an unknown simbol in my answer, when i test it on my IDE answers mathes. Help please\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I feel that it\\'s a pretty good problem once you understand what\\'s being asked"
                    },
                    {
                        "username": "jaydeepsolanki4567",
                        "content": " char * convert(char * s, int numRows)\\n{\\n    char *str=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0;\\n    for (int i=0; i<numRows; i++)\\n    {\\n        for(int j=i;j<strlen(s); j++)\\n        {\\n            if((j+i)%((numRows-1)*2)==0 || (j-i)%((numRows-1)*2)==0)\\n            {\\n            str[k++]=s[j];\\n            }\\n        }\\n    }\\n    return str;\\n}\\n\\nwhy my solution is throwing an error: \"heap-buffer-overflow\" ? while it\\'s working perfectly fine on VScode."
                    },
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level tbh "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "piotr-ginal",
                        "content": "can someone please tell me why this problem has so many dislikes?"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n\\n    int solve(string s,int row) {\\n        if(row==1) {\\n            return s.size();\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        while(index<n) {\\n            index++;\\n            i++;\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        return j+1;\\n    }\\n\\n    string convert(string s, int row) {\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        vector<vector<char>>v(row,vector<char>(solve(s,row),\\'0\\'));\\n        if(row==1) {\\n            return s;\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        v[0][0]=s[0];\\n        while(index<n) {\\n            index++;\\n            i++;\\n            v[i][j]=s[index];\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    v[i][j]=s[index];\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        string ans=\"\";\\n        for(auto i:v) {\\n            for(auto j:i) {\\n                if(j!=\\'0\\') {\\n                    ans.push_back(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t post solutions in discussion. that\\'s what the solution tab is for"
                    },
                    {
                        "username": "shlok4112000",
                        "content": "If you are trying to print this zigzag pattern then saving the string in a 2D array in the given format is a viable solution. So for that:\\nMaximum number of columns required will always  = int ( ( len(s) + 1) / 2)"
                    },
                    {
                        "username": "cp_wallah",
                        "content": "one of the worst wording and explanantion of  a question"
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "yeah it doesn\\'t really tell you that there are no zigs, only zags, so you have to read it vertically then diagonally, not diagonally all the way through"
                    },
                    {
                        "username": "tonynin1",
                        "content": "Spend a whole day to solve this problem, but then i realize it\\'s not an usual problem :) 100% depend on your creativity"
                    }
                ]
            },
            {
                "id": 2009569,
                "content": [
                    {
                        "username": "jordan222",
                        "content": "This was a great first problem to get back into LeetCode."
                    },
                    {
                        "username": "Klinag",
                        "content": "On leetCode shows that I have an unknown simbol in my answer, when i test it on my IDE answers mathes. Help please\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I feel that it\\'s a pretty good problem once you understand what\\'s being asked"
                    },
                    {
                        "username": "jaydeepsolanki4567",
                        "content": " char * convert(char * s, int numRows)\\n{\\n    char *str=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0;\\n    for (int i=0; i<numRows; i++)\\n    {\\n        for(int j=i;j<strlen(s); j++)\\n        {\\n            if((j+i)%((numRows-1)*2)==0 || (j-i)%((numRows-1)*2)==0)\\n            {\\n            str[k++]=s[j];\\n            }\\n        }\\n    }\\n    return str;\\n}\\n\\nwhy my solution is throwing an error: \"heap-buffer-overflow\" ? while it\\'s working perfectly fine on VScode."
                    },
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level tbh "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "piotr-ginal",
                        "content": "can someone please tell me why this problem has so many dislikes?"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n\\n    int solve(string s,int row) {\\n        if(row==1) {\\n            return s.size();\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        while(index<n) {\\n            index++;\\n            i++;\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        return j+1;\\n    }\\n\\n    string convert(string s, int row) {\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        vector<vector<char>>v(row,vector<char>(solve(s,row),\\'0\\'));\\n        if(row==1) {\\n            return s;\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        v[0][0]=s[0];\\n        while(index<n) {\\n            index++;\\n            i++;\\n            v[i][j]=s[index];\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    v[i][j]=s[index];\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        string ans=\"\";\\n        for(auto i:v) {\\n            for(auto j:i) {\\n                if(j!=\\'0\\') {\\n                    ans.push_back(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t post solutions in discussion. that\\'s what the solution tab is for"
                    },
                    {
                        "username": "shlok4112000",
                        "content": "If you are trying to print this zigzag pattern then saving the string in a 2D array in the given format is a viable solution. So for that:\\nMaximum number of columns required will always  = int ( ( len(s) + 1) / 2)"
                    },
                    {
                        "username": "cp_wallah",
                        "content": "one of the worst wording and explanantion of  a question"
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "yeah it doesn\\'t really tell you that there are no zigs, only zags, so you have to read it vertically then diagonally, not diagonally all the way through"
                    },
                    {
                        "username": "tonynin1",
                        "content": "Spend a whole day to solve this problem, but then i realize it\\'s not an usual problem :) 100% depend on your creativity"
                    }
                ]
            },
            {
                "id": 2009302,
                "content": [
                    {
                        "username": "jordan222",
                        "content": "This was a great first problem to get back into LeetCode."
                    },
                    {
                        "username": "Klinag",
                        "content": "On leetCode shows that I have an unknown simbol in my answer, when i test it on my IDE answers mathes. Help please\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I feel that it\\'s a pretty good problem once you understand what\\'s being asked"
                    },
                    {
                        "username": "jaydeepsolanki4567",
                        "content": " char * convert(char * s, int numRows)\\n{\\n    char *str=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0;\\n    for (int i=0; i<numRows; i++)\\n    {\\n        for(int j=i;j<strlen(s); j++)\\n        {\\n            if((j+i)%((numRows-1)*2)==0 || (j-i)%((numRows-1)*2)==0)\\n            {\\n            str[k++]=s[j];\\n            }\\n        }\\n    }\\n    return str;\\n}\\n\\nwhy my solution is throwing an error: \"heap-buffer-overflow\" ? while it\\'s working perfectly fine on VScode."
                    },
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level tbh "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "piotr-ginal",
                        "content": "can someone please tell me why this problem has so many dislikes?"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n\\n    int solve(string s,int row) {\\n        if(row==1) {\\n            return s.size();\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        while(index<n) {\\n            index++;\\n            i++;\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        return j+1;\\n    }\\n\\n    string convert(string s, int row) {\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        vector<vector<char>>v(row,vector<char>(solve(s,row),\\'0\\'));\\n        if(row==1) {\\n            return s;\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        v[0][0]=s[0];\\n        while(index<n) {\\n            index++;\\n            i++;\\n            v[i][j]=s[index];\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    v[i][j]=s[index];\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        string ans=\"\";\\n        for(auto i:v) {\\n            for(auto j:i) {\\n                if(j!=\\'0\\') {\\n                    ans.push_back(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t post solutions in discussion. that\\'s what the solution tab is for"
                    },
                    {
                        "username": "shlok4112000",
                        "content": "If you are trying to print this zigzag pattern then saving the string in a 2D array in the given format is a viable solution. So for that:\\nMaximum number of columns required will always  = int ( ( len(s) + 1) / 2)"
                    },
                    {
                        "username": "cp_wallah",
                        "content": "one of the worst wording and explanantion of  a question"
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "yeah it doesn\\'t really tell you that there are no zigs, only zags, so you have to read it vertically then diagonally, not diagonally all the way through"
                    },
                    {
                        "username": "tonynin1",
                        "content": "Spend a whole day to solve this problem, but then i realize it\\'s not an usual problem :) 100% depend on your creativity"
                    }
                ]
            },
            {
                "id": 1999254,
                "content": [
                    {
                        "username": "jordan222",
                        "content": "This was a great first problem to get back into LeetCode."
                    },
                    {
                        "username": "Klinag",
                        "content": "On leetCode shows that I have an unknown simbol in my answer, when i test it on my IDE answers mathes. Help please\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I feel that it\\'s a pretty good problem once you understand what\\'s being asked"
                    },
                    {
                        "username": "jaydeepsolanki4567",
                        "content": " char * convert(char * s, int numRows)\\n{\\n    char *str=(char*)malloc(strlen(s)*sizeof(char));\\n    int k=0;\\n    for (int i=0; i<numRows; i++)\\n    {\\n        for(int j=i;j<strlen(s); j++)\\n        {\\n            if((j+i)%((numRows-1)*2)==0 || (j-i)%((numRows-1)*2)==0)\\n            {\\n            str[k++]=s[j];\\n            }\\n        }\\n    }\\n    return str;\\n}\\n\\nwhy my solution is throwing an error: \"heap-buffer-overflow\" ? while it\\'s working perfectly fine on VScode."
                    },
                    {
                        "username": "weraponpat",
                        "content": "this should be easy level tbh "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "piotr-ginal",
                        "content": "can someone please tell me why this problem has so many dislikes?"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n\\n    int solve(string s,int row) {\\n        if(row==1) {\\n            return s.size();\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        while(index<n) {\\n            index++;\\n            i++;\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        return j+1;\\n    }\\n\\n    string convert(string s, int row) {\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        vector<vector<char>>v(row,vector<char>(solve(s,row),\\'0\\'));\\n        if(row==1) {\\n            return s;\\n        }\\n        int n = s.size();\\n        int i=0;\\n        int j=0;\\n        int index=0;\\n        v[0][0]=s[0];\\n        while(index<n) {\\n            index++;\\n            i++;\\n            v[i][j]=s[index];\\n            if(i==row-1) {\\n                while(i>0 && index<n-1) {\\n                    j++;\\n                    index++;\\n                    i--;\\n                    v[i][j]=s[index];\\n                    if(index==n-1) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if(index==n-1) {\\n                break;\\n            }\\n        }\\n        string ans=\"\";\\n        for(auto i:v) {\\n            for(auto j:i) {\\n                if(j!=\\'0\\') {\\n                    ans.push_back(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t post solutions in discussion. that\\'s what the solution tab is for"
                    },
                    {
                        "username": "shlok4112000",
                        "content": "If you are trying to print this zigzag pattern then saving the string in a 2D array in the given format is a viable solution. So for that:\\nMaximum number of columns required will always  = int ( ( len(s) + 1) / 2)"
                    },
                    {
                        "username": "cp_wallah",
                        "content": "one of the worst wording and explanantion of  a question"
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "yeah it doesn\\'t really tell you that there are no zigs, only zags, so you have to read it vertically then diagonally, not diagonally all the way through"
                    },
                    {
                        "username": "tonynin1",
                        "content": "Spend a whole day to solve this problem, but then i realize it\\'s not an usual problem :) 100% depend on your creativity"
                    }
                ]
            },
            {
                "id": 1997061,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "Actually kinda a cool problem that\\'s just pure string manipulation and coding basics, no strings attached!"
                    },
                    {
                        "username": "tomamais",
                        "content": "please, more examples to make it clear. As per the examples above, the test case \"ABCDE\" should be something like this:\\n\\nA - C - D\\nB -    -  E"
                    },
                    {
                        "username": "ChidiE",
                        "content": "No sure why the complaints tho....just increase and decrease the index of the numRows by 1.\\nso numRows 3 is equivalent to.\\n\\n\\'P A Y P A L I S H I R I N G\\'\\n\\'0 1 2 1 0 1 2 1 0 1 2 1 0 1\\'\\n\\nconcat the 0s 1s 2s"
                    },
                    {
                        "username": "user3974tS",
                        "content": "I really like this question"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        ArrayList<Pair> list=new ArrayList<>();\\n        // boolean flag=true;\\n        int cnt=0,c=0;\\n        while(s.length()>cnt){\\n        for(int i=0;i<numRows;i++){\\n            if(i+c<s.length())\\nlist.add(new Pair(i,s.charAt(i+c)+\"\"));\\n\\ncnt++;\\n        }\\n        for(int j=numRows-2;j>=1;j--){\\n            if(cnt<s.length())\\n            list.add(new Pair(j,s.charAt(cnt)+\"\"));\\n            \\n            cnt++;\\n        }\\n        c=cnt;\\n\\n        }\\n\\n        StringBuilder sb=new StringBuilder(\"\");\\n        int k=0;\\n        while(k<numRows){\\n   for(Pair pair:list){\\n\\nif(pair.getKey()==k){\\nsb.append(pair.getValue());\\n}\\n\\n   }  \\n   k++;   \\n        }\\nreturn sb.toString();\\n    }\\n}\\nclass Pair{\\n     private int key;\\n    private String value;\\n\\n    public Pair(int key, String value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n\\n    public int getKey() {\\n        return key;\\n    }\\n\\n    public String getValue() {\\n        return value;\\n    }\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kapsimus",
                        "content": "Wrong Answer\\n\\nOutput\\n\"PINALSIGYAHRPI\"\\nExpected\\n\"PINALSIGYAHRPI\"\\n\\nWhy?\\n"
                    },
                    {
                        "username": "Krvijay_32",
                        "content": "It is one of the Nice question i have ever encountered.\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "garbage question"
                    },
                    {
                        "username": "jonahbebko",
                        "content": "Finally solved. Hint: lay out `s` up-to-down, like Snake. Reverse every second column."
                    },
                    {
                        "username": "jonahbebko",
                        "content": "me when the problem has zero real-world applications"
                    }
                ]
            },
            {
                "id": 1996675,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "Actually kinda a cool problem that\\'s just pure string manipulation and coding basics, no strings attached!"
                    },
                    {
                        "username": "tomamais",
                        "content": "please, more examples to make it clear. As per the examples above, the test case \"ABCDE\" should be something like this:\\n\\nA - C - D\\nB -    -  E"
                    },
                    {
                        "username": "ChidiE",
                        "content": "No sure why the complaints tho....just increase and decrease the index of the numRows by 1.\\nso numRows 3 is equivalent to.\\n\\n\\'P A Y P A L I S H I R I N G\\'\\n\\'0 1 2 1 0 1 2 1 0 1 2 1 0 1\\'\\n\\nconcat the 0s 1s 2s"
                    },
                    {
                        "username": "user3974tS",
                        "content": "I really like this question"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        ArrayList<Pair> list=new ArrayList<>();\\n        // boolean flag=true;\\n        int cnt=0,c=0;\\n        while(s.length()>cnt){\\n        for(int i=0;i<numRows;i++){\\n            if(i+c<s.length())\\nlist.add(new Pair(i,s.charAt(i+c)+\"\"));\\n\\ncnt++;\\n        }\\n        for(int j=numRows-2;j>=1;j--){\\n            if(cnt<s.length())\\n            list.add(new Pair(j,s.charAt(cnt)+\"\"));\\n            \\n            cnt++;\\n        }\\n        c=cnt;\\n\\n        }\\n\\n        StringBuilder sb=new StringBuilder(\"\");\\n        int k=0;\\n        while(k<numRows){\\n   for(Pair pair:list){\\n\\nif(pair.getKey()==k){\\nsb.append(pair.getValue());\\n}\\n\\n   }  \\n   k++;   \\n        }\\nreturn sb.toString();\\n    }\\n}\\nclass Pair{\\n     private int key;\\n    private String value;\\n\\n    public Pair(int key, String value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n\\n    public int getKey() {\\n        return key;\\n    }\\n\\n    public String getValue() {\\n        return value;\\n    }\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kapsimus",
                        "content": "Wrong Answer\\n\\nOutput\\n\"PINALSIGYAHRPI\"\\nExpected\\n\"PINALSIGYAHRPI\"\\n\\nWhy?\\n"
                    },
                    {
                        "username": "Krvijay_32",
                        "content": "It is one of the Nice question i have ever encountered.\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "garbage question"
                    },
                    {
                        "username": "jonahbebko",
                        "content": "Finally solved. Hint: lay out `s` up-to-down, like Snake. Reverse every second column."
                    },
                    {
                        "username": "jonahbebko",
                        "content": "me when the problem has zero real-world applications"
                    }
                ]
            },
            {
                "id": 1991001,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "Actually kinda a cool problem that\\'s just pure string manipulation and coding basics, no strings attached!"
                    },
                    {
                        "username": "tomamais",
                        "content": "please, more examples to make it clear. As per the examples above, the test case \"ABCDE\" should be something like this:\\n\\nA - C - D\\nB -    -  E"
                    },
                    {
                        "username": "ChidiE",
                        "content": "No sure why the complaints tho....just increase and decrease the index of the numRows by 1.\\nso numRows 3 is equivalent to.\\n\\n\\'P A Y P A L I S H I R I N G\\'\\n\\'0 1 2 1 0 1 2 1 0 1 2 1 0 1\\'\\n\\nconcat the 0s 1s 2s"
                    },
                    {
                        "username": "user3974tS",
                        "content": "I really like this question"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        ArrayList<Pair> list=new ArrayList<>();\\n        // boolean flag=true;\\n        int cnt=0,c=0;\\n        while(s.length()>cnt){\\n        for(int i=0;i<numRows;i++){\\n            if(i+c<s.length())\\nlist.add(new Pair(i,s.charAt(i+c)+\"\"));\\n\\ncnt++;\\n        }\\n        for(int j=numRows-2;j>=1;j--){\\n            if(cnt<s.length())\\n            list.add(new Pair(j,s.charAt(cnt)+\"\"));\\n            \\n            cnt++;\\n        }\\n        c=cnt;\\n\\n        }\\n\\n        StringBuilder sb=new StringBuilder(\"\");\\n        int k=0;\\n        while(k<numRows){\\n   for(Pair pair:list){\\n\\nif(pair.getKey()==k){\\nsb.append(pair.getValue());\\n}\\n\\n   }  \\n   k++;   \\n        }\\nreturn sb.toString();\\n    }\\n}\\nclass Pair{\\n     private int key;\\n    private String value;\\n\\n    public Pair(int key, String value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n\\n    public int getKey() {\\n        return key;\\n    }\\n\\n    public String getValue() {\\n        return value;\\n    }\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kapsimus",
                        "content": "Wrong Answer\\n\\nOutput\\n\"PINALSIGYAHRPI\"\\nExpected\\n\"PINALSIGYAHRPI\"\\n\\nWhy?\\n"
                    },
                    {
                        "username": "Krvijay_32",
                        "content": "It is one of the Nice question i have ever encountered.\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "garbage question"
                    },
                    {
                        "username": "jonahbebko",
                        "content": "Finally solved. Hint: lay out `s` up-to-down, like Snake. Reverse every second column."
                    },
                    {
                        "username": "jonahbebko",
                        "content": "me when the problem has zero real-world applications"
                    }
                ]
            },
            {
                "id": 1976844,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "Actually kinda a cool problem that\\'s just pure string manipulation and coding basics, no strings attached!"
                    },
                    {
                        "username": "tomamais",
                        "content": "please, more examples to make it clear. As per the examples above, the test case \"ABCDE\" should be something like this:\\n\\nA - C - D\\nB -    -  E"
                    },
                    {
                        "username": "ChidiE",
                        "content": "No sure why the complaints tho....just increase and decrease the index of the numRows by 1.\\nso numRows 3 is equivalent to.\\n\\n\\'P A Y P A L I S H I R I N G\\'\\n\\'0 1 2 1 0 1 2 1 0 1 2 1 0 1\\'\\n\\nconcat the 0s 1s 2s"
                    },
                    {
                        "username": "user3974tS",
                        "content": "I really like this question"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        ArrayList<Pair> list=new ArrayList<>();\\n        // boolean flag=true;\\n        int cnt=0,c=0;\\n        while(s.length()>cnt){\\n        for(int i=0;i<numRows;i++){\\n            if(i+c<s.length())\\nlist.add(new Pair(i,s.charAt(i+c)+\"\"));\\n\\ncnt++;\\n        }\\n        for(int j=numRows-2;j>=1;j--){\\n            if(cnt<s.length())\\n            list.add(new Pair(j,s.charAt(cnt)+\"\"));\\n            \\n            cnt++;\\n        }\\n        c=cnt;\\n\\n        }\\n\\n        StringBuilder sb=new StringBuilder(\"\");\\n        int k=0;\\n        while(k<numRows){\\n   for(Pair pair:list){\\n\\nif(pair.getKey()==k){\\nsb.append(pair.getValue());\\n}\\n\\n   }  \\n   k++;   \\n        }\\nreturn sb.toString();\\n    }\\n}\\nclass Pair{\\n     private int key;\\n    private String value;\\n\\n    public Pair(int key, String value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n\\n    public int getKey() {\\n        return key;\\n    }\\n\\n    public String getValue() {\\n        return value;\\n    }\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kapsimus",
                        "content": "Wrong Answer\\n\\nOutput\\n\"PINALSIGYAHRPI\"\\nExpected\\n\"PINALSIGYAHRPI\"\\n\\nWhy?\\n"
                    },
                    {
                        "username": "Krvijay_32",
                        "content": "It is one of the Nice question i have ever encountered.\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "garbage question"
                    },
                    {
                        "username": "jonahbebko",
                        "content": "Finally solved. Hint: lay out `s` up-to-down, like Snake. Reverse every second column."
                    },
                    {
                        "username": "jonahbebko",
                        "content": "me when the problem has zero real-world applications"
                    }
                ]
            },
            {
                "id": 1975121,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "Actually kinda a cool problem that\\'s just pure string manipulation and coding basics, no strings attached!"
                    },
                    {
                        "username": "tomamais",
                        "content": "please, more examples to make it clear. As per the examples above, the test case \"ABCDE\" should be something like this:\\n\\nA - C - D\\nB -    -  E"
                    },
                    {
                        "username": "ChidiE",
                        "content": "No sure why the complaints tho....just increase and decrease the index of the numRows by 1.\\nso numRows 3 is equivalent to.\\n\\n\\'P A Y P A L I S H I R I N G\\'\\n\\'0 1 2 1 0 1 2 1 0 1 2 1 0 1\\'\\n\\nconcat the 0s 1s 2s"
                    },
                    {
                        "username": "user3974tS",
                        "content": "I really like this question"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        ArrayList<Pair> list=new ArrayList<>();\\n        // boolean flag=true;\\n        int cnt=0,c=0;\\n        while(s.length()>cnt){\\n        for(int i=0;i<numRows;i++){\\n            if(i+c<s.length())\\nlist.add(new Pair(i,s.charAt(i+c)+\"\"));\\n\\ncnt++;\\n        }\\n        for(int j=numRows-2;j>=1;j--){\\n            if(cnt<s.length())\\n            list.add(new Pair(j,s.charAt(cnt)+\"\"));\\n            \\n            cnt++;\\n        }\\n        c=cnt;\\n\\n        }\\n\\n        StringBuilder sb=new StringBuilder(\"\");\\n        int k=0;\\n        while(k<numRows){\\n   for(Pair pair:list){\\n\\nif(pair.getKey()==k){\\nsb.append(pair.getValue());\\n}\\n\\n   }  \\n   k++;   \\n        }\\nreturn sb.toString();\\n    }\\n}\\nclass Pair{\\n     private int key;\\n    private String value;\\n\\n    public Pair(int key, String value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n\\n    public int getKey() {\\n        return key;\\n    }\\n\\n    public String getValue() {\\n        return value;\\n    }\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kapsimus",
                        "content": "Wrong Answer\\n\\nOutput\\n\"PINALSIGYAHRPI\"\\nExpected\\n\"PINALSIGYAHRPI\"\\n\\nWhy?\\n"
                    },
                    {
                        "username": "Krvijay_32",
                        "content": "It is one of the Nice question i have ever encountered.\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "garbage question"
                    },
                    {
                        "username": "jonahbebko",
                        "content": "Finally solved. Hint: lay out `s` up-to-down, like Snake. Reverse every second column."
                    },
                    {
                        "username": "jonahbebko",
                        "content": "me when the problem has zero real-world applications"
                    }
                ]
            },
            {
                "id": 1974113,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "Actually kinda a cool problem that\\'s just pure string manipulation and coding basics, no strings attached!"
                    },
                    {
                        "username": "tomamais",
                        "content": "please, more examples to make it clear. As per the examples above, the test case \"ABCDE\" should be something like this:\\n\\nA - C - D\\nB -    -  E"
                    },
                    {
                        "username": "ChidiE",
                        "content": "No sure why the complaints tho....just increase and decrease the index of the numRows by 1.\\nso numRows 3 is equivalent to.\\n\\n\\'P A Y P A L I S H I R I N G\\'\\n\\'0 1 2 1 0 1 2 1 0 1 2 1 0 1\\'\\n\\nconcat the 0s 1s 2s"
                    },
                    {
                        "username": "user3974tS",
                        "content": "I really like this question"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        ArrayList<Pair> list=new ArrayList<>();\\n        // boolean flag=true;\\n        int cnt=0,c=0;\\n        while(s.length()>cnt){\\n        for(int i=0;i<numRows;i++){\\n            if(i+c<s.length())\\nlist.add(new Pair(i,s.charAt(i+c)+\"\"));\\n\\ncnt++;\\n        }\\n        for(int j=numRows-2;j>=1;j--){\\n            if(cnt<s.length())\\n            list.add(new Pair(j,s.charAt(cnt)+\"\"));\\n            \\n            cnt++;\\n        }\\n        c=cnt;\\n\\n        }\\n\\n        StringBuilder sb=new StringBuilder(\"\");\\n        int k=0;\\n        while(k<numRows){\\n   for(Pair pair:list){\\n\\nif(pair.getKey()==k){\\nsb.append(pair.getValue());\\n}\\n\\n   }  \\n   k++;   \\n        }\\nreturn sb.toString();\\n    }\\n}\\nclass Pair{\\n     private int key;\\n    private String value;\\n\\n    public Pair(int key, String value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n\\n    public int getKey() {\\n        return key;\\n    }\\n\\n    public String getValue() {\\n        return value;\\n    }\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kapsimus",
                        "content": "Wrong Answer\\n\\nOutput\\n\"PINALSIGYAHRPI\"\\nExpected\\n\"PINALSIGYAHRPI\"\\n\\nWhy?\\n"
                    },
                    {
                        "username": "Krvijay_32",
                        "content": "It is one of the Nice question i have ever encountered.\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "garbage question"
                    },
                    {
                        "username": "jonahbebko",
                        "content": "Finally solved. Hint: lay out `s` up-to-down, like Snake. Reverse every second column."
                    },
                    {
                        "username": "jonahbebko",
                        "content": "me when the problem has zero real-world applications"
                    }
                ]
            },
            {
                "id": 1963356,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "Actually kinda a cool problem that\\'s just pure string manipulation and coding basics, no strings attached!"
                    },
                    {
                        "username": "tomamais",
                        "content": "please, more examples to make it clear. As per the examples above, the test case \"ABCDE\" should be something like this:\\n\\nA - C - D\\nB -    -  E"
                    },
                    {
                        "username": "ChidiE",
                        "content": "No sure why the complaints tho....just increase and decrease the index of the numRows by 1.\\nso numRows 3 is equivalent to.\\n\\n\\'P A Y P A L I S H I R I N G\\'\\n\\'0 1 2 1 0 1 2 1 0 1 2 1 0 1\\'\\n\\nconcat the 0s 1s 2s"
                    },
                    {
                        "username": "user3974tS",
                        "content": "I really like this question"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        ArrayList<Pair> list=new ArrayList<>();\\n        // boolean flag=true;\\n        int cnt=0,c=0;\\n        while(s.length()>cnt){\\n        for(int i=0;i<numRows;i++){\\n            if(i+c<s.length())\\nlist.add(new Pair(i,s.charAt(i+c)+\"\"));\\n\\ncnt++;\\n        }\\n        for(int j=numRows-2;j>=1;j--){\\n            if(cnt<s.length())\\n            list.add(new Pair(j,s.charAt(cnt)+\"\"));\\n            \\n            cnt++;\\n        }\\n        c=cnt;\\n\\n        }\\n\\n        StringBuilder sb=new StringBuilder(\"\");\\n        int k=0;\\n        while(k<numRows){\\n   for(Pair pair:list){\\n\\nif(pair.getKey()==k){\\nsb.append(pair.getValue());\\n}\\n\\n   }  \\n   k++;   \\n        }\\nreturn sb.toString();\\n    }\\n}\\nclass Pair{\\n     private int key;\\n    private String value;\\n\\n    public Pair(int key, String value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n\\n    public int getKey() {\\n        return key;\\n    }\\n\\n    public String getValue() {\\n        return value;\\n    }\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kapsimus",
                        "content": "Wrong Answer\\n\\nOutput\\n\"PINALSIGYAHRPI\"\\nExpected\\n\"PINALSIGYAHRPI\"\\n\\nWhy?\\n"
                    },
                    {
                        "username": "Krvijay_32",
                        "content": "It is one of the Nice question i have ever encountered.\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "garbage question"
                    },
                    {
                        "username": "jonahbebko",
                        "content": "Finally solved. Hint: lay out `s` up-to-down, like Snake. Reverse every second column."
                    },
                    {
                        "username": "jonahbebko",
                        "content": "me when the problem has zero real-world applications"
                    }
                ]
            },
            {
                "id": 1957666,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "Actually kinda a cool problem that\\'s just pure string manipulation and coding basics, no strings attached!"
                    },
                    {
                        "username": "tomamais",
                        "content": "please, more examples to make it clear. As per the examples above, the test case \"ABCDE\" should be something like this:\\n\\nA - C - D\\nB -    -  E"
                    },
                    {
                        "username": "ChidiE",
                        "content": "No sure why the complaints tho....just increase and decrease the index of the numRows by 1.\\nso numRows 3 is equivalent to.\\n\\n\\'P A Y P A L I S H I R I N G\\'\\n\\'0 1 2 1 0 1 2 1 0 1 2 1 0 1\\'\\n\\nconcat the 0s 1s 2s"
                    },
                    {
                        "username": "user3974tS",
                        "content": "I really like this question"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        ArrayList<Pair> list=new ArrayList<>();\\n        // boolean flag=true;\\n        int cnt=0,c=0;\\n        while(s.length()>cnt){\\n        for(int i=0;i<numRows;i++){\\n            if(i+c<s.length())\\nlist.add(new Pair(i,s.charAt(i+c)+\"\"));\\n\\ncnt++;\\n        }\\n        for(int j=numRows-2;j>=1;j--){\\n            if(cnt<s.length())\\n            list.add(new Pair(j,s.charAt(cnt)+\"\"));\\n            \\n            cnt++;\\n        }\\n        c=cnt;\\n\\n        }\\n\\n        StringBuilder sb=new StringBuilder(\"\");\\n        int k=0;\\n        while(k<numRows){\\n   for(Pair pair:list){\\n\\nif(pair.getKey()==k){\\nsb.append(pair.getValue());\\n}\\n\\n   }  \\n   k++;   \\n        }\\nreturn sb.toString();\\n    }\\n}\\nclass Pair{\\n     private int key;\\n    private String value;\\n\\n    public Pair(int key, String value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n\\n    public int getKey() {\\n        return key;\\n    }\\n\\n    public String getValue() {\\n        return value;\\n    }\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kapsimus",
                        "content": "Wrong Answer\\n\\nOutput\\n\"PINALSIGYAHRPI\"\\nExpected\\n\"PINALSIGYAHRPI\"\\n\\nWhy?\\n"
                    },
                    {
                        "username": "Krvijay_32",
                        "content": "It is one of the Nice question i have ever encountered.\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "garbage question"
                    },
                    {
                        "username": "jonahbebko",
                        "content": "Finally solved. Hint: lay out `s` up-to-down, like Snake. Reverse every second column."
                    },
                    {
                        "username": "jonahbebko",
                        "content": "me when the problem has zero real-world applications"
                    }
                ]
            },
            {
                "id": 1949689,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "Actually kinda a cool problem that\\'s just pure string manipulation and coding basics, no strings attached!"
                    },
                    {
                        "username": "tomamais",
                        "content": "please, more examples to make it clear. As per the examples above, the test case \"ABCDE\" should be something like this:\\n\\nA - C - D\\nB -    -  E"
                    },
                    {
                        "username": "ChidiE",
                        "content": "No sure why the complaints tho....just increase and decrease the index of the numRows by 1.\\nso numRows 3 is equivalent to.\\n\\n\\'P A Y P A L I S H I R I N G\\'\\n\\'0 1 2 1 0 1 2 1 0 1 2 1 0 1\\'\\n\\nconcat the 0s 1s 2s"
                    },
                    {
                        "username": "user3974tS",
                        "content": "I really like this question"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        ArrayList<Pair> list=new ArrayList<>();\\n        // boolean flag=true;\\n        int cnt=0,c=0;\\n        while(s.length()>cnt){\\n        for(int i=0;i<numRows;i++){\\n            if(i+c<s.length())\\nlist.add(new Pair(i,s.charAt(i+c)+\"\"));\\n\\ncnt++;\\n        }\\n        for(int j=numRows-2;j>=1;j--){\\n            if(cnt<s.length())\\n            list.add(new Pair(j,s.charAt(cnt)+\"\"));\\n            \\n            cnt++;\\n        }\\n        c=cnt;\\n\\n        }\\n\\n        StringBuilder sb=new StringBuilder(\"\");\\n        int k=0;\\n        while(k<numRows){\\n   for(Pair pair:list){\\n\\nif(pair.getKey()==k){\\nsb.append(pair.getValue());\\n}\\n\\n   }  \\n   k++;   \\n        }\\nreturn sb.toString();\\n    }\\n}\\nclass Pair{\\n     private int key;\\n    private String value;\\n\\n    public Pair(int key, String value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n\\n    public int getKey() {\\n        return key;\\n    }\\n\\n    public String getValue() {\\n        return value;\\n    }\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kapsimus",
                        "content": "Wrong Answer\\n\\nOutput\\n\"PINALSIGYAHRPI\"\\nExpected\\n\"PINALSIGYAHRPI\"\\n\\nWhy?\\n"
                    },
                    {
                        "username": "Krvijay_32",
                        "content": "It is one of the Nice question i have ever encountered.\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "garbage question"
                    },
                    {
                        "username": "jonahbebko",
                        "content": "Finally solved. Hint: lay out `s` up-to-down, like Snake. Reverse every second column."
                    },
                    {
                        "username": "jonahbebko",
                        "content": "me when the problem has zero real-world applications"
                    }
                ]
            },
            {
                "id": 1949400,
                "content": [
                    {
                        "username": "kenzgf",
                        "content": "Actually kinda a cool problem that\\'s just pure string manipulation and coding basics, no strings attached!"
                    },
                    {
                        "username": "tomamais",
                        "content": "please, more examples to make it clear. As per the examples above, the test case \"ABCDE\" should be something like this:\\n\\nA - C - D\\nB -    -  E"
                    },
                    {
                        "username": "ChidiE",
                        "content": "No sure why the complaints tho....just increase and decrease the index of the numRows by 1.\\nso numRows 3 is equivalent to.\\n\\n\\'P A Y P A L I S H I R I N G\\'\\n\\'0 1 2 1 0 1 2 1 0 1 2 1 0 1\\'\\n\\nconcat the 0s 1s 2s"
                    },
                    {
                        "username": "user3974tS",
                        "content": "I really like this question"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "class Solution {\\n    public String convert(String s, int numRows) {\\n        ArrayList<Pair> list=new ArrayList<>();\\n        // boolean flag=true;\\n        int cnt=0,c=0;\\n        while(s.length()>cnt){\\n        for(int i=0;i<numRows;i++){\\n            if(i+c<s.length())\\nlist.add(new Pair(i,s.charAt(i+c)+\"\"));\\n\\ncnt++;\\n        }\\n        for(int j=numRows-2;j>=1;j--){\\n            if(cnt<s.length())\\n            list.add(new Pair(j,s.charAt(cnt)+\"\"));\\n            \\n            cnt++;\\n        }\\n        c=cnt;\\n\\n        }\\n\\n        StringBuilder sb=new StringBuilder(\"\");\\n        int k=0;\\n        while(k<numRows){\\n   for(Pair pair:list){\\n\\nif(pair.getKey()==k){\\nsb.append(pair.getValue());\\n}\\n\\n   }  \\n   k++;   \\n        }\\nreturn sb.toString();\\n    }\\n}\\nclass Pair{\\n     private int key;\\n    private String value;\\n\\n    public Pair(int key, String value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n\\n    public int getKey() {\\n        return key;\\n    }\\n\\n    public String getValue() {\\n        return value;\\n    }\\n\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kapsimus",
                        "content": "Wrong Answer\\n\\nOutput\\n\"PINALSIGYAHRPI\"\\nExpected\\n\"PINALSIGYAHRPI\"\\n\\nWhy?\\n"
                    },
                    {
                        "username": "Krvijay_32",
                        "content": "It is one of the Nice question i have ever encountered.\n"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "garbage question"
                    },
                    {
                        "username": "jonahbebko",
                        "content": "Finally solved. Hint: lay out `s` up-to-down, like Snake. Reverse every second column."
                    },
                    {
                        "username": "jonahbebko",
                        "content": "me when the problem has zero real-world applications"
                    }
                ]
            },
            {
                "id": 1940066,
                "content": [
                    {
                        "username": "shyamvenkat007",
                        "content": "I am getting the following error when I try to run my program, but I have checked the code with an online compiler and it works fine in it. What might be the problem?\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "hd116527",
                        "content": "Heres how I understood this question, the string is read in this order\\n\\nnumRows = 3\\n\\n1     5    9\\n2 4 6 8\\n3    7\\n\\nyour goal is to return the string grouped by the rows in which they appear meaning they will be grouped as such:\\n\\n1     1     1\\n2 2 2 2 2\\n3    3    3\\n\\nthe letter are grouped by number in the order of appearance as shown by the first diagram\\n\\nhope this helps"
                    },
                    {
                        "username": "Alexamzi",
                        "content": "You can either rawdog it into an array and combine the rows (medium difficulty) or develop and implement an algorithm (hard difficulty). I like this problem."
                    },
                    {
                        "username": "Alexamzi",
                        "content": "Though I don\\'t think you can set the algorithm with runtime less than O(n^2)."
                    },
                    {
                        "username": "Mindframe",
                        "content": "Problems like these make me feel like a useless developer. All I\\'m good at is front end web design stuff and database queries. I sit here feeling defeated looking at these algorithmic things."
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "So what does \"A\" , 3 look like?"
                    },
                    {
                        "username": "xecuti431",
                        "content": "is a zig zag pattern a known thing or are we to guess what the hell that means"
                    },
                    {
                        "username": "brightshinigamii",
                        "content": "not work"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "ohh, it\\'s too easy how its described.\\nmannnnn. I hate this kind of problem. no proper explained."
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(s.size() <=2 || numRows == 1) return s;\\n        vector<string> ans(numRows, \"\");\\n        bool flag = true;\\n        for(int i=0;i<s.size(); i++)\\n        {\\n            if(flag)\\n            {\\n                int index = i%numRows;\\n                ans[index]+=s[i];\\n                if(index == numRows-1) flag = !flag;\\n            }\\n            else\\n            {\\n                ans[i - (i%numRows -2)] += s[i];\\n                if(i - (i%numRows -2) == 0) flag = !flag;\\n            }\\n        }\\n        for(int i=1;i<ans.size();i++) \\n        {\\n            ans[0]+=ans[i];\\n        }\\n        return ans[0];\\n    }\\n};\\n\\nSomeone pls tell me what wron i;m doing"
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "I'm using rust. I wrote down all my code and the test cases are working as it should be on my local machine. But if I hand in the question, leetcode gives me this Runtime Error\n\n```bash\nassertion failed: step != 0 (/rustc/db9d1b20bba1968c1ec1fc49616d4742c1725b4b/library/core/src/iter/adapters/step_by.rs)\n```\nThere are no other explanation. Is there a way to solve this?"
                    }
                ]
            },
            {
                "id": 1936652,
                "content": [
                    {
                        "username": "shyamvenkat007",
                        "content": "I am getting the following error when I try to run my program, but I have checked the code with an online compiler and it works fine in it. What might be the problem?\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "hd116527",
                        "content": "Heres how I understood this question, the string is read in this order\\n\\nnumRows = 3\\n\\n1     5    9\\n2 4 6 8\\n3    7\\n\\nyour goal is to return the string grouped by the rows in which they appear meaning they will be grouped as such:\\n\\n1     1     1\\n2 2 2 2 2\\n3    3    3\\n\\nthe letter are grouped by number in the order of appearance as shown by the first diagram\\n\\nhope this helps"
                    },
                    {
                        "username": "Alexamzi",
                        "content": "You can either rawdog it into an array and combine the rows (medium difficulty) or develop and implement an algorithm (hard difficulty). I like this problem."
                    },
                    {
                        "username": "Alexamzi",
                        "content": "Though I don\\'t think you can set the algorithm with runtime less than O(n^2)."
                    },
                    {
                        "username": "Mindframe",
                        "content": "Problems like these make me feel like a useless developer. All I\\'m good at is front end web design stuff and database queries. I sit here feeling defeated looking at these algorithmic things."
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "So what does \"A\" , 3 look like?"
                    },
                    {
                        "username": "xecuti431",
                        "content": "is a zig zag pattern a known thing or are we to guess what the hell that means"
                    },
                    {
                        "username": "brightshinigamii",
                        "content": "not work"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "ohh, it\\'s too easy how its described.\\nmannnnn. I hate this kind of problem. no proper explained."
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(s.size() <=2 || numRows == 1) return s;\\n        vector<string> ans(numRows, \"\");\\n        bool flag = true;\\n        for(int i=0;i<s.size(); i++)\\n        {\\n            if(flag)\\n            {\\n                int index = i%numRows;\\n                ans[index]+=s[i];\\n                if(index == numRows-1) flag = !flag;\\n            }\\n            else\\n            {\\n                ans[i - (i%numRows -2)] += s[i];\\n                if(i - (i%numRows -2) == 0) flag = !flag;\\n            }\\n        }\\n        for(int i=1;i<ans.size();i++) \\n        {\\n            ans[0]+=ans[i];\\n        }\\n        return ans[0];\\n    }\\n};\\n\\nSomeone pls tell me what wron i;m doing"
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "I'm using rust. I wrote down all my code and the test cases are working as it should be on my local machine. But if I hand in the question, leetcode gives me this Runtime Error\n\n```bash\nassertion failed: step != 0 (/rustc/db9d1b20bba1968c1ec1fc49616d4742c1725b4b/library/core/src/iter/adapters/step_by.rs)\n```\nThere are no other explanation. Is there a way to solve this?"
                    }
                ]
            },
            {
                "id": 1930551,
                "content": [
                    {
                        "username": "shyamvenkat007",
                        "content": "I am getting the following error when I try to run my program, but I have checked the code with an online compiler and it works fine in it. What might be the problem?\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "hd116527",
                        "content": "Heres how I understood this question, the string is read in this order\\n\\nnumRows = 3\\n\\n1     5    9\\n2 4 6 8\\n3    7\\n\\nyour goal is to return the string grouped by the rows in which they appear meaning they will be grouped as such:\\n\\n1     1     1\\n2 2 2 2 2\\n3    3    3\\n\\nthe letter are grouped by number in the order of appearance as shown by the first diagram\\n\\nhope this helps"
                    },
                    {
                        "username": "Alexamzi",
                        "content": "You can either rawdog it into an array and combine the rows (medium difficulty) or develop and implement an algorithm (hard difficulty). I like this problem."
                    },
                    {
                        "username": "Alexamzi",
                        "content": "Though I don\\'t think you can set the algorithm with runtime less than O(n^2)."
                    },
                    {
                        "username": "Mindframe",
                        "content": "Problems like these make me feel like a useless developer. All I\\'m good at is front end web design stuff and database queries. I sit here feeling defeated looking at these algorithmic things."
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "So what does \"A\" , 3 look like?"
                    },
                    {
                        "username": "xecuti431",
                        "content": "is a zig zag pattern a known thing or are we to guess what the hell that means"
                    },
                    {
                        "username": "brightshinigamii",
                        "content": "not work"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "ohh, it\\'s too easy how its described.\\nmannnnn. I hate this kind of problem. no proper explained."
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(s.size() <=2 || numRows == 1) return s;\\n        vector<string> ans(numRows, \"\");\\n        bool flag = true;\\n        for(int i=0;i<s.size(); i++)\\n        {\\n            if(flag)\\n            {\\n                int index = i%numRows;\\n                ans[index]+=s[i];\\n                if(index == numRows-1) flag = !flag;\\n            }\\n            else\\n            {\\n                ans[i - (i%numRows -2)] += s[i];\\n                if(i - (i%numRows -2) == 0) flag = !flag;\\n            }\\n        }\\n        for(int i=1;i<ans.size();i++) \\n        {\\n            ans[0]+=ans[i];\\n        }\\n        return ans[0];\\n    }\\n};\\n\\nSomeone pls tell me what wron i;m doing"
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "I'm using rust. I wrote down all my code and the test cases are working as it should be on my local machine. But if I hand in the question, leetcode gives me this Runtime Error\n\n```bash\nassertion failed: step != 0 (/rustc/db9d1b20bba1968c1ec1fc49616d4742c1725b4b/library/core/src/iter/adapters/step_by.rs)\n```\nThere are no other explanation. Is there a way to solve this?"
                    }
                ]
            },
            {
                "id": 1902536,
                "content": [
                    {
                        "username": "shyamvenkat007",
                        "content": "I am getting the following error when I try to run my program, but I have checked the code with an online compiler and it works fine in it. What might be the problem?\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "hd116527",
                        "content": "Heres how I understood this question, the string is read in this order\\n\\nnumRows = 3\\n\\n1     5    9\\n2 4 6 8\\n3    7\\n\\nyour goal is to return the string grouped by the rows in which they appear meaning they will be grouped as such:\\n\\n1     1     1\\n2 2 2 2 2\\n3    3    3\\n\\nthe letter are grouped by number in the order of appearance as shown by the first diagram\\n\\nhope this helps"
                    },
                    {
                        "username": "Alexamzi",
                        "content": "You can either rawdog it into an array and combine the rows (medium difficulty) or develop and implement an algorithm (hard difficulty). I like this problem."
                    },
                    {
                        "username": "Alexamzi",
                        "content": "Though I don\\'t think you can set the algorithm with runtime less than O(n^2)."
                    },
                    {
                        "username": "Mindframe",
                        "content": "Problems like these make me feel like a useless developer. All I\\'m good at is front end web design stuff and database queries. I sit here feeling defeated looking at these algorithmic things."
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "So what does \"A\" , 3 look like?"
                    },
                    {
                        "username": "xecuti431",
                        "content": "is a zig zag pattern a known thing or are we to guess what the hell that means"
                    },
                    {
                        "username": "brightshinigamii",
                        "content": "not work"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "ohh, it\\'s too easy how its described.\\nmannnnn. I hate this kind of problem. no proper explained."
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(s.size() <=2 || numRows == 1) return s;\\n        vector<string> ans(numRows, \"\");\\n        bool flag = true;\\n        for(int i=0;i<s.size(); i++)\\n        {\\n            if(flag)\\n            {\\n                int index = i%numRows;\\n                ans[index]+=s[i];\\n                if(index == numRows-1) flag = !flag;\\n            }\\n            else\\n            {\\n                ans[i - (i%numRows -2)] += s[i];\\n                if(i - (i%numRows -2) == 0) flag = !flag;\\n            }\\n        }\\n        for(int i=1;i<ans.size();i++) \\n        {\\n            ans[0]+=ans[i];\\n        }\\n        return ans[0];\\n    }\\n};\\n\\nSomeone pls tell me what wron i;m doing"
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "I'm using rust. I wrote down all my code and the test cases are working as it should be on my local machine. But if I hand in the question, leetcode gives me this Runtime Error\n\n```bash\nassertion failed: step != 0 (/rustc/db9d1b20bba1968c1ec1fc49616d4742c1725b4b/library/core/src/iter/adapters/step_by.rs)\n```\nThere are no other explanation. Is there a way to solve this?"
                    }
                ]
            },
            {
                "id": 1876132,
                "content": [
                    {
                        "username": "shyamvenkat007",
                        "content": "I am getting the following error when I try to run my program, but I have checked the code with an online compiler and it works fine in it. What might be the problem?\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "hd116527",
                        "content": "Heres how I understood this question, the string is read in this order\\n\\nnumRows = 3\\n\\n1     5    9\\n2 4 6 8\\n3    7\\n\\nyour goal is to return the string grouped by the rows in which they appear meaning they will be grouped as such:\\n\\n1     1     1\\n2 2 2 2 2\\n3    3    3\\n\\nthe letter are grouped by number in the order of appearance as shown by the first diagram\\n\\nhope this helps"
                    },
                    {
                        "username": "Alexamzi",
                        "content": "You can either rawdog it into an array and combine the rows (medium difficulty) or develop and implement an algorithm (hard difficulty). I like this problem."
                    },
                    {
                        "username": "Alexamzi",
                        "content": "Though I don\\'t think you can set the algorithm with runtime less than O(n^2)."
                    },
                    {
                        "username": "Mindframe",
                        "content": "Problems like these make me feel like a useless developer. All I\\'m good at is front end web design stuff and database queries. I sit here feeling defeated looking at these algorithmic things."
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "So what does \"A\" , 3 look like?"
                    },
                    {
                        "username": "xecuti431",
                        "content": "is a zig zag pattern a known thing or are we to guess what the hell that means"
                    },
                    {
                        "username": "brightshinigamii",
                        "content": "not work"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "ohh, it\\'s too easy how its described.\\nmannnnn. I hate this kind of problem. no proper explained."
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(s.size() <=2 || numRows == 1) return s;\\n        vector<string> ans(numRows, \"\");\\n        bool flag = true;\\n        for(int i=0;i<s.size(); i++)\\n        {\\n            if(flag)\\n            {\\n                int index = i%numRows;\\n                ans[index]+=s[i];\\n                if(index == numRows-1) flag = !flag;\\n            }\\n            else\\n            {\\n                ans[i - (i%numRows -2)] += s[i];\\n                if(i - (i%numRows -2) == 0) flag = !flag;\\n            }\\n        }\\n        for(int i=1;i<ans.size();i++) \\n        {\\n            ans[0]+=ans[i];\\n        }\\n        return ans[0];\\n    }\\n};\\n\\nSomeone pls tell me what wron i;m doing"
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "I'm using rust. I wrote down all my code and the test cases are working as it should be on my local machine. But if I hand in the question, leetcode gives me this Runtime Error\n\n```bash\nassertion failed: step != 0 (/rustc/db9d1b20bba1968c1ec1fc49616d4742c1725b4b/library/core/src/iter/adapters/step_by.rs)\n```\nThere are no other explanation. Is there a way to solve this?"
                    }
                ]
            },
            {
                "id": 1875022,
                "content": [
                    {
                        "username": "shyamvenkat007",
                        "content": "I am getting the following error when I try to run my program, but I have checked the code with an online compiler and it works fine in it. What might be the problem?\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "hd116527",
                        "content": "Heres how I understood this question, the string is read in this order\\n\\nnumRows = 3\\n\\n1     5    9\\n2 4 6 8\\n3    7\\n\\nyour goal is to return the string grouped by the rows in which they appear meaning they will be grouped as such:\\n\\n1     1     1\\n2 2 2 2 2\\n3    3    3\\n\\nthe letter are grouped by number in the order of appearance as shown by the first diagram\\n\\nhope this helps"
                    },
                    {
                        "username": "Alexamzi",
                        "content": "You can either rawdog it into an array and combine the rows (medium difficulty) or develop and implement an algorithm (hard difficulty). I like this problem."
                    },
                    {
                        "username": "Alexamzi",
                        "content": "Though I don\\'t think you can set the algorithm with runtime less than O(n^2)."
                    },
                    {
                        "username": "Mindframe",
                        "content": "Problems like these make me feel like a useless developer. All I\\'m good at is front end web design stuff and database queries. I sit here feeling defeated looking at these algorithmic things."
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "So what does \"A\" , 3 look like?"
                    },
                    {
                        "username": "xecuti431",
                        "content": "is a zig zag pattern a known thing or are we to guess what the hell that means"
                    },
                    {
                        "username": "brightshinigamii",
                        "content": "not work"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "ohh, it\\'s too easy how its described.\\nmannnnn. I hate this kind of problem. no proper explained."
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(s.size() <=2 || numRows == 1) return s;\\n        vector<string> ans(numRows, \"\");\\n        bool flag = true;\\n        for(int i=0;i<s.size(); i++)\\n        {\\n            if(flag)\\n            {\\n                int index = i%numRows;\\n                ans[index]+=s[i];\\n                if(index == numRows-1) flag = !flag;\\n            }\\n            else\\n            {\\n                ans[i - (i%numRows -2)] += s[i];\\n                if(i - (i%numRows -2) == 0) flag = !flag;\\n            }\\n        }\\n        for(int i=1;i<ans.size();i++) \\n        {\\n            ans[0]+=ans[i];\\n        }\\n        return ans[0];\\n    }\\n};\\n\\nSomeone pls tell me what wron i;m doing"
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "I'm using rust. I wrote down all my code and the test cases are working as it should be on my local machine. But if I hand in the question, leetcode gives me this Runtime Error\n\n```bash\nassertion failed: step != 0 (/rustc/db9d1b20bba1968c1ec1fc49616d4742c1725b4b/library/core/src/iter/adapters/step_by.rs)\n```\nThere are no other explanation. Is there a way to solve this?"
                    }
                ]
            },
            {
                "id": 1874592,
                "content": [
                    {
                        "username": "shyamvenkat007",
                        "content": "I am getting the following error when I try to run my program, but I have checked the code with an online compiler and it works fine in it. What might be the problem?\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "hd116527",
                        "content": "Heres how I understood this question, the string is read in this order\\n\\nnumRows = 3\\n\\n1     5    9\\n2 4 6 8\\n3    7\\n\\nyour goal is to return the string grouped by the rows in which they appear meaning they will be grouped as such:\\n\\n1     1     1\\n2 2 2 2 2\\n3    3    3\\n\\nthe letter are grouped by number in the order of appearance as shown by the first diagram\\n\\nhope this helps"
                    },
                    {
                        "username": "Alexamzi",
                        "content": "You can either rawdog it into an array and combine the rows (medium difficulty) or develop and implement an algorithm (hard difficulty). I like this problem."
                    },
                    {
                        "username": "Alexamzi",
                        "content": "Though I don\\'t think you can set the algorithm with runtime less than O(n^2)."
                    },
                    {
                        "username": "Mindframe",
                        "content": "Problems like these make me feel like a useless developer. All I\\'m good at is front end web design stuff and database queries. I sit here feeling defeated looking at these algorithmic things."
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "So what does \"A\" , 3 look like?"
                    },
                    {
                        "username": "xecuti431",
                        "content": "is a zig zag pattern a known thing or are we to guess what the hell that means"
                    },
                    {
                        "username": "brightshinigamii",
                        "content": "not work"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "ohh, it\\'s too easy how its described.\\nmannnnn. I hate this kind of problem. no proper explained."
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(s.size() <=2 || numRows == 1) return s;\\n        vector<string> ans(numRows, \"\");\\n        bool flag = true;\\n        for(int i=0;i<s.size(); i++)\\n        {\\n            if(flag)\\n            {\\n                int index = i%numRows;\\n                ans[index]+=s[i];\\n                if(index == numRows-1) flag = !flag;\\n            }\\n            else\\n            {\\n                ans[i - (i%numRows -2)] += s[i];\\n                if(i - (i%numRows -2) == 0) flag = !flag;\\n            }\\n        }\\n        for(int i=1;i<ans.size();i++) \\n        {\\n            ans[0]+=ans[i];\\n        }\\n        return ans[0];\\n    }\\n};\\n\\nSomeone pls tell me what wron i;m doing"
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "I'm using rust. I wrote down all my code and the test cases are working as it should be on my local machine. But if I hand in the question, leetcode gives me this Runtime Error\n\n```bash\nassertion failed: step != 0 (/rustc/db9d1b20bba1968c1ec1fc49616d4742c1725b4b/library/core/src/iter/adapters/step_by.rs)\n```\nThere are no other explanation. Is there a way to solve this?"
                    }
                ]
            },
            {
                "id": 1868301,
                "content": [
                    {
                        "username": "shyamvenkat007",
                        "content": "I am getting the following error when I try to run my program, but I have checked the code with an online compiler and it works fine in it. What might be the problem?\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "hd116527",
                        "content": "Heres how I understood this question, the string is read in this order\\n\\nnumRows = 3\\n\\n1     5    9\\n2 4 6 8\\n3    7\\n\\nyour goal is to return the string grouped by the rows in which they appear meaning they will be grouped as such:\\n\\n1     1     1\\n2 2 2 2 2\\n3    3    3\\n\\nthe letter are grouped by number in the order of appearance as shown by the first diagram\\n\\nhope this helps"
                    },
                    {
                        "username": "Alexamzi",
                        "content": "You can either rawdog it into an array and combine the rows (medium difficulty) or develop and implement an algorithm (hard difficulty). I like this problem."
                    },
                    {
                        "username": "Alexamzi",
                        "content": "Though I don\\'t think you can set the algorithm with runtime less than O(n^2)."
                    },
                    {
                        "username": "Mindframe",
                        "content": "Problems like these make me feel like a useless developer. All I\\'m good at is front end web design stuff and database queries. I sit here feeling defeated looking at these algorithmic things."
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "So what does \"A\" , 3 look like?"
                    },
                    {
                        "username": "xecuti431",
                        "content": "is a zig zag pattern a known thing or are we to guess what the hell that means"
                    },
                    {
                        "username": "brightshinigamii",
                        "content": "not work"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "ohh, it\\'s too easy how its described.\\nmannnnn. I hate this kind of problem. no proper explained."
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(s.size() <=2 || numRows == 1) return s;\\n        vector<string> ans(numRows, \"\");\\n        bool flag = true;\\n        for(int i=0;i<s.size(); i++)\\n        {\\n            if(flag)\\n            {\\n                int index = i%numRows;\\n                ans[index]+=s[i];\\n                if(index == numRows-1) flag = !flag;\\n            }\\n            else\\n            {\\n                ans[i - (i%numRows -2)] += s[i];\\n                if(i - (i%numRows -2) == 0) flag = !flag;\\n            }\\n        }\\n        for(int i=1;i<ans.size();i++) \\n        {\\n            ans[0]+=ans[i];\\n        }\\n        return ans[0];\\n    }\\n};\\n\\nSomeone pls tell me what wron i;m doing"
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "I'm using rust. I wrote down all my code and the test cases are working as it should be on my local machine. But if I hand in the question, leetcode gives me this Runtime Error\n\n```bash\nassertion failed: step != 0 (/rustc/db9d1b20bba1968c1ec1fc49616d4742c1725b4b/library/core/src/iter/adapters/step_by.rs)\n```\nThere are no other explanation. Is there a way to solve this?"
                    }
                ]
            },
            {
                "id": 1860535,
                "content": [
                    {
                        "username": "shyamvenkat007",
                        "content": "I am getting the following error when I try to run my program, but I have checked the code with an online compiler and it works fine in it. What might be the problem?\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "hd116527",
                        "content": "Heres how I understood this question, the string is read in this order\\n\\nnumRows = 3\\n\\n1     5    9\\n2 4 6 8\\n3    7\\n\\nyour goal is to return the string grouped by the rows in which they appear meaning they will be grouped as such:\\n\\n1     1     1\\n2 2 2 2 2\\n3    3    3\\n\\nthe letter are grouped by number in the order of appearance as shown by the first diagram\\n\\nhope this helps"
                    },
                    {
                        "username": "Alexamzi",
                        "content": "You can either rawdog it into an array and combine the rows (medium difficulty) or develop and implement an algorithm (hard difficulty). I like this problem."
                    },
                    {
                        "username": "Alexamzi",
                        "content": "Though I don\\'t think you can set the algorithm with runtime less than O(n^2)."
                    },
                    {
                        "username": "Mindframe",
                        "content": "Problems like these make me feel like a useless developer. All I\\'m good at is front end web design stuff and database queries. I sit here feeling defeated looking at these algorithmic things."
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "So what does \"A\" , 3 look like?"
                    },
                    {
                        "username": "xecuti431",
                        "content": "is a zig zag pattern a known thing or are we to guess what the hell that means"
                    },
                    {
                        "username": "brightshinigamii",
                        "content": "not work"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "ohh, it\\'s too easy how its described.\\nmannnnn. I hate this kind of problem. no proper explained."
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(s.size() <=2 || numRows == 1) return s;\\n        vector<string> ans(numRows, \"\");\\n        bool flag = true;\\n        for(int i=0;i<s.size(); i++)\\n        {\\n            if(flag)\\n            {\\n                int index = i%numRows;\\n                ans[index]+=s[i];\\n                if(index == numRows-1) flag = !flag;\\n            }\\n            else\\n            {\\n                ans[i - (i%numRows -2)] += s[i];\\n                if(i - (i%numRows -2) == 0) flag = !flag;\\n            }\\n        }\\n        for(int i=1;i<ans.size();i++) \\n        {\\n            ans[0]+=ans[i];\\n        }\\n        return ans[0];\\n    }\\n};\\n\\nSomeone pls tell me what wron i;m doing"
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "I'm using rust. I wrote down all my code and the test cases are working as it should be on my local machine. But if I hand in the question, leetcode gives me this Runtime Error\n\n```bash\nassertion failed: step != 0 (/rustc/db9d1b20bba1968c1ec1fc49616d4742c1725b4b/library/core/src/iter/adapters/step_by.rs)\n```\nThere are no other explanation. Is there a way to solve this?"
                    }
                ]
            },
            {
                "id": 1850099,
                "content": [
                    {
                        "username": "shyamvenkat007",
                        "content": "I am getting the following error when I try to run my program, but I have checked the code with an online compiler and it works fine in it. What might be the problem?\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "hd116527",
                        "content": "Heres how I understood this question, the string is read in this order\\n\\nnumRows = 3\\n\\n1     5    9\\n2 4 6 8\\n3    7\\n\\nyour goal is to return the string grouped by the rows in which they appear meaning they will be grouped as such:\\n\\n1     1     1\\n2 2 2 2 2\\n3    3    3\\n\\nthe letter are grouped by number in the order of appearance as shown by the first diagram\\n\\nhope this helps"
                    },
                    {
                        "username": "Alexamzi",
                        "content": "You can either rawdog it into an array and combine the rows (medium difficulty) or develop and implement an algorithm (hard difficulty). I like this problem."
                    },
                    {
                        "username": "Alexamzi",
                        "content": "Though I don\\'t think you can set the algorithm with runtime less than O(n^2)."
                    },
                    {
                        "username": "Mindframe",
                        "content": "Problems like these make me feel like a useless developer. All I\\'m good at is front end web design stuff and database queries. I sit here feeling defeated looking at these algorithmic things."
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "So what does \"A\" , 3 look like?"
                    },
                    {
                        "username": "xecuti431",
                        "content": "is a zig zag pattern a known thing or are we to guess what the hell that means"
                    },
                    {
                        "username": "brightshinigamii",
                        "content": "not work"
                    },
                    {
                        "username": "mdmasidulhasan27",
                        "content": "ohh, it\\'s too easy how its described.\\nmannnnn. I hate this kind of problem. no proper explained."
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(s.size() <=2 || numRows == 1) return s;\\n        vector<string> ans(numRows, \"\");\\n        bool flag = true;\\n        for(int i=0;i<s.size(); i++)\\n        {\\n            if(flag)\\n            {\\n                int index = i%numRows;\\n                ans[index]+=s[i];\\n                if(index == numRows-1) flag = !flag;\\n            }\\n            else\\n            {\\n                ans[i - (i%numRows -2)] += s[i];\\n                if(i - (i%numRows -2) == 0) flag = !flag;\\n            }\\n        }\\n        for(int i=1;i<ans.size();i++) \\n        {\\n            ans[0]+=ans[i];\\n        }\\n        return ans[0];\\n    }\\n};\\n\\nSomeone pls tell me what wron i;m doing"
                    },
                    {
                        "username": "SKKUGoon",
                        "content": "I'm using rust. I wrote down all my code and the test cases are working as it should be on my local machine. But if I hand in the question, leetcode gives me this Runtime Error\n\n```bash\nassertion failed: step != 0 (/rustc/db9d1b20bba1968c1ec1fc49616d4742c1725b4b/library/core/src/iter/adapters/step_by.rs)\n```\nThere are no other explanation. Is there a way to solve this?"
                    }
                ]
            },
            {
                "id": 1844270,
                "content": [
                    {
                        "username": "lskook47",
                        "content": "In C, the test case does multiple calls for the target converting function"
                    },
                    {
                        "username": "pg99285",
                        "content": "This is Rail Fence Cipher Encryption."
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "The description of this is so confusing that I\\'m not even trying this. I\\'m a natural born english speaker with a decade of programming experience and I minored in Math in college."
                    },
                    {
                        "username": "Franco_20",
                        "content": "process exited with signal SIGILL\\n\\nFirstly, I wrote my program in my local machine. Then I copy all my code and insert it LeetCode. Usually it works! \\n\\nBut now, it\\'s giving me Runtime Error called: process exited with signal SIGILL\\n\\nFirst time facing this issue, is there anyone who can help me with this?\\n\\n `class Solution {\\n\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        var matrix: [[Character]] = []\\n\\nvar index = 1\\n\\n\\n\\nfunc goDown(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    index1 = 1\\n    //print(\"GO down\", terminator: \" \")\\n    for i in 0..<numRows-1{ // 0 1 2\\n        if index == s.count{\\n                    break\\n                }\\n        //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        \\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        index1 += 1\\n        index += 1\\n        \\n       \\n    }\\n    //print(\"\")\\n    index1 -= 1\\n}\\n//------------------------------------------------------------------\\nfunc goUp(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    //print(\"GO up\", terminator: \" \")\\n    index1 -= 1\\n    index2 += 1\\n    for i in 0..<numRows-1{\\n        if index == s.count{\\n            break\\n        }\\n                //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        \\n        \\n        index1 -= 1 \\n        index2 += 1 \\n        index += 1\\n            }\\n    index2 -= 1\\n    //print(\"\")\\n}\\n\\nfor i in 0..<numRows{\\n    matrix.append([])\\n    for j in 0..<s.count/2{\\n        matrix[i].append(\" \")\\n    }\\n}\\nmatrix[0][0] = (s[s.index(s.startIndex, offsetBy: 0)])\\n\\n\\nvar index1 = 1\\nvar index2 = 0\\n\\nwhile true {\\n    goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n    goUp(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n\\n    //goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    \\n    if index == s.count{\\n                        break\\n                    }\\n}\\n\\n\\n\\n\\n\\n//for i in 0..<numRows{\\n//   print(matrix[i])\\n//}\\nvar myString = \"\"\\nfor i in 0..<numRows{\\n    for j in 0..<s.count/2{\\n        if matrix[i][j] == \" \"{\\n            continue\\n        }else{\\n            //print(matrix[i][j], terminator: \"\")\\n            myString.append(matrix[i][j])\\n        }\\n    }\\n}\\n        return myString\\n    }\\n\\n}`"
                    },
                    {
                        "username": "garggaurav823",
                        "content": "class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n\\n        final_ans = \\'\\'\\n        i=0\\n\\n        for row in range(1,numRows+1):\\n            \\n            temp = i\\n            temp_ans = \\'\\'\\n\\n            while temp<len(s):\\n                temp_ans += s[temp]\\n                print(temp_ans,row)\\n\\n                if row == 1 or len(temp_ans)%2 != 0 and row != numRows:\\n                    temp_num = numRows - row\\n                    jump = 2 * temp_num - 1\\n\\n                else:\\n                    temp_num = row-1\\n                    jump = 2*temp_num - 1\\n\\n                temp+=jump+1\\n                if temp>len(s):\\n                    break\\n                \\n            final_ans += temp_ans\\n\\n            i+=1\\n\\n            if len(final_ans) == len(s):\\n                break\\n                        \\n        return final_ans\\n\\n\\nThe above code works fine on my interpreter but LeetCode\\'s interpreter has a bug or something, the program just loops back to row 1 again and again"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Can anybody tell me why is it showing TLE?\\n\\n `\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n    \\n        int l=s.size();\\n        string res=\"\";\\n        for(int i=0;i<numRows;i++)\\n        {\\n            if(i==0 || i==(numRows-1))\\n            {\\n                int j=i;\\n              // if I comment out the while loop then it does not give TLE\\n                while(j<l)\\n                {\\n                    res+=s[j];\\n                    j+=2*(numRows-1);\\n                }\\n             \\n            }\\n            else\\n            {\\n                int c=0;\\n                for(int j=i;j<l;)\\n                {\\n                    res+=s[j];\\n                    if(c%2==0)\\n                        j+=(numRows-i-1)*2;\\n                    else\\n                        j+=i*2;\\n                    c++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};`"
                    },
                    {
                        "username": "principoshi",
                        "content": "How is this in the most liked questions with an overwhelming number of actual \\'dislikes\\'?"
                    },
                    {
                        "username": "schuylermartin45",
                        "content": "Ah yes, I am allowed to pass as soon as I remove some debugging print statements. Glad I/O is my limiting factor, that seems fair."
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Sorry, but what are the rules or requirements for zigzag? If I randomly split a string in numRows parts it\\'s not correct, while it doesn\\'t violate the rules according to the task. Awful, 0 explanations."
                    },
                    {
                        "username": "dhwaj_03",
                        "content": "i did write the code, and it executed perfectly on my sublime ide but leetcode input is just not passing it write to the function. any ideas how to solve for this\\n"
                    }
                ]
            },
            {
                "id": 1839793,
                "content": [
                    {
                        "username": "lskook47",
                        "content": "In C, the test case does multiple calls for the target converting function"
                    },
                    {
                        "username": "pg99285",
                        "content": "This is Rail Fence Cipher Encryption."
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "The description of this is so confusing that I\\'m not even trying this. I\\'m a natural born english speaker with a decade of programming experience and I minored in Math in college."
                    },
                    {
                        "username": "Franco_20",
                        "content": "process exited with signal SIGILL\\n\\nFirstly, I wrote my program in my local machine. Then I copy all my code and insert it LeetCode. Usually it works! \\n\\nBut now, it\\'s giving me Runtime Error called: process exited with signal SIGILL\\n\\nFirst time facing this issue, is there anyone who can help me with this?\\n\\n `class Solution {\\n\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        var matrix: [[Character]] = []\\n\\nvar index = 1\\n\\n\\n\\nfunc goDown(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    index1 = 1\\n    //print(\"GO down\", terminator: \" \")\\n    for i in 0..<numRows-1{ // 0 1 2\\n        if index == s.count{\\n                    break\\n                }\\n        //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        \\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        index1 += 1\\n        index += 1\\n        \\n       \\n    }\\n    //print(\"\")\\n    index1 -= 1\\n}\\n//------------------------------------------------------------------\\nfunc goUp(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    //print(\"GO up\", terminator: \" \")\\n    index1 -= 1\\n    index2 += 1\\n    for i in 0..<numRows-1{\\n        if index == s.count{\\n            break\\n        }\\n                //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        \\n        \\n        index1 -= 1 \\n        index2 += 1 \\n        index += 1\\n            }\\n    index2 -= 1\\n    //print(\"\")\\n}\\n\\nfor i in 0..<numRows{\\n    matrix.append([])\\n    for j in 0..<s.count/2{\\n        matrix[i].append(\" \")\\n    }\\n}\\nmatrix[0][0] = (s[s.index(s.startIndex, offsetBy: 0)])\\n\\n\\nvar index1 = 1\\nvar index2 = 0\\n\\nwhile true {\\n    goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n    goUp(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n\\n    //goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    \\n    if index == s.count{\\n                        break\\n                    }\\n}\\n\\n\\n\\n\\n\\n//for i in 0..<numRows{\\n//   print(matrix[i])\\n//}\\nvar myString = \"\"\\nfor i in 0..<numRows{\\n    for j in 0..<s.count/2{\\n        if matrix[i][j] == \" \"{\\n            continue\\n        }else{\\n            //print(matrix[i][j], terminator: \"\")\\n            myString.append(matrix[i][j])\\n        }\\n    }\\n}\\n        return myString\\n    }\\n\\n}`"
                    },
                    {
                        "username": "garggaurav823",
                        "content": "class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n\\n        final_ans = \\'\\'\\n        i=0\\n\\n        for row in range(1,numRows+1):\\n            \\n            temp = i\\n            temp_ans = \\'\\'\\n\\n            while temp<len(s):\\n                temp_ans += s[temp]\\n                print(temp_ans,row)\\n\\n                if row == 1 or len(temp_ans)%2 != 0 and row != numRows:\\n                    temp_num = numRows - row\\n                    jump = 2 * temp_num - 1\\n\\n                else:\\n                    temp_num = row-1\\n                    jump = 2*temp_num - 1\\n\\n                temp+=jump+1\\n                if temp>len(s):\\n                    break\\n                \\n            final_ans += temp_ans\\n\\n            i+=1\\n\\n            if len(final_ans) == len(s):\\n                break\\n                        \\n        return final_ans\\n\\n\\nThe above code works fine on my interpreter but LeetCode\\'s interpreter has a bug or something, the program just loops back to row 1 again and again"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Can anybody tell me why is it showing TLE?\\n\\n `\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n    \\n        int l=s.size();\\n        string res=\"\";\\n        for(int i=0;i<numRows;i++)\\n        {\\n            if(i==0 || i==(numRows-1))\\n            {\\n                int j=i;\\n              // if I comment out the while loop then it does not give TLE\\n                while(j<l)\\n                {\\n                    res+=s[j];\\n                    j+=2*(numRows-1);\\n                }\\n             \\n            }\\n            else\\n            {\\n                int c=0;\\n                for(int j=i;j<l;)\\n                {\\n                    res+=s[j];\\n                    if(c%2==0)\\n                        j+=(numRows-i-1)*2;\\n                    else\\n                        j+=i*2;\\n                    c++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};`"
                    },
                    {
                        "username": "principoshi",
                        "content": "How is this in the most liked questions with an overwhelming number of actual \\'dislikes\\'?"
                    },
                    {
                        "username": "schuylermartin45",
                        "content": "Ah yes, I am allowed to pass as soon as I remove some debugging print statements. Glad I/O is my limiting factor, that seems fair."
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Sorry, but what are the rules or requirements for zigzag? If I randomly split a string in numRows parts it\\'s not correct, while it doesn\\'t violate the rules according to the task. Awful, 0 explanations."
                    },
                    {
                        "username": "dhwaj_03",
                        "content": "i did write the code, and it executed perfectly on my sublime ide but leetcode input is just not passing it write to the function. any ideas how to solve for this\\n"
                    }
                ]
            },
            {
                "id": 1836049,
                "content": [
                    {
                        "username": "lskook47",
                        "content": "In C, the test case does multiple calls for the target converting function"
                    },
                    {
                        "username": "pg99285",
                        "content": "This is Rail Fence Cipher Encryption."
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "The description of this is so confusing that I\\'m not even trying this. I\\'m a natural born english speaker with a decade of programming experience and I minored in Math in college."
                    },
                    {
                        "username": "Franco_20",
                        "content": "process exited with signal SIGILL\\n\\nFirstly, I wrote my program in my local machine. Then I copy all my code and insert it LeetCode. Usually it works! \\n\\nBut now, it\\'s giving me Runtime Error called: process exited with signal SIGILL\\n\\nFirst time facing this issue, is there anyone who can help me with this?\\n\\n `class Solution {\\n\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        var matrix: [[Character]] = []\\n\\nvar index = 1\\n\\n\\n\\nfunc goDown(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    index1 = 1\\n    //print(\"GO down\", terminator: \" \")\\n    for i in 0..<numRows-1{ // 0 1 2\\n        if index == s.count{\\n                    break\\n                }\\n        //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        \\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        index1 += 1\\n        index += 1\\n        \\n       \\n    }\\n    //print(\"\")\\n    index1 -= 1\\n}\\n//------------------------------------------------------------------\\nfunc goUp(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    //print(\"GO up\", terminator: \" \")\\n    index1 -= 1\\n    index2 += 1\\n    for i in 0..<numRows-1{\\n        if index == s.count{\\n            break\\n        }\\n                //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        \\n        \\n        index1 -= 1 \\n        index2 += 1 \\n        index += 1\\n            }\\n    index2 -= 1\\n    //print(\"\")\\n}\\n\\nfor i in 0..<numRows{\\n    matrix.append([])\\n    for j in 0..<s.count/2{\\n        matrix[i].append(\" \")\\n    }\\n}\\nmatrix[0][0] = (s[s.index(s.startIndex, offsetBy: 0)])\\n\\n\\nvar index1 = 1\\nvar index2 = 0\\n\\nwhile true {\\n    goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n    goUp(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n\\n    //goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    \\n    if index == s.count{\\n                        break\\n                    }\\n}\\n\\n\\n\\n\\n\\n//for i in 0..<numRows{\\n//   print(matrix[i])\\n//}\\nvar myString = \"\"\\nfor i in 0..<numRows{\\n    for j in 0..<s.count/2{\\n        if matrix[i][j] == \" \"{\\n            continue\\n        }else{\\n            //print(matrix[i][j], terminator: \"\")\\n            myString.append(matrix[i][j])\\n        }\\n    }\\n}\\n        return myString\\n    }\\n\\n}`"
                    },
                    {
                        "username": "garggaurav823",
                        "content": "class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n\\n        final_ans = \\'\\'\\n        i=0\\n\\n        for row in range(1,numRows+1):\\n            \\n            temp = i\\n            temp_ans = \\'\\'\\n\\n            while temp<len(s):\\n                temp_ans += s[temp]\\n                print(temp_ans,row)\\n\\n                if row == 1 or len(temp_ans)%2 != 0 and row != numRows:\\n                    temp_num = numRows - row\\n                    jump = 2 * temp_num - 1\\n\\n                else:\\n                    temp_num = row-1\\n                    jump = 2*temp_num - 1\\n\\n                temp+=jump+1\\n                if temp>len(s):\\n                    break\\n                \\n            final_ans += temp_ans\\n\\n            i+=1\\n\\n            if len(final_ans) == len(s):\\n                break\\n                        \\n        return final_ans\\n\\n\\nThe above code works fine on my interpreter but LeetCode\\'s interpreter has a bug or something, the program just loops back to row 1 again and again"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Can anybody tell me why is it showing TLE?\\n\\n `\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n    \\n        int l=s.size();\\n        string res=\"\";\\n        for(int i=0;i<numRows;i++)\\n        {\\n            if(i==0 || i==(numRows-1))\\n            {\\n                int j=i;\\n              // if I comment out the while loop then it does not give TLE\\n                while(j<l)\\n                {\\n                    res+=s[j];\\n                    j+=2*(numRows-1);\\n                }\\n             \\n            }\\n            else\\n            {\\n                int c=0;\\n                for(int j=i;j<l;)\\n                {\\n                    res+=s[j];\\n                    if(c%2==0)\\n                        j+=(numRows-i-1)*2;\\n                    else\\n                        j+=i*2;\\n                    c++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};`"
                    },
                    {
                        "username": "principoshi",
                        "content": "How is this in the most liked questions with an overwhelming number of actual \\'dislikes\\'?"
                    },
                    {
                        "username": "schuylermartin45",
                        "content": "Ah yes, I am allowed to pass as soon as I remove some debugging print statements. Glad I/O is my limiting factor, that seems fair."
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Sorry, but what are the rules or requirements for zigzag? If I randomly split a string in numRows parts it\\'s not correct, while it doesn\\'t violate the rules according to the task. Awful, 0 explanations."
                    },
                    {
                        "username": "dhwaj_03",
                        "content": "i did write the code, and it executed perfectly on my sublime ide but leetcode input is just not passing it write to the function. any ideas how to solve for this\\n"
                    }
                ]
            },
            {
                "id": 1834011,
                "content": [
                    {
                        "username": "lskook47",
                        "content": "In C, the test case does multiple calls for the target converting function"
                    },
                    {
                        "username": "pg99285",
                        "content": "This is Rail Fence Cipher Encryption."
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "The description of this is so confusing that I\\'m not even trying this. I\\'m a natural born english speaker with a decade of programming experience and I minored in Math in college."
                    },
                    {
                        "username": "Franco_20",
                        "content": "process exited with signal SIGILL\\n\\nFirstly, I wrote my program in my local machine. Then I copy all my code and insert it LeetCode. Usually it works! \\n\\nBut now, it\\'s giving me Runtime Error called: process exited with signal SIGILL\\n\\nFirst time facing this issue, is there anyone who can help me with this?\\n\\n `class Solution {\\n\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        var matrix: [[Character]] = []\\n\\nvar index = 1\\n\\n\\n\\nfunc goDown(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    index1 = 1\\n    //print(\"GO down\", terminator: \" \")\\n    for i in 0..<numRows-1{ // 0 1 2\\n        if index == s.count{\\n                    break\\n                }\\n        //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        \\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        index1 += 1\\n        index += 1\\n        \\n       \\n    }\\n    //print(\"\")\\n    index1 -= 1\\n}\\n//------------------------------------------------------------------\\nfunc goUp(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    //print(\"GO up\", terminator: \" \")\\n    index1 -= 1\\n    index2 += 1\\n    for i in 0..<numRows-1{\\n        if index == s.count{\\n            break\\n        }\\n                //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        \\n        \\n        index1 -= 1 \\n        index2 += 1 \\n        index += 1\\n            }\\n    index2 -= 1\\n    //print(\"\")\\n}\\n\\nfor i in 0..<numRows{\\n    matrix.append([])\\n    for j in 0..<s.count/2{\\n        matrix[i].append(\" \")\\n    }\\n}\\nmatrix[0][0] = (s[s.index(s.startIndex, offsetBy: 0)])\\n\\n\\nvar index1 = 1\\nvar index2 = 0\\n\\nwhile true {\\n    goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n    goUp(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n\\n    //goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    \\n    if index == s.count{\\n                        break\\n                    }\\n}\\n\\n\\n\\n\\n\\n//for i in 0..<numRows{\\n//   print(matrix[i])\\n//}\\nvar myString = \"\"\\nfor i in 0..<numRows{\\n    for j in 0..<s.count/2{\\n        if matrix[i][j] == \" \"{\\n            continue\\n        }else{\\n            //print(matrix[i][j], terminator: \"\")\\n            myString.append(matrix[i][j])\\n        }\\n    }\\n}\\n        return myString\\n    }\\n\\n}`"
                    },
                    {
                        "username": "garggaurav823",
                        "content": "class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n\\n        final_ans = \\'\\'\\n        i=0\\n\\n        for row in range(1,numRows+1):\\n            \\n            temp = i\\n            temp_ans = \\'\\'\\n\\n            while temp<len(s):\\n                temp_ans += s[temp]\\n                print(temp_ans,row)\\n\\n                if row == 1 or len(temp_ans)%2 != 0 and row != numRows:\\n                    temp_num = numRows - row\\n                    jump = 2 * temp_num - 1\\n\\n                else:\\n                    temp_num = row-1\\n                    jump = 2*temp_num - 1\\n\\n                temp+=jump+1\\n                if temp>len(s):\\n                    break\\n                \\n            final_ans += temp_ans\\n\\n            i+=1\\n\\n            if len(final_ans) == len(s):\\n                break\\n                        \\n        return final_ans\\n\\n\\nThe above code works fine on my interpreter but LeetCode\\'s interpreter has a bug or something, the program just loops back to row 1 again and again"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Can anybody tell me why is it showing TLE?\\n\\n `\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n    \\n        int l=s.size();\\n        string res=\"\";\\n        for(int i=0;i<numRows;i++)\\n        {\\n            if(i==0 || i==(numRows-1))\\n            {\\n                int j=i;\\n              // if I comment out the while loop then it does not give TLE\\n                while(j<l)\\n                {\\n                    res+=s[j];\\n                    j+=2*(numRows-1);\\n                }\\n             \\n            }\\n            else\\n            {\\n                int c=0;\\n                for(int j=i;j<l;)\\n                {\\n                    res+=s[j];\\n                    if(c%2==0)\\n                        j+=(numRows-i-1)*2;\\n                    else\\n                        j+=i*2;\\n                    c++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};`"
                    },
                    {
                        "username": "principoshi",
                        "content": "How is this in the most liked questions with an overwhelming number of actual \\'dislikes\\'?"
                    },
                    {
                        "username": "schuylermartin45",
                        "content": "Ah yes, I am allowed to pass as soon as I remove some debugging print statements. Glad I/O is my limiting factor, that seems fair."
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Sorry, but what are the rules or requirements for zigzag? If I randomly split a string in numRows parts it\\'s not correct, while it doesn\\'t violate the rules according to the task. Awful, 0 explanations."
                    },
                    {
                        "username": "dhwaj_03",
                        "content": "i did write the code, and it executed perfectly on my sublime ide but leetcode input is just not passing it write to the function. any ideas how to solve for this\\n"
                    }
                ]
            },
            {
                "id": 1827028,
                "content": [
                    {
                        "username": "lskook47",
                        "content": "In C, the test case does multiple calls for the target converting function"
                    },
                    {
                        "username": "pg99285",
                        "content": "This is Rail Fence Cipher Encryption."
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "The description of this is so confusing that I\\'m not even trying this. I\\'m a natural born english speaker with a decade of programming experience and I minored in Math in college."
                    },
                    {
                        "username": "Franco_20",
                        "content": "process exited with signal SIGILL\\n\\nFirstly, I wrote my program in my local machine. Then I copy all my code and insert it LeetCode. Usually it works! \\n\\nBut now, it\\'s giving me Runtime Error called: process exited with signal SIGILL\\n\\nFirst time facing this issue, is there anyone who can help me with this?\\n\\n `class Solution {\\n\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        var matrix: [[Character]] = []\\n\\nvar index = 1\\n\\n\\n\\nfunc goDown(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    index1 = 1\\n    //print(\"GO down\", terminator: \" \")\\n    for i in 0..<numRows-1{ // 0 1 2\\n        if index == s.count{\\n                    break\\n                }\\n        //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        \\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        index1 += 1\\n        index += 1\\n        \\n       \\n    }\\n    //print(\"\")\\n    index1 -= 1\\n}\\n//------------------------------------------------------------------\\nfunc goUp(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    //print(\"GO up\", terminator: \" \")\\n    index1 -= 1\\n    index2 += 1\\n    for i in 0..<numRows-1{\\n        if index == s.count{\\n            break\\n        }\\n                //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        \\n        \\n        index1 -= 1 \\n        index2 += 1 \\n        index += 1\\n            }\\n    index2 -= 1\\n    //print(\"\")\\n}\\n\\nfor i in 0..<numRows{\\n    matrix.append([])\\n    for j in 0..<s.count/2{\\n        matrix[i].append(\" \")\\n    }\\n}\\nmatrix[0][0] = (s[s.index(s.startIndex, offsetBy: 0)])\\n\\n\\nvar index1 = 1\\nvar index2 = 0\\n\\nwhile true {\\n    goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n    goUp(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n\\n    //goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    \\n    if index == s.count{\\n                        break\\n                    }\\n}\\n\\n\\n\\n\\n\\n//for i in 0..<numRows{\\n//   print(matrix[i])\\n//}\\nvar myString = \"\"\\nfor i in 0..<numRows{\\n    for j in 0..<s.count/2{\\n        if matrix[i][j] == \" \"{\\n            continue\\n        }else{\\n            //print(matrix[i][j], terminator: \"\")\\n            myString.append(matrix[i][j])\\n        }\\n    }\\n}\\n        return myString\\n    }\\n\\n}`"
                    },
                    {
                        "username": "garggaurav823",
                        "content": "class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n\\n        final_ans = \\'\\'\\n        i=0\\n\\n        for row in range(1,numRows+1):\\n            \\n            temp = i\\n            temp_ans = \\'\\'\\n\\n            while temp<len(s):\\n                temp_ans += s[temp]\\n                print(temp_ans,row)\\n\\n                if row == 1 or len(temp_ans)%2 != 0 and row != numRows:\\n                    temp_num = numRows - row\\n                    jump = 2 * temp_num - 1\\n\\n                else:\\n                    temp_num = row-1\\n                    jump = 2*temp_num - 1\\n\\n                temp+=jump+1\\n                if temp>len(s):\\n                    break\\n                \\n            final_ans += temp_ans\\n\\n            i+=1\\n\\n            if len(final_ans) == len(s):\\n                break\\n                        \\n        return final_ans\\n\\n\\nThe above code works fine on my interpreter but LeetCode\\'s interpreter has a bug or something, the program just loops back to row 1 again and again"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Can anybody tell me why is it showing TLE?\\n\\n `\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n    \\n        int l=s.size();\\n        string res=\"\";\\n        for(int i=0;i<numRows;i++)\\n        {\\n            if(i==0 || i==(numRows-1))\\n            {\\n                int j=i;\\n              // if I comment out the while loop then it does not give TLE\\n                while(j<l)\\n                {\\n                    res+=s[j];\\n                    j+=2*(numRows-1);\\n                }\\n             \\n            }\\n            else\\n            {\\n                int c=0;\\n                for(int j=i;j<l;)\\n                {\\n                    res+=s[j];\\n                    if(c%2==0)\\n                        j+=(numRows-i-1)*2;\\n                    else\\n                        j+=i*2;\\n                    c++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};`"
                    },
                    {
                        "username": "principoshi",
                        "content": "How is this in the most liked questions with an overwhelming number of actual \\'dislikes\\'?"
                    },
                    {
                        "username": "schuylermartin45",
                        "content": "Ah yes, I am allowed to pass as soon as I remove some debugging print statements. Glad I/O is my limiting factor, that seems fair."
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Sorry, but what are the rules or requirements for zigzag? If I randomly split a string in numRows parts it\\'s not correct, while it doesn\\'t violate the rules according to the task. Awful, 0 explanations."
                    },
                    {
                        "username": "dhwaj_03",
                        "content": "i did write the code, and it executed perfectly on my sublime ide but leetcode input is just not passing it write to the function. any ideas how to solve for this\\n"
                    }
                ]
            },
            {
                "id": 1825174,
                "content": [
                    {
                        "username": "lskook47",
                        "content": "In C, the test case does multiple calls for the target converting function"
                    },
                    {
                        "username": "pg99285",
                        "content": "This is Rail Fence Cipher Encryption."
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "The description of this is so confusing that I\\'m not even trying this. I\\'m a natural born english speaker with a decade of programming experience and I minored in Math in college."
                    },
                    {
                        "username": "Franco_20",
                        "content": "process exited with signal SIGILL\\n\\nFirstly, I wrote my program in my local machine. Then I copy all my code and insert it LeetCode. Usually it works! \\n\\nBut now, it\\'s giving me Runtime Error called: process exited with signal SIGILL\\n\\nFirst time facing this issue, is there anyone who can help me with this?\\n\\n `class Solution {\\n\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        var matrix: [[Character]] = []\\n\\nvar index = 1\\n\\n\\n\\nfunc goDown(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    index1 = 1\\n    //print(\"GO down\", terminator: \" \")\\n    for i in 0..<numRows-1{ // 0 1 2\\n        if index == s.count{\\n                    break\\n                }\\n        //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        \\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        index1 += 1\\n        index += 1\\n        \\n       \\n    }\\n    //print(\"\")\\n    index1 -= 1\\n}\\n//------------------------------------------------------------------\\nfunc goUp(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    //print(\"GO up\", terminator: \" \")\\n    index1 -= 1\\n    index2 += 1\\n    for i in 0..<numRows-1{\\n        if index == s.count{\\n            break\\n        }\\n                //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        \\n        \\n        index1 -= 1 \\n        index2 += 1 \\n        index += 1\\n            }\\n    index2 -= 1\\n    //print(\"\")\\n}\\n\\nfor i in 0..<numRows{\\n    matrix.append([])\\n    for j in 0..<s.count/2{\\n        matrix[i].append(\" \")\\n    }\\n}\\nmatrix[0][0] = (s[s.index(s.startIndex, offsetBy: 0)])\\n\\n\\nvar index1 = 1\\nvar index2 = 0\\n\\nwhile true {\\n    goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n    goUp(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n\\n    //goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    \\n    if index == s.count{\\n                        break\\n                    }\\n}\\n\\n\\n\\n\\n\\n//for i in 0..<numRows{\\n//   print(matrix[i])\\n//}\\nvar myString = \"\"\\nfor i in 0..<numRows{\\n    for j in 0..<s.count/2{\\n        if matrix[i][j] == \" \"{\\n            continue\\n        }else{\\n            //print(matrix[i][j], terminator: \"\")\\n            myString.append(matrix[i][j])\\n        }\\n    }\\n}\\n        return myString\\n    }\\n\\n}`"
                    },
                    {
                        "username": "garggaurav823",
                        "content": "class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n\\n        final_ans = \\'\\'\\n        i=0\\n\\n        for row in range(1,numRows+1):\\n            \\n            temp = i\\n            temp_ans = \\'\\'\\n\\n            while temp<len(s):\\n                temp_ans += s[temp]\\n                print(temp_ans,row)\\n\\n                if row == 1 or len(temp_ans)%2 != 0 and row != numRows:\\n                    temp_num = numRows - row\\n                    jump = 2 * temp_num - 1\\n\\n                else:\\n                    temp_num = row-1\\n                    jump = 2*temp_num - 1\\n\\n                temp+=jump+1\\n                if temp>len(s):\\n                    break\\n                \\n            final_ans += temp_ans\\n\\n            i+=1\\n\\n            if len(final_ans) == len(s):\\n                break\\n                        \\n        return final_ans\\n\\n\\nThe above code works fine on my interpreter but LeetCode\\'s interpreter has a bug or something, the program just loops back to row 1 again and again"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Can anybody tell me why is it showing TLE?\\n\\n `\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n    \\n        int l=s.size();\\n        string res=\"\";\\n        for(int i=0;i<numRows;i++)\\n        {\\n            if(i==0 || i==(numRows-1))\\n            {\\n                int j=i;\\n              // if I comment out the while loop then it does not give TLE\\n                while(j<l)\\n                {\\n                    res+=s[j];\\n                    j+=2*(numRows-1);\\n                }\\n             \\n            }\\n            else\\n            {\\n                int c=0;\\n                for(int j=i;j<l;)\\n                {\\n                    res+=s[j];\\n                    if(c%2==0)\\n                        j+=(numRows-i-1)*2;\\n                    else\\n                        j+=i*2;\\n                    c++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};`"
                    },
                    {
                        "username": "principoshi",
                        "content": "How is this in the most liked questions with an overwhelming number of actual \\'dislikes\\'?"
                    },
                    {
                        "username": "schuylermartin45",
                        "content": "Ah yes, I am allowed to pass as soon as I remove some debugging print statements. Glad I/O is my limiting factor, that seems fair."
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Sorry, but what are the rules or requirements for zigzag? If I randomly split a string in numRows parts it\\'s not correct, while it doesn\\'t violate the rules according to the task. Awful, 0 explanations."
                    },
                    {
                        "username": "dhwaj_03",
                        "content": "i did write the code, and it executed perfectly on my sublime ide but leetcode input is just not passing it write to the function. any ideas how to solve for this\\n"
                    }
                ]
            },
            {
                "id": 1802342,
                "content": [
                    {
                        "username": "lskook47",
                        "content": "In C, the test case does multiple calls for the target converting function"
                    },
                    {
                        "username": "pg99285",
                        "content": "This is Rail Fence Cipher Encryption."
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "The description of this is so confusing that I\\'m not even trying this. I\\'m a natural born english speaker with a decade of programming experience and I minored in Math in college."
                    },
                    {
                        "username": "Franco_20",
                        "content": "process exited with signal SIGILL\\n\\nFirstly, I wrote my program in my local machine. Then I copy all my code and insert it LeetCode. Usually it works! \\n\\nBut now, it\\'s giving me Runtime Error called: process exited with signal SIGILL\\n\\nFirst time facing this issue, is there anyone who can help me with this?\\n\\n `class Solution {\\n\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        var matrix: [[Character]] = []\\n\\nvar index = 1\\n\\n\\n\\nfunc goDown(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    index1 = 1\\n    //print(\"GO down\", terminator: \" \")\\n    for i in 0..<numRows-1{ // 0 1 2\\n        if index == s.count{\\n                    break\\n                }\\n        //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        \\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        index1 += 1\\n        index += 1\\n        \\n       \\n    }\\n    //print(\"\")\\n    index1 -= 1\\n}\\n//------------------------------------------------------------------\\nfunc goUp(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    //print(\"GO up\", terminator: \" \")\\n    index1 -= 1\\n    index2 += 1\\n    for i in 0..<numRows-1{\\n        if index == s.count{\\n            break\\n        }\\n                //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        \\n        \\n        index1 -= 1 \\n        index2 += 1 \\n        index += 1\\n            }\\n    index2 -= 1\\n    //print(\"\")\\n}\\n\\nfor i in 0..<numRows{\\n    matrix.append([])\\n    for j in 0..<s.count/2{\\n        matrix[i].append(\" \")\\n    }\\n}\\nmatrix[0][0] = (s[s.index(s.startIndex, offsetBy: 0)])\\n\\n\\nvar index1 = 1\\nvar index2 = 0\\n\\nwhile true {\\n    goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n    goUp(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n\\n    //goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    \\n    if index == s.count{\\n                        break\\n                    }\\n}\\n\\n\\n\\n\\n\\n//for i in 0..<numRows{\\n//   print(matrix[i])\\n//}\\nvar myString = \"\"\\nfor i in 0..<numRows{\\n    for j in 0..<s.count/2{\\n        if matrix[i][j] == \" \"{\\n            continue\\n        }else{\\n            //print(matrix[i][j], terminator: \"\")\\n            myString.append(matrix[i][j])\\n        }\\n    }\\n}\\n        return myString\\n    }\\n\\n}`"
                    },
                    {
                        "username": "garggaurav823",
                        "content": "class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n\\n        final_ans = \\'\\'\\n        i=0\\n\\n        for row in range(1,numRows+1):\\n            \\n            temp = i\\n            temp_ans = \\'\\'\\n\\n            while temp<len(s):\\n                temp_ans += s[temp]\\n                print(temp_ans,row)\\n\\n                if row == 1 or len(temp_ans)%2 != 0 and row != numRows:\\n                    temp_num = numRows - row\\n                    jump = 2 * temp_num - 1\\n\\n                else:\\n                    temp_num = row-1\\n                    jump = 2*temp_num - 1\\n\\n                temp+=jump+1\\n                if temp>len(s):\\n                    break\\n                \\n            final_ans += temp_ans\\n\\n            i+=1\\n\\n            if len(final_ans) == len(s):\\n                break\\n                        \\n        return final_ans\\n\\n\\nThe above code works fine on my interpreter but LeetCode\\'s interpreter has a bug or something, the program just loops back to row 1 again and again"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Can anybody tell me why is it showing TLE?\\n\\n `\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n    \\n        int l=s.size();\\n        string res=\"\";\\n        for(int i=0;i<numRows;i++)\\n        {\\n            if(i==0 || i==(numRows-1))\\n            {\\n                int j=i;\\n              // if I comment out the while loop then it does not give TLE\\n                while(j<l)\\n                {\\n                    res+=s[j];\\n                    j+=2*(numRows-1);\\n                }\\n             \\n            }\\n            else\\n            {\\n                int c=0;\\n                for(int j=i;j<l;)\\n                {\\n                    res+=s[j];\\n                    if(c%2==0)\\n                        j+=(numRows-i-1)*2;\\n                    else\\n                        j+=i*2;\\n                    c++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};`"
                    },
                    {
                        "username": "principoshi",
                        "content": "How is this in the most liked questions with an overwhelming number of actual \\'dislikes\\'?"
                    },
                    {
                        "username": "schuylermartin45",
                        "content": "Ah yes, I am allowed to pass as soon as I remove some debugging print statements. Glad I/O is my limiting factor, that seems fair."
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Sorry, but what are the rules or requirements for zigzag? If I randomly split a string in numRows parts it\\'s not correct, while it doesn\\'t violate the rules according to the task. Awful, 0 explanations."
                    },
                    {
                        "username": "dhwaj_03",
                        "content": "i did write the code, and it executed perfectly on my sublime ide but leetcode input is just not passing it write to the function. any ideas how to solve for this\\n"
                    }
                ]
            },
            {
                "id": 1792117,
                "content": [
                    {
                        "username": "lskook47",
                        "content": "In C, the test case does multiple calls for the target converting function"
                    },
                    {
                        "username": "pg99285",
                        "content": "This is Rail Fence Cipher Encryption."
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "The description of this is so confusing that I\\'m not even trying this. I\\'m a natural born english speaker with a decade of programming experience and I minored in Math in college."
                    },
                    {
                        "username": "Franco_20",
                        "content": "process exited with signal SIGILL\\n\\nFirstly, I wrote my program in my local machine. Then I copy all my code and insert it LeetCode. Usually it works! \\n\\nBut now, it\\'s giving me Runtime Error called: process exited with signal SIGILL\\n\\nFirst time facing this issue, is there anyone who can help me with this?\\n\\n `class Solution {\\n\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        var matrix: [[Character]] = []\\n\\nvar index = 1\\n\\n\\n\\nfunc goDown(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    index1 = 1\\n    //print(\"GO down\", terminator: \" \")\\n    for i in 0..<numRows-1{ // 0 1 2\\n        if index == s.count{\\n                    break\\n                }\\n        //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        \\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        index1 += 1\\n        index += 1\\n        \\n       \\n    }\\n    //print(\"\")\\n    index1 -= 1\\n}\\n//------------------------------------------------------------------\\nfunc goUp(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    //print(\"GO up\", terminator: \" \")\\n    index1 -= 1\\n    index2 += 1\\n    for i in 0..<numRows-1{\\n        if index == s.count{\\n            break\\n        }\\n                //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        \\n        \\n        index1 -= 1 \\n        index2 += 1 \\n        index += 1\\n            }\\n    index2 -= 1\\n    //print(\"\")\\n}\\n\\nfor i in 0..<numRows{\\n    matrix.append([])\\n    for j in 0..<s.count/2{\\n        matrix[i].append(\" \")\\n    }\\n}\\nmatrix[0][0] = (s[s.index(s.startIndex, offsetBy: 0)])\\n\\n\\nvar index1 = 1\\nvar index2 = 0\\n\\nwhile true {\\n    goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n    goUp(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n\\n    //goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    \\n    if index == s.count{\\n                        break\\n                    }\\n}\\n\\n\\n\\n\\n\\n//for i in 0..<numRows{\\n//   print(matrix[i])\\n//}\\nvar myString = \"\"\\nfor i in 0..<numRows{\\n    for j in 0..<s.count/2{\\n        if matrix[i][j] == \" \"{\\n            continue\\n        }else{\\n            //print(matrix[i][j], terminator: \"\")\\n            myString.append(matrix[i][j])\\n        }\\n    }\\n}\\n        return myString\\n    }\\n\\n}`"
                    },
                    {
                        "username": "garggaurav823",
                        "content": "class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n\\n        final_ans = \\'\\'\\n        i=0\\n\\n        for row in range(1,numRows+1):\\n            \\n            temp = i\\n            temp_ans = \\'\\'\\n\\n            while temp<len(s):\\n                temp_ans += s[temp]\\n                print(temp_ans,row)\\n\\n                if row == 1 or len(temp_ans)%2 != 0 and row != numRows:\\n                    temp_num = numRows - row\\n                    jump = 2 * temp_num - 1\\n\\n                else:\\n                    temp_num = row-1\\n                    jump = 2*temp_num - 1\\n\\n                temp+=jump+1\\n                if temp>len(s):\\n                    break\\n                \\n            final_ans += temp_ans\\n\\n            i+=1\\n\\n            if len(final_ans) == len(s):\\n                break\\n                        \\n        return final_ans\\n\\n\\nThe above code works fine on my interpreter but LeetCode\\'s interpreter has a bug or something, the program just loops back to row 1 again and again"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Can anybody tell me why is it showing TLE?\\n\\n `\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n    \\n        int l=s.size();\\n        string res=\"\";\\n        for(int i=0;i<numRows;i++)\\n        {\\n            if(i==0 || i==(numRows-1))\\n            {\\n                int j=i;\\n              // if I comment out the while loop then it does not give TLE\\n                while(j<l)\\n                {\\n                    res+=s[j];\\n                    j+=2*(numRows-1);\\n                }\\n             \\n            }\\n            else\\n            {\\n                int c=0;\\n                for(int j=i;j<l;)\\n                {\\n                    res+=s[j];\\n                    if(c%2==0)\\n                        j+=(numRows-i-1)*2;\\n                    else\\n                        j+=i*2;\\n                    c++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};`"
                    },
                    {
                        "username": "principoshi",
                        "content": "How is this in the most liked questions with an overwhelming number of actual \\'dislikes\\'?"
                    },
                    {
                        "username": "schuylermartin45",
                        "content": "Ah yes, I am allowed to pass as soon as I remove some debugging print statements. Glad I/O is my limiting factor, that seems fair."
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Sorry, but what are the rules or requirements for zigzag? If I randomly split a string in numRows parts it\\'s not correct, while it doesn\\'t violate the rules according to the task. Awful, 0 explanations."
                    },
                    {
                        "username": "dhwaj_03",
                        "content": "i did write the code, and it executed perfectly on my sublime ide but leetcode input is just not passing it write to the function. any ideas how to solve for this\\n"
                    }
                ]
            },
            {
                "id": 1789797,
                "content": [
                    {
                        "username": "lskook47",
                        "content": "In C, the test case does multiple calls for the target converting function"
                    },
                    {
                        "username": "pg99285",
                        "content": "This is Rail Fence Cipher Encryption."
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "The description of this is so confusing that I\\'m not even trying this. I\\'m a natural born english speaker with a decade of programming experience and I minored in Math in college."
                    },
                    {
                        "username": "Franco_20",
                        "content": "process exited with signal SIGILL\\n\\nFirstly, I wrote my program in my local machine. Then I copy all my code and insert it LeetCode. Usually it works! \\n\\nBut now, it\\'s giving me Runtime Error called: process exited with signal SIGILL\\n\\nFirst time facing this issue, is there anyone who can help me with this?\\n\\n `class Solution {\\n\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        var matrix: [[Character]] = []\\n\\nvar index = 1\\n\\n\\n\\nfunc goDown(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    index1 = 1\\n    //print(\"GO down\", terminator: \" \")\\n    for i in 0..<numRows-1{ // 0 1 2\\n        if index == s.count{\\n                    break\\n                }\\n        //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        \\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        index1 += 1\\n        index += 1\\n        \\n       \\n    }\\n    //print(\"\")\\n    index1 -= 1\\n}\\n//------------------------------------------------------------------\\nfunc goUp(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    //print(\"GO up\", terminator: \" \")\\n    index1 -= 1\\n    index2 += 1\\n    for i in 0..<numRows-1{\\n        if index == s.count{\\n            break\\n        }\\n                //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        \\n        \\n        index1 -= 1 \\n        index2 += 1 \\n        index += 1\\n            }\\n    index2 -= 1\\n    //print(\"\")\\n}\\n\\nfor i in 0..<numRows{\\n    matrix.append([])\\n    for j in 0..<s.count/2{\\n        matrix[i].append(\" \")\\n    }\\n}\\nmatrix[0][0] = (s[s.index(s.startIndex, offsetBy: 0)])\\n\\n\\nvar index1 = 1\\nvar index2 = 0\\n\\nwhile true {\\n    goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n    goUp(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n\\n    //goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    \\n    if index == s.count{\\n                        break\\n                    }\\n}\\n\\n\\n\\n\\n\\n//for i in 0..<numRows{\\n//   print(matrix[i])\\n//}\\nvar myString = \"\"\\nfor i in 0..<numRows{\\n    for j in 0..<s.count/2{\\n        if matrix[i][j] == \" \"{\\n            continue\\n        }else{\\n            //print(matrix[i][j], terminator: \"\")\\n            myString.append(matrix[i][j])\\n        }\\n    }\\n}\\n        return myString\\n    }\\n\\n}`"
                    },
                    {
                        "username": "garggaurav823",
                        "content": "class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n\\n        final_ans = \\'\\'\\n        i=0\\n\\n        for row in range(1,numRows+1):\\n            \\n            temp = i\\n            temp_ans = \\'\\'\\n\\n            while temp<len(s):\\n                temp_ans += s[temp]\\n                print(temp_ans,row)\\n\\n                if row == 1 or len(temp_ans)%2 != 0 and row != numRows:\\n                    temp_num = numRows - row\\n                    jump = 2 * temp_num - 1\\n\\n                else:\\n                    temp_num = row-1\\n                    jump = 2*temp_num - 1\\n\\n                temp+=jump+1\\n                if temp>len(s):\\n                    break\\n                \\n            final_ans += temp_ans\\n\\n            i+=1\\n\\n            if len(final_ans) == len(s):\\n                break\\n                        \\n        return final_ans\\n\\n\\nThe above code works fine on my interpreter but LeetCode\\'s interpreter has a bug or something, the program just loops back to row 1 again and again"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Can anybody tell me why is it showing TLE?\\n\\n `\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n    \\n        int l=s.size();\\n        string res=\"\";\\n        for(int i=0;i<numRows;i++)\\n        {\\n            if(i==0 || i==(numRows-1))\\n            {\\n                int j=i;\\n              // if I comment out the while loop then it does not give TLE\\n                while(j<l)\\n                {\\n                    res+=s[j];\\n                    j+=2*(numRows-1);\\n                }\\n             \\n            }\\n            else\\n            {\\n                int c=0;\\n                for(int j=i;j<l;)\\n                {\\n                    res+=s[j];\\n                    if(c%2==0)\\n                        j+=(numRows-i-1)*2;\\n                    else\\n                        j+=i*2;\\n                    c++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};`"
                    },
                    {
                        "username": "principoshi",
                        "content": "How is this in the most liked questions with an overwhelming number of actual \\'dislikes\\'?"
                    },
                    {
                        "username": "schuylermartin45",
                        "content": "Ah yes, I am allowed to pass as soon as I remove some debugging print statements. Glad I/O is my limiting factor, that seems fair."
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Sorry, but what are the rules or requirements for zigzag? If I randomly split a string in numRows parts it\\'s not correct, while it doesn\\'t violate the rules according to the task. Awful, 0 explanations."
                    },
                    {
                        "username": "dhwaj_03",
                        "content": "i did write the code, and it executed perfectly on my sublime ide but leetcode input is just not passing it write to the function. any ideas how to solve for this\\n"
                    }
                ]
            },
            {
                "id": 1787187,
                "content": [
                    {
                        "username": "lskook47",
                        "content": "In C, the test case does multiple calls for the target converting function"
                    },
                    {
                        "username": "pg99285",
                        "content": "This is Rail Fence Cipher Encryption."
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "The description of this is so confusing that I\\'m not even trying this. I\\'m a natural born english speaker with a decade of programming experience and I minored in Math in college."
                    },
                    {
                        "username": "Franco_20",
                        "content": "process exited with signal SIGILL\\n\\nFirstly, I wrote my program in my local machine. Then I copy all my code and insert it LeetCode. Usually it works! \\n\\nBut now, it\\'s giving me Runtime Error called: process exited with signal SIGILL\\n\\nFirst time facing this issue, is there anyone who can help me with this?\\n\\n `class Solution {\\n\\n    func convert(_ s: String, _ numRows: Int) -> String {\\n        var matrix: [[Character]] = []\\n\\nvar index = 1\\n\\n\\n\\nfunc goDown(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    index1 = 1\\n    //print(\"GO down\", terminator: \" \")\\n    for i in 0..<numRows-1{ // 0 1 2\\n        if index == s.count{\\n                    break\\n                }\\n        //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        \\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        index1 += 1\\n        index += 1\\n        \\n       \\n    }\\n    //print(\"\")\\n    index1 -= 1\\n}\\n//------------------------------------------------------------------\\nfunc goUp(_ matrix: inout [[Character]], _ index1: inout Int, _ index2: inout Int, _ s: String, _ numRows: Int, _ index: inout Int){\\n    //print(\"GO up\", terminator: \" \")\\n    index1 -= 1\\n    index2 += 1\\n    for i in 0..<numRows-1{\\n        if index == s.count{\\n            break\\n        }\\n                //print(\"\\\\(index1),\\\\(index2)\", terminator: \" \")\\n        matrix[index1][index2] = (s[s.index(s.startIndex, offsetBy: index)])\\n        \\n        \\n        index1 -= 1 \\n        index2 += 1 \\n        index += 1\\n            }\\n    index2 -= 1\\n    //print(\"\")\\n}\\n\\nfor i in 0..<numRows{\\n    matrix.append([])\\n    for j in 0..<s.count/2{\\n        matrix[i].append(\" \")\\n    }\\n}\\nmatrix[0][0] = (s[s.index(s.startIndex, offsetBy: 0)])\\n\\n\\nvar index1 = 1\\nvar index2 = 0\\n\\nwhile true {\\n    goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n    goUp(&matrix, &index1, &index2, s, numRows, &index)\\n    //print(index1, index2)\\n\\n    //goDown(&matrix, &index1, &index2, s, numRows, &index)\\n    \\n    if index == s.count{\\n                        break\\n                    }\\n}\\n\\n\\n\\n\\n\\n//for i in 0..<numRows{\\n//   print(matrix[i])\\n//}\\nvar myString = \"\"\\nfor i in 0..<numRows{\\n    for j in 0..<s.count/2{\\n        if matrix[i][j] == \" \"{\\n            continue\\n        }else{\\n            //print(matrix[i][j], terminator: \"\")\\n            myString.append(matrix[i][j])\\n        }\\n    }\\n}\\n        return myString\\n    }\\n\\n}`"
                    },
                    {
                        "username": "garggaurav823",
                        "content": "class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n\\n        final_ans = \\'\\'\\n        i=0\\n\\n        for row in range(1,numRows+1):\\n            \\n            temp = i\\n            temp_ans = \\'\\'\\n\\n            while temp<len(s):\\n                temp_ans += s[temp]\\n                print(temp_ans,row)\\n\\n                if row == 1 or len(temp_ans)%2 != 0 and row != numRows:\\n                    temp_num = numRows - row\\n                    jump = 2 * temp_num - 1\\n\\n                else:\\n                    temp_num = row-1\\n                    jump = 2*temp_num - 1\\n\\n                temp+=jump+1\\n                if temp>len(s):\\n                    break\\n                \\n            final_ans += temp_ans\\n\\n            i+=1\\n\\n            if len(final_ans) == len(s):\\n                break\\n                        \\n        return final_ans\\n\\n\\nThe above code works fine on my interpreter but LeetCode\\'s interpreter has a bug or something, the program just loops back to row 1 again and again"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Can anybody tell me why is it showing TLE?\\n\\n `\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n    \\n        int l=s.size();\\n        string res=\"\";\\n        for(int i=0;i<numRows;i++)\\n        {\\n            if(i==0 || i==(numRows-1))\\n            {\\n                int j=i;\\n              // if I comment out the while loop then it does not give TLE\\n                while(j<l)\\n                {\\n                    res+=s[j];\\n                    j+=2*(numRows-1);\\n                }\\n             \\n            }\\n            else\\n            {\\n                int c=0;\\n                for(int j=i;j<l;)\\n                {\\n                    res+=s[j];\\n                    if(c%2==0)\\n                        j+=(numRows-i-1)*2;\\n                    else\\n                        j+=i*2;\\n                    c++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};`"
                    },
                    {
                        "username": "principoshi",
                        "content": "How is this in the most liked questions with an overwhelming number of actual \\'dislikes\\'?"
                    },
                    {
                        "username": "schuylermartin45",
                        "content": "Ah yes, I am allowed to pass as soon as I remove some debugging print statements. Glad I/O is my limiting factor, that seems fair."
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Sorry, but what are the rules or requirements for zigzag? If I randomly split a string in numRows parts it\\'s not correct, while it doesn\\'t violate the rules according to the task. Awful, 0 explanations."
                    },
                    {
                        "username": "dhwaj_03",
                        "content": "i did write the code, and it executed perfectly on my sublime ide but leetcode input is just not passing it write to the function. any ideas how to solve for this\\n"
                    }
                ]
            },
            {
                "id": 1786568,
                "content": [
                    {
                        "username": "LilClown",
                        "content": "My code works perfectly on my pc(C++23), but when I run it on leetcode,  starts an endless loop \"while\" if numRows = 1,so i added extra lines to fix that wierd case, its that ok ?  You can see code in my profile,if you want.Sorry for my bad English. "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "wondering if anyone actually got the formula from examples, like,\\n\\nI realised you \"use\" n chars for col 1,\\nand then 1 char for the next n-2 columns,\\nthen again a col of n chars,\\nthen 1 char for n-2 columns;\\nuntil you exhaust all letters..\\n\\nbut I actually had to build a naive solution to calc the matrix length.."
                    },
                    {
                        "username": "CodeWithbeer",
                        "content": "Shit here we go again"
                    },
                    {
                        "username": "kaaditya0625",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        int n=s.size(), r=numRows;\\n        if(r==1 || n<=r){\\n            return s;\\n        }\\n        int t=2*r-2;\\n        string res;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; i+j<n; j+=t){\\n                res.push_back(s[i+j]);\\n                if(i!=0 && i!=r-1 && j+t-i<n)\\n                    res.push_back(s[j+t-i]);\\n            }\\n        }\\n        return res;\\n    }\\n};  @"
                    },
                    {
                        "username": "smissner",
                        "content": "JaJa type problem"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Understanding the question is half the problem"
                    },
                    {
                        "username": "a147688934",
                        "content": "First have to know that the \"zigzag\" means the shape of alphabet \"N\" and this problem flips it vertically. "
                    },
                    {
                        "username": "Michellead",
                        "content": "To be fair, this question doesn\\'t have the full context it\\nmeant to have."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "could someone look into my code,im getting runtime error which i couldnt figure out\\n\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<vector<char>> v;\\n        int x = 0;\\n        int i = 0;\\n        while(x<s.length()){\\n            if(i%(numRows-1) == 0){\\n                for(int k = 0;k<numRows;k++){\\n                    if(x<s.length()){\\n                        v[k][i] = s[x];\\n                        x++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            else{\\n                if(x<s.length()){\\n                    v[numRows-1-(i%numRows)][i] = s[x];\\n                    x++;\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<v[i].size();j++){\\n                ans = ans+v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "it  gives runtime error , heap buffer overflow , but the code works fine on my pc, please suggest anything which help"
                    }
                ]
            },
            {
                "id": 1786561,
                "content": [
                    {
                        "username": "LilClown",
                        "content": "My code works perfectly on my pc(C++23), but when I run it on leetcode,  starts an endless loop \"while\" if numRows = 1,so i added extra lines to fix that wierd case, its that ok ?  You can see code in my profile,if you want.Sorry for my bad English. "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "wondering if anyone actually got the formula from examples, like,\\n\\nI realised you \"use\" n chars for col 1,\\nand then 1 char for the next n-2 columns,\\nthen again a col of n chars,\\nthen 1 char for n-2 columns;\\nuntil you exhaust all letters..\\n\\nbut I actually had to build a naive solution to calc the matrix length.."
                    },
                    {
                        "username": "CodeWithbeer",
                        "content": "Shit here we go again"
                    },
                    {
                        "username": "kaaditya0625",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        int n=s.size(), r=numRows;\\n        if(r==1 || n<=r){\\n            return s;\\n        }\\n        int t=2*r-2;\\n        string res;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; i+j<n; j+=t){\\n                res.push_back(s[i+j]);\\n                if(i!=0 && i!=r-1 && j+t-i<n)\\n                    res.push_back(s[j+t-i]);\\n            }\\n        }\\n        return res;\\n    }\\n};  @"
                    },
                    {
                        "username": "smissner",
                        "content": "JaJa type problem"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Understanding the question is half the problem"
                    },
                    {
                        "username": "a147688934",
                        "content": "First have to know that the \"zigzag\" means the shape of alphabet \"N\" and this problem flips it vertically. "
                    },
                    {
                        "username": "Michellead",
                        "content": "To be fair, this question doesn\\'t have the full context it\\nmeant to have."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "could someone look into my code,im getting runtime error which i couldnt figure out\\n\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<vector<char>> v;\\n        int x = 0;\\n        int i = 0;\\n        while(x<s.length()){\\n            if(i%(numRows-1) == 0){\\n                for(int k = 0;k<numRows;k++){\\n                    if(x<s.length()){\\n                        v[k][i] = s[x];\\n                        x++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            else{\\n                if(x<s.length()){\\n                    v[numRows-1-(i%numRows)][i] = s[x];\\n                    x++;\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<v[i].size();j++){\\n                ans = ans+v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "it  gives runtime error , heap buffer overflow , but the code works fine on my pc, please suggest anything which help"
                    }
                ]
            },
            {
                "id": 1786497,
                "content": [
                    {
                        "username": "LilClown",
                        "content": "My code works perfectly on my pc(C++23), but when I run it on leetcode,  starts an endless loop \"while\" if numRows = 1,so i added extra lines to fix that wierd case, its that ok ?  You can see code in my profile,if you want.Sorry for my bad English. "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "wondering if anyone actually got the formula from examples, like,\\n\\nI realised you \"use\" n chars for col 1,\\nand then 1 char for the next n-2 columns,\\nthen again a col of n chars,\\nthen 1 char for n-2 columns;\\nuntil you exhaust all letters..\\n\\nbut I actually had to build a naive solution to calc the matrix length.."
                    },
                    {
                        "username": "CodeWithbeer",
                        "content": "Shit here we go again"
                    },
                    {
                        "username": "kaaditya0625",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        int n=s.size(), r=numRows;\\n        if(r==1 || n<=r){\\n            return s;\\n        }\\n        int t=2*r-2;\\n        string res;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; i+j<n; j+=t){\\n                res.push_back(s[i+j]);\\n                if(i!=0 && i!=r-1 && j+t-i<n)\\n                    res.push_back(s[j+t-i]);\\n            }\\n        }\\n        return res;\\n    }\\n};  @"
                    },
                    {
                        "username": "smissner",
                        "content": "JaJa type problem"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Understanding the question is half the problem"
                    },
                    {
                        "username": "a147688934",
                        "content": "First have to know that the \"zigzag\" means the shape of alphabet \"N\" and this problem flips it vertically. "
                    },
                    {
                        "username": "Michellead",
                        "content": "To be fair, this question doesn\\'t have the full context it\\nmeant to have."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "could someone look into my code,im getting runtime error which i couldnt figure out\\n\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<vector<char>> v;\\n        int x = 0;\\n        int i = 0;\\n        while(x<s.length()){\\n            if(i%(numRows-1) == 0){\\n                for(int k = 0;k<numRows;k++){\\n                    if(x<s.length()){\\n                        v[k][i] = s[x];\\n                        x++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            else{\\n                if(x<s.length()){\\n                    v[numRows-1-(i%numRows)][i] = s[x];\\n                    x++;\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<v[i].size();j++){\\n                ans = ans+v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "it  gives runtime error , heap buffer overflow , but the code works fine on my pc, please suggest anything which help"
                    }
                ]
            },
            {
                "id": 1786464,
                "content": [
                    {
                        "username": "LilClown",
                        "content": "My code works perfectly on my pc(C++23), but when I run it on leetcode,  starts an endless loop \"while\" if numRows = 1,so i added extra lines to fix that wierd case, its that ok ?  You can see code in my profile,if you want.Sorry for my bad English. "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "wondering if anyone actually got the formula from examples, like,\\n\\nI realised you \"use\" n chars for col 1,\\nand then 1 char for the next n-2 columns,\\nthen again a col of n chars,\\nthen 1 char for n-2 columns;\\nuntil you exhaust all letters..\\n\\nbut I actually had to build a naive solution to calc the matrix length.."
                    },
                    {
                        "username": "CodeWithbeer",
                        "content": "Shit here we go again"
                    },
                    {
                        "username": "kaaditya0625",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        int n=s.size(), r=numRows;\\n        if(r==1 || n<=r){\\n            return s;\\n        }\\n        int t=2*r-2;\\n        string res;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; i+j<n; j+=t){\\n                res.push_back(s[i+j]);\\n                if(i!=0 && i!=r-1 && j+t-i<n)\\n                    res.push_back(s[j+t-i]);\\n            }\\n        }\\n        return res;\\n    }\\n};  @"
                    },
                    {
                        "username": "smissner",
                        "content": "JaJa type problem"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Understanding the question is half the problem"
                    },
                    {
                        "username": "a147688934",
                        "content": "First have to know that the \"zigzag\" means the shape of alphabet \"N\" and this problem flips it vertically. "
                    },
                    {
                        "username": "Michellead",
                        "content": "To be fair, this question doesn\\'t have the full context it\\nmeant to have."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "could someone look into my code,im getting runtime error which i couldnt figure out\\n\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<vector<char>> v;\\n        int x = 0;\\n        int i = 0;\\n        while(x<s.length()){\\n            if(i%(numRows-1) == 0){\\n                for(int k = 0;k<numRows;k++){\\n                    if(x<s.length()){\\n                        v[k][i] = s[x];\\n                        x++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            else{\\n                if(x<s.length()){\\n                    v[numRows-1-(i%numRows)][i] = s[x];\\n                    x++;\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<v[i].size();j++){\\n                ans = ans+v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "it  gives runtime error , heap buffer overflow , but the code works fine on my pc, please suggest anything which help"
                    }
                ]
            },
            {
                "id": 1786430,
                "content": [
                    {
                        "username": "LilClown",
                        "content": "My code works perfectly on my pc(C++23), but when I run it on leetcode,  starts an endless loop \"while\" if numRows = 1,so i added extra lines to fix that wierd case, its that ok ?  You can see code in my profile,if you want.Sorry for my bad English. "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "wondering if anyone actually got the formula from examples, like,\\n\\nI realised you \"use\" n chars for col 1,\\nand then 1 char for the next n-2 columns,\\nthen again a col of n chars,\\nthen 1 char for n-2 columns;\\nuntil you exhaust all letters..\\n\\nbut I actually had to build a naive solution to calc the matrix length.."
                    },
                    {
                        "username": "CodeWithbeer",
                        "content": "Shit here we go again"
                    },
                    {
                        "username": "kaaditya0625",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        int n=s.size(), r=numRows;\\n        if(r==1 || n<=r){\\n            return s;\\n        }\\n        int t=2*r-2;\\n        string res;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; i+j<n; j+=t){\\n                res.push_back(s[i+j]);\\n                if(i!=0 && i!=r-1 && j+t-i<n)\\n                    res.push_back(s[j+t-i]);\\n            }\\n        }\\n        return res;\\n    }\\n};  @"
                    },
                    {
                        "username": "smissner",
                        "content": "JaJa type problem"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Understanding the question is half the problem"
                    },
                    {
                        "username": "a147688934",
                        "content": "First have to know that the \"zigzag\" means the shape of alphabet \"N\" and this problem flips it vertically. "
                    },
                    {
                        "username": "Michellead",
                        "content": "To be fair, this question doesn\\'t have the full context it\\nmeant to have."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "could someone look into my code,im getting runtime error which i couldnt figure out\\n\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<vector<char>> v;\\n        int x = 0;\\n        int i = 0;\\n        while(x<s.length()){\\n            if(i%(numRows-1) == 0){\\n                for(int k = 0;k<numRows;k++){\\n                    if(x<s.length()){\\n                        v[k][i] = s[x];\\n                        x++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            else{\\n                if(x<s.length()){\\n                    v[numRows-1-(i%numRows)][i] = s[x];\\n                    x++;\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<v[i].size();j++){\\n                ans = ans+v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "it  gives runtime error , heap buffer overflow , but the code works fine on my pc, please suggest anything which help"
                    }
                ]
            },
            {
                "id": 1786423,
                "content": [
                    {
                        "username": "LilClown",
                        "content": "My code works perfectly on my pc(C++23), but when I run it on leetcode,  starts an endless loop \"while\" if numRows = 1,so i added extra lines to fix that wierd case, its that ok ?  You can see code in my profile,if you want.Sorry for my bad English. "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "wondering if anyone actually got the formula from examples, like,\\n\\nI realised you \"use\" n chars for col 1,\\nand then 1 char for the next n-2 columns,\\nthen again a col of n chars,\\nthen 1 char for n-2 columns;\\nuntil you exhaust all letters..\\n\\nbut I actually had to build a naive solution to calc the matrix length.."
                    },
                    {
                        "username": "CodeWithbeer",
                        "content": "Shit here we go again"
                    },
                    {
                        "username": "kaaditya0625",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        int n=s.size(), r=numRows;\\n        if(r==1 || n<=r){\\n            return s;\\n        }\\n        int t=2*r-2;\\n        string res;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; i+j<n; j+=t){\\n                res.push_back(s[i+j]);\\n                if(i!=0 && i!=r-1 && j+t-i<n)\\n                    res.push_back(s[j+t-i]);\\n            }\\n        }\\n        return res;\\n    }\\n};  @"
                    },
                    {
                        "username": "smissner",
                        "content": "JaJa type problem"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Understanding the question is half the problem"
                    },
                    {
                        "username": "a147688934",
                        "content": "First have to know that the \"zigzag\" means the shape of alphabet \"N\" and this problem flips it vertically. "
                    },
                    {
                        "username": "Michellead",
                        "content": "To be fair, this question doesn\\'t have the full context it\\nmeant to have."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "could someone look into my code,im getting runtime error which i couldnt figure out\\n\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<vector<char>> v;\\n        int x = 0;\\n        int i = 0;\\n        while(x<s.length()){\\n            if(i%(numRows-1) == 0){\\n                for(int k = 0;k<numRows;k++){\\n                    if(x<s.length()){\\n                        v[k][i] = s[x];\\n                        x++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            else{\\n                if(x<s.length()){\\n                    v[numRows-1-(i%numRows)][i] = s[x];\\n                    x++;\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<v[i].size();j++){\\n                ans = ans+v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "it  gives runtime error , heap buffer overflow , but the code works fine on my pc, please suggest anything which help"
                    }
                ]
            },
            {
                "id": 1786411,
                "content": [
                    {
                        "username": "LilClown",
                        "content": "My code works perfectly on my pc(C++23), but when I run it on leetcode,  starts an endless loop \"while\" if numRows = 1,so i added extra lines to fix that wierd case, its that ok ?  You can see code in my profile,if you want.Sorry for my bad English. "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "wondering if anyone actually got the formula from examples, like,\\n\\nI realised you \"use\" n chars for col 1,\\nand then 1 char for the next n-2 columns,\\nthen again a col of n chars,\\nthen 1 char for n-2 columns;\\nuntil you exhaust all letters..\\n\\nbut I actually had to build a naive solution to calc the matrix length.."
                    },
                    {
                        "username": "CodeWithbeer",
                        "content": "Shit here we go again"
                    },
                    {
                        "username": "kaaditya0625",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        int n=s.size(), r=numRows;\\n        if(r==1 || n<=r){\\n            return s;\\n        }\\n        int t=2*r-2;\\n        string res;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; i+j<n; j+=t){\\n                res.push_back(s[i+j]);\\n                if(i!=0 && i!=r-1 && j+t-i<n)\\n                    res.push_back(s[j+t-i]);\\n            }\\n        }\\n        return res;\\n    }\\n};  @"
                    },
                    {
                        "username": "smissner",
                        "content": "JaJa type problem"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Understanding the question is half the problem"
                    },
                    {
                        "username": "a147688934",
                        "content": "First have to know that the \"zigzag\" means the shape of alphabet \"N\" and this problem flips it vertically. "
                    },
                    {
                        "username": "Michellead",
                        "content": "To be fair, this question doesn\\'t have the full context it\\nmeant to have."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "could someone look into my code,im getting runtime error which i couldnt figure out\\n\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<vector<char>> v;\\n        int x = 0;\\n        int i = 0;\\n        while(x<s.length()){\\n            if(i%(numRows-1) == 0){\\n                for(int k = 0;k<numRows;k++){\\n                    if(x<s.length()){\\n                        v[k][i] = s[x];\\n                        x++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            else{\\n                if(x<s.length()){\\n                    v[numRows-1-(i%numRows)][i] = s[x];\\n                    x++;\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<v[i].size();j++){\\n                ans = ans+v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "it  gives runtime error , heap buffer overflow , but the code works fine on my pc, please suggest anything which help"
                    }
                ]
            },
            {
                "id": 1786393,
                "content": [
                    {
                        "username": "LilClown",
                        "content": "My code works perfectly on my pc(C++23), but when I run it on leetcode,  starts an endless loop \"while\" if numRows = 1,so i added extra lines to fix that wierd case, its that ok ?  You can see code in my profile,if you want.Sorry for my bad English. "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "wondering if anyone actually got the formula from examples, like,\\n\\nI realised you \"use\" n chars for col 1,\\nand then 1 char for the next n-2 columns,\\nthen again a col of n chars,\\nthen 1 char for n-2 columns;\\nuntil you exhaust all letters..\\n\\nbut I actually had to build a naive solution to calc the matrix length.."
                    },
                    {
                        "username": "CodeWithbeer",
                        "content": "Shit here we go again"
                    },
                    {
                        "username": "kaaditya0625",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        int n=s.size(), r=numRows;\\n        if(r==1 || n<=r){\\n            return s;\\n        }\\n        int t=2*r-2;\\n        string res;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; i+j<n; j+=t){\\n                res.push_back(s[i+j]);\\n                if(i!=0 && i!=r-1 && j+t-i<n)\\n                    res.push_back(s[j+t-i]);\\n            }\\n        }\\n        return res;\\n    }\\n};  @"
                    },
                    {
                        "username": "smissner",
                        "content": "JaJa type problem"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Understanding the question is half the problem"
                    },
                    {
                        "username": "a147688934",
                        "content": "First have to know that the \"zigzag\" means the shape of alphabet \"N\" and this problem flips it vertically. "
                    },
                    {
                        "username": "Michellead",
                        "content": "To be fair, this question doesn\\'t have the full context it\\nmeant to have."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "could someone look into my code,im getting runtime error which i couldnt figure out\\n\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<vector<char>> v;\\n        int x = 0;\\n        int i = 0;\\n        while(x<s.length()){\\n            if(i%(numRows-1) == 0){\\n                for(int k = 0;k<numRows;k++){\\n                    if(x<s.length()){\\n                        v[k][i] = s[x];\\n                        x++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            else{\\n                if(x<s.length()){\\n                    v[numRows-1-(i%numRows)][i] = s[x];\\n                    x++;\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<v[i].size();j++){\\n                ans = ans+v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "it  gives runtime error , heap buffer overflow , but the code works fine on my pc, please suggest anything which help"
                    }
                ]
            },
            {
                "id": 1786275,
                "content": [
                    {
                        "username": "LilClown",
                        "content": "My code works perfectly on my pc(C++23), but when I run it on leetcode,  starts an endless loop \"while\" if numRows = 1,so i added extra lines to fix that wierd case, its that ok ?  You can see code in my profile,if you want.Sorry for my bad English. "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "wondering if anyone actually got the formula from examples, like,\\n\\nI realised you \"use\" n chars for col 1,\\nand then 1 char for the next n-2 columns,\\nthen again a col of n chars,\\nthen 1 char for n-2 columns;\\nuntil you exhaust all letters..\\n\\nbut I actually had to build a naive solution to calc the matrix length.."
                    },
                    {
                        "username": "CodeWithbeer",
                        "content": "Shit here we go again"
                    },
                    {
                        "username": "kaaditya0625",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        int n=s.size(), r=numRows;\\n        if(r==1 || n<=r){\\n            return s;\\n        }\\n        int t=2*r-2;\\n        string res;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; i+j<n; j+=t){\\n                res.push_back(s[i+j]);\\n                if(i!=0 && i!=r-1 && j+t-i<n)\\n                    res.push_back(s[j+t-i]);\\n            }\\n        }\\n        return res;\\n    }\\n};  @"
                    },
                    {
                        "username": "smissner",
                        "content": "JaJa type problem"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Understanding the question is half the problem"
                    },
                    {
                        "username": "a147688934",
                        "content": "First have to know that the \"zigzag\" means the shape of alphabet \"N\" and this problem flips it vertically. "
                    },
                    {
                        "username": "Michellead",
                        "content": "To be fair, this question doesn\\'t have the full context it\\nmeant to have."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "could someone look into my code,im getting runtime error which i couldnt figure out\\n\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<vector<char>> v;\\n        int x = 0;\\n        int i = 0;\\n        while(x<s.length()){\\n            if(i%(numRows-1) == 0){\\n                for(int k = 0;k<numRows;k++){\\n                    if(x<s.length()){\\n                        v[k][i] = s[x];\\n                        x++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            else{\\n                if(x<s.length()){\\n                    v[numRows-1-(i%numRows)][i] = s[x];\\n                    x++;\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<v[i].size();j++){\\n                ans = ans+v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "it  gives runtime error , heap buffer overflow , but the code works fine on my pc, please suggest anything which help"
                    }
                ]
            },
            {
                "id": 1786265,
                "content": [
                    {
                        "username": "LilClown",
                        "content": "My code works perfectly on my pc(C++23), but when I run it on leetcode,  starts an endless loop \"while\" if numRows = 1,so i added extra lines to fix that wierd case, its that ok ?  You can see code in my profile,if you want.Sorry for my bad English. "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "wondering if anyone actually got the formula from examples, like,\\n\\nI realised you \"use\" n chars for col 1,\\nand then 1 char for the next n-2 columns,\\nthen again a col of n chars,\\nthen 1 char for n-2 columns;\\nuntil you exhaust all letters..\\n\\nbut I actually had to build a naive solution to calc the matrix length.."
                    },
                    {
                        "username": "CodeWithbeer",
                        "content": "Shit here we go again"
                    },
                    {
                        "username": "kaaditya0625",
                        "content": "class Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        int n=s.size(), r=numRows;\\n        if(r==1 || n<=r){\\n            return s;\\n        }\\n        int t=2*r-2;\\n        string res;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; i+j<n; j+=t){\\n                res.push_back(s[i+j]);\\n                if(i!=0 && i!=r-1 && j+t-i<n)\\n                    res.push_back(s[j+t-i]);\\n            }\\n        }\\n        return res;\\n    }\\n};  @"
                    },
                    {
                        "username": "smissner",
                        "content": "JaJa type problem"
                    },
                    {
                        "username": "BristolJ",
                        "content": "Understanding the question is half the problem"
                    },
                    {
                        "username": "a147688934",
                        "content": "First have to know that the \"zigzag\" means the shape of alphabet \"N\" and this problem flips it vertically. "
                    },
                    {
                        "username": "Michellead",
                        "content": "To be fair, this question doesn\\'t have the full context it\\nmeant to have."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "could someone look into my code,im getting runtime error which i couldnt figure out\\n\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        vector<vector<char>> v;\\n        int x = 0;\\n        int i = 0;\\n        while(x<s.length()){\\n            if(i%(numRows-1) == 0){\\n                for(int k = 0;k<numRows;k++){\\n                    if(x<s.length()){\\n                        v[k][i] = s[x];\\n                        x++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            else{\\n                if(x<s.length()){\\n                    v[numRows-1-(i%numRows)][i] = s[x];\\n                    x++;\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<v[i].size();j++){\\n                ans = ans+v[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "it  gives runtime error , heap buffer overflow , but the code works fine on my pc, please suggest anything which help"
                    }
                ]
            },
            {
                "id": 1786255,
                "content": [
                    {
                        "username": "Yongbi",
                        "content": "```\n#1. Just create an empty list (length of numRows), then\n#2. Follow a loop of letter in the given string. \n#3. Pick up each letter in at each iteration by the following rule: \n#4. Define a _pointer_ or _i_  run in the range(0, numRows) with direction. \nWhen i=0 inscrease i+=1, direction=1, \notherwise, i=numRows then descreases i-=1, direction=-1.\nlist[i]+=letter\n#5. Return \"\".join(list)\n```\nMy solution is O(n), I'm thinking about an O(log(n)) solution."
                    },
                    {
                        "username": "aha_an007",
                        "content": "hi danish keep growing buddy !!!!!!!!"
                    },
                    {
                        "username": "mddanishsamir",
                        "content": "Hii Mudassir,\\nchamp where are you\\n"
                    },
                    {
                        "username": "kelvin950",
                        "content": "Took me two hours to solve this question. went through the discussion avoiding the solutions. saw \"rail fence cipher \" and searched it on google. create  a 2d array to store  the strings but loop through from column to row, top to down, when you reach the last row (numRows-1) move up by reducing row by one and diagonally by increasing column by 1 till you reach 0 and start over again."
                    },
                    {
                        "username": "pokaChika",
                        "content": "use me as a dislike button for this question! #paypallayingoff"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode is playing with our feeling #paypal is laying off \n<br>\nUpvote It if you Like My solution <br>\nMy solution link : -> https://leetcode.com/problems/zigzag-conversion/solutions/3136532/c-easy-and-simple-solution-using-2d-array/"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "easy to solve\\nhard to even understand since the question didnt give a f about readers lol"
                    },
                    {
                        "username": "bikram7151",
                        "content": "Explanation:\\n\\n1.If numRows is equal to 1, the string does not need to be converted and can be returned as is.\\n2.Create an array of StringBuilder objects with numRows elements.\\n3.Use a while loop to traverse the input string s.\\n4.In each iteration, append characters to the StringBuilder objects in the following way: first append to the 0th, then 1st, 2nd, ... numRows-1th elements, then numRows-2nd, numRows-3rd, ... 1st elements, and so on.\\n5.Finally, append all the StringBuilder objects except for the 0th to the 0th StringBuilder, and return the result as a string.\\n\\npublic String convert(String s, int numRows) {\\n    if (numRows == 1) return s;\\n    \\n    int len = s.length();\\n    StringBuilder[] sb = new StringBuilder[numRows];\\n    for (int i = 0; i < numRows; i++) {\\n        sb[i] = new StringBuilder();\\n    }\\n    \\n    int idx = 0;\\n    while (idx < len) {\\n        for (int i = 0; i < numRows && idx < len; i++) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n        for (int i = numRows-2; i > 0 && idx < len; i--) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n    }\\n    \\n    for (int i = 1; i < numRows; i++) {\\n        sb[0].append(sb[i]);\\n    }\\n    return sb[0].toString();\\n}\\n\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Doing this on my birthday, and was able to come up with a ac solution."
                    },
                    {
                        "username": "syed-m-osama",
                        "content": "```\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int vertical = numRows;\n        int diagonal = vertical - 2;\n        int next = vertical + diagonal;\n        vector<vector<char>> matrix(vertical);\n        int c = 0, r = 0, i = 0;\n        while(i < s.length()){\n            while(r < vertical){\n                matrix[r].push_back(s[i]);\n                r++, i++;\n            }\n            if(i >= s.length()){ break; }\n            r-=2;\n            while(vertical - r != vertical){\n                matrix[r].push_back(s[i]);\n                r--, i++;     \n            }\n        }\n        string res ;\n        for(int k = 0; k< vertical; k++){\n            for(int j = 0; j< matrix[k].size(); j++){\n                res.push_back(matrix[k][j]);\n            }   \n        }\n        return res;\n    }\n};\n```\n\ncan somebody help me why its not working even there's no diff between 'expected' and 'output' solutions."
                    }
                ]
            },
            {
                "id": 1786154,
                "content": [
                    {
                        "username": "Yongbi",
                        "content": "```\n#1. Just create an empty list (length of numRows), then\n#2. Follow a loop of letter in the given string. \n#3. Pick up each letter in at each iteration by the following rule: \n#4. Define a _pointer_ or _i_  run in the range(0, numRows) with direction. \nWhen i=0 inscrease i+=1, direction=1, \notherwise, i=numRows then descreases i-=1, direction=-1.\nlist[i]+=letter\n#5. Return \"\".join(list)\n```\nMy solution is O(n), I'm thinking about an O(log(n)) solution."
                    },
                    {
                        "username": "aha_an007",
                        "content": "hi danish keep growing buddy !!!!!!!!"
                    },
                    {
                        "username": "mddanishsamir",
                        "content": "Hii Mudassir,\\nchamp where are you\\n"
                    },
                    {
                        "username": "kelvin950",
                        "content": "Took me two hours to solve this question. went through the discussion avoiding the solutions. saw \"rail fence cipher \" and searched it on google. create  a 2d array to store  the strings but loop through from column to row, top to down, when you reach the last row (numRows-1) move up by reducing row by one and diagonally by increasing column by 1 till you reach 0 and start over again."
                    },
                    {
                        "username": "pokaChika",
                        "content": "use me as a dislike button for this question! #paypallayingoff"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode is playing with our feeling #paypal is laying off \n<br>\nUpvote It if you Like My solution <br>\nMy solution link : -> https://leetcode.com/problems/zigzag-conversion/solutions/3136532/c-easy-and-simple-solution-using-2d-array/"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "easy to solve\\nhard to even understand since the question didnt give a f about readers lol"
                    },
                    {
                        "username": "bikram7151",
                        "content": "Explanation:\\n\\n1.If numRows is equal to 1, the string does not need to be converted and can be returned as is.\\n2.Create an array of StringBuilder objects with numRows elements.\\n3.Use a while loop to traverse the input string s.\\n4.In each iteration, append characters to the StringBuilder objects in the following way: first append to the 0th, then 1st, 2nd, ... numRows-1th elements, then numRows-2nd, numRows-3rd, ... 1st elements, and so on.\\n5.Finally, append all the StringBuilder objects except for the 0th to the 0th StringBuilder, and return the result as a string.\\n\\npublic String convert(String s, int numRows) {\\n    if (numRows == 1) return s;\\n    \\n    int len = s.length();\\n    StringBuilder[] sb = new StringBuilder[numRows];\\n    for (int i = 0; i < numRows; i++) {\\n        sb[i] = new StringBuilder();\\n    }\\n    \\n    int idx = 0;\\n    while (idx < len) {\\n        for (int i = 0; i < numRows && idx < len; i++) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n        for (int i = numRows-2; i > 0 && idx < len; i--) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n    }\\n    \\n    for (int i = 1; i < numRows; i++) {\\n        sb[0].append(sb[i]);\\n    }\\n    return sb[0].toString();\\n}\\n\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Doing this on my birthday, and was able to come up with a ac solution."
                    },
                    {
                        "username": "syed-m-osama",
                        "content": "```\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int vertical = numRows;\n        int diagonal = vertical - 2;\n        int next = vertical + diagonal;\n        vector<vector<char>> matrix(vertical);\n        int c = 0, r = 0, i = 0;\n        while(i < s.length()){\n            while(r < vertical){\n                matrix[r].push_back(s[i]);\n                r++, i++;\n            }\n            if(i >= s.length()){ break; }\n            r-=2;\n            while(vertical - r != vertical){\n                matrix[r].push_back(s[i]);\n                r--, i++;     \n            }\n        }\n        string res ;\n        for(int k = 0; k< vertical; k++){\n            for(int j = 0; j< matrix[k].size(); j++){\n                res.push_back(matrix[k][j]);\n            }   \n        }\n        return res;\n    }\n};\n```\n\ncan somebody help me why its not working even there's no diff between 'expected' and 'output' solutions."
                    }
                ]
            },
            {
                "id": 1786153,
                "content": [
                    {
                        "username": "Yongbi",
                        "content": "```\n#1. Just create an empty list (length of numRows), then\n#2. Follow a loop of letter in the given string. \n#3. Pick up each letter in at each iteration by the following rule: \n#4. Define a _pointer_ or _i_  run in the range(0, numRows) with direction. \nWhen i=0 inscrease i+=1, direction=1, \notherwise, i=numRows then descreases i-=1, direction=-1.\nlist[i]+=letter\n#5. Return \"\".join(list)\n```\nMy solution is O(n), I'm thinking about an O(log(n)) solution."
                    },
                    {
                        "username": "aha_an007",
                        "content": "hi danish keep growing buddy !!!!!!!!"
                    },
                    {
                        "username": "mddanishsamir",
                        "content": "Hii Mudassir,\\nchamp where are you\\n"
                    },
                    {
                        "username": "kelvin950",
                        "content": "Took me two hours to solve this question. went through the discussion avoiding the solutions. saw \"rail fence cipher \" and searched it on google. create  a 2d array to store  the strings but loop through from column to row, top to down, when you reach the last row (numRows-1) move up by reducing row by one and diagonally by increasing column by 1 till you reach 0 and start over again."
                    },
                    {
                        "username": "pokaChika",
                        "content": "use me as a dislike button for this question! #paypallayingoff"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode is playing with our feeling #paypal is laying off \n<br>\nUpvote It if you Like My solution <br>\nMy solution link : -> https://leetcode.com/problems/zigzag-conversion/solutions/3136532/c-easy-and-simple-solution-using-2d-array/"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "easy to solve\\nhard to even understand since the question didnt give a f about readers lol"
                    },
                    {
                        "username": "bikram7151",
                        "content": "Explanation:\\n\\n1.If numRows is equal to 1, the string does not need to be converted and can be returned as is.\\n2.Create an array of StringBuilder objects with numRows elements.\\n3.Use a while loop to traverse the input string s.\\n4.In each iteration, append characters to the StringBuilder objects in the following way: first append to the 0th, then 1st, 2nd, ... numRows-1th elements, then numRows-2nd, numRows-3rd, ... 1st elements, and so on.\\n5.Finally, append all the StringBuilder objects except for the 0th to the 0th StringBuilder, and return the result as a string.\\n\\npublic String convert(String s, int numRows) {\\n    if (numRows == 1) return s;\\n    \\n    int len = s.length();\\n    StringBuilder[] sb = new StringBuilder[numRows];\\n    for (int i = 0; i < numRows; i++) {\\n        sb[i] = new StringBuilder();\\n    }\\n    \\n    int idx = 0;\\n    while (idx < len) {\\n        for (int i = 0; i < numRows && idx < len; i++) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n        for (int i = numRows-2; i > 0 && idx < len; i--) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n    }\\n    \\n    for (int i = 1; i < numRows; i++) {\\n        sb[0].append(sb[i]);\\n    }\\n    return sb[0].toString();\\n}\\n\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Doing this on my birthday, and was able to come up with a ac solution."
                    },
                    {
                        "username": "syed-m-osama",
                        "content": "```\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int vertical = numRows;\n        int diagonal = vertical - 2;\n        int next = vertical + diagonal;\n        vector<vector<char>> matrix(vertical);\n        int c = 0, r = 0, i = 0;\n        while(i < s.length()){\n            while(r < vertical){\n                matrix[r].push_back(s[i]);\n                r++, i++;\n            }\n            if(i >= s.length()){ break; }\n            r-=2;\n            while(vertical - r != vertical){\n                matrix[r].push_back(s[i]);\n                r--, i++;     \n            }\n        }\n        string res ;\n        for(int k = 0; k< vertical; k++){\n            for(int j = 0; j< matrix[k].size(); j++){\n                res.push_back(matrix[k][j]);\n            }   \n        }\n        return res;\n    }\n};\n```\n\ncan somebody help me why its not working even there's no diff between 'expected' and 'output' solutions."
                    }
                ]
            },
            {
                "id": 1786149,
                "content": [
                    {
                        "username": "Yongbi",
                        "content": "```\n#1. Just create an empty list (length of numRows), then\n#2. Follow a loop of letter in the given string. \n#3. Pick up each letter in at each iteration by the following rule: \n#4. Define a _pointer_ or _i_  run in the range(0, numRows) with direction. \nWhen i=0 inscrease i+=1, direction=1, \notherwise, i=numRows then descreases i-=1, direction=-1.\nlist[i]+=letter\n#5. Return \"\".join(list)\n```\nMy solution is O(n), I'm thinking about an O(log(n)) solution."
                    },
                    {
                        "username": "aha_an007",
                        "content": "hi danish keep growing buddy !!!!!!!!"
                    },
                    {
                        "username": "mddanishsamir",
                        "content": "Hii Mudassir,\\nchamp where are you\\n"
                    },
                    {
                        "username": "kelvin950",
                        "content": "Took me two hours to solve this question. went through the discussion avoiding the solutions. saw \"rail fence cipher \" and searched it on google. create  a 2d array to store  the strings but loop through from column to row, top to down, when you reach the last row (numRows-1) move up by reducing row by one and diagonally by increasing column by 1 till you reach 0 and start over again."
                    },
                    {
                        "username": "pokaChika",
                        "content": "use me as a dislike button for this question! #paypallayingoff"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode is playing with our feeling #paypal is laying off \n<br>\nUpvote It if you Like My solution <br>\nMy solution link : -> https://leetcode.com/problems/zigzag-conversion/solutions/3136532/c-easy-and-simple-solution-using-2d-array/"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "easy to solve\\nhard to even understand since the question didnt give a f about readers lol"
                    },
                    {
                        "username": "bikram7151",
                        "content": "Explanation:\\n\\n1.If numRows is equal to 1, the string does not need to be converted and can be returned as is.\\n2.Create an array of StringBuilder objects with numRows elements.\\n3.Use a while loop to traverse the input string s.\\n4.In each iteration, append characters to the StringBuilder objects in the following way: first append to the 0th, then 1st, 2nd, ... numRows-1th elements, then numRows-2nd, numRows-3rd, ... 1st elements, and so on.\\n5.Finally, append all the StringBuilder objects except for the 0th to the 0th StringBuilder, and return the result as a string.\\n\\npublic String convert(String s, int numRows) {\\n    if (numRows == 1) return s;\\n    \\n    int len = s.length();\\n    StringBuilder[] sb = new StringBuilder[numRows];\\n    for (int i = 0; i < numRows; i++) {\\n        sb[i] = new StringBuilder();\\n    }\\n    \\n    int idx = 0;\\n    while (idx < len) {\\n        for (int i = 0; i < numRows && idx < len; i++) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n        for (int i = numRows-2; i > 0 && idx < len; i--) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n    }\\n    \\n    for (int i = 1; i < numRows; i++) {\\n        sb[0].append(sb[i]);\\n    }\\n    return sb[0].toString();\\n}\\n\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Doing this on my birthday, and was able to come up with a ac solution."
                    },
                    {
                        "username": "syed-m-osama",
                        "content": "```\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int vertical = numRows;\n        int diagonal = vertical - 2;\n        int next = vertical + diagonal;\n        vector<vector<char>> matrix(vertical);\n        int c = 0, r = 0, i = 0;\n        while(i < s.length()){\n            while(r < vertical){\n                matrix[r].push_back(s[i]);\n                r++, i++;\n            }\n            if(i >= s.length()){ break; }\n            r-=2;\n            while(vertical - r != vertical){\n                matrix[r].push_back(s[i]);\n                r--, i++;     \n            }\n        }\n        string res ;\n        for(int k = 0; k< vertical; k++){\n            for(int j = 0; j< matrix[k].size(); j++){\n                res.push_back(matrix[k][j]);\n            }   \n        }\n        return res;\n    }\n};\n```\n\ncan somebody help me why its not working even there's no diff between 'expected' and 'output' solutions."
                    }
                ]
            },
            {
                "id": 1786142,
                "content": [
                    {
                        "username": "Yongbi",
                        "content": "```\n#1. Just create an empty list (length of numRows), then\n#2. Follow a loop of letter in the given string. \n#3. Pick up each letter in at each iteration by the following rule: \n#4. Define a _pointer_ or _i_  run in the range(0, numRows) with direction. \nWhen i=0 inscrease i+=1, direction=1, \notherwise, i=numRows then descreases i-=1, direction=-1.\nlist[i]+=letter\n#5. Return \"\".join(list)\n```\nMy solution is O(n), I'm thinking about an O(log(n)) solution."
                    },
                    {
                        "username": "aha_an007",
                        "content": "hi danish keep growing buddy !!!!!!!!"
                    },
                    {
                        "username": "mddanishsamir",
                        "content": "Hii Mudassir,\\nchamp where are you\\n"
                    },
                    {
                        "username": "kelvin950",
                        "content": "Took me two hours to solve this question. went through the discussion avoiding the solutions. saw \"rail fence cipher \" and searched it on google. create  a 2d array to store  the strings but loop through from column to row, top to down, when you reach the last row (numRows-1) move up by reducing row by one and diagonally by increasing column by 1 till you reach 0 and start over again."
                    },
                    {
                        "username": "pokaChika",
                        "content": "use me as a dislike button for this question! #paypallayingoff"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode is playing with our feeling #paypal is laying off \n<br>\nUpvote It if you Like My solution <br>\nMy solution link : -> https://leetcode.com/problems/zigzag-conversion/solutions/3136532/c-easy-and-simple-solution-using-2d-array/"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "easy to solve\\nhard to even understand since the question didnt give a f about readers lol"
                    },
                    {
                        "username": "bikram7151",
                        "content": "Explanation:\\n\\n1.If numRows is equal to 1, the string does not need to be converted and can be returned as is.\\n2.Create an array of StringBuilder objects with numRows elements.\\n3.Use a while loop to traverse the input string s.\\n4.In each iteration, append characters to the StringBuilder objects in the following way: first append to the 0th, then 1st, 2nd, ... numRows-1th elements, then numRows-2nd, numRows-3rd, ... 1st elements, and so on.\\n5.Finally, append all the StringBuilder objects except for the 0th to the 0th StringBuilder, and return the result as a string.\\n\\npublic String convert(String s, int numRows) {\\n    if (numRows == 1) return s;\\n    \\n    int len = s.length();\\n    StringBuilder[] sb = new StringBuilder[numRows];\\n    for (int i = 0; i < numRows; i++) {\\n        sb[i] = new StringBuilder();\\n    }\\n    \\n    int idx = 0;\\n    while (idx < len) {\\n        for (int i = 0; i < numRows && idx < len; i++) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n        for (int i = numRows-2; i > 0 && idx < len; i--) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n    }\\n    \\n    for (int i = 1; i < numRows; i++) {\\n        sb[0].append(sb[i]);\\n    }\\n    return sb[0].toString();\\n}\\n\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Doing this on my birthday, and was able to come up with a ac solution."
                    },
                    {
                        "username": "syed-m-osama",
                        "content": "```\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int vertical = numRows;\n        int diagonal = vertical - 2;\n        int next = vertical + diagonal;\n        vector<vector<char>> matrix(vertical);\n        int c = 0, r = 0, i = 0;\n        while(i < s.length()){\n            while(r < vertical){\n                matrix[r].push_back(s[i]);\n                r++, i++;\n            }\n            if(i >= s.length()){ break; }\n            r-=2;\n            while(vertical - r != vertical){\n                matrix[r].push_back(s[i]);\n                r--, i++;     \n            }\n        }\n        string res ;\n        for(int k = 0; k< vertical; k++){\n            for(int j = 0; j< matrix[k].size(); j++){\n                res.push_back(matrix[k][j]);\n            }   \n        }\n        return res;\n    }\n};\n```\n\ncan somebody help me why its not working even there's no diff between 'expected' and 'output' solutions."
                    }
                ]
            },
            {
                "id": 1786110,
                "content": [
                    {
                        "username": "Yongbi",
                        "content": "```\n#1. Just create an empty list (length of numRows), then\n#2. Follow a loop of letter in the given string. \n#3. Pick up each letter in at each iteration by the following rule: \n#4. Define a _pointer_ or _i_  run in the range(0, numRows) with direction. \nWhen i=0 inscrease i+=1, direction=1, \notherwise, i=numRows then descreases i-=1, direction=-1.\nlist[i]+=letter\n#5. Return \"\".join(list)\n```\nMy solution is O(n), I'm thinking about an O(log(n)) solution."
                    },
                    {
                        "username": "aha_an007",
                        "content": "hi danish keep growing buddy !!!!!!!!"
                    },
                    {
                        "username": "mddanishsamir",
                        "content": "Hii Mudassir,\\nchamp where are you\\n"
                    },
                    {
                        "username": "kelvin950",
                        "content": "Took me two hours to solve this question. went through the discussion avoiding the solutions. saw \"rail fence cipher \" and searched it on google. create  a 2d array to store  the strings but loop through from column to row, top to down, when you reach the last row (numRows-1) move up by reducing row by one and diagonally by increasing column by 1 till you reach 0 and start over again."
                    },
                    {
                        "username": "pokaChika",
                        "content": "use me as a dislike button for this question! #paypallayingoff"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode is playing with our feeling #paypal is laying off \n<br>\nUpvote It if you Like My solution <br>\nMy solution link : -> https://leetcode.com/problems/zigzag-conversion/solutions/3136532/c-easy-and-simple-solution-using-2d-array/"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "easy to solve\\nhard to even understand since the question didnt give a f about readers lol"
                    },
                    {
                        "username": "bikram7151",
                        "content": "Explanation:\\n\\n1.If numRows is equal to 1, the string does not need to be converted and can be returned as is.\\n2.Create an array of StringBuilder objects with numRows elements.\\n3.Use a while loop to traverse the input string s.\\n4.In each iteration, append characters to the StringBuilder objects in the following way: first append to the 0th, then 1st, 2nd, ... numRows-1th elements, then numRows-2nd, numRows-3rd, ... 1st elements, and so on.\\n5.Finally, append all the StringBuilder objects except for the 0th to the 0th StringBuilder, and return the result as a string.\\n\\npublic String convert(String s, int numRows) {\\n    if (numRows == 1) return s;\\n    \\n    int len = s.length();\\n    StringBuilder[] sb = new StringBuilder[numRows];\\n    for (int i = 0; i < numRows; i++) {\\n        sb[i] = new StringBuilder();\\n    }\\n    \\n    int idx = 0;\\n    while (idx < len) {\\n        for (int i = 0; i < numRows && idx < len; i++) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n        for (int i = numRows-2; i > 0 && idx < len; i--) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n    }\\n    \\n    for (int i = 1; i < numRows; i++) {\\n        sb[0].append(sb[i]);\\n    }\\n    return sb[0].toString();\\n}\\n\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Doing this on my birthday, and was able to come up with a ac solution."
                    },
                    {
                        "username": "syed-m-osama",
                        "content": "```\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int vertical = numRows;\n        int diagonal = vertical - 2;\n        int next = vertical + diagonal;\n        vector<vector<char>> matrix(vertical);\n        int c = 0, r = 0, i = 0;\n        while(i < s.length()){\n            while(r < vertical){\n                matrix[r].push_back(s[i]);\n                r++, i++;\n            }\n            if(i >= s.length()){ break; }\n            r-=2;\n            while(vertical - r != vertical){\n                matrix[r].push_back(s[i]);\n                r--, i++;     \n            }\n        }\n        string res ;\n        for(int k = 0; k< vertical; k++){\n            for(int j = 0; j< matrix[k].size(); j++){\n                res.push_back(matrix[k][j]);\n            }   \n        }\n        return res;\n    }\n};\n```\n\ncan somebody help me why its not working even there's no diff between 'expected' and 'output' solutions."
                    }
                ]
            },
            {
                "id": 1786084,
                "content": [
                    {
                        "username": "Yongbi",
                        "content": "```\n#1. Just create an empty list (length of numRows), then\n#2. Follow a loop of letter in the given string. \n#3. Pick up each letter in at each iteration by the following rule: \n#4. Define a _pointer_ or _i_  run in the range(0, numRows) with direction. \nWhen i=0 inscrease i+=1, direction=1, \notherwise, i=numRows then descreases i-=1, direction=-1.\nlist[i]+=letter\n#5. Return \"\".join(list)\n```\nMy solution is O(n), I'm thinking about an O(log(n)) solution."
                    },
                    {
                        "username": "aha_an007",
                        "content": "hi danish keep growing buddy !!!!!!!!"
                    },
                    {
                        "username": "mddanishsamir",
                        "content": "Hii Mudassir,\\nchamp where are you\\n"
                    },
                    {
                        "username": "kelvin950",
                        "content": "Took me two hours to solve this question. went through the discussion avoiding the solutions. saw \"rail fence cipher \" and searched it on google. create  a 2d array to store  the strings but loop through from column to row, top to down, when you reach the last row (numRows-1) move up by reducing row by one and diagonally by increasing column by 1 till you reach 0 and start over again."
                    },
                    {
                        "username": "pokaChika",
                        "content": "use me as a dislike button for this question! #paypallayingoff"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode is playing with our feeling #paypal is laying off \n<br>\nUpvote It if you Like My solution <br>\nMy solution link : -> https://leetcode.com/problems/zigzag-conversion/solutions/3136532/c-easy-and-simple-solution-using-2d-array/"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "easy to solve\\nhard to even understand since the question didnt give a f about readers lol"
                    },
                    {
                        "username": "bikram7151",
                        "content": "Explanation:\\n\\n1.If numRows is equal to 1, the string does not need to be converted and can be returned as is.\\n2.Create an array of StringBuilder objects with numRows elements.\\n3.Use a while loop to traverse the input string s.\\n4.In each iteration, append characters to the StringBuilder objects in the following way: first append to the 0th, then 1st, 2nd, ... numRows-1th elements, then numRows-2nd, numRows-3rd, ... 1st elements, and so on.\\n5.Finally, append all the StringBuilder objects except for the 0th to the 0th StringBuilder, and return the result as a string.\\n\\npublic String convert(String s, int numRows) {\\n    if (numRows == 1) return s;\\n    \\n    int len = s.length();\\n    StringBuilder[] sb = new StringBuilder[numRows];\\n    for (int i = 0; i < numRows; i++) {\\n        sb[i] = new StringBuilder();\\n    }\\n    \\n    int idx = 0;\\n    while (idx < len) {\\n        for (int i = 0; i < numRows && idx < len; i++) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n        for (int i = numRows-2; i > 0 && idx < len; i--) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n    }\\n    \\n    for (int i = 1; i < numRows; i++) {\\n        sb[0].append(sb[i]);\\n    }\\n    return sb[0].toString();\\n}\\n\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Doing this on my birthday, and was able to come up with a ac solution."
                    },
                    {
                        "username": "syed-m-osama",
                        "content": "```\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int vertical = numRows;\n        int diagonal = vertical - 2;\n        int next = vertical + diagonal;\n        vector<vector<char>> matrix(vertical);\n        int c = 0, r = 0, i = 0;\n        while(i < s.length()){\n            while(r < vertical){\n                matrix[r].push_back(s[i]);\n                r++, i++;\n            }\n            if(i >= s.length()){ break; }\n            r-=2;\n            while(vertical - r != vertical){\n                matrix[r].push_back(s[i]);\n                r--, i++;     \n            }\n        }\n        string res ;\n        for(int k = 0; k< vertical; k++){\n            for(int j = 0; j< matrix[k].size(); j++){\n                res.push_back(matrix[k][j]);\n            }   \n        }\n        return res;\n    }\n};\n```\n\ncan somebody help me why its not working even there's no diff between 'expected' and 'output' solutions."
                    }
                ]
            },
            {
                "id": 1786071,
                "content": [
                    {
                        "username": "Yongbi",
                        "content": "```\n#1. Just create an empty list (length of numRows), then\n#2. Follow a loop of letter in the given string. \n#3. Pick up each letter in at each iteration by the following rule: \n#4. Define a _pointer_ or _i_  run in the range(0, numRows) with direction. \nWhen i=0 inscrease i+=1, direction=1, \notherwise, i=numRows then descreases i-=1, direction=-1.\nlist[i]+=letter\n#5. Return \"\".join(list)\n```\nMy solution is O(n), I'm thinking about an O(log(n)) solution."
                    },
                    {
                        "username": "aha_an007",
                        "content": "hi danish keep growing buddy !!!!!!!!"
                    },
                    {
                        "username": "mddanishsamir",
                        "content": "Hii Mudassir,\\nchamp where are you\\n"
                    },
                    {
                        "username": "kelvin950",
                        "content": "Took me two hours to solve this question. went through the discussion avoiding the solutions. saw \"rail fence cipher \" and searched it on google. create  a 2d array to store  the strings but loop through from column to row, top to down, when you reach the last row (numRows-1) move up by reducing row by one and diagonally by increasing column by 1 till you reach 0 and start over again."
                    },
                    {
                        "username": "pokaChika",
                        "content": "use me as a dislike button for this question! #paypallayingoff"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode is playing with our feeling #paypal is laying off \n<br>\nUpvote It if you Like My solution <br>\nMy solution link : -> https://leetcode.com/problems/zigzag-conversion/solutions/3136532/c-easy-and-simple-solution-using-2d-array/"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "easy to solve\\nhard to even understand since the question didnt give a f about readers lol"
                    },
                    {
                        "username": "bikram7151",
                        "content": "Explanation:\\n\\n1.If numRows is equal to 1, the string does not need to be converted and can be returned as is.\\n2.Create an array of StringBuilder objects with numRows elements.\\n3.Use a while loop to traverse the input string s.\\n4.In each iteration, append characters to the StringBuilder objects in the following way: first append to the 0th, then 1st, 2nd, ... numRows-1th elements, then numRows-2nd, numRows-3rd, ... 1st elements, and so on.\\n5.Finally, append all the StringBuilder objects except for the 0th to the 0th StringBuilder, and return the result as a string.\\n\\npublic String convert(String s, int numRows) {\\n    if (numRows == 1) return s;\\n    \\n    int len = s.length();\\n    StringBuilder[] sb = new StringBuilder[numRows];\\n    for (int i = 0; i < numRows; i++) {\\n        sb[i] = new StringBuilder();\\n    }\\n    \\n    int idx = 0;\\n    while (idx < len) {\\n        for (int i = 0; i < numRows && idx < len; i++) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n        for (int i = numRows-2; i > 0 && idx < len; i--) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n    }\\n    \\n    for (int i = 1; i < numRows; i++) {\\n        sb[0].append(sb[i]);\\n    }\\n    return sb[0].toString();\\n}\\n\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Doing this on my birthday, and was able to come up with a ac solution."
                    },
                    {
                        "username": "syed-m-osama",
                        "content": "```\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int vertical = numRows;\n        int diagonal = vertical - 2;\n        int next = vertical + diagonal;\n        vector<vector<char>> matrix(vertical);\n        int c = 0, r = 0, i = 0;\n        while(i < s.length()){\n            while(r < vertical){\n                matrix[r].push_back(s[i]);\n                r++, i++;\n            }\n            if(i >= s.length()){ break; }\n            r-=2;\n            while(vertical - r != vertical){\n                matrix[r].push_back(s[i]);\n                r--, i++;     \n            }\n        }\n        string res ;\n        for(int k = 0; k< vertical; k++){\n            for(int j = 0; j< matrix[k].size(); j++){\n                res.push_back(matrix[k][j]);\n            }   \n        }\n        return res;\n    }\n};\n```\n\ncan somebody help me why its not working even there's no diff between 'expected' and 'output' solutions."
                    }
                ]
            },
            {
                "id": 1786066,
                "content": [
                    {
                        "username": "Yongbi",
                        "content": "```\n#1. Just create an empty list (length of numRows), then\n#2. Follow a loop of letter in the given string. \n#3. Pick up each letter in at each iteration by the following rule: \n#4. Define a _pointer_ or _i_  run in the range(0, numRows) with direction. \nWhen i=0 inscrease i+=1, direction=1, \notherwise, i=numRows then descreases i-=1, direction=-1.\nlist[i]+=letter\n#5. Return \"\".join(list)\n```\nMy solution is O(n), I'm thinking about an O(log(n)) solution."
                    },
                    {
                        "username": "aha_an007",
                        "content": "hi danish keep growing buddy !!!!!!!!"
                    },
                    {
                        "username": "mddanishsamir",
                        "content": "Hii Mudassir,\\nchamp where are you\\n"
                    },
                    {
                        "username": "kelvin950",
                        "content": "Took me two hours to solve this question. went through the discussion avoiding the solutions. saw \"rail fence cipher \" and searched it on google. create  a 2d array to store  the strings but loop through from column to row, top to down, when you reach the last row (numRows-1) move up by reducing row by one and diagonally by increasing column by 1 till you reach 0 and start over again."
                    },
                    {
                        "username": "pokaChika",
                        "content": "use me as a dislike button for this question! #paypallayingoff"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode is playing with our feeling #paypal is laying off \n<br>\nUpvote It if you Like My solution <br>\nMy solution link : -> https://leetcode.com/problems/zigzag-conversion/solutions/3136532/c-easy-and-simple-solution-using-2d-array/"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "easy to solve\\nhard to even understand since the question didnt give a f about readers lol"
                    },
                    {
                        "username": "bikram7151",
                        "content": "Explanation:\\n\\n1.If numRows is equal to 1, the string does not need to be converted and can be returned as is.\\n2.Create an array of StringBuilder objects with numRows elements.\\n3.Use a while loop to traverse the input string s.\\n4.In each iteration, append characters to the StringBuilder objects in the following way: first append to the 0th, then 1st, 2nd, ... numRows-1th elements, then numRows-2nd, numRows-3rd, ... 1st elements, and so on.\\n5.Finally, append all the StringBuilder objects except for the 0th to the 0th StringBuilder, and return the result as a string.\\n\\npublic String convert(String s, int numRows) {\\n    if (numRows == 1) return s;\\n    \\n    int len = s.length();\\n    StringBuilder[] sb = new StringBuilder[numRows];\\n    for (int i = 0; i < numRows; i++) {\\n        sb[i] = new StringBuilder();\\n    }\\n    \\n    int idx = 0;\\n    while (idx < len) {\\n        for (int i = 0; i < numRows && idx < len; i++) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n        for (int i = numRows-2; i > 0 && idx < len; i--) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n    }\\n    \\n    for (int i = 1; i < numRows; i++) {\\n        sb[0].append(sb[i]);\\n    }\\n    return sb[0].toString();\\n}\\n\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Doing this on my birthday, and was able to come up with a ac solution."
                    },
                    {
                        "username": "syed-m-osama",
                        "content": "```\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int vertical = numRows;\n        int diagonal = vertical - 2;\n        int next = vertical + diagonal;\n        vector<vector<char>> matrix(vertical);\n        int c = 0, r = 0, i = 0;\n        while(i < s.length()){\n            while(r < vertical){\n                matrix[r].push_back(s[i]);\n                r++, i++;\n            }\n            if(i >= s.length()){ break; }\n            r-=2;\n            while(vertical - r != vertical){\n                matrix[r].push_back(s[i]);\n                r--, i++;     \n            }\n        }\n        string res ;\n        for(int k = 0; k< vertical; k++){\n            for(int j = 0; j< matrix[k].size(); j++){\n                res.push_back(matrix[k][j]);\n            }   \n        }\n        return res;\n    }\n};\n```\n\ncan somebody help me why its not working even there's no diff between 'expected' and 'output' solutions."
                    }
                ]
            },
            {
                "id": 1786060,
                "content": [
                    {
                        "username": "Yongbi",
                        "content": "```\n#1. Just create an empty list (length of numRows), then\n#2. Follow a loop of letter in the given string. \n#3. Pick up each letter in at each iteration by the following rule: \n#4. Define a _pointer_ or _i_  run in the range(0, numRows) with direction. \nWhen i=0 inscrease i+=1, direction=1, \notherwise, i=numRows then descreases i-=1, direction=-1.\nlist[i]+=letter\n#5. Return \"\".join(list)\n```\nMy solution is O(n), I'm thinking about an O(log(n)) solution."
                    },
                    {
                        "username": "aha_an007",
                        "content": "hi danish keep growing buddy !!!!!!!!"
                    },
                    {
                        "username": "mddanishsamir",
                        "content": "Hii Mudassir,\\nchamp where are you\\n"
                    },
                    {
                        "username": "kelvin950",
                        "content": "Took me two hours to solve this question. went through the discussion avoiding the solutions. saw \"rail fence cipher \" and searched it on google. create  a 2d array to store  the strings but loop through from column to row, top to down, when you reach the last row (numRows-1) move up by reducing row by one and diagonally by increasing column by 1 till you reach 0 and start over again."
                    },
                    {
                        "username": "pokaChika",
                        "content": "use me as a dislike button for this question! #paypallayingoff"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode is playing with our feeling #paypal is laying off \n<br>\nUpvote It if you Like My solution <br>\nMy solution link : -> https://leetcode.com/problems/zigzag-conversion/solutions/3136532/c-easy-and-simple-solution-using-2d-array/"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "easy to solve\\nhard to even understand since the question didnt give a f about readers lol"
                    },
                    {
                        "username": "bikram7151",
                        "content": "Explanation:\\n\\n1.If numRows is equal to 1, the string does not need to be converted and can be returned as is.\\n2.Create an array of StringBuilder objects with numRows elements.\\n3.Use a while loop to traverse the input string s.\\n4.In each iteration, append characters to the StringBuilder objects in the following way: first append to the 0th, then 1st, 2nd, ... numRows-1th elements, then numRows-2nd, numRows-3rd, ... 1st elements, and so on.\\n5.Finally, append all the StringBuilder objects except for the 0th to the 0th StringBuilder, and return the result as a string.\\n\\npublic String convert(String s, int numRows) {\\n    if (numRows == 1) return s;\\n    \\n    int len = s.length();\\n    StringBuilder[] sb = new StringBuilder[numRows];\\n    for (int i = 0; i < numRows; i++) {\\n        sb[i] = new StringBuilder();\\n    }\\n    \\n    int idx = 0;\\n    while (idx < len) {\\n        for (int i = 0; i < numRows && idx < len; i++) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n        for (int i = numRows-2; i > 0 && idx < len; i--) {\\n            sb[i].append(s.charAt(idx++));\\n        }\\n    }\\n    \\n    for (int i = 1; i < numRows; i++) {\\n        sb[0].append(sb[i]);\\n    }\\n    return sb[0].toString();\\n}\\n\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Doing this on my birthday, and was able to come up with a ac solution."
                    },
                    {
                        "username": "syed-m-osama",
                        "content": "```\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int vertical = numRows;\n        int diagonal = vertical - 2;\n        int next = vertical + diagonal;\n        vector<vector<char>> matrix(vertical);\n        int c = 0, r = 0, i = 0;\n        while(i < s.length()){\n            while(r < vertical){\n                matrix[r].push_back(s[i]);\n                r++, i++;\n            }\n            if(i >= s.length()){ break; }\n            r-=2;\n            while(vertical - r != vertical){\n                matrix[r].push_back(s[i]);\n                r--, i++;     \n            }\n        }\n        string res ;\n        for(int k = 0; k< vertical; k++){\n            for(int j = 0; j< matrix[k].size(); j++){\n                res.push_back(matrix[k][j]);\n            }   \n        }\n        return res;\n    }\n};\n```\n\ncan somebody help me why its not working even there's no diff between 'expected' and 'output' solutions."
                    }
                ]
            },
            {
                "id": 1786040,
                "content": [
                    {
                        "username": "armagan979",
                        "content": "//what is wrong with the approach.. and why the ans array is not getting updated. could anyone help\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "anoyash",
                        "content": "just analyse the index and subsequent gaps each row -  wise\nfor given test case , numRows = 4 , \ninitial gap will be : 2*( numRows - 1)\n1  ->  7 -> 13\n2  ->  6 -> 8 -> 12 -> 14\n3  -> 9  -> 11\n4 -> 10\n ---------------------->\n +6 -> +6\n+4  -> +2 -> +4 -> +2 \n+2 -> + 4 -> +2 -> +4\n+6 -> +6  "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easy implementation\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans=\"\";\\n        int kd=2*(numRows-1),n=s.size();\\n        if(kd==0){\\n            return s;\\n        }\\n        else{\\n            for(int i=0;i<numRows;i++){\\n                int ci=i;\\n                while(ci<=n-1){\\n                    ans+=s[ci];\\n                 if(i!=0&&i!=numRows-1){\\n                    int secondindx=ci+(kd-2*i);\\n                    if(secondindx<=n-1){\\n                        ans+=s[secondindx];\\n                    }\\n                 }\\n                ci=ci+kd;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "The edge case is not given : what should be returned if the numRows is greater than the length of the string s itself?\\nThen the code won\\'t work - but what must be returned??\\n\\n\\n\\n\\n\\nEven if there is no edge case like this - then the question must specify a condition like : \"numRows <= s.size()\""
                    },
                    {
                        "username": "Mariia_89",
                        "content": "There was a test case s = \\xABAB\\xBB, numRows = 3. The correct answer was \\u201CAB\\u201D"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "I don\\'t think the problem is medium,it\\'s easier when you just forgot about the  ziczac and space things, it\\'s just like put the character into row from top to bottom and vice versa."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Spend many times for priority_queue implementation and realized that the container does not give the desired sequence of elements with the same index.\\n`#priority_queue`"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n    class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        ans = [\"\" for _ in range(numRows)]\\n        n = len(s)\\n        for i in range(n):\\n            m = i%(2*numRows-2) \\n            if m < numRows:\\n                ans[m] += s[i]\\n            else:\\n                ans[numRows-m-2] += s[i]\\n                \\n        return \\'\\'.join(ans)\\n\\n\\n    def convert(self, s, numRows):\\n        box= collections.defaultdict(str)\\n        j = 0\\n        increment = 1\\n        for i , char in enumerate(s):\\n            box[j] += char\\n            j  += increment\\n            if j == numRows - 1 or j == 0:\\n                increment = - increment\\n        keys = list(box.keys())\\n        keys.sort()\\n        return \\'\\'.join(box[i] for i in keys)\\n\\uD83D\\uDE02\\uD83E\\uDD17\\uD83E\\uDD70"
                    },
                    {
                        "username": "waky",
                        "content": "If anybody wants to understand the question, check the diagram given in solution tab!!"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Now Paypall is laying off. Also big tech companies too sad "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can someone please explain the question briefly?"
                    }
                ]
            },
            {
                "id": 1786032,
                "content": [
                    {
                        "username": "armagan979",
                        "content": "//what is wrong with the approach.. and why the ans array is not getting updated. could anyone help\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "anoyash",
                        "content": "just analyse the index and subsequent gaps each row -  wise\nfor given test case , numRows = 4 , \ninitial gap will be : 2*( numRows - 1)\n1  ->  7 -> 13\n2  ->  6 -> 8 -> 12 -> 14\n3  -> 9  -> 11\n4 -> 10\n ---------------------->\n +6 -> +6\n+4  -> +2 -> +4 -> +2 \n+2 -> + 4 -> +2 -> +4\n+6 -> +6  "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easy implementation\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans=\"\";\\n        int kd=2*(numRows-1),n=s.size();\\n        if(kd==0){\\n            return s;\\n        }\\n        else{\\n            for(int i=0;i<numRows;i++){\\n                int ci=i;\\n                while(ci<=n-1){\\n                    ans+=s[ci];\\n                 if(i!=0&&i!=numRows-1){\\n                    int secondindx=ci+(kd-2*i);\\n                    if(secondindx<=n-1){\\n                        ans+=s[secondindx];\\n                    }\\n                 }\\n                ci=ci+kd;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "The edge case is not given : what should be returned if the numRows is greater than the length of the string s itself?\\nThen the code won\\'t work - but what must be returned??\\n\\n\\n\\n\\n\\nEven if there is no edge case like this - then the question must specify a condition like : \"numRows <= s.size()\""
                    },
                    {
                        "username": "Mariia_89",
                        "content": "There was a test case s = \\xABAB\\xBB, numRows = 3. The correct answer was \\u201CAB\\u201D"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "I don\\'t think the problem is medium,it\\'s easier when you just forgot about the  ziczac and space things, it\\'s just like put the character into row from top to bottom and vice versa."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Spend many times for priority_queue implementation and realized that the container does not give the desired sequence of elements with the same index.\\n`#priority_queue`"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n    class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        ans = [\"\" for _ in range(numRows)]\\n        n = len(s)\\n        for i in range(n):\\n            m = i%(2*numRows-2) \\n            if m < numRows:\\n                ans[m] += s[i]\\n            else:\\n                ans[numRows-m-2] += s[i]\\n                \\n        return \\'\\'.join(ans)\\n\\n\\n    def convert(self, s, numRows):\\n        box= collections.defaultdict(str)\\n        j = 0\\n        increment = 1\\n        for i , char in enumerate(s):\\n            box[j] += char\\n            j  += increment\\n            if j == numRows - 1 or j == 0:\\n                increment = - increment\\n        keys = list(box.keys())\\n        keys.sort()\\n        return \\'\\'.join(box[i] for i in keys)\\n\\uD83D\\uDE02\\uD83E\\uDD17\\uD83E\\uDD70"
                    },
                    {
                        "username": "waky",
                        "content": "If anybody wants to understand the question, check the diagram given in solution tab!!"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Now Paypall is laying off. Also big tech companies too sad "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can someone please explain the question briefly?"
                    }
                ]
            },
            {
                "id": 1786022,
                "content": [
                    {
                        "username": "armagan979",
                        "content": "//what is wrong with the approach.. and why the ans array is not getting updated. could anyone help\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "anoyash",
                        "content": "just analyse the index and subsequent gaps each row -  wise\nfor given test case , numRows = 4 , \ninitial gap will be : 2*( numRows - 1)\n1  ->  7 -> 13\n2  ->  6 -> 8 -> 12 -> 14\n3  -> 9  -> 11\n4 -> 10\n ---------------------->\n +6 -> +6\n+4  -> +2 -> +4 -> +2 \n+2 -> + 4 -> +2 -> +4\n+6 -> +6  "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easy implementation\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans=\"\";\\n        int kd=2*(numRows-1),n=s.size();\\n        if(kd==0){\\n            return s;\\n        }\\n        else{\\n            for(int i=0;i<numRows;i++){\\n                int ci=i;\\n                while(ci<=n-1){\\n                    ans+=s[ci];\\n                 if(i!=0&&i!=numRows-1){\\n                    int secondindx=ci+(kd-2*i);\\n                    if(secondindx<=n-1){\\n                        ans+=s[secondindx];\\n                    }\\n                 }\\n                ci=ci+kd;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "The edge case is not given : what should be returned if the numRows is greater than the length of the string s itself?\\nThen the code won\\'t work - but what must be returned??\\n\\n\\n\\n\\n\\nEven if there is no edge case like this - then the question must specify a condition like : \"numRows <= s.size()\""
                    },
                    {
                        "username": "Mariia_89",
                        "content": "There was a test case s = \\xABAB\\xBB, numRows = 3. The correct answer was \\u201CAB\\u201D"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "I don\\'t think the problem is medium,it\\'s easier when you just forgot about the  ziczac and space things, it\\'s just like put the character into row from top to bottom and vice versa."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Spend many times for priority_queue implementation and realized that the container does not give the desired sequence of elements with the same index.\\n`#priority_queue`"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n    class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        ans = [\"\" for _ in range(numRows)]\\n        n = len(s)\\n        for i in range(n):\\n            m = i%(2*numRows-2) \\n            if m < numRows:\\n                ans[m] += s[i]\\n            else:\\n                ans[numRows-m-2] += s[i]\\n                \\n        return \\'\\'.join(ans)\\n\\n\\n    def convert(self, s, numRows):\\n        box= collections.defaultdict(str)\\n        j = 0\\n        increment = 1\\n        for i , char in enumerate(s):\\n            box[j] += char\\n            j  += increment\\n            if j == numRows - 1 or j == 0:\\n                increment = - increment\\n        keys = list(box.keys())\\n        keys.sort()\\n        return \\'\\'.join(box[i] for i in keys)\\n\\uD83D\\uDE02\\uD83E\\uDD17\\uD83E\\uDD70"
                    },
                    {
                        "username": "waky",
                        "content": "If anybody wants to understand the question, check the diagram given in solution tab!!"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Now Paypall is laying off. Also big tech companies too sad "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can someone please explain the question briefly?"
                    }
                ]
            },
            {
                "id": 1786015,
                "content": [
                    {
                        "username": "armagan979",
                        "content": "//what is wrong with the approach.. and why the ans array is not getting updated. could anyone help\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "anoyash",
                        "content": "just analyse the index and subsequent gaps each row -  wise\nfor given test case , numRows = 4 , \ninitial gap will be : 2*( numRows - 1)\n1  ->  7 -> 13\n2  ->  6 -> 8 -> 12 -> 14\n3  -> 9  -> 11\n4 -> 10\n ---------------------->\n +6 -> +6\n+4  -> +2 -> +4 -> +2 \n+2 -> + 4 -> +2 -> +4\n+6 -> +6  "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easy implementation\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans=\"\";\\n        int kd=2*(numRows-1),n=s.size();\\n        if(kd==0){\\n            return s;\\n        }\\n        else{\\n            for(int i=0;i<numRows;i++){\\n                int ci=i;\\n                while(ci<=n-1){\\n                    ans+=s[ci];\\n                 if(i!=0&&i!=numRows-1){\\n                    int secondindx=ci+(kd-2*i);\\n                    if(secondindx<=n-1){\\n                        ans+=s[secondindx];\\n                    }\\n                 }\\n                ci=ci+kd;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "The edge case is not given : what should be returned if the numRows is greater than the length of the string s itself?\\nThen the code won\\'t work - but what must be returned??\\n\\n\\n\\n\\n\\nEven if there is no edge case like this - then the question must specify a condition like : \"numRows <= s.size()\""
                    },
                    {
                        "username": "Mariia_89",
                        "content": "There was a test case s = \\xABAB\\xBB, numRows = 3. The correct answer was \\u201CAB\\u201D"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "I don\\'t think the problem is medium,it\\'s easier when you just forgot about the  ziczac and space things, it\\'s just like put the character into row from top to bottom and vice versa."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Spend many times for priority_queue implementation and realized that the container does not give the desired sequence of elements with the same index.\\n`#priority_queue`"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n    class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        ans = [\"\" for _ in range(numRows)]\\n        n = len(s)\\n        for i in range(n):\\n            m = i%(2*numRows-2) \\n            if m < numRows:\\n                ans[m] += s[i]\\n            else:\\n                ans[numRows-m-2] += s[i]\\n                \\n        return \\'\\'.join(ans)\\n\\n\\n    def convert(self, s, numRows):\\n        box= collections.defaultdict(str)\\n        j = 0\\n        increment = 1\\n        for i , char in enumerate(s):\\n            box[j] += char\\n            j  += increment\\n            if j == numRows - 1 or j == 0:\\n                increment = - increment\\n        keys = list(box.keys())\\n        keys.sort()\\n        return \\'\\'.join(box[i] for i in keys)\\n\\uD83D\\uDE02\\uD83E\\uDD17\\uD83E\\uDD70"
                    },
                    {
                        "username": "waky",
                        "content": "If anybody wants to understand the question, check the diagram given in solution tab!!"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Now Paypall is laying off. Also big tech companies too sad "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can someone please explain the question briefly?"
                    }
                ]
            },
            {
                "id": 1786003,
                "content": [
                    {
                        "username": "armagan979",
                        "content": "//what is wrong with the approach.. and why the ans array is not getting updated. could anyone help\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "anoyash",
                        "content": "just analyse the index and subsequent gaps each row -  wise\nfor given test case , numRows = 4 , \ninitial gap will be : 2*( numRows - 1)\n1  ->  7 -> 13\n2  ->  6 -> 8 -> 12 -> 14\n3  -> 9  -> 11\n4 -> 10\n ---------------------->\n +6 -> +6\n+4  -> +2 -> +4 -> +2 \n+2 -> + 4 -> +2 -> +4\n+6 -> +6  "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easy implementation\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans=\"\";\\n        int kd=2*(numRows-1),n=s.size();\\n        if(kd==0){\\n            return s;\\n        }\\n        else{\\n            for(int i=0;i<numRows;i++){\\n                int ci=i;\\n                while(ci<=n-1){\\n                    ans+=s[ci];\\n                 if(i!=0&&i!=numRows-1){\\n                    int secondindx=ci+(kd-2*i);\\n                    if(secondindx<=n-1){\\n                        ans+=s[secondindx];\\n                    }\\n                 }\\n                ci=ci+kd;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "The edge case is not given : what should be returned if the numRows is greater than the length of the string s itself?\\nThen the code won\\'t work - but what must be returned??\\n\\n\\n\\n\\n\\nEven if there is no edge case like this - then the question must specify a condition like : \"numRows <= s.size()\""
                    },
                    {
                        "username": "Mariia_89",
                        "content": "There was a test case s = \\xABAB\\xBB, numRows = 3. The correct answer was \\u201CAB\\u201D"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "I don\\'t think the problem is medium,it\\'s easier when you just forgot about the  ziczac and space things, it\\'s just like put the character into row from top to bottom and vice versa."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Spend many times for priority_queue implementation and realized that the container does not give the desired sequence of elements with the same index.\\n`#priority_queue`"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n    class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        ans = [\"\" for _ in range(numRows)]\\n        n = len(s)\\n        for i in range(n):\\n            m = i%(2*numRows-2) \\n            if m < numRows:\\n                ans[m] += s[i]\\n            else:\\n                ans[numRows-m-2] += s[i]\\n                \\n        return \\'\\'.join(ans)\\n\\n\\n    def convert(self, s, numRows):\\n        box= collections.defaultdict(str)\\n        j = 0\\n        increment = 1\\n        for i , char in enumerate(s):\\n            box[j] += char\\n            j  += increment\\n            if j == numRows - 1 or j == 0:\\n                increment = - increment\\n        keys = list(box.keys())\\n        keys.sort()\\n        return \\'\\'.join(box[i] for i in keys)\\n\\uD83D\\uDE02\\uD83E\\uDD17\\uD83E\\uDD70"
                    },
                    {
                        "username": "waky",
                        "content": "If anybody wants to understand the question, check the diagram given in solution tab!!"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Now Paypall is laying off. Also big tech companies too sad "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can someone please explain the question briefly?"
                    }
                ]
            },
            {
                "id": 1785981,
                "content": [
                    {
                        "username": "armagan979",
                        "content": "//what is wrong with the approach.. and why the ans array is not getting updated. could anyone help\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "anoyash",
                        "content": "just analyse the index and subsequent gaps each row -  wise\nfor given test case , numRows = 4 , \ninitial gap will be : 2*( numRows - 1)\n1  ->  7 -> 13\n2  ->  6 -> 8 -> 12 -> 14\n3  -> 9  -> 11\n4 -> 10\n ---------------------->\n +6 -> +6\n+4  -> +2 -> +4 -> +2 \n+2 -> + 4 -> +2 -> +4\n+6 -> +6  "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easy implementation\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans=\"\";\\n        int kd=2*(numRows-1),n=s.size();\\n        if(kd==0){\\n            return s;\\n        }\\n        else{\\n            for(int i=0;i<numRows;i++){\\n                int ci=i;\\n                while(ci<=n-1){\\n                    ans+=s[ci];\\n                 if(i!=0&&i!=numRows-1){\\n                    int secondindx=ci+(kd-2*i);\\n                    if(secondindx<=n-1){\\n                        ans+=s[secondindx];\\n                    }\\n                 }\\n                ci=ci+kd;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "The edge case is not given : what should be returned if the numRows is greater than the length of the string s itself?\\nThen the code won\\'t work - but what must be returned??\\n\\n\\n\\n\\n\\nEven if there is no edge case like this - then the question must specify a condition like : \"numRows <= s.size()\""
                    },
                    {
                        "username": "Mariia_89",
                        "content": "There was a test case s = \\xABAB\\xBB, numRows = 3. The correct answer was \\u201CAB\\u201D"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "I don\\'t think the problem is medium,it\\'s easier when you just forgot about the  ziczac and space things, it\\'s just like put the character into row from top to bottom and vice versa."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Spend many times for priority_queue implementation and realized that the container does not give the desired sequence of elements with the same index.\\n`#priority_queue`"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n    class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        ans = [\"\" for _ in range(numRows)]\\n        n = len(s)\\n        for i in range(n):\\n            m = i%(2*numRows-2) \\n            if m < numRows:\\n                ans[m] += s[i]\\n            else:\\n                ans[numRows-m-2] += s[i]\\n                \\n        return \\'\\'.join(ans)\\n\\n\\n    def convert(self, s, numRows):\\n        box= collections.defaultdict(str)\\n        j = 0\\n        increment = 1\\n        for i , char in enumerate(s):\\n            box[j] += char\\n            j  += increment\\n            if j == numRows - 1 or j == 0:\\n                increment = - increment\\n        keys = list(box.keys())\\n        keys.sort()\\n        return \\'\\'.join(box[i] for i in keys)\\n\\uD83D\\uDE02\\uD83E\\uDD17\\uD83E\\uDD70"
                    },
                    {
                        "username": "waky",
                        "content": "If anybody wants to understand the question, check the diagram given in solution tab!!"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Now Paypall is laying off. Also big tech companies too sad "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can someone please explain the question briefly?"
                    }
                ]
            },
            {
                "id": 1785936,
                "content": [
                    {
                        "username": "armagan979",
                        "content": "//what is wrong with the approach.. and why the ans array is not getting updated. could anyone help\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "anoyash",
                        "content": "just analyse the index and subsequent gaps each row -  wise\nfor given test case , numRows = 4 , \ninitial gap will be : 2*( numRows - 1)\n1  ->  7 -> 13\n2  ->  6 -> 8 -> 12 -> 14\n3  -> 9  -> 11\n4 -> 10\n ---------------------->\n +6 -> +6\n+4  -> +2 -> +4 -> +2 \n+2 -> + 4 -> +2 -> +4\n+6 -> +6  "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easy implementation\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans=\"\";\\n        int kd=2*(numRows-1),n=s.size();\\n        if(kd==0){\\n            return s;\\n        }\\n        else{\\n            for(int i=0;i<numRows;i++){\\n                int ci=i;\\n                while(ci<=n-1){\\n                    ans+=s[ci];\\n                 if(i!=0&&i!=numRows-1){\\n                    int secondindx=ci+(kd-2*i);\\n                    if(secondindx<=n-1){\\n                        ans+=s[secondindx];\\n                    }\\n                 }\\n                ci=ci+kd;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "The edge case is not given : what should be returned if the numRows is greater than the length of the string s itself?\\nThen the code won\\'t work - but what must be returned??\\n\\n\\n\\n\\n\\nEven if there is no edge case like this - then the question must specify a condition like : \"numRows <= s.size()\""
                    },
                    {
                        "username": "Mariia_89",
                        "content": "There was a test case s = \\xABAB\\xBB, numRows = 3. The correct answer was \\u201CAB\\u201D"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "I don\\'t think the problem is medium,it\\'s easier when you just forgot about the  ziczac and space things, it\\'s just like put the character into row from top to bottom and vice versa."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Spend many times for priority_queue implementation and realized that the container does not give the desired sequence of elements with the same index.\\n`#priority_queue`"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n    class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        ans = [\"\" for _ in range(numRows)]\\n        n = len(s)\\n        for i in range(n):\\n            m = i%(2*numRows-2) \\n            if m < numRows:\\n                ans[m] += s[i]\\n            else:\\n                ans[numRows-m-2] += s[i]\\n                \\n        return \\'\\'.join(ans)\\n\\n\\n    def convert(self, s, numRows):\\n        box= collections.defaultdict(str)\\n        j = 0\\n        increment = 1\\n        for i , char in enumerate(s):\\n            box[j] += char\\n            j  += increment\\n            if j == numRows - 1 or j == 0:\\n                increment = - increment\\n        keys = list(box.keys())\\n        keys.sort()\\n        return \\'\\'.join(box[i] for i in keys)\\n\\uD83D\\uDE02\\uD83E\\uDD17\\uD83E\\uDD70"
                    },
                    {
                        "username": "waky",
                        "content": "If anybody wants to understand the question, check the diagram given in solution tab!!"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Now Paypall is laying off. Also big tech companies too sad "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can someone please explain the question briefly?"
                    }
                ]
            },
            {
                "id": 1785924,
                "content": [
                    {
                        "username": "armagan979",
                        "content": "//what is wrong with the approach.. and why the ans array is not getting updated. could anyone help\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "anoyash",
                        "content": "just analyse the index and subsequent gaps each row -  wise\nfor given test case , numRows = 4 , \ninitial gap will be : 2*( numRows - 1)\n1  ->  7 -> 13\n2  ->  6 -> 8 -> 12 -> 14\n3  -> 9  -> 11\n4 -> 10\n ---------------------->\n +6 -> +6\n+4  -> +2 -> +4 -> +2 \n+2 -> + 4 -> +2 -> +4\n+6 -> +6  "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easy implementation\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans=\"\";\\n        int kd=2*(numRows-1),n=s.size();\\n        if(kd==0){\\n            return s;\\n        }\\n        else{\\n            for(int i=0;i<numRows;i++){\\n                int ci=i;\\n                while(ci<=n-1){\\n                    ans+=s[ci];\\n                 if(i!=0&&i!=numRows-1){\\n                    int secondindx=ci+(kd-2*i);\\n                    if(secondindx<=n-1){\\n                        ans+=s[secondindx];\\n                    }\\n                 }\\n                ci=ci+kd;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "The edge case is not given : what should be returned if the numRows is greater than the length of the string s itself?\\nThen the code won\\'t work - but what must be returned??\\n\\n\\n\\n\\n\\nEven if there is no edge case like this - then the question must specify a condition like : \"numRows <= s.size()\""
                    },
                    {
                        "username": "Mariia_89",
                        "content": "There was a test case s = \\xABAB\\xBB, numRows = 3. The correct answer was \\u201CAB\\u201D"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "I don\\'t think the problem is medium,it\\'s easier when you just forgot about the  ziczac and space things, it\\'s just like put the character into row from top to bottom and vice versa."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Spend many times for priority_queue implementation and realized that the container does not give the desired sequence of elements with the same index.\\n`#priority_queue`"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n    class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        ans = [\"\" for _ in range(numRows)]\\n        n = len(s)\\n        for i in range(n):\\n            m = i%(2*numRows-2) \\n            if m < numRows:\\n                ans[m] += s[i]\\n            else:\\n                ans[numRows-m-2] += s[i]\\n                \\n        return \\'\\'.join(ans)\\n\\n\\n    def convert(self, s, numRows):\\n        box= collections.defaultdict(str)\\n        j = 0\\n        increment = 1\\n        for i , char in enumerate(s):\\n            box[j] += char\\n            j  += increment\\n            if j == numRows - 1 or j == 0:\\n                increment = - increment\\n        keys = list(box.keys())\\n        keys.sort()\\n        return \\'\\'.join(box[i] for i in keys)\\n\\uD83D\\uDE02\\uD83E\\uDD17\\uD83E\\uDD70"
                    },
                    {
                        "username": "waky",
                        "content": "If anybody wants to understand the question, check the diagram given in solution tab!!"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Now Paypall is laying off. Also big tech companies too sad "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can someone please explain the question briefly?"
                    }
                ]
            },
            {
                "id": 1785882,
                "content": [
                    {
                        "username": "armagan979",
                        "content": "//what is wrong with the approach.. and why the ans array is not getting updated. could anyone help\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "anoyash",
                        "content": "just analyse the index and subsequent gaps each row -  wise\nfor given test case , numRows = 4 , \ninitial gap will be : 2*( numRows - 1)\n1  ->  7 -> 13\n2  ->  6 -> 8 -> 12 -> 14\n3  -> 9  -> 11\n4 -> 10\n ---------------------->\n +6 -> +6\n+4  -> +2 -> +4 -> +2 \n+2 -> + 4 -> +2 -> +4\n+6 -> +6  "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easy implementation\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans=\"\";\\n        int kd=2*(numRows-1),n=s.size();\\n        if(kd==0){\\n            return s;\\n        }\\n        else{\\n            for(int i=0;i<numRows;i++){\\n                int ci=i;\\n                while(ci<=n-1){\\n                    ans+=s[ci];\\n                 if(i!=0&&i!=numRows-1){\\n                    int secondindx=ci+(kd-2*i);\\n                    if(secondindx<=n-1){\\n                        ans+=s[secondindx];\\n                    }\\n                 }\\n                ci=ci+kd;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "The edge case is not given : what should be returned if the numRows is greater than the length of the string s itself?\\nThen the code won\\'t work - but what must be returned??\\n\\n\\n\\n\\n\\nEven if there is no edge case like this - then the question must specify a condition like : \"numRows <= s.size()\""
                    },
                    {
                        "username": "Mariia_89",
                        "content": "There was a test case s = \\xABAB\\xBB, numRows = 3. The correct answer was \\u201CAB\\u201D"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "I don\\'t think the problem is medium,it\\'s easier when you just forgot about the  ziczac and space things, it\\'s just like put the character into row from top to bottom and vice versa."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Spend many times for priority_queue implementation and realized that the container does not give the desired sequence of elements with the same index.\\n`#priority_queue`"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n    class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        ans = [\"\" for _ in range(numRows)]\\n        n = len(s)\\n        for i in range(n):\\n            m = i%(2*numRows-2) \\n            if m < numRows:\\n                ans[m] += s[i]\\n            else:\\n                ans[numRows-m-2] += s[i]\\n                \\n        return \\'\\'.join(ans)\\n\\n\\n    def convert(self, s, numRows):\\n        box= collections.defaultdict(str)\\n        j = 0\\n        increment = 1\\n        for i , char in enumerate(s):\\n            box[j] += char\\n            j  += increment\\n            if j == numRows - 1 or j == 0:\\n                increment = - increment\\n        keys = list(box.keys())\\n        keys.sort()\\n        return \\'\\'.join(box[i] for i in keys)\\n\\uD83D\\uDE02\\uD83E\\uDD17\\uD83E\\uDD70"
                    },
                    {
                        "username": "waky",
                        "content": "If anybody wants to understand the question, check the diagram given in solution tab!!"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Now Paypall is laying off. Also big tech companies too sad "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can someone please explain the question briefly?"
                    }
                ]
            },
            {
                "id": 1785844,
                "content": [
                    {
                        "username": "armagan979",
                        "content": "//what is wrong with the approach.. and why the ans array is not getting updated. could anyone help\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        if(numRows ==1)\\n        return s;\\n\\n        int i,j,k,n,counter;\\n        n=s.size();\\n        i=0;j=0;\\n        counter=1;\\n        char ans[1001][1001];\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++)\\n            ans[i][j]=\\'_\\';\\n        }\\n        k=0;\\n        while(k<n){\\n            if(counter==1){\\n                ans[i][j]=s[k];\\n                i++;\\n                if(i==numRows){\\n                    counter=-1;\\n                    i=i-2;\\n                    j++;\\n                }\\n            }\\n            else{\\n                ans[i][j]=s[k];\\n                j++;\\n                i--;\\n                if(i==0){\\n                    counter=1;\\n                }\\n            }\\n            k++;\\n        }\\n        k=0;\\n        for(i=0;i<numRows;i++){\\n            for(j=0;j<n;j++){\\n                if(ans[i][j]!=\\'_\\'){\\n                    s[k]=ans[i][j];\\n                    k++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "anoyash",
                        "content": "just analyse the index and subsequent gaps each row -  wise\nfor given test case , numRows = 4 , \ninitial gap will be : 2*( numRows - 1)\n1  ->  7 -> 13\n2  ->  6 -> 8 -> 12 -> 14\n3  -> 9  -> 11\n4 -> 10\n ---------------------->\n +6 -> +6\n+4  -> +2 -> +4 -> +2 \n+2 -> + 4 -> +2 -> +4\n+6 -> +6  "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easy implementation\\nclass Solution {\\npublic:\\n    string convert(string s, int numRows) {\\n        string ans=\"\";\\n        int kd=2*(numRows-1),n=s.size();\\n        if(kd==0){\\n            return s;\\n        }\\n        else{\\n            for(int i=0;i<numRows;i++){\\n                int ci=i;\\n                while(ci<=n-1){\\n                    ans+=s[ci];\\n                 if(i!=0&&i!=numRows-1){\\n                    int secondindx=ci+(kd-2*i);\\n                    if(secondindx<=n-1){\\n                        ans+=s[secondindx];\\n                    }\\n                 }\\n                ci=ci+kd;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Eaglesight02",
                        "content": "The edge case is not given : what should be returned if the numRows is greater than the length of the string s itself?\\nThen the code won\\'t work - but what must be returned??\\n\\n\\n\\n\\n\\nEven if there is no edge case like this - then the question must specify a condition like : \"numRows <= s.size()\""
                    },
                    {
                        "username": "Mariia_89",
                        "content": "There was a test case s = \\xABAB\\xBB, numRows = 3. The correct answer was \\u201CAB\\u201D"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "I don\\'t think the problem is medium,it\\'s easier when you just forgot about the  ziczac and space things, it\\'s just like put the character into row from top to bottom and vice versa."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "Spend many times for priority_queue implementation and realized that the container does not give the desired sequence of elements with the same index.\\n`#priority_queue`"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n    class Solution:\\n    def convert(self, s: str, numRows: int) -> str:\\n        if numRows == 1: return s\\n        ans = [\"\" for _ in range(numRows)]\\n        n = len(s)\\n        for i in range(n):\\n            m = i%(2*numRows-2) \\n            if m < numRows:\\n                ans[m] += s[i]\\n            else:\\n                ans[numRows-m-2] += s[i]\\n                \\n        return \\'\\'.join(ans)\\n\\n\\n    def convert(self, s, numRows):\\n        box= collections.defaultdict(str)\\n        j = 0\\n        increment = 1\\n        for i , char in enumerate(s):\\n            box[j] += char\\n            j  += increment\\n            if j == numRows - 1 or j == 0:\\n                increment = - increment\\n        keys = list(box.keys())\\n        keys.sort()\\n        return \\'\\'.join(box[i] for i in keys)\\n\\uD83D\\uDE02\\uD83E\\uDD17\\uD83E\\uDD70"
                    },
                    {
                        "username": "waky",
                        "content": "If anybody wants to understand the question, check the diagram given in solution tab!!"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Now Paypall is laying off. Also big tech companies too sad "
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can someone please explain the question briefly?"
                    }
                ]
            },
            {
                "id": 1785822,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "This was a question which I did when I was just starting out, that time it took me an hour to do, but today I was able to do it in a few minutes !!\\nI am pretty happy rn : ) "
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky, tried a general solution but ended up having to handle 3 special cases (numRows == 0, 1, and 2)"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Will just give a tip take out pen and paper and write down jig jag pattern and try to find the logic , DO NOT I REPEAT DO NOT COPY OTHERS CODE IT WONT MAKE SENSE TILL YOU WRITE BY YOUR OWN. Just give some time while working on it. ALL THE BEST"
                    },
                    {
                        "username": "no-username",
                        "content": "I am looking for a job but I am ok to fail the interview if this type of question I get. "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use StringBuilder array and create the pattern."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Nope, PayPal is firing instead of hiring right now"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Essentially what is required from you Following : \\nthe given string is to be filled in number of rows given in a zig-gag manner.\\nlike this:\\n [P           A           H            N]\\n[   A    P      L    S     I      I        G]\\n[      Y            I           R]\\n\\nThat is Basically same as putting every character of string in given number of rows going from 1st row to last row then going to 1st row again.\\n\\nFor example: S=PAYPALISHIRING, NUMROWS= 3;\\n\\nIterating the string:\\n`0:row[0].append(s[0])`\\n`1:row[1].append(s[1])`\\n`2:row[2].append(s[2]) change to going up`\\n`3:row[1].append(s[3])`\\n`4:row[0].append(s[4]) change to going down`\\n`5:row[1].append(s[5])`\\nThis will continue till end of string. \\nHere till 6th character of string you have\\nrow[0] = [P ,A]\\nrow[1] = [A, P, L]\\nrow[2] = [Y]\\n\\nthis can be easily done by tracking the current row and if we are going up or down."
                    },
                    {
                        "username": "Jayanthsomuri",
                        "content": "The question description and the sample that they have shown don\\'t justify\\uD83D\\uDE2A\\uD83D\\uDE44"
                    },
                    {
                        "username": "agrawalharsh0522",
                        "content": "I got some stackoverflow problem , Don't know why\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        // we know numrows \n        // for column we will try some math \n        int size=s.length();\n\n        if(size<=numRows){\n            return s;\n        }\n\n        else{\n            int col=0;\n            int l=size;\n\n            while(l!=0){\n                if(l>=(numRows)+(numRows-2)){\n                    col=col+(numRows-1);\n                    l=l-(numRows)+(numRows-2);\n                }\n\n                else if(l>numRows && l<(numRows)+(numRows-2) ){\n                    col=col+(1+l-numRows);\n                    l=0;\n                }\n\n                else if(l<=numRows){\n                    col=col+1;\n                    l=0;\n                }\n            }\n\n            char mat[numRows][col];\n            int index=0;\n            int i;\n            for(int j=0;j<col;j++){\n                for( i=0;i<numRows;i++){\n                    mat[i][j]=s[index];\n                    index++;\n                }\n                while(i>0){\n                    j++;\n                    i--;\n                    mat[i][j]=s[index];\n                    index++;\n                }\n            }\n\n            string res;\n            for(int i=0;i<numRows;i++){\n                for(int j=0;j<col;j++){\n                    if(mat[i][j]!=NULL){\n                        res=res+mat[i][j];\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        return 0;\n    }\n};\n\n==31==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe1ae40010 at pc 0x00000034488d bp 0x7ffe1ae3fdb0 sp 0x7ffe1ae3fda8\nREAD of size 1 at 0x7ffe1ae40010 thread T0\n    #3 0x7f0a95ac00b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddress 0x7ffe1ae40010 is located in stack of thread T0 at offset 80 in frame\n  This frame has 2 object(s):"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Solution - https://leetcode.com/problems/zigzag-conversion/solutions/3134632/easy-and-neat-c-solution-using-array-of-pairs-full-explanation-o-n-m/\\n--> I have posted an easy C++ solution using array explaining the pattern and the approach in detail. The problem is easy if you get the pattern. Hope this helps you out.\\n"
                    }
                ]
            },
            {
                "id": 1785810,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "This was a question which I did when I was just starting out, that time it took me an hour to do, but today I was able to do it in a few minutes !!\\nI am pretty happy rn : ) "
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky, tried a general solution but ended up having to handle 3 special cases (numRows == 0, 1, and 2)"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Will just give a tip take out pen and paper and write down jig jag pattern and try to find the logic , DO NOT I REPEAT DO NOT COPY OTHERS CODE IT WONT MAKE SENSE TILL YOU WRITE BY YOUR OWN. Just give some time while working on it. ALL THE BEST"
                    },
                    {
                        "username": "no-username",
                        "content": "I am looking for a job but I am ok to fail the interview if this type of question I get. "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use StringBuilder array and create the pattern."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Nope, PayPal is firing instead of hiring right now"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Essentially what is required from you Following : \\nthe given string is to be filled in number of rows given in a zig-gag manner.\\nlike this:\\n [P           A           H            N]\\n[   A    P      L    S     I      I        G]\\n[      Y            I           R]\\n\\nThat is Basically same as putting every character of string in given number of rows going from 1st row to last row then going to 1st row again.\\n\\nFor example: S=PAYPALISHIRING, NUMROWS= 3;\\n\\nIterating the string:\\n`0:row[0].append(s[0])`\\n`1:row[1].append(s[1])`\\n`2:row[2].append(s[2]) change to going up`\\n`3:row[1].append(s[3])`\\n`4:row[0].append(s[4]) change to going down`\\n`5:row[1].append(s[5])`\\nThis will continue till end of string. \\nHere till 6th character of string you have\\nrow[0] = [P ,A]\\nrow[1] = [A, P, L]\\nrow[2] = [Y]\\n\\nthis can be easily done by tracking the current row and if we are going up or down."
                    },
                    {
                        "username": "Jayanthsomuri",
                        "content": "The question description and the sample that they have shown don\\'t justify\\uD83D\\uDE2A\\uD83D\\uDE44"
                    },
                    {
                        "username": "agrawalharsh0522",
                        "content": "I got some stackoverflow problem , Don't know why\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        // we know numrows \n        // for column we will try some math \n        int size=s.length();\n\n        if(size<=numRows){\n            return s;\n        }\n\n        else{\n            int col=0;\n            int l=size;\n\n            while(l!=0){\n                if(l>=(numRows)+(numRows-2)){\n                    col=col+(numRows-1);\n                    l=l-(numRows)+(numRows-2);\n                }\n\n                else if(l>numRows && l<(numRows)+(numRows-2) ){\n                    col=col+(1+l-numRows);\n                    l=0;\n                }\n\n                else if(l<=numRows){\n                    col=col+1;\n                    l=0;\n                }\n            }\n\n            char mat[numRows][col];\n            int index=0;\n            int i;\n            for(int j=0;j<col;j++){\n                for( i=0;i<numRows;i++){\n                    mat[i][j]=s[index];\n                    index++;\n                }\n                while(i>0){\n                    j++;\n                    i--;\n                    mat[i][j]=s[index];\n                    index++;\n                }\n            }\n\n            string res;\n            for(int i=0;i<numRows;i++){\n                for(int j=0;j<col;j++){\n                    if(mat[i][j]!=NULL){\n                        res=res+mat[i][j];\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        return 0;\n    }\n};\n\n==31==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe1ae40010 at pc 0x00000034488d bp 0x7ffe1ae3fdb0 sp 0x7ffe1ae3fda8\nREAD of size 1 at 0x7ffe1ae40010 thread T0\n    #3 0x7f0a95ac00b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddress 0x7ffe1ae40010 is located in stack of thread T0 at offset 80 in frame\n  This frame has 2 object(s):"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Solution - https://leetcode.com/problems/zigzag-conversion/solutions/3134632/easy-and-neat-c-solution-using-array-of-pairs-full-explanation-o-n-m/\\n--> I have posted an easy C++ solution using array explaining the pattern and the approach in detail. The problem is easy if you get the pattern. Hope this helps you out.\\n"
                    }
                ]
            },
            {
                "id": 1785738,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "This was a question which I did when I was just starting out, that time it took me an hour to do, but today I was able to do it in a few minutes !!\\nI am pretty happy rn : ) "
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky, tried a general solution but ended up having to handle 3 special cases (numRows == 0, 1, and 2)"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Will just give a tip take out pen and paper and write down jig jag pattern and try to find the logic , DO NOT I REPEAT DO NOT COPY OTHERS CODE IT WONT MAKE SENSE TILL YOU WRITE BY YOUR OWN. Just give some time while working on it. ALL THE BEST"
                    },
                    {
                        "username": "no-username",
                        "content": "I am looking for a job but I am ok to fail the interview if this type of question I get. "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use StringBuilder array and create the pattern."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Nope, PayPal is firing instead of hiring right now"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Essentially what is required from you Following : \\nthe given string is to be filled in number of rows given in a zig-gag manner.\\nlike this:\\n [P           A           H            N]\\n[   A    P      L    S     I      I        G]\\n[      Y            I           R]\\n\\nThat is Basically same as putting every character of string in given number of rows going from 1st row to last row then going to 1st row again.\\n\\nFor example: S=PAYPALISHIRING, NUMROWS= 3;\\n\\nIterating the string:\\n`0:row[0].append(s[0])`\\n`1:row[1].append(s[1])`\\n`2:row[2].append(s[2]) change to going up`\\n`3:row[1].append(s[3])`\\n`4:row[0].append(s[4]) change to going down`\\n`5:row[1].append(s[5])`\\nThis will continue till end of string. \\nHere till 6th character of string you have\\nrow[0] = [P ,A]\\nrow[1] = [A, P, L]\\nrow[2] = [Y]\\n\\nthis can be easily done by tracking the current row and if we are going up or down."
                    },
                    {
                        "username": "Jayanthsomuri",
                        "content": "The question description and the sample that they have shown don\\'t justify\\uD83D\\uDE2A\\uD83D\\uDE44"
                    },
                    {
                        "username": "agrawalharsh0522",
                        "content": "I got some stackoverflow problem , Don't know why\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        // we know numrows \n        // for column we will try some math \n        int size=s.length();\n\n        if(size<=numRows){\n            return s;\n        }\n\n        else{\n            int col=0;\n            int l=size;\n\n            while(l!=0){\n                if(l>=(numRows)+(numRows-2)){\n                    col=col+(numRows-1);\n                    l=l-(numRows)+(numRows-2);\n                }\n\n                else if(l>numRows && l<(numRows)+(numRows-2) ){\n                    col=col+(1+l-numRows);\n                    l=0;\n                }\n\n                else if(l<=numRows){\n                    col=col+1;\n                    l=0;\n                }\n            }\n\n            char mat[numRows][col];\n            int index=0;\n            int i;\n            for(int j=0;j<col;j++){\n                for( i=0;i<numRows;i++){\n                    mat[i][j]=s[index];\n                    index++;\n                }\n                while(i>0){\n                    j++;\n                    i--;\n                    mat[i][j]=s[index];\n                    index++;\n                }\n            }\n\n            string res;\n            for(int i=0;i<numRows;i++){\n                for(int j=0;j<col;j++){\n                    if(mat[i][j]!=NULL){\n                        res=res+mat[i][j];\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        return 0;\n    }\n};\n\n==31==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe1ae40010 at pc 0x00000034488d bp 0x7ffe1ae3fdb0 sp 0x7ffe1ae3fda8\nREAD of size 1 at 0x7ffe1ae40010 thread T0\n    #3 0x7f0a95ac00b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddress 0x7ffe1ae40010 is located in stack of thread T0 at offset 80 in frame\n  This frame has 2 object(s):"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Solution - https://leetcode.com/problems/zigzag-conversion/solutions/3134632/easy-and-neat-c-solution-using-array-of-pairs-full-explanation-o-n-m/\\n--> I have posted an easy C++ solution using array explaining the pattern and the approach in detail. The problem is easy if you get the pattern. Hope this helps you out.\\n"
                    }
                ]
            },
            {
                "id": 1785730,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "This was a question which I did when I was just starting out, that time it took me an hour to do, but today I was able to do it in a few minutes !!\\nI am pretty happy rn : ) "
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky, tried a general solution but ended up having to handle 3 special cases (numRows == 0, 1, and 2)"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Will just give a tip take out pen and paper and write down jig jag pattern and try to find the logic , DO NOT I REPEAT DO NOT COPY OTHERS CODE IT WONT MAKE SENSE TILL YOU WRITE BY YOUR OWN. Just give some time while working on it. ALL THE BEST"
                    },
                    {
                        "username": "no-username",
                        "content": "I am looking for a job but I am ok to fail the interview if this type of question I get. "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use StringBuilder array and create the pattern."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Nope, PayPal is firing instead of hiring right now"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Essentially what is required from you Following : \\nthe given string is to be filled in number of rows given in a zig-gag manner.\\nlike this:\\n [P           A           H            N]\\n[   A    P      L    S     I      I        G]\\n[      Y            I           R]\\n\\nThat is Basically same as putting every character of string in given number of rows going from 1st row to last row then going to 1st row again.\\n\\nFor example: S=PAYPALISHIRING, NUMROWS= 3;\\n\\nIterating the string:\\n`0:row[0].append(s[0])`\\n`1:row[1].append(s[1])`\\n`2:row[2].append(s[2]) change to going up`\\n`3:row[1].append(s[3])`\\n`4:row[0].append(s[4]) change to going down`\\n`5:row[1].append(s[5])`\\nThis will continue till end of string. \\nHere till 6th character of string you have\\nrow[0] = [P ,A]\\nrow[1] = [A, P, L]\\nrow[2] = [Y]\\n\\nthis can be easily done by tracking the current row and if we are going up or down."
                    },
                    {
                        "username": "Jayanthsomuri",
                        "content": "The question description and the sample that they have shown don\\'t justify\\uD83D\\uDE2A\\uD83D\\uDE44"
                    },
                    {
                        "username": "agrawalharsh0522",
                        "content": "I got some stackoverflow problem , Don't know why\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        // we know numrows \n        // for column we will try some math \n        int size=s.length();\n\n        if(size<=numRows){\n            return s;\n        }\n\n        else{\n            int col=0;\n            int l=size;\n\n            while(l!=0){\n                if(l>=(numRows)+(numRows-2)){\n                    col=col+(numRows-1);\n                    l=l-(numRows)+(numRows-2);\n                }\n\n                else if(l>numRows && l<(numRows)+(numRows-2) ){\n                    col=col+(1+l-numRows);\n                    l=0;\n                }\n\n                else if(l<=numRows){\n                    col=col+1;\n                    l=0;\n                }\n            }\n\n            char mat[numRows][col];\n            int index=0;\n            int i;\n            for(int j=0;j<col;j++){\n                for( i=0;i<numRows;i++){\n                    mat[i][j]=s[index];\n                    index++;\n                }\n                while(i>0){\n                    j++;\n                    i--;\n                    mat[i][j]=s[index];\n                    index++;\n                }\n            }\n\n            string res;\n            for(int i=0;i<numRows;i++){\n                for(int j=0;j<col;j++){\n                    if(mat[i][j]!=NULL){\n                        res=res+mat[i][j];\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        return 0;\n    }\n};\n\n==31==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe1ae40010 at pc 0x00000034488d bp 0x7ffe1ae3fdb0 sp 0x7ffe1ae3fda8\nREAD of size 1 at 0x7ffe1ae40010 thread T0\n    #3 0x7f0a95ac00b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddress 0x7ffe1ae40010 is located in stack of thread T0 at offset 80 in frame\n  This frame has 2 object(s):"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Solution - https://leetcode.com/problems/zigzag-conversion/solutions/3134632/easy-and-neat-c-solution-using-array-of-pairs-full-explanation-o-n-m/\\n--> I have posted an easy C++ solution using array explaining the pattern and the approach in detail. The problem is easy if you get the pattern. Hope this helps you out.\\n"
                    }
                ]
            },
            {
                "id": 1785711,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "This was a question which I did when I was just starting out, that time it took me an hour to do, but today I was able to do it in a few minutes !!\\nI am pretty happy rn : ) "
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky, tried a general solution but ended up having to handle 3 special cases (numRows == 0, 1, and 2)"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Will just give a tip take out pen and paper and write down jig jag pattern and try to find the logic , DO NOT I REPEAT DO NOT COPY OTHERS CODE IT WONT MAKE SENSE TILL YOU WRITE BY YOUR OWN. Just give some time while working on it. ALL THE BEST"
                    },
                    {
                        "username": "no-username",
                        "content": "I am looking for a job but I am ok to fail the interview if this type of question I get. "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use StringBuilder array and create the pattern."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Nope, PayPal is firing instead of hiring right now"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Essentially what is required from you Following : \\nthe given string is to be filled in number of rows given in a zig-gag manner.\\nlike this:\\n [P           A           H            N]\\n[   A    P      L    S     I      I        G]\\n[      Y            I           R]\\n\\nThat is Basically same as putting every character of string in given number of rows going from 1st row to last row then going to 1st row again.\\n\\nFor example: S=PAYPALISHIRING, NUMROWS= 3;\\n\\nIterating the string:\\n`0:row[0].append(s[0])`\\n`1:row[1].append(s[1])`\\n`2:row[2].append(s[2]) change to going up`\\n`3:row[1].append(s[3])`\\n`4:row[0].append(s[4]) change to going down`\\n`5:row[1].append(s[5])`\\nThis will continue till end of string. \\nHere till 6th character of string you have\\nrow[0] = [P ,A]\\nrow[1] = [A, P, L]\\nrow[2] = [Y]\\n\\nthis can be easily done by tracking the current row and if we are going up or down."
                    },
                    {
                        "username": "Jayanthsomuri",
                        "content": "The question description and the sample that they have shown don\\'t justify\\uD83D\\uDE2A\\uD83D\\uDE44"
                    },
                    {
                        "username": "agrawalharsh0522",
                        "content": "I got some stackoverflow problem , Don't know why\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        // we know numrows \n        // for column we will try some math \n        int size=s.length();\n\n        if(size<=numRows){\n            return s;\n        }\n\n        else{\n            int col=0;\n            int l=size;\n\n            while(l!=0){\n                if(l>=(numRows)+(numRows-2)){\n                    col=col+(numRows-1);\n                    l=l-(numRows)+(numRows-2);\n                }\n\n                else if(l>numRows && l<(numRows)+(numRows-2) ){\n                    col=col+(1+l-numRows);\n                    l=0;\n                }\n\n                else if(l<=numRows){\n                    col=col+1;\n                    l=0;\n                }\n            }\n\n            char mat[numRows][col];\n            int index=0;\n            int i;\n            for(int j=0;j<col;j++){\n                for( i=0;i<numRows;i++){\n                    mat[i][j]=s[index];\n                    index++;\n                }\n                while(i>0){\n                    j++;\n                    i--;\n                    mat[i][j]=s[index];\n                    index++;\n                }\n            }\n\n            string res;\n            for(int i=0;i<numRows;i++){\n                for(int j=0;j<col;j++){\n                    if(mat[i][j]!=NULL){\n                        res=res+mat[i][j];\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        return 0;\n    }\n};\n\n==31==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe1ae40010 at pc 0x00000034488d bp 0x7ffe1ae3fdb0 sp 0x7ffe1ae3fda8\nREAD of size 1 at 0x7ffe1ae40010 thread T0\n    #3 0x7f0a95ac00b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddress 0x7ffe1ae40010 is located in stack of thread T0 at offset 80 in frame\n  This frame has 2 object(s):"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Solution - https://leetcode.com/problems/zigzag-conversion/solutions/3134632/easy-and-neat-c-solution-using-array-of-pairs-full-explanation-o-n-m/\\n--> I have posted an easy C++ solution using array explaining the pattern and the approach in detail. The problem is easy if you get the pattern. Hope this helps you out.\\n"
                    }
                ]
            },
            {
                "id": 1785710,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "This was a question which I did when I was just starting out, that time it took me an hour to do, but today I was able to do it in a few minutes !!\\nI am pretty happy rn : ) "
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky, tried a general solution but ended up having to handle 3 special cases (numRows == 0, 1, and 2)"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Will just give a tip take out pen and paper and write down jig jag pattern and try to find the logic , DO NOT I REPEAT DO NOT COPY OTHERS CODE IT WONT MAKE SENSE TILL YOU WRITE BY YOUR OWN. Just give some time while working on it. ALL THE BEST"
                    },
                    {
                        "username": "no-username",
                        "content": "I am looking for a job but I am ok to fail the interview if this type of question I get. "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use StringBuilder array and create the pattern."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Nope, PayPal is firing instead of hiring right now"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Essentially what is required from you Following : \\nthe given string is to be filled in number of rows given in a zig-gag manner.\\nlike this:\\n [P           A           H            N]\\n[   A    P      L    S     I      I        G]\\n[      Y            I           R]\\n\\nThat is Basically same as putting every character of string in given number of rows going from 1st row to last row then going to 1st row again.\\n\\nFor example: S=PAYPALISHIRING, NUMROWS= 3;\\n\\nIterating the string:\\n`0:row[0].append(s[0])`\\n`1:row[1].append(s[1])`\\n`2:row[2].append(s[2]) change to going up`\\n`3:row[1].append(s[3])`\\n`4:row[0].append(s[4]) change to going down`\\n`5:row[1].append(s[5])`\\nThis will continue till end of string. \\nHere till 6th character of string you have\\nrow[0] = [P ,A]\\nrow[1] = [A, P, L]\\nrow[2] = [Y]\\n\\nthis can be easily done by tracking the current row and if we are going up or down."
                    },
                    {
                        "username": "Jayanthsomuri",
                        "content": "The question description and the sample that they have shown don\\'t justify\\uD83D\\uDE2A\\uD83D\\uDE44"
                    },
                    {
                        "username": "agrawalharsh0522",
                        "content": "I got some stackoverflow problem , Don't know why\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        // we know numrows \n        // for column we will try some math \n        int size=s.length();\n\n        if(size<=numRows){\n            return s;\n        }\n\n        else{\n            int col=0;\n            int l=size;\n\n            while(l!=0){\n                if(l>=(numRows)+(numRows-2)){\n                    col=col+(numRows-1);\n                    l=l-(numRows)+(numRows-2);\n                }\n\n                else if(l>numRows && l<(numRows)+(numRows-2) ){\n                    col=col+(1+l-numRows);\n                    l=0;\n                }\n\n                else if(l<=numRows){\n                    col=col+1;\n                    l=0;\n                }\n            }\n\n            char mat[numRows][col];\n            int index=0;\n            int i;\n            for(int j=0;j<col;j++){\n                for( i=0;i<numRows;i++){\n                    mat[i][j]=s[index];\n                    index++;\n                }\n                while(i>0){\n                    j++;\n                    i--;\n                    mat[i][j]=s[index];\n                    index++;\n                }\n            }\n\n            string res;\n            for(int i=0;i<numRows;i++){\n                for(int j=0;j<col;j++){\n                    if(mat[i][j]!=NULL){\n                        res=res+mat[i][j];\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        return 0;\n    }\n};\n\n==31==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe1ae40010 at pc 0x00000034488d bp 0x7ffe1ae3fdb0 sp 0x7ffe1ae3fda8\nREAD of size 1 at 0x7ffe1ae40010 thread T0\n    #3 0x7f0a95ac00b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddress 0x7ffe1ae40010 is located in stack of thread T0 at offset 80 in frame\n  This frame has 2 object(s):"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Solution - https://leetcode.com/problems/zigzag-conversion/solutions/3134632/easy-and-neat-c-solution-using-array-of-pairs-full-explanation-o-n-m/\\n--> I have posted an easy C++ solution using array explaining the pattern and the approach in detail. The problem is easy if you get the pattern. Hope this helps you out.\\n"
                    }
                ]
            },
            {
                "id": 1785660,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "This was a question which I did when I was just starting out, that time it took me an hour to do, but today I was able to do it in a few minutes !!\\nI am pretty happy rn : ) "
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky, tried a general solution but ended up having to handle 3 special cases (numRows == 0, 1, and 2)"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Will just give a tip take out pen and paper and write down jig jag pattern and try to find the logic , DO NOT I REPEAT DO NOT COPY OTHERS CODE IT WONT MAKE SENSE TILL YOU WRITE BY YOUR OWN. Just give some time while working on it. ALL THE BEST"
                    },
                    {
                        "username": "no-username",
                        "content": "I am looking for a job but I am ok to fail the interview if this type of question I get. "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use StringBuilder array and create the pattern."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Nope, PayPal is firing instead of hiring right now"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Essentially what is required from you Following : \\nthe given string is to be filled in number of rows given in a zig-gag manner.\\nlike this:\\n [P           A           H            N]\\n[   A    P      L    S     I      I        G]\\n[      Y            I           R]\\n\\nThat is Basically same as putting every character of string in given number of rows going from 1st row to last row then going to 1st row again.\\n\\nFor example: S=PAYPALISHIRING, NUMROWS= 3;\\n\\nIterating the string:\\n`0:row[0].append(s[0])`\\n`1:row[1].append(s[1])`\\n`2:row[2].append(s[2]) change to going up`\\n`3:row[1].append(s[3])`\\n`4:row[0].append(s[4]) change to going down`\\n`5:row[1].append(s[5])`\\nThis will continue till end of string. \\nHere till 6th character of string you have\\nrow[0] = [P ,A]\\nrow[1] = [A, P, L]\\nrow[2] = [Y]\\n\\nthis can be easily done by tracking the current row and if we are going up or down."
                    },
                    {
                        "username": "Jayanthsomuri",
                        "content": "The question description and the sample that they have shown don\\'t justify\\uD83D\\uDE2A\\uD83D\\uDE44"
                    },
                    {
                        "username": "agrawalharsh0522",
                        "content": "I got some stackoverflow problem , Don't know why\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        // we know numrows \n        // for column we will try some math \n        int size=s.length();\n\n        if(size<=numRows){\n            return s;\n        }\n\n        else{\n            int col=0;\n            int l=size;\n\n            while(l!=0){\n                if(l>=(numRows)+(numRows-2)){\n                    col=col+(numRows-1);\n                    l=l-(numRows)+(numRows-2);\n                }\n\n                else if(l>numRows && l<(numRows)+(numRows-2) ){\n                    col=col+(1+l-numRows);\n                    l=0;\n                }\n\n                else if(l<=numRows){\n                    col=col+1;\n                    l=0;\n                }\n            }\n\n            char mat[numRows][col];\n            int index=0;\n            int i;\n            for(int j=0;j<col;j++){\n                for( i=0;i<numRows;i++){\n                    mat[i][j]=s[index];\n                    index++;\n                }\n                while(i>0){\n                    j++;\n                    i--;\n                    mat[i][j]=s[index];\n                    index++;\n                }\n            }\n\n            string res;\n            for(int i=0;i<numRows;i++){\n                for(int j=0;j<col;j++){\n                    if(mat[i][j]!=NULL){\n                        res=res+mat[i][j];\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        return 0;\n    }\n};\n\n==31==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe1ae40010 at pc 0x00000034488d bp 0x7ffe1ae3fdb0 sp 0x7ffe1ae3fda8\nREAD of size 1 at 0x7ffe1ae40010 thread T0\n    #3 0x7f0a95ac00b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddress 0x7ffe1ae40010 is located in stack of thread T0 at offset 80 in frame\n  This frame has 2 object(s):"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Solution - https://leetcode.com/problems/zigzag-conversion/solutions/3134632/easy-and-neat-c-solution-using-array-of-pairs-full-explanation-o-n-m/\\n--> I have posted an easy C++ solution using array explaining the pattern and the approach in detail. The problem is easy if you get the pattern. Hope this helps you out.\\n"
                    }
                ]
            },
            {
                "id": 1785652,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "This was a question which I did when I was just starting out, that time it took me an hour to do, but today I was able to do it in a few minutes !!\\nI am pretty happy rn : ) "
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky, tried a general solution but ended up having to handle 3 special cases (numRows == 0, 1, and 2)"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Will just give a tip take out pen and paper and write down jig jag pattern and try to find the logic , DO NOT I REPEAT DO NOT COPY OTHERS CODE IT WONT MAKE SENSE TILL YOU WRITE BY YOUR OWN. Just give some time while working on it. ALL THE BEST"
                    },
                    {
                        "username": "no-username",
                        "content": "I am looking for a job but I am ok to fail the interview if this type of question I get. "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use StringBuilder array and create the pattern."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Nope, PayPal is firing instead of hiring right now"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Essentially what is required from you Following : \\nthe given string is to be filled in number of rows given in a zig-gag manner.\\nlike this:\\n [P           A           H            N]\\n[   A    P      L    S     I      I        G]\\n[      Y            I           R]\\n\\nThat is Basically same as putting every character of string in given number of rows going from 1st row to last row then going to 1st row again.\\n\\nFor example: S=PAYPALISHIRING, NUMROWS= 3;\\n\\nIterating the string:\\n`0:row[0].append(s[0])`\\n`1:row[1].append(s[1])`\\n`2:row[2].append(s[2]) change to going up`\\n`3:row[1].append(s[3])`\\n`4:row[0].append(s[4]) change to going down`\\n`5:row[1].append(s[5])`\\nThis will continue till end of string. \\nHere till 6th character of string you have\\nrow[0] = [P ,A]\\nrow[1] = [A, P, L]\\nrow[2] = [Y]\\n\\nthis can be easily done by tracking the current row and if we are going up or down."
                    },
                    {
                        "username": "Jayanthsomuri",
                        "content": "The question description and the sample that they have shown don\\'t justify\\uD83D\\uDE2A\\uD83D\\uDE44"
                    },
                    {
                        "username": "agrawalharsh0522",
                        "content": "I got some stackoverflow problem , Don't know why\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        // we know numrows \n        // for column we will try some math \n        int size=s.length();\n\n        if(size<=numRows){\n            return s;\n        }\n\n        else{\n            int col=0;\n            int l=size;\n\n            while(l!=0){\n                if(l>=(numRows)+(numRows-2)){\n                    col=col+(numRows-1);\n                    l=l-(numRows)+(numRows-2);\n                }\n\n                else if(l>numRows && l<(numRows)+(numRows-2) ){\n                    col=col+(1+l-numRows);\n                    l=0;\n                }\n\n                else if(l<=numRows){\n                    col=col+1;\n                    l=0;\n                }\n            }\n\n            char mat[numRows][col];\n            int index=0;\n            int i;\n            for(int j=0;j<col;j++){\n                for( i=0;i<numRows;i++){\n                    mat[i][j]=s[index];\n                    index++;\n                }\n                while(i>0){\n                    j++;\n                    i--;\n                    mat[i][j]=s[index];\n                    index++;\n                }\n            }\n\n            string res;\n            for(int i=0;i<numRows;i++){\n                for(int j=0;j<col;j++){\n                    if(mat[i][j]!=NULL){\n                        res=res+mat[i][j];\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        return 0;\n    }\n};\n\n==31==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe1ae40010 at pc 0x00000034488d bp 0x7ffe1ae3fdb0 sp 0x7ffe1ae3fda8\nREAD of size 1 at 0x7ffe1ae40010 thread T0\n    #3 0x7f0a95ac00b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddress 0x7ffe1ae40010 is located in stack of thread T0 at offset 80 in frame\n  This frame has 2 object(s):"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Solution - https://leetcode.com/problems/zigzag-conversion/solutions/3134632/easy-and-neat-c-solution-using-array-of-pairs-full-explanation-o-n-m/\\n--> I have posted an easy C++ solution using array explaining the pattern and the approach in detail. The problem is easy if you get the pattern. Hope this helps you out.\\n"
                    }
                ]
            },
            {
                "id": 1785644,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "This was a question which I did when I was just starting out, that time it took me an hour to do, but today I was able to do it in a few minutes !!\\nI am pretty happy rn : ) "
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky, tried a general solution but ended up having to handle 3 special cases (numRows == 0, 1, and 2)"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Will just give a tip take out pen and paper and write down jig jag pattern and try to find the logic , DO NOT I REPEAT DO NOT COPY OTHERS CODE IT WONT MAKE SENSE TILL YOU WRITE BY YOUR OWN. Just give some time while working on it. ALL THE BEST"
                    },
                    {
                        "username": "no-username",
                        "content": "I am looking for a job but I am ok to fail the interview if this type of question I get. "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use StringBuilder array and create the pattern."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Nope, PayPal is firing instead of hiring right now"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Essentially what is required from you Following : \\nthe given string is to be filled in number of rows given in a zig-gag manner.\\nlike this:\\n [P           A           H            N]\\n[   A    P      L    S     I      I        G]\\n[      Y            I           R]\\n\\nThat is Basically same as putting every character of string in given number of rows going from 1st row to last row then going to 1st row again.\\n\\nFor example: S=PAYPALISHIRING, NUMROWS= 3;\\n\\nIterating the string:\\n`0:row[0].append(s[0])`\\n`1:row[1].append(s[1])`\\n`2:row[2].append(s[2]) change to going up`\\n`3:row[1].append(s[3])`\\n`4:row[0].append(s[4]) change to going down`\\n`5:row[1].append(s[5])`\\nThis will continue till end of string. \\nHere till 6th character of string you have\\nrow[0] = [P ,A]\\nrow[1] = [A, P, L]\\nrow[2] = [Y]\\n\\nthis can be easily done by tracking the current row and if we are going up or down."
                    },
                    {
                        "username": "Jayanthsomuri",
                        "content": "The question description and the sample that they have shown don\\'t justify\\uD83D\\uDE2A\\uD83D\\uDE44"
                    },
                    {
                        "username": "agrawalharsh0522",
                        "content": "I got some stackoverflow problem , Don't know why\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        // we know numrows \n        // for column we will try some math \n        int size=s.length();\n\n        if(size<=numRows){\n            return s;\n        }\n\n        else{\n            int col=0;\n            int l=size;\n\n            while(l!=0){\n                if(l>=(numRows)+(numRows-2)){\n                    col=col+(numRows-1);\n                    l=l-(numRows)+(numRows-2);\n                }\n\n                else if(l>numRows && l<(numRows)+(numRows-2) ){\n                    col=col+(1+l-numRows);\n                    l=0;\n                }\n\n                else if(l<=numRows){\n                    col=col+1;\n                    l=0;\n                }\n            }\n\n            char mat[numRows][col];\n            int index=0;\n            int i;\n            for(int j=0;j<col;j++){\n                for( i=0;i<numRows;i++){\n                    mat[i][j]=s[index];\n                    index++;\n                }\n                while(i>0){\n                    j++;\n                    i--;\n                    mat[i][j]=s[index];\n                    index++;\n                }\n            }\n\n            string res;\n            for(int i=0;i<numRows;i++){\n                for(int j=0;j<col;j++){\n                    if(mat[i][j]!=NULL){\n                        res=res+mat[i][j];\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        return 0;\n    }\n};\n\n==31==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe1ae40010 at pc 0x00000034488d bp 0x7ffe1ae3fdb0 sp 0x7ffe1ae3fda8\nREAD of size 1 at 0x7ffe1ae40010 thread T0\n    #3 0x7f0a95ac00b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddress 0x7ffe1ae40010 is located in stack of thread T0 at offset 80 in frame\n  This frame has 2 object(s):"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Solution - https://leetcode.com/problems/zigzag-conversion/solutions/3134632/easy-and-neat-c-solution-using-array-of-pairs-full-explanation-o-n-m/\\n--> I have posted an easy C++ solution using array explaining the pattern and the approach in detail. The problem is easy if you get the pattern. Hope this helps you out.\\n"
                    }
                ]
            },
            {
                "id": 1785631,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "This was a question which I did when I was just starting out, that time it took me an hour to do, but today I was able to do it in a few minutes !!\\nI am pretty happy rn : ) "
                    },
                    {
                        "username": "user5400vw",
                        "content": "tricky, tried a general solution but ended up having to handle 3 special cases (numRows == 0, 1, and 2)"
                    },
                    {
                        "username": "sneha_bk",
                        "content": "Will just give a tip take out pen and paper and write down jig jag pattern and try to find the logic , DO NOT I REPEAT DO NOT COPY OTHERS CODE IT WONT MAKE SENSE TILL YOU WRITE BY YOUR OWN. Just give some time while working on it. ALL THE BEST"
                    },
                    {
                        "username": "no-username",
                        "content": "I am looking for a job but I am ok to fail the interview if this type of question I get. "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use StringBuilder array and create the pattern."
                    },
                    {
                        "username": "hemantdhamija",
                        "content": "Nope, PayPal is firing instead of hiring right now"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Essentially what is required from you Following : \\nthe given string is to be filled in number of rows given in a zig-gag manner.\\nlike this:\\n [P           A           H            N]\\n[   A    P      L    S     I      I        G]\\n[      Y            I           R]\\n\\nThat is Basically same as putting every character of string in given number of rows going from 1st row to last row then going to 1st row again.\\n\\nFor example: S=PAYPALISHIRING, NUMROWS= 3;\\n\\nIterating the string:\\n`0:row[0].append(s[0])`\\n`1:row[1].append(s[1])`\\n`2:row[2].append(s[2]) change to going up`\\n`3:row[1].append(s[3])`\\n`4:row[0].append(s[4]) change to going down`\\n`5:row[1].append(s[5])`\\nThis will continue till end of string. \\nHere till 6th character of string you have\\nrow[0] = [P ,A]\\nrow[1] = [A, P, L]\\nrow[2] = [Y]\\n\\nthis can be easily done by tracking the current row and if we are going up or down."
                    },
                    {
                        "username": "Jayanthsomuri",
                        "content": "The question description and the sample that they have shown don\\'t justify\\uD83D\\uDE2A\\uD83D\\uDE44"
                    },
                    {
                        "username": "agrawalharsh0522",
                        "content": "I got some stackoverflow problem , Don't know why\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        // we know numrows \n        // for column we will try some math \n        int size=s.length();\n\n        if(size<=numRows){\n            return s;\n        }\n\n        else{\n            int col=0;\n            int l=size;\n\n            while(l!=0){\n                if(l>=(numRows)+(numRows-2)){\n                    col=col+(numRows-1);\n                    l=l-(numRows)+(numRows-2);\n                }\n\n                else if(l>numRows && l<(numRows)+(numRows-2) ){\n                    col=col+(1+l-numRows);\n                    l=0;\n                }\n\n                else if(l<=numRows){\n                    col=col+1;\n                    l=0;\n                }\n            }\n\n            char mat[numRows][col];\n            int index=0;\n            int i;\n            for(int j=0;j<col;j++){\n                for( i=0;i<numRows;i++){\n                    mat[i][j]=s[index];\n                    index++;\n                }\n                while(i>0){\n                    j++;\n                    i--;\n                    mat[i][j]=s[index];\n                    index++;\n                }\n            }\n\n            string res;\n            for(int i=0;i<numRows;i++){\n                for(int j=0;j<col;j++){\n                    if(mat[i][j]!=NULL){\n                        res=res+mat[i][j];\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        return 0;\n    }\n};\n\n==31==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe1ae40010 at pc 0x00000034488d bp 0x7ffe1ae3fdb0 sp 0x7ffe1ae3fda8\nREAD of size 1 at 0x7ffe1ae40010 thread T0\n    #3 0x7f0a95ac00b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddress 0x7ffe1ae40010 is located in stack of thread T0 at offset 80 in frame\n  This frame has 2 object(s):"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Solution - https://leetcode.com/problems/zigzag-conversion/solutions/3134632/easy-and-neat-c-solution-using-array-of-pairs-full-explanation-o-n-m/\\n--> I have posted an easy C++ solution using array explaining the pattern and the approach in detail. The problem is easy if you get the pattern. Hope this helps you out.\\n"
                    }
                ]
            },
            {
                "id": 1785620,
                "content": [
                    {
                        "username": "Phoenix_21",
                        "content": "Ready to break my streak for this question."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Personally, I didn\\'t have any trouble understanding the question, but from the dislikes I can see that a huge amount of people was not able the follow the description.\\nThis is a GIF from the LeetCode\\'s official solution for the problem, watch it and you\\'ll be good to go.\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/2868537/Figures/6/filling.gif"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me extra word\\nex- \\n1     5 \\n2 4  6\\n3     7    why 4 here "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "finding 2023 comment leetcode improve details or not \\n"
                    },
                    {
                        "username": "ironskillet2",
                        "content": "im getting the correct answer on my machine but not with leetCode so idk what to do here.\n\nmy code is rather large for this kind of problem i imagine. but my code still passes all the testcase's on my other environment just not here on leetCode\n\nnevermind i fixed it, but i ran beyond the time-limit HAHA man my code is bad"
                    },
                    {
                        "username": "jasimuddin164",
                        "content": "Why is the problem defined inaccurately?"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird question lol"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "aint this the question a youtuber was ranting about \\uD83D\\uDE05 .... like how it was asked in his interview and he still doesnt know the solution til date even after his numerous co-workers explain it to him : summary it doesnt matter if you cant solve a leet problem in interview(yt video summary , not mine\\uD83D\\uDE01)"
                    },
                    {
                        "username": "lanthony42",
                        "content": "Why is this a medium? Is it just cause its poorly written?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good task and so many dislikes :("
                    }
                ]
            },
            {
                "id": 1785578,
                "content": [
                    {
                        "username": "Phoenix_21",
                        "content": "Ready to break my streak for this question."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Personally, I didn\\'t have any trouble understanding the question, but from the dislikes I can see that a huge amount of people was not able the follow the description.\\nThis is a GIF from the LeetCode\\'s official solution for the problem, watch it and you\\'ll be good to go.\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/2868537/Figures/6/filling.gif"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me extra word\\nex- \\n1     5 \\n2 4  6\\n3     7    why 4 here "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "finding 2023 comment leetcode improve details or not \\n"
                    },
                    {
                        "username": "ironskillet2",
                        "content": "im getting the correct answer on my machine but not with leetCode so idk what to do here.\n\nmy code is rather large for this kind of problem i imagine. but my code still passes all the testcase's on my other environment just not here on leetCode\n\nnevermind i fixed it, but i ran beyond the time-limit HAHA man my code is bad"
                    },
                    {
                        "username": "jasimuddin164",
                        "content": "Why is the problem defined inaccurately?"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird question lol"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "aint this the question a youtuber was ranting about \\uD83D\\uDE05 .... like how it was asked in his interview and he still doesnt know the solution til date even after his numerous co-workers explain it to him : summary it doesnt matter if you cant solve a leet problem in interview(yt video summary , not mine\\uD83D\\uDE01)"
                    },
                    {
                        "username": "lanthony42",
                        "content": "Why is this a medium? Is it just cause its poorly written?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good task and so many dislikes :("
                    }
                ]
            },
            {
                "id": 1785551,
                "content": [
                    {
                        "username": "Phoenix_21",
                        "content": "Ready to break my streak for this question."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Personally, I didn\\'t have any trouble understanding the question, but from the dislikes I can see that a huge amount of people was not able the follow the description.\\nThis is a GIF from the LeetCode\\'s official solution for the problem, watch it and you\\'ll be good to go.\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/2868537/Figures/6/filling.gif"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me extra word\\nex- \\n1     5 \\n2 4  6\\n3     7    why 4 here "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "finding 2023 comment leetcode improve details or not \\n"
                    },
                    {
                        "username": "ironskillet2",
                        "content": "im getting the correct answer on my machine but not with leetCode so idk what to do here.\n\nmy code is rather large for this kind of problem i imagine. but my code still passes all the testcase's on my other environment just not here on leetCode\n\nnevermind i fixed it, but i ran beyond the time-limit HAHA man my code is bad"
                    },
                    {
                        "username": "jasimuddin164",
                        "content": "Why is the problem defined inaccurately?"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird question lol"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "aint this the question a youtuber was ranting about \\uD83D\\uDE05 .... like how it was asked in his interview and he still doesnt know the solution til date even after his numerous co-workers explain it to him : summary it doesnt matter if you cant solve a leet problem in interview(yt video summary , not mine\\uD83D\\uDE01)"
                    },
                    {
                        "username": "lanthony42",
                        "content": "Why is this a medium? Is it just cause its poorly written?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good task and so many dislikes :("
                    }
                ]
            },
            {
                "id": 1785550,
                "content": [
                    {
                        "username": "Phoenix_21",
                        "content": "Ready to break my streak for this question."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Personally, I didn\\'t have any trouble understanding the question, but from the dislikes I can see that a huge amount of people was not able the follow the description.\\nThis is a GIF from the LeetCode\\'s official solution for the problem, watch it and you\\'ll be good to go.\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/2868537/Figures/6/filling.gif"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me extra word\\nex- \\n1     5 \\n2 4  6\\n3     7    why 4 here "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "finding 2023 comment leetcode improve details or not \\n"
                    },
                    {
                        "username": "ironskillet2",
                        "content": "im getting the correct answer on my machine but not with leetCode so idk what to do here.\n\nmy code is rather large for this kind of problem i imagine. but my code still passes all the testcase's on my other environment just not here on leetCode\n\nnevermind i fixed it, but i ran beyond the time-limit HAHA man my code is bad"
                    },
                    {
                        "username": "jasimuddin164",
                        "content": "Why is the problem defined inaccurately?"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird question lol"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "aint this the question a youtuber was ranting about \\uD83D\\uDE05 .... like how it was asked in his interview and he still doesnt know the solution til date even after his numerous co-workers explain it to him : summary it doesnt matter if you cant solve a leet problem in interview(yt video summary , not mine\\uD83D\\uDE01)"
                    },
                    {
                        "username": "lanthony42",
                        "content": "Why is this a medium? Is it just cause its poorly written?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good task and so many dislikes :("
                    }
                ]
            },
            {
                "id": 1785494,
                "content": [
                    {
                        "username": "Phoenix_21",
                        "content": "Ready to break my streak for this question."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Personally, I didn\\'t have any trouble understanding the question, but from the dislikes I can see that a huge amount of people was not able the follow the description.\\nThis is a GIF from the LeetCode\\'s official solution for the problem, watch it and you\\'ll be good to go.\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/2868537/Figures/6/filling.gif"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me extra word\\nex- \\n1     5 \\n2 4  6\\n3     7    why 4 here "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "finding 2023 comment leetcode improve details or not \\n"
                    },
                    {
                        "username": "ironskillet2",
                        "content": "im getting the correct answer on my machine but not with leetCode so idk what to do here.\n\nmy code is rather large for this kind of problem i imagine. but my code still passes all the testcase's on my other environment just not here on leetCode\n\nnevermind i fixed it, but i ran beyond the time-limit HAHA man my code is bad"
                    },
                    {
                        "username": "jasimuddin164",
                        "content": "Why is the problem defined inaccurately?"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird question lol"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "aint this the question a youtuber was ranting about \\uD83D\\uDE05 .... like how it was asked in his interview and he still doesnt know the solution til date even after his numerous co-workers explain it to him : summary it doesnt matter if you cant solve a leet problem in interview(yt video summary , not mine\\uD83D\\uDE01)"
                    },
                    {
                        "username": "lanthony42",
                        "content": "Why is this a medium? Is it just cause its poorly written?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good task and so many dislikes :("
                    }
                ]
            },
            {
                "id": 1785446,
                "content": [
                    {
                        "username": "Phoenix_21",
                        "content": "Ready to break my streak for this question."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Personally, I didn\\'t have any trouble understanding the question, but from the dislikes I can see that a huge amount of people was not able the follow the description.\\nThis is a GIF from the LeetCode\\'s official solution for the problem, watch it and you\\'ll be good to go.\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/2868537/Figures/6/filling.gif"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me extra word\\nex- \\n1     5 \\n2 4  6\\n3     7    why 4 here "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "finding 2023 comment leetcode improve details or not \\n"
                    },
                    {
                        "username": "ironskillet2",
                        "content": "im getting the correct answer on my machine but not with leetCode so idk what to do here.\n\nmy code is rather large for this kind of problem i imagine. but my code still passes all the testcase's on my other environment just not here on leetCode\n\nnevermind i fixed it, but i ran beyond the time-limit HAHA man my code is bad"
                    },
                    {
                        "username": "jasimuddin164",
                        "content": "Why is the problem defined inaccurately?"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird question lol"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "aint this the question a youtuber was ranting about \\uD83D\\uDE05 .... like how it was asked in his interview and he still doesnt know the solution til date even after his numerous co-workers explain it to him : summary it doesnt matter if you cant solve a leet problem in interview(yt video summary , not mine\\uD83D\\uDE01)"
                    },
                    {
                        "username": "lanthony42",
                        "content": "Why is this a medium? Is it just cause its poorly written?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good task and so many dislikes :("
                    }
                ]
            },
            {
                "id": 1785426,
                "content": [
                    {
                        "username": "Phoenix_21",
                        "content": "Ready to break my streak for this question."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Personally, I didn\\'t have any trouble understanding the question, but from the dislikes I can see that a huge amount of people was not able the follow the description.\\nThis is a GIF from the LeetCode\\'s official solution for the problem, watch it and you\\'ll be good to go.\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/2868537/Figures/6/filling.gif"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me extra word\\nex- \\n1     5 \\n2 4  6\\n3     7    why 4 here "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "finding 2023 comment leetcode improve details or not \\n"
                    },
                    {
                        "username": "ironskillet2",
                        "content": "im getting the correct answer on my machine but not with leetCode so idk what to do here.\n\nmy code is rather large for this kind of problem i imagine. but my code still passes all the testcase's on my other environment just not here on leetCode\n\nnevermind i fixed it, but i ran beyond the time-limit HAHA man my code is bad"
                    },
                    {
                        "username": "jasimuddin164",
                        "content": "Why is the problem defined inaccurately?"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird question lol"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "aint this the question a youtuber was ranting about \\uD83D\\uDE05 .... like how it was asked in his interview and he still doesnt know the solution til date even after his numerous co-workers explain it to him : summary it doesnt matter if you cant solve a leet problem in interview(yt video summary , not mine\\uD83D\\uDE01)"
                    },
                    {
                        "username": "lanthony42",
                        "content": "Why is this a medium? Is it just cause its poorly written?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good task and so many dislikes :("
                    }
                ]
            },
            {
                "id": 1785419,
                "content": [
                    {
                        "username": "Phoenix_21",
                        "content": "Ready to break my streak for this question."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Personally, I didn\\'t have any trouble understanding the question, but from the dislikes I can see that a huge amount of people was not able the follow the description.\\nThis is a GIF from the LeetCode\\'s official solution for the problem, watch it and you\\'ll be good to go.\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/2868537/Figures/6/filling.gif"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me extra word\\nex- \\n1     5 \\n2 4  6\\n3     7    why 4 here "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "finding 2023 comment leetcode improve details or not \\n"
                    },
                    {
                        "username": "ironskillet2",
                        "content": "im getting the correct answer on my machine but not with leetCode so idk what to do here.\n\nmy code is rather large for this kind of problem i imagine. but my code still passes all the testcase's on my other environment just not here on leetCode\n\nnevermind i fixed it, but i ran beyond the time-limit HAHA man my code is bad"
                    },
                    {
                        "username": "jasimuddin164",
                        "content": "Why is the problem defined inaccurately?"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird question lol"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "aint this the question a youtuber was ranting about \\uD83D\\uDE05 .... like how it was asked in his interview and he still doesnt know the solution til date even after his numerous co-workers explain it to him : summary it doesnt matter if you cant solve a leet problem in interview(yt video summary , not mine\\uD83D\\uDE01)"
                    },
                    {
                        "username": "lanthony42",
                        "content": "Why is this a medium? Is it just cause its poorly written?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good task and so many dislikes :("
                    }
                ]
            },
            {
                "id": 1785418,
                "content": [
                    {
                        "username": "Phoenix_21",
                        "content": "Ready to break my streak for this question."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Personally, I didn\\'t have any trouble understanding the question, but from the dislikes I can see that a huge amount of people was not able the follow the description.\\nThis is a GIF from the LeetCode\\'s official solution for the problem, watch it and you\\'ll be good to go.\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/2868537/Figures/6/filling.gif"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me extra word\\nex- \\n1     5 \\n2 4  6\\n3     7    why 4 here "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "finding 2023 comment leetcode improve details or not \\n"
                    },
                    {
                        "username": "ironskillet2",
                        "content": "im getting the correct answer on my machine but not with leetCode so idk what to do here.\n\nmy code is rather large for this kind of problem i imagine. but my code still passes all the testcase's on my other environment just not here on leetCode\n\nnevermind i fixed it, but i ran beyond the time-limit HAHA man my code is bad"
                    },
                    {
                        "username": "jasimuddin164",
                        "content": "Why is the problem defined inaccurately?"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird question lol"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "aint this the question a youtuber was ranting about \\uD83D\\uDE05 .... like how it was asked in his interview and he still doesnt know the solution til date even after his numerous co-workers explain it to him : summary it doesnt matter if you cant solve a leet problem in interview(yt video summary , not mine\\uD83D\\uDE01)"
                    },
                    {
                        "username": "lanthony42",
                        "content": "Why is this a medium? Is it just cause its poorly written?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good task and so many dislikes :("
                    }
                ]
            },
            {
                "id": 1785399,
                "content": [
                    {
                        "username": "Phoenix_21",
                        "content": "Ready to break my streak for this question."
                    },
                    {
                        "username": "jithu7432",
                        "content": "Personally, I didn\\'t have any trouble understanding the question, but from the dislikes I can see that a huge amount of people was not able the follow the description.\\nThis is a GIF from the LeetCode\\'s official solution for the problem, watch it and you\\'ll be good to go.\\nhttps://leetcode.com/problems/zigzag-conversion/solutions/2868537/Figures/6/filling.gif"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "anyone explain me extra word\\nex- \\n1     5 \\n2 4  6\\n3     7    why 4 here "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "finding 2023 comment leetcode improve details or not \\n"
                    },
                    {
                        "username": "ironskillet2",
                        "content": "im getting the correct answer on my machine but not with leetCode so idk what to do here.\n\nmy code is rather large for this kind of problem i imagine. but my code still passes all the testcase's on my other environment just not here on leetCode\n\nnevermind i fixed it, but i ran beyond the time-limit HAHA man my code is bad"
                    },
                    {
                        "username": "jasimuddin164",
                        "content": "Why is the problem defined inaccurately?"
                    },
                    {
                        "username": "hosua",
                        "content": "Weird question lol"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "aint this the question a youtuber was ranting about \\uD83D\\uDE05 .... like how it was asked in his interview and he still doesnt know the solution til date even after his numerous co-workers explain it to him : summary it doesnt matter if you cant solve a leet problem in interview(yt video summary , not mine\\uD83D\\uDE01)"
                    },
                    {
                        "username": "lanthony42",
                        "content": "Why is this a medium? Is it just cause its poorly written?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good task and so many dislikes :("
                    }
                ]
            },
            {
                "id": 1785356,
                "content": [
                    {
                        "username": "user0740h",
                        "content": "I had trouble with this one in the past and just saw the pattern, so here are some hints:\n\n- Based on the description, the expected result is the rows without the empty spaces. Are the spaces required?\n\n- In example 2:\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N                  row 1\nA   L S  I G               row 2\nY A   H R                  row 3\nP     I                         row 4\n```\nThe first 4 characters (PAYP) go in rows 1 to 4, but the 5th (A) goes in row 3. The 6th (L) goes in row 2 and 7th (I) in row 1. We went back to row 1 and for the 8th (S) is row 2 again. Each character seems to go in the row adjacent to the previous character. Is there a pattern there?"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want a few hints without the full solution continue reading!\nUse as many hints as you need, go one at a time if you want to test yourself!\n\n1) You should loop through the rows and apply a  formula on the input string for each one.\n\n2) That formula will include a secondary loop that transforms part of the input string in a partial output. (concatenate the partial outputs that you get in each iteration).\n\n3) Notice that for the first and last rows the formula is very straightforward.\n\n4) For the rows in the middle (when numRows > 2) you need to think a little bit more but it's not too hard."
                    },
                    {
                        "username": "rotkay",
                        "content": "literally worst described problem I\\'ve seen on the leetcode"
                    },
                    {
                        "username": "qle_13",
                        "content": "This one should be easy :>"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I am seeing a pattern here. It is that first every character after numrows distance and then print every character after every  numrows-1 distance and so on. But this is failing in some cases someone help me out!\\n\\nHere is my code:\\n```class Solution {\\npublic:\\n\\n    string convert(string s, int numRows) {\\n        vector<bool> vis(size(s),false);\\n        int max,n=size(s);\\n         \\n        int k=numRows;\\n        if(numRows%2==0)\\n        max=numRows+2;\\n        else max=numRows+1;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<=0)\\n            break;\\n            for(int j=i;j<n;j+=max)\\n            { if(vis[j]!=true){ans+=s[j]; vis[j]=true;}}\\n            if(k%2==0)\\n            max-=3;\\n            else max-=1;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        { if(!vis[i]) ans+=s[i];}\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "how to pass 2d array in c++. I looked online and it is giving false answer.\\nhere is my code\\n\\n\\nclass Solution {\\npublic:\\nint col(string s,int numRows){\\n    int n=s.length();\\n    while(n=>0){\\n        n=n-numRows;\\n        col++;\\n        if(n<=0){\\n            return col;\\n            break;\\n        }\\n for(int i=0;i<numRows-2;i++){\\n     if(n==0){\\n         return col;\\n     }\\n     n-=1;\\n     col++;\\n }\\n    }\\n    return col;\\n}\\nstring answer(int arr[int n][int m]){\\nstring anand=\"\";\\nfor(int i=0;i<m;i++){\\n    for(int j=0;j<n;j++){\\n        anand+=arr[j][i];\\n    }\\n}\\nreturn anand;\\n}\\n\\n    string convert(string s, int numRows) {\\n        string anand=\"\";\\n        int column=col(s,numRows);\\n        char arr[numRows][col];\\n        for(int a=0;a<numRows;a++){\\n            for(int b=0;b<column;b++){\\n                arr[numRows][col]=\\' \\';\\n            }\\n        }\\n        int i=0;\\n        int row=0,col=0;\\n        while(i!=s.length()){\\n        while(row<numRows && i<s.length()){\\n            arr[row][col]=s[i];\\n            i++;\\n        }\\n        col++;\\n        row--;\\nif(i==s.length()){\\nanand=answer(arr[numRows][column]);\\n}\\nwhile(row>0){\\n    arr[row][col]=s[i];\\n    i++;\\n    row--;\\n    col++;\\n}\\n        }\\n        return anand;\\n    }\\n};"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "In the second example explanation is not these spaces extra (I've put 'x's there), that's not exactly ZigZag movement IMHO. In other words, the first section has 6 columns while the second has 5, which doesn't make sense to me.  \n```\nP     I    N\nA  xL S  I G\nY Ax  H R\nP     I\n```"
                    },
                    {
                        "username": "hexpranay",
                        "content": "# What is wrong with this solution?\\n\\nI am doing exactly what the official solution is doing with same complexity, but my solution gives me TLE, while the official solution is accepted.\\n\\nMy solution - \\n ```\\nstring convert(string s, int numRows) {\\n        string complete=\"\";\\n        int leng = s.size();\\n        if (leng==1 || numRows>=leng)\\n            return s;\\n        int j = 0;\\n        int k = 0;\\n        int tot_row = 2*numRows-2;\\n        for(int i=0;i<numRows;i++)\\n        {\\n            j = i;\\n            while(j<leng)\\n            {\\n                complete+=s[j];\\n                if (i!=0 && i!=numRows-1){\\n                k = j+tot_row - 2 *i;\\n                if(k<leng)\\n                    {complete+=s[k];}\\n                }\\n                j+=tot_row;\\n            }   \\n        }\\n        return complete;\\n    }\\n```"
                    },
                    {
                        "username": "cityfarmer2017",
                        "content": "Why this is a wrong answer?\n```\nWrong Answer\nRuntime: 3 ms\nCase 1\nCase 2\nCase 3\nInput\ns =\n\"PAYPALISHIRING\"\nnumRows =\n3\nOutput\n\"PAHNAPLSIIGYIR\"\nExpected\n\"PAHNAPLSIIGYIR\"\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Anyone here can explain the question?"
                    }
                ]
            },
            {
                "id": 1785333,
                "content": [
                    {
                        "username": "user0740h",
                        "content": "I had trouble with this one in the past and just saw the pattern, so here are some hints:\n\n- Based on the description, the expected result is the rows without the empty spaces. Are the spaces required?\n\n- In example 2:\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N                  row 1\nA   L S  I G               row 2\nY A   H R                  row 3\nP     I                         row 4\n```\nThe first 4 characters (PAYP) go in rows 1 to 4, but the 5th (A) goes in row 3. The 6th (L) goes in row 2 and 7th (I) in row 1. We went back to row 1 and for the 8th (S) is row 2 again. Each character seems to go in the row adjacent to the previous character. Is there a pattern there?"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want a few hints without the full solution continue reading!\nUse as many hints as you need, go one at a time if you want to test yourself!\n\n1) You should loop through the rows and apply a  formula on the input string for each one.\n\n2) That formula will include a secondary loop that transforms part of the input string in a partial output. (concatenate the partial outputs that you get in each iteration).\n\n3) Notice that for the first and last rows the formula is very straightforward.\n\n4) For the rows in the middle (when numRows > 2) you need to think a little bit more but it's not too hard."
                    },
                    {
                        "username": "rotkay",
                        "content": "literally worst described problem I\\'ve seen on the leetcode"
                    },
                    {
                        "username": "qle_13",
                        "content": "This one should be easy :>"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I am seeing a pattern here. It is that first every character after numrows distance and then print every character after every  numrows-1 distance and so on. But this is failing in some cases someone help me out!\\n\\nHere is my code:\\n```class Solution {\\npublic:\\n\\n    string convert(string s, int numRows) {\\n        vector<bool> vis(size(s),false);\\n        int max,n=size(s);\\n         \\n        int k=numRows;\\n        if(numRows%2==0)\\n        max=numRows+2;\\n        else max=numRows+1;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<=0)\\n            break;\\n            for(int j=i;j<n;j+=max)\\n            { if(vis[j]!=true){ans+=s[j]; vis[j]=true;}}\\n            if(k%2==0)\\n            max-=3;\\n            else max-=1;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        { if(!vis[i]) ans+=s[i];}\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "how to pass 2d array in c++. I looked online and it is giving false answer.\\nhere is my code\\n\\n\\nclass Solution {\\npublic:\\nint col(string s,int numRows){\\n    int n=s.length();\\n    while(n=>0){\\n        n=n-numRows;\\n        col++;\\n        if(n<=0){\\n            return col;\\n            break;\\n        }\\n for(int i=0;i<numRows-2;i++){\\n     if(n==0){\\n         return col;\\n     }\\n     n-=1;\\n     col++;\\n }\\n    }\\n    return col;\\n}\\nstring answer(int arr[int n][int m]){\\nstring anand=\"\";\\nfor(int i=0;i<m;i++){\\n    for(int j=0;j<n;j++){\\n        anand+=arr[j][i];\\n    }\\n}\\nreturn anand;\\n}\\n\\n    string convert(string s, int numRows) {\\n        string anand=\"\";\\n        int column=col(s,numRows);\\n        char arr[numRows][col];\\n        for(int a=0;a<numRows;a++){\\n            for(int b=0;b<column;b++){\\n                arr[numRows][col]=\\' \\';\\n            }\\n        }\\n        int i=0;\\n        int row=0,col=0;\\n        while(i!=s.length()){\\n        while(row<numRows && i<s.length()){\\n            arr[row][col]=s[i];\\n            i++;\\n        }\\n        col++;\\n        row--;\\nif(i==s.length()){\\nanand=answer(arr[numRows][column]);\\n}\\nwhile(row>0){\\n    arr[row][col]=s[i];\\n    i++;\\n    row--;\\n    col++;\\n}\\n        }\\n        return anand;\\n    }\\n};"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "In the second example explanation is not these spaces extra (I've put 'x's there), that's not exactly ZigZag movement IMHO. In other words, the first section has 6 columns while the second has 5, which doesn't make sense to me.  \n```\nP     I    N\nA  xL S  I G\nY Ax  H R\nP     I\n```"
                    },
                    {
                        "username": "hexpranay",
                        "content": "# What is wrong with this solution?\\n\\nI am doing exactly what the official solution is doing with same complexity, but my solution gives me TLE, while the official solution is accepted.\\n\\nMy solution - \\n ```\\nstring convert(string s, int numRows) {\\n        string complete=\"\";\\n        int leng = s.size();\\n        if (leng==1 || numRows>=leng)\\n            return s;\\n        int j = 0;\\n        int k = 0;\\n        int tot_row = 2*numRows-2;\\n        for(int i=0;i<numRows;i++)\\n        {\\n            j = i;\\n            while(j<leng)\\n            {\\n                complete+=s[j];\\n                if (i!=0 && i!=numRows-1){\\n                k = j+tot_row - 2 *i;\\n                if(k<leng)\\n                    {complete+=s[k];}\\n                }\\n                j+=tot_row;\\n            }   \\n        }\\n        return complete;\\n    }\\n```"
                    },
                    {
                        "username": "cityfarmer2017",
                        "content": "Why this is a wrong answer?\n```\nWrong Answer\nRuntime: 3 ms\nCase 1\nCase 2\nCase 3\nInput\ns =\n\"PAYPALISHIRING\"\nnumRows =\n3\nOutput\n\"PAHNAPLSIIGYIR\"\nExpected\n\"PAHNAPLSIIGYIR\"\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Anyone here can explain the question?"
                    }
                ]
            },
            {
                "id": 1785315,
                "content": [
                    {
                        "username": "user0740h",
                        "content": "I had trouble with this one in the past and just saw the pattern, so here are some hints:\n\n- Based on the description, the expected result is the rows without the empty spaces. Are the spaces required?\n\n- In example 2:\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N                  row 1\nA   L S  I G               row 2\nY A   H R                  row 3\nP     I                         row 4\n```\nThe first 4 characters (PAYP) go in rows 1 to 4, but the 5th (A) goes in row 3. The 6th (L) goes in row 2 and 7th (I) in row 1. We went back to row 1 and for the 8th (S) is row 2 again. Each character seems to go in the row adjacent to the previous character. Is there a pattern there?"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want a few hints without the full solution continue reading!\nUse as many hints as you need, go one at a time if you want to test yourself!\n\n1) You should loop through the rows and apply a  formula on the input string for each one.\n\n2) That formula will include a secondary loop that transforms part of the input string in a partial output. (concatenate the partial outputs that you get in each iteration).\n\n3) Notice that for the first and last rows the formula is very straightforward.\n\n4) For the rows in the middle (when numRows > 2) you need to think a little bit more but it's not too hard."
                    },
                    {
                        "username": "rotkay",
                        "content": "literally worst described problem I\\'ve seen on the leetcode"
                    },
                    {
                        "username": "qle_13",
                        "content": "This one should be easy :>"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I am seeing a pattern here. It is that first every character after numrows distance and then print every character after every  numrows-1 distance and so on. But this is failing in some cases someone help me out!\\n\\nHere is my code:\\n```class Solution {\\npublic:\\n\\n    string convert(string s, int numRows) {\\n        vector<bool> vis(size(s),false);\\n        int max,n=size(s);\\n         \\n        int k=numRows;\\n        if(numRows%2==0)\\n        max=numRows+2;\\n        else max=numRows+1;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<=0)\\n            break;\\n            for(int j=i;j<n;j+=max)\\n            { if(vis[j]!=true){ans+=s[j]; vis[j]=true;}}\\n            if(k%2==0)\\n            max-=3;\\n            else max-=1;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        { if(!vis[i]) ans+=s[i];}\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "how to pass 2d array in c++. I looked online and it is giving false answer.\\nhere is my code\\n\\n\\nclass Solution {\\npublic:\\nint col(string s,int numRows){\\n    int n=s.length();\\n    while(n=>0){\\n        n=n-numRows;\\n        col++;\\n        if(n<=0){\\n            return col;\\n            break;\\n        }\\n for(int i=0;i<numRows-2;i++){\\n     if(n==0){\\n         return col;\\n     }\\n     n-=1;\\n     col++;\\n }\\n    }\\n    return col;\\n}\\nstring answer(int arr[int n][int m]){\\nstring anand=\"\";\\nfor(int i=0;i<m;i++){\\n    for(int j=0;j<n;j++){\\n        anand+=arr[j][i];\\n    }\\n}\\nreturn anand;\\n}\\n\\n    string convert(string s, int numRows) {\\n        string anand=\"\";\\n        int column=col(s,numRows);\\n        char arr[numRows][col];\\n        for(int a=0;a<numRows;a++){\\n            for(int b=0;b<column;b++){\\n                arr[numRows][col]=\\' \\';\\n            }\\n        }\\n        int i=0;\\n        int row=0,col=0;\\n        while(i!=s.length()){\\n        while(row<numRows && i<s.length()){\\n            arr[row][col]=s[i];\\n            i++;\\n        }\\n        col++;\\n        row--;\\nif(i==s.length()){\\nanand=answer(arr[numRows][column]);\\n}\\nwhile(row>0){\\n    arr[row][col]=s[i];\\n    i++;\\n    row--;\\n    col++;\\n}\\n        }\\n        return anand;\\n    }\\n};"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "In the second example explanation is not these spaces extra (I've put 'x's there), that's not exactly ZigZag movement IMHO. In other words, the first section has 6 columns while the second has 5, which doesn't make sense to me.  \n```\nP     I    N\nA  xL S  I G\nY Ax  H R\nP     I\n```"
                    },
                    {
                        "username": "hexpranay",
                        "content": "# What is wrong with this solution?\\n\\nI am doing exactly what the official solution is doing with same complexity, but my solution gives me TLE, while the official solution is accepted.\\n\\nMy solution - \\n ```\\nstring convert(string s, int numRows) {\\n        string complete=\"\";\\n        int leng = s.size();\\n        if (leng==1 || numRows>=leng)\\n            return s;\\n        int j = 0;\\n        int k = 0;\\n        int tot_row = 2*numRows-2;\\n        for(int i=0;i<numRows;i++)\\n        {\\n            j = i;\\n            while(j<leng)\\n            {\\n                complete+=s[j];\\n                if (i!=0 && i!=numRows-1){\\n                k = j+tot_row - 2 *i;\\n                if(k<leng)\\n                    {complete+=s[k];}\\n                }\\n                j+=tot_row;\\n            }   \\n        }\\n        return complete;\\n    }\\n```"
                    },
                    {
                        "username": "cityfarmer2017",
                        "content": "Why this is a wrong answer?\n```\nWrong Answer\nRuntime: 3 ms\nCase 1\nCase 2\nCase 3\nInput\ns =\n\"PAYPALISHIRING\"\nnumRows =\n3\nOutput\n\"PAHNAPLSIIGYIR\"\nExpected\n\"PAHNAPLSIIGYIR\"\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Anyone here can explain the question?"
                    }
                ]
            },
            {
                "id": 1785314,
                "content": [
                    {
                        "username": "user0740h",
                        "content": "I had trouble with this one in the past and just saw the pattern, so here are some hints:\n\n- Based on the description, the expected result is the rows without the empty spaces. Are the spaces required?\n\n- In example 2:\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N                  row 1\nA   L S  I G               row 2\nY A   H R                  row 3\nP     I                         row 4\n```\nThe first 4 characters (PAYP) go in rows 1 to 4, but the 5th (A) goes in row 3. The 6th (L) goes in row 2 and 7th (I) in row 1. We went back to row 1 and for the 8th (S) is row 2 again. Each character seems to go in the row adjacent to the previous character. Is there a pattern there?"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want a few hints without the full solution continue reading!\nUse as many hints as you need, go one at a time if you want to test yourself!\n\n1) You should loop through the rows and apply a  formula on the input string for each one.\n\n2) That formula will include a secondary loop that transforms part of the input string in a partial output. (concatenate the partial outputs that you get in each iteration).\n\n3) Notice that for the first and last rows the formula is very straightforward.\n\n4) For the rows in the middle (when numRows > 2) you need to think a little bit more but it's not too hard."
                    },
                    {
                        "username": "rotkay",
                        "content": "literally worst described problem I\\'ve seen on the leetcode"
                    },
                    {
                        "username": "qle_13",
                        "content": "This one should be easy :>"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I am seeing a pattern here. It is that first every character after numrows distance and then print every character after every  numrows-1 distance and so on. But this is failing in some cases someone help me out!\\n\\nHere is my code:\\n```class Solution {\\npublic:\\n\\n    string convert(string s, int numRows) {\\n        vector<bool> vis(size(s),false);\\n        int max,n=size(s);\\n         \\n        int k=numRows;\\n        if(numRows%2==0)\\n        max=numRows+2;\\n        else max=numRows+1;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<=0)\\n            break;\\n            for(int j=i;j<n;j+=max)\\n            { if(vis[j]!=true){ans+=s[j]; vis[j]=true;}}\\n            if(k%2==0)\\n            max-=3;\\n            else max-=1;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        { if(!vis[i]) ans+=s[i];}\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "how to pass 2d array in c++. I looked online and it is giving false answer.\\nhere is my code\\n\\n\\nclass Solution {\\npublic:\\nint col(string s,int numRows){\\n    int n=s.length();\\n    while(n=>0){\\n        n=n-numRows;\\n        col++;\\n        if(n<=0){\\n            return col;\\n            break;\\n        }\\n for(int i=0;i<numRows-2;i++){\\n     if(n==0){\\n         return col;\\n     }\\n     n-=1;\\n     col++;\\n }\\n    }\\n    return col;\\n}\\nstring answer(int arr[int n][int m]){\\nstring anand=\"\";\\nfor(int i=0;i<m;i++){\\n    for(int j=0;j<n;j++){\\n        anand+=arr[j][i];\\n    }\\n}\\nreturn anand;\\n}\\n\\n    string convert(string s, int numRows) {\\n        string anand=\"\";\\n        int column=col(s,numRows);\\n        char arr[numRows][col];\\n        for(int a=0;a<numRows;a++){\\n            for(int b=0;b<column;b++){\\n                arr[numRows][col]=\\' \\';\\n            }\\n        }\\n        int i=0;\\n        int row=0,col=0;\\n        while(i!=s.length()){\\n        while(row<numRows && i<s.length()){\\n            arr[row][col]=s[i];\\n            i++;\\n        }\\n        col++;\\n        row--;\\nif(i==s.length()){\\nanand=answer(arr[numRows][column]);\\n}\\nwhile(row>0){\\n    arr[row][col]=s[i];\\n    i++;\\n    row--;\\n    col++;\\n}\\n        }\\n        return anand;\\n    }\\n};"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "In the second example explanation is not these spaces extra (I've put 'x's there), that's not exactly ZigZag movement IMHO. In other words, the first section has 6 columns while the second has 5, which doesn't make sense to me.  \n```\nP     I    N\nA  xL S  I G\nY Ax  H R\nP     I\n```"
                    },
                    {
                        "username": "hexpranay",
                        "content": "# What is wrong with this solution?\\n\\nI am doing exactly what the official solution is doing with same complexity, but my solution gives me TLE, while the official solution is accepted.\\n\\nMy solution - \\n ```\\nstring convert(string s, int numRows) {\\n        string complete=\"\";\\n        int leng = s.size();\\n        if (leng==1 || numRows>=leng)\\n            return s;\\n        int j = 0;\\n        int k = 0;\\n        int tot_row = 2*numRows-2;\\n        for(int i=0;i<numRows;i++)\\n        {\\n            j = i;\\n            while(j<leng)\\n            {\\n                complete+=s[j];\\n                if (i!=0 && i!=numRows-1){\\n                k = j+tot_row - 2 *i;\\n                if(k<leng)\\n                    {complete+=s[k];}\\n                }\\n                j+=tot_row;\\n            }   \\n        }\\n        return complete;\\n    }\\n```"
                    },
                    {
                        "username": "cityfarmer2017",
                        "content": "Why this is a wrong answer?\n```\nWrong Answer\nRuntime: 3 ms\nCase 1\nCase 2\nCase 3\nInput\ns =\n\"PAYPALISHIRING\"\nnumRows =\n3\nOutput\n\"PAHNAPLSIIGYIR\"\nExpected\n\"PAHNAPLSIIGYIR\"\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Anyone here can explain the question?"
                    }
                ]
            },
            {
                "id": 1784944,
                "content": [
                    {
                        "username": "user0740h",
                        "content": "I had trouble with this one in the past and just saw the pattern, so here are some hints:\n\n- Based on the description, the expected result is the rows without the empty spaces. Are the spaces required?\n\n- In example 2:\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N                  row 1\nA   L S  I G               row 2\nY A   H R                  row 3\nP     I                         row 4\n```\nThe first 4 characters (PAYP) go in rows 1 to 4, but the 5th (A) goes in row 3. The 6th (L) goes in row 2 and 7th (I) in row 1. We went back to row 1 and for the 8th (S) is row 2 again. Each character seems to go in the row adjacent to the previous character. Is there a pattern there?"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want a few hints without the full solution continue reading!\nUse as many hints as you need, go one at a time if you want to test yourself!\n\n1) You should loop through the rows and apply a  formula on the input string for each one.\n\n2) That formula will include a secondary loop that transforms part of the input string in a partial output. (concatenate the partial outputs that you get in each iteration).\n\n3) Notice that for the first and last rows the formula is very straightforward.\n\n4) For the rows in the middle (when numRows > 2) you need to think a little bit more but it's not too hard."
                    },
                    {
                        "username": "rotkay",
                        "content": "literally worst described problem I\\'ve seen on the leetcode"
                    },
                    {
                        "username": "qle_13",
                        "content": "This one should be easy :>"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I am seeing a pattern here. It is that first every character after numrows distance and then print every character after every  numrows-1 distance and so on. But this is failing in some cases someone help me out!\\n\\nHere is my code:\\n```class Solution {\\npublic:\\n\\n    string convert(string s, int numRows) {\\n        vector<bool> vis(size(s),false);\\n        int max,n=size(s);\\n         \\n        int k=numRows;\\n        if(numRows%2==0)\\n        max=numRows+2;\\n        else max=numRows+1;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<=0)\\n            break;\\n            for(int j=i;j<n;j+=max)\\n            { if(vis[j]!=true){ans+=s[j]; vis[j]=true;}}\\n            if(k%2==0)\\n            max-=3;\\n            else max-=1;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        { if(!vis[i]) ans+=s[i];}\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "how to pass 2d array in c++. I looked online and it is giving false answer.\\nhere is my code\\n\\n\\nclass Solution {\\npublic:\\nint col(string s,int numRows){\\n    int n=s.length();\\n    while(n=>0){\\n        n=n-numRows;\\n        col++;\\n        if(n<=0){\\n            return col;\\n            break;\\n        }\\n for(int i=0;i<numRows-2;i++){\\n     if(n==0){\\n         return col;\\n     }\\n     n-=1;\\n     col++;\\n }\\n    }\\n    return col;\\n}\\nstring answer(int arr[int n][int m]){\\nstring anand=\"\";\\nfor(int i=0;i<m;i++){\\n    for(int j=0;j<n;j++){\\n        anand+=arr[j][i];\\n    }\\n}\\nreturn anand;\\n}\\n\\n    string convert(string s, int numRows) {\\n        string anand=\"\";\\n        int column=col(s,numRows);\\n        char arr[numRows][col];\\n        for(int a=0;a<numRows;a++){\\n            for(int b=0;b<column;b++){\\n                arr[numRows][col]=\\' \\';\\n            }\\n        }\\n        int i=0;\\n        int row=0,col=0;\\n        while(i!=s.length()){\\n        while(row<numRows && i<s.length()){\\n            arr[row][col]=s[i];\\n            i++;\\n        }\\n        col++;\\n        row--;\\nif(i==s.length()){\\nanand=answer(arr[numRows][column]);\\n}\\nwhile(row>0){\\n    arr[row][col]=s[i];\\n    i++;\\n    row--;\\n    col++;\\n}\\n        }\\n        return anand;\\n    }\\n};"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "In the second example explanation is not these spaces extra (I've put 'x's there), that's not exactly ZigZag movement IMHO. In other words, the first section has 6 columns while the second has 5, which doesn't make sense to me.  \n```\nP     I    N\nA  xL S  I G\nY Ax  H R\nP     I\n```"
                    },
                    {
                        "username": "hexpranay",
                        "content": "# What is wrong with this solution?\\n\\nI am doing exactly what the official solution is doing with same complexity, but my solution gives me TLE, while the official solution is accepted.\\n\\nMy solution - \\n ```\\nstring convert(string s, int numRows) {\\n        string complete=\"\";\\n        int leng = s.size();\\n        if (leng==1 || numRows>=leng)\\n            return s;\\n        int j = 0;\\n        int k = 0;\\n        int tot_row = 2*numRows-2;\\n        for(int i=0;i<numRows;i++)\\n        {\\n            j = i;\\n            while(j<leng)\\n            {\\n                complete+=s[j];\\n                if (i!=0 && i!=numRows-1){\\n                k = j+tot_row - 2 *i;\\n                if(k<leng)\\n                    {complete+=s[k];}\\n                }\\n                j+=tot_row;\\n            }   \\n        }\\n        return complete;\\n    }\\n```"
                    },
                    {
                        "username": "cityfarmer2017",
                        "content": "Why this is a wrong answer?\n```\nWrong Answer\nRuntime: 3 ms\nCase 1\nCase 2\nCase 3\nInput\ns =\n\"PAYPALISHIRING\"\nnumRows =\n3\nOutput\n\"PAHNAPLSIIGYIR\"\nExpected\n\"PAHNAPLSIIGYIR\"\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Anyone here can explain the question?"
                    }
                ]
            },
            {
                "id": 1782166,
                "content": [
                    {
                        "username": "user0740h",
                        "content": "I had trouble with this one in the past and just saw the pattern, so here are some hints:\n\n- Based on the description, the expected result is the rows without the empty spaces. Are the spaces required?\n\n- In example 2:\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N                  row 1\nA   L S  I G               row 2\nY A   H R                  row 3\nP     I                         row 4\n```\nThe first 4 characters (PAYP) go in rows 1 to 4, but the 5th (A) goes in row 3. The 6th (L) goes in row 2 and 7th (I) in row 1. We went back to row 1 and for the 8th (S) is row 2 again. Each character seems to go in the row adjacent to the previous character. Is there a pattern there?"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want a few hints without the full solution continue reading!\nUse as many hints as you need, go one at a time if you want to test yourself!\n\n1) You should loop through the rows and apply a  formula on the input string for each one.\n\n2) That formula will include a secondary loop that transforms part of the input string in a partial output. (concatenate the partial outputs that you get in each iteration).\n\n3) Notice that for the first and last rows the formula is very straightforward.\n\n4) For the rows in the middle (when numRows > 2) you need to think a little bit more but it's not too hard."
                    },
                    {
                        "username": "rotkay",
                        "content": "literally worst described problem I\\'ve seen on the leetcode"
                    },
                    {
                        "username": "qle_13",
                        "content": "This one should be easy :>"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I am seeing a pattern here. It is that first every character after numrows distance and then print every character after every  numrows-1 distance and so on. But this is failing in some cases someone help me out!\\n\\nHere is my code:\\n```class Solution {\\npublic:\\n\\n    string convert(string s, int numRows) {\\n        vector<bool> vis(size(s),false);\\n        int max,n=size(s);\\n         \\n        int k=numRows;\\n        if(numRows%2==0)\\n        max=numRows+2;\\n        else max=numRows+1;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<=0)\\n            break;\\n            for(int j=i;j<n;j+=max)\\n            { if(vis[j]!=true){ans+=s[j]; vis[j]=true;}}\\n            if(k%2==0)\\n            max-=3;\\n            else max-=1;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        { if(!vis[i]) ans+=s[i];}\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "how to pass 2d array in c++. I looked online and it is giving false answer.\\nhere is my code\\n\\n\\nclass Solution {\\npublic:\\nint col(string s,int numRows){\\n    int n=s.length();\\n    while(n=>0){\\n        n=n-numRows;\\n        col++;\\n        if(n<=0){\\n            return col;\\n            break;\\n        }\\n for(int i=0;i<numRows-2;i++){\\n     if(n==0){\\n         return col;\\n     }\\n     n-=1;\\n     col++;\\n }\\n    }\\n    return col;\\n}\\nstring answer(int arr[int n][int m]){\\nstring anand=\"\";\\nfor(int i=0;i<m;i++){\\n    for(int j=0;j<n;j++){\\n        anand+=arr[j][i];\\n    }\\n}\\nreturn anand;\\n}\\n\\n    string convert(string s, int numRows) {\\n        string anand=\"\";\\n        int column=col(s,numRows);\\n        char arr[numRows][col];\\n        for(int a=0;a<numRows;a++){\\n            for(int b=0;b<column;b++){\\n                arr[numRows][col]=\\' \\';\\n            }\\n        }\\n        int i=0;\\n        int row=0,col=0;\\n        while(i!=s.length()){\\n        while(row<numRows && i<s.length()){\\n            arr[row][col]=s[i];\\n            i++;\\n        }\\n        col++;\\n        row--;\\nif(i==s.length()){\\nanand=answer(arr[numRows][column]);\\n}\\nwhile(row>0){\\n    arr[row][col]=s[i];\\n    i++;\\n    row--;\\n    col++;\\n}\\n        }\\n        return anand;\\n    }\\n};"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "In the second example explanation is not these spaces extra (I've put 'x's there), that's not exactly ZigZag movement IMHO. In other words, the first section has 6 columns while the second has 5, which doesn't make sense to me.  \n```\nP     I    N\nA  xL S  I G\nY Ax  H R\nP     I\n```"
                    },
                    {
                        "username": "hexpranay",
                        "content": "# What is wrong with this solution?\\n\\nI am doing exactly what the official solution is doing with same complexity, but my solution gives me TLE, while the official solution is accepted.\\n\\nMy solution - \\n ```\\nstring convert(string s, int numRows) {\\n        string complete=\"\";\\n        int leng = s.size();\\n        if (leng==1 || numRows>=leng)\\n            return s;\\n        int j = 0;\\n        int k = 0;\\n        int tot_row = 2*numRows-2;\\n        for(int i=0;i<numRows;i++)\\n        {\\n            j = i;\\n            while(j<leng)\\n            {\\n                complete+=s[j];\\n                if (i!=0 && i!=numRows-1){\\n                k = j+tot_row - 2 *i;\\n                if(k<leng)\\n                    {complete+=s[k];}\\n                }\\n                j+=tot_row;\\n            }   \\n        }\\n        return complete;\\n    }\\n```"
                    },
                    {
                        "username": "cityfarmer2017",
                        "content": "Why this is a wrong answer?\n```\nWrong Answer\nRuntime: 3 ms\nCase 1\nCase 2\nCase 3\nInput\ns =\n\"PAYPALISHIRING\"\nnumRows =\n3\nOutput\n\"PAHNAPLSIIGYIR\"\nExpected\n\"PAHNAPLSIIGYIR\"\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Anyone here can explain the question?"
                    }
                ]
            },
            {
                "id": 1781938,
                "content": [
                    {
                        "username": "user0740h",
                        "content": "I had trouble with this one in the past and just saw the pattern, so here are some hints:\n\n- Based on the description, the expected result is the rows without the empty spaces. Are the spaces required?\n\n- In example 2:\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N                  row 1\nA   L S  I G               row 2\nY A   H R                  row 3\nP     I                         row 4\n```\nThe first 4 characters (PAYP) go in rows 1 to 4, but the 5th (A) goes in row 3. The 6th (L) goes in row 2 and 7th (I) in row 1. We went back to row 1 and for the 8th (S) is row 2 again. Each character seems to go in the row adjacent to the previous character. Is there a pattern there?"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want a few hints without the full solution continue reading!\nUse as many hints as you need, go one at a time if you want to test yourself!\n\n1) You should loop through the rows and apply a  formula on the input string for each one.\n\n2) That formula will include a secondary loop that transforms part of the input string in a partial output. (concatenate the partial outputs that you get in each iteration).\n\n3) Notice that for the first and last rows the formula is very straightforward.\n\n4) For the rows in the middle (when numRows > 2) you need to think a little bit more but it's not too hard."
                    },
                    {
                        "username": "rotkay",
                        "content": "literally worst described problem I\\'ve seen on the leetcode"
                    },
                    {
                        "username": "qle_13",
                        "content": "This one should be easy :>"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I am seeing a pattern here. It is that first every character after numrows distance and then print every character after every  numrows-1 distance and so on. But this is failing in some cases someone help me out!\\n\\nHere is my code:\\n```class Solution {\\npublic:\\n\\n    string convert(string s, int numRows) {\\n        vector<bool> vis(size(s),false);\\n        int max,n=size(s);\\n         \\n        int k=numRows;\\n        if(numRows%2==0)\\n        max=numRows+2;\\n        else max=numRows+1;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<=0)\\n            break;\\n            for(int j=i;j<n;j+=max)\\n            { if(vis[j]!=true){ans+=s[j]; vis[j]=true;}}\\n            if(k%2==0)\\n            max-=3;\\n            else max-=1;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        { if(!vis[i]) ans+=s[i];}\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "how to pass 2d array in c++. I looked online and it is giving false answer.\\nhere is my code\\n\\n\\nclass Solution {\\npublic:\\nint col(string s,int numRows){\\n    int n=s.length();\\n    while(n=>0){\\n        n=n-numRows;\\n        col++;\\n        if(n<=0){\\n            return col;\\n            break;\\n        }\\n for(int i=0;i<numRows-2;i++){\\n     if(n==0){\\n         return col;\\n     }\\n     n-=1;\\n     col++;\\n }\\n    }\\n    return col;\\n}\\nstring answer(int arr[int n][int m]){\\nstring anand=\"\";\\nfor(int i=0;i<m;i++){\\n    for(int j=0;j<n;j++){\\n        anand+=arr[j][i];\\n    }\\n}\\nreturn anand;\\n}\\n\\n    string convert(string s, int numRows) {\\n        string anand=\"\";\\n        int column=col(s,numRows);\\n        char arr[numRows][col];\\n        for(int a=0;a<numRows;a++){\\n            for(int b=0;b<column;b++){\\n                arr[numRows][col]=\\' \\';\\n            }\\n        }\\n        int i=0;\\n        int row=0,col=0;\\n        while(i!=s.length()){\\n        while(row<numRows && i<s.length()){\\n            arr[row][col]=s[i];\\n            i++;\\n        }\\n        col++;\\n        row--;\\nif(i==s.length()){\\nanand=answer(arr[numRows][column]);\\n}\\nwhile(row>0){\\n    arr[row][col]=s[i];\\n    i++;\\n    row--;\\n    col++;\\n}\\n        }\\n        return anand;\\n    }\\n};"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "In the second example explanation is not these spaces extra (I've put 'x's there), that's not exactly ZigZag movement IMHO. In other words, the first section has 6 columns while the second has 5, which doesn't make sense to me.  \n```\nP     I    N\nA  xL S  I G\nY Ax  H R\nP     I\n```"
                    },
                    {
                        "username": "hexpranay",
                        "content": "# What is wrong with this solution?\\n\\nI am doing exactly what the official solution is doing with same complexity, but my solution gives me TLE, while the official solution is accepted.\\n\\nMy solution - \\n ```\\nstring convert(string s, int numRows) {\\n        string complete=\"\";\\n        int leng = s.size();\\n        if (leng==1 || numRows>=leng)\\n            return s;\\n        int j = 0;\\n        int k = 0;\\n        int tot_row = 2*numRows-2;\\n        for(int i=0;i<numRows;i++)\\n        {\\n            j = i;\\n            while(j<leng)\\n            {\\n                complete+=s[j];\\n                if (i!=0 && i!=numRows-1){\\n                k = j+tot_row - 2 *i;\\n                if(k<leng)\\n                    {complete+=s[k];}\\n                }\\n                j+=tot_row;\\n            }   \\n        }\\n        return complete;\\n    }\\n```"
                    },
                    {
                        "username": "cityfarmer2017",
                        "content": "Why this is a wrong answer?\n```\nWrong Answer\nRuntime: 3 ms\nCase 1\nCase 2\nCase 3\nInput\ns =\n\"PAYPALISHIRING\"\nnumRows =\n3\nOutput\n\"PAHNAPLSIIGYIR\"\nExpected\n\"PAHNAPLSIIGYIR\"\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Anyone here can explain the question?"
                    }
                ]
            },
            {
                "id": 1774359,
                "content": [
                    {
                        "username": "user0740h",
                        "content": "I had trouble with this one in the past and just saw the pattern, so here are some hints:\n\n- Based on the description, the expected result is the rows without the empty spaces. Are the spaces required?\n\n- In example 2:\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N                  row 1\nA   L S  I G               row 2\nY A   H R                  row 3\nP     I                         row 4\n```\nThe first 4 characters (PAYP) go in rows 1 to 4, but the 5th (A) goes in row 3. The 6th (L) goes in row 2 and 7th (I) in row 1. We went back to row 1 and for the 8th (S) is row 2 again. Each character seems to go in the row adjacent to the previous character. Is there a pattern there?"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want a few hints without the full solution continue reading!\nUse as many hints as you need, go one at a time if you want to test yourself!\n\n1) You should loop through the rows and apply a  formula on the input string for each one.\n\n2) That formula will include a secondary loop that transforms part of the input string in a partial output. (concatenate the partial outputs that you get in each iteration).\n\n3) Notice that for the first and last rows the formula is very straightforward.\n\n4) For the rows in the middle (when numRows > 2) you need to think a little bit more but it's not too hard."
                    },
                    {
                        "username": "rotkay",
                        "content": "literally worst described problem I\\'ve seen on the leetcode"
                    },
                    {
                        "username": "qle_13",
                        "content": "This one should be easy :>"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I am seeing a pattern here. It is that first every character after numrows distance and then print every character after every  numrows-1 distance and so on. But this is failing in some cases someone help me out!\\n\\nHere is my code:\\n```class Solution {\\npublic:\\n\\n    string convert(string s, int numRows) {\\n        vector<bool> vis(size(s),false);\\n        int max,n=size(s);\\n         \\n        int k=numRows;\\n        if(numRows%2==0)\\n        max=numRows+2;\\n        else max=numRows+1;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<=0)\\n            break;\\n            for(int j=i;j<n;j+=max)\\n            { if(vis[j]!=true){ans+=s[j]; vis[j]=true;}}\\n            if(k%2==0)\\n            max-=3;\\n            else max-=1;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        { if(!vis[i]) ans+=s[i];}\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "how to pass 2d array in c++. I looked online and it is giving false answer.\\nhere is my code\\n\\n\\nclass Solution {\\npublic:\\nint col(string s,int numRows){\\n    int n=s.length();\\n    while(n=>0){\\n        n=n-numRows;\\n        col++;\\n        if(n<=0){\\n            return col;\\n            break;\\n        }\\n for(int i=0;i<numRows-2;i++){\\n     if(n==0){\\n         return col;\\n     }\\n     n-=1;\\n     col++;\\n }\\n    }\\n    return col;\\n}\\nstring answer(int arr[int n][int m]){\\nstring anand=\"\";\\nfor(int i=0;i<m;i++){\\n    for(int j=0;j<n;j++){\\n        anand+=arr[j][i];\\n    }\\n}\\nreturn anand;\\n}\\n\\n    string convert(string s, int numRows) {\\n        string anand=\"\";\\n        int column=col(s,numRows);\\n        char arr[numRows][col];\\n        for(int a=0;a<numRows;a++){\\n            for(int b=0;b<column;b++){\\n                arr[numRows][col]=\\' \\';\\n            }\\n        }\\n        int i=0;\\n        int row=0,col=0;\\n        while(i!=s.length()){\\n        while(row<numRows && i<s.length()){\\n            arr[row][col]=s[i];\\n            i++;\\n        }\\n        col++;\\n        row--;\\nif(i==s.length()){\\nanand=answer(arr[numRows][column]);\\n}\\nwhile(row>0){\\n    arr[row][col]=s[i];\\n    i++;\\n    row--;\\n    col++;\\n}\\n        }\\n        return anand;\\n    }\\n};"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "In the second example explanation is not these spaces extra (I've put 'x's there), that's not exactly ZigZag movement IMHO. In other words, the first section has 6 columns while the second has 5, which doesn't make sense to me.  \n```\nP     I    N\nA  xL S  I G\nY Ax  H R\nP     I\n```"
                    },
                    {
                        "username": "hexpranay",
                        "content": "# What is wrong with this solution?\\n\\nI am doing exactly what the official solution is doing with same complexity, but my solution gives me TLE, while the official solution is accepted.\\n\\nMy solution - \\n ```\\nstring convert(string s, int numRows) {\\n        string complete=\"\";\\n        int leng = s.size();\\n        if (leng==1 || numRows>=leng)\\n            return s;\\n        int j = 0;\\n        int k = 0;\\n        int tot_row = 2*numRows-2;\\n        for(int i=0;i<numRows;i++)\\n        {\\n            j = i;\\n            while(j<leng)\\n            {\\n                complete+=s[j];\\n                if (i!=0 && i!=numRows-1){\\n                k = j+tot_row - 2 *i;\\n                if(k<leng)\\n                    {complete+=s[k];}\\n                }\\n                j+=tot_row;\\n            }   \\n        }\\n        return complete;\\n    }\\n```"
                    },
                    {
                        "username": "cityfarmer2017",
                        "content": "Why this is a wrong answer?\n```\nWrong Answer\nRuntime: 3 ms\nCase 1\nCase 2\nCase 3\nInput\ns =\n\"PAYPALISHIRING\"\nnumRows =\n3\nOutput\n\"PAHNAPLSIIGYIR\"\nExpected\n\"PAHNAPLSIIGYIR\"\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Anyone here can explain the question?"
                    }
                ]
            },
            {
                "id": 1771837,
                "content": [
                    {
                        "username": "user0740h",
                        "content": "I had trouble with this one in the past and just saw the pattern, so here are some hints:\n\n- Based on the description, the expected result is the rows without the empty spaces. Are the spaces required?\n\n- In example 2:\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N                  row 1\nA   L S  I G               row 2\nY A   H R                  row 3\nP     I                         row 4\n```\nThe first 4 characters (PAYP) go in rows 1 to 4, but the 5th (A) goes in row 3. The 6th (L) goes in row 2 and 7th (I) in row 1. We went back to row 1 and for the 8th (S) is row 2 again. Each character seems to go in the row adjacent to the previous character. Is there a pattern there?"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want a few hints without the full solution continue reading!\nUse as many hints as you need, go one at a time if you want to test yourself!\n\n1) You should loop through the rows and apply a  formula on the input string for each one.\n\n2) That formula will include a secondary loop that transforms part of the input string in a partial output. (concatenate the partial outputs that you get in each iteration).\n\n3) Notice that for the first and last rows the formula is very straightforward.\n\n4) For the rows in the middle (when numRows > 2) you need to think a little bit more but it's not too hard."
                    },
                    {
                        "username": "rotkay",
                        "content": "literally worst described problem I\\'ve seen on the leetcode"
                    },
                    {
                        "username": "qle_13",
                        "content": "This one should be easy :>"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I am seeing a pattern here. It is that first every character after numrows distance and then print every character after every  numrows-1 distance and so on. But this is failing in some cases someone help me out!\\n\\nHere is my code:\\n```class Solution {\\npublic:\\n\\n    string convert(string s, int numRows) {\\n        vector<bool> vis(size(s),false);\\n        int max,n=size(s);\\n         \\n        int k=numRows;\\n        if(numRows%2==0)\\n        max=numRows+2;\\n        else max=numRows+1;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<=0)\\n            break;\\n            for(int j=i;j<n;j+=max)\\n            { if(vis[j]!=true){ans+=s[j]; vis[j]=true;}}\\n            if(k%2==0)\\n            max-=3;\\n            else max-=1;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        { if(!vis[i]) ans+=s[i];}\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "how to pass 2d array in c++. I looked online and it is giving false answer.\\nhere is my code\\n\\n\\nclass Solution {\\npublic:\\nint col(string s,int numRows){\\n    int n=s.length();\\n    while(n=>0){\\n        n=n-numRows;\\n        col++;\\n        if(n<=0){\\n            return col;\\n            break;\\n        }\\n for(int i=0;i<numRows-2;i++){\\n     if(n==0){\\n         return col;\\n     }\\n     n-=1;\\n     col++;\\n }\\n    }\\n    return col;\\n}\\nstring answer(int arr[int n][int m]){\\nstring anand=\"\";\\nfor(int i=0;i<m;i++){\\n    for(int j=0;j<n;j++){\\n        anand+=arr[j][i];\\n    }\\n}\\nreturn anand;\\n}\\n\\n    string convert(string s, int numRows) {\\n        string anand=\"\";\\n        int column=col(s,numRows);\\n        char arr[numRows][col];\\n        for(int a=0;a<numRows;a++){\\n            for(int b=0;b<column;b++){\\n                arr[numRows][col]=\\' \\';\\n            }\\n        }\\n        int i=0;\\n        int row=0,col=0;\\n        while(i!=s.length()){\\n        while(row<numRows && i<s.length()){\\n            arr[row][col]=s[i];\\n            i++;\\n        }\\n        col++;\\n        row--;\\nif(i==s.length()){\\nanand=answer(arr[numRows][column]);\\n}\\nwhile(row>0){\\n    arr[row][col]=s[i];\\n    i++;\\n    row--;\\n    col++;\\n}\\n        }\\n        return anand;\\n    }\\n};"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "In the second example explanation is not these spaces extra (I've put 'x's there), that's not exactly ZigZag movement IMHO. In other words, the first section has 6 columns while the second has 5, which doesn't make sense to me.  \n```\nP     I    N\nA  xL S  I G\nY Ax  H R\nP     I\n```"
                    },
                    {
                        "username": "hexpranay",
                        "content": "# What is wrong with this solution?\\n\\nI am doing exactly what the official solution is doing with same complexity, but my solution gives me TLE, while the official solution is accepted.\\n\\nMy solution - \\n ```\\nstring convert(string s, int numRows) {\\n        string complete=\"\";\\n        int leng = s.size();\\n        if (leng==1 || numRows>=leng)\\n            return s;\\n        int j = 0;\\n        int k = 0;\\n        int tot_row = 2*numRows-2;\\n        for(int i=0;i<numRows;i++)\\n        {\\n            j = i;\\n            while(j<leng)\\n            {\\n                complete+=s[j];\\n                if (i!=0 && i!=numRows-1){\\n                k = j+tot_row - 2 *i;\\n                if(k<leng)\\n                    {complete+=s[k];}\\n                }\\n                j+=tot_row;\\n            }   \\n        }\\n        return complete;\\n    }\\n```"
                    },
                    {
                        "username": "cityfarmer2017",
                        "content": "Why this is a wrong answer?\n```\nWrong Answer\nRuntime: 3 ms\nCase 1\nCase 2\nCase 3\nInput\ns =\n\"PAYPALISHIRING\"\nnumRows =\n3\nOutput\n\"PAHNAPLSIIGYIR\"\nExpected\n\"PAHNAPLSIIGYIR\"\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Anyone here can explain the question?"
                    }
                ]
            },
            {
                "id": 1755957,
                "content": [
                    {
                        "username": "user0740h",
                        "content": "I had trouble with this one in the past and just saw the pattern, so here are some hints:\n\n- Based on the description, the expected result is the rows without the empty spaces. Are the spaces required?\n\n- In example 2:\n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N                  row 1\nA   L S  I G               row 2\nY A   H R                  row 3\nP     I                         row 4\n```\nThe first 4 characters (PAYP) go in rows 1 to 4, but the 5th (A) goes in row 3. The 6th (L) goes in row 2 and 7th (I) in row 1. We went back to row 1 and for the 8th (S) is row 2 again. Each character seems to go in the row adjacent to the previous character. Is there a pattern there?"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want a few hints without the full solution continue reading!\nUse as many hints as you need, go one at a time if you want to test yourself!\n\n1) You should loop through the rows and apply a  formula on the input string for each one.\n\n2) That formula will include a secondary loop that transforms part of the input string in a partial output. (concatenate the partial outputs that you get in each iteration).\n\n3) Notice that for the first and last rows the formula is very straightforward.\n\n4) For the rows in the middle (when numRows > 2) you need to think a little bit more but it's not too hard."
                    },
                    {
                        "username": "rotkay",
                        "content": "literally worst described problem I\\'ve seen on the leetcode"
                    },
                    {
                        "username": "qle_13",
                        "content": "This one should be easy :>"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "I am seeing a pattern here. It is that first every character after numrows distance and then print every character after every  numrows-1 distance and so on. But this is failing in some cases someone help me out!\\n\\nHere is my code:\\n```class Solution {\\npublic:\\n\\n    string convert(string s, int numRows) {\\n        vector<bool> vis(size(s),false);\\n        int max,n=size(s);\\n         \\n        int k=numRows;\\n        if(numRows%2==0)\\n        max=numRows+2;\\n        else max=numRows+1;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<=0)\\n            break;\\n            for(int j=i;j<n;j+=max)\\n            { if(vis[j]!=true){ans+=s[j]; vis[j]=true;}}\\n            if(k%2==0)\\n            max-=3;\\n            else max-=1;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        { if(!vis[i]) ans+=s[i];}\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "how to pass 2d array in c++. I looked online and it is giving false answer.\\nhere is my code\\n\\n\\nclass Solution {\\npublic:\\nint col(string s,int numRows){\\n    int n=s.length();\\n    while(n=>0){\\n        n=n-numRows;\\n        col++;\\n        if(n<=0){\\n            return col;\\n            break;\\n        }\\n for(int i=0;i<numRows-2;i++){\\n     if(n==0){\\n         return col;\\n     }\\n     n-=1;\\n     col++;\\n }\\n    }\\n    return col;\\n}\\nstring answer(int arr[int n][int m]){\\nstring anand=\"\";\\nfor(int i=0;i<m;i++){\\n    for(int j=0;j<n;j++){\\n        anand+=arr[j][i];\\n    }\\n}\\nreturn anand;\\n}\\n\\n    string convert(string s, int numRows) {\\n        string anand=\"\";\\n        int column=col(s,numRows);\\n        char arr[numRows][col];\\n        for(int a=0;a<numRows;a++){\\n            for(int b=0;b<column;b++){\\n                arr[numRows][col]=\\' \\';\\n            }\\n        }\\n        int i=0;\\n        int row=0,col=0;\\n        while(i!=s.length()){\\n        while(row<numRows && i<s.length()){\\n            arr[row][col]=s[i];\\n            i++;\\n        }\\n        col++;\\n        row--;\\nif(i==s.length()){\\nanand=answer(arr[numRows][column]);\\n}\\nwhile(row>0){\\n    arr[row][col]=s[i];\\n    i++;\\n    row--;\\n    col++;\\n}\\n        }\\n        return anand;\\n    }\\n};"
                    },
                    {
                        "username": "genuine_stamina",
                        "content": "In the second example explanation is not these spaces extra (I've put 'x's there), that's not exactly ZigZag movement IMHO. In other words, the first section has 6 columns while the second has 5, which doesn't make sense to me.  \n```\nP     I    N\nA  xL S  I G\nY Ax  H R\nP     I\n```"
                    },
                    {
                        "username": "hexpranay",
                        "content": "# What is wrong with this solution?\\n\\nI am doing exactly what the official solution is doing with same complexity, but my solution gives me TLE, while the official solution is accepted.\\n\\nMy solution - \\n ```\\nstring convert(string s, int numRows) {\\n        string complete=\"\";\\n        int leng = s.size();\\n        if (leng==1 || numRows>=leng)\\n            return s;\\n        int j = 0;\\n        int k = 0;\\n        int tot_row = 2*numRows-2;\\n        for(int i=0;i<numRows;i++)\\n        {\\n            j = i;\\n            while(j<leng)\\n            {\\n                complete+=s[j];\\n                if (i!=0 && i!=numRows-1){\\n                k = j+tot_row - 2 *i;\\n                if(k<leng)\\n                    {complete+=s[k];}\\n                }\\n                j+=tot_row;\\n            }   \\n        }\\n        return complete;\\n    }\\n```"
                    },
                    {
                        "username": "cityfarmer2017",
                        "content": "Why this is a wrong answer?\n```\nWrong Answer\nRuntime: 3 ms\nCase 1\nCase 2\nCase 3\nInput\ns =\n\"PAYPALISHIRING\"\nnumRows =\n3\nOutput\n\"PAHNAPLSIIGYIR\"\nExpected\n\"PAHNAPLSIIGYIR\"\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Anyone here can explain the question?"
                    }
                ]
            },
            {
                "id": 1750893,
                "content": [
                    {
                        "username": "kannan-ramesh",
                        "content": "why this code error?,,but no error in cpp please any one help...\\n\\nLine 11: error: array required, but String found\\n                arr[row++][col]=s[cur++];\\n                                 ^\\nLine 15: error: array required, but String found\\n                arr[row--][++col]=s[cur++];\\n                                   ^\\n2 errors\\nConsole\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        String arr[][]=new String[numRows][s.length()];\\n\\n        int row=0;\\n        int col=0;\\n        int cur=0;\\n\\n        while(cur<s.length()){\\n            while(row<numRows && cur<s.length()){\\n                arr[row++][col]=s[cur++];\\n            }\\n            row=Math.max(0,row-2);\\n            while(row>0 && cur<s.length()){\\n                arr[row--][++col]=s[cur++];\\n            }\\n            col++;\\n        }\\n\\n        String ans=\" \";\\n\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<s.length();j++){\\n                ans+=arr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "coder_Harsh",
                        "content": "Problem statement not clear!!!"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Am I the Only one who don\\'t understand  what is the required  ?\\nI see this question is not clear and missing details "
                    },
                    {
                        "username": "pablomariaarranzpou",
                        "content": "It\\'s like the words are readed going up un down starting going down and the a diagonal to the right. This Is done with the number of rows in input."
                    },
                    {
                        "username": "pranil517161",
                        "content": "I am using 2 loops thats O(N^2) TC. Anyone can suggest good approach?"
                    },
                    {
                        "username": "Ikshan_Bhardwaj",
                        "content": "Can someone please explain why I am getting a runtime error here?\\n\\n    string convert(string s, int numRows) {\\n        //simply just start counting numRows times from the present index, if present index exceeds then take the % value\\n\\n        string ans;\\n        int len=s.size();\\n        int k=0;\\n\\n        if(len<1 || len >1000 || numRows <1 || numRows>1000)\\n        {\\n            return \" \";\\n        }\\n\\n        for(int i=0 ; i<len ; i=(i+numRows+1)%(len))\\n        {\\n            if(i==len-1)\\n            {\\n                return ans;\\n            }\\n\\n            ans[k]=s[i];\\n            k++;\\n        }\\n        return ans;\\n}"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "string have s.length() to calculate size of string\\nyou are using s.size() which is used in vectors"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java Python C++ and C programming.\\n[https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html](https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html)"
                    },
                    {
                        "username": "utsav1123",
                        "content": "There is a testcase where array \\'s\\' contains a single character but numRow is more than 1.\\n\\nHow can someone distribute one character in more than one rows?? \\nDoesn\\'t make sense. \\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have completely solved the question with  runtime 15ms.  contact me for detailed solution,  at instagram (gautam_pahwa07).   or mail me at  pahwagautam786@gmail.com"
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "Man what the question says only god knows."
                    },
                    {
                        "username": "hybp",
                        "content": "A haahahahahah I wrote a program that output\\n\"P   A   H   N   \\\\nA P L S I I G \\\\nY   I   R\\\\n\"\\nfor test 1\\n\\n\"P    I    N    \\\\nA  L S  I G  \\\\nP    I\\\\n\"\\nfor test 2\\n\\n\"A\"\\nfor test 3,\\njust to realize it was all a waste of time"
                    }
                ]
            },
            {
                "id": 1748223,
                "content": [
                    {
                        "username": "kannan-ramesh",
                        "content": "why this code error?,,but no error in cpp please any one help...\\n\\nLine 11: error: array required, but String found\\n                arr[row++][col]=s[cur++];\\n                                 ^\\nLine 15: error: array required, but String found\\n                arr[row--][++col]=s[cur++];\\n                                   ^\\n2 errors\\nConsole\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        String arr[][]=new String[numRows][s.length()];\\n\\n        int row=0;\\n        int col=0;\\n        int cur=0;\\n\\n        while(cur<s.length()){\\n            while(row<numRows && cur<s.length()){\\n                arr[row++][col]=s[cur++];\\n            }\\n            row=Math.max(0,row-2);\\n            while(row>0 && cur<s.length()){\\n                arr[row--][++col]=s[cur++];\\n            }\\n            col++;\\n        }\\n\\n        String ans=\" \";\\n\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<s.length();j++){\\n                ans+=arr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "coder_Harsh",
                        "content": "Problem statement not clear!!!"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Am I the Only one who don\\'t understand  what is the required  ?\\nI see this question is not clear and missing details "
                    },
                    {
                        "username": "pablomariaarranzpou",
                        "content": "It\\'s like the words are readed going up un down starting going down and the a diagonal to the right. This Is done with the number of rows in input."
                    },
                    {
                        "username": "pranil517161",
                        "content": "I am using 2 loops thats O(N^2) TC. Anyone can suggest good approach?"
                    },
                    {
                        "username": "Ikshan_Bhardwaj",
                        "content": "Can someone please explain why I am getting a runtime error here?\\n\\n    string convert(string s, int numRows) {\\n        //simply just start counting numRows times from the present index, if present index exceeds then take the % value\\n\\n        string ans;\\n        int len=s.size();\\n        int k=0;\\n\\n        if(len<1 || len >1000 || numRows <1 || numRows>1000)\\n        {\\n            return \" \";\\n        }\\n\\n        for(int i=0 ; i<len ; i=(i+numRows+1)%(len))\\n        {\\n            if(i==len-1)\\n            {\\n                return ans;\\n            }\\n\\n            ans[k]=s[i];\\n            k++;\\n        }\\n        return ans;\\n}"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "string have s.length() to calculate size of string\\nyou are using s.size() which is used in vectors"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java Python C++ and C programming.\\n[https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html](https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html)"
                    },
                    {
                        "username": "utsav1123",
                        "content": "There is a testcase where array \\'s\\' contains a single character but numRow is more than 1.\\n\\nHow can someone distribute one character in more than one rows?? \\nDoesn\\'t make sense. \\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have completely solved the question with  runtime 15ms.  contact me for detailed solution,  at instagram (gautam_pahwa07).   or mail me at  pahwagautam786@gmail.com"
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "Man what the question says only god knows."
                    },
                    {
                        "username": "hybp",
                        "content": "A haahahahahah I wrote a program that output\\n\"P   A   H   N   \\\\nA P L S I I G \\\\nY   I   R\\\\n\"\\nfor test 1\\n\\n\"P    I    N    \\\\nA  L S  I G  \\\\nP    I\\\\n\"\\nfor test 2\\n\\n\"A\"\\nfor test 3,\\njust to realize it was all a waste of time"
                    }
                ]
            },
            {
                "id": 1742865,
                "content": [
                    {
                        "username": "kannan-ramesh",
                        "content": "why this code error?,,but no error in cpp please any one help...\\n\\nLine 11: error: array required, but String found\\n                arr[row++][col]=s[cur++];\\n                                 ^\\nLine 15: error: array required, but String found\\n                arr[row--][++col]=s[cur++];\\n                                   ^\\n2 errors\\nConsole\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        String arr[][]=new String[numRows][s.length()];\\n\\n        int row=0;\\n        int col=0;\\n        int cur=0;\\n\\n        while(cur<s.length()){\\n            while(row<numRows && cur<s.length()){\\n                arr[row++][col]=s[cur++];\\n            }\\n            row=Math.max(0,row-2);\\n            while(row>0 && cur<s.length()){\\n                arr[row--][++col]=s[cur++];\\n            }\\n            col++;\\n        }\\n\\n        String ans=\" \";\\n\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<s.length();j++){\\n                ans+=arr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "coder_Harsh",
                        "content": "Problem statement not clear!!!"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Am I the Only one who don\\'t understand  what is the required  ?\\nI see this question is not clear and missing details "
                    },
                    {
                        "username": "pablomariaarranzpou",
                        "content": "It\\'s like the words are readed going up un down starting going down and the a diagonal to the right. This Is done with the number of rows in input."
                    },
                    {
                        "username": "pranil517161",
                        "content": "I am using 2 loops thats O(N^2) TC. Anyone can suggest good approach?"
                    },
                    {
                        "username": "Ikshan_Bhardwaj",
                        "content": "Can someone please explain why I am getting a runtime error here?\\n\\n    string convert(string s, int numRows) {\\n        //simply just start counting numRows times from the present index, if present index exceeds then take the % value\\n\\n        string ans;\\n        int len=s.size();\\n        int k=0;\\n\\n        if(len<1 || len >1000 || numRows <1 || numRows>1000)\\n        {\\n            return \" \";\\n        }\\n\\n        for(int i=0 ; i<len ; i=(i+numRows+1)%(len))\\n        {\\n            if(i==len-1)\\n            {\\n                return ans;\\n            }\\n\\n            ans[k]=s[i];\\n            k++;\\n        }\\n        return ans;\\n}"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "string have s.length() to calculate size of string\\nyou are using s.size() which is used in vectors"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java Python C++ and C programming.\\n[https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html](https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html)"
                    },
                    {
                        "username": "utsav1123",
                        "content": "There is a testcase where array \\'s\\' contains a single character but numRow is more than 1.\\n\\nHow can someone distribute one character in more than one rows?? \\nDoesn\\'t make sense. \\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have completely solved the question with  runtime 15ms.  contact me for detailed solution,  at instagram (gautam_pahwa07).   or mail me at  pahwagautam786@gmail.com"
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "Man what the question says only god knows."
                    },
                    {
                        "username": "hybp",
                        "content": "A haahahahahah I wrote a program that output\\n\"P   A   H   N   \\\\nA P L S I I G \\\\nY   I   R\\\\n\"\\nfor test 1\\n\\n\"P    I    N    \\\\nA  L S  I G  \\\\nP    I\\\\n\"\\nfor test 2\\n\\n\"A\"\\nfor test 3,\\njust to realize it was all a waste of time"
                    }
                ]
            },
            {
                "id": 1739005,
                "content": [
                    {
                        "username": "kannan-ramesh",
                        "content": "why this code error?,,but no error in cpp please any one help...\\n\\nLine 11: error: array required, but String found\\n                arr[row++][col]=s[cur++];\\n                                 ^\\nLine 15: error: array required, but String found\\n                arr[row--][++col]=s[cur++];\\n                                   ^\\n2 errors\\nConsole\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        String arr[][]=new String[numRows][s.length()];\\n\\n        int row=0;\\n        int col=0;\\n        int cur=0;\\n\\n        while(cur<s.length()){\\n            while(row<numRows && cur<s.length()){\\n                arr[row++][col]=s[cur++];\\n            }\\n            row=Math.max(0,row-2);\\n            while(row>0 && cur<s.length()){\\n                arr[row--][++col]=s[cur++];\\n            }\\n            col++;\\n        }\\n\\n        String ans=\" \";\\n\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<s.length();j++){\\n                ans+=arr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "coder_Harsh",
                        "content": "Problem statement not clear!!!"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Am I the Only one who don\\'t understand  what is the required  ?\\nI see this question is not clear and missing details "
                    },
                    {
                        "username": "pablomariaarranzpou",
                        "content": "It\\'s like the words are readed going up un down starting going down and the a diagonal to the right. This Is done with the number of rows in input."
                    },
                    {
                        "username": "pranil517161",
                        "content": "I am using 2 loops thats O(N^2) TC. Anyone can suggest good approach?"
                    },
                    {
                        "username": "Ikshan_Bhardwaj",
                        "content": "Can someone please explain why I am getting a runtime error here?\\n\\n    string convert(string s, int numRows) {\\n        //simply just start counting numRows times from the present index, if present index exceeds then take the % value\\n\\n        string ans;\\n        int len=s.size();\\n        int k=0;\\n\\n        if(len<1 || len >1000 || numRows <1 || numRows>1000)\\n        {\\n            return \" \";\\n        }\\n\\n        for(int i=0 ; i<len ; i=(i+numRows+1)%(len))\\n        {\\n            if(i==len-1)\\n            {\\n                return ans;\\n            }\\n\\n            ans[k]=s[i];\\n            k++;\\n        }\\n        return ans;\\n}"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "string have s.length() to calculate size of string\\nyou are using s.size() which is used in vectors"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java Python C++ and C programming.\\n[https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html](https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html)"
                    },
                    {
                        "username": "utsav1123",
                        "content": "There is a testcase where array \\'s\\' contains a single character but numRow is more than 1.\\n\\nHow can someone distribute one character in more than one rows?? \\nDoesn\\'t make sense. \\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have completely solved the question with  runtime 15ms.  contact me for detailed solution,  at instagram (gautam_pahwa07).   or mail me at  pahwagautam786@gmail.com"
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "Man what the question says only god knows."
                    },
                    {
                        "username": "hybp",
                        "content": "A haahahahahah I wrote a program that output\\n\"P   A   H   N   \\\\nA P L S I I G \\\\nY   I   R\\\\n\"\\nfor test 1\\n\\n\"P    I    N    \\\\nA  L S  I G  \\\\nP    I\\\\n\"\\nfor test 2\\n\\n\"A\"\\nfor test 3,\\njust to realize it was all a waste of time"
                    }
                ]
            },
            {
                "id": 1738387,
                "content": [
                    {
                        "username": "kannan-ramesh",
                        "content": "why this code error?,,but no error in cpp please any one help...\\n\\nLine 11: error: array required, but String found\\n                arr[row++][col]=s[cur++];\\n                                 ^\\nLine 15: error: array required, but String found\\n                arr[row--][++col]=s[cur++];\\n                                   ^\\n2 errors\\nConsole\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        String arr[][]=new String[numRows][s.length()];\\n\\n        int row=0;\\n        int col=0;\\n        int cur=0;\\n\\n        while(cur<s.length()){\\n            while(row<numRows && cur<s.length()){\\n                arr[row++][col]=s[cur++];\\n            }\\n            row=Math.max(0,row-2);\\n            while(row>0 && cur<s.length()){\\n                arr[row--][++col]=s[cur++];\\n            }\\n            col++;\\n        }\\n\\n        String ans=\" \";\\n\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<s.length();j++){\\n                ans+=arr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "coder_Harsh",
                        "content": "Problem statement not clear!!!"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Am I the Only one who don\\'t understand  what is the required  ?\\nI see this question is not clear and missing details "
                    },
                    {
                        "username": "pablomariaarranzpou",
                        "content": "It\\'s like the words are readed going up un down starting going down and the a diagonal to the right. This Is done with the number of rows in input."
                    },
                    {
                        "username": "pranil517161",
                        "content": "I am using 2 loops thats O(N^2) TC. Anyone can suggest good approach?"
                    },
                    {
                        "username": "Ikshan_Bhardwaj",
                        "content": "Can someone please explain why I am getting a runtime error here?\\n\\n    string convert(string s, int numRows) {\\n        //simply just start counting numRows times from the present index, if present index exceeds then take the % value\\n\\n        string ans;\\n        int len=s.size();\\n        int k=0;\\n\\n        if(len<1 || len >1000 || numRows <1 || numRows>1000)\\n        {\\n            return \" \";\\n        }\\n\\n        for(int i=0 ; i<len ; i=(i+numRows+1)%(len))\\n        {\\n            if(i==len-1)\\n            {\\n                return ans;\\n            }\\n\\n            ans[k]=s[i];\\n            k++;\\n        }\\n        return ans;\\n}"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "string have s.length() to calculate size of string\\nyou are using s.size() which is used in vectors"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java Python C++ and C programming.\\n[https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html](https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html)"
                    },
                    {
                        "username": "utsav1123",
                        "content": "There is a testcase where array \\'s\\' contains a single character but numRow is more than 1.\\n\\nHow can someone distribute one character in more than one rows?? \\nDoesn\\'t make sense. \\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have completely solved the question with  runtime 15ms.  contact me for detailed solution,  at instagram (gautam_pahwa07).   or mail me at  pahwagautam786@gmail.com"
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "Man what the question says only god knows."
                    },
                    {
                        "username": "hybp",
                        "content": "A haahahahahah I wrote a program that output\\n\"P   A   H   N   \\\\nA P L S I I G \\\\nY   I   R\\\\n\"\\nfor test 1\\n\\n\"P    I    N    \\\\nA  L S  I G  \\\\nP    I\\\\n\"\\nfor test 2\\n\\n\"A\"\\nfor test 3,\\njust to realize it was all a waste of time"
                    }
                ]
            },
            {
                "id": 1735649,
                "content": [
                    {
                        "username": "kannan-ramesh",
                        "content": "why this code error?,,but no error in cpp please any one help...\\n\\nLine 11: error: array required, but String found\\n                arr[row++][col]=s[cur++];\\n                                 ^\\nLine 15: error: array required, but String found\\n                arr[row--][++col]=s[cur++];\\n                                   ^\\n2 errors\\nConsole\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        String arr[][]=new String[numRows][s.length()];\\n\\n        int row=0;\\n        int col=0;\\n        int cur=0;\\n\\n        while(cur<s.length()){\\n            while(row<numRows && cur<s.length()){\\n                arr[row++][col]=s[cur++];\\n            }\\n            row=Math.max(0,row-2);\\n            while(row>0 && cur<s.length()){\\n                arr[row--][++col]=s[cur++];\\n            }\\n            col++;\\n        }\\n\\n        String ans=\" \";\\n\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<s.length();j++){\\n                ans+=arr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "coder_Harsh",
                        "content": "Problem statement not clear!!!"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Am I the Only one who don\\'t understand  what is the required  ?\\nI see this question is not clear and missing details "
                    },
                    {
                        "username": "pablomariaarranzpou",
                        "content": "It\\'s like the words are readed going up un down starting going down and the a diagonal to the right. This Is done with the number of rows in input."
                    },
                    {
                        "username": "pranil517161",
                        "content": "I am using 2 loops thats O(N^2) TC. Anyone can suggest good approach?"
                    },
                    {
                        "username": "Ikshan_Bhardwaj",
                        "content": "Can someone please explain why I am getting a runtime error here?\\n\\n    string convert(string s, int numRows) {\\n        //simply just start counting numRows times from the present index, if present index exceeds then take the % value\\n\\n        string ans;\\n        int len=s.size();\\n        int k=0;\\n\\n        if(len<1 || len >1000 || numRows <1 || numRows>1000)\\n        {\\n            return \" \";\\n        }\\n\\n        for(int i=0 ; i<len ; i=(i+numRows+1)%(len))\\n        {\\n            if(i==len-1)\\n            {\\n                return ans;\\n            }\\n\\n            ans[k]=s[i];\\n            k++;\\n        }\\n        return ans;\\n}"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "string have s.length() to calculate size of string\\nyou are using s.size() which is used in vectors"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java Python C++ and C programming.\\n[https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html](https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html)"
                    },
                    {
                        "username": "utsav1123",
                        "content": "There is a testcase where array \\'s\\' contains a single character but numRow is more than 1.\\n\\nHow can someone distribute one character in more than one rows?? \\nDoesn\\'t make sense. \\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have completely solved the question with  runtime 15ms.  contact me for detailed solution,  at instagram (gautam_pahwa07).   or mail me at  pahwagautam786@gmail.com"
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "Man what the question says only god knows."
                    },
                    {
                        "username": "hybp",
                        "content": "A haahahahahah I wrote a program that output\\n\"P   A   H   N   \\\\nA P L S I I G \\\\nY   I   R\\\\n\"\\nfor test 1\\n\\n\"P    I    N    \\\\nA  L S  I G  \\\\nP    I\\\\n\"\\nfor test 2\\n\\n\"A\"\\nfor test 3,\\njust to realize it was all a waste of time"
                    }
                ]
            },
            {
                "id": 1724804,
                "content": [
                    {
                        "username": "kannan-ramesh",
                        "content": "why this code error?,,but no error in cpp please any one help...\\n\\nLine 11: error: array required, but String found\\n                arr[row++][col]=s[cur++];\\n                                 ^\\nLine 15: error: array required, but String found\\n                arr[row--][++col]=s[cur++];\\n                                   ^\\n2 errors\\nConsole\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        String arr[][]=new String[numRows][s.length()];\\n\\n        int row=0;\\n        int col=0;\\n        int cur=0;\\n\\n        while(cur<s.length()){\\n            while(row<numRows && cur<s.length()){\\n                arr[row++][col]=s[cur++];\\n            }\\n            row=Math.max(0,row-2);\\n            while(row>0 && cur<s.length()){\\n                arr[row--][++col]=s[cur++];\\n            }\\n            col++;\\n        }\\n\\n        String ans=\" \";\\n\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<s.length();j++){\\n                ans+=arr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "coder_Harsh",
                        "content": "Problem statement not clear!!!"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Am I the Only one who don\\'t understand  what is the required  ?\\nI see this question is not clear and missing details "
                    },
                    {
                        "username": "pablomariaarranzpou",
                        "content": "It\\'s like the words are readed going up un down starting going down and the a diagonal to the right. This Is done with the number of rows in input."
                    },
                    {
                        "username": "pranil517161",
                        "content": "I am using 2 loops thats O(N^2) TC. Anyone can suggest good approach?"
                    },
                    {
                        "username": "Ikshan_Bhardwaj",
                        "content": "Can someone please explain why I am getting a runtime error here?\\n\\n    string convert(string s, int numRows) {\\n        //simply just start counting numRows times from the present index, if present index exceeds then take the % value\\n\\n        string ans;\\n        int len=s.size();\\n        int k=0;\\n\\n        if(len<1 || len >1000 || numRows <1 || numRows>1000)\\n        {\\n            return \" \";\\n        }\\n\\n        for(int i=0 ; i<len ; i=(i+numRows+1)%(len))\\n        {\\n            if(i==len-1)\\n            {\\n                return ans;\\n            }\\n\\n            ans[k]=s[i];\\n            k++;\\n        }\\n        return ans;\\n}"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "string have s.length() to calculate size of string\\nyou are using s.size() which is used in vectors"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java Python C++ and C programming.\\n[https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html](https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html)"
                    },
                    {
                        "username": "utsav1123",
                        "content": "There is a testcase where array \\'s\\' contains a single character but numRow is more than 1.\\n\\nHow can someone distribute one character in more than one rows?? \\nDoesn\\'t make sense. \\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have completely solved the question with  runtime 15ms.  contact me for detailed solution,  at instagram (gautam_pahwa07).   or mail me at  pahwagautam786@gmail.com"
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "Man what the question says only god knows."
                    },
                    {
                        "username": "hybp",
                        "content": "A haahahahahah I wrote a program that output\\n\"P   A   H   N   \\\\nA P L S I I G \\\\nY   I   R\\\\n\"\\nfor test 1\\n\\n\"P    I    N    \\\\nA  L S  I G  \\\\nP    I\\\\n\"\\nfor test 2\\n\\n\"A\"\\nfor test 3,\\njust to realize it was all a waste of time"
                    }
                ]
            },
            {
                "id": 1722734,
                "content": [
                    {
                        "username": "kannan-ramesh",
                        "content": "why this code error?,,but no error in cpp please any one help...\\n\\nLine 11: error: array required, but String found\\n                arr[row++][col]=s[cur++];\\n                                 ^\\nLine 15: error: array required, but String found\\n                arr[row--][++col]=s[cur++];\\n                                   ^\\n2 errors\\nConsole\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        String arr[][]=new String[numRows][s.length()];\\n\\n        int row=0;\\n        int col=0;\\n        int cur=0;\\n\\n        while(cur<s.length()){\\n            while(row<numRows && cur<s.length()){\\n                arr[row++][col]=s[cur++];\\n            }\\n            row=Math.max(0,row-2);\\n            while(row>0 && cur<s.length()){\\n                arr[row--][++col]=s[cur++];\\n            }\\n            col++;\\n        }\\n\\n        String ans=\" \";\\n\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<s.length();j++){\\n                ans+=arr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "coder_Harsh",
                        "content": "Problem statement not clear!!!"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Am I the Only one who don\\'t understand  what is the required  ?\\nI see this question is not clear and missing details "
                    },
                    {
                        "username": "pablomariaarranzpou",
                        "content": "It\\'s like the words are readed going up un down starting going down and the a diagonal to the right. This Is done with the number of rows in input."
                    },
                    {
                        "username": "pranil517161",
                        "content": "I am using 2 loops thats O(N^2) TC. Anyone can suggest good approach?"
                    },
                    {
                        "username": "Ikshan_Bhardwaj",
                        "content": "Can someone please explain why I am getting a runtime error here?\\n\\n    string convert(string s, int numRows) {\\n        //simply just start counting numRows times from the present index, if present index exceeds then take the % value\\n\\n        string ans;\\n        int len=s.size();\\n        int k=0;\\n\\n        if(len<1 || len >1000 || numRows <1 || numRows>1000)\\n        {\\n            return \" \";\\n        }\\n\\n        for(int i=0 ; i<len ; i=(i+numRows+1)%(len))\\n        {\\n            if(i==len-1)\\n            {\\n                return ans;\\n            }\\n\\n            ans[k]=s[i];\\n            k++;\\n        }\\n        return ans;\\n}"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "string have s.length() to calculate size of string\\nyou are using s.size() which is used in vectors"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java Python C++ and C programming.\\n[https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html](https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html)"
                    },
                    {
                        "username": "utsav1123",
                        "content": "There is a testcase where array \\'s\\' contains a single character but numRow is more than 1.\\n\\nHow can someone distribute one character in more than one rows?? \\nDoesn\\'t make sense. \\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have completely solved the question with  runtime 15ms.  contact me for detailed solution,  at instagram (gautam_pahwa07).   or mail me at  pahwagautam786@gmail.com"
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "Man what the question says only god knows."
                    },
                    {
                        "username": "hybp",
                        "content": "A haahahahahah I wrote a program that output\\n\"P   A   H   N   \\\\nA P L S I I G \\\\nY   I   R\\\\n\"\\nfor test 1\\n\\n\"P    I    N    \\\\nA  L S  I G  \\\\nP    I\\\\n\"\\nfor test 2\\n\\n\"A\"\\nfor test 3,\\njust to realize it was all a waste of time"
                    }
                ]
            },
            {
                "id": 1721030,
                "content": [
                    {
                        "username": "kannan-ramesh",
                        "content": "why this code error?,,but no error in cpp please any one help...\\n\\nLine 11: error: array required, but String found\\n                arr[row++][col]=s[cur++];\\n                                 ^\\nLine 15: error: array required, but String found\\n                arr[row--][++col]=s[cur++];\\n                                   ^\\n2 errors\\nConsole\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        String arr[][]=new String[numRows][s.length()];\\n\\n        int row=0;\\n        int col=0;\\n        int cur=0;\\n\\n        while(cur<s.length()){\\n            while(row<numRows && cur<s.length()){\\n                arr[row++][col]=s[cur++];\\n            }\\n            row=Math.max(0,row-2);\\n            while(row>0 && cur<s.length()){\\n                arr[row--][++col]=s[cur++];\\n            }\\n            col++;\\n        }\\n\\n        String ans=\" \";\\n\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<s.length();j++){\\n                ans+=arr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "coder_Harsh",
                        "content": "Problem statement not clear!!!"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Am I the Only one who don\\'t understand  what is the required  ?\\nI see this question is not clear and missing details "
                    },
                    {
                        "username": "pablomariaarranzpou",
                        "content": "It\\'s like the words are readed going up un down starting going down and the a diagonal to the right. This Is done with the number of rows in input."
                    },
                    {
                        "username": "pranil517161",
                        "content": "I am using 2 loops thats O(N^2) TC. Anyone can suggest good approach?"
                    },
                    {
                        "username": "Ikshan_Bhardwaj",
                        "content": "Can someone please explain why I am getting a runtime error here?\\n\\n    string convert(string s, int numRows) {\\n        //simply just start counting numRows times from the present index, if present index exceeds then take the % value\\n\\n        string ans;\\n        int len=s.size();\\n        int k=0;\\n\\n        if(len<1 || len >1000 || numRows <1 || numRows>1000)\\n        {\\n            return \" \";\\n        }\\n\\n        for(int i=0 ; i<len ; i=(i+numRows+1)%(len))\\n        {\\n            if(i==len-1)\\n            {\\n                return ans;\\n            }\\n\\n            ans[k]=s[i];\\n            k++;\\n        }\\n        return ans;\\n}"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "string have s.length() to calculate size of string\\nyou are using s.size() which is used in vectors"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java Python C++ and C programming.\\n[https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html](https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html)"
                    },
                    {
                        "username": "utsav1123",
                        "content": "There is a testcase where array \\'s\\' contains a single character but numRow is more than 1.\\n\\nHow can someone distribute one character in more than one rows?? \\nDoesn\\'t make sense. \\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have completely solved the question with  runtime 15ms.  contact me for detailed solution,  at instagram (gautam_pahwa07).   or mail me at  pahwagautam786@gmail.com"
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "Man what the question says only god knows."
                    },
                    {
                        "username": "hybp",
                        "content": "A haahahahahah I wrote a program that output\\n\"P   A   H   N   \\\\nA P L S I I G \\\\nY   I   R\\\\n\"\\nfor test 1\\n\\n\"P    I    N    \\\\nA  L S  I G  \\\\nP    I\\\\n\"\\nfor test 2\\n\\n\"A\"\\nfor test 3,\\njust to realize it was all a waste of time"
                    }
                ]
            },
            {
                "id": 1716133,
                "content": [
                    {
                        "username": "kannan-ramesh",
                        "content": "why this code error?,,but no error in cpp please any one help...\\n\\nLine 11: error: array required, but String found\\n                arr[row++][col]=s[cur++];\\n                                 ^\\nLine 15: error: array required, but String found\\n                arr[row--][++col]=s[cur++];\\n                                   ^\\n2 errors\\nConsole\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        String arr[][]=new String[numRows][s.length()];\\n\\n        int row=0;\\n        int col=0;\\n        int cur=0;\\n\\n        while(cur<s.length()){\\n            while(row<numRows && cur<s.length()){\\n                arr[row++][col]=s[cur++];\\n            }\\n            row=Math.max(0,row-2);\\n            while(row>0 && cur<s.length()){\\n                arr[row--][++col]=s[cur++];\\n            }\\n            col++;\\n        }\\n\\n        String ans=\" \";\\n\\n        for(int i=0;i<numRows;i++){\\n            for(int j=0;j<s.length();j++){\\n                ans+=arr[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "coder_Harsh",
                        "content": "Problem statement not clear!!!"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Am I the Only one who don\\'t understand  what is the required  ?\\nI see this question is not clear and missing details "
                    },
                    {
                        "username": "pablomariaarranzpou",
                        "content": "It\\'s like the words are readed going up un down starting going down and the a diagonal to the right. This Is done with the number of rows in input."
                    },
                    {
                        "username": "pranil517161",
                        "content": "I am using 2 loops thats O(N^2) TC. Anyone can suggest good approach?"
                    },
                    {
                        "username": "Ikshan_Bhardwaj",
                        "content": "Can someone please explain why I am getting a runtime error here?\\n\\n    string convert(string s, int numRows) {\\n        //simply just start counting numRows times from the present index, if present index exceeds then take the % value\\n\\n        string ans;\\n        int len=s.size();\\n        int k=0;\\n\\n        if(len<1 || len >1000 || numRows <1 || numRows>1000)\\n        {\\n            return \" \";\\n        }\\n\\n        for(int i=0 ; i<len ; i=(i+numRows+1)%(len))\\n        {\\n            if(i==len-1)\\n            {\\n                return ans;\\n            }\\n\\n            ans[k]=s[i];\\n            k++;\\n        }\\n        return ans;\\n}"
                    },
                    {
                        "username": "bhanutechie",
                        "content": "string have s.length() to calculate size of string\\nyou are using s.size() which is used in vectors"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java Python C++ and C programming.\\n[https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html](https://thecscience.com/leetcode-zigzag-conversion-problem-solution.html)"
                    },
                    {
                        "username": "utsav1123",
                        "content": "There is a testcase where array \\'s\\' contains a single character but numRow is more than 1.\\n\\nHow can someone distribute one character in more than one rows?? \\nDoesn\\'t make sense. \\n"
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have completely solved the question with  runtime 15ms.  contact me for detailed solution,  at instagram (gautam_pahwa07).   or mail me at  pahwagautam786@gmail.com"
                    },
                    {
                        "username": "rohitmondal2003",
                        "content": "Man what the question says only god knows."
                    },
                    {
                        "username": "hybp",
                        "content": "A haahahahahah I wrote a program that output\\n\"P   A   H   N   \\\\nA P L S I I G \\\\nY   I   R\\\\n\"\\nfor test 1\\n\\n\"P    I    N    \\\\nA  L S  I G  \\\\nP    I\\\\n\"\\nfor test 2\\n\\n\"A\"\\nfor test 3,\\njust to realize it was all a waste of time"
                    }
                ]
            },
            {
                "id": 1715460,
                "content": [
                    {
                        "username": "user3278TD",
                        "content": "I fail to understand why you couldn\\'t just post the picture from the solution as an example, the problem would\\'ve been a million times easier to understand than the given which makes absolutely 0 sense."
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "I didn\\'t get the idea of the question, it is so mysterious the is not enough explanation about what the output of the question should be and what is the logic of this question I hope someone can give more details or put it in a simple way."
                    },
                    {
                        "username": "Nitishl",
                        "content": "\\nJava Solution -- Can someone explain why my solution isn\\'t working--??\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        int start=0,diffcharcters=2*(numRows-1);\\n        int i=0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i = 0;i<numRows;++i){\\n           start = i;\\n           while(start<s.length())\\n           {  \\n                sb.append(start);\\n               if(i!=0 && i!=numRows-1){\\n                   start += diffcharcters-2*i;\\n               }\\n               else{\\n                   start += diffcharcters;\\n               }\\n           }\\n        }\\n        return sb.toString();\\n    }\\n}\\n"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Such a time waste question. What concept is this question testing at all?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "Animated Description would be nice too"
                    },
                    {
                        "username": "MuftawoOmar",
                        "content": "What is this ??? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html)"
                    },
                    {
                        "username": "fahdrafi",
                        "content": "What does an input like this mean for number or rows?\\n\\nFirst line:\\n\"Apalindromeisaword,phrase,number,orothersequenceofunitsthatcanbereadthesamewayineitherdirection,withgeneralallowancesforadjustmentstopunctuationandworddividers.\"\\n\\nSecond line:\\n\\' +\\n\\nThird line:\\n  \\'3"
                    },
                    {
                        "username": "Alok5102R",
                        "content": "Many people are confused about Rows=2:\n\n-> Let, s = PAYPALIS  and Rows=2\n\nP Y A I \nA P L S\n\nOutput : PYAIAPLS\n\n-> Let, s = PAYPALIS  and Rows=1\n\nP A Y P A L I S\n\nOutput : PAYPALIS\n\nHope it'll help you guys!!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    }
                ]
            },
            {
                "id": 1713523,
                "content": [
                    {
                        "username": "user3278TD",
                        "content": "I fail to understand why you couldn\\'t just post the picture from the solution as an example, the problem would\\'ve been a million times easier to understand than the given which makes absolutely 0 sense."
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "I didn\\'t get the idea of the question, it is so mysterious the is not enough explanation about what the output of the question should be and what is the logic of this question I hope someone can give more details or put it in a simple way."
                    },
                    {
                        "username": "Nitishl",
                        "content": "\\nJava Solution -- Can someone explain why my solution isn\\'t working--??\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        int start=0,diffcharcters=2*(numRows-1);\\n        int i=0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i = 0;i<numRows;++i){\\n           start = i;\\n           while(start<s.length())\\n           {  \\n                sb.append(start);\\n               if(i!=0 && i!=numRows-1){\\n                   start += diffcharcters-2*i;\\n               }\\n               else{\\n                   start += diffcharcters;\\n               }\\n           }\\n        }\\n        return sb.toString();\\n    }\\n}\\n"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Such a time waste question. What concept is this question testing at all?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "Animated Description would be nice too"
                    },
                    {
                        "username": "MuftawoOmar",
                        "content": "What is this ??? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html)"
                    },
                    {
                        "username": "fahdrafi",
                        "content": "What does an input like this mean for number or rows?\\n\\nFirst line:\\n\"Apalindromeisaword,phrase,number,orothersequenceofunitsthatcanbereadthesamewayineitherdirection,withgeneralallowancesforadjustmentstopunctuationandworddividers.\"\\n\\nSecond line:\\n\\' +\\n\\nThird line:\\n  \\'3"
                    },
                    {
                        "username": "Alok5102R",
                        "content": "Many people are confused about Rows=2:\n\n-> Let, s = PAYPALIS  and Rows=2\n\nP Y A I \nA P L S\n\nOutput : PYAIAPLS\n\n-> Let, s = PAYPALIS  and Rows=1\n\nP A Y P A L I S\n\nOutput : PAYPALIS\n\nHope it'll help you guys!!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    }
                ]
            },
            {
                "id": 1708245,
                "content": [
                    {
                        "username": "user3278TD",
                        "content": "I fail to understand why you couldn\\'t just post the picture from the solution as an example, the problem would\\'ve been a million times easier to understand than the given which makes absolutely 0 sense."
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "I didn\\'t get the idea of the question, it is so mysterious the is not enough explanation about what the output of the question should be and what is the logic of this question I hope someone can give more details or put it in a simple way."
                    },
                    {
                        "username": "Nitishl",
                        "content": "\\nJava Solution -- Can someone explain why my solution isn\\'t working--??\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        int start=0,diffcharcters=2*(numRows-1);\\n        int i=0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i = 0;i<numRows;++i){\\n           start = i;\\n           while(start<s.length())\\n           {  \\n                sb.append(start);\\n               if(i!=0 && i!=numRows-1){\\n                   start += diffcharcters-2*i;\\n               }\\n               else{\\n                   start += diffcharcters;\\n               }\\n           }\\n        }\\n        return sb.toString();\\n    }\\n}\\n"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Such a time waste question. What concept is this question testing at all?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "Animated Description would be nice too"
                    },
                    {
                        "username": "MuftawoOmar",
                        "content": "What is this ??? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html)"
                    },
                    {
                        "username": "fahdrafi",
                        "content": "What does an input like this mean for number or rows?\\n\\nFirst line:\\n\"Apalindromeisaword,phrase,number,orothersequenceofunitsthatcanbereadthesamewayineitherdirection,withgeneralallowancesforadjustmentstopunctuationandworddividers.\"\\n\\nSecond line:\\n\\' +\\n\\nThird line:\\n  \\'3"
                    },
                    {
                        "username": "Alok5102R",
                        "content": "Many people are confused about Rows=2:\n\n-> Let, s = PAYPALIS  and Rows=2\n\nP Y A I \nA P L S\n\nOutput : PYAIAPLS\n\n-> Let, s = PAYPALIS  and Rows=1\n\nP A Y P A L I S\n\nOutput : PAYPALIS\n\nHope it'll help you guys!!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    }
                ]
            },
            {
                "id": 1704464,
                "content": [
                    {
                        "username": "user3278TD",
                        "content": "I fail to understand why you couldn\\'t just post the picture from the solution as an example, the problem would\\'ve been a million times easier to understand than the given which makes absolutely 0 sense."
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "I didn\\'t get the idea of the question, it is so mysterious the is not enough explanation about what the output of the question should be and what is the logic of this question I hope someone can give more details or put it in a simple way."
                    },
                    {
                        "username": "Nitishl",
                        "content": "\\nJava Solution -- Can someone explain why my solution isn\\'t working--??\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        int start=0,diffcharcters=2*(numRows-1);\\n        int i=0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i = 0;i<numRows;++i){\\n           start = i;\\n           while(start<s.length())\\n           {  \\n                sb.append(start);\\n               if(i!=0 && i!=numRows-1){\\n                   start += diffcharcters-2*i;\\n               }\\n               else{\\n                   start += diffcharcters;\\n               }\\n           }\\n        }\\n        return sb.toString();\\n    }\\n}\\n"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Such a time waste question. What concept is this question testing at all?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "Animated Description would be nice too"
                    },
                    {
                        "username": "MuftawoOmar",
                        "content": "What is this ??? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html)"
                    },
                    {
                        "username": "fahdrafi",
                        "content": "What does an input like this mean for number or rows?\\n\\nFirst line:\\n\"Apalindromeisaword,phrase,number,orothersequenceofunitsthatcanbereadthesamewayineitherdirection,withgeneralallowancesforadjustmentstopunctuationandworddividers.\"\\n\\nSecond line:\\n\\' +\\n\\nThird line:\\n  \\'3"
                    },
                    {
                        "username": "Alok5102R",
                        "content": "Many people are confused about Rows=2:\n\n-> Let, s = PAYPALIS  and Rows=2\n\nP Y A I \nA P L S\n\nOutput : PYAIAPLS\n\n-> Let, s = PAYPALIS  and Rows=1\n\nP A Y P A L I S\n\nOutput : PAYPALIS\n\nHope it'll help you guys!!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    }
                ]
            },
            {
                "id": 1701763,
                "content": [
                    {
                        "username": "user3278TD",
                        "content": "I fail to understand why you couldn\\'t just post the picture from the solution as an example, the problem would\\'ve been a million times easier to understand than the given which makes absolutely 0 sense."
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "I didn\\'t get the idea of the question, it is so mysterious the is not enough explanation about what the output of the question should be and what is the logic of this question I hope someone can give more details or put it in a simple way."
                    },
                    {
                        "username": "Nitishl",
                        "content": "\\nJava Solution -- Can someone explain why my solution isn\\'t working--??\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        int start=0,diffcharcters=2*(numRows-1);\\n        int i=0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i = 0;i<numRows;++i){\\n           start = i;\\n           while(start<s.length())\\n           {  \\n                sb.append(start);\\n               if(i!=0 && i!=numRows-1){\\n                   start += diffcharcters-2*i;\\n               }\\n               else{\\n                   start += diffcharcters;\\n               }\\n           }\\n        }\\n        return sb.toString();\\n    }\\n}\\n"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Such a time waste question. What concept is this question testing at all?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "Animated Description would be nice too"
                    },
                    {
                        "username": "MuftawoOmar",
                        "content": "What is this ??? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html)"
                    },
                    {
                        "username": "fahdrafi",
                        "content": "What does an input like this mean for number or rows?\\n\\nFirst line:\\n\"Apalindromeisaword,phrase,number,orothersequenceofunitsthatcanbereadthesamewayineitherdirection,withgeneralallowancesforadjustmentstopunctuationandworddividers.\"\\n\\nSecond line:\\n\\' +\\n\\nThird line:\\n  \\'3"
                    },
                    {
                        "username": "Alok5102R",
                        "content": "Many people are confused about Rows=2:\n\n-> Let, s = PAYPALIS  and Rows=2\n\nP Y A I \nA P L S\n\nOutput : PYAIAPLS\n\n-> Let, s = PAYPALIS  and Rows=1\n\nP A Y P A L I S\n\nOutput : PAYPALIS\n\nHope it'll help you guys!!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    }
                ]
            },
            {
                "id": 1671786,
                "content": [
                    {
                        "username": "user3278TD",
                        "content": "I fail to understand why you couldn\\'t just post the picture from the solution as an example, the problem would\\'ve been a million times easier to understand than the given which makes absolutely 0 sense."
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "I didn\\'t get the idea of the question, it is so mysterious the is not enough explanation about what the output of the question should be and what is the logic of this question I hope someone can give more details or put it in a simple way."
                    },
                    {
                        "username": "Nitishl",
                        "content": "\\nJava Solution -- Can someone explain why my solution isn\\'t working--??\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        int start=0,diffcharcters=2*(numRows-1);\\n        int i=0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i = 0;i<numRows;++i){\\n           start = i;\\n           while(start<s.length())\\n           {  \\n                sb.append(start);\\n               if(i!=0 && i!=numRows-1){\\n                   start += diffcharcters-2*i;\\n               }\\n               else{\\n                   start += diffcharcters;\\n               }\\n           }\\n        }\\n        return sb.toString();\\n    }\\n}\\n"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Such a time waste question. What concept is this question testing at all?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "Animated Description would be nice too"
                    },
                    {
                        "username": "MuftawoOmar",
                        "content": "What is this ??? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html)"
                    },
                    {
                        "username": "fahdrafi",
                        "content": "What does an input like this mean for number or rows?\\n\\nFirst line:\\n\"Apalindromeisaword,phrase,number,orothersequenceofunitsthatcanbereadthesamewayineitherdirection,withgeneralallowancesforadjustmentstopunctuationandworddividers.\"\\n\\nSecond line:\\n\\' +\\n\\nThird line:\\n  \\'3"
                    },
                    {
                        "username": "Alok5102R",
                        "content": "Many people are confused about Rows=2:\n\n-> Let, s = PAYPALIS  and Rows=2\n\nP Y A I \nA P L S\n\nOutput : PYAIAPLS\n\n-> Let, s = PAYPALIS  and Rows=1\n\nP A Y P A L I S\n\nOutput : PAYPALIS\n\nHope it'll help you guys!!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    }
                ]
            },
            {
                "id": 1671232,
                "content": [
                    {
                        "username": "user3278TD",
                        "content": "I fail to understand why you couldn\\'t just post the picture from the solution as an example, the problem would\\'ve been a million times easier to understand than the given which makes absolutely 0 sense."
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "I didn\\'t get the idea of the question, it is so mysterious the is not enough explanation about what the output of the question should be and what is the logic of this question I hope someone can give more details or put it in a simple way."
                    },
                    {
                        "username": "Nitishl",
                        "content": "\\nJava Solution -- Can someone explain why my solution isn\\'t working--??\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        int start=0,diffcharcters=2*(numRows-1);\\n        int i=0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i = 0;i<numRows;++i){\\n           start = i;\\n           while(start<s.length())\\n           {  \\n                sb.append(start);\\n               if(i!=0 && i!=numRows-1){\\n                   start += diffcharcters-2*i;\\n               }\\n               else{\\n                   start += diffcharcters;\\n               }\\n           }\\n        }\\n        return sb.toString();\\n    }\\n}\\n"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Such a time waste question. What concept is this question testing at all?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "Animated Description would be nice too"
                    },
                    {
                        "username": "MuftawoOmar",
                        "content": "What is this ??? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html)"
                    },
                    {
                        "username": "fahdrafi",
                        "content": "What does an input like this mean for number or rows?\\n\\nFirst line:\\n\"Apalindromeisaword,phrase,number,orothersequenceofunitsthatcanbereadthesamewayineitherdirection,withgeneralallowancesforadjustmentstopunctuationandworddividers.\"\\n\\nSecond line:\\n\\' +\\n\\nThird line:\\n  \\'3"
                    },
                    {
                        "username": "Alok5102R",
                        "content": "Many people are confused about Rows=2:\n\n-> Let, s = PAYPALIS  and Rows=2\n\nP Y A I \nA P L S\n\nOutput : PYAIAPLS\n\n-> Let, s = PAYPALIS  and Rows=1\n\nP A Y P A L I S\n\nOutput : PAYPALIS\n\nHope it'll help you guys!!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    }
                ]
            },
            {
                "id": 1648014,
                "content": [
                    {
                        "username": "user3278TD",
                        "content": "I fail to understand why you couldn\\'t just post the picture from the solution as an example, the problem would\\'ve been a million times easier to understand than the given which makes absolutely 0 sense."
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "I didn\\'t get the idea of the question, it is so mysterious the is not enough explanation about what the output of the question should be and what is the logic of this question I hope someone can give more details or put it in a simple way."
                    },
                    {
                        "username": "Nitishl",
                        "content": "\\nJava Solution -- Can someone explain why my solution isn\\'t working--??\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        int start=0,diffcharcters=2*(numRows-1);\\n        int i=0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i = 0;i<numRows;++i){\\n           start = i;\\n           while(start<s.length())\\n           {  \\n                sb.append(start);\\n               if(i!=0 && i!=numRows-1){\\n                   start += diffcharcters-2*i;\\n               }\\n               else{\\n                   start += diffcharcters;\\n               }\\n           }\\n        }\\n        return sb.toString();\\n    }\\n}\\n"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Such a time waste question. What concept is this question testing at all?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "Animated Description would be nice too"
                    },
                    {
                        "username": "MuftawoOmar",
                        "content": "What is this ??? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html)"
                    },
                    {
                        "username": "fahdrafi",
                        "content": "What does an input like this mean for number or rows?\\n\\nFirst line:\\n\"Apalindromeisaword,phrase,number,orothersequenceofunitsthatcanbereadthesamewayineitherdirection,withgeneralallowancesforadjustmentstopunctuationandworddividers.\"\\n\\nSecond line:\\n\\' +\\n\\nThird line:\\n  \\'3"
                    },
                    {
                        "username": "Alok5102R",
                        "content": "Many people are confused about Rows=2:\n\n-> Let, s = PAYPALIS  and Rows=2\n\nP Y A I \nA P L S\n\nOutput : PYAIAPLS\n\n-> Let, s = PAYPALIS  and Rows=1\n\nP A Y P A L I S\n\nOutput : PAYPALIS\n\nHope it'll help you guys!!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    }
                ]
            },
            {
                "id": 1641202,
                "content": [
                    {
                        "username": "user3278TD",
                        "content": "I fail to understand why you couldn\\'t just post the picture from the solution as an example, the problem would\\'ve been a million times easier to understand than the given which makes absolutely 0 sense."
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "I didn\\'t get the idea of the question, it is so mysterious the is not enough explanation about what the output of the question should be and what is the logic of this question I hope someone can give more details or put it in a simple way."
                    },
                    {
                        "username": "Nitishl",
                        "content": "\\nJava Solution -- Can someone explain why my solution isn\\'t working--??\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        int start=0,diffcharcters=2*(numRows-1);\\n        int i=0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i = 0;i<numRows;++i){\\n           start = i;\\n           while(start<s.length())\\n           {  \\n                sb.append(start);\\n               if(i!=0 && i!=numRows-1){\\n                   start += diffcharcters-2*i;\\n               }\\n               else{\\n                   start += diffcharcters;\\n               }\\n           }\\n        }\\n        return sb.toString();\\n    }\\n}\\n"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Such a time waste question. What concept is this question testing at all?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "Animated Description would be nice too"
                    },
                    {
                        "username": "MuftawoOmar",
                        "content": "What is this ??? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html)"
                    },
                    {
                        "username": "fahdrafi",
                        "content": "What does an input like this mean for number or rows?\\n\\nFirst line:\\n\"Apalindromeisaword,phrase,number,orothersequenceofunitsthatcanbereadthesamewayineitherdirection,withgeneralallowancesforadjustmentstopunctuationandworddividers.\"\\n\\nSecond line:\\n\\' +\\n\\nThird line:\\n  \\'3"
                    },
                    {
                        "username": "Alok5102R",
                        "content": "Many people are confused about Rows=2:\n\n-> Let, s = PAYPALIS  and Rows=2\n\nP Y A I \nA P L S\n\nOutput : PYAIAPLS\n\n-> Let, s = PAYPALIS  and Rows=1\n\nP A Y P A L I S\n\nOutput : PAYPALIS\n\nHope it'll help you guys!!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    }
                ]
            },
            {
                "id": 1576451,
                "content": [
                    {
                        "username": "user3278TD",
                        "content": "I fail to understand why you couldn\\'t just post the picture from the solution as an example, the problem would\\'ve been a million times easier to understand than the given which makes absolutely 0 sense."
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "I didn\\'t get the idea of the question, it is so mysterious the is not enough explanation about what the output of the question should be and what is the logic of this question I hope someone can give more details or put it in a simple way."
                    },
                    {
                        "username": "Nitishl",
                        "content": "\\nJava Solution -- Can someone explain why my solution isn\\'t working--??\\n\\nclass Solution {\\n    public String convert(String s, int numRows) {\\n        int start=0,diffcharcters=2*(numRows-1);\\n        int i=0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i = 0;i<numRows;++i){\\n           start = i;\\n           while(start<s.length())\\n           {  \\n                sb.append(start);\\n               if(i!=0 && i!=numRows-1){\\n                   start += diffcharcters-2*i;\\n               }\\n               else{\\n                   start += diffcharcters;\\n               }\\n           }\\n        }\\n        return sb.toString();\\n    }\\n}\\n"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Such a time waste question. What concept is this question testing at all?"
                    },
                    {
                        "username": "Bobzero",
                        "content": "Animated Description would be nice too"
                    },
                    {
                        "username": "MuftawoOmar",
                        "content": "What is this ??? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-zigzag-problem-solution.html)"
                    },
                    {
                        "username": "fahdrafi",
                        "content": "What does an input like this mean for number or rows?\\n\\nFirst line:\\n\"Apalindromeisaword,phrase,number,orothersequenceofunitsthatcanbereadthesamewayineitherdirection,withgeneralallowancesforadjustmentstopunctuationandworddividers.\"\\n\\nSecond line:\\n\\' +\\n\\nThird line:\\n  \\'3"
                    },
                    {
                        "username": "Alok5102R",
                        "content": "Many people are confused about Rows=2:\n\n-> Let, s = PAYPALIS  and Rows=2\n\nP Y A I \nA P L S\n\nOutput : PYAIAPLS\n\n-> Let, s = PAYPALIS  and Rows=1\n\nP A Y P A L I S\n\nOutput : PAYPALIS\n\nHope it'll help you guys!!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/zigzag-conversion-leetcode-solutions/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Construct Binary Tree from Inorder and Postorder Traversal",
        "question_content": "<p>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> inorder = [-1], postorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>\n\t<li><code>postorder.length == inorder.length</code></li>\n\t<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>\n\t<li><code>inorder</code> and <code>postorder</code> consist of <strong>unique</strong> values.</li>\n\t<li>Each value of <code>postorder</code> also appears in <code>inorder</code>.</li>\n\t<li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li>\n\t<li><code>postorder</code> is <strong>guaranteed</strong> to be the postorder traversal of the tree.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 221681,
                "title": "a-better-python-solution",
                "content": "Here I copied the previous top voted Python solution:\\n```\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        if not inorder or not postorder:\\n            return None\\n        \\n        root = TreeNode(postorder.pop())\\n        inorderIndex = inorder.index(root.val) # Line A\\n\\n        root.right = self.buildTree(inorder[inorderIndex+1:], postorder) # Line B\\n        root.left = self.buildTree(inorder[:inorderIndex], postorder) # Line C\\n\\n        return root\\n```\\n\\nThe code is clean and short. However, if you give this implementation during an interview, there is a good chance you will be asked, \"can you improve/optimize your solution?\"\\n\\nWhy? Take a look at Line A, Line B and Line C.\\nLine A takes O(N) time.\\nLine B and C takes O(N) time and extra space.\\nThus, the overall running time and extra space is O(N^2).\\nSo this implementation has a very bad performance, and you can avoid it.\\n\\nHere is my solution which has O(N) time and extra space.\\n```\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        map_inorder = {}\\n        for i, val in enumerate(inorder): map_inorder[val] = i\\n        def recur(low, high):\\n            if low > high: return None\\n            x = TreeNode(postorder.pop())\\n            mid = map_inorder[x.val]\\n            x.right = recur(mid+1, high)\\n            x.left = recur(low, mid-1)\\n            return x\\n        return recur(0, len(inorder)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        if not inorder or not postorder:\\n            return None\\n        \\n        root = TreeNode(postorder.pop())\\n        inorderIndex = inorder.index(root.val) # Line A\\n\\n        root.right = self.buildTree(inorder[inorderIndex+1:], postorder) # Line B\\n        root.left = self.buildTree(inorder[:inorderIndex], postorder) # Line C\\n\\n        return root\\n```\n```\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        map_inorder = {}\\n        for i, val in enumerate(inorder): map_inorder[val] = i\\n        def recur(low, high):\\n            if low > high: return None\\n            x = TreeNode(postorder.pop())\\n            mid = map_inorder[x.val]\\n            x.right = recur(mid+1, high)\\n            x.left = recur(low, mid-1)\\n            return x\\n        return recur(0, len(inorder)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758462,
                "title": "c-detail-explain-diagram",
                "content": "The Idea is As They Given us ```Inorder and Postorder```\\n\\n \\xA0 \\xA0as we Know Inorder Fallow --> ```Left_subtree => Root_Node => Right_subtree ``` Traverse\\n \\xA0 \\xA0ans \\xA0  Postorder Fallow --> ```Left_subtree => Right_subtree =>Root_Node ```traverse\\n    using Postorder_array We can Find Root_Node Which always lay in Postorder_array last Possition\\n    After Finding That Root_Node ,First we are going to divide Inorder_array Into Two Part  and Postorder  Array \\n    into Two part .\\n\\n    Then We are going to use Both of the arrays left part to Figur Out Left_subtree\\n                         and Both of the arraysRigth Part to Figur out Right_subtree\\n\\n    We are going to recursively do so until One Of the array dose not got empty\\n\\nLet\\'s take an Example \\n```\\n    inorder   = [4 2 5 1 6 3 7]\\n    postorder = [4 5 2 6 7 3 1]\\n\\n    So root would be 1 here and Left array which lay left of 1 is [4 2 5] and Right of 1 is [6 3 7]\\n    so left_inorder_array =  [4 2 5] and right_inorder_arry = [6 3 7]\\n\\n    using 6 [ which is just rigth of 1] we are going to devide Postorder_array into two part\\n    [4 5 2] and [6 7 3]\\n\\n\\n    1st Phase=>        \\n\\t                   1\\n\\n                   /        \\\\\\n\\n                [4 2 5]   [6 3 7]       <= inorder array\\n                [4 5 2]   [6 7 3]       <= postorder array\\n\\nNow we have new freash problem like need to make tree by using inorder = [4 2 5] && postorder =  [4 5 2] for left subtree \\nAND inorder = [6 3 7] && postorder = [6 7 3] for right  subtree \\n**now same process we need to do again and again  until One Of the array dose not got empty\\nRest of the Process show in a diagram Form :)\\n\\n    2nd Phase =>\\n                           1\\n\\n                      /        \\\\\\n                     2          3\\n                [4]    [5]   [6]   [7]       <= inorder array\\n                [4]    [5]   [6]   [7]       <= postorder array\\n\\n\\n3rd Phase =>  \\n\\t             1\\n\\n               /    \\\\\\n              2      3\\n \\n            /  \\\\    /  \\\\             <==== Answer\\n \\n           4    5  6    7 \\n```\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode *Tree(vector<int>& in, int x, int y,vector<int>& po,int a,int b){\\n        if(x > y || a > b)return nullptr;\\n        TreeNode *node = new TreeNode(po[b]);\\n        int SI = x;  \\n        while(node->val != in[SI])SI++;\\n        node->left  = Tree(in,x,SI-1,po,a,a+SI-x-1);\\n        node->right = Tree(in,SI+1,y,po,a+SI-x,b-1);\\n        return node;\\n    }\\n    TreeNode* buildTree(vector<int>& in, vector<int>& po){\\n        return Tree(in,0,in.size()-1,po,0,po.size()-1);\\n    }\\n};\\n```\\nIf You Really Like It please **upvote**\\nAny doubt Comments Bellow\\n**happy Coding :)**",
                "solutionTags": [],
                "code": "```Inorder and Postorder```\n```Left_subtree => Root_Node => Right_subtree ```\n```Left_subtree => Right_subtree =>Root_Node ```\n```\\n    inorder   = [4 2 5 1 6 3 7]\\n    postorder = [4 5 2 6 7 3 1]\\n\\n    So root would be 1 here and Left array which lay left of 1 is [4 2 5] and Right of 1 is [6 3 7]\\n    so left_inorder_array =  [4 2 5] and right_inorder_arry = [6 3 7]\\n\\n    using 6 [ which is just rigth of 1] we are going to devide Postorder_array into two part\\n    [4 5 2] and [6 7 3]\\n\\n\\n    1st Phase=>        \\n\\t                   1\\n\\n                   /        \\\\\\n\\n                [4 2 5]   [6 3 7]       <= inorder array\\n                [4 5 2]   [6 7 3]       <= postorder array\\n\\nNow we have new freash problem like need to make tree by using inorder = [4 2 5] && postorder =  [4 5 2] for left subtree \\nAND inorder = [6 3 7] && postorder = [6 7 3] for right  subtree \\n**now same process we need to do again and again  until One Of the array dose not got empty\\nRest of the Process show in a diagram Form :)\\n\\n    2nd Phase =>\\n                           1\\n\\n                      /        \\\\\\n                     2          3\\n                [4]    [5]   [6]   [7]       <= inorder array\\n                [4]    [5]   [6]   [7]       <= postorder array\\n\\n\\n3rd Phase =>  \\n\\t             1\\n\\n               /    \\\\\\n              2      3\\n \\n            /  \\\\    /  \\\\             <==== Answer\\n \\n           4    5  6    7 \\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode *Tree(vector<int>& in, int x, int y,vector<int>& po,int a,int b){\\n        if(x > y || a > b)return nullptr;\\n        TreeNode *node = new TreeNode(po[b]);\\n        int SI = x;  \\n        while(node->val != in[SI])SI++;\\n        node->left  = Tree(in,x,SI-1,po,a,a+SI-x-1);\\n        node->right = Tree(in,SI+1,y,po,a+SI-x,b-1);\\n        return node;\\n    }\\n    TreeNode* buildTree(vector<int>& in, vector<int>& po){\\n        return Tree(in,0,in.size()-1,po,0,po.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589310,
                "title": "c-python-2-simple-solutions-w-images-and-detailed-explanation-recursion-hashmap",
                "content": "\\u2714\\uFE0F ***Solution - I (Recursive)***\\n\\nFirst, we need to observe that we cant form exact binary tree with only 1 traversal. \\n* For eg. `inorder = [9,3,15,20,7]`, here we dont know which is the root node of tree and their children. It could start with any node as root and form a valid binary tree. \\n* Similarly, `postorder = [9,15,7,20,3]`, here we know `3` is the root node since traversal ended with it, however we are not sure of its children. It could have been all rest nodes on right side as `(root)3 -> 20 -> 7 -> 15 -> 9` or all on left side as `9 <- 15 <- 7 <- 20 <- 3(root)` or any intermediate of these.\\n\\nBut, when we consider both traversals, we can form a unique tree. Since the postorder traversal ends with root node, we know the root node of tree is last node of `postorder`. At the same time, we can search for that node in `inorder` and we know that the nodes that occur to its left form its left sub-tree and nodes occuring to the right of it form its right sub-tree. We recursively repeat the same process - \\n* Next node in the line from last  from `postorder` forms the root node, we search it in `inorder` and see what its left and right subtree are, then recurse for right subtree first, then the left one...until all nodes are traversed.\\n\\n\\n\\n\\n<table>\\n<tr>\\n<th>\\n<p align=middle><b>Step</b></p>\\n</th>\\n<th>\\n<p align=middle><b>Description</b></p>\\n</th>\\n</tr>\\n<tr></tr>\\n<tr>\\n<td><img src=\"https://assets.leetcode.com/users/images/90e76a97-9d03-4d51-b6d5-cb0409a67736_1637459119.542401.png\" width=600 /></td>\\n<td>The red node-3 denotes current root node</br>The blue nodes on left and right of red node denotes its left & right-subtrees respectively</br>We recursively construct the right subtree and then left subtree</td>\\n</tr>\\n<tr></tr>\\n<tr>\\n<td><img src=\"https://assets.leetcode.com/users/images/86ac3f2b-c0ce-49b7-b537-f87ae555a5dc_1637459304.2370312.png\" width=600 /></td>\\n<td>We have recursed to form the right subtree of previous root node-3</br>20 is the next node from end in postorder traversal and so it forms the current node</br>Again, the blue nodes on left & right of 20 denote its left & right-subtrees respectively</br>We again recursively construct the right subtree and then left subtree</td>\\n</tr>\\n<tr></tr>\\n<tr>\\n<td><img src=\"https://assets.leetcode.com/users/images/505ebc42-7713-4fa7-9110-ea5edc82fc9c_1637459360.4169023.png\" width=600 /></td>\\n<td>We have recursed to form the right subtree of previous root node-20</br>7 is next node in postorder which forms current node</br>There are no left and right subtrees for 7</br>So just create node-7 and return</td>\\n</tr>\\n<tr></tr>\\n<tr>\\n<td><img src=\"https://assets.leetcode.com/users/images/c881ffb6-5c85-4e06-a195-e506b30d3272_1637459438.2325265.png\" width=600 /></td>\\n<td>Now, we recurse from step-2 to form left subtree of root node-20</br>Again, 15 is next node in postorder and it forms the current node</br>Again, there are no left and right subtrees</br> So just create node-15 and return</td>\\n</tr>\\n<tr></tr>\\n<tr>\\n<td><img src=\"https://assets.leetcode.com/users/images/075935ae-9ceb-4c2d-8d72-b9bb530dcbf7_1637459480.7908006.png\" width=600 /></td>\\n<td>Now, we recurse from step-1 to form left subtree of root node-3</br>9 is the next node in postorder and it forms current node</br>We dont have any left and right subtree for 9</br> So just create node-9 and return</td>\\n</tr>\\n<tr></tr>\\n<tr>\\n<td><img src=\"https://assets.leetcode.com/users/images/2ae430ac-ac5b-4886-a4e8-1859f7e6c7de_1637461160.3626633.png\" width=600 /></td>\\n<td>All the nodes have been traversed</br>The recursion stops here and we return the final tree</td>\\n</tr>\\n</table>\\n\\nSo to summarize the algorithm can be stated as -\\n1. We start by initializing `postIdx = n-1`, where `n` is the number of nodes. `postIdx` denotes the index of postorder traversal that we are at. It will give us the root node for each point of recursion\\n2. We also initialize `inStart = 0` and `inEnd = n-1` which denotes the current range in `inorder` that the subtree will lie in. \\n3. At each recursion, we choose `postorder[postIdx]` as current root node. We search that index of that node in `inorder` as well. Then all nodes to the left of that index (till the previous root) are part of current root\\'s left sub-tree and all nodes to the right of it are part of its right sub-tree.\\n3. We decrement `postIdx` and recurse to build the right sub-tree and then left sub-tree. \\n  **Why right first**? Because postorder goes as `left->right->root` and we are traversing it from end. So we consider in order `root->right->left`)\\n 4. The process is continued till all nodes are traversed.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int n = size(inorder), postIdx = n-1;\\n        return build(inorder, postorder, 0, n-1, postIdx);\\n    }\\n\\n    TreeNode* build(vector<int>& in, vector<int>& post, int inStart, int inEnd, int& postIdx) {\\n        if(inStart > inEnd) return nullptr;\\n        TreeNode* root = new TreeNode(post[postIdx--]);\\n        int inIdx = find(begin(in), end(in), root -> val) - begin(in);\\n        root -> right = build(in, post, inIdx+1, inEnd, postIdx);\\n        root -> left  = build(in, post, inStart, inIdx-1, postIdx);\\n        return root;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        self.postIdx = len(postorder)-1\\n        def build(inStart, inEnd):\\n            if inStart > inEnd: return None\\n            root = TreeNode(postorder[self.postIdx])\\n            self.postIdx -= 1\\n            root.right = build(inorder.index(root.val)+1, inEnd)\\n            root.left  = build(inStart, inorder.index(root.val)-1)\\n            return root        \\n        return build(0, len(inorder)-1)\\n```\\n\\n***Time Complexity :*** **<code>O(N<sup>2</sup>)</code>** where `N` is the number of nodes in the tree. At each recursion, we are choosing `post[postIdx]` and searching it in `inorder`. This may take `O(N)` for each search and we are building a tree with `N` such nodes. So total time complexity is <code>O(N<sup>2</sup>)</code>\\n***Space Complexity :*** **<code>O(N)</code>**, required by implicit recursive stack. In worst case of skewed tree, the recursion depth might go upto `N`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive w/ Hashmap)***\\n\\nIn the previous approach, we had to search a node in the `inorder` array everytime which cost us `O(N)` and led to higher time complexity. However, we can reduce this cost if we maintain a mapping of node\\'s value to `inorder` node index in a hashmap. This allows us to fetch index of a node in `inorder` array in `O(1)` time at each recursion.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, int> mp;\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        for(int i = 0; i < size(inorder); i++) mp[inorder[i]] = i;\\n        int n = size(inorder), postIdx = n-1;\\n        return build(inorder, postorder, 0, n-1, postIdx);\\n    }\\n\\n    TreeNode* build(vector<int>& in, vector<int>& post, int inStart, int inEnd, int& postIdx) {\\n        if(inStart > inEnd) return nullptr;\\n        TreeNode* root = new TreeNode(post[postIdx--]);\\n        int inIdx = mp[root -> val];\\n        root -> right = build(in, post, inIdx+1, inEnd, postIdx);\\n        root -> left  = build(in, post, inStart, inIdx-1, postIdx);\\n        return root;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        self.postIdx, mp = len(postorder)-1, {val: idx for idx, val in enumerate(inorder)}\\n        def build(inStart, inEnd):\\n            if inStart > inEnd: return None\\n            root = TreeNode(postorder[self.postIdx])\\n            self.postIdx -= 1\\n            root.right = build(mp[root.val]+1, inEnd)\\n            root.left  = build(inStart, mp[root.val]-1)\\n            return root        \\n        return build(0, len(inorder)-1)\\n```\\n\\n***Time Complexity :*** `O(N)`, now we can find `inIdx` in `O(1)` time. So the time required to build the tree out of `N` nodes each taking `O(1)` comes out to be `O(N)`\\n***Space Complexity :*** `O(N)`, requried by recursive stack and to maintain hashmap.\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int n = size(inorder), postIdx = n-1;\\n        return build(inorder, postorder, 0, n-1, postIdx);\\n    }\\n\\n    TreeNode* build(vector<int>& in, vector<int>& post, int inStart, int inEnd, int& postIdx) {\\n        if(inStart > inEnd) return nullptr;\\n        TreeNode* root = new TreeNode(post[postIdx--]);\\n        int inIdx = find(begin(in), end(in), root -> val) - begin(in);\\n        root -> right = build(in, post, inIdx+1, inEnd, postIdx);\\n        root -> left  = build(in, post, inStart, inIdx-1, postIdx);\\n        return root;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        self.postIdx = len(postorder)-1\\n        def build(inStart, inEnd):\\n            if inStart > inEnd: return None\\n            root = TreeNode(postorder[self.postIdx])\\n            self.postIdx -= 1\\n            root.right = build(inorder.index(root.val)+1, inEnd)\\n            root.left  = build(inStart, inorder.index(root.val)-1)\\n            return root        \\n        return build(0, len(inorder)-1)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, int> mp;\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        for(int i = 0; i < size(inorder); i++) mp[inorder[i]] = i;\\n        int n = size(inorder), postIdx = n-1;\\n        return build(inorder, postorder, 0, n-1, postIdx);\\n    }\\n\\n    TreeNode* build(vector<int>& in, vector<int>& post, int inStart, int inEnd, int& postIdx) {\\n        if(inStart > inEnd) return nullptr;\\n        TreeNode* root = new TreeNode(post[postIdx--]);\\n        int inIdx = mp[root -> val];\\n        root -> right = build(in, post, inIdx+1, inEnd, postIdx);\\n        root -> left  = build(in, post, inStart, inIdx-1, postIdx);\\n        return root;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        self.postIdx, mp = len(postorder)-1, {val: idx for idx, val in enumerate(inorder)}\\n        def build(inStart, inEnd):\\n            if inStart > inEnd: return None\\n            root = TreeNode(postorder[self.postIdx])\\n            self.postIdx -= 1\\n            root.right = build(mp[root.val]+1, inEnd)\\n            root.left  = build(inStart, mp[root.val]-1)\\n            return root        \\n        return build(0, len(inorder)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34782,
                "title": "my-recursive-java-code-with-o-n-time-and-o-n-space",
                "content": "The the basic idea is to take the last element in postorder array as the root, find the position of the root in the inorder array; then locate the range for left sub-tree and right sub-tree and do recursion. Use a HashMap to record the index of root in the inorder array.\\n\\n    public TreeNode buildTreePostIn(int[] inorder, int[] postorder) {\\n    \\tif (inorder == null || postorder == null || inorder.length != postorder.length)\\n    \\t\\treturn null;\\n    \\tHashMap<Integer, Integer> hm = new HashMap<Integer,Integer>();\\n    \\tfor (int i=0;i<inorder.length;++i)\\n    \\t\\thm.put(inorder[i], i);\\n    \\treturn buildTreePostIn(inorder, 0, inorder.length-1, postorder, 0, \\n                              postorder.length-1,hm);\\n    }\\n    \\n    private TreeNode buildTreePostIn(int[] inorder, int is, int ie, int[] postorder, int ps, int pe, \\n                                     HashMap<Integer,Integer> hm){\\n    \\tif (ps>pe || is>ie) return null;\\n    \\tTreeNode root = new TreeNode(postorder[pe]);\\n    \\tint ri = hm.get(postorder[pe]);\\n    \\tTreeNode leftchild = buildTreePostIn(inorder, is, ri-1, postorder, ps, ps+ri-is-1, hm);\\n    \\tTreeNode rightchild = buildTreePostIn(inorder,ri+1, ie, postorder, ps+ri-is, pe-1, hm);\\n    \\troot.left = leftchild;\\n    \\troot.right = rightchild;\\n    \\treturn root;\\n    }",
                "solutionTags": [],
                "code": "The the basic idea is to take the last element in postorder array as the root, find the position of the root in the inorder array; then locate the range for left sub-tree and right sub-tree and do recursion. Use a HashMap to record the index of root in the inorder array.\\n\\n    public TreeNode buildTreePostIn(int[] inorder, int[] postorder) {\\n    \\tif (inorder == null || postorder == null || inorder.length != postorder.length)\\n    \\t\\treturn null;\\n    \\tHashMap<Integer, Integer> hm = new HashMap<Integer,Integer>();\\n    \\tfor (int i=0;i<inorder.length;++i)\\n    \\t\\thm.put(inorder[i], i);\\n    \\treturn buildTreePostIn(inorder, 0, inorder.length-1, postorder, 0, \\n                              postorder.length-1,hm);\\n    }\\n    \\n    private TreeNode buildTreePostIn(int[] inorder, int is, int ie, int[] postorder, int ps, int pe, \\n                                     HashMap<Integer,Integer> hm){\\n    \\tif (ps>pe || is>ie) return null;\\n    \\tTreeNode root = new TreeNode(postorder[pe]);\\n    \\tint ri = hm.get(postorder[pe]);\\n    \\tTreeNode leftchild = buildTreePostIn(inorder, is, ri-1, postorder, ps, ps+ri-is-1, hm);\\n    \\tTreeNode rightchild = buildTreePostIn(inorder,ri+1, ie, postorder, ps+ri-is, pe-1, hm);\\n    \\troot.left = leftchild;\\n    \\troot.right = rightchild;\\n    \\treturn root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3302159,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo construct a binary tree from inorder and postorder traversal arrays, we first need to understand what each of these traversals represents.\\nInorder traversal visits the nodes in ascending order of their values, i.e., left child, parent, and right child. On the other hand, postorder traversal visits the nodes in the order left child, right child, and parent.\\nKnowing this, we can say that the last element in the postorder array is the root node, and its index in the inorder array divides the tree into left and right subtrees. We can recursively apply this logic to construct the entire binary tree.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Start with the last element of the postorder array as the root node.\\n2. Find the index of the root node in the inorder array.\\n3. Divide the inorder array into left and right subtrees based on the index of the root node.\\n4. Divide the postorder array into left and right subtrees based on the number of elements\\nin the left and right subtrees of the inorder array.\\n5. Recursively construct the left and right subtrees.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree. We visit each node only once.\\n\\n- Space complexity:\\nThe space complexity of this algorithm is O(n). We create a hashmap to store the indices of the inorder traversal, which takes O(n) space. Additionally, the recursive call stack can go up to O(n) in the worst case if the binary tree is skewed.\\n\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nlass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        // Call the recursive function with full arrays and return the result\\n        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\\n    }\\n    \\n    private TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {\\n        // Base case\\n        if (inStart > inEnd || postStart > postEnd) {\\n            return null;\\n        }\\n        \\n        // Find the root node from the last element of postorder traversal\\n        int rootVal = postorder[postEnd];\\n        TreeNode root = new TreeNode(rootVal);\\n        \\n        // Find the index of the root node in inorder traversal\\n        int rootIndex = 0;\\n        for (int i = inStart; i <= inEnd; i++) {\\n            if (inorder[i] == rootVal) {\\n                rootIndex = i;\\n                break;\\n            }\\n        }\\n        \\n        // Recursively build the left and right subtrees\\n        int leftSize = rootIndex - inStart;\\n        int rightSize = inEnd - rootIndex;\\n        root.left = buildTree(inorder, inStart, rootIndex - 1, postorder, postStart, postStart + leftSize - 1);\\n        root.right = buildTree(inorder, rootIndex + 1, inEnd, postorder, postEnd - rightSize, postEnd - 1);\\n        \\n        return root;\\n    }\\n}\\n\\n\\n```\\n```Python []\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        # Base case\\n        if not inorder:\\n            return None\\n        \\n        # The last element of postorder list is the root\\n        root_val = postorder.pop()\\n        root = TreeNode(root_val)\\n        \\n        # Find the position of the root in the inorder list\\n        inorder_index = inorder.index(root_val)\\n        \\n        # Recursively build the left and right subtrees\\n        root.right = self.buildTree(inorder[inorder_index+1:], postorder)\\n        root.left = self.buildTree(inorder[:inorder_index], postorder)\\n        \\n        return root\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int, int> index;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            index[inorder[i]] = i;\\n        }\\n        return buildTreeHelper(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1, index);\\n    }\\n    \\n    TreeNode* buildTreeHelper(vector<int>& inorder, vector<int>& postorder, int inorderStart, int inorderEnd, int postorderStart, int postorderEnd, unordered_map<int, int>& index) {\\n        if (inorderStart > inorderEnd || postorderStart > postorderEnd) {\\n            return nullptr;\\n        }\\n        int rootVal = postorder[postorderEnd];\\n        TreeNode* root = new TreeNode(rootVal);\\n        int inorderRootIndex = index[rootVal];\\n        int leftSubtreeSize = inorderRootIndex - inorderStart;\\n        root->left = buildTreeHelper(inorder, postorder, inorderStart, inorderRootIndex - 1, postorderStart, postorderStart + leftSubtreeSize - 1, index);\\n        root->right = buildTreeHelper(inorder, postorder, inorderRootIndex + 1, inorderEnd, postorderStart + leftSubtreeSize, postorderEnd - 1, index);\\n        return root;\\n    }\\n};\\n\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Divide and Conquer",
                    "Tree"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nlass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        // Call the recursive function with full arrays and return the result\\n        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\\n    }\\n    \\n    private TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {\\n        // Base case\\n        if (inStart > inEnd || postStart > postEnd) {\\n            return null;\\n        }\\n        \\n        // Find the root node from the last element of postorder traversal\\n        int rootVal = postorder[postEnd];\\n        TreeNode root = new TreeNode(rootVal);\\n        \\n        // Find the index of the root node in inorder traversal\\n        int rootIndex = 0;\\n        for (int i = inStart; i <= inEnd; i++) {\\n            if (inorder[i] == rootVal) {\\n                rootIndex = i;\\n                break;\\n            }\\n        }\\n        \\n        // Recursively build the left and right subtrees\\n        int leftSize = rootIndex - inStart;\\n        int rightSize = inEnd - rootIndex;\\n        root.left = buildTree(inorder, inStart, rootIndex - 1, postorder, postStart, postStart + leftSize - 1);\\n        root.right = buildTree(inorder, rootIndex + 1, inEnd, postorder, postEnd - rightSize, postEnd - 1);\\n        \\n        return root;\\n    }\\n}\\n\\n\\n```\n```Python []\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        # Base case\\n        if not inorder:\\n            return None\\n        \\n        # The last element of postorder list is the root\\n        root_val = postorder.pop()\\n        root = TreeNode(root_val)\\n        \\n        # Find the position of the root in the inorder list\\n        inorder_index = inorder.index(root_val)\\n        \\n        # Recursively build the left and right subtrees\\n        root.right = self.buildTree(inorder[inorder_index+1:], postorder)\\n        root.left = self.buildTree(inorder[:inorder_index], postorder)\\n        \\n        return root\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int, int> index;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            index[inorder[i]] = i;\\n        }\\n        return buildTreeHelper(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1, index);\\n    }\\n    \\n    TreeNode* buildTreeHelper(vector<int>& inorder, vector<int>& postorder, int inorderStart, int inorderEnd, int postorderStart, int postorderEnd, unordered_map<int, int>& index) {\\n        if (inorderStart > inorderEnd || postorderStart > postorderEnd) {\\n            return nullptr;\\n        }\\n        int rootVal = postorder[postorderEnd];\\n        TreeNode* root = new TreeNode(rootVal);\\n        int inorderRootIndex = index[rootVal];\\n        int leftSubtreeSize = inorderRootIndex - inorderStart;\\n        root->left = buildTreeHelper(inorder, postorder, inorderStart, inorderRootIndex - 1, postorderStart, postorderStart + leftSubtreeSize - 1, index);\\n        root->right = buildTreeHelper(inorder, postorder, inorderRootIndex + 1, inorderEnd, postorderStart + leftSubtreeSize, postorderEnd - 1, index);\\n        return root;\\n    }\\n};\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588934,
                "title": "c-easy-intuitive-sol-clean-recursive-code-w-explanation-dry-run-t-c-o-n",
                "content": "Hello everyone! I hope you all are doing great.\\n\\n***Note: Please do upvote if you find this post helpful!***\\n**Note: Some people are unethically downvoting my post, please do upvote and save this post from disappearing**\\n\\nNow, we want to create our binary tree with given postorder and inorder traversals.\\n\\n**Observations:**\\n1. *Inorder* is `LEFT ROOT RIGHT`. So for any node lets say current node is at index `i` in inorder array, if you think it as a root of its subtree, then all the nodes at indices less than `i` will be on the left subtree of the current node and all the nodes at indices greater than `i` will be on the right subtree of the current node.\\n\\n2. *Postorder* is `LEFT RIGHT ROOT`. So the **last element** of our postorder array will always be our `root`, and then we will move backwards in our postorder array to find the next root.\\n\\n**My Approach:**\\n1. Since Post Order traversal is like `LEFT RIGHT ROOT`, therefore we will traverse the postorder array from backwards and will construct our tree like `ROOT RIGHT LEFT`.\\n\\n2. Take our node from postorder array, let say it is at index `idx` (We came from `postorder.size()-1` to `idx`) and this will be our root in current recursive call, then decrement the `idx` for our next upcoming root.\\n\\n3. Now find our current node (from step 2) in our inorder array (let say we found it at `i`), then we will have nodes in left subtree of current node who are at position less than `i` and nodes in right subtree of current node who are at position greater than `i`.\\n\\n4. So we make a recursive call to construct the right subtree first, then we make a recursive call to construct the left subtree of our current node. (Since we are building our Binary Tree in `ROOT RIGHT LEFT`).\\n\\n**DRY RUN for algo explained above:**\\n\\n**Initial Situtation: (Step 1)** \\n```\\nInorder array: [9,3,15,20,7]\\nPostorder  array: [9,15,7,20,3]\\n\\nHence 3 will be our root and inorder range for left subtree will be [9] and inorder range for right subtree will be [15, 20, 7]\\n\\n\\t\\t\\t3\\n\\t\\t  /\\t  \\\\\\n\\t   [9]    [15, 20, 7]   -> Inorder\\n\\t   [9]    [15, 7, 20]   -> Postorder\\n```\\n\\n**Step 2:**\\n```\\n\\t\\t\\t3\\n\\t\\t /\\t    \\\\\\n\\t\\t9\\t    20\\n\\t   / \\\\\\t    /  \\\\\\n\\t  *   *  [15] [7] -> Inorder\\n\\t\\t\\t [15] [7] -> Postorder\\n```\\n\\n**Step 3:**\\n```\\n\\t\\t\\t3\\n\\t\\t /\\t    \\\\\\n\\t\\t9\\t    20\\n\\t   / \\\\\\t   /  \\\\\\n\\t  *   *   15   7\\n\\t\\t\\t / \\\\  / \\\\\\n\\t\\t\\t * *  * *\\n```\\n\\n**Below is the code for the approach I gave above:**\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int>mp; // Stores (node -> index in inorder array)\\n    \\n    TreeNode* make_tree(int start, int end, int &idx, vector<int>& postorder, vector<int>& inorder){\\n        \\n\\t\\t// If range for inorder is NOT valid then return NULL\\n        if(start > end) return NULL;\\n        \\n\\t\\t// Create a node for our root node of current subtree\\n        TreeNode* root = new TreeNode(postorder[idx]);\\n        \\n\\t\\t// Find position of current root in inorder array\\n        int i = mp[root->val];\\n\\t\\t\\n\\t\\t// Decrement our pointer to postorder array for our next upcoming root if any\\n        idx--;\\n\\t\\t\\n\\t\\t// Make a call to create right subtree, inorder range [i+1, end]\\n        root->right = make_tree(i+1, end, idx, postorder, inorder);\\n\\t\\t\\n\\t\\t// Make a call to create left subtree, inorder range [start, i-1]\\n        root->left = make_tree(start, i-1, idx, postorder, inorder);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int idx=postorder.size()-1;\\n        \\n\\t\\t// Create (nodes -> index of inorder array) mapping\\n        for(int i{}; i<inorder.size(); ++i){\\n            \\n            mp[inorder[i]] = i;\\n        }\\n\\t\\t// Create tree starting from root at position (n-1) in postorder array\\n\\t\\t// Range for current inirder array : [0, n-1]\\n        return make_tree(0, inorder.size()-1, idx, postorder, inorder);\\n    }\\n};\\n```\\n\\n**Time Complexity:** ***O(N)*** since we are visiting every node from postorder array at once and creating a node for it.\\n\\n**Space Complexity:** ***O(N)*** since we are creating a mapping for every node that will contain its index for a node in inorder array.\\n\\n***NOTE: Please do \\u2705 Upvote if you like my solution!***",
                "solutionTags": [],
                "code": "```\\nInorder array: [9,3,15,20,7]\\nPostorder  array: [9,15,7,20,3]\\n\\nHence 3 will be our root and inorder range for left subtree will be [9] and inorder range for right subtree will be [15, 20, 7]\\n\\n\\t\\t\\t3\\n\\t\\t  /\\t  \\\\\\n\\t   [9]    [15, 20, 7]   -> Inorder\\n\\t   [9]    [15, 7, 20]   -> Postorder\\n```\n```\\n\\t\\t\\t3\\n\\t\\t /\\t    \\\\\\n\\t\\t9\\t    20\\n\\t   / \\\\\\t    /  \\\\\\n\\t  *   *  [15] [7] -> Inorder\\n\\t\\t\\t [15] [7] -> Postorder\\n```\n```\\n\\t\\t\\t3\\n\\t\\t /\\t    \\\\\\n\\t\\t9\\t    20\\n\\t   / \\\\\\t   /  \\\\\\n\\t  *   *   15   7\\n\\t\\t\\t / \\\\  / \\\\\\n\\t\\t\\t * *  * *\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int>mp; // Stores (node -> index in inorder array)\\n    \\n    TreeNode* make_tree(int start, int end, int &idx, vector<int>& postorder, vector<int>& inorder){\\n        \\n\\t\\t// If range for inorder is NOT valid then return NULL\\n        if(start > end) return NULL;\\n        \\n\\t\\t// Create a node for our root node of current subtree\\n        TreeNode* root = new TreeNode(postorder[idx]);\\n        \\n\\t\\t// Find position of current root in inorder array\\n        int i = mp[root->val];\\n\\t\\t\\n\\t\\t// Decrement our pointer to postorder array for our next upcoming root if any\\n        idx--;\\n\\t\\t\\n\\t\\t// Make a call to create right subtree, inorder range [i+1, end]\\n        root->right = make_tree(i+1, end, idx, postorder, inorder);\\n\\t\\t\\n\\t\\t// Make a call to create left subtree, inorder range [start, i-1]\\n        root->left = make_tree(start, i-1, idx, postorder, inorder);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int idx=postorder.size()-1;\\n        \\n\\t\\t// Create (nodes -> index of inorder array) mapping\\n        for(int i{}; i<inorder.size(); ++i){\\n            \\n            mp[inorder[i]] = i;\\n        }\\n\\t\\t// Create tree starting from root at position (n-1) in postorder array\\n\\t\\t// Range for current inirder array : [0, n-1]\\n        return make_tree(0, inorder.size()-1, idx, postorder, inorder);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34814,
                "title": "a-python-recursive-solution",
                "content": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param inorder, a list of integers\\n        # @param postorder, a list of integers\\n        # @return a tree node\\n        # 12:00\\n        def buildTree(self, inorder, postorder):\\n            if not inorder or not postorder:\\n                return None\\n            \\n            root = TreeNode(postorder.pop())\\n            inorderIndex = inorder.index(root.val)\\n    \\n            root.right = self.buildTree(inorder[inorderIndex+1:], postorder)\\n            root.left = self.buildTree(inorder[:inorderIndex], postorder)\\n    \\n            return root",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param inorder, a list of integers\\n        # @param postorder, a list of integers\\n        # @return a tree node\\n        # 12:00\\n        def buildTree(self, inorder, postorder):\\n            if not inorder or not postorder:\\n                return None\\n            \\n            root = TreeNode(postorder.pop())\\n            inorderIndex = inorder.index(root.val)\\n    \\n            root.right = self.buildTree(inorder[inorderIndex+1:], postorder)\\n            root.left = self.buildTree(inorder[:inorderIndex], postorder)\\n    \\n            return root",
                "codeTag": "Java"
            },
            {
                "id": 34803,
                "title": "sharing-my-straightforward-recursive-solution",
                "content": "    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\\n        return create(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);\\n    }\\n    \\n    TreeNode* create(vector<int> &inorder, vector<int> &postorder, int is, int ie, int ps, int pe){\\n        if(ps > pe){\\n            return nullptr;\\n        }\\n        TreeNode* node = new TreeNode(postorder[pe]);\\n        int pos;\\n        for(int i = is; i <= ie; i++){\\n            if(inorder[i] == node->val){\\n                pos = i;\\n                break;\\n            }\\n        }\\n        node->left = create(inorder, postorder, is, pos - 1, ps, ps + pos - is - 1);\\n        node->right = create(inorder, postorder, pos + 1, ie, pe - ie + pos, pe - 1);\\n        return node;\\n    }\\n\\nActually, this problem is pretty similar as the previous one. \\n\\n[Here is a like to that solution. ][1]\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/18101/sharing-my-straightforward-recursive-solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\\n        return create(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);\\n    }\\n    \\n    TreeNode* create(vector<int> &inorder, vector<int> &postorder, int is, int ie, int ps, int pe){\\n        if(ps > pe){\\n            return nullptr;\\n        }\\n        TreeNode* node = new TreeNode(postorder[pe]);\\n        int pos;\\n        for(int i = is; i <= ie; i++){\\n            if(inorder[i] == node->val){\\n                pos = i;\\n                break;\\n            }\\n        }\\n        node->left = create(inorder, postorder, is, pos - 1, ps, ps + pos - is - 1);\\n        node->right = create(inorder, postorder, pos + 1, ie, pe - ie + pos, pe - 1);\\n        return node;\\n    }\\n\\nActually, this problem is pretty similar as the previous one. \\n\\n[Here is a like to that solution. ][1]\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/18101/sharing-my-straightforward-recursive-solution",
                "codeTag": "Unknown"
            },
            {
                "id": 34807,
                "title": "java-iterative-solution-with-explanation",
                "content": "\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if (inorder.length == 0 || postorder.length == 0) return null;\\n        int ip = inorder.length - 1;\\n        int pp = postorder.length - 1;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode prev = null;\\n        TreeNode root = new TreeNode(postorder[pp]);\\n        stack.push(root);\\n        pp--;\\n        \\n        while (pp >= 0) {\\n            while (!stack.isEmpty() && stack.peek().val == inorder[ip]) {\\n                prev = stack.pop();\\n                ip--;\\n            }\\n            TreeNode newNode = new TreeNode(postorder[pp]);\\n            if (prev != null) {\\n                prev.left = newNode;\\n            } else if (!stack.isEmpty()) {\\n                TreeNode currTop = stack.peek();\\n                currTop.right = newNode;\\n            }\\n            stack.push(newNode);\\n            prev = null;\\n            pp--;\\n        }\\n        \\n        return root;\\n    }\\n\\nThis is my iterative solution, think about \"Constructing Binary Tree from inorder and preorder array\", the idea is quite similar. Instead of scanning the preorder array from beginning to end and using inorder array as a kind of mark, in this question, the key point is to scanning the postorder array from end to beginning and also use inorder array from end to beginning as a mark because the logic is more clear in this way. ***The core idea is: Starting from the last element of the postorder and inorder array, we put elements from postorder array to a stack and each one is the right child of the last one until an element in postorder array is equal to the element on the inorder array. Then, we pop as many as elements we can from the stack and decrease the mark in inorder array until the peek() element is not equal to the mark value or the stack is empty. Then, the new element that we are gonna scan from postorder array is the left child of the last element we have popped out from the stack.***",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if (inorder.length == 0 || postorder.length == 0) return null;\\n        int ip = inorder.length - 1;\\n        int pp = postorder.length - 1;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode prev = null;\\n        TreeNode root = new TreeNode(postorder[pp]);\\n        stack.push(root);\\n        pp--;\\n        \\n        while (pp >= 0) {\\n            while (!stack.isEmpty() && stack.peek().val == inorder[ip]) {\\n                prev = stack.pop();\\n                ip--;\\n            }\\n            TreeNode newNode = new TreeNode(postorder[pp]);\\n            if (prev != null) {\\n                prev.left = newNode;\\n            } else if (!stack.isEmpty()) {\\n                TreeNode currTop = stack.peek();\\n                currTop.right = newNode;\\n            }\\n            stack.push(newNode);\\n            prev = null;\\n            pp--;\\n        }\\n        \\n        return root;\\n    }\\n\\nThis is my iterative solution, think about \"Constructing Binary Tree from inorder and preorder array\", the idea is quite similar. Instead of scanning the preorder array from beginning to end and using inorder array as a kind of mark, in this question, the key point is to scanning the postorder array from end to beginning and also use inorder array from end to beginning as a mark because the logic is more clear in this way. ***The core idea is: Starting from the last element of the postorder and inorder array, we put elements from postorder array to a stack and each one is the right child of the last one until an element in postorder array is equal to the element on the inorder array. Then, we pop as many as elements we can from the stack and decrease the mark in inorder array until the peek() element is not equal to the mark value or the stack is empty. Then, the new element that we are gonna scan from postorder array is the left child of the last element we have popped out from the stack.***",
                "codeTag": "Unknown"
            },
            {
                "id": 1588974,
                "title": "java-recursive-most-intutive-intution-explanation-using-image",
                "content": "**Intution:** Firstly observe both the arrays and think how they are formed from a tree...which index contain which part from the tree.\\n * *Inorder Traversal*: After storing the inorder traversal of tree u can see that root will always come in between and left of root will be all the nodes of left subtree and in right will be nodes of right subtree.\\n* *Postorder Traversal*: Here u can see that in the array firstly there will be all the left subtree nodes then all the righgt subtree nodes and then at last will be root;\\n     ##### So now u can say that you have the root node confirmed that is at last index of postorder traversal array\\n\\t Now u have to just recursively update the left and right subtree of the root using your two arrays.\\n\\t \\n\\t ![image](https://assets.leetcode.com/users/images/558dd002-738b-4189-8691-97c6d2de39c2_1637464626.6180944.jpeg)\\n\\n\\n```\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        return build(inorder,0,inorder.length-1,postorder,0,postorder.length-1);\\n    }\\n    \\n    public TreeNode build(int[] inorder, int inS, int inE, int[] postorder, int posS, int posE){\\n        if(inS>inE || posS>posE) return  null;\\n        \\n        TreeNode root = new TreeNode(postorder[posE]);\\n        \\n        int rootI=0;\\n        for(int i=0;i<inorder.length;i++){\\n            if(inorder[i]==root.val){\\n                rootI = i;\\n                break;\\n            }\\n        }\\n        \\n        root.left = build(inorder,inS,rootI-1,postorder,posS,posS+rootI-inS-1);\\n        root.right = build(inorder,rootI+1,inE,postorder,posS+rootI-inS,posE-1);\\n        \\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        return build(inorder,0,inorder.length-1,postorder,0,postorder.length-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 34787,
                "title": "simple-and-clean-java-solution-with-comments-recursive",
                "content": "    \\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        return buildTree(inorder, inorder.length-1, 0, postorder, postorder.length-1);\\n    }\\n\\n\\tprivate TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder,\\n\\t\\t\\tint postStart) {\\n\\t\\tif (postStart < 0 || inStart < inEnd)\\n\\t\\t\\treturn null;\\n\\t\\t\\n\\t\\t//The last element in postorder is the root.\\n\\t\\tTreeNode root = new TreeNode(postorder[postStart]);\\n\\t\\t\\n\\t\\t//find the index of the root from inorder. Iterating from the end.\\n\\t\\tint rIndex = inStart;\\n\\t\\tfor (int i = inStart; i >= inEnd; i--) {\\n\\t\\t\\tif (inorder[i] == postorder[postStart]) {\\n\\t\\t\\t\\trIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//build right and left subtrees. Again, scanning from the end to find the sections.\\n\\t\\troot.right = buildTree(inorder, inStart, rIndex + 1, postorder, postStart-1);\\n\\t\\troot.left = buildTree(inorder, rIndex - 1, inEnd, postorder, postStart - (inStart - rIndex) -1);\\n\\t\\treturn root;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    \\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        return buildTree(inorder, inorder.length-1, 0, postorder, postorder.length-1);\\n    }\\n\\n\\tprivate TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder,\\n\\t\\t\\tint postStart) {\\n\\t\\tif (postStart < 0 || inStart < inEnd)\\n\\t\\t\\treturn null;\\n\\t\\t\\n\\t\\t//The last element in postorder is the root.\\n\\t\\tTreeNode root = new TreeNode(postorder[postStart]);\\n\\t\\t\\n\\t\\t//find the index of the root from inorder. Iterating from the end.\\n\\t\\tint rIndex = inStart;\\n\\t\\tfor (int i = inStart; i >= inEnd; i--) {\\n\\t\\t\\tif (inorder[i] == postorder[postStart]) {\\n\\t\\t\\t\\trIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//build right and left subtrees. Again, scanning from the end to find the sections.\\n\\t\\troot.right = buildTree(inorder, inStart, rIndex + 1, postorder, postStart-1);\\n\\t\\troot.left = buildTree(inorder, rIndex - 1, inEnd, postorder, postStart - (inStart - rIndex) -1);\\n\\t\\treturn root;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 758662,
                "title": "python-o-n-recursion-explained-with-diagram",
                "content": "To solve this problem we need to understand, what is `inorder` and what is `postorder` traversal of tree. Let me remind you:\\n\\n1. `inorder` traversal is when you visit `left, root, right`, where `left` is left subtree, `root` is root node and `right` is right subtree.\\n2. `postorder` traversal is when you visit `left, right, root`.\\n\\nWe can see that in `postorder` traverasl `root` will be in the end, so we take this element and we need to find it in `inorder` array. Then we need to call function recursively on the `left` subtree and `right` subtree. It is easier said that done, so let us introduce function `helper(post_beg, post_end, in_beg, in_end)`, which has `4` parameters:\\n1. `post_beg` and `post_end` are indices in original `postorder` array of current window. Note, that we use python notation, so `post_end` points to one element after the end.\\n2. `in_beg` and `in_end` are indices in original `inorder` array of current window. We again use python notation, where `in_end` points to one element after the end.\\n\\nThen what we need to do is to find indices of left part and right part. First of all, evaluate `ind = dic[postorder[post_end-1]]`, where we create `dic = {elem: it for it, elem in enumerate(inorder)}` for fast access to elements. Now, look at the next two images:\\n\\nOn the first one `1, 2, 3, 4` in circles are equal to `post_beg, post_beg + ind - in_beg, in_beg, ind`. Why? `1` should point to beginning of `left` in postorder, so it is equal to `post_beg`. `2` should point to one element after the end of `left`, so we need to know the length of `left`, we can find it from `inorder` array, it is `ind - in_beg`. So, finally, point `2` is equal to `post_beg + ind - in_beg`. Point `3` should point to start of `left` in `inorder` array, that is `in_beg` and point `4` should point to element after the end of `left` in `inorder` array, that is `ind`.\\n\\nOn the second one `1, 2, 3, 4` in circles are equal to `post_end - in_end + ind, post_end - 1, ind + 1, in_end`. The logic is similar as for `left` parts, but here we look into `right` arrays.\\n\\n![image](https://assets.leetcode.com/users/images/58426c75-056e-4c70-bd52-6adbba56cb70_1595848892.2064395.png)\\n\\n**Complexity**: Time complexity is `O(n)`, because we traverse each element only once and we have `O(1)` complexity to find element in `dic`. Space complexity is also `O(n)`, because we keep additional `dic` with this size.\\n\\n```\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        def helper(post_beg, post_end, in_beg, in_end):\\n            if post_end - post_beg <= 0: return None\\n            ind = dic[postorder[post_end-1]]\\n\\n            root = TreeNode(inorder[ind])  \\n            root.left  = helper(post_beg, post_beg + ind - in_beg, in_beg, ind)\\n            root.right = helper(post_end - in_end + ind, post_end - 1, ind + 1, in_end)\\n            return root\\n        \\n        dic = {elem: it for it, elem in enumerate(inorder)}  \\n        return helper(0, len(postorder), 0, len(inorder))\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        def helper(post_beg, post_end, in_beg, in_end):\\n            if post_end - post_beg <= 0: return None\\n            ind = dic[postorder[post_end-1]]\\n\\n            root = TreeNode(inorder[ind])  \\n            root.left  = helper(post_beg, post_beg + ind - in_beg, in_beg, ind)\\n            root.right = helper(post_end - in_end + ind, post_end - 1, ind + 1, in_end)\\n            return root\\n        \\n        dic = {elem: it for it, elem in enumerate(inorder)}  \\n        return helper(0, len(postorder), 0, len(inorder))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389630,
                "title": "c-solution-using-recursion-and-map-with-explanation-90-33-faster",
                "content": "**Explanation:**\\nWe Using Unorder map to know the index of the ROOT element in INORDER element. that\\'s why,we have to iterate all over the INORDER element and save their value and index in our **UNORDERED_MAP**; \\nIt makes the solution **O(n)** instead of O(n^2).\\n\\n\\nWe know that, the last element of **POSTORDER** array contains main **ROOT** Node. and In **INORDER** array we see that the left side of the **ROOT** element contains the **LEFT** side element and **Right** side contains all the **RIGHT** side element.\\nSo, we have to find out the index of **ROOT** element in **INORDER** Element. \\nSo, \\n```int inorderIndex = m[postorder[postIndex]];```\\nand Make ROOT =\\n```TreeNode *root =new TreeNode(inorder[inorderIndex]);```\\nand postIndex decreament by 1 for the next purpose.\\nAnd then we go to the **Right side** first and make the **Right side** of the **ROOT**. Here the start index is inorderIndex+1 cause all Right Part is in the Right Side of the inorder Array.\\n```root->right=solve(inorder,postorder,inorderIndex+1,end,postIndex);```\\n\\nAnd then we go to the **Left Side** and make the Left side of the **ROOT**. Here the end index is inorderIndex-1 cause all left Part is in the left Side of the inorder Array.\\n```root->left=solve(inorder,postorder,start,inorderIndex-1,postIndex);```\\n\\nAnd Now the **base case**, when we stop our Recursion:\\nWe all know when, start> end, we return NULL;\\n``` if(start>end) return NULL;```\\n\\nAnd Last we return ROOT;\\n\\n**N:B: If you recurse Left Side first , it cause Runtime Error, cursed the code**\\nCause,when you call left first the postindex got decreased in every call until left part finishes off but we are comparing from the last so need to get the last indexes for right part too that we will not be able to get it if we called for left part first.\\nIf we call right part eventually postindex should decrease till left part so that we will be able to access parent node for every left tree element.\\nHope this helps:)\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n unordered_map<int,int>m;\\n    TreeNode* solve(vector<int>& inorder,vector<int>& postorder,int start,int end,int &postIndex){\\n        if(start>end) return NULL;\\n         int inorderIndex = m[postorder[postIndex]];\\n\\n        TreeNode* root = new TreeNode(inorder[inorderIndex]);    \\n        \\n        (postIndex)--;\\n      root->right=solve(inorder,postorder,inorderIndex+1,end,postIndex);\\n        root->left=solve(inorder,postorder,start,inorderIndex-1,postIndex);\\n        \\n        return root;\\n    }\\n    \\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n\\n        for(int i=0;i<inorder.size();i++){\\n           m[inorder[i]] = i;\\n            \\n        }\\n        int postIndex=postorder.size()-1;\\n        return solve(inorder,postorder,0,postorder.size()-1,postIndex);\\n    }\\n};\\n```\\n**If you helped by this Explanation or Code or learn something from this, PLEASE UPVOTE**\\nif I make any mistake , please comment and If you have better Idea please Comment. Thank you for Reading.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```int inorderIndex = m[postorder[postIndex]];```\n```TreeNode *root =new TreeNode(inorder[inorderIndex]);```\n```root->right=solve(inorder,postorder,inorderIndex+1,end,postIndex);```\n```root->left=solve(inorder,postorder,start,inorderIndex-1,postIndex);```\n``` if(start>end) return NULL;```\n```\\nclass Solution {\\npublic:\\n unordered_map<int,int>m;\\n    TreeNode* solve(vector<int>& inorder,vector<int>& postorder,int start,int end,int &postIndex){\\n        if(start>end) return NULL;\\n         int inorderIndex = m[postorder[postIndex]];\\n\\n        TreeNode* root = new TreeNode(inorder[inorderIndex]);    \\n        \\n        (postIndex)--;\\n      root->right=solve(inorder,postorder,inorderIndex+1,end,postIndex);\\n        root->left=solve(inorder,postorder,start,inorderIndex-1,postIndex);\\n        \\n        return root;\\n    }\\n    \\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n\\n        for(int i=0;i<inorder.size();i++){\\n           m[inorder[i]] = i;\\n            \\n        }\\n        int postIndex=postorder.size()-1;\\n        return solve(inorder,postorder,0,postorder.size()-1,postIndex);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34801,
                "title": "python-easy-to-understand-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def buildTree1(self, inorder, postorder):\\n        if not inorder:\\n            return None\\n        idx = inorder.index(postorder.pop())\\n        root = TreeNode(inorder[idx])\\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\\n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:])\\n        return root\\n    \\n    def buildTree(self, inorder, postorder):   \\n        if inorder:\\n            ind = inorder.index(postorder.pop())\\n            root = TreeNode(inorder[ind])\\n            root.right = self.buildTree(inorder[ind+1:], postorder)\\n            root.left = self.buildTree(inorder[:ind], postorder)\\n            return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def buildTree1(self, inorder, postorder):\\n        if not inorder:\\n            return None\\n        idx = inorder.index(postorder.pop())\\n        root = TreeNode(inorder[idx])\\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\\n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:])\\n        return root\\n    \\n    def buildTree(self, inorder, postorder):   \\n        if inorder:\\n            ind = inorder.index(postorder.pop())\\n            root = TreeNode(inorder[ind])\\n            root.right = self.buildTree(inorder[ind+1:], postorder)\\n            root.left = self.buildTree(inorder[:ind], postorder)\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302357,
                "title": "awesome-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:90%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:80%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not inorder or not postorder:\\n            return None\\n        root=TreeNode(postorder[-1])\\n        index=inorder.index(postorder[-1])\\n        root.left=self.buildTree(inorder[:index],postorder[:index])\\n        root.right=self.buildTree(inorder[index+1:],postorder[index:-1])\\n        return root\\n    #please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not inorder or not postorder:\\n            return None\\n        root=TreeNode(postorder[-1])\\n        index=inorder.index(postorder[-1])\\n        root.left=self.buildTree(inorder[:index],postorder[:index])\\n        root.right=self.buildTree(inorder[index+1:],postorder[index:-1])\\n        return root\\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491447,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Inorder: `<LEFT><ROOT><RIGHT>`, postorder: `<LEFT><RIGHT><ROOT>`\\n2. The last element of postorder will always be the root of a subtree. We can furter determine its left and right subtree by finding its position in the inorder array. \\n<img src=\"https://assets.leetcode.com/users/aminick/image_1580110093.png\" width=600px>\\n\\n``` javascript\\n/**\\n * @param {number[]} inorder\\n * @param {number[]} postorder\\n * @return {TreeNode}\\n */\\nvar buildTree = function(inorder, postorder) {    \\n    let hash = {};\\n    for (let i=0;i<inorder.length;i++) hash[inorder[i]] = i; \\n    \\n    let recur = function(start, end) {\\n        if (start > end) return null;\\n        let val = postorder.pop();\\n        let root = new TreeNode(val);\\n        root.right = recur(hash[val] + 1, end);\\n        root.left = recur(start, hash[val] - 1);\\n        return root;\\n    }\\n    \\n    return recur(0, inorder.length - 1);  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[]} inorder\\n * @param {number[]} postorder\\n * @return {TreeNode}\\n */\\nvar buildTree = function(inorder, postorder) {    \\n    let hash = {};\\n    for (let i=0;i<inorder.length;i++) hash[inorder[i]] = i; \\n    \\n    let recur = function(start, end) {\\n        if (start > end) return null;\\n        let val = postorder.pop();\\n        let root = new TreeNode(val);\\n        root.right = recur(hash[val] + 1, end);\\n        root.left = recur(start, hash[val] - 1);\\n        return root;\\n    }\\n    \\n    return recur(0, inorder.length - 1);  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588854,
                "title": "c-simple-and-clean-recursive-solution-with-explanation-no-map",
                "content": "**Explanation:**\\nWhen we do an inorder traversal, we have the left subtree, then somewhere in the middle the root, then the right subtree.\\nWhen we do postorder traversal, we have the root at the end.\\n\\nSo we have `m_curr` to go from the end of `m_postorder` - this will be the root at each iteration.\\nNow, we have the value of the root, we try to find that value in `m_inorder`.\\nOnce we found the index of the root in `m_inorder`, we know that the subarray in the left belongs to the left subtree and the right subarray is the right subtree.\\nSo all we need to do is create the current root from that value and send to a recursive call with the right indices.\\nWe also decrease `m_curr` to have the next subtree\\'s root.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* rec(int l, int r) {\\n        if (l > r) return NULL;\\n        \\n        int i = 0;\\n        while (m_inorder[i] != m_postorder[m_curr]) {\\n            i++;\\n        }\\n        \\n        m_curr--;\\n        TreeNode* node = new TreeNode(m_inorder[i]);\\n        node->right = rec(i+1, r);\\n        node->left = rec(l, i-1);\\n        return node;\\n        \\n    }\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        m_postorder = postorder, m_inorder = inorder, m_curr = inorder.size()-1;\\n        return rec(0, postorder.size()-1);\\n    }\\n    \\nprivate:\\n    int m_curr;\\n    vector<int> m_postorder, m_inorder;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* rec(int l, int r) {\\n        if (l > r) return NULL;\\n        \\n        int i = 0;\\n        while (m_inorder[i] != m_postorder[m_curr]) {\\n            i++;\\n        }\\n        \\n        m_curr--;\\n        TreeNode* node = new TreeNode(m_inorder[i]);\\n        node->right = rec(i+1, r);\\n        node->left = rec(l, i-1);\\n        return node;\\n        \\n    }\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        m_postorder = postorder, m_inorder = inorder, m_curr = inorder.size()-1;\\n        return rec(0, postorder.size()-1);\\n    }\\n    \\nprivate:\\n    int m_curr;\\n    vector<int> m_postorder, m_inorder;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34849,
                "title": "my-comprehension-of-o-n-solution-from-hongzhi",
                "content": "Below is the O(n) solution from @hongzhi but that discuss is closed now 'cause @hongzhi says little about his code. \\n\\nhttps://oj.leetcode.com/discuss/6334/here-is-my-o-n-solution-is-it-neat\\n\\nI've modified some of and tried this code and got AC.\\nJust share about some comprehension about his code.\\n\\nI've modified vtn(vector) to stn(stack) in that **stack** is probably what this algs means and needs.\\n\\nWhat matters most is the meaning of *stn*. \\n\\nOnly nodes whoes left side **hasn't been** handled will be pushed into *stn*.\\n\\nAnd inorder is organized as (inorder of left) root (inorder of right),\\n\\nAnd postorder is as (postorder of left) (postorder of right) root.\\n\\nSo at the very begin, we only have root in stn and we check if *inorder.back() == root->val* and in most cases it's **false**(see Note 1). Then we make this node root's right sub-node and push it into stn. \\n\\n**Note 1: this is actually *(inorder of right).back() == (postorder of right).back()*, so if only there's no right subtree or the answer will always be false.**\\n\\n**Note 2: we delete one node from *postorder* as we push one into stn.**\\n\\nNow we have [root, root's right] as stn and we check *inorder.back() == stn.top()->val* again. \\n\\n - **true** means *inorder.back()* is the root node and needs handled left case.\\n - **false** means *inorder.back()* is the next right sub-node\\n\\nSo when we encounter a true, we will cache *stn.top()* as p and **delete both nodes from inorder and stn**. \\n\\nThen we check inorder.size(), if there's no nodes left, it means p has no left node. \\n\\nElse the next node in inorder could be *p's left node* or *p's father* which equals to the now *stn.top()* (remember we popped *p* from *stn* above). \\n\\nIf the latter happens, it means *p* has **no left node** and we need to move on to *p's father(stn.top())*.\\n\\nIf the former happens, it means *p* has one left node and it's *postorder.back()*, so we put it to p's left and delete it from the *postorder* and push the left node into *stn* 'cause **it** should be the next check node as the *postorder* is organized as above.\\n\\nThat's all of it. The algs just build a binary tree. :)\\n\\nInform me if there's anything vague or wrong, I'm open to any suggestions.\\n\\n    class Solution {\\n    public:\\n        TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\\n            if(inorder.size() == 0)return NULL;\\n            TreeNode *p;\\n            TreeNode *root;\\n            stack<TreeNode *> stn;\\n            \\n            root = new TreeNode(postorder.back()); \\n            stn.push(root); \\n            postorder.pop_back(); \\n            \\n            while(true)\\n            {\\n                if(inorder.back() == stn.top()->val) \\n                {\\n                    p = stn.top();\\n                    stn.pop(); \\n                    inorder.pop_back(); \\n                    if(inorder.size() == 0) break;\\n                    if(stn.size() && inorder.back() == stn.top()->val)\\n                        continue;\\n                    p->left = new TreeNode(postorder.back()); \\n                    postorder.pop_back();\\n                    stn.push(p->left);\\n                }\\n                else \\n                {\\n                    p = new TreeNode(postorder.back());\\n                    postorder.pop_back();\\n                    stn.top()->right = p; \\n                    stn.push(p); \\n                }\\n            }\\n            return root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\\n            if(inorder.size() == 0)return NULL;\\n            TreeNode *p;\\n            TreeNode *root;\\n            stack<TreeNode *> stn;\\n            \\n            root = new TreeNode(postorder.back()); \\n            stn.push(root); \\n            postorder.pop_back(); \\n            \\n            while(true)\\n            {\\n                if(inorder.back() == stn.top()->val) \\n                {\\n                    p = stn.top();\\n                    stn.pop(); \\n                    inorder.pop_back(); \\n                    if(inorder.size() == 0) break;\\n                    if(stn.size() && inorder.back() == stn.top()->val)\\n                        continue;\\n                    p->left = new TreeNode(postorder.back()); \\n                    postorder.pop_back();\\n                    stn.push(p->left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 34911,
                "title": "my-c-solution",
                "content": "    class Solution {\\n    \\n    public:\\n        TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n            \\n            return helper(inorder,0,inorder.size(),postorder,0,postorder.size());\\n        }\\n    private:\\n        TreeNode* helper(vector<int>& inorder,int i,int j,vector<int>& postorder,int ii,int jj)\\n        {\\n            // \\u6bcf\\u6b21\\u53d6postorder\\u7684\\u6700\\u540e\\u4e00\\u4e2a\\u503cmid\\uff0c\\u5c06\\u5176\\u4f5c\\u4e3a\\u6811\\u7684\\u6839\\u8282\\u70b9\\n            // \\u7136\\u540e\\u4eceinroder\\u4e2d\\u627e\\u5230mid\\uff0c\\u5c06\\u5176\\u5206\\u5272\\u6210\\u4e3a\\u4e24\\u90e8\\u5206\\uff0c\\u5de6\\u8fb9\\u4f5c\\u4e3amid\\u7684\\u5de6\\u5b50\\u6811\\uff0c\\u53f3\\u8fb9\\u4f5c\\u4e3amid\\u7684\\u53f3\\u5b50\\u6811\\n            // tree:     8 4 10 3 6 9 11\\n            // Inorder   [3 4 6] 8 [9 10 11]\\n            // postorder [3 6 4]   [9 11 10] 8\\n    \\n            if(i >= j || ii >= jj)\\n                return NULL;\\n            \\n            int mid = postorder[jj - 1];\\n            \\n            auto f = find(inorder.begin() + i,inorder.begin() + j,mid);\\n            \\n            int dis = f - inorder.begin() - i;\\n            \\n            TreeNode* root = new TreeNode(mid);\\n            root -> left = helper(inorder,i,i + dis,postorder,ii,ii + dis);\\n            root -> right = helper(inorder,i + dis + 1,j,postorder,ii + dis,jj - 1);\\n            \\n            return root;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public:\\n        TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n            \\n            return helper(inorder,0,inorder.size(),postorder,0,postorder.size());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3302302,
                "title": "clean-codes-full-explanation-using-stack-c-java-python3",
                "content": "# Intuition :\\n- Given two integer arrays inorder and postorder ,construct and return the binary tree.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Iterative Approach using Stack\\n- Use the last element in the postorder traversal as the root node, then iterate over the rest of the postorder traversal from right to left. \\n- For each element, we create a new node and add it to the stack. We then check if the new node is the left or right child of the previous node. \\n- If it\\'s the left child, we simply attach it to the previous node. \\n- If it\\'s the right child, we pop the stack until we find the parent node whose left child is the previous node, and attach the new node to its right child. \\n- We repeat this process until we\\'ve processed all the nodes in the postorder traversal.\\n<!-- Describe your approach to solving the problem. -->\\n**Credits to @mayijie88 for helping me out**\\n# Let\\'s See an Example :\\n-  Let\\'s take the following inorder and postorder traversals as an example:\\n```\\ninorder = [9,3,15,20,7]\\npostorder = [9,15,7,20,3]\\n```\\n- So we want to use these traversals to build a binary tree. \\n# Steps to be followed :\\n- Both the inorder and postorder traversals are non-empty, so we can continue.\\n\\n```\\nip = 4 (the index of the last element in the inorder traversal), \\npp = 4 (the index of the last element in the postorder traversal).\\n```\\n- We create an empty `stack` and initialize `prev` to `null`.\\n- We create the root node using the last element in the postorder traversal, which is 3. We push the root node onto the stack and decrement pp to 3.\\n\\n```\\nStack:\\n| 3 |\\n```\\n\\n- We iterate over the rest of the postorder traversal from right to left. The next element is 20. \\n- We create a new node for 20 and push it onto the stack. We check if 20 is the left or right child of the previous node (which is 3). \\n- Since it\\'s the right child, we pop the stack until we find the parent node whose left child is 3, which is null. \\n- We attach 20 as the right child of 3, and push 20 onto the stack. prev is set to null.\\n\\n```\\nStack:\\n| 20 |\\n| 3 |\\n```\\n\\n- The next element is 7. We create a new node for 7 and push it onto the stack. We check if 7 is the left or right child of the previous node (which is 20). \\n- Since it\\'s the right child, we pop the stack until we find the parent node whose left child is 20, which is 3. \\n- We attach 7 as the right child of 20, and push 7 onto the stack. prev is set to null.\\n\\n```\\nStack:\\n| 7 |\\n| 20 |\\n| 3 |\\n```\\n\\n- The next element is 15. We create a new node for 15 and push it onto the stack. We check if 15 is the left or right child of the previous node (which is 7). \\n- Since it\\'s the left child, we attach 15 as the left child of 7, and push 15 onto the stack. prev is set to null.\\n\\n```\\nStack:\\n| 15 |\\n| 7 |\\n| 20 |\\n| 3 |\\n```\\n\\n- The next element is 9. We create a new node for 9 and push it onto the stack. We check if 9 is the left or right child of the previous node (which is 15). \\n- Since it\\'s the left child, we attach 9 as the left child of 15, and push 9 onto the stack. prev is set to null.\\n\\n```\\nStack:\\n| 9 |\\n| 15 |\\n| 7 |\\n| 20 |\\n| 3 |\\n```\\n\\n- We\\'ve processed all the elements in the postorder traversal, so we can return the root node of the binary tree, which is 3.\\n- The resulting binary tree looks like this:\\n```\\n     3\\n   /   \\\\\\n  9     20\\n       /  \\\\\\n     15    7\\n\\n```\\n# Complexity :\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] : With Comments\\n```Java []\\nclass Solution \\n{\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n    // If either of the input arrays are empty, the tree is empty, so return null\\n    if (inorder.length == 0 || postorder.length == 0) return null;\\n    \\n    // Initialize indices to the last elements of the inorder and postorder traversals\\n    int ip = inorder.length - 1;\\n    int pp = postorder.length - 1;\\n\\n    // Create an empty stack to help us build the binary tree\\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    // Initialize prev to null since we haven\\'t processed any nodes yet\\n    TreeNode prev = null;\\n    // Create the root node using the last element in the postorder traversal\\n    TreeNode root = new TreeNode(postorder[pp]);\\n    // Push the root onto the stack and move to the next element in the postorder traversal\\n    stack.push(root);\\n    pp--;\\n\\n    // Process the rest of the nodes in the postorder traversal\\n    while (pp >= 0) {\\n        // While the stack is not empty and the top of the stack is the current inorder element\\n        while (!stack.isEmpty() && stack.peek().val == inorder[ip]) {\\n            // The top of the stack is the parent of the current node, so pop it off the stack and update prev\\n            prev = stack.pop();\\n            ip--;\\n        }\\n        // Create a new node for the current postorder element\\n        TreeNode newNode = new TreeNode(postorder[pp]);\\n        // If prev is not null, the parent of the current node is prev, so attach the node as the left child of prev\\n        if (prev != null) {\\n            prev.left = newNode;\\n        // If prev is null, the parent of the current node is the current top of the stack, so attach the node as the right child of the current top of the stack\\n        } else if (!stack.isEmpty()) {\\n            TreeNode currTop = stack.peek();\\n            currTop.right = newNode;\\n        }\\n        // Push the new node onto the stack, reset prev to null, and move to the next element in the postorder traversal\\n        stack.push(newNode);\\n        prev = null;\\n        pp--;\\n    }\\n\\n    // Return the root of the binary tree\\n    return root;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    // If either of the input vectors are empty, the tree is empty, so return null\\n    if (inorder.size() == 0 || postorder.size() == 0) return nullptr;\\n\\n    // Initialize indices to the last elements of the inorder and postorder traversals\\n    int ip = inorder.size() - 1;\\n    int pp = postorder.size() - 1;\\n\\n    // Create an empty stack to help us build the binary tree\\n    stack<TreeNode*> st;\\n    // Initialize prev to null since we haven\\'t processed any nodes yet\\n    TreeNode* prev = nullptr;\\n    // Create the root node using the last element in the postorder traversal\\n    TreeNode* root = new TreeNode(postorder[pp]);\\n    // Push the root onto the stack and move to the next element in the postorder traversal\\n    st.push(root);\\n    pp--;\\n\\n    // Process the rest of the nodes in the postorder traversal\\n    while (pp >= 0) {\\n        // While the stack is not empty and the top of the stack is the current inorder element\\n        while (!st.empty() && st.top()->val == inorder[ip]) {\\n            // The top of the stack is the parent of the current node, so pop it off the stack and update prev\\n            prev = st.top();\\n            st.pop();\\n            ip--;\\n        }\\n        // Create a new node for the current postorder element\\n        TreeNode* newNode = new TreeNode(postorder[pp]);\\n        // If prev is not null, the parent of the current node is prev, so attach the node as the left child of prev\\n        if (prev != nullptr) {\\n            prev->left = newNode;\\n        // If prev is null, the parent of the current node is the current top of the stack, so attach the node as the right child of the current top of the stack\\n        } else if (!st.empty()) {\\n            TreeNode* currTop = st.top();\\n            currTop->right = newNode;\\n        }\\n        // Push the new node onto the stack, reset prev to null, and move to the next element in the postorder traversal\\n        st.push(newNode);\\n        prev = nullptr;\\n        pp--;\\n    }\\n\\n    // Return the root of the binary tree\\n    return root;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        # If either of the input lists are empty, the tree is empty, so return None\\n        if not inorder or not postorder:\\n            return None\\n\\n        # Initialize indices to the last elements of the inorder and postorder traversals\\n        ip = len(inorder) - 1\\n        pp = len(postorder) - 1\\n\\n        # Create an empty stack to help us build the binary tree\\n        st = []\\n        # Initialize prev to None since we haven\\'t processed any nodes yet\\n        prev = None\\n        # Create the root node using the last element in the postorder traversal\\n        root = TreeNode(postorder[pp])\\n        # Push the root onto the stack and move to the next element in the postorder traversal\\n        st.append(root)\\n        pp -= 1\\n\\n        # Process the rest of the nodes in the postorder traversal\\n        while pp >= 0:\\n            # While the stack is not empty and the top of the stack is the current inorder element\\n            while st and st[-1].val == inorder[ip]:\\n                # The top of the stack is the parent of the current node, so pop it off the stack and update prev\\n                prev = st.pop()\\n                ip -= 1\\n            # Create a new node for the current postorder element\\n            new_node = TreeNode(postorder[pp])\\n            # If prev is not None, the parent of the current node is prev, so attach the node as the left child of prev\\n            if prev:\\n                prev.left = new_node\\n            # If prev is None, the parent of the current node is the current top of the stack, so attach the node as the right child of the current top of the stack\\n            elif st:\\n                curr_top = st[-1]\\n                curr_top.right = new_node\\n            # Push the new node onto the stack, reset prev to None, and move to the next element in the postorder traversal\\n            st.append(new_node)\\n            prev = None\\n            pp -= 1\\n\\n        # Return the root of the binary tree\\n        return root\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/87e7df80-afcb-49bb-a54c-5298664e2f43_1678932835.5335186.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ninorder = [9,3,15,20,7]\\npostorder = [9,15,7,20,3]\\n```\n```\\nip = 4 (the index of the last element in the inorder traversal), \\npp = 4 (the index of the last element in the postorder traversal).\\n```\n```\\nStack:\\n| 3 |\\n```\n```\\nStack:\\n| 20 |\\n| 3 |\\n```\n```\\nStack:\\n| 7 |\\n| 20 |\\n| 3 |\\n```\n```\\nStack:\\n| 15 |\\n| 7 |\\n| 20 |\\n| 3 |\\n```\n```\\nStack:\\n| 9 |\\n| 15 |\\n| 7 |\\n| 20 |\\n| 3 |\\n```\n```\\n     3\\n   /   \\\\\\n  9     20\\n       /  \\\\\\n     15    7\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```Java []\\nclass Solution \\n{\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n    // If either of the input arrays are empty, the tree is empty, so return null\\n    if (inorder.length == 0 || postorder.length == 0) return null;\\n    \\n    // Initialize indices to the last elements of the inorder and postorder traversals\\n    int ip = inorder.length - 1;\\n    int pp = postorder.length - 1;\\n\\n    // Create an empty stack to help us build the binary tree\\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    // Initialize prev to null since we haven\\'t processed any nodes yet\\n    TreeNode prev = null;\\n    // Create the root node using the last element in the postorder traversal\\n    TreeNode root = new TreeNode(postorder[pp]);\\n    // Push the root onto the stack and move to the next element in the postorder traversal\\n    stack.push(root);\\n    pp--;\\n\\n    // Process the rest of the nodes in the postorder traversal\\n    while (pp >= 0) {\\n        // While the stack is not empty and the top of the stack is the current inorder element\\n        while (!stack.isEmpty() && stack.peek().val == inorder[ip]) {\\n            // The top of the stack is the parent of the current node, so pop it off the stack and update prev\\n            prev = stack.pop();\\n            ip--;\\n        }\\n        // Create a new node for the current postorder element\\n        TreeNode newNode = new TreeNode(postorder[pp]);\\n        // If prev is not null, the parent of the current node is prev, so attach the node as the left child of prev\\n        if (prev != null) {\\n            prev.left = newNode;\\n        // If prev is null, the parent of the current node is the current top of the stack, so attach the node as the right child of the current top of the stack\\n        } else if (!stack.isEmpty()) {\\n            TreeNode currTop = stack.peek();\\n            currTop.right = newNode;\\n        }\\n        // Push the new node onto the stack, reset prev to null, and move to the next element in the postorder traversal\\n        stack.push(newNode);\\n        prev = null;\\n        pp--;\\n    }\\n\\n    // Return the root of the binary tree\\n    return root;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    // If either of the input vectors are empty, the tree is empty, so return null\\n    if (inorder.size() == 0 || postorder.size() == 0) return nullptr;\\n\\n    // Initialize indices to the last elements of the inorder and postorder traversals\\n    int ip = inorder.size() - 1;\\n    int pp = postorder.size() - 1;\\n\\n    // Create an empty stack to help us build the binary tree\\n    stack<TreeNode*> st;\\n    // Initialize prev to null since we haven\\'t processed any nodes yet\\n    TreeNode* prev = nullptr;\\n    // Create the root node using the last element in the postorder traversal\\n    TreeNode* root = new TreeNode(postorder[pp]);\\n    // Push the root onto the stack and move to the next element in the postorder traversal\\n    st.push(root);\\n    pp--;\\n\\n    // Process the rest of the nodes in the postorder traversal\\n    while (pp >= 0) {\\n        // While the stack is not empty and the top of the stack is the current inorder element\\n        while (!st.empty() && st.top()->val == inorder[ip]) {\\n            // The top of the stack is the parent of the current node, so pop it off the stack and update prev\\n            prev = st.top();\\n            st.pop();\\n            ip--;\\n        }\\n        // Create a new node for the current postorder element\\n        TreeNode* newNode = new TreeNode(postorder[pp]);\\n        // If prev is not null, the parent of the current node is prev, so attach the node as the left child of prev\\n        if (prev != nullptr) {\\n            prev->left = newNode;\\n        // If prev is null, the parent of the current node is the current top of the stack, so attach the node as the right child of the current top of the stack\\n        } else if (!st.empty()) {\\n            TreeNode* currTop = st.top();\\n            currTop->right = newNode;\\n        }\\n        // Push the new node onto the stack, reset prev to null, and move to the next element in the postorder traversal\\n        st.push(newNode);\\n        prev = nullptr;\\n        pp--;\\n    }\\n\\n    // Return the root of the binary tree\\n    return root;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        # If either of the input lists are empty, the tree is empty, so return None\\n        if not inorder or not postorder:\\n            return None\\n\\n        # Initialize indices to the last elements of the inorder and postorder traversals\\n        ip = len(inorder) - 1\\n        pp = len(postorder) - 1\\n\\n        # Create an empty stack to help us build the binary tree\\n        st = []\\n        # Initialize prev to None since we haven\\'t processed any nodes yet\\n        prev = None\\n        # Create the root node using the last element in the postorder traversal\\n        root = TreeNode(postorder[pp])\\n        # Push the root onto the stack and move to the next element in the postorder traversal\\n        st.append(root)\\n        pp -= 1\\n\\n        # Process the rest of the nodes in the postorder traversal\\n        while pp >= 0:\\n            # While the stack is not empty and the top of the stack is the current inorder element\\n            while st and st[-1].val == inorder[ip]:\\n                # The top of the stack is the parent of the current node, so pop it off the stack and update prev\\n                prev = st.pop()\\n                ip -= 1\\n            # Create a new node for the current postorder element\\n            new_node = TreeNode(postorder[pp])\\n            # If prev is not None, the parent of the current node is prev, so attach the node as the left child of prev\\n            if prev:\\n                prev.left = new_node\\n            # If prev is None, the parent of the current node is the current top of the stack, so attach the node as the right child of the current top of the stack\\n            elif st:\\n                curr_top = st[-1]\\n                curr_top.right = new_node\\n            # Push the new node onto the stack, reset prev to None, and move to the next element in the postorder traversal\\n            st.append(new_node)\\n            prev = None\\n            pp -= 1\\n\\n        # Return the root of the binary tree\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166210,
                "title": "super-simple-java-solution-beat-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    \\n    private int idx;\\n    \\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if (inorder.length != postorder.length) return null;\\n        if (inorder.length == 0) return null;\\n        idx = postorder.length-1;\\n        TreeNode root = build(inorder, postorder, 0, idx);\\n        return root;\\n    }\\n    \\n    private TreeNode build(int[] inorder, int[] postorder, int start, int end) {\\n        if (start>end) return null;\\n        TreeNode node = new TreeNode(postorder[idx--]);\\n        if (start==end) return node;\\n        \\n        int index = findIdx(inorder, node.val, end);\\n        node.right = build(inorder, postorder, index+1, end);\\n        node.left = build(inorder, postorder, start, index-1);\\n        return node;\\n    }\\n    \\n    private int findIdx(int[] inorder, int val, int end) {\\n        for (int i=end; i>=0; i--) {\\n            if (inorder[i]==val) return i;\\n        }\\n        return 0;\\n    }\\n}\\n// TC: O(N^2)\\n// AS: O(N)\\n// The worst case falls into the case when tree is a skew tree\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    \\n    private int idx;\\n    \\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if (inorder.length != postorder.length) return null;\\n        if (inorder.length == 0) return null;\\n        idx = postorder.length-1;\\n        TreeNode root = build(inorder, postorder, 0, idx);\\n        return root;\\n    }\\n    \\n    private TreeNode build(int[] inorder, int[] postorder, int start, int end) {\\n        if (start>end) return null;\\n        TreeNode node = new TreeNode(postorder[idx--]);\\n        if (start==end) return node;\\n        \\n        int index = findIdx(inorder, node.val, end);\\n        node.right = build(inorder, postorder, index+1, end);\\n        node.left = build(inorder, postorder, start, index-1);\\n        return node;\\n    }\\n    \\n    private int findIdx(int[] inorder, int val, int end) {\\n        for (int i=end; i>=0; i--) {\\n            if (inorder[i]==val) return i;\\n        }\\n        return 0;\\n    }\\n}\\n// TC: O(N^2)\\n// AS: O(N)\\n// The worst case falls into the case when tree is a skew tree\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758781,
                "title": "simple-recursive-python-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        if not inorder:\\n            return\\n        \\n        r=postorder.pop() \\n        root=TreeNode(r) \\n        i=inorder.index(r) \\n        \\n        root.right=self.buildTree(inorder[i+1:],postorder) \\n        root.left=self.buildTree(inorder[:i],postorder) \\n        return root\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        if not inorder:\\n            return\\n        \\n        r=postorder.pop() \\n        root=TreeNode(r) \\n        i=inorder.index(r) \\n        \\n        root.right=self.buildTree(inorder[i+1:],postorder) \\n        root.left=self.buildTree(inorder[:i],postorder) \\n        return root\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 34799,
                "title": "c-o-n-dfs-solution-beath-91-submissions",
                "content": "Example\\n\\n           13\\n         /    \\\\\\n        2      3\\n       / \\\\    /\\n      5   6  7\\n            / \\\\\\n           8   9\\n                \\\\\\n                10\\n                /\\n              12\\n\\n    5,  2,  6,  13,  8,  7,  9,  12,  10,  3\\n    ---left--- root  ---------right---------\\n    \\n    5,  6,  2,  8,  12,  10,  9,  7,  3,  13\\n    ---left---\\t---------right---------- root \\n\\nCode\\n\\n    class Solution {\\n    private:\\n            unordered_map<int, int> inm; // inorder map [inorder[i], i]\\n    \\n    public:\\n        TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n            int n = inorder.size(), i = 0;\\n            for(auto val: inorder) inm[val] = i++; // build inm for dfs \\n            \\n            return dfs(inorder, 0, n - 1, postorder, 0, n - 1);\\n        }\\n        \\n        TreeNode* dfs(vector<int>& inorder, int ileft, int iright, vector<int>& postorder, int pleft, int pright) {\\n            if(ileft > iright) return nullptr;\\n            \\n            int val = postorder[pright]; // root value\\n            TreeNode *root = new TreeNode(val);\\n            if(ileft == iright) return root;\\n            \\n            int iroot = inm[val];\\n            int nleft = iroot - ileft; // length of left subtree\\n            root->right = dfs(inorder, iroot + 1, iright, postorder, pleft + nleft, pright - 1);\\n            root->left = dfs(inorder, ileft, iroot - 1, postorder, pleft, pleft + nleft - 1);\\n            \\n            return root;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    private:\\n            unordered_map<int, int> inm; // inorder map [inorder[i], i]\\n    \\n    public:\\n        TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n            int n = inorder.size(), i = 0;\\n            for(auto val: inorder) inm[val] = i++; // build inm for dfs \\n            \\n            return dfs(inorder, 0, n - 1, postorder, 0, n - 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 34963,
                "title": "here-is-my-o-n-solution-is-it-neat",
                "content": "    class Solution {\\n    public:\\n        TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\\n            if(inorder.size() == 0)return NULL;\\n            TreeNode* p;\\n            TreeNode* root;\\n            vector<int> vint;\\n            vector<TreeNode*> vtn;\\n            root = new TreeNode(postorder.back());\\n            vtn.push_back(root);\\n            postorder.pop_back();\\n            while(true)\\n            {\\n                if(inorder.back() == vtn.back()->val)\\n                {\\n                    p = vtn.back();\\n                    vtn.pop_back();\\n                    inorder.pop_back();\\n                    if(inorder.size() == 0) break;\\n    \\t\\t\\t\\tif(vtn.size())\\n    \\t\\t\\t\\t\\tif(inorder.back() == vtn.back()->val)continue;\\n                    p->left = new TreeNode(postorder.back());\\n    \\t\\t\\t\\tpostorder.pop_back();\\n                    vtn.push_back(p->left);\\n                }\\n                else\\n                {\\n                    p = new TreeNode(postorder.back());\\n                    postorder.pop_back();\\n                    vtn.back()->right = p;\\n                    vtn.push_back(p);\\n                }\\n            }\\n    \\t\\treturn root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\\n            if(inorder.size() == 0)return NULL;\\n            TreeNode* p;\\n            TreeNode* root;\\n            vector<int> vint;\\n            vector<TreeNode*> vtn;\\n            root = new TreeNode(postorder.back());\\n            vtn.push_back(root);\\n            postorder.pop_back();\\n            while(true)\\n            {\\n                if(inorder.back() == vtn.back()->val)\\n                {\\n                    p = vtn.back();\\n                    vtn.pop_back();\\n                    inorder.pop_back();\\n                    if(inorder.size() == 0) break;\\n    \\t\\t\\t\\tif(vtn.size())\\n    \\t\\t\\t\\t\\tif(inorder.back() == vtn.back()->val)continue;\\n                    p->left = new TreeNode(postorder.back());\\n    \\t\\t\\t\\tpostorder.pop_back();\\n                    vtn.push_back(p->left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 935170,
                "title": "why-so-complicated-answers-are-so-highly-voted",
                "content": "1 USE A GLOBAL INDEX AND START FROM RIGHT TILL LEFT\\n2 AT THE START, CREATE ROOT, AND SET RIGHT AND LEFT\\n3 RETURN NULL IF (start>end)\\n4 FIND INDEX IF ROOT.VAL IN INORDER AND (start, curr-1) FOR LEFT AND\\n(curr+1, end)  FOR RIGHT.\\n\\n```\\nint postIndex;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n = postorder.length;\\n        if(n==0) return null;\\n        if(n==1) return new TreeNode(postorder[0]);\\n        postIndex = n-1;\\n        return helper(inorder, postorder, 0, n-1);\\n    }\\n    \\n    TreeNode helper(int[] inorder, int[] postorder, int start, int end){\\n        if(start > end) return null;\\n        \\n        TreeNode root = new TreeNode(postorder[postIndex--]);\\n        int curr = findIndex(inorder, root.val);\\n        \\n        root.right = helper(inorder, postorder, curr+1, end);\\n        root.left = helper(inorder, postorder, start, curr-1);\\n        return root;\\n    }\\n    \\n    int findIndex(int[] inorder, int key){\\n        for(int i = inorder.length-1; i>=0; i--){\\n            if(inorder[i] == key) return i;\\n        }\\n        return -1;\\n    }\\n```\\t\\n\\nTHE CODE FOR PREORDER IS EXACTLY THE SAME BUT WE MOVE FROM LEFT TO RIGHT\\nAND SET LEFT AND THEN THE RIGHT CHILD.\\n```\\nint preIndex = 0;\\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\\n        int n = preorder.length;\\n        if(n==0) return null;\\n        if(n==1) return new TreeNode(preorder[0]);\\n        \\n        return helper(preorder, inorder, 0, n-1);\\n    }\\n    \\n    TreeNode helper(int[] preorder, int[] inorder, int start, int end){\\n        if(start > end) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[preIndex++]);\\n        int curr = findIndex(inorder, root.val);\\n        \\n        root.left = helper(preorder, inorder, start, curr-1);\\n        root.right = helper(preorder, inorder, curr+1, end);\\n        return root;\\n    }\\n    \\n    int findIndex(int[] inorder, int key){\\n        for(int i =0; i<inorder.length; i++){\\n            if(inorder[i] == key) return i;\\n        }\\n        return -1;\\n    }\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint postIndex;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n = postorder.length;\\n        if(n==0) return null;\\n        if(n==1) return new TreeNode(postorder[0]);\\n        postIndex = n-1;\\n        return helper(inorder, postorder, 0, n-1);\\n    }\\n    \\n    TreeNode helper(int[] inorder, int[] postorder, int start, int end){\\n        if(start > end) return null;\\n        \\n        TreeNode root = new TreeNode(postorder[postIndex--]);\\n        int curr = findIndex(inorder, root.val);\\n        \\n        root.right = helper(inorder, postorder, curr+1, end);\\n        root.left = helper(inorder, postorder, start, curr-1);\\n        return root;\\n    }\\n    \\n    int findIndex(int[] inorder, int key){\\n        for(int i = inorder.length-1; i>=0; i--){\\n            if(inorder[i] == key) return i;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 212565,
                "title": "python-solution",
                "content": "We illustrate the algorithm with an example. Consider `inorder = [9,3,15,20,7]`, `postorder = [9,15,7,20,3]`. Since, we know that postorder traversal traverses a tree in the order `left subtree -> right subtree -> root`, and inorder traversal traverses a tree in the order `left subtree -> root -> right subtree`, `3` must be thre root of the tree, and values that come after (before) `3` in `inorder` must be in the right (left) subtree of `3`. Repeating the above procedure recursively until each subtree consists of a single node, we finish constructing the whole tree. For example, the right subtree of the root `3` consists of values `15`, `20`, `7`. Furthermore, since `20` comes right after `3` when traversing `postorder` from the right, it is the root of the right subtree of `3`. Finally, since `15` (`7`) comes before (after) `20` in `inorder`, it is the left (right) child of `20`. The same analysis applies to the left subtree of `3`, and the binary tree is given by `3(9)(20(15)(7))`.\\n\\nWe can implement the above algorithm in an iterative fashion. To do this, we first construct a hashmap `idx` which maps a value to its inorder index. This will give us an `O(1)` look up of the inorder indices of values of a root and its child, so that we can decide if the child is a left child or right child of the root. Then we can construct the tree with the help of a `stack`. We iterate over `postorder` from the right and create a TreeNode `node` with the corresponding value `val`. If the head is null, we let `head = node`, and push `head` into the `stack`. Else, if the inorder index `stack[-1]` is smaller than that of `val`, we assign `stack[-1].right = node`, and push `node` into the `stack`. Otherwise, we pop from `stack` to until either `stack` is empty or the inorder index of `stack[-1]` is smaller than that of `node`. We assign `u.left = node` for the last popped node `u` from `stack`, and then push `node` to `stack`. After iterating over `postorder`, we return `head`. \\n\\nTime complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        idx = {}\\n        for i, val in enumerate(inorder):\\n            idx[val] = i\\n        \\n        head = None\\n        stack = []\\n        for i in range(len(postorder)-1, -1, -1):\\n            val = postorder[i]\\n            if not head:\\n                head = TreeNode(val)\\n                stack.append(head)\\n            else:\\n                node = TreeNode(val)\\n                if idx[val] > idx[stack[-1].val]:\\n                    stack[-1].right = node\\n                else:\\n                    while stack and idx[stack[-1].val] > idx[val]:\\n                        u = stack.pop()\\n                    u.left = node\\n                stack.append(node)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        idx = {}\\n        for i, val in enumerate(inorder):\\n            idx[val] = i\\n        \\n        head = None\\n        stack = []\\n        for i in range(len(postorder)-1, -1, -1):\\n            val = postorder[i]\\n            if not head:\\n                head = TreeNode(val)\\n                stack.append(head)\\n            else:\\n                node = TreeNode(val)\\n                if idx[val] > idx[stack[-1].val]:\\n                    stack[-1].right = node\\n                else:\\n                    while stack and idx[stack[-1].val] > idx[val]:\\n                        u = stack.pop()\\n                    u.left = node\\n                stack.append(node)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34802,
                "title": "o-n-recursive-solution-without-hashmap-nor-index",
                "content": "python solution:\\n```python\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        def postdfs(stop):\\n            if postorder and inorder[-1] != stop:\\n                root = TreeNode(postorder.pop())\\n                root.right = postdfs(root.val)\\n                inorder.pop()\\n                root.left = postdfs(stop)\\n                return root\\n        inorder, postorder = inorder[:], postorder[:]\\n        return postdfs(None)\\n\\n# 202 / 202 test cases passed.\\n# Status: Accepted\\n# Runtime: 62 ms\\n# beats 97.20 %\\n```\\nc++ solution:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        vector<int> in(inorder), post(postorder);\\n        return postdfs(in, post, (TreeNode *)NULL);\\n    }\\n\\n    TreeNode * postdfs(vector<int> & in, vector<int> & post, TreeNode * stop) {\\n        if ( post.empty() || (stop && in.back() == stop->val) ) {\\n            return NULL;\\n        }\\n        TreeNode * root = new TreeNode(post.back());\\n        post.pop_back();\\n        root->right = postdfs(in, post, root);\\n        in.pop_back();\\n        root->left = postdfs(in, post, stop);\\n        return root;\\n    }\\n};\\n\\n// 202 / 202 test cases passed.\\n// Status: Accepted\\n// Runtime: 9 ms\\n// beats 91.06 %\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        def postdfs(stop):\\n            if postorder and inorder[-1] != stop:\\n                root = TreeNode(postorder.pop())\\n                root.right = postdfs(root.val)\\n                inorder.pop()\\n                root.left = postdfs(stop)\\n                return root\\n        inorder, postorder = inorder[:], postorder[:]\\n        return postdfs(None)\\n\\n# 202 / 202 test cases passed.\\n# Status: Accepted\\n# Runtime: 62 ms\\n# beats 97.20 %\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        vector<int> in(inorder), post(postorder);\\n        return postdfs(in, post, (TreeNode *)NULL);\\n    }\\n\\n    TreeNode * postdfs(vector<int> & in, vector<int> & post, TreeNode * stop) {\\n        if ( post.empty() || (stop && in.back() == stop->val) ) {\\n            return NULL;\\n        }\\n        TreeNode * root = new TreeNode(post.back());\\n        post.pop_back();\\n        root->right = postdfs(in, post, root);\\n        in.pop_back();\\n        root->left = postdfs(in, post, stop);\\n        return root;\\n    }\\n};\\n\\n// 202 / 202 test cases passed.\\n// Status: Accepted\\n// Runtime: 9 ms\\n// beats 91.06 %\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34905,
                "title": "o-n-c-recursive-solution-23ms-with-comments",
                "content": "    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\\n            unordered_map<int, int> inorder_map;\\n            // we need a map to look up the position of root in inorder, so\\n            // that we can divide the tree into separate subtrees,\\n            // reduces the complexity from n^2 to n assuming good hashing by unodered_map\\n            for (int i = 0; i < inorder.size(); ++i) {\\n                inorder_map[inorder[i]] = i;\\n            }\\n            return buildTreeHelper(postorder, 0, inorder.size()-1, 0, postorder.size()-1, inorder_map);\\n        }\\n        \\n        TreeNode* buildTreeHelper(vector<int>& post, int is, int ie, int ps, int pe, unordered_map<int, int>& inorder_map) {\\n            \\n            if (is > ie || ps > pe) {\\n                return NULL;\\n            }\\n            int root_val = post[pe];\\n            TreeNode* root = new TreeNode(root_val);\\n            int i = inorder_map.find(root_val)->second;\\n            // number of nodes in left subtree\\n            int l = i-is;\\n            root->left = buildTreeHelper(post, is, is+l-1, ps, ps+l-1, inorder_map);\\n            root->right = buildTreeHelper(post, is+l+1, ie, ps+l, pe-1, inorder_map);\\n            \\n            return root;\\n        }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\\n            unordered_map<int, int> inorder_map;\\n            // we need a map to look up the position of root in inorder, so\\n            // that we can divide the tree into separate subtrees,\\n            // reduces the complexity from n^2 to n assuming good hashing by unodered_map\\n            for (int i = 0; i < inorder.size(); ++i) {\\n                inorder_map[inorder[i]] = i;\\n            }\\n            return buildTreeHelper(postorder, 0, inorder.size()-1, 0, postorder.size()-1, inorder_map);\\n        }\\n        \\n        TreeNode* buildTreeHelper(vector<int>& post, int is, int ie, int ps, int pe, unordered_map<int, int>& inorder_map) {\\n            \\n            if (is > ie || ps > pe) {\\n                return NULL;\\n            }\\n            int root_val = post[pe];\\n            TreeNode* root = new TreeNode(root_val);\\n            int i = inorder_map.find(root_val)->second;\\n            // number of nodes in left subtree\\n            int l = i-is;\\n            root->left = buildTreeHelper(post, is, is+l-1, ps, ps+l-1, inorder_map);\\n            root->right = buildTreeHelper(post, is+l+1, ie, ps+l, pe-1, inorder_map);\\n            \\n            return root;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3302713,
                "title": "day-75-divide-and-conquer-hash-table-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThe problem is to construct a binary tree from inorder and postorder traversals of the tree. The inorder traversal gives the order of nodes in the left subtree, root, and right subtree, while the postorder traversal gives the order of nodes in the left subtree, right subtree, and root.\\n\\n**The intuition behind the algorithm is to start by identifying the root of the binary tree from the last element of the postorder traversal. Then, we can use the root to divide the inorder traversal into left and right subtrees. We can then recursively apply the same process to the left and right subtrees to construct the entire binary tree.**\\n\\nTo do this efficiently, we can use a hash map to store the indices of elements in the inorder traversal. This allows us to quickly find the position of the root in the inorder traversal and divide the traversal into left and right subtrees.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Create a function called buildTree that takes in two vectors, inorder and postorder, and returns a pointer to the root of the resulting binary tree.\\n2. Initialize an integer variable postorderIndex to postorder.size() - 1. This variable will be used to traverse the postorder vector in reverse order.\\n3. Initialize an empty unordered map called inorderIndexUmp. This map will be used to quickly look up the index of a value in the inorder vector.\\n4. Loop through the inorder vector and insert each value and its index into the inorderIndexUmp map.\\n5. Call a recursive helper function called buildTreeHelper with parameters postorder, 0, and postorder.size() - 1. This function will return the root of the binary tree.\\n6. In the buildTreeHelper function, if left is greater than right, return nullptr.\\n7. Get the root value from the postorder vector using the postorderIndex variable, and decrement postorderIndex.\\n8. Create a new TreeNode with the root value and assign it to a pointer variable called root.\\n9. Get the index of the root value in the inorder vector from the inorderIndexUmp map, and assign it to an integer variable called inorderPivotIndex.\\n10. Recursively call buildTreeHelper with parameters postorder, inorderPivotIndex + 1, and right. Assign the result to root -> right.\\n11. Recursively call buildTreeHelper with parameters postorder, left, and inorderPivotIndex - 1. Assign the result to root -> left.\\n12. Return root.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int postorderIndex;\\n    unordered_map<int, int> inorderIndexUmp;\\n\\n    TreeNode* buildTreeHelper(vector<int>& postorder, int left, int right) {\\n        if (left > right)\\n            return nullptr;\\n        int rootValue = postorder[postorderIndex--];\\n        TreeNode* root = new TreeNode(rootValue);\\n        int inorderPivotIndex = inorderIndexUmp[rootValue];\\n        //think about it...why I took root -> right first then root -> left ?\\n        root -> right = buildTreeHelper(postorder, inorderPivotIndex + 1, right);\\n        root -> left = buildTreeHelper(postorder, left, inorderPivotIndex - 1);\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        postorderIndex = postorder.size() - 1;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            inorderIndexUmp[inorder[i]] = i;\\n        }\\n        return buildTreeHelper(postorder, 0, postorder.size() - 1);\\n    }\\n};\\n```\\n```Java []\\nclass TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n    TreeNode() {}\\n    TreeNode(int val) { this.val = val; }\\n    TreeNode(int val, TreeNode left, TreeNode right) {\\n        this.val = val;\\n        this.left = left;\\n        this.right = right;\\n    }\\n}\\n\\nclass Solution {\\n    int postorderIndex;\\n    Map<Integer, Integer> inorderIndexUmp;\\n\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        postorderIndex = postorder.length - 1;\\n        inorderIndexUmp = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < inorder.length; i++) {\\n            inorderIndexUmp.put(inorder[i], i);\\n        }\\n        return buildTreeHelper(postorder, 0, postorder.length - 1);\\n    }\\n\\n    private TreeNode buildTreeHelper(int[] postorder, int left, int right) {\\n        if (left > right)\\n            return null;\\n        int rootValue = postorder[postorderIndex--];\\n        TreeNode root = new TreeNode(rootValue);\\n        int inorderPivotIndex = inorderIndexUmp.get(rootValue);\\n        root.right = buildTreeHelper(postorder, inorderPivotIndex + 1, right);\\n        root.left = buildTreeHelper(postorder, left, inorderPivotIndex - 1);\\n        return root;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def buildTreeHelper(self, postorder: List[int], left: int, right: int) -> TreeNode:\\n        if left > right:\\n            return None\\n        root_value = postorder[self.postorder_index]\\n        self.postorder_index -= 1\\n        root = TreeNode(root_value)\\n        inorder_pivot_index = self.inorder_index_map[root_value]\\n        root.right = self.buildTreeHelper(postorder, inorder_pivot_index + 1, right)\\n        root.left = self.buildTreeHelper(postorder, left, inorder_pivot_index - 1)\\n        return root\\n\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        self.postorder_index = len(postorder) - 1\\n        self.inorder_index_map = {val: i for i, val in enumerate(inorder)}\\n        return self.buildTreeHelper(postorder, 0, len(postorder) - 1)\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity : **O(n)**, The buildTreeHelper() function is called for each node in the tree exactly once, and the time complexity of each call is O(1). Therefore, the overall time complexity of the algorithm is O(n), where n is the number of nodes in the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(n)**, where n is the number of nodes in the tree. This is because we are creating a new TreeNode object for each node in the tree, and we are also using an unordered_map to store the indices of the nodes in the inorder traversal. Additionally, the recursive calls to buildTreeHelper() create a call stack of size O(n) in the worst case, where n is the number of nodes in the tree.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n**YOU CAN ALSO TRY BELOW PROBLWM WHICH IS SIMILAR TO THIS PROBLEM**\\n105. Construct Binary Tree from Preorder and Inorder Traversal\\n**SOLUTION :**\\nhttps://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/3303059/divide-and-conquer-hash-table-easiest-beginner-friendly-sol/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Divide and Conquer"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int postorderIndex;\\n    unordered_map<int, int> inorderIndexUmp;\\n\\n    TreeNode* buildTreeHelper(vector<int>& postorder, int left, int right) {\\n        if (left > right)\\n            return nullptr;\\n        int rootValue = postorder[postorderIndex--];\\n        TreeNode* root = new TreeNode(rootValue);\\n        int inorderPivotIndex = inorderIndexUmp[rootValue];\\n        //think about it...why I took root -> right first then root -> left ?\\n        root -> right = buildTreeHelper(postorder, inorderPivotIndex + 1, right);\\n        root -> left = buildTreeHelper(postorder, left, inorderPivotIndex - 1);\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        postorderIndex = postorder.size() - 1;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            inorderIndexUmp[inorder[i]] = i;\\n        }\\n        return buildTreeHelper(postorder, 0, postorder.size() - 1);\\n    }\\n};\\n```\n```Java []\\nclass TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n    TreeNode() {}\\n    TreeNode(int val) { this.val = val; }\\n    TreeNode(int val, TreeNode left, TreeNode right) {\\n        this.val = val;\\n        this.left = left;\\n        this.right = right;\\n    }\\n}\\n\\nclass Solution {\\n    int postorderIndex;\\n    Map<Integer, Integer> inorderIndexUmp;\\n\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        postorderIndex = postorder.length - 1;\\n        inorderIndexUmp = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < inorder.length; i++) {\\n            inorderIndexUmp.put(inorder[i], i);\\n        }\\n        return buildTreeHelper(postorder, 0, postorder.length - 1);\\n    }\\n\\n    private TreeNode buildTreeHelper(int[] postorder, int left, int right) {\\n        if (left > right)\\n            return null;\\n        int rootValue = postorder[postorderIndex--];\\n        TreeNode root = new TreeNode(rootValue);\\n        int inorderPivotIndex = inorderIndexUmp.get(rootValue);\\n        root.right = buildTreeHelper(postorder, inorderPivotIndex + 1, right);\\n        root.left = buildTreeHelper(postorder, left, inorderPivotIndex - 1);\\n        return root;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def buildTreeHelper(self, postorder: List[int], left: int, right: int) -> TreeNode:\\n        if left > right:\\n            return None\\n        root_value = postorder[self.postorder_index]\\n        self.postorder_index -= 1\\n        root = TreeNode(root_value)\\n        inorder_pivot_index = self.inorder_index_map[root_value]\\n        root.right = self.buildTreeHelper(postorder, inorder_pivot_index + 1, right)\\n        root.left = self.buildTreeHelper(postorder, left, inorder_pivot_index - 1)\\n        return root\\n\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        self.postorder_index = len(postorder) - 1\\n        self.inorder_index_map = {val: i for i, val in enumerate(inorder)}\\n        return self.buildTreeHelper(postorder, 0, len(postorder) - 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523304,
                "title": "java-1ms-beats-100-no-map-clean-recursion",
                "content": "105 is same as 106 (almost) here are the comparisons, check the similarity and differences\\n# [105 inorder + preorder](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\\nwe use preorder to create nodes from left to right, whenever we go left, we need to pass current root value as right boundary for it\\'s whole left sub tree(root has no boundary, so used 3001 as valid nodes are from 1-3000, you could use Integer.MAX_VALUE), so that the left sub tree creation will know when to exit to go right subtree, the right bounary of right subtree is right subtree\\'s parent\\'s parent which was passed in.\\n```java\\nclass Solution { // TC: O(n), SC: O(height)\\n   int i, p; // i as index for inorder, p as index for preorder\\n   public TreeNode buildTree(int[] pre, int[] in) {\\n      i = p = 0;\\n      return dfs(pre, in, 3001);\\n   }\\n\\n   private TreeNode dfs(int[] pre, int[] in, int rightBoundary) {\\n      if (p == pre.length || in[i] == rightBoundary) return null;\\n\\n      TreeNode node = new TreeNode(pre[p++]);\\n      node.left  = dfs(pre, in, node.val);\\n      i++;\\n      node.right = dfs(pre, in, rightBoundary);\\n      return node;\\n   }\\n}\\n```\\n# [106 inorder + postorder](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\\nAlmost exactly same as above, but we go backwards and create right sub tree first (and check for left boundary as end because we scan backwards right to left)\\n```java\\nclass Solution {\\n    int i, o; // i: inorder traversal idx, o: postorder traversal idx;\\n    public TreeNode buildTree(int[] in, int[] po) {\\n        i = o = po.length - 1;\\n        return dfs(in, po, 3001);\\n    }\\n    \\n    private TreeNode dfs(int[] in, int[] po, int leftBoundary) {\\n        if (o == -1 || in[i] == leftBoundary) return null;\\n        TreeNode node = new TreeNode(po[o--]);\\n        node.right = dfs(in, po, node.val);\\n        i--;\\n        node.left  = dfs(in, po, leftBoundary);\\n        return node;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution { // TC: O(n), SC: O(height)\\n   int i, p; // i as index for inorder, p as index for preorder\\n   public TreeNode buildTree(int[] pre, int[] in) {\\n      i = p = 0;\\n      return dfs(pre, in, 3001);\\n   }\\n\\n   private TreeNode dfs(int[] pre, int[] in, int rightBoundary) {\\n      if (p == pre.length || in[i] == rightBoundary) return null;\\n\\n      TreeNode node = new TreeNode(pre[p++]);\\n      node.left  = dfs(pre, in, node.val);\\n      i++;\\n      node.right = dfs(pre, in, rightBoundary);\\n      return node;\\n   }\\n}\\n```\n```java\\nclass Solution {\\n    int i, o; // i: inorder traversal idx, o: postorder traversal idx;\\n    public TreeNode buildTree(int[] in, int[] po) {\\n        i = o = po.length - 1;\\n        return dfs(in, po, 3001);\\n    }\\n    \\n    private TreeNode dfs(int[] in, int[] po, int leftBoundary) {\\n        if (o == -1 || in[i] == leftBoundary) return null;\\n        TreeNode node = new TreeNode(po[o--]);\\n        node.right = dfs(in, po, node.val);\\n        i--;\\n        node.left  = dfs(in, po, leftBoundary);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758514,
                "title": "2-approaches-easy-to-comprehend-detailed-explanation-c-java",
                "content": "**Explanation:**\\n**Inorder Traversal** -> First visit the left subtree, followed by the root node, followed by the right subtree.\\n**Left -> Root -> Right**\\nPoint of observation: The root node divides the inorder array into 2 halves, left subtree and right subtree.\\n**Postorder Traversal** -> First visit left subtree, followed by the right subtree, followed bt the root node.\\n**Left -> Right -> Root**\\nPoint of observation: The root node is available at the end the of the postorder array. \\n\\nSo, as the first step, we can eaily obtain the value of the root node for the tree (or subtree) from the postorder array by accessessing the last element of the postorder array. Then, it can be observed that the root node divides the inorder array into two halves, the left and right subtree. So, for constructing the tree using postorder and inorder, we will find the find the index of root node in inorder array and then make recursive calls on the left and right subtrees.\\n\\n**Approach 1**\\n\\n**C++ Code:**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n\\t// variable key: \\n\\t// in -> inorder array\\n\\t// ins -> inorder start index\\n\\t// ine -> inorder end index\\n\\t// post -> postorder array\\n\\t// posts -> postorder start index\\n\\t// poste -> postorder end index\\n\\n    TreeNode* buildTreeUtil(vector<int>& in, int ins, int ine, vector<int>& post, int posts, int poste) {\\n        \\n        if(ins>ine || posts>poste) return nullptr;\\n        \\n        int rval=post[poste]; // root value\\n        TreeNode* root = new TreeNode(rval);\\n        \\n        int i=ins;\\n        while(in[i] != rval) i++;\\n        \\n        root->right = buildTreeUtil(in, i+1, ine, post, posts+i-ins, poste-1);\\n        root->left = buildTreeUtil(in, ins, i-1, post, posts, posts+i-(ins+1));\\n        return root;\\n        \\n    }\\n    \\n    TreeNode* buildTree(vector<int>& in, vector<int>& post) {\\n        return buildTreeUtil(in, 0, in.size()-1, post, 0, post.size()-1);\\n    }\\n};\\n```\\n\\n**Java Code:**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n\\t// variable key: \\n\\t// in -> inorder array\\n\\t// ins -> inorder start index\\n\\t// ine -> inorder end index\\n\\t// post -> postorder array\\n\\t// posts -> postorder start index\\n\\t// poste -> postorder end index\\n        \\n    public TreeNode buildTreeUtil(int[] in, int ins, int ine, int[] post, int posts, int poste) {\\n        \\n        if(ins>ine || posts>poste) return null;\\n        \\n        int rval=post[poste]; // root value\\n        TreeNode root = new TreeNode(rval);\\n        \\n        int i=ins;\\n        while(in[i] != rval) i++;\\n        \\n        root.right = buildTreeUtil(in, i+1, ine, post, posts+i-ins, poste-1);\\n        root.left = buildTreeUtil(in, ins, i-1, post, posts, posts+i-(ins+1));\\n        return root;\\n        \\n    }\\n    \\n    public TreeNode buildTree(int[] in, int[] post) {\\n        return buildTreeUtil(in, 0, in.length-1, post, 0, post.length-1);\\n    }\\n}\\n```\\n\\n\\n****Approach 2****\\nNote: (As given in the problem description)\\nYou may assume that duplicates do not exist in the tree.\\n\\nSince we need not worry about the presence of duplicates in the tree, we can simply create an inorder key-value index map to store all values inside Hash Map and easily access the index of any particular node in the inorder traversal of the tree.\\n\\n**C++ Code:**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* buildTreeUtil(vector<int>& post, int& idx, const int& si, const int& ei) {\\n        if (si>ei) return NULL;\\n        TreeNode* root = new TreeNode(post[idx]);\\n        int mid = mp[post[idx]];\\n        idx--;\\n        root->right = buildTreeUtil(post, idx, mid+1, ei);\\n        root->left = buildTreeUtil(post, idx, si, mid-1);\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& in, vector<int>& post) {\\n        for(int i=0; i<in.size(); i++) mp[in[i]]=i;\\n        int idx=post.size()-1;\\n        return buildTreeUtil(post, idx, 0, in.size()-1);\\n    }\\n};\\n```\\n\\n**Java Code:**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public TreeNode buildTreeUtil(int[] post, int idx, int si, int ei, Map<Integer, Integer> mp) {\\n        \\n        if (si>ei) return null;\\n        TreeNode root = new TreeNode(post[idx]);\\n\\n        int mid = mp.get(post[idx]);\\n        idx--;\\n\\n        root.right = buildTreeUtil(post, idx, mid+1, ei, mp);\\n        root.left = buildTreeUtil(post, idx-(ei-mid), si, mid-1, mp);\\n        return root;\\n    }\\n\\n    public TreeNode buildTree(int[] in, int[] post) {\\n        \\n        Map<Integer, Integer> mp = new HashMap<Integer, Integer>();\\n        for(int i=0; i<in.length; i++) mp.put(in[i], i);\\n        return buildTreeUtil(post, post.length-1, 0, in.length-1, mp);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n\\t// variable key: \\n\\t// in -> inorder array\\n\\t// ins -> inorder start index\\n\\t// ine -> inorder end index\\n\\t// post -> postorder array\\n\\t// posts -> postorder start index\\n\\t// poste -> postorder end index\\n\\n    TreeNode* buildTreeUtil(vector<int>& in, int ins, int ine, vector<int>& post, int posts, int poste) {\\n        \\n        if(ins>ine || posts>poste) return nullptr;\\n        \\n        int rval=post[poste]; // root value\\n        TreeNode* root = new TreeNode(rval);\\n        \\n        int i=ins;\\n        while(in[i] != rval) i++;\\n        \\n        root->right = buildTreeUtil(in, i+1, ine, post, posts+i-ins, poste-1);\\n        root->left = buildTreeUtil(in, ins, i-1, post, posts, posts+i-(ins+1));\\n        return root;\\n        \\n    }\\n    \\n    TreeNode* buildTree(vector<int>& in, vector<int>& post) {\\n        return buildTreeUtil(in, 0, in.size()-1, post, 0, post.size()-1);\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n\\t// variable key: \\n\\t// in -> inorder array\\n\\t// ins -> inorder start index\\n\\t// ine -> inorder end index\\n\\t// post -> postorder array\\n\\t// posts -> postorder start index\\n\\t// poste -> postorder end index\\n        \\n    public TreeNode buildTreeUtil(int[] in, int ins, int ine, int[] post, int posts, int poste) {\\n        \\n        if(ins>ine || posts>poste) return null;\\n        \\n        int rval=post[poste]; // root value\\n        TreeNode root = new TreeNode(rval);\\n        \\n        int i=ins;\\n        while(in[i] != rval) i++;\\n        \\n        root.right = buildTreeUtil(in, i+1, ine, post, posts+i-ins, poste-1);\\n        root.left = buildTreeUtil(in, ins, i-1, post, posts, posts+i-(ins+1));\\n        return root;\\n        \\n    }\\n    \\n    public TreeNode buildTree(int[] in, int[] post) {\\n        return buildTreeUtil(in, 0, in.length-1, post, 0, post.length-1);\\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* buildTreeUtil(vector<int>& post, int& idx, const int& si, const int& ei) {\\n        if (si>ei) return NULL;\\n        TreeNode* root = new TreeNode(post[idx]);\\n        int mid = mp[post[idx]];\\n        idx--;\\n        root->right = buildTreeUtil(post, idx, mid+1, ei);\\n        root->left = buildTreeUtil(post, idx, si, mid-1);\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& in, vector<int>& post) {\\n        for(int i=0; i<in.size(); i++) mp[in[i]]=i;\\n        int idx=post.size()-1;\\n        return buildTreeUtil(post, idx, 0, in.size()-1);\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public TreeNode buildTreeUtil(int[] post, int idx, int si, int ei, Map<Integer, Integer> mp) {\\n        \\n        if (si>ei) return null;\\n        TreeNode root = new TreeNode(post[idx]);\\n\\n        int mid = mp.get(post[idx]);\\n        idx--;\\n\\n        root.right = buildTreeUtil(post, idx, mid+1, ei, mp);\\n        root.left = buildTreeUtil(post, idx-(ei-mid), si, mid-1, mp);\\n        return root;\\n    }\\n\\n    public TreeNode buildTree(int[] in, int[] post) {\\n        \\n        Map<Integer, Integer> mp = new HashMap<Integer, Integer>();\\n        for(int i=0; i<in.length; i++) mp.put(in[i], i);\\n        return buildTreeUtil(post, post.length-1, 0, in.length-1, mp);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758465,
                "title": "javascript-concise-solution",
                "content": "Facts,\\n1. The `root` is at the end of `postorder`\\n2.  `inorder` is of the form `[...leftinorder, root, ...rightinorder]`\\n3.  `postorder` is of the form `[...leftpostorder, ...rightpostorder, root]`\\n4.  `leftinorder.length === leftpostorder.length`\\n5.  `rightinorder.length === rightpostorder.length`\\n\\nSolution,\\n```\\nvar buildTree = function(inorder, postorder) {\\n    if (inorder.length === 0) return null;\\n\\n    let root = postorder[postorder.length - 1];\\n    let pivot = inorder.indexOf(root);\\n\\n    return {\\n        val: root,\\n        left: buildTree(inorder.slice(0, pivot), postorder.slice(0, pivot)),\\n        right: buildTree(inorder.slice(pivot + 1), postorder.slice(pivot, -1))\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar buildTree = function(inorder, postorder) {\\n    if (inorder.length === 0) return null;\\n\\n    let root = postorder[postorder.length - 1];\\n    let pivot = inorder.indexOf(root);\\n\\n    return {\\n        val: root,\\n        left: buildTree(inorder.slice(0, pivot), postorder.slice(0, pivot)),\\n        right: buildTree(inorder.slice(pivot + 1), postorder.slice(pivot, -1))\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588887,
                "title": "python-arriving-at-an-o-n-solution",
                "content": "Initial answer/thought process:\\n\\nWell -- the first thing I notice with the provided example (inorder: [9,3,15,20,7], postorder: [9,15,7,20,3]) is that the root is the last value in postorder. Next, we can see that all the values to the left of this root (3) in inorder are in the root\\'s left subtree, and all of the values to the right of the root in order are in the root\\'s right subtree. So, we get some intuition that a recursive approach here might work.\\n\\nLet\\'s pop off the root in postorder -- the last element -- and then get its left and right subtrees:\\n\\nnew postorder: [9, 15, 7, 20]\\nleft inorder: [9]\\nright inorder: [15, 20, 7]\\n\\nSo we can make the root, and now we need to handle making the left subtree and the right subtree with these values. Well, what I noticed is that the root of the right subtree is now the last value in the new postorder -- aha! The recursive approach becomes clear. We need to recursively repeat this process with the right subtree until there\\'s nothing else in this right subtree, and then the only nodes left in the trimmed postorders are in the left subtree, so we can then handle that case:\\n\\n\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not (inorder and postorder):\\n            return None\\n        r_val = postorder.pop()\\n        left = inorder[:inorder.index(r_val)]\\n        right = inorder[inorder.index(r_val) + 1:]\\n        root = TreeNode(r_val)\\n        root.right = self.buildTree(right, postorder)\\n        root.left = self.buildTree(left, postorder)\\n        return root\\n\\nTime: 39th percentile\\nSpace: 39th percentile\\n\\nMaking sublists and using the index function is a bit suspicious/slow in time and space. Annoyingly, this means we\\'ll have to make the \"niceness\" of this solution a little harder to follow for the sake of saving time and space. First, we don\\'t want to use O(N) functions in recursive calls, so we should spot these inefficiencies and think of how to shorten them to O(1) time. The one that sticks out to me here is using index, since that\\'s a linear search. Instead, we can just make a hashmap that maps values to their index in inorder. This of course is still O(N), but we only need to do this once so that recursive calls can just use this map to find the appropriate index in O(1) time. Next, instead of making sublists, we can just store the indices for the bounds on the array we\\'d normally shrink. Essentially we\\'re virtually shrinking the array. The result is a better solution in terms of time and space, but it\\'s a bit more confusing to understand:\\n\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        m = {}\\n        for idx, r in enumerate(inorder):\\n            m[r] = idx\\n        def help(left, right):\\n            if not (postorder and left <= right):\\n                return None\\n            r_val = postorder.pop()\\n            idx = m[r_val]\\n            root = TreeNode(r_val)\\n            root.right = help(idx + 1, right)\\n            root.left = help(left, idx - 1)\\n            return root\\n        return help(0, len(postorder) - 1)\\n\\nTime: 94th percentile\\nSpace: 90th percentile\\n\\nTough problem to get an efficient solution to.",
                "solutionTags": [
                    "Python"
                ],
                "code": "Initial answer/thought process:\\n\\nWell -- the first thing I notice with the provided example (inorder: [9,3,15,20,7], postorder: [9,15,7,20,3]) is that the root is the last value in postorder. Next, we can see that all the values to the left of this root (3) in inorder are in the root\\'s left subtree, and all of the values to the right of the root in order are in the root\\'s right subtree. So, we get some intuition that a recursive approach here might work.\\n\\nLet\\'s pop off the root in postorder -- the last element -- and then get its left and right subtrees:\\n\\nnew postorder: [9, 15, 7, 20]\\nleft inorder: [9]\\nright inorder: [15, 20, 7]\\n\\nSo we can make the root, and now we need to handle making the left subtree and the right subtree with these values. Well, what I noticed is that the root of the right subtree is now the last value in the new postorder -- aha! The recursive approach becomes clear. We need to recursively repeat this process with the right subtree until there\\'s nothing else in this right subtree, and then the only nodes left in the trimmed postorders are in the left subtree, so we can then handle that case:\\n\\n\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not (inorder and postorder):\\n            return None\\n        r_val = postorder.pop()\\n        left = inorder[:inorder.index(r_val)]\\n        right = inorder[inorder.index(r_val) + 1:]\\n        root = TreeNode(r_val)\\n        root.right = self.buildTree(right, postorder)\\n        root.left = self.buildTree(left, postorder)\\n        return root\\n\\nTime: 39th percentile\\nSpace: 39th percentile\\n\\nMaking sublists and using the index function is a bit suspicious/slow in time and space. Annoyingly, this means we\\'ll have to make the \"niceness\" of this solution a little harder to follow for the sake of saving time and space. First, we don\\'t want to use O(N) functions in recursive calls, so we should spot these inefficiencies and think of how to shorten them to O(1) time. The one that sticks out to me here is using index, since that\\'s a linear search. Instead, we can just make a hashmap that maps values to their index in inorder. This of course is still O(N), but we only need to do this once so that recursive calls can just use this map to find the appropriate index in O(1) time. Next, instead of making sublists, we can just store the indices for the bounds on the array we\\'d normally shrink. Essentially we\\'re virtually shrinking the array. The result is a better solution in terms of time and space, but it\\'s a bit more confusing to understand:\\n\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        m = {}\\n        for idx, r in enumerate(inorder):\\n            m[r] = idx\\n        def help(left, right):\\n            if not (postorder and left <= right):\\n                return None\\n            r_val = postorder.pop()\\n            idx = m[r_val]\\n            root = TreeNode(r_val)\\n            root.right = help(idx + 1, right)\\n            root.left = help(left, idx - 1)\\n            return root\\n        return help(0, len(postorder) - 1)\\n\\nTime: 94th percentile\\nSpace: 90th percentile\\n\\nTough problem to get an efficient solution to.",
                "codeTag": "Python3"
            },
            {
                "id": 34910,
                "title": "concise-recursive-java-code-by-making-slight-modification-to-the-previous-problem",
                "content": "Here I'll show you a comparison of code for Construct Binary Tree from [Problem 105: Preorder and Inorder Traversal][1] and from [Problem 106: Inorder and Postorder Traversal][2].\\n\\nCode for Problem 105:\\n\\n\\n    public static TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return helper(preorder, 0, inorder, 0, inorder.length - 1);\\n    }\\n\\n    public static TreeNode helper(int[] preorder, int preStart, int[] inorder, int inStart, int inEnd) {\\n        if (preStart > preorder.length - 1 || inStart > inEnd)\\n            return null;\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        int target = inStart;\\n        while (inorder[target] != preorder[preStart]) target++;\\n        root.left = helper(preorder, preStart + 1, inorder, inStart, target - 1);\\n        root.right = helper(preorder, preStart + target - inStart + 1, inorder, target + 1, inEnd);\\n\\n        return root;\\n    }\\n\\nCode for Problem 106:\\n\\n\\n    public static TreeNode buildTree(int[] inorder, int[] postorder) {\\n        return helper(postorder, postorder.length - 1, inorder, 0, inorder.length - 1);\\n    }\\n\\n    public static TreeNode helper(int[] postorder, int postStart, int[] inorder, int inStart, int inEnd) {\\n        if (postStart < 0 || inStart > inEnd)\\n            return null;\\n        TreeNode root = new TreeNode(postorder[postStart]);\\n        int target = inStart;\\n        while (inorder[target] != postorder[postStart]) target++;\\n        root.left = helper(postorder, postStart - inEnd + target - 1, inorder, inStart, target - 1);\\n        root.right = helper(postorder, postStart - 1, inorder, target + 1, inEnd);\\n\\n        return root;\\n    }\\n\\nNote that the only difference is, for post-order we traverse from the end of `postorder` and change the way for finding `poststart`.  \\nEnjoy :)\\n  [1]: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\\n  [2]: http://Inorder%20and%20Postorder%20Traversal",
                "solutionTags": [],
                "code": "Here I'll show you a comparison of code for Construct Binary Tree from [Problem 105: Preorder and Inorder Traversal][1] and from [Problem 106: Inorder and Postorder Traversal][2].\\n\\nCode for Problem 105:\\n\\n\\n    public static TreeNode buildTree(int[] preorder, int[] inorder) {\\n        return helper(preorder, 0, inorder, 0, inorder.length - 1);\\n    }\\n\\n    public static TreeNode helper(int[] preorder, int preStart, int[] inorder, int inStart, int inEnd) {\\n        if (preStart > preorder.length - 1 || inStart > inEnd)\\n            return null;\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        int target = inStart;\\n        while (inorder[target] != preorder[preStart]) target++;\\n        root.left = helper(preorder, preStart + 1, inorder, inStart, target - 1);\\n        root.right = helper(preorder, preStart + target - inStart + 1, inorder, target + 1, inEnd);\\n\\n        return root;\\n    }\\n\\nCode for Problem 106:\\n\\n\\n    public static TreeNode buildTree(int[] inorder, int[] postorder) {\\n        return helper(postorder, postorder.length - 1, inorder, 0, inorder.length - 1);\\n    }\\n\\n    public static TreeNode helper(int[] postorder, int postStart, int[] inorder, int inStart, int inEnd) {\\n        if (postStart < 0 || inStart > inEnd)\\n            return null;\\n        TreeNode root = new TreeNode(postorder[postStart]);\\n        int target = inStart;\\n        while (inorder[target] != postorder[postStart]) target++;\\n        root.left = helper(postorder, postStart - inEnd + target - 1, inorder, inStart, target - 1);\\n        root.right = helper(postorder, postStart - 1, inorder, target + 1, inEnd);\\n\\n        return root;\\n    }\\n\\nNote that the only difference is, for post-order we traverse from the end of `postorder` and change the way for finding `poststart`.  \\nEnjoy :)\\n  [1]: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\\n  [2]: http://Inorder%20and%20Postorder%20Traversal",
                "codeTag": "Unknown"
            },
            {
                "id": 1928026,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func buildTree(_ inorder: [Int], _ postorder: [Int]) -> TreeNode? {\\n        guard postorder.count > 0 else { return nil }\\n        \\n        let totalCount = postorder.count\\n        let root = TreeNode(postorder[totalCount - 1])\\n        var rootIndex = -1\\n        \\n        for (i, val) in inorder.enumerated() {\\n            if val == root.val {\\n                rootIndex = i\\n                break\\n            } \\n        }\\n        \\n        let leftCount = rootIndex\\n        let rightCount = totalCount - leftCount - 1\\n        \\n        root.left = buildTree(Array(inorder[0..<leftCount]), Array(postorder[0..<leftCount]))\\n        root.right = buildTree(Array(inorder[1 + leftCount..<totalCount]), Array(postorder[leftCount..<totalCount - 1]))\\n        return root\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func buildTree(_ inorder: [Int], _ postorder: [Int]) -> TreeNode? {\\n        guard postorder.count > 0 else { return nil }\\n        \\n        let totalCount = postorder.count\\n        let root = TreeNode(postorder[totalCount - 1])\\n        var rootIndex = -1\\n        \\n        for (i, val) in inorder.enumerated() {\\n            if val == root.val {\\n                rootIndex = i\\n                break\\n            } \\n        }\\n        \\n        let leftCount = rootIndex\\n        let rightCount = totalCount - leftCount - 1\\n        \\n        root.left = buildTree(Array(inorder[0..<leftCount]), Array(postorder[0..<leftCount]))\\n        root.right = buildTree(Array(inorder[1 + leftCount..<totalCount]), Array(postorder[leftCount..<totalCount - 1]))\\n        return root\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606319,
                "title": "java-solution-1-ms-faster-than-95-05",
                "content": "```\\nclass Solution {\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<inorder.length; i++){\\n            map.put(inorder[i], i);\\n        }\\n        index = postorder.length-1;\\n        return build(inorder, postorder, map, 0, postorder.length-1);\\n    }\\n    \\n    public TreeNode build(int[] inorder, int[] postorder, HashMap<Integer, Integer> map, int start, int end){\\n        if(start > end) return null;\\n        TreeNode root = new TreeNode(postorder[index--]);\\n        int pos = map.get(root.val);\\n        root.right = build(inorder, postorder, map, pos+1, end);\\n        root.left = build(inorder, postorder, map, start, pos-1);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<inorder.length; i++){\\n            map.put(inorder[i], i);\\n        }\\n        index = postorder.length-1;\\n        return build(inorder, postorder, map, 0, postorder.length-1);\\n    }\\n    \\n    public TreeNode build(int[] inorder, int[] postorder, HashMap<Integer, Integer> map, int start, int end){\\n        if(start > end) return null;\\n        TreeNode root = new TreeNode(postorder[index--]);\\n        int pos = map.get(root.val);\\n        root.right = build(inorder, postorder, map, pos+1, end);\\n        root.left = build(inorder, postorder, map, start, pos-1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322738,
                "title": "c-simple-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        return bld(inorder,postorder,0,inorder.size()-1,0,postorder.size()-1);\\n    }\\n    \\n    TreeNode* bld(vector<int>&inorder, vector<int>&postorder, int istart, int iend,\\n                  int pstart,int pend){\\n        if(istart > iend || pstart > pend)\\n            return NULL;\\n        int val = postorder[pend];\\n        \\n        int i = istart;\\n        while(inorder[i] != val) i++;\\n\\n        TreeNode* root = new TreeNode(val);\\n        root->left = bld(inorder, postorder, istart, i-1, pstart, pstart+i-istart-1);\\n        root->right = bld(inorder, postorder, i+1, iend, pend-(iend-i), pend-1);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        return bld(inorder,postorder,0,inorder.size()-1,0,postorder.size()-1);\\n    }\\n    \\n    TreeNode* bld(vector<int>&inorder, vector<int>&postorder, int istart, int iend,\\n                  int pstart,int pend){\\n        if(istart > iend || pstart > pend)\\n            return NULL;\\n        int val = postorder[pend];\\n        \\n        int i = istart;\\n        while(inorder[i] != val) i++;\\n\\n        TreeNode* root = new TreeNode(val);\\n        root->left = bld(inorder, postorder, istart, i-1, pstart, pstart+i-istart-1);\\n        root->right = bld(inorder, postorder, i+1, iend, pend-(iend-i), pend-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302229,
                "title": "c-recursion-map-beat-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& ino, vector<int>& post) {\\n    int i1 = post.size()-1;\\n        return solve(i1,ino,post,0,ino.size()-1);\\n    }\\n    TreeNode* solve(int &i,vector<int> &in,vector<int> &post,int l,int r){\\n        if(l>r)return NULL;\\n        int x = r;\\n        while(post[i] != in[x]){\\n            x--;\\n        }\\n        i--;\\n        TreeNode* root = new TreeNode(in[x]);\\n        root->right = solve(i,in,post,x+1,r);\\n        root->left = solve(i,in,post,l,x-1);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& ino, vector<int>& post) {\\n    int i1 = post.size()-1;\\n        return solve(i1,ino,post,0,ino.size()-1);\\n    }\\n    TreeNode* solve(int &i,vector<int> &in,vector<int> &post,int l,int r){\\n        if(l>r)return NULL;\\n        int x = r;\\n        while(post[i] != in[x]){\\n            x--;\\n        }\\n        i--;\\n        TreeNode* root = new TreeNode(in[x]);\\n        root->right = solve(i,in,post,x+1,r);\\n        root->left = solve(i,in,post,l,x-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302185,
                "title": "java-easy-solution-100-faster-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++) {\\n                map.put(inorder[i], i);\\n           \\n        }\\n        \\n        return helper(map, postorder, 0, inorder.length - 1, 0, postorder.length - 1);\\n        \\n    }\\n    \\n    private TreeNode helper(Map<Integer, Integer> map, int[] postorder, int inLeft, int inRight, int poLeft, int poRight) {\\n        if (inLeft > inRight) {\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(postorder[poRight]);\\n        int inMid = map.get(root.val);\\n        \\n        root.left = helper(map, postorder, inLeft, inMid - 1, poLeft, poLeft + inMid - inLeft - 1);\\n        root.right = helper(map, postorder, inMid + 1, inRight, poRight - inRight + inMid, poRight - 1);\\n        return root;\\n    }\\n\\t\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++) {\\n                map.put(inorder[i], i);\\n           \\n        }\\n        \\n        return helper(map, postorder, 0, inorder.length - 1, 0, postorder.length - 1);\\n        \\n    }\\n    \\n    private TreeNode helper(Map<Integer, Integer> map, int[] postorder, int inLeft, int inRight, int poLeft, int poRight) {\\n        if (inLeft > inRight) {\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(postorder[poRight]);\\n        int inMid = map.get(root.val);\\n        \\n        root.left = helper(map, postorder, inLeft, inMid - 1, poLeft, poLeft + inMid - inLeft - 1);\\n        root.right = helper(map, postorder, inMid + 1, inRight, poRight - inRight + inMid, poRight - 1);\\n        return root;\\n    }\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099342,
                "title": "c-8ms-100-simple-8-line-recursive-explained",
                "content": "# **Solution**\\n```c\\nstruct TreeNode* buildTree(int* inorder, int inlen, int* postorder, int postlen){\\n    if(inlen == 0) return NULL;\\n\\t\\n    // Last elem of postorder must be (sub)tree\\'s root\\n    struct TreeNode* curr = malloc(sizeof(struct TreeNode));\\n    curr->val = postorder[postlen-1];\\n\\t\\n    // Find partition index\\n    int mid = 0;\\n    while(inorder[mid]!=curr->val) ++mid;\\n\\t\\n    curr->left = buildTree(&inorder[0], mid, &postorder[0], mid);\\n    curr->right = buildTree(&inorder[mid+1], inlen-mid-1, &postorder[mid], inlen-mid-1);\\n    return curr;\\n}\\n```\\n\\n# **Explanation**\\nThere are 2 properties that we can use to arrive at our solution.\\nA. In the `postorder` array, the last element **must** be the `root` node.\\nB. In the `inorder` array, all the elements *left* of `root` must belong to `root`s left tree. Similarly, all the elements *right* of `root` must belong to `root`\\'s right tree.\\n\\n## **Divide & Conquer**\\n*Initialisation*\\n1. For any input, ``postorder[postlen-1]`` **must** be the root of the (sub)tree. I named `root` as `curr` for distinction between the tree root & subtree \\'root\\'.\\n2. So, for every function call a `TreeNode` named `curr` with value `postorder[postlen-1]` is made.\\n3. Find the index, `mid`, where `curr` appears in `inorder`. With the index, we can determine `curr`\\'s left and right elements in `postorder` and `inorder` respectively.\\n\\n*Division*\\nBy repeatedly partitioning our input arrays around each function call\\'s subtree root, `curr`, we will narrow down the array until we get a base case where the length of the input array is zero. We will return NULL in that case. This return value will later be assigned to the parent\\'s left/right node as explained in \\'conquer\\'.\\n\\nNote: In effect, each function call divides the tree into smaller subtrees. `curr` each subtree\\'s root.\\n\\n4. Recursively call the function on the left and right subarrays (representing the subtrees).\\nThe array length of the left subtree must be equal to `mid`, the partition index.\\nThe array length of the right subtree must be equal to `inlen-mid-1`. (You can verify using the sample testcase provided!)\\n\\nTranslated into code:\\n```c\\nbuildTree(???, mid, ???, mid);\\n```\\n5. We need to input arrays for `???`. We *could* copy the values into a new array, but since this is C, we can provide the subtree array\\'s starting element *memory address* instead to save space.\\nLength is not a concern and will resolve itself since we input the supposed length of the subtree arrays already.\\nDetermining the mem addess is straightforward for the LEFT recursion call.\\nBut for RIGHT, due to the ordering of elements, `inorder` should start at `mid+1`, not `mid`.\\nYou can verify this using the sample testcase provided in the qn.\\n\\nTranslated into code:\\n```c\\nbuildTree(&inorder[0], mid, &postorder[0], mid); // LEFT\\nbuildTree(&inorder[mid+1], mid, &postorder[mid], mid); // RIGHT\\n```\\n\\n*Conquer*\\n6. The function will either return `NULL` or the \\'root\\' node of a certain subtree.\\n7. Build the tree by assigning `curr`\\'s left and right to the returned value of the recursion calls.\\n8. Profit\\n\\nHope this explanation and solution helps! Cheers\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```c\\nstruct TreeNode* buildTree(int* inorder, int inlen, int* postorder, int postlen){\\n    if(inlen == 0) return NULL;\\n\\t\\n    // Last elem of postorder must be (sub)tree\\'s root\\n    struct TreeNode* curr = malloc(sizeof(struct TreeNode));\\n    curr->val = postorder[postlen-1];\\n\\t\\n    // Find partition index\\n    int mid = 0;\\n    while(inorder[mid]!=curr->val) ++mid;\\n\\t\\n    curr->left = buildTree(&inorder[0], mid, &postorder[0], mid);\\n    curr->right = buildTree(&inorder[mid+1], inlen-mid-1, &postorder[mid], inlen-mid-1);\\n    return curr;\\n}\\n```\n```c\\nbuildTree(???, mid, ???, mid);\\n```\n```c\\nbuildTree(&inorder[0], mid, &postorder[0], mid); // LEFT\\nbuildTree(&inorder[mid+1], mid, &postorder[mid], mid); // RIGHT\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 735108,
                "title": "javascript-clean-dfs",
                "content": "## Solution - 1\\n```javascript\\nvar buildTree = function(inorder, postorder) {\\n    \\n    function callDFS(arr) {\\n        if(!arr.length) return null;\\n        const val = postorder.pop();\\n        const idx = arr.indexOf(val);\\n        const node = new TreeNode(val);\\n        node.right = callDFS(arr.slice(idx+1));\\n        node.left = callDFS(arr.slice(0, idx));\\n        return node;\\n    }\\n    \\n    return callDFS(inorder);\\n};\\n```\\n\\n## Solution - 2: Optimized Using Hash Map\\n```javascript\\nvar buildTree = function(inorder, postorder) {\\n    const map = new Map();\\n    \\n    for(let i = 0; i < inorder.length; i++) {\\n        map.set(inorder[i], i);\\n    }\\n    \\n    function callDFS(start, end) {\\n        if(start > end) return null;\\n        const val = postorder.pop();\\n        const idx = map.get(val);\\n        const node = new TreeNode(val);\\n        node.right = callDFS(idx+1, end);\\n        node.left = callDFS(start, idx-1);\\n        return node;\\n    }\\n    \\n    return callDFS(0, inorder.length-1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar buildTree = function(inorder, postorder) {\\n    \\n    function callDFS(arr) {\\n        if(!arr.length) return null;\\n        const val = postorder.pop();\\n        const idx = arr.indexOf(val);\\n        const node = new TreeNode(val);\\n        node.right = callDFS(arr.slice(idx+1));\\n        node.left = callDFS(arr.slice(0, idx));\\n        return node;\\n    }\\n    \\n    return callDFS(inorder);\\n};\\n```\n```javascript\\nvar buildTree = function(inorder, postorder) {\\n    const map = new Map();\\n    \\n    for(let i = 0; i < inorder.length; i++) {\\n        map.set(inorder[i], i);\\n    }\\n    \\n    function callDFS(start, end) {\\n        if(start > end) return null;\\n        const val = postorder.pop();\\n        const idx = map.get(val);\\n        const node = new TreeNode(val);\\n        node.right = callDFS(idx+1, end);\\n        node.left = callDFS(start, idx-1);\\n        return node;\\n    }\\n    \\n    return callDFS(0, inorder.length-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302204,
                "title": "easy-explanation-video-java-c-python",
                "content": "InOrder Traversal: we visit the left subtree first, then the root node, and then the right subtree\\n4,10,12,15,18,22,24,25,31,35,44,50,66,70,90\\n\\nPostOrder Traversal: we visit the left subtree first, then the right subtree, and then the current node\\n4,12,10,18,24,22,15,31,44,35,66,90,70,50,25\\n\\n![image](https://assets.leetcode.com/users/images/6047cd49-5ad5-4a1d-9ed8-228f59c35fc5_1678925849.7006507.jpeg)\\n\\n# Intuition and Approach\\nThe biggest hint is that the root node is always at end in postOrder Traversal ex:  25 is root node.\\nWe find this root node in Inorder Traversal and all the elements on left i.e 4,10,12,15,18,22,24 act as left subtree and all elements on right 31,35,44,50,66,70,90 act as right subtree. \\n\\nThe above process can be repeated to form left and right subtree again individually\\neg: 4,10,12,15,18,22,24 is Inorder for left and 4,12,10,18,24,22,15 is Post Order for left and here again 15 will act as the root node. \\nHence The idea will be to use Recursion.\\n\\n# Approach \\n1. The buildTree method calls the formBinaryTree method with parameters A, B, 0, A.length-1, 0, and B.length-1. These parameters specify the starting and ending indices of the inorder and postorder traversal arrays.\\n2. create a new TreeNode with the last element of the postorder traversal  as the value. This value represents the root node of the current subtree.\\n3.  search for this value in the inorder traversal array to find the index of the root node.\\n4.   recursively call itself to  form left and right subtree. It passes the parameters as follows:\\nfor left:  start, mid-1, start2, x\\nfor right: mid+1,end,x+1,end2-1\\n\\n// x = end of postOrderTraversal of left subtree\\nx = no of elemnts in leftSubtree + start of postOrder\\n\\n# Improvement\\nInstead of finding the middle node every time in Inorder Traversal, create a hashMap with value as key and position as value.\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/2uRa3e3-Vdc\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public HashMap<Integer,Integer> hashMap;\\n    public TreeNode buildTree(int[] A, int[] B) {\\n        hashMap = new HashMap<>();\\n        for(int i = 0;i<A.length;i++){\\n            hashMap.put(A[i],i);\\n        }\\n        return formBinaryTree(A,B,0,A.length-1,0,B.length-1);\\n    }\\n    \\n    public TreeNode formBinaryTree(int[] inOrder, int [] postOrder, int start, int end , int start2, int end2)      {\\n        if(start > end){\\n            \\n            return  null;\\n        }\\n        TreeNode middle = new TreeNode(postOrder[end2]);\\n        int mid = hashMap.get(middle.val);\\n        \\n        int x = mid-1+start2-start;\\n        middle.left = formBinaryTree(inOrder,postOrder, start, mid-1, start2, x);\\n        middle.right = formBinaryTree(inOrder,postOrder,mid+1,end,x+1,end2-1 );\\n        return middle;\\n    }\\n}\\n```\\n\\n\\n```\\n\\nclass Solution {\\n    public TreeNode buildTree(int[] A, int[] B) {\\n        return formBinaryTree(A,B,0,A.length-1,0,B.length-1);\\n    }\\n    \\n    public TreeNode formBinaryTree(int[] inOrder, int [] postOrder, int start, int end , int start2, int end2)      {\\n        if(start > end){\\n            \\n            return  null;\\n        }\\n        TreeNode middle = new TreeNode(postOrder[end2]);\\n        int mid = 0;\\n        for(int i = start;i<=end;i++){\\n            if(inOrder[i]==middle.val) {\\n                mid = i;\\n                break;\\n            }\\n        }\\n        int noOfElements = mid-1-start;\\n        int x = noOfElements + start2;//i.e the end of postOrderTraversal of left subtree\\n        middle.left = formBinaryTree(inOrder,postOrder, start, mid-1, start2, x);\\n        middle.right = formBinaryTree(inOrder,postOrder,mid+1,end,x+1,end2-1 );\\n        return middle;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        return formBinaryTree(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);\\n    }\\n\\n    TreeNode* formBinaryTree(vector<int>& inOrder, vector<int>& postOrder, int start, int end, int start2, int end2) {\\n        if (start > end) {\\n            return nullptr;\\n        }\\n        TreeNode* middle = new TreeNode(postOrder[end2]);\\n        int mid = 0;\\n        for (int i = start; i <= end; i++) {\\n            if (inOrder[i] == middle->val) {\\n                mid = i;\\n                break;\\n            }\\n        }\\n        int noOfElements = mid - 1 - start;\\n        int x = noOfElements + start2; // i.e the end of postOrderTraversal of left subtree\\n        middle->left = formBinaryTree(inOrder, postOrder, start, mid - 1, start2, x);\\n        middle->right = formBinaryTree(inOrder, postOrder, mid + 1, end, x + 1, end2 - 1);\\n        return middle;\\n    }\\n};\\n```\\n\\n```\\n\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        return self.formBinaryTree(inorder, postorder, 0, len(inorder) - 1, 0, len(postorder) - 1)\\n\\n    def formBinaryTree(self, inOrder: List[int], postOrder: List[int], start: int, end: int, start2: int, end2: int) -> TreeNode:\\n        if start > end:\\n            return None\\n        middle = TreeNode(postOrder[end2])\\n        mid = 0\\n        for i in range(start, end + 1):\\n            if inOrder[i] == middle.val:\\n                mid = i\\n                break\\n        noOfElements = mid - 1 - start\\n        x = noOfElements + start2  # i.e the end of postOrderTraversal of left subtree\\n        middle.left = self.formBinaryTree(inOrder, postOrder, start, mid - 1, start2, x)\\n        middle.right = self.formBinaryTree(inOrder, postOrder, mid + 1, end, x + 1, end2 - 1)\\n        return middle\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public HashMap<Integer,Integer> hashMap;\\n    public TreeNode buildTree(int[] A, int[] B) {\\n        hashMap = new HashMap<>();\\n        for(int i = 0;i<A.length;i++){\\n            hashMap.put(A[i],i);\\n        }\\n        return formBinaryTree(A,B,0,A.length-1,0,B.length-1);\\n    }\\n    \\n    public TreeNode formBinaryTree(int[] inOrder, int [] postOrder, int start, int end , int start2, int end2)      {\\n        if(start > end){\\n            \\n            return  null;\\n        }\\n        TreeNode middle = new TreeNode(postOrder[end2]);\\n        int mid = hashMap.get(middle.val);\\n        \\n        int x = mid-1+start2-start;\\n        middle.left = formBinaryTree(inOrder,postOrder, start, mid-1, start2, x);\\n        middle.right = formBinaryTree(inOrder,postOrder,mid+1,end,x+1,end2-1 );\\n        return middle;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    public TreeNode buildTree(int[] A, int[] B) {\\n        return formBinaryTree(A,B,0,A.length-1,0,B.length-1);\\n    }\\n    \\n    public TreeNode formBinaryTree(int[] inOrder, int [] postOrder, int start, int end , int start2, int end2)      {\\n        if(start > end){\\n            \\n            return  null;\\n        }\\n        TreeNode middle = new TreeNode(postOrder[end2]);\\n        int mid = 0;\\n        for(int i = start;i<=end;i++){\\n            if(inOrder[i]==middle.val) {\\n                mid = i;\\n                break;\\n            }\\n        }\\n        int noOfElements = mid-1-start;\\n        int x = noOfElements + start2;//i.e the end of postOrderTraversal of left subtree\\n        middle.left = formBinaryTree(inOrder,postOrder, start, mid-1, start2, x);\\n        middle.right = formBinaryTree(inOrder,postOrder,mid+1,end,x+1,end2-1 );\\n        return middle;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        return formBinaryTree(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);\\n    }\\n\\n    TreeNode* formBinaryTree(vector<int>& inOrder, vector<int>& postOrder, int start, int end, int start2, int end2) {\\n        if (start > end) {\\n            return nullptr;\\n        }\\n        TreeNode* middle = new TreeNode(postOrder[end2]);\\n        int mid = 0;\\n        for (int i = start; i <= end; i++) {\\n            if (inOrder[i] == middle->val) {\\n                mid = i;\\n                break;\\n            }\\n        }\\n        int noOfElements = mid - 1 - start;\\n        int x = noOfElements + start2; // i.e the end of postOrderTraversal of left subtree\\n        middle->left = formBinaryTree(inOrder, postOrder, start, mid - 1, start2, x);\\n        middle->right = formBinaryTree(inOrder, postOrder, mid + 1, end, x + 1, end2 - 1);\\n        return middle;\\n    }\\n};\\n```\n```\\n\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        return self.formBinaryTree(inorder, postorder, 0, len(inorder) - 1, 0, len(postorder) - 1)\\n\\n    def formBinaryTree(self, inOrder: List[int], postOrder: List[int], start: int, end: int, start2: int, end2: int) -> TreeNode:\\n        if start > end:\\n            return None\\n        middle = TreeNode(postOrder[end2])\\n        mid = 0\\n        for i in range(start, end + 1):\\n            if inOrder[i] == middle.val:\\n                mid = i\\n                break\\n        noOfElements = mid - 1 - start\\n        x = noOfElements + start2  # i.e the end of postOrderTraversal of left subtree\\n        middle.left = self.formBinaryTree(inOrder, postOrder, start, mid - 1, start2, x)\\n        middle.right = self.formBinaryTree(inOrder, postOrder, mid + 1, end, x + 1, end2 - 1)\\n        return middle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302181,
                "title": "complete-explanation-intuition-for-each-step-explained-notes",
                "content": "![image](https://assets.leetcode.com/users/images/ac27336b-6edf-4481-a311-6ac5194959c5_1678928387.4402616.png)\\n![image](https://assets.leetcode.com/users/images/24a38530-e97c-4319-80d4-7b7be35bfc10_1678928391.094104.png)\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getRoot(vector<int>&postorder, map<int, int>&mp, int& rootIdx, int low, int high)\\n    {\\n        if (low > high) return NULL;\\n        \\n        int currRoot = postorder[rootIdx--];\\n        int inorderRootIdx = mp[currRoot];\\n        TreeNode* rootNode = new TreeNode(currRoot);\\n        \\n        rootNode->right = getRoot(postorder, mp, rootIdx, inorderRootIdx + 1, high);\\n        rootNode->left = getRoot(postorder, mp, rootIdx, low, inorderRootIdx - 1);\\n        return rootNode;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) \\n    {\\n        int n = inorder.size();\\n        map<int, int>mp;\\n        for (int i = 0; i < n; i++) mp[inorder[i]] = i; //mentioned that values are unique\\n        \\n        int rootIdx = n - 1;\\n        TreeNode* root = getRoot(postorder, mp, rootIdx, 0, n - 1);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getRoot(vector<int>&postorder, map<int, int>&mp, int& rootIdx, int low, int high)\\n    {\\n        if (low > high) return NULL;\\n        \\n        int currRoot = postorder[rootIdx--];\\n        int inorderRootIdx = mp[currRoot];\\n        TreeNode* rootNode = new TreeNode(currRoot);\\n        \\n        rootNode->right = getRoot(postorder, mp, rootIdx, inorderRootIdx + 1, high);\\n        rootNode->left = getRoot(postorder, mp, rootIdx, low, inorderRootIdx - 1);\\n        return rootNode;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) \\n    {\\n        int n = inorder.size();\\n        map<int, int>mp;\\n        for (int i = 0; i < n; i++) mp[inorder[i]] = i; //mentioned that values are unique\\n        \\n        int rootIdx = n - 1;\\n        TreeNode* root = getRoot(postorder, mp, rootIdx, 0, n - 1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588877,
                "title": "c-simple-recursion-without-the-map-use-detailed-explaination",
                "content": "The Idea is As They Given us Inorder and Postorder\\n\\nas we Know Inorder Fallow --> Left_subtree => Root_Node => Right_subtree Traverse\\n   ans   Postorder Fallow --> Left_subtree => Right_subtree =>Root_Nodetraverse\\nusing Postorder_array We can Find Root_Node Which always lay in Postorder_array last Possition\\nAfter Finding That Root_Node ,First we are going to divide Inorder_array Into Two Part and Postorder Array\\ninto Two part .\\n\\nThen We are going to use Both of the arrays left part to Figur Out Left_subtree\\n                     and Both of the arraysRigth Part to Figur out Right_subtree\\n\\nWe are going to recursively do so until One Of the array dose not got empty\\nLet\\'s take an Example\\n\\n    inorder   = [4 2 5 1 6 3 7]\\n    postorder = [4 5 2 6 7 3 1]\\n\\n    So root would be 1 here and Left array which lay left of 1 is [4 2 5] and Right of 1 is [6 3 7]\\n    so left_inorder_array =  [4 2 5] and right_inorder_arry = [6 3 7]\\n\\n    using 6 [ which is just rigth of 1] we are going to devide Postorder_array into two part\\n    [4 5 2] and [6 7 3]\\n\\n\\n    1st Phase=>        \\n\\t                   1\\n\\n                   /        \\\\\\n\\n                [4 2 5]   [6 3 7]       <= inorder array\\n                [4 5 2]   [6 7 3]       <= postorder array\\n\\nNow we have new freash problem like need to make tree by using inorder = [4 2 5] && postorder =  [4 5 2] for left subtree \\nAND inorder = [6 3 7] && postorder = [6 7 3] for right  subtree \\n**now same process we need to do again and again  until One Of the array dose not got empty\\nRest of the Process show in a diagram Form :)\\n\\n    2nd Phase =>\\n                           1\\n\\n                      /        \\\\\\n                     2          3\\n                [4]    [5]   [6]   [7]       <= inorder array\\n                [4]    [5]   [6]   [7]       <= postorder array\\n\\n\\n3rd Phase =>  \\n\\t             1\\n\\n               /    \\\\\\n              2      3\\n \\n            /  \\\\    /  \\\\             <==== Answer\\n \\n           4    5  6    7 \\n\\n\\n\\nin the helper function, IN_SI  and IN_EI : starting index and ending index for the inorder vector\\nPOST_SI and POST_EI : starting and ending idx for the postorder vector !! (to mark up the part of vector in consideration for that phase of recursion)\\n\\t\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\n    TreeNode*helper(vector<int>&in,vector<int>&post,int IN_SI,int IN_EI,int POST_SI,int POST_EI){\\n    if(IN_SI > IN_EI){\\n        return NULL;\\n    }\\n    int rootdata = post[POST_EI];\\n    int rootindex = -1;\\n     for(int i = IN_SI; i<=IN_EI; i++){\\n         if(in[i] == rootdata){\\n             rootindex = i;\\n             break;\\n         }\\n     }\\n     \\n            int Left_ins = IN_SI;\\n            int Left_ine = rootindex-1;\\n            int Left_posts = POST_SI;\\n            int Left_poste = Left_ine - Left_ins + Left_posts;\\n            int Right_ins = rootindex+1;\\n            int Right_ine = IN_EI;\\n            int Right_posts = Left_poste + 1;\\n            int Right_poste  = POST_EI - 1;  \\n        \\n    TreeNode*root = new TreeNode(rootdata);\\n    root->left = helper(in,post,Left_ins,Left_ine,Left_posts,Left_poste);\\n    root->right = helper(in,post,Right_ins,Right_ine,Right_posts,Right_poste);\\n    return root;\\n            \\n        }\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int size = inorder.size();\\n        return helper(inorder,postorder,0,size-1,0,size-1);\\n    \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode*helper(vector<int>&in,vector<int>&post,int IN_SI,int IN_EI,int POST_SI,int POST_EI){\\n    if(IN_SI > IN_EI){\\n        return NULL;\\n    }\\n    int rootdata = post[POST_EI];\\n    int rootindex = -1;\\n     for(int i = IN_SI; i<=IN_EI; i++){\\n         if(in[i] == rootdata){\\n             rootindex = i;\\n             break;\\n         }\\n     }\\n     \\n            int Left_ins = IN_SI;\\n            int Left_ine = rootindex-1;\\n            int Left_posts = POST_SI;\\n            int Left_poste = Left_ine - Left_ins + Left_posts;\\n            int Right_ins = rootindex+1;\\n            int Right_ine = IN_EI;\\n            int Right_posts = Left_poste + 1;\\n            int Right_poste  = POST_EI - 1;  \\n        \\n    TreeNode*root = new TreeNode(rootdata);\\n    root->left = helper(in,post,Left_ins,Left_ine,Left_posts,Left_poste);\\n    root->right = helper(in,post,Right_ins,Right_ine,Right_posts,Right_poste);\\n    return root;\\n            \\n        }\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int size = inorder.size();\\n        return helper(inorder,postorder,0,size-1,0,size-1);\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646550,
                "title": "python-o-n-by-definition-80-w-comment",
                "content": "Python O(n) by definition.\\n\\n---\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        \\n        ## dictionary\\n        # key: number\\n        # value: index in inorder array\\n        val_index_dict = { num:idx for idx, num in enumerate(inorder) }\\n        \\n        def helper( left, right):\\n            \\n            if left > right:\\n                # Base case:\\n                # return empty node as leaf node\\'s child\\n                return None\\n            \\n            else:\\n                \\n                # Recall:\\n                # definition of postorder traversal: Left, Right, Center\\n                # rebuild with reversed direction ( from right to left )\\n                root = TreeNode( postorder.pop() )\\n                \\n                mid = val_index_dict[ root.val ]\\n                \\n                root.right = helper( mid+1, right)\\n                root.left = helper( left, mid-1 )\\n                return root\\n        # ----------------------------------------------------\\n        \\n        ## Top-down rebuild binary tree with definition\\n        return helper( left = 0, right = len(inorder)-1 )\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Leetcode training session: Binary Tree Traversal](https://leetcode.com/explore/learn/card/data-structure-tree/134/traverse-a-tree/992/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        \\n        ## dictionary\\n        # key: number\\n        # value: index in inorder array\\n        val_index_dict = { num:idx for idx, num in enumerate(inorder) }\\n        \\n        def helper( left, right):\\n            \\n            if left > right:\\n                # Base case:\\n                # return empty node as leaf node\\'s child\\n                return None\\n            \\n            else:\\n                \\n                # Recall:\\n                # definition of postorder traversal: Left, Right, Center\\n                # rebuild with reversed direction ( from right to left )\\n                root = TreeNode( postorder.pop() )\\n                \\n                mid = val_index_dict[ root.val ]\\n                \\n                root.right = helper( mid+1, right)\\n                root.left = helper( left, mid-1 )\\n                return root\\n        # ----------------------------------------------------\\n        \\n        ## Top-down rebuild binary tree with definition\\n        return helper( left = 0, right = len(inorder)-1 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34850,
                "title": "annotated-iterative-solution-with-comments-does-not-modify-parameters",
                "content": "Courtesy of the post by lizhuogo. Details see\\n    https://discuss.leetcode.com/topic/4746/my-comprehension-of-o-n-solution-from-hongzhi/2\\n\\nI thought his explanation is still a bit difficult to understand so I try to give a high-level understanding of this approach and the fundamental reason why it works as intended.\\n\\nThe key here is knowing the patterns of serialized list of inorder and postorder\\ntravesals.\\n\\nIf we traverse from root to the left child and back up, both inorder\\nand postorder traversals give us the same sequence, i.e. they are in\\nthe same direction.\\n```       \\n       1\\n      /\\n    2\\ninorder:  [1, 2]\\npostorder: [1, 2]\\n```\\nwhereas if we traverse from root to right child and back up, inorder and postorder\\ngives us sequences that are reverse of each other.\\n```\\n     1\\n      \\\\\\n       2\\ninorder: [1, 2]\\npostorder: [2, 1]\\n```\\nUsing this observation, and the fact that the last member in postorder array is\\nthe root of current subtree, we can traverse from right to left of the serialized\\nlists and build left and right child accordingly.\\n\\nIf we see postorder and inorder are of same value, we build the left child, else\\nwe build the right child. After each operation, we store the newly created node\\non stack to be the new root of the current subtree of size 1 and later traverse back\\nup.\\n\\nA stack is helpful for storing them because each pop let us go back up a level to\\nthe parent of our current root.\\n\\nCode in Python below with comments:\\n```\\ndef buildTree(self, inorder, postorder):\\n    if len(inorder) == 0: return None\\n    root = TreeNode(postorder[-1])\\n    stack = [root]   \\n    # array indexes, i for inorder array, p for postorder array\\n    i = len(inorder) - 1\\n    p = len(postorder) - 2 # initially root already 'popped' off postorder and stored in stack\\n\\n    # we store values off postorder array and compare top of stack with\\n    # right most member of inorder array (indexed by i)\\n    while True:\\n      # top of stack is same as right most entry of inorder. The first time it\\n      # happens means we reached root of current tree. Then we keep removing them\\n      # since we already built right child nodes with them and they are on stack just so we\\n      # can traverse back up. See the else branch for the actual creation of right child. \\n      if stack[-1].val == inorder[i]:\\n        n = stack.pop()\\n        i -= 1\\n\\n        if i==-1: break\\n        if stack and inorder[i] == stack[-1].val:\\n          # keep removing these values, that is, traverse back up\\n          continue\\n\\n        # finished all the right branch and root itself, now we build left child\\n        # 'n' here was popped from stack which gave us the current root.\\n        n.left = TreeNode(postorder[p])\\n        p -= 1\\n        stack.append(n.left)\\n\\n      else: # mismatch values means we should build right child for current root\\n        n = TreeNode(postorder[p])\\n        p-=1\\n        stack[-1].right = n\\n        stack.append(n)\\n        \\n    return root\\n```",
                "solutionTags": [],
                "code": "```       \\n       1\\n      /\\n    2\\ninorder:  [1, 2]\\npostorder: [1, 2]\\n```\n```\\n     1\\n      \\\\\\n       2\\ninorder: [1, 2]\\npostorder: [2, 1]\\n```\n```\\ndef buildTree(self, inorder, postorder):\\n    if len(inorder) == 0: return None\\n    root = TreeNode(postorder[-1])\\n    stack = [root]   \\n    # array indexes, i for inorder array, p for postorder array\\n    i = len(inorder) - 1\\n    p = len(postorder) - 2 # initially root already 'popped' off postorder and stored in stack\\n\\n    # we store values off postorder array and compare top of stack with\\n    # right most member of inorder array (indexed by i)\\n    while True:\\n      # top of stack is same as right most entry of inorder. The first time it\\n      # happens means we reached root of current tree. Then we keep removing them\\n      # since we already built right child nodes with them and they are on stack just so we\\n      # can traverse back up. See the else branch for the actual creation of right child. \\n      if stack[-1].val == inorder[i]:\\n        n = stack.pop()\\n        i -= 1\\n\\n        if i==-1: break\\n        if stack and inorder[i] == stack[-1].val:\\n          # keep removing these values, that is, traverse back up\\n          continue\\n\\n        # finished all the right branch and root itself, now we build left child\\n        # 'n' here was popped from stack which gave us the current root.\\n        n.left = TreeNode(postorder[p])\\n        p -= 1\\n        stack.append(n.left)\\n\\n      else: # mismatch values means we should build right child for current root\\n        n = TreeNode(postorder[p])\\n        p-=1\\n        stack[-1].right = n\\n        stack.append(n)\\n        \\n    return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3660644,
                "title": "c-striver-s-approach",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    TreeNode* buildTree(vector<int>& in, vector<int>& post) {\\n        for(int i=0;i<in.size();i++)m[in[i]]=i;\\n        TreeNode* root = build(in,0,in.size()-1,post,0,post.size()-1);\\n        return root;\\n    }\\n    TreeNode* build(vector<int>&in, int inS,int inE,vector<int>&post,int postS,int postE){\\n        if(inS>inE || postS>postE)return NULL;\\n        TreeNode* root = new TreeNode(post[postE]);\\n        int index = m[post[postE]];\\n        int len = inE - index;   \\n        root->right = build(in,index+1,inE,post,postE-len,postE-1);\\n        root->left = build(in,inS,index-1,post,postS,postE-len-1);\\n        return root;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/4b3e6582-96f7-459e-81c8-7e165085b188_1687249951.4209003.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    TreeNode* buildTree(vector<int>& in, vector<int>& post) {\\n        for(int i=0;i<in.size();i++)m[in[i]]=i;\\n        TreeNode* root = build(in,0,in.size()-1,post,0,post.size()-1);\\n        return root;\\n    }\\n    TreeNode* build(vector<int>&in, int inS,int inE,vector<int>&post,int postS,int postE){\\n        if(inS>inE || postS>postE)return NULL;\\n        TreeNode* root = new TreeNode(post[postE]);\\n        int index = m[post[postE]];\\n        int len = inE - index;   \\n        root->right = build(in,index+1,inE,post,postE-len,postE-1);\\n        root->left = build(in,inS,index-1,post,postS,postE-len-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302122,
                "title": "daily-leetcoding-challenge-march-day-16",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 518260,
                "title": "in-post-pre-in-pre-post",
                "content": "Inorder + Postorder\\n```\\nTreeNode* helper(int inSt, int inEnd, int poEnd, vector<int> &inorder, vector<int> &postorder) {\\n    if(poEnd < 0 || inSt > inEnd) return nullptr; // base condition\\n\\n    TreeNode *root = new TreeNode(postorder[poEnd]);\\n\\n    int pivot;\\n    for(int i = inSt; i < inorder.size(); i++) {\\n        if(root->val == inorder[i]) {\\n            pivot = i; break;\\n        }\\n    }\\n\\n    root->left = helper(inSt, pivot - 1, poEnd - 1 + pivot - inEnd, inorder, postorder);\\n    root->right = helper(pivot + 1, inEnd, poEnd - 1, inorder, postorder);\\n\\n    return root;\\n}    \\n\\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    return helper(0, inorder.size() - 1, postorder.size() - 1, inorder, postorder);\\n}\\n```\\n\\nPreorder + Inorder\\n```\\nTreeNode* helper(int preSt, int inSt, int inEnd, vector<int>& preorder, vector<int>& inorder) {\\n    if(inSt > inEnd || preSt >= preorder.size()) return nullptr;\\n\\n    TreeNode* root = new TreeNode(preorder[preSt]);\\n\\n    int pivot;\\n    for(int i = 0; i < inorder.size(); i++) {\\n        if(inorder[i] == root->val) {\\n            pivot = i; break;\\n        }\\n    }\\n\\n    root->left = helper(preSt + 1, inSt, pivot - 1, preorder, inorder);\\n    root->right = helper(preSt + pivot - inSt + 1, pivot + 1, inEnd, preorder, inorder);\\n\\n    return root;\\n}\\n\\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n    return helper(0, 0, inorder.size() - 1, preorder, inorder);\\n}\\n```\\n\\nPreorder + Postorder (Can only be done for full trees i.e. 0 or 2 children for every node)\\n```\\nTreeNode* helper(vector<int> &pre, int preSt, int preEnd, vector<int> &post, int postSt, int postEnd) {\\n    if(preSt == preEnd) return new TreeNode(pre[preSt]);\\n    if(preSt > preEnd) return nullptr;\\n\\n    TreeNode *root = new TreeNode(pre[preSt]);\\n\\n    int pivot;\\n    for(pivot = postSt; pivot <= postEnd;  pivot++) {\\n        if(pre[preSt + 1] == post[pivot]) {\\n            pivot = pivot + 1 - postSt; break;\\n        }\\n    }\\n\\n    root->left = helper(pre, preSt + 1, preSt + pivot, post, postSt, postSt + pivot - 1);\\n    root->right = helper(pre, preSt + pivot + 1, preEnd, post, postSt + pivot, postEnd - 1);\\n\\n    return root;\\n}\\n\\nTreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n    return helper(pre, 0, pre.size() - 1, post, 0, post.size() - 1);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTreeNode* helper(int inSt, int inEnd, int poEnd, vector<int> &inorder, vector<int> &postorder) {\\n    if(poEnd < 0 || inSt > inEnd) return nullptr; // base condition\\n\\n    TreeNode *root = new TreeNode(postorder[poEnd]);\\n\\n    int pivot;\\n    for(int i = inSt; i < inorder.size(); i++) {\\n        if(root->val == inorder[i]) {\\n            pivot = i; break;\\n        }\\n    }\\n\\n    root->left = helper(inSt, pivot - 1, poEnd - 1 + pivot - inEnd, inorder, postorder);\\n    root->right = helper(pivot + 1, inEnd, poEnd - 1, inorder, postorder);\\n\\n    return root;\\n}    \\n\\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    return helper(0, inorder.size() - 1, postorder.size() - 1, inorder, postorder);\\n}\\n```\n```\\nTreeNode* helper(int preSt, int inSt, int inEnd, vector<int>& preorder, vector<int>& inorder) {\\n    if(inSt > inEnd || preSt >= preorder.size()) return nullptr;\\n\\n    TreeNode* root = new TreeNode(preorder[preSt]);\\n\\n    int pivot;\\n    for(int i = 0; i < inorder.size(); i++) {\\n        if(inorder[i] == root->val) {\\n            pivot = i; break;\\n        }\\n    }\\n\\n    root->left = helper(preSt + 1, inSt, pivot - 1, preorder, inorder);\\n    root->right = helper(preSt + pivot - inSt + 1, pivot + 1, inEnd, preorder, inorder);\\n\\n    return root;\\n}\\n\\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n    return helper(0, 0, inorder.size() - 1, preorder, inorder);\\n}\\n```\n```\\nTreeNode* helper(vector<int> &pre, int preSt, int preEnd, vector<int> &post, int postSt, int postEnd) {\\n    if(preSt == preEnd) return new TreeNode(pre[preSt]);\\n    if(preSt > preEnd) return nullptr;\\n\\n    TreeNode *root = new TreeNode(pre[preSt]);\\n\\n    int pivot;\\n    for(pivot = postSt; pivot <= postEnd;  pivot++) {\\n        if(pre[preSt + 1] == post[pivot]) {\\n            pivot = pivot + 1 - postSt; break;\\n        }\\n    }\\n\\n    root->left = helper(pre, preSt + 1, preSt + pivot, post, postSt, postSt + pivot - 1);\\n    root->right = helper(pre, preSt + pivot + 1, preEnd, post, postSt + pivot, postEnd - 1);\\n\\n    return root;\\n}\\n\\nTreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n    return helper(pre, 0, pre.size() - 1, post, 0, post.size() - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3304989,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int, int> index;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            index[inorder[i]] = i;\\n        }\\n        return buildTreeHelper(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1, index);\\n    }\\n    \\n    TreeNode* buildTreeHelper(vector<int>& inorder, vector<int>& postorder, int inorderStart, int inorderEnd, int postorderStart, int postorderEnd, unordered_map<int, int>& index) {\\n        if (inorderStart > inorderEnd || postorderStart > postorderEnd) {\\n            return nullptr;\\n        }\\n        int rootVal = postorder[postorderEnd];\\n        TreeNode* root = new TreeNode(rootVal);\\n        int inorderRootIndex = index[rootVal];\\n        int leftSubtreeSize = inorderRootIndex - inorderStart;\\n        root->left = buildTreeHelper(inorder, postorder, inorderStart, inorderRootIndex - 1, postorderStart, postorderStart + leftSubtreeSize - 1, index);\\n        root->right = buildTreeHelper(inorder, postorder, inorderRootIndex + 1, inorderEnd, postorderStart + leftSubtreeSize, postorderEnd - 1, index);\\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int, int> index;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            index[inorder[i]] = i;\\n        }\\n        return buildTreeHelper(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1, index);\\n    }\\n    \\n    TreeNode* buildTreeHelper(vector<int>& inorder, vector<int>& postorder, int inorderStart, int inorderEnd, int postorderStart, int postorderEnd, unordered_map<int, int>& index) {\\n        if (inorderStart > inorderEnd || postorderStart > postorderEnd) {\\n            return nullptr;\\n        }\\n        int rootVal = postorder[postorderEnd];\\n        TreeNode* root = new TreeNode(rootVal);\\n        int inorderRootIndex = index[rootVal];\\n        int leftSubtreeSize = inorderRootIndex - inorderStart;\\n        root->left = buildTreeHelper(inorder, postorder, inorderStart, inorderRootIndex - 1, postorderStart, postorderStart + leftSubtreeSize - 1, index);\\n        root->right = buildTreeHelper(inorder, postorder, inorderRootIndex + 1, inorderEnd, postorderStart + leftSubtreeSize, postorderEnd - 1, index);\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303672,
                "title": "go-beats-100-easy-to-understand-simple-recursive-solution",
                "content": "# Code\\n```\\nfunc buildTree(inorder []int, postorder []int) *TreeNode {\\n\\tn := len(postorder)\\n\\tif n == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tpivotId := 0\\n\\tfor pivotId < n && inorder[pivotId] != postorder[n-1] {\\n\\t\\tpivotId++\\n\\t}\\n\\n\\troot := new(TreeNode)\\n\\troot.Val = postorder[n-1]\\n\\troot.Left = buildTree(inorder[:pivotId], postorder[:pivotId])\\n\\troot.Right = buildTree(inorder[pivotId+1:], postorder[pivotId:n-1])\\n\\treturn root\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nfunc buildTree(inorder []int, postorder []int) *TreeNode {\\n\\tn := len(postorder)\\n\\tif n == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tpivotId := 0\\n\\tfor pivotId < n && inorder[pivotId] != postorder[n-1] {\\n\\t\\tpivotId++\\n\\t}\\n\\n\\troot := new(TreeNode)\\n\\troot.Val = postorder[n-1]\\n\\troot.Left = buildTree(inorder[:pivotId], postorder[:pivotId])\\n\\troot.Right = buildTree(inorder[pivotId+1:], postorder[pivotId:n-1])\\n\\treturn root\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588889,
                "title": "python3-only-2-lines-explained",
                "content": "By definition, the ```postorder``` input has the root of the tree as its last element.\\nAlso, by definition, ```inorder``` and ```postorder``` have equal lengths.\\n\\nTherefore, to split these inputs into left and right subtrees, we can find the last element of ```postorder``` within ```inorder``` and split ```inorder``` at that point, recursing to the left with the elements left of that point and to the right with the elements to the right of that point.\\n\\nSince the inputs must be of equal length, we must split ```postorder``` at the same position, but include the element at that position in the input for the right subtree (and, of course, exclude the element in the last position).\\n\\ne.g. ```inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]```\\nThen the root is 3, so ```inorder``` and ```postorder``` are split thusly:\\ninorder_left = [9]\\ninorder_right = [15,20,7]\\npostorder_left = [9]\\npostorder_right = [15,7,20]\\nThen set the left subtree to ```buildTree(inorder_left, postorder_left)``` and set the right subtree to ```buildTree(inorder_right, postorder_right)```.\\n\\nSo, here is the resulting algorithm:\\nStep 1: If ```inorder``` is not empty, then find the last element of ```postorder``` in ```inorder```.\\nStep 2: If ```inorder``` is not empty, then divide the inputs into left and right subtrees and recurse.\\n\\nAnd here is the code:\\n```\\n#Runtime: 180 ms, faster than 36.95% of Python3 online submissions for Construct Binary Tree from Inorder and Postorder Traversal.\\n#Memory Usage: 88.1 MB, less than 28.00% of Python3 online submissions for Construct Binary Tree from Inorder and Postorder Traversal.\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        pos = inorder.index(postorder[-1]) if inorder else -1\\n        return TreeNode(postorder[-1], self.buildTree(inorder[:pos], postorder[:pos]), self.buildTree(inorder[pos+1:], postorder[pos:-1])) if pos>-1 else None\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```postorder```\n```inorder```\n```postorder```\n```postorder```\n```inorder```\n```inorder```\n```postorder```\n```inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]```\n```inorder```\n```postorder```\n```buildTree(inorder_left, postorder_left)```\n```buildTree(inorder_right, postorder_right)```\n```inorder```\n```postorder```\n```inorder```\n```inorder```\n```\\n#Runtime: 180 ms, faster than 36.95% of Python3 online submissions for Construct Binary Tree from Inorder and Postorder Traversal.\\n#Memory Usage: 88.1 MB, less than 28.00% of Python3 online submissions for Construct Binary Tree from Inorder and Postorder Traversal.\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        pos = inorder.index(postorder[-1]) if inorder else -1\\n        return TreeNode(postorder[-1], self.buildTree(inorder[:pos], postorder[:pos]), self.buildTree(inorder[pos+1:], postorder[pos:-1])) if pos>-1 else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324952,
                "title": "c-simple-recursive-solution-no-map",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* rec(int l, int r) {\\n        if (l > r) return NULL;\\n        \\n        int i = 0;\\n        while (m_inorder[i] != m_postorder[m_curr]) {\\n            i++;\\n        }\\n        \\n        m_curr--;\\n        TreeNode* node = new TreeNode(m_inorder[i]);\\n        node->right = rec(i+1, r);\\n        node->left = rec(l, i-1);\\n        return node;\\n        \\n    }\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        m_postorder = postorder, m_inorder = inorder, m_curr = inorder.size()-1;\\n        return rec(0, postorder.size()-1);\\n    }\\n    \\nprivate:\\n    int m_curr;\\n    vector<int> m_postorder, m_inorder;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* rec(int l, int r) {\\n        if (l > r) return NULL;\\n        \\n        int i = 0;\\n        while (m_inorder[i] != m_postorder[m_curr]) {\\n            i++;\\n        }\\n        \\n        m_curr--;\\n        TreeNode* node = new TreeNode(m_inorder[i]);\\n        node->right = rec(i+1, r);\\n        node->left = rec(l, i-1);\\n        return node;\\n        \\n    }\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        m_postorder = postorder, m_inorder = inorder, m_curr = inorder.size()-1;\\n        return rec(0, postorder.size()-1);\\n    }\\n    \\nprivate:\\n    int m_curr;\\n    vector<int> m_postorder, m_inorder;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569688,
                "title": "c-recursive-solution-with-key-ideas-explanation",
                "content": "There are 3 main ideas:\\n1) Postorder traversal ends with the root node\\n // by definition: starting from the root returns its value after both subtrees traversal\\n2) Inorder traversal allows us to separate a given tree on two subtrees\\n // by definition too: returns root value after left  and before right subtree traversals, so the root value is between subtrees\\n3) Rolling back postorder traversal will give us root values in each subtree. So we can use a stack for it.\\n\\n```\\n    public TreeNode BuildTree(int[] inorder, int[] postorder) {\\n        var post = new Stack<int>(postorder);\\n        var index = inorder.Select((val, index) => (val, index))\\n                           .ToDictionary(x => x.val, x => x.index);\\n        return Build(0, inorder.Length - 1);\\n\\n        TreeNode Build(int left, int right) {\\n            if (left > right) return null;\\n\\n            var val = post.Pop();\\n            var i = index[val];\\n\\n            return new TreeNode(val) {\\n                right = Build(i + 1, right),\\n                left = Build(left, i - 1)\\n            };\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    public TreeNode BuildTree(int[] inorder, int[] postorder) {\\n        var post = new Stack<int>(postorder);\\n        var index = inorder.Select((val, index) => (val, index))\\n                           .ToDictionary(x => x.val, x => x.index);\\n        return Build(0, inorder.Length - 1);\\n\\n        TreeNode Build(int left, int right) {\\n            if (left > right) return null;\\n\\n            var val = post.Pop();\\n            var i = index[val];\\n\\n            return new TreeNode(val) {\\n                right = Build(i + 1, right),\\n                left = Build(left, i - 1)\\n            };\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 453905,
                "title": "intuition-for-the-efficient-o-n-recursion",
                "content": "Starting from this video, I would like to explain how the efficient solution works.\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/IVlCn-DNO5k\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\nSuppose we have this tree ![image](https://assets.leetcode.com/users/valdrinit/image_1576567347.png)\\n\\nIt\\'s traversals are as follows ![image](https://assets.leetcode.com/users/valdrinit/image_1576567393.png)\\n\\nNow, it\\'s obvious that the last node of the postorder traversal `(A)` will be the root of the tree. As stated in the video, all the nodes from the inorder traversal that are to the left of the root belong to the left subtree `(D,B,F,E)` and all the others belong to the right one `(G,C,L,J,H,K)`. \\n\\nFrom this, it seems that we need an efficient way of answering the question \"given a node in the postorder traversal, where is it at in the inorder array (or what is its index in the inorder traversal)?\" This is what the `inorderLocator` map does: it maps each node\\'s value to its index in the inorder array `(inorderLocator[node value] = inorder index)`. \\n\\nWe\\'ve seen that dividing the inorder traversal into a left subtree traversal and a right subtree traversal is easy, we just find the root\\'s index and split there. But what about dividing the postorder traversal?\\n\\nThink about how postorder works. **We visit the left subtree first**, then the right subtree, and finally the root. What this means is that **the postorder traversal begins with all the elements of the left subtree (1)**; those are the ones we visit first, right? \\n\\nWe also know the index of the root in the inorder traversal, and that **the number of elements left of the root in an inorder traversal is exactly the number of elements in the left subtree (2)**. That number happens to be the **index of the root in the traversal minus the index of the first element considered (initially 0)**.\\n\\nGiven **1** and **2**, we can now divide the postorder traversal into subproblems too. The postorder traversal of the left subtree will have all the elements from `beginning` to `beginning + #(elements in the left subtree) - 1` and the right subtree will have all elements from `beginning + #(elements in the left subtree)` to `ending - 1` (as the last index was the root itself).\\n\\nIn our example, `A` is at index 4, we have `4 - 0 = 4` elements in the left subtree, so we split the postorder from index `0` to `4 - 1 = 3` `(D,F,E,B)`, and then again from `4` to `10 - 1 = 9` `(G,L,J,K,H,C)`.\\n\\nWe now have a beautiful recursion: we can solve `f([D,F,E,B,G,L,J,K,H,C,A], [D,B,F,E,A,G,C,L,J,H,K])` by choosing `root = A` and solving `root.left = f([D,F,E,B] [D,B,F,E])` AND `root.right = f([G,L,J,K,H,C], [G,C,L,J,H,K])`. The basecase would be when we want to solve `f([], [])`, and its result would be the null tree.\\n\\nFor optimization purposes, we could also consider `f([X], [X])` to be a base case, the tree with root X and no children. Also, we won\\'t split the arrays, but rather store their boundaries as `[start, end]` indeces so that we only consider the portions from `array[start]` to `array[end]`.\\n\\n```java\\nclass Solution {\\n    public Map<Integer, Integer> inorderLocator;\\n    \\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        inorderLocator = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++) {\\n            inorderLocator.put(inorder[i], i);\\n        }\\n        \\n        return buildTreeHelper(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\\n    }\\n    \\n    public TreeNode buildTreeHelper(int[] inorder, int inorderStart, int inorderEnd, int[] postorder, int postorderStart, int postorderEnd) {\\n        if (inorderStart > inorderEnd)\\n            return null;\\n        \\n        TreeNode root = new TreeNode(postorder[postorderEnd]);\\n\\t\\tif (inorderStart == inorderEnd)\\n\\t\\t\\treturn root;\\n        \\n        int inorderIndex = inorderLocator.get(postorder[postorderEnd]);\\n\\t\\tint leftSubtreeCount = inorderIndex - inorderStart;\\n\\t\\t\\n        root.left = buildTreeHelper(inorder, inorderStart, inorderIndex - 1, postorder, postorderStart, postorderStart + leftSubtreeCount - 1);\\n        root.right = buildTreeHelper(inorder, inorderIndex + 1, inorderEnd, postorder, postorderStart + leftSubtreeCount, postorderEnd - 1);\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public Map<Integer, Integer> inorderLocator;\\n    \\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        inorderLocator = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++) {\\n            inorderLocator.put(inorder[i], i);\\n        }\\n        \\n        return buildTreeHelper(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\\n    }\\n    \\n    public TreeNode buildTreeHelper(int[] inorder, int inorderStart, int inorderEnd, int[] postorder, int postorderStart, int postorderEnd) {\\n        if (inorderStart > inorderEnd)\\n            return null;\\n        \\n        TreeNode root = new TreeNode(postorder[postorderEnd]);\\n\\t\\tif (inorderStart == inorderEnd)\\n\\t\\t\\treturn root;\\n        \\n        int inorderIndex = inorderLocator.get(postorder[postorderEnd]);\\n\\t\\tint leftSubtreeCount = inorderIndex - inorderStart;\\n\\t\\t\\n        root.left = buildTreeHelper(inorder, inorderStart, inorderIndex - 1, postorder, postorderStart, postorderStart + leftSubtreeCount - 1);\\n        root.right = buildTreeHelper(inorder, inorderIndex + 1, inorderEnd, postorder, postorderStart + leftSubtreeCount, postorderEnd - 1);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34851,
                "title": "my-java-recursive-answer-beat-92-9-2ms",
                "content": "    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        return build(inorder,inorder.length-1,0,postorder,postorder.length-1);\\n    }\\n    \\n    public TreeNode build(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart){\\n    \\tif(inEnd > inStart){\\n    \\t\\treturn null;\\n    \\t}\\n    \\tTreeNode root = new TreeNode(postorder[postStart]);\\n    \\tif(inEnd == inStart){\\n    \\t\\treturn root;\\n    \\t}\\n    \\tint index = 0;\\n    \\t// find the index in inorder:\\n    \\tfor(int i = inStart; i >= inEnd; i--){\\n    \\t\\tif(inorder[i] == root.val){\\n    \\t\\t\\tindex = i;\\n    \\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\troot.right = build(inorder,inStart,index+1,postorder,postStart-1);\\n    \\troot.left = build(inorder,index-1,inEnd,postorder,postStart-(inStart-index)-1);\\n    \\t\\n    \\treturn root;\\n    }",
                "solutionTags": [],
                "code": "    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        return build(inorder,inorder.length-1,0,postorder,postorder.length-1);\\n    }\\n    \\n    public TreeNode build(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart){\\n    \\tif(inEnd > inStart){\\n    \\t\\treturn null;\\n    \\t}\\n    \\tTreeNode root = new TreeNode(postorder[postStart]);\\n    \\tif(inEnd == inStart){\\n    \\t\\treturn root;\\n    \\t}\\n    \\tint index = 0;\\n    \\t// find the index in inorder:\\n    \\tfor(int i = inStart; i >= inEnd; i--){\\n    \\t\\tif(inorder[i] == root.val){\\n    \\t\\t\\tindex = i;\\n    \\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\troot.right = build(inorder,inStart,index+1,postorder,postStart-1);\\n    \\troot.left = build(inorder,index-1,inEnd,postorder,postStart-(inStart-index)-1);\\n    \\t\\n    \\treturn root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3191853,
                "title": "construct-binary-tree-from-inorder-and-postorder-traversal-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe start by creating a hashmap called inorder_map to store the indices of each element in the inorder list. This will allow us to quickly find the index of a given value in constant time later on.\\n\\nThen, we define a recursive helper function called build that takes two arguments: the start and end indices of the current subtree we\\'re working on. If the start index is greater than the end index, we\\'ve reached the end of a branch and we should return None.\\n\\nInside the build function, we pop the last value from the postorder list and create a new node with that value. Then, we use the inorder_map to find the index of the node in the inorder list.\\n\\nSince we\\'re working with the postorder traversal, we first recursively build the right subtree by calling build with the start index set to index + 1 and the end index set to end. Then, we recursively build the left subtree by calling build with the start index set to start and the end index set to index - 1.\\n\\nFinally, we call the build function with the start index set to 0 and the end index set to len(inorder) - 1, which will build the entire tree. The build function will return the root node of the tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        # Use a hashmap to store the indices of each element in the inorder list\\n        inorder_map = {}\\n        for i, val in enumerate(inorder):\\n            inorder_map[val] = i\\n        \\n        # Define a recursive helper function to build the tree\\n        def build(start, end):\\n            # Base case: the start index is greater than the end index\\n            if start > end:\\n                return None\\n            \\n            # Create a new node with the last value in the postorder list\\n            val = postorder.pop()\\n            node = TreeNode(val)\\n            \\n            # Find the index of the node in the inorder list\\n            index = inorder_map[val]\\n            \\n            # Recursively build the right subtree first, since we\\'re working with the postorder traversal\\n            node.right = build(index + 1, end)\\n            # Then build the left subtree\\n            node.left = build(start, index - 1)\\n            \\n            return node\\n        \\n        # Call the helper function to build the tree\\n        return build(0, len(inorder) - 1)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        # Use a hashmap to store the indices of each element in the inorder list\\n        inorder_map = {}\\n        for i, val in enumerate(inorder):\\n            inorder_map[val] = i\\n        \\n        # Define a recursive helper function to build the tree\\n        def build(start, end):\\n            # Base case: the start index is greater than the end index\\n            if start > end:\\n                return None\\n            \\n            # Create a new node with the last value in the postorder list\\n            val = postorder.pop()\\n            node = TreeNode(val)\\n            \\n            # Find the index of the node in the inorder list\\n            index = inorder_map[val]\\n            \\n            # Recursively build the right subtree first, since we\\'re working with the postorder traversal\\n            node.right = build(index + 1, end)\\n            # Then build the left subtree\\n            node.left = build(start, index - 1)\\n            \\n            return node\\n        \\n        # Call the helper function to build the tree\\n        return build(0, len(inorder) - 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448935,
                "title": "python-fast-dfs-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/ff5d17d7-fe53-485e-a9bb-e386b3e3c7f0_1660911649.0673482.png)\\n\\n```\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        inorder_map = {val:i for i, val in enumerate(inorder)}\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            root = TreeNode(postorder.pop())\\n            root_index = inorder_map[root.val]\\n            root.right = dfs(root_index+1, end)  # have to put right before left because postorder.pop will return the right node first\\n            root.left = dfs(start, root_index-1)\\n            return root\\n        \\n        return dfs(0, len(inorder)-1)\\n```\\n![image](https://assets.leetcode.com/users/images/b8e8a9e2-a243-494f-8848-4c82a7c454c9_1660911627.902091.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        inorder_map = {val:i for i, val in enumerate(inorder)}\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            root = TreeNode(postorder.pop())\\n            root_index = inorder_map[root.val]\\n            root.right = dfs(root_index+1, end)  # have to put right before left because postorder.pop will return the right node first\\n            root.left = dfs(start, root_index-1)\\n            return root\\n        \\n        return dfs(0, len(inorder)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606677,
                "title": "python-easy-code",
                "content": "\\t def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if len(postorder)==0:\\n            return None\\n        root=TreeNode(postorder[-1])\\n        for i in range(len(inorder)):\\n            if postorder[-1]==inorder[i]:\\n                break\\n        root.left=self.buildTree(inorder[0:i],postorder[0:i])\\n        root.right=self.buildTree(inorder[i+1:],postorder[i:-1])\\n        return root",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\t def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if len(postorder)==0:\\n            return None\\n        root=TreeNode(postorder[-1])\\n        for i in range(len(inorder)):\\n            if postorder[-1]==inorder[i]:\\n                break\\n        root.left=self.buildTree(inorder[0:i],postorder[0:i])\\n        root.right=self.buildTree(inorder[i+1:],postorder[i:-1])\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 1589846,
                "title": "java-simple-easy-to-understand-intuitive-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if (postorder.length == 0 && inorder.length == 0)\\n            return null;\\n        if (postorder.length == 1 && inorder.length == 1)\\n            return new TreeNode(inorder[0]);\\n        int len = postorder.length;\\n        int root = postorder[len - 1];\\n        int index = findIndex(inorder, root);\\n        \\n        int[] leftIn = Arrays.copyOfRange(inorder, 0, index);\\n        int[] rightIn = Arrays.copyOfRange(inorder, index + 1, len);\\n        \\n        int[] leftPost = Arrays.copyOfRange(postorder, 0, index);\\n        int[] rightPost = Arrays.copyOfRange(postorder, index, len - 1);\\n        \\n        TreeNode lroot = buildTree(leftIn, leftPost);\\n        TreeNode rroot = buildTree(rightIn, rightPost);\\n        \\n        return new TreeNode(root, lroot, rroot);\\n    }\\n    int findIndex(int[] arr, int x) {\\n        for (int i = 0; i < arr.length; i++)\\n            if (arr[i] == x)\\n                return i;\\n        return -1;\\n    }\\n}\\n```\\nPlease **upvote** :-)",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if (postorder.length == 0 && inorder.length == 0)\\n            return null;\\n        if (postorder.length == 1 && inorder.length == 1)\\n            return new TreeNode(inorder[0]);\\n        int len = postorder.length;\\n        int root = postorder[len - 1];\\n        int index = findIndex(inorder, root);\\n        \\n        int[] leftIn = Arrays.copyOfRange(inorder, 0, index);\\n        int[] rightIn = Arrays.copyOfRange(inorder, index + 1, len);\\n        \\n        int[] leftPost = Arrays.copyOfRange(postorder, 0, index);\\n        int[] rightPost = Arrays.copyOfRange(postorder, index, len - 1);\\n        \\n        TreeNode lroot = buildTree(leftIn, leftPost);\\n        TreeNode rroot = buildTree(rightIn, rightPost);\\n        \\n        return new TreeNode(root, lroot, rroot);\\n    }\\n    int findIndex(int[] arr, int x) {\\n        for (int i = 0; i < arr.length; i++)\\n            if (arr[i] == x)\\n                return i;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758424,
                "title": "java-solution-3ms-fast-detailed-explanation",
                "content": "If you found the solution helpful, kindly like and upvote. :)\\n\\n```\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n            \\treturn helper(inorder, postorder, 0, inorder.length-1, postorder.length-1);\\n    }\\n\\n\\tTreeNode helper(int[] inorder, int[] postorder, int instart, int inend, int postend) {\\n\\t\\tif(postend<0 ||instart>inend) return null;\\n\\t\\t//The root will always be at the end\\n\\t\\tTreeNode root= new TreeNode(postorder[postend]);\\n\\t\\tint i=instart;\\n\\t\\t//Now we need to find the index in inorder (items on the left are left subtree, right are right subtree)\\n\\t\\tfor(; i<inend; i++)\\n\\t\\t{\\n\\t\\t\\tif(inorder[i]==root.val)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\t//Now all that is left is recursing on the left and the right subtree\\n\\t\\troot.left=helper(inorder, postorder, instart, i-1, postend-1+i-inend);\\n\\t\\troot.right=helper(inorder, postorder, i+1, inend, postend-1);\\n\\t\\treturn root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n            \\treturn helper(inorder, postorder, 0, inorder.length-1, postorder.length-1);\\n    }\\n\\n\\tTreeNode helper(int[] inorder, int[] postorder, int instart, int inend, int postend) {\\n\\t\\tif(postend<0 ||instart>inend) return null;\\n\\t\\t//The root will always be at the end\\n\\t\\tTreeNode root= new TreeNode(postorder[postend]);\\n\\t\\tint i=instart;\\n\\t\\t//Now we need to find the index in inorder (items on the left are left subtree, right are right subtree)\\n\\t\\tfor(; i<inend; i++)\\n\\t\\t{\\n\\t\\t\\tif(inorder[i]==root.val)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\t//Now all that is left is recursing on the left and the right subtree\\n\\t\\troot.left=helper(inorder, postorder, instart, i-1, postend-1+i-inend);\\n\\t\\troot.right=helper(inorder, postorder, i+1, inend, postend-1);\\n\\t\\treturn root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 237393,
                "title": "simple-and-crystal-clear-c-solutions",
                "content": "```\\nstruct TreeNode* newNode(val)\\n{\\n    struct TreeNode* p = (struct TreeNode*)malloc(sizeof(struct TreeNode));\\n    p->val = val;\\n    p->left = p->right = NULL;\\n    return p;\\n}\\n\\nstruct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize) {\\n    if (!inorder || !postorder || (inorderSize != postorderSize) || inorderSize <= 0) return NULL;\\n    \\n    int rootVal = postorder[postorderSize - 1];\\n    struct TreeNode* root = newNode(rootVal);\\n    int idx = 0;\\n    for (; idx < inorderSize - 1; idx++)\\n    {\\n        if (inorder[idx] == rootVal) break;\\n    }\\n    root->left = buildTree(inorder, idx, postorder, idx);\\n    root->right = buildTree(inorder+idx+1, inorderSize-idx-1, postorder+idx, inorderSize-idx-1);\\n    return root;\\n}\\n```\\n\\nI could get such straight-forward solution in C with the help of C pointer arithmetic. In fact, I am also trying \\nwith C++ vectors, but I think Cpp Vectors would not convenient (I am not skillful in Cpp), :(\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nstruct TreeNode* newNode(val)\\n{\\n    struct TreeNode* p = (struct TreeNode*)malloc(sizeof(struct TreeNode));\\n    p->val = val;\\n    p->left = p->right = NULL;\\n    return p;\\n}\\n\\nstruct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize) {\\n    if (!inorder || !postorder || (inorderSize != postorderSize) || inorderSize <= 0) return NULL;\\n    \\n    int rootVal = postorder[postorderSize - 1];\\n    struct TreeNode* root = newNode(rootVal);\\n    int idx = 0;\\n    for (; idx < inorderSize - 1; idx++)\\n    {\\n        if (inorder[idx] == rootVal) break;\\n    }\\n    root->left = buildTree(inorder, idx, postorder, idx);\\n    root->right = buildTree(inorder+idx+1, inorderSize-idx-1, postorder+idx, inorderSize-idx-1);\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 184882,
                "title": "ruby-recursive-solution-6-lines",
                "content": "What we know is that the root node in a postorder traversal is the very last node, so the last value is the root val. With that we know where to split the inorder traversal because in the inorder array, everything left of the root val is the left side of the tree, and everything right of the root val is the right side of the tree. We also know that in the postorder traversal there is some middle point of the traversal that splits the left and right of the tree because we know that the traversal jumps to the right side of the root node only after the entire left side is completed. Now, since we know the exact number of nodes on the left side from our logic about the inorder traversal array, we can take exactly that many values from the postorder traversal array for the left side, and then take the remaining values minus the last value for the right side.\\n\\n```\\ndef build_tree(inorder, postorder)   \\n    \\n    return nil if inorder.none?\\n    \\n    node = TreeNode.new(postorder.last)\\n    i = inorder.index(postorder.last)\\n    node.left = build_tree(inorder[0...i], postorder[0...i])\\n    node.right = build_tree(inorder[i+1..-1], postorder[i...-1])\\n    \\n    node\\n    \\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef build_tree(inorder, postorder)   \\n    \\n    return nil if inorder.none?\\n    \\n    node = TreeNode.new(postorder.last)\\n    i = inorder.index(postorder.last)\\n    node.left = build_tree(inorder[0...i], postorder[0...i])\\n    node.right = build_tree(inorder[i+1..-1], postorder[i...-1])\\n    \\n    node\\n    \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 159531,
                "title": "a-simple-recursive-way-in-go-with-explanation",
                "content": "A basic idea is that, the last element of slice `postorder` is `root`\\nAnd we can use `root` to find out left sub-tree and right sub-tree from `inorder`\\nThen, we go to build left/right sub-trees.\\nSlice `postorder` and `inorder` of the left sub-tree have the same indexing `[:rootIdx]` from the original `postorder` and `inorder`.\\nAs for the right sub-tree, its `inorder` is obtained by skipping the first element of original `inorder` because it is `root`. Then for `postorder`, we skip the last one. \\n\\n```\\nfunc buildTree(inorder []int, postorder []int) *TreeNode {\\n\\n\\tif len(inorder) == 0 && len(postorder) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tpivot := postorder[len(postorder)-1]\\n\\tpivotIdx := 0\\n\\tfor inorder[pivotIdx] != pivot {\\n\\t\\tpivotIdx++\\n\\t}\\n\\n\\tleft := buildTree(inorder[:pivotIdx], postorder[:pivotIdx])\\n\\tright := buildTree(inorder[pivotIdx+1:], postorder[pivotIdx:len(postorder)-1])\\n\\n\\troot := &TreeNode{pivot, left, right}\\n\\treturn root\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc buildTree(inorder []int, postorder []int) *TreeNode {\\n\\n\\tif len(inorder) == 0 && len(postorder) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tpivot := postorder[len(postorder)-1]\\n\\tpivotIdx := 0\\n\\tfor inorder[pivotIdx] != pivot {\\n\\t\\tpivotIdx++\\n\\t}\\n\\n\\tleft := buildTree(inorder[:pivotIdx], postorder[:pivotIdx])\\n\\tright := buildTree(inorder[pivotIdx+1:], postorder[pivotIdx:len(postorder)-1])\\n\\n\\troot := &TreeNode{pivot, left, right}\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 34837,
                "title": "simple-javascript-solution-using-dfs",
                "content": "```javascript\\n/**\\n * @param {number[]} inorder\\n * @param {number[]} postorder\\n * @return {TreeNode}\\n */\\nvar buildTree = function(inorder, postorder) {\\n  return dfs(inorder.length - 1, 0, inorder.length - 1);\\n\\n  function dfs(index, startPos, endPos) {\\n    if (startPos > endPos)\\n      return null;\\n\\n    var node = new TreeNode(postorder[index]);\\n    var pos = inorder.indexOf(postorder[index]);\\n\\n    node.left = dfs(index - (endPos - pos) - 1, startPos, pos - 1);\\n    node.right = dfs(index - 1, pos + 1, endPos);\\n\\n    return node;\\n  }\\n};\\n```\\n\\nall my leetcode solutions are here <https://github.com/hanzichi/leetcode>, give me a star if you like it!",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number[]} inorder\\n * @param {number[]} postorder\\n * @return {TreeNode}\\n */\\nvar buildTree = function(inorder, postorder) {\\n  return dfs(inorder.length - 1, 0, inorder.length - 1);\\n\\n  function dfs(index, startPos, endPos) {\\n    if (startPos > endPos)\\n      return null;\\n\\n    var node = new TreeNode(postorder[index]);\\n    var pos = inorder.indexOf(postorder[index]);\\n\\n    node.left = dfs(index - (endPos - pos) - 1, startPos, pos - 1);\\n    node.right = dfs(index - 1, pos + 1, endPos);\\n\\n    return node;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 34931,
                "title": "o-n-solution-with-forward-iteration",
                "content": "The code makes sure each step we are in the state where\\n\\n 1. We have a constructed sub tree. (the \"working\" tree in the code)\\n 1. Both iterators point to just pass that subtree. (the nodes for the subtree are continuous in both in-order and post-order lists.)\\n\\nThen, we can deduce that: **the next node in the in-order list must be the parent of the working tree**.\\n\\n 1. We extend the working tree by adding the next in-order list node as its parent, then push it to a stack; clear the working tree, and work on building the right branch from scratch. **All the notes until the same node appears in post-order are for the right child of the parent.**\\n 1. When the post-order element matches with the stack top, then the stack top node has its right branch finished. Thus, pop the stack, make the working tree as its right child. Point the working tree to the new completed tree.\\n\\nRun this over until the postorder sequences are consumed. The working tree is the answer, and the stack at that point should be empty.\\n\\nHere's the code\\n\\n    class Solution {\\n     public:\\n      TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        if (inorder.empty()) return nullptr;\\n        // 'parents' contains all the nodes we have seen so far, we haven't\\n        // finished building their right branch nodes yet.\\n        vector<TreeNode*> parents;\\n        // 'working' is a completed subtree of the final problem, based on the\\n        // inorder/postorder we examined so far. We will keep adding its parent to\\n        // build the final tree.\\n        TreeNode* working = nullptr;\\n        auto in = inorder.begin();\\n        auto post = postorder.begin();\\n        while (post != postorder.end())  {\\n          if (!parents.empty() && *post == parents.back()->val) {\\n            // Post order node matches the stack top parent notes. It means the\\n            // working tree is the right branch of the stack top. Pop the stack top\\n            // to be the working tree.\\n            parents.back()->right = working;\\n            working = parents.back();\\n            parents.pop_back();\\n            ++post;\\n          } else {\\n            // Otherwise, we get a new parent for the current working tree. \\n            // Extend the existing working tree, push it to the stack and work on\\n            // the right branch of the new parent.\\n            TreeNode* new_node = new TreeNode(*in);\\n            new_node->left = working;\\n            working = nullptr;\\n            parents.push_back(new_node);\\n            ++in;\\n          }\\n        }\\n        return working;\\n      }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n     public:\\n      TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        if (inorder.empty()) return nullptr;\\n        // 'parents' contains all the nodes we have seen so far, we haven't\\n        // finished building their right branch nodes yet.\\n        vector<TreeNode*> parents;\\n        // 'working' is a completed subtree of the final problem, based on the\\n        // inorder/postorder we examined so far. We will keep adding its parent to\\n        // build the final tree.\\n        TreeNode* working = nullptr;\\n        auto in = inorder.begin();\\n        auto post = postorder.begin();\\n        while (post != postorder.end())  {\\n          if (!parents.empty() && *post == parents.back()->val) {\\n            // Post order node matches the stack top parent notes. It means the\\n            // working tree is the right branch of the stack top. Pop the stack top\\n            // to be the working tree.\\n            parents.back()->right = working;\\n            working = parents.back();\\n            parents.pop_back();\\n            ++post;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 3979671,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* build(int postStart, int postEnd, vector<int>& postorder, \\n    int inStart, int inEnd, vector<int>& inorder, unordered_map <int, int>& mp) {\\n        if (postStart > postEnd || inStart > inEnd)\\n            return NULL;\\n        TreeNode* root = new TreeNode(postorder[postEnd]);\\n        int ind = mp[postorder[postEnd]];    \\n        root->left = build(postStart, postStart+ind-inStart-1, postorder, inStart, ind-1, inorder, mp);\\n        root->right = build(postStart+ind-inStart, postEnd-1, postorder, ind+1, inEnd, inorder, mp);\\n\\n        return root;   \\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int postStart = 0, postEnd = postorder.size() - 1;\\n        int inStart = 0, inEnd = inorder.size() - 1;\\n        unordered_map <int, int> mp;\\n        for (int i = 0; i < inorder.size(); i++)\\n            mp[inorder[i]] = i;\\n\\n        return build(postStart, postEnd, postorder, inStart, inEnd, inorder, mp);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* build(int postStart, int postEnd, vector<int>& postorder, \\n    int inStart, int inEnd, vector<int>& inorder, unordered_map <int, int>& mp) {\\n        if (postStart > postEnd || inStart > inEnd)\\n            return NULL;\\n        TreeNode* root = new TreeNode(postorder[postEnd]);\\n        int ind = mp[postorder[postEnd]];    \\n        root->left = build(postStart, postStart+ind-inStart-1, postorder, inStart, ind-1, inorder, mp);\\n        root->right = build(postStart+ind-inStart, postEnd-1, postorder, ind+1, inEnd, inorder, mp);\\n\\n        return root;   \\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int postStart = 0, postEnd = postorder.size() - 1;\\n        int inStart = 0, inEnd = inorder.size() - 1;\\n        unordered_map <int, int> mp;\\n        for (int i = 0; i < inorder.size(); i++)\\n            mp[inorder[i]] = i;\\n\\n        return build(postStart, postEnd, postorder, inStart, inEnd, inorder, mp);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798020,
                "title": "easy-explanation-of-the-code-c-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***The intuition behind this solution is since the postOrder store the root node ( top most node of tree) at its last index . from traversing reverse we get our root node, from this I can easily find the right and left subtree from the Inorder . From this data that we have we can crete our tree by joining first rightSubtree to root node and then leftSubtree to it.***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The code defines a class `Solution` that contains a function `buildTree` to construct a binary tree from its inorder and postorder traversal sequences.\\n\\n2. The binary tree nodes are represented using the `TreeNode` struct, which has an integer value (`val`) and pointers to its left and right children (`left` and `right`).\\n\\n3. The `buildTree` function takes two input vectors, `inorder` and `postorder`, representing the inorder and postorder traversal sequences of the binary tree, respectively.\\n\\n4. Inorder traversal visits the left subtree first, then the root node, and finally the right subtree. Postorder traversal visits the left subtree first, then the right subtree, and finally the root node.\\n\\n5. The `buildTree` function initializes variables `size`, `postIndex`, `start`, and `end` to keep track of the tree size, current index in the `postorder` vector, and the start and end indices of the `inorder` subarray being processed, respectively.\\n\\n6. It also uses an unordered map `mp` to store the indices of elements in the `inorder` vector. This map allows quick lookup of an element\\'s position in the `inorder` sequence.\\n\\n7. The main logic of tree construction is implemented in the `solver` function, which is a recursive helper function.\\n\\n8. The `solver` function takes the `postorder` and `inorder` vectors, along with the previously mentioned variables (`size`, `postIndex`, `start`, `end`, and `mp`), to construct the binary tree.\\n\\n9. In the `solver` function, it checks if the `postIndex` is out of bounds or if the `start` index exceeds the `end` index. If either condition is true, it means the current subtree is empty, and it returns `NULL`.\\n\\n10. Otherwise, it takes the element at `postIndex` from the `postorder` vector, creates a new node with this element, and decrements `postIndex`.\\n\\n11. It then finds the position (index) of this element in the `inorder` vector using the precomputed indices stored in the `mp` map.\\n\\n12. Next, it calls `solver` recursively to build the right subtree, passing the appropriate indices for the right subarray of `inorder`.\\n\\n13. Similarly, it constructs the left subtree using recursive calls to `solver` and passing the appropriate indices for the left subarray of `inorder`.\\n\\n14. The `solver` function returns the current node, and this node becomes the right or left child of its parent node in subsequent recursive calls.\\n\\n15. Finally, the `buildTree` function returns the root of the constructed binary tree.\\n\\nIn summary, the code efficiently constructs a binary tree from its inorder and postorder traversal sequences using a recursive approach with the aid of an unordered map for faster element position lookup. The recursive `solver` function handles the tree construction for each subtree, and the construction starts from the last element of the postorder sequence and proceeds backward.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n***----------------Please UpVote if you really find heplfull-----------***\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solver(vector<int> &postorder,vector<int> &inorder,int size,int &postIndex,int start,int end,     unordered_map<int,int>  &mp)\\n   {\\n       if(postIndex<0 || start>end)\\n       {\\n           return NULL;\\n       }\\n\\n       int element=postorder[postIndex];\\n       postIndex--;\\n       int pos= mp[element];\\n       TreeNode* root=new TreeNode(element);\\n       root->right=solver(postorder,inorder,size,postIndex,pos+1,end,mp);\\n       root->left= solver(postorder,inorder,size,postIndex,start,pos-1,mp); \\n       return root;\\n       \\n   }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int size=postorder.size();\\n        int postIndex=size-1;\\n        int start=0;\\n        int end=size-1;\\n        unordered_map<int,int>  mp;\\n        for(int i=0;i<size;i++)\\n        {\\n            mp[inorder[i]]=i;\\n        }\\n\\n        TreeNode* root=solver(postorder,inorder,size,postIndex,start,end,mp);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solver(vector<int> &postorder,vector<int> &inorder,int size,int &postIndex,int start,int end,     unordered_map<int,int>  &mp)\\n   {\\n       if(postIndex<0 || start>end)\\n       {\\n           return NULL;\\n       }\\n\\n       int element=postorder[postIndex];\\n       postIndex--;\\n       int pos= mp[element];\\n       TreeNode* root=new TreeNode(element);\\n       root->right=solver(postorder,inorder,size,postIndex,pos+1,end,mp);\\n       root->left= solver(postorder,inorder,size,postIndex,start,pos-1,mp); \\n       return root;\\n       \\n   }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int size=postorder.size();\\n        int postIndex=size-1;\\n        int start=0;\\n        int end=size-1;\\n        unordered_map<int,int>  mp;\\n        for(int i=0;i<size;i++)\\n        {\\n            mp[inorder[i]]=i;\\n        }\\n\\n        TreeNode* root=solver(postorder,inorder,size,postIndex,start,end,mp);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728624,
                "title": "c-beats-99-intuitive-simple-recursion-easy-solution",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo first of all u must know the conditions for a constructing a unique binary tree that u must be given an inorder and a postorder/preorder/levelorder/anyother traversal to construct a unique binary tree\\n\\nThen next step is to figure out the root of the tree as we know the postorer traversal goes like left---->right---->root so the last element of the postorder msut be the root.\\n\\nSo,now u have the root okay so after u got the root what is the next thing u want left and right of the root, isn\\'t it. Hey why don\\'t u think what does inorder provides us its like left--->root--->right so if we find the root obtained from the postorder in the inorder vector then the nodes to the left of it would be the part of left subtree and the nodes at the right of it would be the part of right subtree.\\n\\nSo now u know the root of the tree the components of leftsubtree and the rightsubtree just try to extract the postorder and inorder of left and right subtree from the given vectors and just do the recursive calls for the left and the right subtree and u are good to go with the recursive solution.\\n\\n# Recursive code\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   \\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n    class Solution {\\n    public:\\n    #include <algorithm>\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        if(postorder.empty()) return nullptr;\\n        \\n        int n=postorder.size();\\n        int root_val=postorder[n-1];\\n        TreeNode* root=new TreeNode(root_val);\\n        int index=find(inorder.begin(),inorder.end(),root_val)-inorder.begin();\\n\\n        vector<int> linorder(inorder.begin(),inorder.begin()+index);\\n        vector<int> lpostorder(postorder.begin(),postorder.begin()+index);\\n        \\n        TreeNode* left=buildTree(linorder,lpostorder);\\n        root->left=left;\\n\\n        vector<int> rinorder(inorder.begin()+index+1,inorder.end());\\n        vector<int> rpostorder(postorder.begin()+index,postorder.end()-1);\\n\\n        TreeNode* right=buildTree(rinorder,rpostorder);\\n        root->right=right;\\n        return root;}};\\n\\n# Optimized code\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   \\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```  \\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        if (postorder.empty()) return nullptr;\\n\\n        int postIndex = postorder.size() - 1; // Start with the last element of postorder\\n        return buildTreeHelper(inorder, postorder, postIndex, 0, inorder.size() - 1);\\n    }\\n\\n    TreeNode* buildTreeHelper(vector<int>& inorder, vector<int>& postorder, int& postIndex, int inStart, int inEnd) {\\n        if (inStart > inEnd) return nullptr;\\n\\n        int rootVal = postorder[postIndex];\\n        TreeNode* root = new TreeNode(rootVal);\\n        postIndex--;\\n\\n        int rootIndex = findIndex(inorder, rootVal, inStart, inEnd);\\n\\n        root->right = buildTreeHelper(inorder, postorder, postIndex, rootIndex + 1, inEnd);\\n        root->left = buildTreeHelper(inorder, postorder, postIndex, inStart, rootIndex - 1);\\n\\n        return root;\\n    }\\n\\n    int findIndex(vector<int>& inorder, int target, int start, int end) {\\n        for (int i = start; i <= end; i++) {\\n            if (inorder[i] == target)\\n                return i;\\n        }\\n        return -1; // Not found\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```  \\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        if (postorder.empty()) return nullptr;\\n\\n        int postIndex = postorder.size() - 1; // Start with the last element of postorder\\n        return buildTreeHelper(inorder, postorder, postIndex, 0, inorder.size() - 1);\\n    }\\n\\n    TreeNode* buildTreeHelper(vector<int>& inorder, vector<int>& postorder, int& postIndex, int inStart, int inEnd) {\\n        if (inStart > inEnd) return nullptr;\\n\\n        int rootVal = postorder[postIndex];\\n        TreeNode* root = new TreeNode(rootVal);\\n        postIndex--;\\n\\n        int rootIndex = findIndex(inorder, rootVal, inStart, inEnd);\\n\\n        root->right = buildTreeHelper(inorder, postorder, postIndex, rootIndex + 1, inEnd);\\n        root->left = buildTreeHelper(inorder, postorder, postIndex, inStart, rootIndex - 1);\\n\\n        return root;\\n    }\\n\\n    int findIndex(vector<int>& inorder, int target, int start, int end) {\\n        for (int i = start; i <= end; i++) {\\n            if (inorder[i] == target)\\n                return i;\\n        }\\n        return -1; // Not found\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312608,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    unordered_map<int, int> inToIndex;\\n\\n    for (int i = 0; i < inorder.size(); ++i)\\n      inToIndex[inorder[i]] = i;\\n\\n    return build(inorder, 0, inorder.size() - 1, postorder, 0,\\n                 postorder.size() - 1, inToIndex);\\n  }\\n\\n private:\\n  TreeNode* build(const vector<int>& inorder, int inStart, int inEnd,\\n                  const vector<int>& postorder, int postStart, int postEnd,\\n                  const unordered_map<int, int>& inToIndex) {\\n    if (inStart > inEnd)\\n      return nullptr;\\n\\n    const int rootVal = postorder[postEnd];\\n    const int rootInIndex = inToIndex.at(rootVal);\\n    const int leftSize = rootInIndex - inStart;\\n\\n    TreeNode* root = new TreeNode(rootVal);\\n    root->left = build(inorder, inStart, rootInIndex - 1, postorder, postStart,\\n                       postStart + leftSize - 1, inToIndex);\\n    root->right = build(inorder, rootInIndex + 1, inEnd, postorder,\\n                        postStart + leftSize, postEnd - 1, inToIndex);\\n    return root;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    unordered_map<int, int> inToIndex;\\n\\n    for (int i = 0; i < inorder.size(); ++i)\\n      inToIndex[inorder[i]] = i;\\n\\n    return build(inorder, 0, inorder.size() - 1, postorder, 0,\\n                 postorder.size() - 1, inToIndex);\\n  }\\n\\n private:\\n  TreeNode* build(const vector<int>& inorder, int inStart, int inEnd,\\n                  const vector<int>& postorder, int postStart, int postEnd,\\n                  const unordered_map<int, int>& inToIndex) {\\n    if (inStart > inEnd)\\n      return nullptr;\\n\\n    const int rootVal = postorder[postEnd];\\n    const int rootInIndex = inToIndex.at(rootVal);\\n    const int leftSize = rootInIndex - inStart;\\n\\n    TreeNode* root = new TreeNode(rootVal);\\n    root->left = build(inorder, inStart, rootInIndex - 1, postorder, postStart,\\n                       postStart + leftSize - 1, inToIndex);\\n    root->right = build(inorder, rootInIndex + 1, inEnd, postorder,\\n                        postStart + leftSize, postEnd - 1, inToIndex);\\n    return root;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304107,
                "title": "java-detailed-explanation",
                "content": "# Read till the end:\\n---\\n```\\nRole of Postorder traversal: \\nTells us which is the root.\\n\\nRole of Inorder traversal: \\nTells us which are the left and right subtrees.\\n```\\nThe root always lie at the end of our postorder array (or subtree subarray). So when we know what our root is, we would want to define the left and right subtree from the inorder array (Becase in inorder, root lies between left and right while in postorder left and right lies together so we don\\'t know hwere to put the partition). But we don\\'t know where our root lies in the inorder array. So we would use a hashmap to store the inorder elements along with their indices. So we would get the root indices at constant time. \\n\\nSo in the inorder array:\\nLeft subtree would be: `start` to `root index - 1`\\nRight subtree would be: `root index + 1` to `end`\\n\\nIn the postorder array:\\nLeft subtree would be: \\n`start` to `start + (number of elements in left subtree) - 1`\\n\\nRight subtree would be:\\n`start + (number of elements in left subtree)` to `end`\\n\\nNow in these broken down subarrays, the root will be given by postorder subarray, and left and right subtree would be derived from inorder subarrays.\\n\\n(Head over to my YT (in my bio) for a VERY DETAILED explanation. Can\\'t share the link coz I was banned from discuss one time).\\n\\nThe pictures depict how we are defining the subtrees:\\n\\n![image.png](https://assets.leetcode.com/users/images/08868b1d-1881-476c-a2dd-10c8f284a258_1678971510.0150607.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/8c24e7ce-ddb5-4a7d-a797-ed5b02f8f003_1678971533.02077.png)\\n\\n\\n\\n---\\n### Code:\\n```\\nclass Solution {\\n    private Map<Integer, Integer> map;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        map = new HashMap<>();\\n        int n = inorder.length;\\n        // build the hashmap\\n        for (int i = 0; i < n; i++) {\\n            map.put(inorder[i], i);\\n        }\\n        // range is 0 -> n-1 because this is the main function call\\n        // for all the elements in the tree\\n        return build(inorder, 0, n - 1, postorder, 0, n - 1);\\n    }\\n\\n    // io -> In Order\\n    // po -> Post Order\\n    private TreeNode build( int[] io, int ioStart, int ioEnd, \\n                            int[] po, int poStart, int poEnd) {\\n        // BASE CONDITION:\\n        // ioStart and ioEnd are moving closer to each, similarly\\n        // poStart and poEnd are moving closer to each other \\n        // when we\\'ll reach the leaf node, \\n        // ioStart and ioEnd will be at the same position                          \\n        // poStart and poEnd will be at the same position\\n        // upon further recursive calls, they\\'ll cross each other\\n        if (ioStart > ioEnd || poStart > poEnd) {\\n            return null;    // in that case return null\\n        }\\n\\n        // po[poEnd] will give us the root node value\\n        // because po knows who our root is\\n        TreeNode root = new TreeNode(po[poEnd]);    // create the root node\\n        // hashmap knows where our root lies in io array\\n        int rootIdx = map.get(po[poEnd]);      // get that index from te map\\n        // compute the number of elements at the left of root index in io array \\n        int numsAtLeft = rootIdx - ioStart;\\n        // this numsAtLeft is nothing but the number of elements in our left subtree\\n        // We don\\'t know from where to where our left and right subtree lies\\n        // in the po array, so numsAtLeft will help us \\n        // define the range for left and right subtrees in po array\\n        // (See the pictures for the parameters in the recursive calls)\\n\\n        root.left = build(io, ioStart, rootIdx - 1, \\n                          po, poStart, poStart + numsAtLeft - 1);\\n\\n        root.right = build(io, rootIdx + 1, ioEnd, \\n                           po, poStart + numsAtLeft, poEnd - 1);\\n\\n        // our recursion will go to the bottom (single node level) \\n        // and build the tree and come back\\n        return root;\\n    }\\n}\\n```\\n---\\n#### Clean solution:\\n```\\nclass Solution {\\n    private Map<Integer, Integer> map = new HashMap<>();\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n = inorder.length;\\n        for (int i = 0; i < n; i++) {\\n            map.put(inorder[i], i);\\n        }\\n\\n        return build(inorder, 0, n - 1, postorder, 0, n - 1);\\n    }\\n\\n    private TreeNode build( int[] io, int ioStart, int ioEnd, \\n                            int[] po, int poStart, int poEnd) {\\n\\n        if (ioStart > ioEnd || poStart > poEnd) {\\n            return null;    \\n        }\\n\\n        TreeNode root = new TreeNode(po[poEnd]);\\n        int rootIdx = map.get(po[poEnd]);      \\n        int numsAtLeft = rootIdx - ioStart;\\n\\n        root.left = build(io, ioStart, rootIdx - 1, \\n                          po, poStart, poStart + numsAtLeft - 1);\\n\\n        root.right = build(io, rootIdx + 1, ioEnd, \\n                           po, poStart + numsAtLeft, poEnd - 1);\\n        return root;\\n    }\\n}\\n```\\n--- \\n### Complexity analysis:\\n##### Time complexity: $$O(n)$$\\n> A $$O(n)$$ to populate the hashmap.\\n\\n> Another $$O(n)$$ to build the tree, assuming at worst case we build a skewed tree of height $$n$$.\\n\\n> *We have used a hashmap so that we can access the root indices from the inorder array in constant time. Otherwise we would have had to traverse the ionorder array everytime to get the root index which cost us another $$O(n)$$ time making our tree building process $$O(n^2)$$. So in order to avoid that we used a hashmap.*\\n\\n> So, final time complexity: $$O(n) + O(n) => O(n)$$ \\n\\n##### Space complexity: $$O(n)$$\\n> We use a hashmap of size $$n$$.\\n\\n> Our recursive stack space can cost us a space complexity of $$O(n)$$\\nassuming we uild a skewed tree of height $$n$$.\\n\\n> So final time complexity: $$O(n) + O(n) => O(n)$$\\n---\\n                           Do comment if you have any doubt \\uD83D\\uDC4D\\uD83C\\uDFFB\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nRole of Postorder traversal: \\nTells us which is the root.\\n\\nRole of Inorder traversal: \\nTells us which are the left and right subtrees.\\n```\n```\\nclass Solution {\\n    private Map<Integer, Integer> map;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        map = new HashMap<>();\\n        int n = inorder.length;\\n        // build the hashmap\\n        for (int i = 0; i < n; i++) {\\n            map.put(inorder[i], i);\\n        }\\n        // range is 0 -> n-1 because this is the main function call\\n        // for all the elements in the tree\\n        return build(inorder, 0, n - 1, postorder, 0, n - 1);\\n    }\\n\\n    // io -> In Order\\n    // po -> Post Order\\n    private TreeNode build( int[] io, int ioStart, int ioEnd, \\n                            int[] po, int poStart, int poEnd) {\\n        // BASE CONDITION:\\n        // ioStart and ioEnd are moving closer to each, similarly\\n        // poStart and poEnd are moving closer to each other \\n        // when we\\'ll reach the leaf node, \\n        // ioStart and ioEnd will be at the same position                          \\n        // poStart and poEnd will be at the same position\\n        // upon further recursive calls, they\\'ll cross each other\\n        if (ioStart > ioEnd || poStart > poEnd) {\\n            return null;    // in that case return null\\n        }\\n\\n        // po[poEnd] will give us the root node value\\n        // because po knows who our root is\\n        TreeNode root = new TreeNode(po[poEnd]);    // create the root node\\n        // hashmap knows where our root lies in io array\\n        int rootIdx = map.get(po[poEnd]);      // get that index from te map\\n        // compute the number of elements at the left of root index in io array \\n        int numsAtLeft = rootIdx - ioStart;\\n        // this numsAtLeft is nothing but the number of elements in our left subtree\\n        // We don\\'t know from where to where our left and right subtree lies\\n        // in the po array, so numsAtLeft will help us \\n        // define the range for left and right subtrees in po array\\n        // (See the pictures for the parameters in the recursive calls)\\n\\n        root.left = build(io, ioStart, rootIdx - 1, \\n                          po, poStart, poStart + numsAtLeft - 1);\\n\\n        root.right = build(io, rootIdx + 1, ioEnd, \\n                           po, poStart + numsAtLeft, poEnd - 1);\\n\\n        // our recursion will go to the bottom (single node level) \\n        // and build the tree and come back\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Map<Integer, Integer> map = new HashMap<>();\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n = inorder.length;\\n        for (int i = 0; i < n; i++) {\\n            map.put(inorder[i], i);\\n        }\\n\\n        return build(inorder, 0, n - 1, postorder, 0, n - 1);\\n    }\\n\\n    private TreeNode build( int[] io, int ioStart, int ioEnd, \\n                            int[] po, int poStart, int poEnd) {\\n\\n        if (ioStart > ioEnd || poStart > poEnd) {\\n            return null;    \\n        }\\n\\n        TreeNode root = new TreeNode(po[poEnd]);\\n        int rootIdx = map.get(po[poEnd]);      \\n        int numsAtLeft = rootIdx - ioStart;\\n\\n        root.left = build(io, ioStart, rootIdx - 1, \\n                          po, poStart, poStart + numsAtLeft - 1);\\n\\n        root.right = build(io, rootIdx + 1, ioEnd, \\n                           po, poStart + numsAtLeft, poEnd - 1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303929,
                "title": "concise-java-soution-explained-beats-100-submissions",
                "content": "# Intuition\\nInorder is    L Root R\\nPostorder is  L  R   Root\\n\\nSo the last element of the post order traversal will give us the root\\nwe can find the root element index in inorder to indentify the root elements left and right subtree\\n\\ninorder = [9,**3**,15,20,7]\\npostorder = [9,15,7,20, **3** ]\\n\\n----\\n#root is 3\\nso index 0 to 0(rootIndex-1) is left subtree that is 9\\nand index 2(rootIndex+1) to 4 in inorder is right subtree\\n\\nso we divided the sub problem in sub-parts and now can recursively call it\\n\\n----\\n**NOTE**\\nIn my case i have called right subtree first while solving and have not considered start and end of postorderIndex is because we know that in post traversal order L R Root . If we have solved for root next element would be right(i.e right subtree) and then left(i.e left subtree), so that is the reason.\\n\\n\\n- Time complexity:\\nO(n) since we visiting every element of array\\n\\n- Space complexity\\nO(n) storing data inorder data in hashmap\\n\\n# Code\\n```\\nclass Solution {\\n    int postorderIndex;\\n    Map<Integer, Integer> inorderIndexMap;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        postorderIndex = postorder.length - 1;\\n        // build a hashmap to store value -> its index relations\\n        inorderIndexMap = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++) {\\n            inorderIndexMap.put(inorder[i], i);\\n        }\\n\\n        return arrayToTree(postorder, 0, postorder.length - 1);\\n    }\\n\\n    private TreeNode arrayToTree(int[] postorder, int left, int right) {\\n        // if there are no elements to construct the tree\\n        if (left > right) return null;\\n\\n        // select the postorder_index element as the root and decrement it\\n        int rootValue = postorder[postorderIndex--];\\n        TreeNode root = new TreeNode(rootValue);\\n\\n        // build right and left subtree\\n        // excluding inorderIndexMap[rootValue] element because it\\'s the root\\n        root.right = arrayToTree(postorder, inorderIndexMap.get(rootValue) + 1, right);\\n        root.left = arrayToTree(postorder, left, inorderIndexMap.get(rootValue) - 1);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int postorderIndex;\\n    Map<Integer, Integer> inorderIndexMap;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        postorderIndex = postorder.length - 1;\\n        // build a hashmap to store value -> its index relations\\n        inorderIndexMap = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++) {\\n            inorderIndexMap.put(inorder[i], i);\\n        }\\n\\n        return arrayToTree(postorder, 0, postorder.length - 1);\\n    }\\n\\n    private TreeNode arrayToTree(int[] postorder, int left, int right) {\\n        // if there are no elements to construct the tree\\n        if (left > right) return null;\\n\\n        // select the postorder_index element as the root and decrement it\\n        int rootValue = postorder[postorderIndex--];\\n        TreeNode root = new TreeNode(rootValue);\\n\\n        // build right and left subtree\\n        // excluding inorderIndexMap[rootValue] element because it\\'s the root\\n        root.right = arrayToTree(postorder, inorderIndexMap.get(rootValue) + 1, right);\\n        root.left = arrayToTree(postorder, left, inorderIndexMap.get(rootValue) - 1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302281,
                "title": "c-recursion",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode BuildTree(int[] inorder, int[] postorder) \\n    {\\n        TreeNode? Build(Span<int> inorder, Span<int> postorder)\\n        {\\n            if (postorder.IsEmpty || inorder.IsEmpty)\\n            {\\n                return null;\\n            }\\n\\n            var pos = inorder.IndexOf(postorder[^1]);\\n            return new TreeNode(postorder[^1])\\n            {\\n                left = Build(inorder[..pos], postorder[..pos]),\\n                right = Build(inorder[(pos + 1)..], postorder[pos..^1])\\n            };\\n        }\\n\\n        return Build(inorder, postorder);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode BuildTree(int[] inorder, int[] postorder) \\n    {\\n        TreeNode? Build(Span<int> inorder, Span<int> postorder)\\n        {\\n            if (postorder.IsEmpty || inorder.IsEmpty)\\n            {\\n                return null;\\n            }\\n\\n            var pos = inorder.IndexOf(postorder[^1]);\\n            return new TreeNode(postorder[^1])\\n            {\\n                left = Build(inorder[..pos], postorder[..pos]),\\n                right = Build(inorder[(pos + 1)..], postorder[pos..^1])\\n            };\\n        }\\n\\n        return Build(inorder, postorder);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109718,
                "title": "simple-python-solution-using-recursion-100-working",
                "content": "**Python dictionary can be used in place of index to get linear time complexity.**\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not inorder or not postorder:\\n            return None\\n        root=TreeNode(postorder.pop())\\n        mid=inorder.index(root.val)\\n        root.left=self.buildTree(inorder[:mid],postorder[:mid])\\n        root.right=self.buildTree(inorder[mid+1:],postorder[mid:])\\n        return root\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not inorder or not postorder:\\n            return None\\n        root=TreeNode(postorder.pop())\\n        mid=inorder.index(root.val)\\n        root.left=self.buildTree(inorder[:mid],postorder[:mid])\\n        root.right=self.buildTree(inorder[mid+1:],postorder[mid:])\\n        return root\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601734,
                "title": "python-with-and-without-dictionary-solution",
                "content": "**Solution 1:**\\n```\\ndef buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if inorder:\\n            node = TreeNode(postorder[-1])\\n            idx = inorder.index(postorder.pop())\\n            node.right = self.buildTree(inorder[idx+1:], postorder)\\n            node.left = self.buildTree(inorder[0:idx], postorder)\\n            return node\\n```\\n**Solution 2:**\\n```\\ndef buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        dic = {}\\n        \\n        for idx, val in enumerate(inorder):\\n            dic[val] = idx\\n        \\n        def f(start, end):\\n            if start > end:\\n                return None\\n            node = TreeNode(postorder.pop())\\n            index = dic[node.val]\\n            node.right = f(index+1, end)\\n            node.left = f(start, index-1)\\n            return node\\n\\n        return f(0, len(inorder)-1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if inorder:\\n            node = TreeNode(postorder[-1])\\n            idx = inorder.index(postorder.pop())\\n            node.right = self.buildTree(inorder[idx+1:], postorder)\\n            node.left = self.buildTree(inorder[0:idx], postorder)\\n            return node\\n```\n```\\ndef buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        dic = {}\\n        \\n        for idx, val in enumerate(inorder):\\n            dic[val] = idx\\n        \\n        def f(start, end):\\n            if start > end:\\n                return None\\n            node = TreeNode(postorder.pop())\\n            index = dic[node.val]\\n            node.right = f(index+1, end)\\n            node.left = f(start, index-1)\\n            return node\\n\\n        return f(0, len(inorder)-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2281003,
                "title": "java-simple-solution-recursive-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n = postorder.length;\\n        return rBuildTree(postorder,0,n-1,inorder,0,n-1);\\n    }\\n    \\n    // psi -> Postorder starting index\\n    // pei -> Postorder ending index\\n    // isi -> Inorder starting index\\n    // iei -> Inorder ending index\\n    // colse -> Count of Left Sub Tree elements\\n    private TreeNode rBuildTree(int[] postorder, int psi, int pei, int[] inorder, int isi, int iei) {\\n        if(isi>iei)\\n            return null;\\n        int idx = isi;\\n        while(inorder[idx]!=postorder[pei])\\n            idx++;\\n        \\n        int colse = idx-isi;\\n        TreeNode node = new TreeNode(postorder[pei]);\\n        \\n        node.left = rBuildTree(postorder,psi,psi+colse-1,inorder,isi,idx-1); // left subtree call\\n        node.right = rBuildTree(postorder,psi+colse,pei-1,inorder,idx+1,iei); // right subtree call\\n        \\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n = postorder.length;\\n        return rBuildTree(postorder,0,n-1,inorder,0,n-1);\\n    }\\n    \\n    // psi -> Postorder starting index\\n    // pei -> Postorder ending index\\n    // isi -> Inorder starting index\\n    // iei -> Inorder ending index\\n    // colse -> Count of Left Sub Tree elements\\n    private TreeNode rBuildTree(int[] postorder, int psi, int pei, int[] inorder, int isi, int iei) {\\n        if(isi>iei)\\n            return null;\\n        int idx = isi;\\n        while(inorder[idx]!=postorder[pei])\\n            idx++;\\n        \\n        int colse = idx-isi;\\n        TreeNode node = new TreeNode(postorder[pei]);\\n        \\n        node.left = rBuildTree(postorder,psi,psi+colse-1,inorder,isi,idx-1); // left subtree call\\n        node.right = rBuildTree(postorder,psi+colse,pei-1,inorder,idx+1,iei); // right subtree call\\n        \\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804815,
                "title": "c-easy-and-clean-code-15ms-faster-than-88-23",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        if(inorder.size()!=postorder.size())\\n            return NULL;\\n        map<int,int> hm;\\n        for(int i=0;i<inorder.size();i++)\\n            hm[inorder[i]]=i;\\n        TreeNode* root=solve(inorder,0,inorder.size()-1,postorder,0,postorder.size()-1,hm);\\n        return root;\\n    }\\n    TreeNode* solve(vector<int> &inorder,int is,int ie,vector<int> &postorder,int ps,int pe,map<int,int> &hm){\\n        if(ps>pe || is>ie)\\n            return NULL;\\n        TreeNode* root=new TreeNode(postorder[pe]);\\n        int inRoot=hm[postorder[pe]];\\n        int numsleft=inRoot-is;\\n        root->left=solve(inorder,is,inRoot-1,postorder,ps,ps+numsleft-1,hm);\\n        root->right=solve(inorder,inRoot+1,ie,postorder,ps+numsleft,pe-1,hm);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        if(inorder.size()!=postorder.size())\\n            return NULL;\\n        map<int,int> hm;\\n        for(int i=0;i<inorder.size();i++)\\n            hm[inorder[i]]=i;\\n        TreeNode* root=solve(inorder,0,inorder.size()-1,postorder,0,postorder.size()-1,hm);\\n        return root;\\n    }\\n    TreeNode* solve(vector<int> &inorder,int is,int ie,vector<int> &postorder,int ps,int pe,map<int,int> &hm){\\n        if(ps>pe || is>ie)\\n            return NULL;\\n        TreeNode* root=new TreeNode(postorder[pe]);\\n        int inRoot=hm[postorder[pe]];\\n        int numsleft=inRoot-is;\\n        root->left=solve(inorder,is,inRoot-1,postorder,ps,ps+numsleft-1,hm);\\n        root->right=solve(inorder,inRoot+1,ie,postorder,ps+numsleft,pe-1,hm);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588924,
                "title": "c-106-construct-binary-tree-from-inorder-and-postorder-traversal",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int, int> mp; \\n        for (int i = 0; i < inorder.size(); ++i) mp[inorder[i]] = i; \\n        \\n        stack<TreeNode*> stk; \\n        TreeNode *root = nullptr, *node = nullptr; \\n        for (int i = postorder.size()-1; i >= 0; --i) {\\n            int x = postorder[i]; \\n            if (!root) root = node = new TreeNode(x); \\n            else if (mp[node->val] < mp[x]) {\\n                stk.push(node); \\n                node = node->right = new TreeNode(x); \\n            } else {\\n                while (stk.size() && mp[x] < mp[stk.top()->val]) node = stk.top(), stk.pop(); \\n                node = node->left = new TreeNode(x); \\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int, int> mp; \\n        for (int i = 0; i < inorder.size(); ++i) mp[inorder[i]] = i; \\n        \\n        stack<TreeNode*> stk; \\n        TreeNode *root = nullptr, *node = nullptr; \\n        for (int i = postorder.size()-1; i >= 0; --i) {\\n            int x = postorder[i]; \\n            if (!root) root = node = new TreeNode(x); \\n            else if (mp[node->val] < mp[x]) {\\n                stk.push(node); \\n                node = node->right = new TreeNode(x); \\n            } else {\\n                while (stk.size() && mp[x] < mp[stk.top()->val]) node = stk.top(), stk.pop(); \\n                node = node->left = new TreeNode(x); \\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588865,
                "title": "recursive-solution-python-with-o-n-time",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\'\\'\\'\\n             0 1 2  3  4\\ninorder =   [9,3,15,20,7]\\n             l         r\\n           l r   l     r\\n\\t\\t\\t\\npostorder = [9,15,7,20,3]\\n             l         r\\n           l r l     r\\n\\'\\'\\'\\n\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def rec(in_l, in_r, post_l, post_r):\\n            if in_l > in_r:\\n                return None\\n            if in_l == in_r:\\n                return TreeNode(inorder[in_l])\\n            \\n            pivot_val = postorder[post_r]\\n            left_node_nums = inorder_dict[pivot_val] - in_l\\n            \\n            pivot_node = TreeNode(pivot_val)\\n            pivot_node.left = rec(in_l, inorder_dict[pivot_val] - 1, post_l, post_l + left_node_nums - 1)\\n            pivot_node.right = rec(inorder_dict[pivot_val] + 1, in_r, post_l + left_node_nums, post_r - 1)\\n            \\n            return pivot_node\\n            \\n        inorder_dict = {val : idx for idx, val in enumerate(inorder)}\\n        \\n        N = len(postorder)\\n        return rec(0, N - 1, 0, N - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\'\\'\\'\\n             0 1 2  3  4\\ninorder =   [9,3,15,20,7]\\n             l         r\\n           l r   l     r\\n\\t\\t\\t\\npostorder = [9,15,7,20,3]\\n             l         r\\n           l r l     r\\n\\'\\'\\'\\n\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def rec(in_l, in_r, post_l, post_r):\\n            if in_l > in_r:\\n                return None\\n            if in_l == in_r:\\n                return TreeNode(inorder[in_l])\\n            \\n            pivot_val = postorder[post_r]\\n            left_node_nums = inorder_dict[pivot_val] - in_l\\n            \\n            pivot_node = TreeNode(pivot_val)\\n            pivot_node.left = rec(in_l, inorder_dict[pivot_val] - 1, post_l, post_l + left_node_nums - 1)\\n            pivot_node.right = rec(inorder_dict[pivot_val] + 1, in_r, post_l + left_node_nums, post_r - 1)\\n            \\n            return pivot_node\\n            \\n        inorder_dict = {val : idx for idx, val in enumerate(inorder)}\\n        \\n        N = len(postorder)\\n        return rec(0, N - 1, 0, N - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317025,
                "title": "easy-c-solution-99-faster-commented",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int postInd;\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        postInd=postorder.size()-1;\\n        \\n        //map all the elements of inorder to their index\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++)\\n            mp[inorder[i]]=i;\\n        \\n        return helper(0,inorder.size()-1,mp,postorder);\\n    }\\n    TreeNode* helper(int start,int end,unordered_map<int,int>& mp,vector<int>& postorder)\\n    {\\n        if(start>end)\\n            return NULL;\\n        int curr=postorder[postInd];\\n        TreeNode* node=new TreeNode(curr);\\n        postInd--;\\n        node->right=helper(mp[curr]+1,end,mp,postorder);\\n        node->left=helper(start,mp[curr]-1,mp,postorder);\\n        return node;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int postInd;\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        postInd=postorder.size()-1;\\n        \\n        //map all the elements of inorder to their index\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++)\\n            mp[inorder[i]]=i;\\n        \\n        return helper(0,inorder.size()-1,mp,postorder);\\n    }\\n    TreeNode* helper(int start,int end,unordered_map<int,int>& mp,vector<int>& postorder)\\n    {\\n        if(start>end)\\n            return NULL;\\n        int curr=postorder[postInd];\\n        TreeNode* node=new TreeNode(curr);\\n        postInd--;\\n        node->right=helper(mp[curr]+1,end,mp,postorder);\\n        node->left=helper(start,mp[curr]-1,mp,postorder);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963281,
                "title": "java-solution",
                "content": "java\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if(postorder.length == 0)\\n            return null;\\n        if(postorder.length == 1)\\n            return new TreeNode(postorder[0]);\\n        return helper(postorder.length-1, 0, inorder.length-1, postorder, inorder);\\n    }\\n    public TreeNode helper( int postend, int instart, int inend, int[] postorder, int[] inorder) {\\n        if(postend<0 || instart>inend)\\n            return null;\\n        TreeNode node = new TreeNode(postorder[postend]);\\n        int index=0;\\n        for(int i=instart;i<=inend;i++) {\\n            \\n            if(inorder[i] == node.val) {\\n                index=i;\\n                break;\\n            }\\n        }\\n        node.left = helper(postend - 1 - inend + index, instart, index-1, postorder, inorder);\\n        node.right = helper(postend-1, index+1, inend, postorder, inorder);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if(postorder.length == 0)\\n            return null;\\n        if(postorder.length == 1)\\n            return new TreeNode(postorder[0]);\\n        return helper(postorder.length-1, 0, inorder.length-1, postorder, inorder);\\n    }\\n    public TreeNode helper( int postend, int instart, int inend, int[] postorder, int[] inorder) {\\n        if(postend<0 || instart>inend)\\n            return null;\\n        TreeNode node = new TreeNode(postorder[postend]);\\n        int index=0;\\n        for(int i=instart;i<=inend;i++) {\\n            \\n            if(inorder[i] == node.val) {\\n                index=i;\\n                break;\\n            }\\n        }\\n        node.left = helper(postend - 1 - inend + index, instart, index-1, postorder, inorder);\\n        node.right = helper(postend-1, index+1, inend, postorder, inorder);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492750,
                "title": "my-accepted-swift-soluti-n",
                "content": "```\\nclass Solution {\\n    var idx:Int = 0\\n    func buildTree(_ inorder: [Int], _ postorder: [Int]) -> TreeNode? {\\n        if inorder.count != postorder.count {return nil}\\n        if inorder.count == 0 {return nil}\\n        idx = postorder.count - 1\\n        return helper(inorder, postorder, 0, idx)\\n    }\\n    \\n    func helper(_ inorder: [Int], _ postorder: [Int], _ start:Int, _ end: Int)-> TreeNode? {\\n        if start > end {return nil}\\n        let node = TreeNode(postorder[idx])\\n        idx -= 1\\n        if start == end { return node }\\n        let index = findIdx(inorder, node.val, end)\\n        node.right = helper(inorder, postorder, index+1, end)\\n        node.left = helper(inorder, postorder, start, index-1)\\n        return node\\n    }\\n    \\n    func findIdx(_ inorder: [Int], _ val:Int, _ end:Int)->Int{\\n        for i in (0...end).reversed(){\\n            if inorder[i] == val{ return i }\\n        }\\n        return 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    var idx:Int = 0\\n    func buildTree(_ inorder: [Int], _ postorder: [Int]) -> TreeNode? {\\n        if inorder.count != postorder.count {return nil}\\n        if inorder.count == 0 {return nil}\\n        idx = postorder.count - 1\\n        return helper(inorder, postorder, 0, idx)\\n    }\\n    \\n    func helper(_ inorder: [Int], _ postorder: [Int], _ start:Int, _ end: Int)-> TreeNode? {\\n        if start > end {return nil}\\n        let node = TreeNode(postorder[idx])\\n        idx -= 1\\n        if start == end { return node }\\n        let index = findIdx(inorder, node.val, end)\\n        node.right = helper(inorder, postorder, index+1, end)\\n        node.left = helper(inorder, postorder, start, index-1)\\n        return node\\n    }\\n    \\n    func findIdx(_ inorder: [Int], _ val:Int, _ end:Int)->Int{\\n        for i in (0...end).reversed(){\\n            if inorder[i] == val{ return i }\\n        }\\n        return 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338524,
                "title": "java-using-hashmap",
                "content": "\\tclass Solution {\\n\\t\\t\\tint n = 0;\\n\\t\\t\\tMap<Integer, Integer> hm = new HashMap<>();\\n\\t\\t\\tpublic TreeNode buildTree(int[] inorder, int[] postorder) {\\n\\t\\t\\t\\tn = inorder.length-1;\\n\\t\\t\\t\\tfor (int i=0; i< inorder.length; i++){\\n\\t\\t\\t\\t\\thm.put(inorder[i], i);   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn buildTree(postorder, inorder, 0, inorder.length-1);\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate TreeNode buildTree(int[] postorder, int[] inorder, int start, int end) {\\n\\t\\t\\t\\tif (start > end) return null;\\n\\n\\t\\t\\t\\tTreeNode root = new TreeNode(postorder[n]);\\n\\t\\t\\t\\tn--;\\n\\n\\t\\t\\t\\tif (start == end) return root;\\n\\n\\t\\t\\t\\tint index = hm.get(root.val);\\n\\n\\t\\t\\t\\troot.right = buildTree(postorder, inorder, index + 1, end);\\n\\t\\t\\t\\troot.left = buildTree(postorder, inorder, start, index - 1);\\n\\n\\t\\t\\t\\treturn root;\\n\\n\\t\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tint n = 0;\\n\\t\\t\\tMap<Integer, Integer> hm = new HashMap<>();\\n\\t\\t\\tpublic TreeNode buildTree(int[] inorder, int[] postorder) {\\n\\t\\t\\t\\tn = inorder.length-1;\\n\\t\\t\\t\\tfor (int i=0; i< inorder.length; i++){\\n\\t\\t\\t\\t\\thm.put(inorder[i], i);   \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 153572,
                "title": "python-recursive-iterative",
                "content": "```\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if inorder:\\n            root = TreeNode(postorder.pop())\\n            ind = inorder.index(root.val)\\n            root.right = self.buildTree(inorder[ind+1:], postorder)\\n            root.left = self.buildTree(inorder[:ind], postorder)\\n            return root\\n\\n    def buildTree2(self, inorder, postorder):\\n        self.inorder = inorder\\n        self.postorder = postorder\\n        self.indDict = {val: i for i, val in enumerate(self.inorder)}\\n        return self.helper(0, len(inorder))\\n    \\n    def helper(self, leftInd, rightInd):\\n        if leftInd < rightInd:\\n            root = TreeNode(self.postorder.pop())\\n            rootInd = self.indDict[root.val]\\n            root.right = self.helper(rootInd+1, rightInd)\\n            root.left = self.helper(leftInd, rootInd)\\n            return root\\n    \\n    def buildTree3(self, inorder, postorder):\\n        if not inorder:\\n            return None\\n            \\n        root = TreeNode(postorder[-1])\\n        stack = [root]\\n        i, j = len(postorder)-2, len(inorder) - 1\\n        while i >= 0:\\n            node = TreeNode(postorder[i])\\n            tmp = None\\n            while stack and stack[-1].val == inorder[j]:\\n                tmp = stack.pop()\\n                j -= 1\\n            if tmp:\\n                tmp.left = node\\n            else:\\n                stack[-1].right = node\\n            \\n            stack.append(node)\\n            i -= 1\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if inorder:\\n            root = TreeNode(postorder.pop())\\n            ind = inorder.index(root.val)\\n            root.right = self.buildTree(inorder[ind+1:], postorder)\\n            root.left = self.buildTree(inorder[:ind], postorder)\\n            return root\\n\\n    def buildTree2(self, inorder, postorder):\\n        self.inorder = inorder\\n        self.postorder = postorder\\n        self.indDict = {val: i for i, val in enumerate(self.inorder)}\\n        return self.helper(0, len(inorder))\\n    \\n    def helper(self, leftInd, rightInd):\\n        if leftInd < rightInd:\\n            root = TreeNode(self.postorder.pop())\\n            rootInd = self.indDict[root.val]\\n            root.right = self.helper(rootInd+1, rightInd)\\n            root.left = self.helper(leftInd, rootInd)\\n            return root\\n    \\n    def buildTree3(self, inorder, postorder):\\n        if not inorder:\\n            return None\\n            \\n        root = TreeNode(postorder[-1])\\n        stack = [root]\\n        i, j = len(postorder)-2, len(inorder) - 1\\n        while i >= 0:\\n            node = TreeNode(postorder[i])\\n            tmp = None\\n            while stack and stack[-1].val == inorder[j]:\\n                tmp = stack.pop()\\n                j -= 1\\n            if tmp:\\n                tmp.left = node\\n            else:\\n                stack[-1].right = node\\n            \\n            stack.append(node)\\n            i -= 1\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138184,
                "title": "my-javascript-solution-with-self-explains",
                "content": "```\\nvar buildTree = function(inorder, postorder) {\\n    if (inorder.length == 0) return [];\\n    let rootNode = new TreeNode(postorder[postorder.length - 1]);\\n    let rootIndex = inorder.indexOf(rootNode.val);\\n    let leftInorder = inorder.slice(0, rootIndex);\\n    let rightInorder = inorder.slice(rootIndex + 1);\\n    let leftPostorder = postorder.slice(0, leftInorder.length);\\n    let rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);\\n    if (leftInorder.length == 0) {\\n        rootNode.left = null;\\n    } else {\\n        rootNode.left = buildTree(leftInorder, leftPostorder);\\n    }\\n    if (rightInorder.length == 0) {\\n        rootNode.right = null;\\n    } else {\\n        rootNode.right = buildTree(rightInorder, rightPostorder);\\n    }\\n    return rootNode;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar buildTree = function(inorder, postorder) {\\n    if (inorder.length == 0) return [];\\n    let rootNode = new TreeNode(postorder[postorder.length - 1]);\\n    let rootIndex = inorder.indexOf(rootNode.val);\\n    let leftInorder = inorder.slice(0, rootIndex);\\n    let rightInorder = inorder.slice(rootIndex + 1);\\n    let leftPostorder = postorder.slice(0, leftInorder.length);\\n    let rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);\\n    if (leftInorder.length == 0) {\\n        rootNode.left = null;\\n    } else {\\n        rootNode.left = buildTree(leftInorder, leftPostorder);\\n    }\\n    if (rightInorder.length == 0) {\\n        rootNode.right = null;\\n    } else {\\n        rootNode.right = buildTree(rightInorder, rightPostorder);\\n    }\\n    return rootNode;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963157,
                "title": "easy-c-solutions-with-video-explanation-with-and-without-map-beats-100",
                "content": "# [Video link](https://youtu.be/ffE1xj51EBQ?feature=shared)\\n\\n# Code\\n```\\n// Without map\\nclass Solution {\\npublic:\\n    int findPos(vector<int> inorder, int element){\\n        for(int i=0; i<inorder.size(); i++){\\n            if(inorder[i] == element)\\n                return i;\\n        }\\n        return -1;\\n    }\\n\\n    TreeNode *solve(vector<int> inorder, vector<int> postorder, int &postIndex, int inStart, int inEnd){\\n        //base case\\n        if(postIndex < 0 || inStart > inEnd)\\n            return NULL;\\n        \\n        // Find the corresponding index in inorder traversal\\n        int element = postorder[postIndex--];\\n        TreeNode *node = new TreeNode(element);\\n        int pos = findPos(inorder, element);\\n\\n        // Solve for thr right first because postorder follows left->right->node\\n        // so when traversing from behind, we should solve right after node\\n        node->right = solve(inorder, postorder, postIndex, pos+1, inEnd);\\n        node->left = solve(inorder, postorder, postIndex, inStart, pos-1);\\n\\n        return node;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int postIndex = postorder.size()-1;\\n        return solve(inorder, postorder, postIndex, 0, inorder.size()-1);\\n    }\\n};\\n\\n// With map\\nclass Solution {\\npublic:\\n    unordered_map<int, int> mp;\\n\\n    TreeNode *solve(vector<int> inorder, vector<int> postorder, int &postIndex, int inStart, int inEnd){\\n        //base case\\n        if(postIndex < 0 || inStart > inEnd)\\n            return NULL;\\n        \\n        // Find the corresponding index in inorder from map\\n        int element = postorder[postIndex--];\\n        TreeNode *node = new TreeNode(element);\\n        int pos = mp[element];\\n\\n        // Solve for thr right first because postorder follows left->right->node\\n        // so when traversing from behind, we should solve right after node\\n        node->right = solve(inorder, postorder, postIndex, pos+1, inEnd);\\n        node->left = solve(inorder, postorder, postIndex, inStart, pos-1);\\n\\n        return node;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        // create a mapping of inorder traversals \\n        for(int i=0; i<inorder.size(); i++)\\n            mp[inorder[i]] = i;\\n\\n        int postIndex = postorder.size()-1;\\n        return solve(inorder, postorder, postIndex, 0, inorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Without map\\nclass Solution {\\npublic:\\n    int findPos(vector<int> inorder, int element){\\n        for(int i=0; i<inorder.size(); i++){\\n            if(inorder[i] == element)\\n                return i;\\n        }\\n        return -1;\\n    }\\n\\n    TreeNode *solve(vector<int> inorder, vector<int> postorder, int &postIndex, int inStart, int inEnd){\\n        //base case\\n        if(postIndex < 0 || inStart > inEnd)\\n            return NULL;\\n        \\n        // Find the corresponding index in inorder traversal\\n        int element = postorder[postIndex--];\\n        TreeNode *node = new TreeNode(element);\\n        int pos = findPos(inorder, element);\\n\\n        // Solve for thr right first because postorder follows left->right->node\\n        // so when traversing from behind, we should solve right after node\\n        node->right = solve(inorder, postorder, postIndex, pos+1, inEnd);\\n        node->left = solve(inorder, postorder, postIndex, inStart, pos-1);\\n\\n        return node;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int postIndex = postorder.size()-1;\\n        return solve(inorder, postorder, postIndex, 0, inorder.size()-1);\\n    }\\n};\\n\\n// With map\\nclass Solution {\\npublic:\\n    unordered_map<int, int> mp;\\n\\n    TreeNode *solve(vector<int> inorder, vector<int> postorder, int &postIndex, int inStart, int inEnd){\\n        //base case\\n        if(postIndex < 0 || inStart > inEnd)\\n            return NULL;\\n        \\n        // Find the corresponding index in inorder from map\\n        int element = postorder[postIndex--];\\n        TreeNode *node = new TreeNode(element);\\n        int pos = mp[element];\\n\\n        // Solve for thr right first because postorder follows left->right->node\\n        // so when traversing from behind, we should solve right after node\\n        node->right = solve(inorder, postorder, postIndex, pos+1, inEnd);\\n        node->left = solve(inorder, postorder, postIndex, inStart, pos-1);\\n\\n        return node;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        // create a mapping of inorder traversals \\n        for(int i=0; i<inorder.size(); i++)\\n            mp[inorder[i]] = i;\\n\\n        int postIndex = postorder.size()-1;\\n        return solve(inorder, postorder, postIndex, 0, inorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306792,
                "title": "short-sweet-easy-to-understand-c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int x ;\\n    TreeNode* solve(vector<int> &a,vector<int> &b,int s,int e){\\n        if(s>e)return NULL;\\n        TreeNode* node = new TreeNode(b[x++]);\\n        int i;\\n        for(i = s; i<=e; i++){\\n            if(node->val == a[i]){\\n                break;\\n            }\\n        }\\n        node->right = solve(a,b,i+1,e);\\n        node->left = solve(a,b,s,i-1);\\n        return node;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        reverse(postorder.begin(),postorder.end());\\n        x = 0;\\n        return solve(inorder,postorder,0,inorder.size()-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x ;\\n    TreeNode* solve(vector<int> &a,vector<int> &b,int s,int e){\\n        if(s>e)return NULL;\\n        TreeNode* node = new TreeNode(b[x++]);\\n        int i;\\n        for(i = s; i<=e; i++){\\n            if(node->val == a[i]){\\n                break;\\n            }\\n        }\\n        node->right = solve(a,b,i+1,e);\\n        node->left = solve(a,b,s,i-1);\\n        return node;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        reverse(postorder.begin(),postorder.end());\\n        x = 0;\\n        return solve(inorder,postorder,0,inorder.size()-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305274,
                "title": "python-short-and-clean",
                "content": "# Approach\\nTL;DR, Similar to [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/3305262/python-short-and-clean/).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def buildTree(self, inorder: list[int], postorder: list[int]) -> TreeNode | None:\\n        in_index_map = dict(map(reversed, enumerate(inorder)))\\n        \\n        def build_tree(post_end: int, in_start: int, in_end: int) -> tuple[TreeNode | None, int]:\\n            if in_start >= in_end: return None, post_end\\n            \\n            root_val = postorder[post_end]\\n            root_index = in_index_map[root_val]\\n            \\n            r_tree, post_start = build_tree(post_end - 1, root_index + 1, in_end)\\n            l_tree, post_start = build_tree(post_start, in_start, root_index)\\n            \\n            return TreeNode(root_val, l_tree, r_tree), post_start\\n        \\n        return build_tree(len(postorder) - 1, 0, len(inorder))[0]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Divide and Conquer",
                    "Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def buildTree(self, inorder: list[int], postorder: list[int]) -> TreeNode | None:\\n        in_index_map = dict(map(reversed, enumerate(inorder)))\\n        \\n        def build_tree(post_end: int, in_start: int, in_end: int) -> tuple[TreeNode | None, int]:\\n            if in_start >= in_end: return None, post_end\\n            \\n            root_val = postorder[post_end]\\n            root_index = in_index_map[root_val]\\n            \\n            r_tree, post_start = build_tree(post_end - 1, root_index + 1, in_end)\\n            l_tree, post_start = build_tree(post_start, in_start, root_index)\\n            \\n            return TreeNode(root_val, l_tree, r_tree), post_start\\n        \\n        return build_tree(len(postorder) - 1, 0, len(inorder))[0]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304807,
                "title": "binary-tree-node",
                "content": "\\n\\n```\\nvar buildTree = function(inorder, postorder) {\\n    if (inorder.length === 0 || postorder.length === 0) {\\n        return null;\\n    }\\n    \\n    const rootVal = postorder[postorder.length - 1];\\n    const root = new TreeNode(rootVal);\\n    const rootIndex = inorder.indexOf(rootVal);\\n    \\n    const leftInorder = inorder.slice(0, rootIndex);\\n    const rightInorder = inorder.slice(rootIndex + 1);\\n    const leftPostorder = postorder.slice(0, leftInorder.length);\\n    const rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);\\n    \\n    root.left = buildTree(leftInorder, leftPostorder);\\n    root.right = buildTree(rightInorder, rightPostorder);\\n    \\n    return root;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree"
                ],
                "code": "```\\nvar buildTree = function(inorder, postorder) {\\n    if (inorder.length === 0 || postorder.length === 0) {\\n        return null;\\n    }\\n    \\n    const rootVal = postorder[postorder.length - 1];\\n    const root = new TreeNode(rootVal);\\n    const rootIndex = inorder.indexOf(rootVal);\\n    \\n    const leftInorder = inorder.slice(0, rootIndex);\\n    const rightInorder = inorder.slice(rootIndex + 1);\\n    const leftPostorder = postorder.slice(0, leftInorder.length);\\n    const rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);\\n    \\n    root.left = buildTree(leftInorder, leftPostorder);\\n    root.right = buildTree(rightInorder, rightPostorder);\\n    \\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3303455,
                "title": "easy-solution-in-java-with-detail-explanation-beginner-friendly",
                "content": "# Intuition\\nInorder :- Left -> Root - > Right\\nPost Order:- Left -> Right -> Root\\n\\nRoot of tree is end of postorder, root comes between left and right in order, so we find root first in inorder, left side of root is left node of tree and right side is right side nodes of tree.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Find Root** :- we get root at end of postorder.\\n2. **Find left and right side nodes**:- root is always between left and ride in inorder, and we know who is root of tree from step 1. Find root in inorder, left side of root is left nodes of tree and right side is right side node of tree.\\n3. **Draw Subtree**:- Att now we know left side and right side nodes, so we repeat step 1 and 2 for subtree. So we divide inorder and post order array into two parts like left side and right side to figure out left subtree and right subtree.\\n\\nLet take one example\\n```\\n    inorder   = [4 2 5 1 6 3 7]\\n    postorder = [4 5 2 6 7 3 1]\\n\\n    So root would be 1 here and Left array which lay left of 1 is [4 2 5] and Right of 1 is [6 3 7]\\n    so left_inorder_array =  [4 2 5] and right_inorder_arry = [6 3 7]\\n\\n    using 6 [ which is just rigth of 1] we are going to devide Postorder_array into two part\\n    [4 5 2] and [6 7 3]\\n\\n\\n    1st Phase=>        \\n\\t                   1\\n\\n                   /        \\\\\\n\\n                [4 2 5]   [6 3 7]       <= inorder array\\n                [4 5 2]   [6 7 3]       <= postorder array\\n\\nNow we have new freash problem like need to make tree by using inorder = [4 2 5] && postorder =  [4 5 2] for left subtree \\nAND inorder = [6 3 7] && postorder = [6 7 3] for right  subtree \\n**now same process we need to do again and again  until One Of the array dose not got empty\\nRest of the Process show in a diagram Form :)\\n\\n    2nd Phase =>\\n                           1\\n\\n                      /        \\\\\\n                     2          3\\n                [4]    [5]   [6]   [7]       <= inorder array\\n                [4]    [5]   [6]   [7]       <= postorder array\\n\\n\\n3rd Phase =>  \\n\\t             1\\n\\n               /    \\\\\\n              2      3\\n \\n            /  \\\\    /  \\\\             <==== Answer\\n \\n           4    5  6    7 \\n``` \\n\\nIf You Really Like It please upvote tr\\nExample credit @ https://leetcode.com/suman_buie/\\n\\n# Complexity\\n- Time complexity: O (n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private TreeNode buildTree(int[] inorder, int iS, int iE, int[] postorder, int ps, int pE) {\\n        if (ps > pE || iS > iE) {\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(postorder[pE]);\\n        int rootI = iS;\\n        while (root.val != inorder[rootI]) {\\n            rootI++;\\n        }\\n\\n        root.left = buildTree(inorder, iS, rootI - 1, postorder, ps, ps + rootI - iS - 1);\\n        root.right = buildTree(inorder, rootI + 1, iE, postorder, ps + rootI - iS, pE - 1);\\n        return root;\\n    }\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\\n    }\\n}\\n```\\n# HINDI Explanation \\nhttps://youtu.be/aWoKYJsOfYE\\n\\nIf You Really Like It please upvote \\nhappy Coding :)",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n    inorder   = [4 2 5 1 6 3 7]\\n    postorder = [4 5 2 6 7 3 1]\\n\\n    So root would be 1 here and Left array which lay left of 1 is [4 2 5] and Right of 1 is [6 3 7]\\n    so left_inorder_array =  [4 2 5] and right_inorder_arry = [6 3 7]\\n\\n    using 6 [ which is just rigth of 1] we are going to devide Postorder_array into two part\\n    [4 5 2] and [6 7 3]\\n\\n\\n    1st Phase=>        \\n\\t                   1\\n\\n                   /        \\\\\\n\\n                [4 2 5]   [6 3 7]       <= inorder array\\n                [4 5 2]   [6 7 3]       <= postorder array\\n\\nNow we have new freash problem like need to make tree by using inorder = [4 2 5] && postorder =  [4 5 2] for left subtree \\nAND inorder = [6 3 7] && postorder = [6 7 3] for right  subtree \\n**now same process we need to do again and again  until One Of the array dose not got empty\\nRest of the Process show in a diagram Form :)\\n\\n    2nd Phase =>\\n                           1\\n\\n                      /        \\\\\\n                     2          3\\n                [4]    [5]   [6]   [7]       <= inorder array\\n                [4]    [5]   [6]   [7]       <= postorder array\\n\\n\\n3rd Phase =>  \\n\\t             1\\n\\n               /    \\\\\\n              2      3\\n \\n            /  \\\\    /  \\\\             <==== Answer\\n \\n           4    5  6    7 \\n```\n```\\nclass Solution {\\n    private TreeNode buildTree(int[] inorder, int iS, int iE, int[] postorder, int ps, int pE) {\\n        if (ps > pE || iS > iE) {\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(postorder[pE]);\\n        int rootI = iS;\\n        while (root.val != inorder[rootI]) {\\n            rootI++;\\n        }\\n\\n        root.left = buildTree(inorder, iS, rootI - 1, postorder, ps, ps + rootI - iS - 1);\\n        root.right = buildTree(inorder, rootI + 1, iE, postorder, ps + rootI - iS, pE - 1);\\n        return root;\\n    }\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303236,
                "title": "python-intuition-and-inline-detailed-explanation",
                "content": "```\\n#Intuition\\n#1. In post order list, the last element is the root node\\n#2. find the index of the root node at inorder list\\n#3. At inorder list:\\n    # we can divide the inorder list into two subtrees(left and right) at the root node index(step 2)\\n    # make sure to not include the mid node(root node) while dividing\\n#4. At postorder list:\\n    # the same index(step 2) can be used to divide the postorder list into subtrees\\n    # but make sure to include the middle node(non root node) to the right tree\\n    # also make sure that the root node(last node) is removed\\n#do this recursively\\n\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        #if no element then return empty binary tree\\n        if not inorder or not postorder:\\n            return None\\n\\n        #1. last element in the postorder list is the root\\n        root_val=postorder[-1]\\n\\n        #2. get the index to split\\n        mid=inorder.index(root_val)# we can use index because all nodes have unique val\\n\\n        #3. splitting inorder list into left and right subtree dividing at root.val\\n        left_inorder=inorder[:mid] #excluding the middle(root node)\\n        right_inorder=inorder[mid+1:] #excluding the middle(root node)\\n\\n        #4. split post order also at the same position including the middle \\n        left_postorder=postorder[:mid]# not including mid node\\n        right_postorder=postorder[mid:]# including mid node to right tree\\n        right_postorder.pop()#remove the root value from the post order\\n\\n        left_tree=self.buildTree(left_inorder,left_postorder)\\n        right_tree=self.buildTree(right_inorder,right_postorder)\\n\\n        return TreeNode(root_val,left_tree,right_tree)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#Intuition\\n#1. In post order list, the last element is the root node\\n#2. find the index of the root node at inorder list\\n#3. At inorder list:\\n    # we can divide the inorder list into two subtrees(left and right) at the root node index(step 2)\\n    # make sure to not include the mid node(root node) while dividing\\n#4. At postorder list:\\n    # the same index(step 2) can be used to divide the postorder list into subtrees\\n    # but make sure to include the middle node(non root node) to the right tree\\n    # also make sure that the root node(last node) is removed\\n#do this recursively\\n\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        #if no element then return empty binary tree\\n        if not inorder or not postorder:\\n            return None\\n\\n        #1. last element in the postorder list is the root\\n        root_val=postorder[-1]\\n\\n        #2. get the index to split\\n        mid=inorder.index(root_val)# we can use index because all nodes have unique val\\n\\n        #3. splitting inorder list into left and right subtree dividing at root.val\\n        left_inorder=inorder[:mid] #excluding the middle(root node)\\n        right_inorder=inorder[mid+1:] #excluding the middle(root node)\\n\\n        #4. split post order also at the same position including the middle \\n        left_postorder=postorder[:mid]# not including mid node\\n        right_postorder=postorder[mid:]# including mid node to right tree\\n        right_postorder.pop()#remove the root value from the post order\\n\\n        left_tree=self.buildTree(left_inorder,left_postorder)\\n        right_tree=self.buildTree(right_inorder,right_postorder)\\n\\n        return TreeNode(root_val,left_tree,right_tree)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303170,
                "title": "easy-rust-recursive",
                "content": "# Code\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn build_tree(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\\n        Self::builder(&inorder, &postorder)\\n    }\\n    pub fn builder(inorder: &[i32], mut postorder: &[i32]) -> Option<Rc<RefCell<TreeNode>>>{\\n        if inorder.is_empty() {\\n            return None\\n        }\\n\\n        let mut root = TreeNode::new(*postorder.last().unwrap());\\n\\n        let in_split = inorder.split(|&val| val == root.val).collect::<Vec<&[i32]>>();\\n\\n        root.left = Self::builder(in_split[0], &postorder[..in_split[0].len()]);\\n        root.right = Self::builder(in_split[1], &postorder[in_split[0].len()..postorder.len()-1]);\\n\\n        Some(Rc::new(RefCell::new(root)))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn build_tree(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\\n        Self::builder(&inorder, &postorder)\\n    }\\n    pub fn builder(inorder: &[i32], mut postorder: &[i32]) -> Option<Rc<RefCell<TreeNode>>>{\\n        if inorder.is_empty() {\\n            return None\\n        }\\n\\n        let mut root = TreeNode::new(*postorder.last().unwrap());\\n\\n        let in_split = inorder.split(|&val| val == root.val).collect::<Vec<&[i32]>>();\\n\\n        root.left = Self::builder(in_split[0], &postorder[..in_split[0].len()]);\\n        root.right = Self::builder(in_split[1], &postorder[in_split[0].len()..postorder.len()-1]);\\n\\n        Some(Rc::new(RefCell::new(root)))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3303156,
                "title": "best-c-solution-beats-100-simple-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int index;\\n    map<int,int> map;\\n    TreeNode* helper(vector<int>& inorder, vector<int>& postorder,int left,int right){\\n        if(left>right)\\n            return NULL;\\n\\n        int mid = map[postorder[index]];\\n        TreeNode* curr = new TreeNode(postorder[index--]);\\n\\n        curr->right = helper(inorder,postorder,mid+1,right);\\n        curr->left = helper(inorder,postorder,left,mid-1);\\n\\n        return curr;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        index = inorder.size()-1;\\n\\n        for(int i=0;i<postorder.size();i++)\\n            map[inorder[i]]=i;\\n\\n        return helper(inorder,postorder,0,postorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int index;\\n    map<int,int> map;\\n    TreeNode* helper(vector<int>& inorder, vector<int>& postorder,int left,int right){\\n        if(left>right)\\n            return NULL;\\n\\n        int mid = map[postorder[index]];\\n        TreeNode* curr = new TreeNode(postorder[index--]);\\n\\n        curr->right = helper(inorder,postorder,mid+1,right);\\n        curr->left = helper(inorder,postorder,left,mid-1);\\n\\n        return curr;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        index = inorder.size()-1;\\n\\n        for(int i=0;i<postorder.size();i++)\\n            map[inorder[i]]=i;\\n\\n        return helper(inorder,postorder,0,postorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303026,
                "title": "java-dfs-beats-97-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int i;\\n  Map<Integer, Integer> map = new HashMap<>();\\n\\n  private TreeNode buildTree(int[] postorder, int l, int r) {\\n    if (l > r) return null;\\n\\n    var m = map.get(postorder[i]);\\n    var node = new TreeNode(postorder[i--]);\\n\\n    node.right = buildTree(postorder, m+1, r);\\n    node.left = buildTree(postorder, l, m-1);\\n\\n    return node;\\n  }\\n\\n  public TreeNode buildTree(int[] inorder, int[] postorder) {\\n    for (var i=0; i < inorder.length; i++)\\n      map.put(inorder[i], i);\\n    \\n    i = postorder.length - 1;\\n    return buildTree(postorder, 0, inorder.length - 1);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  int i;\\n  Map<Integer, Integer> map = new HashMap<>();\\n\\n  private TreeNode buildTree(int[] postorder, int l, int r) {\\n    if (l > r) return null;\\n\\n    var m = map.get(postorder[i]);\\n    var node = new TreeNode(postorder[i--]);\\n\\n    node.right = buildTree(postorder, m+1, r);\\n    node.left = buildTree(postorder, l, m-1);\\n\\n    return node;\\n  }\\n\\n  public TreeNode buildTree(int[] inorder, int[] postorder) {\\n    for (var i=0; i < inorder.length; i++)\\n      map.put(inorder[i], i);\\n    \\n    i = postorder.length - 1;\\n    return buildTree(postorder, 0, inorder.length - 1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302742,
                "title": "c-recursive-solution-preorder-traversal",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        if(inorder.size()!=postorder.size()) return NULL;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp[inorder[i]]=i;\\n        }\\n        return buildTreePostIn(0,inorder.size()-1,postorder,0,postorder.size()-1,mp);\\n    }\\n\\n    TreeNode* buildTreePostIn(int is,int ie,vector<int>&postorder,int ps,int pe,unordered_map<int,int>&mp)\\n    {\\n        if(is>ie||ps>pe) return NULL;\\n        TreeNode* root=new TreeNode(postorder[pe]);\\n        int rootIo=mp[postorder[pe]];\\n        int numsLeft=rootIo-is;\\n\\n        root->left=buildTreePostIn(is,rootIo-1,postorder,ps,ps+numsLeft-1,mp);\\n        root->right=buildTreePostIn(rootIo+1,ie,postorder,ps+numsLeft,pe-1,mp);\\n        return root;\\n    }\\n\\n};\\n```\\n\\n![b0bf2fa1-1680-41fc-be3f-3ba1c8745505_1675216604.7695017.jpeg](https://assets.leetcode.com/users/images/d665b4ff-dc61-4bd3-88fe-657dcb2681a1_1678944554.805918.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        if(inorder.size()!=postorder.size()) return NULL;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            mp[inorder[i]]=i;\\n        }\\n        return buildTreePostIn(0,inorder.size()-1,postorder,0,postorder.size()-1,mp);\\n    }\\n\\n    TreeNode* buildTreePostIn(int is,int ie,vector<int>&postorder,int ps,int pe,unordered_map<int,int>&mp)\\n    {\\n        if(is>ie||ps>pe) return NULL;\\n        TreeNode* root=new TreeNode(postorder[pe]);\\n        int rootIo=mp[postorder[pe]];\\n        int numsLeft=rootIo-is;\\n\\n        root->left=buildTreePostIn(is,rootIo-1,postorder,ps,ps+numsLeft-1,mp);\\n        root->right=buildTreePostIn(rootIo+1,ie,postorder,ps+numsLeft,pe-1,mp);\\n        return root;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302341,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int linearSearch(int element,vector<int>& inorder)\\n    {\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            if(element==inorder[i])\\n                return i;\\n        }\\n        return -1;\\n    }\\n    TreeNode* solve(int& idx,int start,int end,vector<int>& inorder,vector<int>& postorder){\\n        if(start>end || idx<0) return NULL;\\n        int element=postorder[idx];\\n        idx--;\\n        int pos=linearSearch(element,inorder);\\n        TreeNode* root=new TreeNode(element);\\n        root->right=solve(idx,pos+1,end,inorder,postorder);\\n        root->left=solve(idx,start,pos-1,inorder,postorder);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        TreeNode* root;\\n        int n=inorder.size();\\n        int lastpos=n-1;\\n        root=solve(lastpos,0,n-1,inorder,postorder);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int linearSearch(int element,vector<int>& inorder)\\n    {\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            if(element==inorder[i])\\n                return i;\\n        }\\n        return -1;\\n    }\\n    TreeNode* solve(int& idx,int start,int end,vector<int>& inorder,vector<int>& postorder){\\n        if(start>end || idx<0) return NULL;\\n        int element=postorder[idx];\\n        idx--;\\n        int pos=linearSearch(element,inorder);\\n        TreeNode* root=new TreeNode(element);\\n        root->right=solve(idx,pos+1,end,inorder,postorder);\\n        root->left=solve(idx,start,pos-1,inorder,postorder);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        TreeNode* root;\\n        int n=inorder.size();\\n        int lastpos=n-1;\\n        root=solve(lastpos,0,n-1,inorder,postorder);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302261,
                "title": "c-binary-tree-recursive-faster-easy-to-understand",
                "content": "* ***Recursive***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // i will point on post array and it will give the root of the tree\\n    \\n    int i;\\n    \\n    // function for finding the position of the val in inorder array\\n    \\n    int search(vector<int>& in, int start, int end, int val)\\n    {\\n        for(int i = start; i <= end; i++)\\n        {\\n            if(in[i] == val)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    // recursive function for contructing binary tree\\n    \\n    TreeNode* construct(vector<int>& post, int start, int end, vector<int>& in)\\n    {\\n        // base case\\n        \\n        if(start > end)\\n        {\\n            return NULL;\\n        }\\n        \\n        // find the root_val\\n        \\n        int val = post[i];\\n        \\n        // decrement i\\n        \\n        i--;\\n        \\n        // search the position of val in inorder array, so that we can create right and left subtree\\n        \\n        int idx = search(in, start, end, val);\\n        \\n        // create root node\\n        \\n        TreeNode* root = new TreeNode(val);\\n        \\n        // create right subtree\\n        \\n        root -> right = construct(post, idx + 1, end, in);\\n        \\n        // create left subtree\\n        \\n        root -> left = construct(post, start, idx - 1, in);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& in, vector<int>& post) {\\n        \\n        int n = in.size();\\n        \\n        // initialize i\\n        \\n        i = n - 1;\\n        \\n        return construct(post, 0, n - 1, in);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // i will point on post array and it will give the root of the tree\\n    \\n    int i;\\n    \\n    // function for finding the position of the val in inorder array\\n    \\n    int search(vector<int>& in, int start, int end, int val)\\n    {\\n        for(int i = start; i <= end; i++)\\n        {\\n            if(in[i] == val)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    // recursive function for contructing binary tree\\n    \\n    TreeNode* construct(vector<int>& post, int start, int end, vector<int>& in)\\n    {\\n        // base case\\n        \\n        if(start > end)\\n        {\\n            return NULL;\\n        }\\n        \\n        // find the root_val\\n        \\n        int val = post[i];\\n        \\n        // decrement i\\n        \\n        i--;\\n        \\n        // search the position of val in inorder array, so that we can create right and left subtree\\n        \\n        int idx = search(in, start, end, val);\\n        \\n        // create root node\\n        \\n        TreeNode* root = new TreeNode(val);\\n        \\n        // create right subtree\\n        \\n        root -> right = construct(post, idx + 1, end, in);\\n        \\n        // create left subtree\\n        \\n        root -> left = construct(post, start, idx - 1, in);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& in, vector<int>& post) {\\n        \\n        int n = in.size();\\n        \\n        // initialize i\\n        \\n        i = n - 1;\\n        \\n        return construct(post, 0, n - 1, in);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302248,
                "title": "simple-python3-solution-upto-90-faster-explained",
                "content": "# Intuition\\nTo construct a binary tree from its inorder and postorder traversals, we can follow these steps:\\n\\n1. Start with the postorder traversal and take the last element as the root node of the binary tree.\\nEx : Case 1 : inorder = [9,3,15,20,7], postorder = [9,15,7,20,**3**]\\n\\n2. Find the index of the root node\\'s value in the inorder traversal. This gives us the sizes of the left and right subtrees of the root node.\\nEx: inorder: [9,(left)      **3**,     15,20,7(right)]\\n    postoder: [9,(Left)     15,7,20,(right),      **3**]\\n\\n3. Recursively construct the left subtree by using the left part of the inorder traversal and the corresponding part of the postorder traversal.\\n\\nWe repeat the Step 1 and Step2 until the end of Left side of Inorder then we do it for the right side.\\n\\n4. Recursively construct the right subtree by using the right part of the inorder traversal and the corresponding part of the postorder traversal.\\n5. Return the root node of the binary tree.\\n\\n# Complexity\\n- Time complexity:\\n**O(n*n)**\\n\\n- Space complexity:\\n**O(m)**\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]):\\n        def bTree(inorder, postorder):\\n            if not inorder:\\n                return None\\n            \\n            # Take the last element of the postorder traversal as the root node\\n            root_val = postorder.pop()\\n            root = TreeNode(root_val)\\n            \\n            # Find the index of the root node\\'s value in the inorder traversal\\n            root_index = inorder.index(root_val)\\n            \\n            # Recursively construct the left and right subtrees\\n            root.right = bTree(inorder[root_index+1:], postorder)\\n            root.left = bTree(inorder[:root_index], postorder)\\n            \\n            return root\\n\\n\\n        root = bTree(inorder, postorder)\\n        return root\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]):\\n        def bTree(inorder, postorder):\\n            if not inorder:\\n                return None\\n            \\n            # Take the last element of the postorder traversal as the root node\\n            root_val = postorder.pop()\\n            root = TreeNode(root_val)\\n            \\n            # Find the index of the root node\\'s value in the inorder traversal\\n            root_index = inorder.index(root_val)\\n            \\n            # Recursively construct the left and right subtrees\\n            root.right = bTree(inorder[root_index+1:], postorder)\\n            root.left = bTree(inorder[:root_index], postorder)\\n            \\n            return root\\n\\n\\n        root = bTree(inorder, postorder)\\n        return root\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134607,
                "title": "easy-c-solution-o-n-maps",
                "content": "# Time complexity : O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int postindex;\\n    \\n    TreeNode* solve(vector<int>& inorder, vector<int>& postorder, int is , int end, map<int, int>& mp) {\\n\\n        // base case\\n        if(is>end) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postindex]);\\n        int position = mp[postorder[postindex]];\\n        postindex--;\\n\\n        root->right = solve(inorder,postorder,position+1,end,mp);\\n        root->left = solve(inorder,postorder,is,position-1,mp);\\n        \\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n\\n        postindex = inorder.size()-1;\\n        map<int,int> mp;\\n        for(int i = 0; i<inorder.size(); i++){\\n            mp[inorder[i]] =i;\\n        }      \\n\\n        return solve(inorder,postorder,0,inorder.size()-1,mp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int postindex;\\n    \\n    TreeNode* solve(vector<int>& inorder, vector<int>& postorder, int is , int end, map<int, int>& mp) {\\n\\n        // base case\\n        if(is>end) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postindex]);\\n        int position = mp[postorder[postindex]];\\n        postindex--;\\n\\n        root->right = solve(inorder,postorder,position+1,end,mp);\\n        root->left = solve(inorder,postorder,is,position-1,mp);\\n        \\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n\\n        postindex = inorder.size()-1;\\n        map<int,int> mp;\\n        for(int i = 0; i<inorder.size(); i++){\\n            mp[inorder[i]] =i;\\n        }      \\n\\n        return solve(inorder,postorder,0,inorder.size()-1,mp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950789,
                "title": "c-not-that-easy-to-understand-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/716b8aaa-24c1-4826-987d-3123ab1df0b5_1671990677.607235.png)\\n\\n**N==number of nodes\\nT->O(N) && S->O(N) [Map] + O(N) [ASS]**\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* tree(vector<int>& in,int inStart,int inEnd,vector<int>& post,int postStart,int postEnd,map<int,int>& ind){\\n\\t\\t\\t\\tif(inStart>inEnd || postStart>postEnd) return NULL;\\n\\t\\t\\t\\tTreeNode* root=new TreeNode(post[postEnd]);\\n\\t\\t\\t\\tint inRoot=ind[root->val];\\n\\t\\t\\t\\tint numsleft=inRoot-inStart;\\n\\t\\t\\t\\troot->left=tree(in,inStart,inRoot-1,post,postStart,postStart+numsleft-1,ind);\\n\\t\\t\\t\\troot->right=tree(in,inRoot+1,inEnd,post,postStart+numsleft,postEnd-1,ind);\\n\\t\\t\\t\\treturn root;        \\n\\t\\t\\t}\\n\\n\\t\\t\\tTreeNode* buildTree(vector<int>& in, vector<int>& post) {\\n\\t\\t\\t\\tif(in.size()!=post.size()) return NULL;\\n\\t\\t\\t\\tmap<int,int>ind;\\n\\t\\t\\t\\tfor(int i=0;i<in.size();i++) ind[in[i]]=i;\\n\\t\\t\\t\\treturn tree(in,0,in.size()-1,post,0,post.size()-1,ind);\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* tree(vector<int>& in,int inStart,int inEnd,vector<int>& post,int postStart,int postEnd,map<int,int>& ind){\\n\\t\\t\\t\\tif(inStart>inEnd || postStart>postEnd) return NULL;\\n\\t\\t\\t\\tTreeNode* root=new TreeNode(post[postEnd]);\\n\\t\\t\\t\\tint inRoot=ind[root->val];\\n\\t\\t\\t\\tint numsleft=inRoot-inStart;\\n\\t\\t\\t\\troot->left=tree(in,inStart,inRoot-1,post,postStart,postStart+numsleft-1,ind);\\n\\t\\t\\t\\troot->right=tree(in,inRoot+1,inEnd,post,postStart+numsleft,postEnd-1,ind);\\n\\t\\t\\t\\treturn root;        \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2254521,
                "title": "easy-to-understand-c-recursion",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    int posInd;\\n    map<int,int> m;\\n    TreeNode* build(vector<int> pos,int s,int e){\\n        if(s>e) return NULL;\\n        //create node\\n        TreeNode* root = new TreeNode(pos[posInd]);\\n        int ind = m[pos[posInd]];\\n        posInd--;\\n        root->right = build(pos,ind+1,e);\\n        root->left = build(pos,s,ind-1);\\n        return root;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& in, vector<int>& pos) {\\n        posInd = in.size()-1;\\n        for(int i=0;i<in.size();i++) m[in[i]] = i;\\n        return build(pos,0,in.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int posInd;\\n    map<int,int> m;\\n    TreeNode* build(vector<int> pos,int s,int e){\\n        if(s>e) return NULL;\\n        //create node\\n        TreeNode* root = new TreeNode(pos[posInd]);\\n        int ind = m[pos[posInd]];\\n        posInd--;\\n        root->right = build(pos,ind+1,e);\\n        root->left = build(pos,s,ind-1);\\n        return root;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& in, vector<int>& pos) {\\n        posInd = in.size()-1;\\n        for(int i=0;i<in.size();i++) m[in[i]] = i;\\n        return build(pos,0,in.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182737,
                "title": "jai-striver",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int>inorder;\\n    vector<int>postorder;\\n     unordered_map <int , int > indexinorder;\\n    TreeNode* buildTree(vector<int>& Inorder, vector<int>& Postorder) {\\n        inorder=Inorder;\\n        postorder= Postorder;\\n       \\n        for(int i=0 ; i< inorder.size(); i++){\\n            indexinorder[inorder[i]]=i;\\n        }\\n        return go(0, postorder.size()-1, 0, inorder.size()-1);\\n        \\n    }\\n    TreeNode* go(int poststart, int postend, int instart, int inend){\\n        if(poststart>postend || instart>inend){\\n            return NULL;\\n        }\\n        TreeNode* root= new TreeNode(postorder[postend]);\\n        int indexroot= indexinorder[root->val];\\n        int eleleft = indexroot - instart;\\n        root->left= go(poststart, poststart+eleleft-1, instart, indexroot-1);\\n        root->right= go(poststart+eleleft,postend-1,indexroot+1, inend   );\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int>inorder;\\n    vector<int>postorder;\\n     unordered_map <int , int > indexinorder;\\n    TreeNode* buildTree(vector<int>& Inorder, vector<int>& Postorder) {\\n        inorder=Inorder;\\n        postorder= Postorder;\\n       \\n        for(int i=0 ; i< inorder.size(); i++){\\n            indexinorder[inorder[i]]=i;\\n        }\\n        return go(0, postorder.size()-1, 0, inorder.size()-1);\\n        \\n    }\\n    TreeNode* go(int poststart, int postend, int instart, int inend){\\n        if(poststart>postend || instart>inend){\\n            return NULL;\\n        }\\n        TreeNode* root= new TreeNode(postorder[postend]);\\n        int indexroot= indexinorder[root->val];\\n        int eleleft = indexroot - instart;\\n        root->left= go(poststart, poststart+eleleft-1, instart, indexroot-1);\\n        root->right= go(poststart+eleleft,postend-1,indexroot+1, inend   );\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034373,
                "title": "easy-c-solution",
                "content": "**If you like the solution please upvote it.**\\n\\n\\tunordered_map<int, int> mp;\\n    TreeNode* build(vector<int>& inorder, vector<int>& postorder, int &i, int l, int r)     {\\n        if(l>r)\\n            return NULL;\\n        TreeNode* node = new TreeNode(postorder[i]);\\n        int idx = mp[postorder[i--]];\\n        node->right = build(inorder, postorder, i, idx+1, r);\\n        node->left = build(inorder, postorder, i, l, idx-1);\\n        return node;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int n = inorder.size();\\n        for(int i=0;i<n;i++)\\n            mp[inorder[i]] = i;\\n        int i=n-1;\\n        return build(inorder, postorder, i, 0, n-1);\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "**If you like the solution please upvote it.**\\n\\n\\tunordered_map<int, int> mp;\\n    TreeNode* build(vector<int>& inorder, vector<int>& postorder, int &i, int l, int r)     {\\n        if(l>r)\\n            return NULL;\\n        TreeNode* node = new TreeNode(postorder[i]);\\n        int idx = mp[postorder[i--]];\\n        node->right = build(inorder, postorder, i, idx+1, r);\\n        node->left = build(inorder, postorder, i, l, idx-1);\\n        return node;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int n = inorder.size();\\n        for(int i=0;i<n;i++)\\n            mp[inorder[i]] = i;\\n        int i=n-1;\\n        return build(inorder, postorder, i, 0, n-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1952849,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<inorder.length; i++){\\n            map.put(inorder[i], i);\\n        }\\n        index = postorder.length-1;\\n        return build(inorder, postorder, map, 0, postorder.length-1);\\n    }\\n    \\n    public TreeNode build(int[] inorder, int[] postorder, HashMap<Integer, Integer> map, int start, int end){\\n        if(start > end) return null;\\n        TreeNode root = new TreeNode(postorder[index--]);\\n        int pos = map.get(root.val);\\n        root.right = build(inorder, postorder, map, pos+1, end);\\n        root.left = build(inorder, postorder, map, start, pos-1);\\n        return root;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<inorder.length; i++){\\n            map.put(inorder[i], i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1860753,
                "title": "easy-to-understand-c-o-n-approach",
                "content": "```\\nTC: O(n) if map takes O(1), otherwise O(nlogn) in worst-case\\nSC: O(n)\\n```\\nI would suggest doing a dry-run by drawing 2-3 binary trees and going through the logic for better understanding.\\n```\\n// Given an inorder and a postorder traversal of a binary tree, the binary tree that is generated from it will be unique\\nclass Solution {\\nprivate:\\n\\t// inStart & postStart: starting index of inorder and postorder, inEnd & postEnd: ending index, inMappings: mappings for inorder values \\n    TreeNode* buildTree(vector<int> &inorder, int inStart, int inEnd, vector<int> &postorder, int postStart, int postEnd, map<int, int> &inMappings) {\\n        if(inStart > inEnd || postStart > postEnd) return NULL; // base case\\n        \\n        TreeNode* root = new TreeNode(postorder[postEnd]); // create the root node of this tree\\n        \\n        int inRoot = inMappings[root->val]; // index at which the root node is present\\n        \\n        int numsLeft = inRoot - inStart; // number of nodes to the left of root node\\n        \\n        // attach the left and right subtrees using recursion\\n        root->left = buildTree(inorder, inStart, inRoot - 1, postorder, postStart, postStart + numsLeft - 1, inMappings);\\n        root->right = buildTree(inorder, inRoot + 1, inEnd, postorder, postStart + numsLeft, postEnd - 1, inMappings);\\n        \\n        return root;\\n    }\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        map<int, int> inMappings; // Inorder [node.val : index]\\n        \\n        for(int i = 0; i < inorder.size(); ++i) inMappings[inorder[i]] = i;\\n        \\n        return buildTree(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1, inMappings);\\n    }\\n\\t\\n```\\n\\t\\nAn upvote would be appreciated. ^_^",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTC: O(n) if map takes O(1), otherwise O(nlogn) in worst-case\\nSC: O(n)\\n```\n```\\n// Given an inorder and a postorder traversal of a binary tree, the binary tree that is generated from it will be unique\\nclass Solution {\\nprivate:\\n\\t// inStart & postStart: starting index of inorder and postorder, inEnd & postEnd: ending index, inMappings: mappings for inorder values \\n    TreeNode* buildTree(vector<int> &inorder, int inStart, int inEnd, vector<int> &postorder, int postStart, int postEnd, map<int, int> &inMappings) {\\n        if(inStart > inEnd || postStart > postEnd) return NULL; // base case\\n        \\n        TreeNode* root = new TreeNode(postorder[postEnd]); // create the root node of this tree\\n        \\n        int inRoot = inMappings[root->val]; // index at which the root node is present\\n        \\n        int numsLeft = inRoot - inStart; // number of nodes to the left of root node\\n        \\n        // attach the left and right subtrees using recursion\\n        root->left = buildTree(inorder, inStart, inRoot - 1, postorder, postStart, postStart + numsLeft - 1, inMappings);\\n        root->right = buildTree(inorder, inRoot + 1, inEnd, postorder, postStart + numsLeft, postEnd - 1, inMappings);\\n        \\n        return root;\\n    }\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        map<int, int> inMappings; // Inorder [node.val : index]\\n        \\n        for(int i = 0; i < inorder.size(); ++i) inMappings[inorder[i]] = i;\\n        \\n        return buildTree(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1, inMappings);\\n    }\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664652,
                "title": "javascript-solution",
                "content": "```\\nvar buildTree = function(inorder, postorder) {\\n    if (!inorder.length || !postorder.length) {\\n        return null;\\n    }\\n    var val = postorder.pop();\\n    var index = inorder.indexOf(val);\\n    var node = new TreeNode(val);\\n    node.right = buildTree(inorder.slice(index+1, inorder.length), postorder);\\n    node.left = buildTree(inorder.slice(0, index), postorder);\\n    return node;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nvar buildTree = function(inorder, postorder) {\\n    if (!inorder.length || !postorder.length) {\\n        return null;\\n    }\\n    var val = postorder.pop();\\n    var index = inorder.indexOf(val);\\n    var node = new TreeNode(val);\\n    node.right = buildTree(inorder.slice(index+1, inorder.length), postorder);\\n    node.left = buildTree(inorder.slice(0, index), postorder);\\n    return node;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1593196,
                "title": "java-easy-to-understand-solution-recursion",
                "content": "**Code**\\n```java\\npublic TreeNode buildTree(int[] inorder, int[] postorder) {\\n\\treturn buildTreeUtil(inorder, postorder, 0, inorder.length-1, 0, postorder.length - 1);\\n}\\n\\nprivate TreeNode buildTreeUtil(int[] inorder, int[] postorder, int inS, int inE, int postS, int postE) {\\n\\tif(inS > inE) return null;\\n\\n\\t// in postorder root is present at last index\\n\\tint rootData = postorder[postE];\\n\\tTreeNode root = new TreeNode(rootData);\\n\\tint rootIdx = -1;\\n\\n\\t// find rootData in inorder array\\n\\tfor(int i = inS; i <= inE; i++) {\\n\\t\\tif(inorder[i] == rootData) {\\n\\t\\t\\trootIdx = i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// generate indices of left and right subtree for both inorder and postorder array\\n\\tint leftInS = inS;\\n\\tint leftInE = rootIdx - 1;\\n\\tint leftPostS = postS;\\n\\tint leftPostE = leftPostS + (leftInE - leftInS);\\n\\n\\tint rightInS = rootIdx + 1;\\n\\tint rightInE = inE;\\n\\tint rightPostS = leftPostE + 1;\\n\\tint rightPostE = postE - 1;\\n\\n\\troot.left = buildTreeUtil(inorder, postorder, leftInS, leftInE, leftPostS, leftPostE);\\n\\troot.right = buildTreeUtil(inorder, postorder, rightInS, rightInE, rightPostS, rightPostE);\\n\\n\\treturn root;\\n}\\n```\\n\\nHope it helps\\nDo upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```java\\npublic TreeNode buildTree(int[] inorder, int[] postorder) {\\n\\treturn buildTreeUtil(inorder, postorder, 0, inorder.length-1, 0, postorder.length - 1);\\n}\\n\\nprivate TreeNode buildTreeUtil(int[] inorder, int[] postorder, int inS, int inE, int postS, int postE) {\\n\\tif(inS > inE) return null;\\n\\n\\t// in postorder root is present at last index\\n\\tint rootData = postorder[postE];\\n\\tTreeNode root = new TreeNode(rootData);\\n\\tint rootIdx = -1;\\n\\n\\t// find rootData in inorder array\\n\\tfor(int i = inS; i <= inE; i++) {\\n\\t\\tif(inorder[i] == rootData) {\\n\\t\\t\\trootIdx = i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// generate indices of left and right subtree for both inorder and postorder array\\n\\tint leftInS = inS;\\n\\tint leftInE = rootIdx - 1;\\n\\tint leftPostS = postS;\\n\\tint leftPostE = leftPostS + (leftInE - leftInS);\\n\\n\\tint rightInS = rootIdx + 1;\\n\\tint rightInE = inE;\\n\\tint rightPostS = leftPostE + 1;\\n\\tint rightPostE = postE - 1;\\n\\n\\troot.left = buildTreeUtil(inorder, postorder, leftInS, leftInE, leftPostS, leftPostE);\\n\\troot.right = buildTreeUtil(inorder, postorder, rightInS, rightInE, rightPostS, rightPostE);\\n\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352312,
                "title": "c-o-n-faster-than-100-using-hashmaps-3ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int index;\\n    unordered_map<int,int>m;\\n    TreeNode* helper(vector<int>& in, vector<int>& post, int lb, int ub)\\n    {\\n        if(lb>ub) return NULL;\\n        \\n        TreeNode* root = new TreeNode(post[index]);\\n        index--;\\n        \\n        if(lb==ub) return root;\\n        \\n        int mid = m[root->val];\\n        \\n        \\n        root->right = helper(in, post, mid+1, ub);\\n        root->left = helper(in, post, lb, mid-1);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) \\n    {\\n        index = postorder.size()-1;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            m[inorder[i]]=i;\\n        }\\n        TreeNode* root = helper(inorder, postorder, 0, inorder.size()-1);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int index;\\n    unordered_map<int,int>m;\\n    TreeNode* helper(vector<int>& in, vector<int>& post, int lb, int ub)\\n    {\\n        if(lb>ub) return NULL;\\n        \\n        TreeNode* root = new TreeNode(post[index]);\\n        index--;\\n        \\n        if(lb==ub) return root;\\n        \\n        int mid = m[root->val];\\n        \\n        \\n        root->right = helper(in, post, mid+1, ub);\\n        root->left = helper(in, post, lb, mid-1);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) \\n    {\\n        index = postorder.size()-1;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            m[inorder[i]]=i;\\n        }\\n        TreeNode* root = helper(inorder, postorder, 0, inorder.size()-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120416,
                "title": "iterative-java-code-reused-template-from-previous-question",
                "content": "I have already explained the idea in my post in the previous question(105), [here](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/1120355/Iterative-Java-solution)\\n\\nThe only changes needed from there:\\n1)inorderIndex now moves from n-1 to 0 instead of 0 to n.\\n2)preorderIndex now moves from n-2 to 0 instead of 1 to n.\\n3)if prev == null, you insert to the right instead of left. \\n4)Consequently, if prev is not null, insert to left instead of right.\\n\\nEverything else remains the same.\\n\\n```\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        ArrayDeque<TreeNode> stack = new ArrayDeque<>();\\n        int n = postorder.length;\\n        int inorderIndex = n-1;\\n        TreeNode root = new TreeNode(postorder[n-1]);\\n        stack.push(root);\\n        \\n        for(int i = n-2; i >= 0; i--){\\n            TreeNode prev = null;\\n            while(!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]){\\n                prev = stack.pop();\\n                inorderIndex--;\\n            }\\n            \\n            TreeNode toInsert = new TreeNode(postorder[i]);\\n            if(prev == null){\\n                prev = stack.peek();\\n                prev.right = toInsert;\\n            }\\n            else{\\n                prev.left = toInsert;\\n            }\\n            stack.push(toInsert);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n```java\\n/* Recursive\\n\\nclass Solution {\\n    int postorder[], inorder[]; \\n    int curr;\\n    \\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        this.postorder = postorder;\\n        this.inorder = inorder;\\n        int n = inorder.length;\\n        this.curr = n-1;\\n        \\n        Map<Integer, Integer> positions = new HashMap<>();\\n        for(int i = 0; i < n; i++)\\n            positions.put(inorder[i], i);\\n        \\n        TreeNode root = buildTree(positions, 0, n-1);\\n        return root;\\n    }\\n    \\n    private TreeNode buildTree(Map<Integer, Integer> positions, int start, int end){\\n        if(start > end) return null;\\n        \\n        int pos = positions.get(postorder[curr]);\\n        TreeNode root = new TreeNode(postorder[curr--]);\\n        \\n        root.right = buildTree(positions, pos+1, end);\\n        root.left = buildTree(positions, start, pos-1);\\n        \\n        return root;\\n    }\\n}\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        ArrayDeque<TreeNode> stack = new ArrayDeque<>();\\n        int n = postorder.length;\\n        int inorderIndex = n-1;\\n        TreeNode root = new TreeNode(postorder[n-1]);\\n        stack.push(root);\\n        \\n        for(int i = n-2; i >= 0; i--){\\n            TreeNode prev = null;\\n            while(!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]){\\n                prev = stack.pop();\\n                inorderIndex--;\\n            }\\n            \\n            TreeNode toInsert = new TreeNode(postorder[i]);\\n            if(prev == null){\\n                prev = stack.peek();\\n                prev.right = toInsert;\\n            }\\n            else{\\n                prev.left = toInsert;\\n            }\\n            stack.push(toInsert);\\n        }\\n        return root;\\n    }\\n}\\n```\n```java\\n/* Recursive\\n\\nclass Solution {\\n    int postorder[], inorder[]; \\n    int curr;\\n    \\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        this.postorder = postorder;\\n        this.inorder = inorder;\\n        int n = inorder.length;\\n        this.curr = n-1;\\n        \\n        Map<Integer, Integer> positions = new HashMap<>();\\n        for(int i = 0; i < n; i++)\\n            positions.put(inorder[i], i);\\n        \\n        TreeNode root = buildTree(positions, 0, n-1);\\n        return root;\\n    }\\n    \\n    private TreeNode buildTree(Map<Integer, Integer> positions, int start, int end){\\n        if(start > end) return null;\\n        \\n        int pos = positions.get(postorder[curr]);\\n        TreeNode root = new TreeNode(postorder[curr--]);\\n        \\n        root.right = buildTree(positions, pos+1, end);\\n        root.left = buildTree(positions, start, pos-1);\\n        \\n        return root;\\n    }\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100733,
                "title": "cpp-dfs-recursive",
                "content": "```\\n// https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\\n//\\n// Time Complexity:     O(N)\\n// Space Complexity:    O(H) + O(N) ~ O(N)\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        const int kSize = inorder.size();\\n        \\n        unordered_map<int, int> inorder_val_to_idx;\\n        for(int i = 0; i < kSize; ++i)\\n            inorder_val_to_idx[inorder[i]] = i;\\n        \\n        return dfs(kSize - 1, 0, kSize - 1, inorder, postorder, inorder_val_to_idx);\\n    }\\n    \\nprivate:\\n    TreeNode* dfs(\\n        int idx_postorder,\\n        int idx_start_inorder,\\n        int idx_end_inorder,\\n        vector<int> &inorder,\\n        vector<int> &postorder,\\n        unordered_map<int, int> &inorder_val_to_idx){\\n        \\n        if(idx_postorder < 0 || idx_start_inorder > idx_end_inorder)\\n            return NULL;\\n        \\n        int root_val = postorder[idx_postorder];\\n        TreeNode* root = new TreeNode(root_val);\\n        \\n        int idx_root = inorder_val_to_idx[root_val];\\n        \\n        root -> right = dfs(idx_postorder - 1, \\n                            idx_root + 1, \\n                            idx_end_inorder, \\n                            inorder, \\n                            postorder, \\n                            inorder_val_to_idx);\\n        \\n        root -> left = dfs(idx_postorder - (idx_end_inorder - idx_root + 1),\\n                           idx_start_inorder,\\n                           idx_root - 1,\\n                           inorder,\\n                           postorder,\\n                           inorder_val_to_idx);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\\n//\\n// Time Complexity:     O(N)\\n// Space Complexity:    O(H) + O(N) ~ O(N)\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        const int kSize = inorder.size();\\n        \\n        unordered_map<int, int> inorder_val_to_idx;\\n        for(int i = 0; i < kSize; ++i)\\n            inorder_val_to_idx[inorder[i]] = i;\\n        \\n        return dfs(kSize - 1, 0, kSize - 1, inorder, postorder, inorder_val_to_idx);\\n    }\\n    \\nprivate:\\n    TreeNode* dfs(\\n        int idx_postorder,\\n        int idx_start_inorder,\\n        int idx_end_inorder,\\n        vector<int> &inorder,\\n        vector<int> &postorder,\\n        unordered_map<int, int> &inorder_val_to_idx){\\n        \\n        if(idx_postorder < 0 || idx_start_inorder > idx_end_inorder)\\n            return NULL;\\n        \\n        int root_val = postorder[idx_postorder];\\n        TreeNode* root = new TreeNode(root_val);\\n        \\n        int idx_root = inorder_val_to_idx[root_val];\\n        \\n        root -> right = dfs(idx_postorder - 1, \\n                            idx_root + 1, \\n                            idx_end_inorder, \\n                            inorder, \\n                            postorder, \\n                            inorder_val_to_idx);\\n        \\n        root -> left = dfs(idx_postorder - (idx_end_inorder - idx_root + 1),\\n                           idx_start_inorder,\\n                           idx_root - 1,\\n                           inorder,\\n                           postorder,\\n                           inorder_val_to_idx);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963701,
                "title": "c-solution-easy-to-understand-with-o-n-time-and-o-n-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder)\\n    {\\n        int postEnd = postorder.size() - 1;\\n        int inStart = 0;\\n        int inEnd = inorder.size() - 1;\\n        return helper(postEnd, inStart, inEnd, inorder, postorder);\\n    }\\n\\n    // postorder = L R D\\n    // inorder = L D R\\n\\n    TreeNode *helper(int postEnd, int inStart, int inEnd, vector<int> &inorder, vector<int> &postorder)\\n    {\\n        if (postEnd < 0 || inStart > inEnd)\\n            return NULL;\\n\\n        TreeNode *result = new TreeNode(postorder[postEnd]);\\n\\n        int inIndex = 0;\\n        for (int i = inStart; i <= inEnd; i++)\\n        {\\n            if (inorder[i] == result->val)\\n                inIndex = i;\\n        }\\n\\n        result->right = helper(postEnd - 1, inIndex + 1, inEnd, inorder, postorder);\\n        result->left = helper(postEnd - inEnd + inIndex - 1, inStart, inIndex - 1, inorder, postorder);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder)\\n    {\\n        int postEnd = postorder.size() - 1;\\n        int inStart = 0;\\n        int inEnd = inorder.size() - 1;\\n        return helper(postEnd, inStart, inEnd, inorder, postorder);\\n    }\\n\\n    // postorder = L R D\\n    // inorder = L D R\\n\\n    TreeNode *helper(int postEnd, int inStart, int inEnd, vector<int> &inorder, vector<int> &postorder)\\n    {\\n        if (postEnd < 0 || inStart > inEnd)\\n            return NULL;\\n\\n        TreeNode *result = new TreeNode(postorder[postEnd]);\\n\\n        int inIndex = 0;\\n        for (int i = inStart; i <= inEnd; i++)\\n        {\\n            if (inorder[i] == result->val)\\n                inIndex = i;\\n        }\\n\\n        result->right = helper(postEnd - 1, inIndex + 1, inEnd, inorder, postorder);\\n        result->left = helper(postEnd - inEnd + inIndex - 1, inStart, inIndex - 1, inorder, postorder);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758643,
                "title": "constructing-binary-tree-from-inorder-and-postorder-traversal-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* helper(unordered_map<int,int>& mp, vector<int>& inorder, vector<int>& postorder, int i_first, int i_last)\\n    {\\n        if(i_first > i_last) // base condition by checking size of subtree\\n            return NULL;\\n        \\n        // the approach I have used is to first find the root node value, then break the inorder vector into left subtree and right subtree with respect to the root node. Then filling its left and right subtrees and finally returning the root node.\\n        int val,index = -1;\\n        // the node which lies inside the range of given inorder and is rightmost in the postorder is regarded as the current root node.\\n        for(auto it=postorder.rbegin();it!=postorder.rend();it++)\\n        {\\n            if(mp[*it] >= i_first && mp[*it] <= i_last)\\n            {\\n                index = mp[*it];\\n                break;\\n            }\\n        }\\n        val = inorder[index];\\n        TreeNode* root = new TreeNode(val);\\n        \\n        root->left = helper(mp,inorder,postorder,i_first,index-1);\\n        root->right = helper(mp,inorder,postorder,index+1,i_last);\\n        \\n        return root;\\n        \\n    }\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        int n = inorder.size();\\n        for(int i=0;i<n;i++)\\n            mp[inorder[i]] = i;\\n        \\n        \\n        TreeNode* actualroot = helper(mp,inorder,postorder,0,n-1);\\n        \\n        return actualroot;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* helper(unordered_map<int,int>& mp, vector<int>& inorder, vector<int>& postorder, int i_first, int i_last)\\n    {\\n        if(i_first > i_last) // base condition by checking size of subtree\\n            return NULL;\\n        \\n        // the approach I have used is to first find the root node value, then break the inorder vector into left subtree and right subtree with respect to the root node. Then filling its left and right subtrees and finally returning the root node.\\n        int val,index = -1;\\n        // the node which lies inside the range of given inorder and is rightmost in the postorder is regarded as the current root node.\\n        for(auto it=postorder.rbegin();it!=postorder.rend();it++)\\n        {\\n            if(mp[*it] >= i_first && mp[*it] <= i_last)\\n            {\\n                index = mp[*it];\\n                break;\\n            }\\n        }\\n        val = inorder[index];\\n        TreeNode* root = new TreeNode(val);\\n        \\n        root->left = helper(mp,inorder,postorder,i_first,index-1);\\n        root->right = helper(mp,inorder,postorder,index+1,i_last);\\n        \\n        return root;\\n        \\n    }\\n    \\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        int n = inorder.size();\\n        for(int i=0;i<n;i++)\\n            mp[inorder[i]] = i;\\n        \\n        \\n        TreeNode* actualroot = helper(mp,inorder,postorder,0,n-1);\\n        \\n        return actualroot;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643809,
                "title": "recursive-python3-solution",
                "content": "```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        if inorder and postorder:\\n            rootVal = postorder.pop()\\n            i = inorder.index(rootVal)\\n            root = TreeNode(rootVal)\\n            root.right = self.buildTree(inorder[i+1:], postorder)\\n            root.left = self.buildTree(inorder[0:i], postorder)\\n            return root\\n```\\nGIven a postorder traversal, we know that the last node in it is the root node of the tree. Find the position of this root node in the inorder traversal. We then know that all nodes to the right of this node in the traversal are in the right subtree. Likewise, all nodes to the left in the traversal are in the left subtree. Hence we recursively call the function on both these subtrees. The tree returned is the correct binary tree.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        if inorder and postorder:\\n            rootVal = postorder.pop()\\n            i = inorder.index(rootVal)\\n            root = TreeNode(rootVal)\\n            root.right = self.buildTree(inorder[i+1:], postorder)\\n            root.left = self.buildTree(inorder[0:i], postorder)\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552413,
                "title": "java-recursion-with-no-hashmap-and-pruning-arrays",
                "content": "```\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if (inorder.length == 0) {\\n            return null;\\n        }\\n        if (inorder.length == 1) {\\n            return new TreeNode(inorder[0]);\\n        }\\n        TreeNode root = new TreeNode(postorder[postorder.length - 1]);\\n        int index = -1;\\n        for (int i = 0; i < inorder.length; i++) {\\n            if (inorder[i] == root.val) {\\n                index = i;\\n                break;\\n            }\\n        }                 \\n        \\n        root.left = buildTree(Arrays.copyOfRange(inorder,0, index),\\n                              Arrays.copyOfRange(postorder, 0, index));\\n        root.right = buildTree(Arrays.copyOfRange(inorder,index +1, inorder.length),\\n                               Arrays.copyOfRange(postorder, index, postorder.length -1));\\n        \\n        return root;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if (inorder.length == 0) {\\n            return null;\\n        }\\n        if (inorder.length == 1) {\\n            return new TreeNode(inorder[0]);\\n        }\\n        TreeNode root = new TreeNode(postorder[postorder.length - 1]);\\n        int index = -1;\\n        for (int i = 0; i < inorder.length; i++) {\\n            if (inorder[i] == root.val) {\\n                index = i;\\n                break;\\n            }\\n        }                 \\n        \\n        root.left = buildTree(Arrays.copyOfRange(inorder,0, index),\\n                              Arrays.copyOfRange(postorder, 0, index));\\n        root.right = buildTree(Arrays.copyOfRange(inorder,index +1, inorder.length),\\n                               Arrays.copyOfRange(postorder, index, postorder.length -1));\\n        \\n        return root;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 398013,
                "title": "faster-than-51-first-question-i-solved-using-whiteboard",
                "content": "```\\nvar buildTree = function(inorder, postorder) {\\n    if(inorder.length){\\n        let last = postorder.pop();\\n        let index = inorder.indexOf(last);\\n        let root = new TreeNode(last);\\n        root.right = buildTree(inorder.slice(index+1), postorder);\\n        root.left = buildTree(inorder.slice(0, index), postorder);\\n        return root;\\n    }\\n    return null;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar buildTree = function(inorder, postorder) {\\n    if(inorder.length){\\n        let last = postorder.pop();\\n        let index = inorder.indexOf(last);\\n        let root = new TreeNode(last);\\n        root.right = buildTree(inorder.slice(index+1), postorder);\\n        root.left = buildTree(inorder.slice(0, index), postorder);\\n        return root;\\n    }\\n    return null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386007,
                "title": "python-solution-52ms-14-8mb-16-line-clean-and-easy-to-understand",
                "content": "modified from the 105. iterative solution: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/214622/Precise-one-pass-iterative-solution-O(n)\\n```\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        if not postorder or not inorder: return None\\n        indx, root = 0, TreeNode(postorder[-1])\\n        stack = [root]\\n        for i in postorder[:-1][::-1]:\\n            parent = stack[-1]\\n            isRight = True\\n            node = TreeNode(i)\\n            while stack and inorder[~indx] == stack[-1].val:   # hit the rightmost node = stack[-1] go back to parent and then check left\\n                parent = stack.pop()\\n                isRight = False\\n                indx += 1\\n            if isRight: parent.right = node\\n            else: parent.left = node\\n            stack.append(node)\\n        return root\\n```\\n\\nfor comparison I also rewrite the 105. preorder solution below:\\n```\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        if not preorder or not inorder: return None\\n        indx, root = 0, TreeNode(preorder[0])\\n        stack = [root]\\n        for i in preorder[1:]:\\n            parent = stack[-1]\\n            isLeft = True\\n            node = TreeNode(i)\\n            while stack and inorder[indx] == stack[-1].val:   # hit the leftmost node = stack[-1] go back to parent and then check right\\n                parent = stack.pop()\\n                isLeft = False\\n                indx += 1\\n            if isLeft: parent.left = node\\n            else: parent.right = node\\n            stack.append(node)\\n        return root\\n```\\n\\nit is very instructive to examine the changes so as to better grasp the difference between preorder and postorder:\\n(1) preorder[0] --> postorder[-1]\\n(2) preorder[1:] --> postorder[:-1][::-1]\\n(3) isLeft --> isRight\\n(4) inorder[indx] --> inorder[~indx]\\n(5) if isLeft: parent.left = node --> if isRight: parent.right = node\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        if not postorder or not inorder: return None\\n        indx, root = 0, TreeNode(postorder[-1])\\n        stack = [root]\\n        for i in postorder[:-1][::-1]:\\n            parent = stack[-1]\\n            isRight = True\\n            node = TreeNode(i)\\n            while stack and inorder[~indx] == stack[-1].val:   # hit the rightmost node = stack[-1] go back to parent and then check left\\n                parent = stack.pop()\\n                isRight = False\\n                indx += 1\\n            if isRight: parent.right = node\\n            else: parent.left = node\\n            stack.append(node)\\n        return root\\n```\n```\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        if not preorder or not inorder: return None\\n        indx, root = 0, TreeNode(preorder[0])\\n        stack = [root]\\n        for i in preorder[1:]:\\n            parent = stack[-1]\\n            isLeft = True\\n            node = TreeNode(i)\\n            while stack and inorder[indx] == stack[-1].val:   # hit the leftmost node = stack[-1] go back to parent and then check right\\n                parent = stack.pop()\\n                isLeft = False\\n                indx += 1\\n            if isLeft: parent.left = node\\n            else: parent.right = node\\n            stack.append(node)\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 286372,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public TreeNode BuildTree(int[] inorder, int[] postorder) {\\n        return DFS(inorder, 0, inorder.Length - 1, postorder, 0, postorder.Length - 1);\\n    }\\n\\n    private TreeNode DFS(int[] inOrder, int inLeft, int inRight, int[] postOrder, int postLeft, int postRight) {\\n        if (postLeft > postRight) {\\n            return null;\\n        }\\n\\n        var curValue = postOrder[postRight];\\n\\n        var count = 0;\\n        var i = inLeft;\\n\\n        while (i <= inRight) {\\n            if (inOrder[i] == curValue) {\\n                break;\\n            }\\n            i++;\\n            count++;\\n        }\\n\\n        var cur = new TreeNode(curValue);\\n        cur.left = DFS(inOrder, inLeft, i - 1, postOrder, postLeft, postLeft + count - 1);\\n        cur.right = DFS(inOrder, i + 1, inRight, postOrder, postLeft + count, postRight - 1);\\n\\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public TreeNode BuildTree(int[] inorder, int[] postorder) {\\n        return DFS(inorder, 0, inorder.Length - 1, postorder, 0, postorder.Length - 1);\\n    }\\n\\n    private TreeNode DFS(int[] inOrder, int inLeft, int inRight, int[] postOrder, int postLeft, int postRight) {\\n        if (postLeft > postRight) {\\n            return null;\\n        }\\n\\n        var curValue = postOrder[postRight];\\n\\n        var count = 0;\\n        var i = inLeft;\\n\\n        while (i <= inRight) {\\n            if (inOrder[i] == curValue) {\\n                break;\\n            }\\n            i++;\\n            count++;\\n        }\\n\\n        var cur = new TreeNode(curValue);\\n        cur.left = DFS(inOrder, inLeft, i - 1, postOrder, postLeft, postLeft + count - 1);\\n        cur.right = DFS(inOrder, i + 1, inRight, postOrder, postLeft + count, postRight - 1);\\n\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204677,
                "title": "clean-recursive-o-n-python3-solution",
                "content": "```\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not inorder:\\n            return None\\n        \\n        root = TreeNode(postorder[-1])\\n        split_index = inorder.index(postorder[-1])\\n        \\n        root.left = self.buildTree(inorder[:split_index], postorder[:split_index])\\n        root.right = self.buildTree(inorder[split_index+1:], postorder[split_index:-1])\\n        \\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not inorder:\\n            return None\\n        \\n        root = TreeNode(postorder[-1])\\n        split_index = inorder.index(postorder[-1])\\n        \\n        root.left = self.buildTree(inorder[:split_index], postorder[:split_index])\\n        root.right = self.buildTree(inorder[split_index+1:], postorder[split_index:-1])\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126268,
                "title": "concise-10-line-c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int rootPos = postorder.size() - 1;\\n        return helper(inorder, 0, inorder.size() - 1, postorder, rootPos);\\n    }\\n    \\nprivate:\\n    TreeNode* helper(vector<int>& inorder, int l, int r, vector<int>& postorder, int& end) {\\n        if(l > r || end < 0)    return nullptr;\\n        \\n        int rootVal = postorder[end];\\n        int rootIndex = find(inorder.begin() + l, inorder.begin() + r, rootVal) - inorder.begin();\\n        \\n        TreeNode* root = new TreeNode(rootVal);\\n\\n        end --;\\n        root->right = helper(inorder, rootIndex + 1, r, postorder, end);\\n        root->left = helper(inorder, l, rootIndex - 1, postorder, end);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int rootPos = postorder.size() - 1;\\n        return helper(inorder, 0, inorder.size() - 1, postorder, rootPos);\\n    }\\n    \\nprivate:\\n    TreeNode* helper(vector<int>& inorder, int l, int r, vector<int>& postorder, int& end) {\\n        if(l > r || end < 0)    return nullptr;\\n        \\n        int rootVal = postorder[end];\\n        int rootIndex = find(inorder.begin() + l, inorder.begin() + r, rootVal) - inorder.begin();\\n        \\n        TreeNode* root = new TreeNode(rootVal);\\n\\n        end --;\\n        root->right = helper(inorder, rootIndex + 1, r, postorder, end);\\n        root->left = helper(inorder, l, rootIndex - 1, postorder, end);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34806,
                "title": "swift-solution-recursive",
                "content": "```\\nclass Solution {\\n    func buildTree(_ inorder: [Int], _ postorder: [Int]) -> TreeNode? {\\n        return helper(0, inorder.count - 1, 0, postorder.count - 1, inorder, postorder)\\n    }\\n    \\n    private func helper(_ inStart: Int, _ inEnd: Int, _ postStart: Int, _ postEnd: Int, _ inorder: [Int], _ postorder: [Int]) -> TreeNode? {\\n        if postStart > postEnd {\\n            return nil\\n        }\\n        \\n        let root = TreeNode(postorder[postEnd])\\n        var inIndex = 0\\n        \\n        for i in inStart...inEnd {\\n            if inorder[i] == root.val {\\n                inIndex = i\\n                break\\n            }\\n        }\\n        root.left = helper(inStart, inIndex - 1, postStart, postStart + inIndex - inStart - 1, inorder, postorder)\\n        root.right = helper(inIndex + 1, inEnd, postEnd - inEnd + inIndex, postEnd - 1, inorder, postorder)\\n        \\n        return root\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func buildTree(_ inorder: [Int], _ postorder: [Int]) -> TreeNode? {\\n        return helper(0, inorder.count - 1, 0, postorder.count - 1, inorder, postorder)\\n    }\\n    \\n    private func helper(_ inStart: Int, _ inEnd: Int, _ postStart: Int, _ postEnd: Int, _ inorder: [Int], _ postorder: [Int]) -> TreeNode? {\\n        if postStart > postEnd {\\n            return nil\\n        }\\n        \\n        let root = TreeNode(postorder[postEnd])\\n        var inIndex = 0\\n        \\n        for i in inStart...inEnd {\\n            if inorder[i] == root.val {\\n                inIndex = i\\n                break\\n            }\\n        }\\n        root.left = helper(inStart, inIndex - 1, postStart, postStart + inIndex - inStart - 1, inorder, postorder)\\n        root.right = helper(inIndex + 1, inEnd, postEnd - inEnd + inIndex, postEnd - 1, inorder, postorder)\\n        \\n        return root\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 34874,
                "title": "my-recursive-solution-in-java",
                "content": "    public class Solution {\\n    Map<Integer,Integer> map = new HashMap<>();\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if(inorder == null || inorder.length == 0) return null;\\n        for(int i = 0; i< inorder.length;i++){\\n            map.put(inorder[i],i);\\n        }\\n        return dfs(inorder,0,inorder.length,postorder,0,postorder.length-1);\\n    }\\n    private TreeNode dfs(int[] inorder,int istart,int iend,int[] postorder,int pstart,int pend){\\n        if(pstart > pend) return null;\\n        TreeNode root = new TreeNode(postorder[pend]);\\n        int imid = map.get(root.val);\\n        root.left = dfs(inorder,istart,imid-1,postorder,pstart,pstart + imid - istart-1);\\n        root.right = dfs(inorder,imid+1,iend,postorder,pstart + imid - istart,pend - 1);\\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<Integer,Integer> map = new HashMap<>();\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        if(inorder == null || inorder.length == 0) return null;\\n        for(int i = 0; i< inorder.length;i++){\\n            map.put(inorder[i],i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 34887,
                "title": "12ms-c-solution-o-n-space-and-time",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n            int size = inorder.size();\\n            \\n            TreeNode** path = (TreeNode**)malloc(sizeof(TreeNode*)*(size + 1));\\n            TreeNode* dummy = new TreeNode(0xDEADBEEF);\\n            path[0] = dummy;\\n            TreeNode* root = dummy;\\n            \\n            int pathIdx = 0;\\n            int inIdx = size - 1;\\n            int postIdx = size - 1;\\n            \\n            while(postIdx >= 0){\\n                if(path[pathIdx]->val == inorder[inIdx]){\\n                    root = path[pathIdx];\\n                    pathIdx--;\\n                    inIdx--;\\n                }\\n                else{\\n                    TreeNode* head= new TreeNode(0);\\n                    TreeNode* node = head;\\n                    \\n                    while(postorder[postIdx] != inorder[inIdx]){\\n                        node->right = new TreeNode(postorder[postIdx]);\\n                        postIdx--;\\n                        node = node->right;\\n                        path[++pathIdx] = node;\\n                    }\\n                    \\n                    node->right = new TreeNode(postorder[postIdx]);\\n                    node = node->right;\\n                    path[++pathIdx] = node;\\n                    postIdx--;\\n                    root->left = head->right;\\n                    delete head;\\n                }\\n            }\\n            \\n            return dummy->left;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n            int size = inorder.size();\\n            \\n            TreeNode** path = (TreeNode**)malloc(sizeof(TreeNode*)*(size + 1));\\n            TreeNode* dummy = new TreeNode(0xDEADBEEF);\\n            path[0] = dummy;\\n            TreeNode* root = dummy;\\n            \\n            int pathIdx = 0;\\n            int inIdx = size - 1;\\n            int postIdx = size - 1;\\n            \\n            while(postIdx >= 0){\\n                if(path[pathIdx]->val == inorder[inIdx]){\\n                    root = path[pathIdx];\\n                    pathIdx--;\\n                    inIdx--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 34872,
                "title": "fast-python-recursive-solution-64ms-9-lines",
                "content": "Same ideas as in Construct Binary Tree from Preorder and Inorder Traversal: <br>\\n\\n 1. use `inddict`, a dictionary of val:index in `inorder`, to reduce the runtime. <br>\\n   Geting an item in a dictionary is O(1), but list.index() is O(n)  <br>\\n 3. use index pointers `Lin`, `Rin` for inorder instead of slicing\\n\\n<br>\\n\\n\\n    def buildTree(self, inorder, postorder):\\n        def helper(Lin, Rin):\\n            if Lin < Rin:\\n                root = TreeNode(postorder.pop(-1))\\n                rootind = inddict[root.val]\\n                root.right = helper(rootind+1, Rin)\\n                root.left  = helper(Lin, rootind)\\n                return root\\n        inddict = {val:i for i, val in enumerate(inorder)}\\n        return helper(0, len(inorder))",
                "solutionTags": [
                    "Python"
                ],
                "code": "Same ideas as in Construct Binary Tree from Preorder and Inorder Traversal: <br>\\n\\n 1. use `inddict`, a dictionary of val:index in `inorder`, to reduce the runtime. <br>\\n   Geting an item in a dictionary is O(1), but list.index() is O(n)  <br>\\n 3. use index pointers `Lin`, `Rin` for inorder instead of slicing\\n\\n<br>\\n\\n\\n    def buildTree(self, inorder, postorder):\\n        def helper(Lin, Rin):\\n            if Lin < Rin:\\n                root = TreeNode(postorder.pop(-1))\\n                rootind = inddict[root.val]\\n                root.right = helper(rootind+1, Rin)\\n                root.left  = helper(Lin, rootind)\\n                return root\\n        inddict = {val:i for i, val in enumerate(inorder)}\\n        return helper(0, len(inorder))",
                "codeTag": "Python3"
            },
            {
                "id": 34917,
                "title": "construct-binary-tree-from-inorder-and-postorder-traversal-8-lines-in-python",
                "content": "    def buildTree2(self,inorder,postorder):\\n        if len(inorder) ==0 or len(postorder) ==0:\\n            return None\\n        curr = postorder.pop(-1)\\n        root = TreeNode(curr)\\n        mid = inorder.index(curr)\\n        root.right = self.buildTree2(inorder[mid+1:],postorder)\\n        root.left = self.buildTree2(inorder[:mid],postorder)\\n        return root",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "    def buildTree2(self,inorder,postorder):\\n        if len(inorder) ==0 or len(postorder) ==0:\\n            return None\\n        curr = postorder.pop(-1)\\n        root = TreeNode(curr)\\n        mid = inorder.index(curr)\\n        root.right = self.buildTree2(inorder[mid+1:],postorder)\\n        root.left = self.buildTree2(inorder[:mid],postorder)\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 34952,
                "title": "a-straightforward-way-o-n-time",
                "content": "    //we pass the indices of post/inorder vector, \\n    //which represents the begin and end of the sub tree\\n    TreeNode* helper2( vector<int>& postorder, int poL, int poR,\\n    \\t\\t\\t\\t  vector<int>& inorder, int inL, int inR, map<int, int>& map)\\n    {\\n    \\tif( poL > poR || inL > inR )\\n    \\t\\treturn NULL;\\n    \\t//everytime we insert the post order of sub tree's last element as root\\n    \\tTreeNode* root = new TreeNode( postorder[poR] );\\n    \\tint index = map[root->val];\\n    \\t//( index - inL ) means the length of the left subtree,\\n    \\t//we calculate the indices of the begin and end of the subtree in post/in order\\n    \\troot->left = helper2( postorder, poL, poL + ( index - inL ) - 1, inorder, inL, index-1, map );\\n    \\troot->right = helper2( postorder, poL+ ( index - inL ), poR-1, inorder, index+1, inR, map );\\n    \\treturn root;\\n    \\n    }\\n    \\n    class Solution {\\n    public:\\n        TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\\n        \\n        if( postorder.size() == 0 || inorder.size() == 0 )\\n    \\t\\treturn NULL;\\n    \\tmap<int, int> map;\\n    \\t//faster to get the indices and length of subtree\\n    \\tfor( int i = 0; i < inorder.size(); i++ )\\n    \\t\\tmap[inorder[i]] = i;\\n    \\treturn helper2(postorder,0,postorder.size()-1,inorder,0,inorder.size()-1, map);\\n            \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\\n        \\n        if( postorder.size() == 0 || inorder.size() == 0 )\\n    \\t\\treturn NULL;\\n    \\tmap<int, int> map;\\n    \\t//faster to get the indices and length of subtree\\n    \\tfor( int i = 0; i < inorder.size(); i++ )\\n    \\t\\tmap[inorder[i]] = i;\\n    \\treturn helper2(postorder,0,postorder.size()-1,inorder,0,inorder.size()-1, map);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3987010,
                "title": "best-explanation-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInorder traversal is a special traversal that helps us to identify a node and its left and right subtree. Postorder traversal always gives us the root node as its last element. Using these properties we can construct the unique binary tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![intuit-1.jpg](https://assets.leetcode.com/users/images/093c2338-b1dd-4d40-af7e-ccaea89d086e_1693547845.2104118.jpeg)\\n\\nHere 10 (last element of postorder) is the root element. So we can find its index in the inorder traversal(say elem). The left subtree of the root will be present to the left side of inorder whereas the right subtree of root will be present on the right side of elem in the inorder traversal: \\n\\nWe can define a recursive function that creates one node at a time. First, we create the root node, and then we can take the help of recursion to create its left and right subtrees. In order to make recursion work, we need to provide the correct inorder and postorder traversal of the subtree for every recursive call.\\n\\n![intuit-2.jpg](https://assets.leetcode.com/users/images/0eeac65d-c0ee-4212-8046-45bcdd5f4d06_1693547877.720729.jpeg)\\n\\nTo make more efficient function calls we can use variables (inStart, inEnd) and (postStart and postEnd) in order to point to the start and end of the inorder and postorder traversal respectively, and avoid copying of arrays. \\n\\nNext, we need to figure out how we are going to search the root index in the inorder traversal. For this, we have two options: Linear Search and Hashmaps. We will choose the second one because it will return us the index in constant time. Before making the first recursive call, we will simply add all the (value, index) pairs to a map and pass it to our recursive function.\\n\\nIf n is the size of the Inorder traversal/Postorder traversal. Then our first function call will be :\\n\\n![intuit-3.jpg](https://assets.leetcode.com/users/images/2ed2ea0e-6156-48b9-9d37-35d8b303c80f_1693547911.5575533.jpeg)\\n\\nNow the main task left is to pass the correct postStart, postEnd, inStart, inEnd to the respective recursive calls for the left and right subtree. We can calculate the number of elements in the left subtree from the root index, say nElems (elem \\u2013 InStart, where elem is the index of root in inorder traversal). As inorder is [left, root, right] and postorder is [left, right, root] the number of elements (nElems) will easily tell us the preorder and inorder traversal of the subtrees according to the following table:\\n\\n![intuit-4.jpg](https://assets.leetcode.com/users/images/2b08a74d-d4ed-4c39-9b94-685d61c5aa39_1693547935.551476.jpeg)\\n\\nThe base case will be when inStart> inEnd or postStart > postEnd, in that case, we can simply return NULL.\\n\\nThe algorithm approach can be stated as:\\n\\n1. Create a map to store the inorder indexes.\\n2. Call the function constructTree with all 7 parameters as shown above.\\n3. In the recursive function, first check the base case, if (postStart,>postEnd || inStart> inEnd) then return NULL.\\n4. Construct a node (say root) with the root value( last element of postorder). \\n5. Find the index of the root, say elem from the hashmap.\\n6. Find the number of elements ( say nElem) in the left subtree  = elem \\u2013 inStart\\n7. Call recursively for the left subtree with correct values (shown in the above table) and store the answer received in root->left.\\n8. Call recursively for the right subtree with correct values (shown in the above table) and store the answer received in root->right.\\n9. Return root\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* build(vector<int>& inorder,int inStart,int inEnd,vector<int>& postorder,int postStart,int postEnd,unordered_map<int,int>& mp) {\\n        if(inStart > inEnd || postStart > postEnd)\\n            return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postEnd]);\\n\\n        int index = mp[root->val];\\n\\n        int numsLeft = index - inStart;\\n\\n        root->left = build(inorder,inStart,index-1,postorder,postStart,postStart+numsLeft-1,mp);\\n\\n        root->right = build(inorder,index+1,inEnd,postorder,postStart+numsLeft,postEnd-1,mp);\\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int,int> mp;\\n\\n        int n = inorder.size();\\n        int m = postorder.size();\\n\\n        for(int i=0;i<n;i++) {\\n            mp[inorder[i]] = i;\\n        }\\n\\n\\n        TreeNode* root = build(inorder,0,n-1,postorder,0,m-1,mp);\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* build(vector<int>& inorder,int inStart,int inEnd,vector<int>& postorder,int postStart,int postEnd,unordered_map<int,int>& mp) {\\n        if(inStart > inEnd || postStart > postEnd)\\n            return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postEnd]);\\n\\n        int index = mp[root->val];\\n\\n        int numsLeft = index - inStart;\\n\\n        root->left = build(inorder,inStart,index-1,postorder,postStart,postStart+numsLeft-1,mp);\\n\\n        root->right = build(inorder,index+1,inEnd,postorder,postStart+numsLeft,postEnd-1,mp);\\n\\n        return root;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int,int> mp;\\n\\n        int n = inorder.size();\\n        int m = postorder.size();\\n\\n        for(int i=0;i<n;i++) {\\n            mp[inorder[i]] = i;\\n        }\\n\\n\\n        TreeNode* root = build(inorder,0,n-1,postorder,0,m-1,mp);\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921239,
                "title": "python-easy-solution-100-recursion-beats-99-37",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        postorder_idx=len(postorder)-1\\n\\n        def treeHelper(left, right):\\n            nonlocal postorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = postorder[postorder_idx]\\n            root=TreeNode(node_val)\\n            postorder_idx-=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.right = treeHelper(inorder_index+1, right)\\n            root.left = treeHelper(left, inorder_index-1 )\\n            \\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        postorder_idx=len(postorder)-1\\n\\n        def treeHelper(left, right):\\n            nonlocal postorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = postorder[postorder_idx]\\n            root=TreeNode(node_val)\\n            postorder_idx-=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.right = treeHelper(inorder_index+1, right)\\n            root.left = treeHelper(left, inorder_index-1 )\\n            \\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647196,
                "title": "c-neat-and-crisp-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* construct(vector<int> &postorder,int ps,int pe,vector<int> &inorder, int is,int ie, unordered_map<int,int> &mp){\\n        if(ps>pe || is>ie) return NULL;\\n        TreeNode* root=new TreeNode(postorder[pe]);\\n        int root_idx=mp[postorder[pe]];\\n        int numleft=root_idx-is;\\n        root->left=construct(postorder,ps,ps+numleft-1,inorder,is,root_idx-1,mp);\\n        root->right=construct(postorder,ps+numleft,pe-1,inorder,root_idx+1,ie,mp);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++) mp[inorder[i]]=i;\\n        return construct(postorder,0,postorder.size()-1,inorder,0,inorder.size()-1,mp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* construct(vector<int> &postorder,int ps,int pe,vector<int> &inorder, int is,int ie, unordered_map<int,int> &mp){\\n        if(ps>pe || is>ie) return NULL;\\n        TreeNode* root=new TreeNode(postorder[pe]);\\n        int root_idx=mp[postorder[pe]];\\n        int numleft=root_idx-is;\\n        root->left=construct(postorder,ps,ps+numleft-1,inorder,is,root_idx-1,mp);\\n        root->right=construct(postorder,ps+numleft,pe-1,inorder,root_idx+1,ie,mp);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<inorder.size();i++) mp[inorder[i]]=i;\\n        return construct(postorder,0,postorder.size()-1,inorder,0,inorder.size()-1,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397761,
                "title": "java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N) x (logN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<inorder.length;i++){\\n            map.put(inorder[i],i);\\n        }\\n        return solve(postorder,0,postorder.length-1,inorder,0,inorder.length-1,map);\\n    }\\n\\n    public TreeNode solve(int[]postorder,int postStart,int postEnd,int[]inorder,int inStart,int inEnd,\\n                        HashMap<Integer,Integer>map){\\n\\n            if(postStart>postEnd || inStart>inEnd) return null;\\n\\n            TreeNode root=new TreeNode(postorder[postEnd]);\\n\\n            int inRoot=map.get(root.val);\\n            int numsLeft=inRoot-inStart;\\n\\n            root.left=solve(postorder,postStart,postStart+numsLeft-1,inorder,inStart,inRoot-1,map);\\n            root.right=solve(postorder,postStart+numsLeft,postEnd-1,inorder,inRoot+1,inEnd,map);\\n\\n            return root;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<inorder.length;i++){\\n            map.put(inorder[i],i);\\n        }\\n        return solve(postorder,0,postorder.length-1,inorder,0,inorder.length-1,map);\\n    }\\n\\n    public TreeNode solve(int[]postorder,int postStart,int postEnd,int[]inorder,int inStart,int inEnd,\\n                        HashMap<Integer,Integer>map){\\n\\n            if(postStart>postEnd || inStart>inEnd) return null;\\n\\n            TreeNode root=new TreeNode(postorder[postEnd]);\\n\\n            int inRoot=map.get(root.val);\\n            int numsLeft=inRoot-inStart;\\n\\n            root.left=solve(postorder,postStart,postStart+numsLeft-1,inorder,inStart,inRoot-1,map);\\n            root.right=solve(postorder,postStart+numsLeft,postEnd-1,inorder,inRoot+1,inEnd,map);\\n\\n            return root;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391075,
                "title": "fastest-and-the-most-detailed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot 2023-03-15 185755.png](https://assets.leetcode.com/users/images/cdef38ff-a2f5-4cc6-a251-95a66c7ff03c_1680886811.0713117.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n\\n        // check if input arrays are null or not the same length\\n        if (inorder == null || postorder == null || inorder.length != postorder.length) {\\n            return null;\\n        }\\n\\n        // create a hashmap to store the indices of each value in the inorder array\\n        Map<Integer, Integer> inMap = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++) {\\n            inMap.put(inorder[i], i);\\n        }\\n\\n        // call the recursive helper function to build the binary tree\\n        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, inMap);\\n    }\\n\\n\\n    public TreeNode buildTree(int inorder[], int inStart, int inEnd,\\n                             int postorder[], int posStart, int posEnd, Map<Integer, Integer> inMap) {\\n\\n        // check if the current subtree is empty (inorder and/or postorder indices are out of bounds)\\n        if (inStart > inEnd || posStart > posEnd) {\\n            return null;\\n        }\\n\\n        // create the root node of the current subtree using the last value in the postorder array\\n        TreeNode root = new TreeNode(postorder[posEnd]);\\n\\n        // find the index of the root value in the inorder array using the hashmap\\n        int posRoot = inMap.get(postorder[posEnd]);\\n\\n        // calculate the number of nodes in the left subtree\\n        int numsLeft = posRoot - inStart;\\n\\n        // This recursively builds the left subtree of the current root node by calling the buildTree method with updated parameters:\\n        // inorder: the original inorder array of the entire tree\\n        // inStart: the starting index of the current subtree in the inorder array (which is the same as the starting index of the entire tree for the left subtree)\\n        // posRoot - 1: the ending index of the current subtree in the inorder array, which is one less than the index of the root node in the inorder array\\n        // postorder: the original postorder array of the entire tree\\n        // posStart: the starting index of the current subtree in the postorder array (which is the same as the starting index of the entire tree for the left subtree)\\n        // posStart + numsLeft - 1: the ending index of the current subtree in the postorder array, which is the index of the last node in the left subtree\\n        // inMap: a map that stores the indices of each element in the inorder array to speed up the lookup of the root node\\'s index\\n        root.left = buildTree(inorder, inStart, posRoot - 1, postorder, posStart, posStart + numsLeft - 1, inMap);\\n\\n        //This recursively builds the right subtree of the current root node by calling the buildTree method with updated parameters:\\n        // inorder: the original inorder array of the entire tree\\n        // posRoot + 1: the starting index of the current subtree in the inorder array, which is one more than the index of the root node in the inorder array\\n        // inEnd: the ending index of the current subtree in the inorder array (which is the same as the ending index of the entire tree for the right subtree)\\n        // postorder: the original postorder array of the entire tree\\n        // posStart + numsLeft: the starting index of the current subtree in the postorder array, which is the index of the first node in the right subtree\\n        // posEnd - 1: the ending index of the current subtree in the postorder array, which is one less than the index of the root node in the postorder array\\n        // inMap: a map that stores the indices of each element in the inorder array to speed up the lookup of the root node\\'s index\\n        root.right = buildTree(inorder, posRoot + 1, inEnd, postorder, posStart + numsLeft, posEnd - 1, inMap);\\n\\n        // return the root node of the completed subtree\\n        return root;         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n\\n        // check if input arrays are null or not the same length\\n        if (inorder == null || postorder == null || inorder.length != postorder.length) {\\n            return null;\\n        }\\n\\n        // create a hashmap to store the indices of each value in the inorder array\\n        Map<Integer, Integer> inMap = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++) {\\n            inMap.put(inorder[i], i);\\n        }\\n\\n        // call the recursive helper function to build the binary tree\\n        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, inMap);\\n    }\\n\\n\\n    public TreeNode buildTree(int inorder[], int inStart, int inEnd,\\n                             int postorder[], int posStart, int posEnd, Map<Integer, Integer> inMap) {\\n\\n        // check if the current subtree is empty (inorder and/or postorder indices are out of bounds)\\n        if (inStart > inEnd || posStart > posEnd) {\\n            return null;\\n        }\\n\\n        // create the root node of the current subtree using the last value in the postorder array\\n        TreeNode root = new TreeNode(postorder[posEnd]);\\n\\n        // find the index of the root value in the inorder array using the hashmap\\n        int posRoot = inMap.get(postorder[posEnd]);\\n\\n        // calculate the number of nodes in the left subtree\\n        int numsLeft = posRoot - inStart;\\n\\n        // This recursively builds the left subtree of the current root node by calling the buildTree method with updated parameters:\\n        // inorder: the original inorder array of the entire tree\\n        // inStart: the starting index of the current subtree in the inorder array (which is the same as the starting index of the entire tree for the left subtree)\\n        // posRoot - 1: the ending index of the current subtree in the inorder array, which is one less than the index of the root node in the inorder array\\n        // postorder: the original postorder array of the entire tree\\n        // posStart: the starting index of the current subtree in the postorder array (which is the same as the starting index of the entire tree for the left subtree)\\n        // posStart + numsLeft - 1: the ending index of the current subtree in the postorder array, which is the index of the last node in the left subtree\\n        // inMap: a map that stores the indices of each element in the inorder array to speed up the lookup of the root node\\'s index\\n        root.left = buildTree(inorder, inStart, posRoot - 1, postorder, posStart, posStart + numsLeft - 1, inMap);\\n\\n        //This recursively builds the right subtree of the current root node by calling the buildTree method with updated parameters:\\n        // inorder: the original inorder array of the entire tree\\n        // posRoot + 1: the starting index of the current subtree in the inorder array, which is one more than the index of the root node in the inorder array\\n        // inEnd: the ending index of the current subtree in the inorder array (which is the same as the ending index of the entire tree for the right subtree)\\n        // postorder: the original postorder array of the entire tree\\n        // posStart + numsLeft: the starting index of the current subtree in the postorder array, which is the index of the first node in the right subtree\\n        // posEnd - 1: the ending index of the current subtree in the postorder array, which is one less than the index of the root node in the postorder array\\n        // inMap: a map that stores the indices of each element in the inorder array to speed up the lookup of the root node\\'s index\\n        root.right = buildTree(inorder, posRoot + 1, inEnd, postorder, posStart + numsLeft, posEnd - 1, inMap);\\n\\n        // return the root node of the completed subtree\\n        return root;         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314390,
                "title": "c-solution-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode *solve(vector<int>& inorder, vector<int>& porder,int istart,int iend, int pstart, int pend){\\n\\n        if(istart > iend)\\n            return NULL;\\n\\n        TreeNode *root = new TreeNode(porder[pend]);\\n\\n        int i = istart;\\n        for(; i<=iend; i++){\\n            if(inorder[i] == root->val)\\n                break;\\n        }\\n\\n        int leftsize = i - istart;\\n        int rightsize = iend - i;\\n\\n        root->left = solve(inorder, porder, istart, i-1, pstart, pstart+leftsize-1);\\n        root->right = solve(inorder, porder, i+1, iend, pend-rightsize ,pend-1);\\n\\n        return root;\\n\\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& porder) {\\n        int n = inorder.size();\\n        TreeNode *root = solve(inorder,porder,0,n-1,0,n-1);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode *solve(vector<int>& inorder, vector<int>& porder,int istart,int iend, int pstart, int pend){\\n\\n        if(istart > iend)\\n            return NULL;\\n\\n        TreeNode *root = new TreeNode(porder[pend]);\\n\\n        int i = istart;\\n        for(; i<=iend; i++){\\n            if(inorder[i] == root->val)\\n                break;\\n        }\\n\\n        int leftsize = i - istart;\\n        int rightsize = iend - i;\\n\\n        root->left = solve(inorder, porder, istart, i-1, pstart, pstart+leftsize-1);\\n        root->right = solve(inorder, porder, i+1, iend, pend-rightsize ,pend-1);\\n\\n        return root;\\n\\n    }\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& porder) {\\n        int n = inorder.size();\\n        TreeNode *root = solve(inorder,porder,0,n-1,0,n-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305367,
                "title": "java-python-c-reverse-traversal-simulation-o-n-time-o-log-n-space-in-depth-guide",
                "content": "# Intuition\\nWhen we are given inorder and postorder traversals of a binary tree, we can observe that the last element in the postorder array is the root of the tree. We can then use this knowledge to reconstruct the tree by splitting the inorder array into left and right subtrees based on the position of the root. By iterating through the postorder array from the end, we can simulate the reverse traversal of the tree, allowing us to reconstruct it in a top-down manner.\\n\\n# Approach\\nWe will use a recursive approach to build the tree. Our function will take the inorder and postorder traversals, along with the current indices for both traversals, and a stopping value as input. The stopping value will be used to determine the boundary between the left and right subtrees in the inorder traversal. We will start by creating the root node using the current postorder index. Then, we will move to the right subtree, followed by the left subtree. We will adjust the indices accordingly and pass the appropriate stopping value to the recursive function.\\n\\n# Algorithm\\n1. Create a helper function buildTreeHelper that takes the inorder and postorder traversals, current indices for both traversals, and a stopping value as input.\\n2. Base case: If the current indices are out of bounds or the current inorder index value matches the stopping value, return null.\\n3. Create the root node using the current postorder index value.\\n4. Decrease the postorder index.\\n5. Call the helper function recursively for the right subtree, passing the root\\'s value as the stopping value.\\n6. Decrease the inorder index.\\n7. Call the helper function recursively for the left subtree, passing the original stopping value.\\n8. Return the root node.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where $$n$$ is the number of nodes in the tree. We visit each node once during the construction of the tree.\\n\\n- Space complexity:\\n    - Average space complexity: $$O(\\\\log{n})$$, where $$n$$ is the number of nodes in the tree. In an average case, the tree is balanced, and the recursion stack depth is proportional to the height of the tree, which is $$\\\\log{n}$$.\\n    - Worst-case space complexity: $$O(n)$$, where $$n$$ is the number of nodes in the tree. In the worst case, the tree is completely unbalanced (e.g., a skewed tree), and the recursion stack will store all the nodes.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int[] inorderIndex = {inorder.length - 1};\\n        int[] postorderIndex = {postorder.length - 1};\\n        return buildTreeHelper(inorder, postorder, inorderIndex, postorderIndex, null);\\n    }\\n\\n    private TreeNode buildTreeHelper(int[] inorder, int[] postorder, int[] inorderIndex, int[] postorderIndex, Integer stopValue) {\\n        if (inorderIndex[0] < 0 || (stopValue != null && inorder[inorderIndex[0]] == stopValue)) {\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(postorder[postorderIndex[0]]);\\n        postorderIndex[0]--;\\n\\n        root.right = buildTreeHelper(inorder, postorder, inorderIndex, postorderIndex, root.val);\\n        inorderIndex[0]--;\\n        root.left = buildTreeHelper(inorder, postorder, inorderIndex, postorderIndex, stopValue);\\n\\n        return root;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n        def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n            def build_tree_helper(stop_value = None):\\n                if not inorder or inorder[-1] == stop_value: \\n                    return None\\n                    \\n                root = TreeNode(postorder.pop())\\n                root.right = build_tree_helper(root.val)\\n                inorder.pop()\\n                root.left = build_tree_helper(stop_value)\\n                return root\\n\\n            return build_tree_helper()\\n```\\n```csharp []\\npublic class Solution {\\n    public TreeNode BuildTree(int[] inorder, int[] postorder) {\\n        int inorderIndex = inorder.Length - 1;\\n        int postorderIndex = postorder.Length - 1;\\n        return BuildTreeHelper(inorder, postorder, ref inorderIndex, ref postorderIndex, null);\\n    }\\n\\n    private TreeNode BuildTreeHelper(int[] inorder, int[] postorder, ref int inorderIndex, ref int postorderIndex, int? stopValue) {\\n        if (inorderIndex < 0 || inorder[inorderIndex] == stopValue) {\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(postorder[postorderIndex]);\\n        postorderIndex--;\\n\\n        root.right = BuildTreeHelper(inorder, postorder, ref inorderIndex, ref postorderIndex, root.val);\\n        inorderIndex--;\\n        root.left = BuildTreeHelper(inorder, postorder, ref inorderIndex, ref postorderIndex, stopValue);\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C#",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java []\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int[] inorderIndex = {inorder.length - 1};\\n        int[] postorderIndex = {postorder.length - 1};\\n        return buildTreeHelper(inorder, postorder, inorderIndex, postorderIndex, null);\\n    }\\n\\n    private TreeNode buildTreeHelper(int[] inorder, int[] postorder, int[] inorderIndex, int[] postorderIndex, Integer stopValue) {\\n        if (inorderIndex[0] < 0 || (stopValue != null && inorder[inorderIndex[0]] == stopValue)) {\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(postorder[postorderIndex[0]]);\\n        postorderIndex[0]--;\\n\\n        root.right = buildTreeHelper(inorder, postorder, inorderIndex, postorderIndex, root.val);\\n        inorderIndex[0]--;\\n        root.left = buildTreeHelper(inorder, postorder, inorderIndex, postorderIndex, stopValue);\\n\\n        return root;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n        def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n            def build_tree_helper(stop_value = None):\\n                if not inorder or inorder[-1] == stop_value: \\n                    return None\\n                    \\n                root = TreeNode(postorder.pop())\\n                root.right = build_tree_helper(root.val)\\n                inorder.pop()\\n                root.left = build_tree_helper(stop_value)\\n                return root\\n\\n            return build_tree_helper()\\n```\n```csharp []\\npublic class Solution {\\n    public TreeNode BuildTree(int[] inorder, int[] postorder) {\\n        int inorderIndex = inorder.Length - 1;\\n        int postorderIndex = postorder.Length - 1;\\n        return BuildTreeHelper(inorder, postorder, ref inorderIndex, ref postorderIndex, null);\\n    }\\n\\n    private TreeNode BuildTreeHelper(int[] inorder, int[] postorder, ref int inorderIndex, ref int postorderIndex, int? stopValue) {\\n        if (inorderIndex < 0 || inorder[inorderIndex] == stopValue) {\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(postorder[postorderIndex]);\\n        postorderIndex--;\\n\\n        root.right = BuildTreeHelper(inorder, postorder, ref inorderIndex, ref postorderIndex, root.val);\\n        inorderIndex--;\\n        root.left = BuildTreeHelper(inorder, postorder, ref inorderIndex, ref postorderIndex, stopValue);\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304992,
                "title": "python-divide-conquer-beats-92-57",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Divide and Conquer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        dic = {}\\n        for i in range(len(inorder)):\\n            dic[inorder[i]] = i\\n        return self.construct(inorder, 0, len(inorder) - 1, postorder, 0, len(postorder) - 1, dic)\\n\\n    def construct(self, ino, in_start, in_end, post, post_start, post_end, dic) -> TreeNode:\\n        if in_start > in_end or post_start > post_end:\\n            return None\\n        \\n        root = TreeNode(post[post_end])\\n        ele_left = dic[root.val] - in_start\\n\\n        root.left = self.construct(ino, in_start, dic[root.val] - 1, post, post_start, post_start + ele_left - 1, dic)\\n        root.right = self.construct(ino, dic[root.val] + 1, in_end, post, post_start + ele_left, post_end - 1, dic)\\n\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Divide and Conquer"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        dic = {}\\n        for i in range(len(inorder)):\\n            dic[inorder[i]] = i\\n        return self.construct(inorder, 0, len(inorder) - 1, postorder, 0, len(postorder) - 1, dic)\\n\\n    def construct(self, ino, in_start, in_end, post, post_start, post_end, dic) -> TreeNode:\\n        if in_start > in_end or post_start > post_end:\\n            return None\\n        \\n        root = TreeNode(post[post_end])\\n        ele_left = dic[root.val] - in_start\\n\\n        root.left = self.construct(ino, in_start, dic[root.val] - 1, post, post_start, post_start + ele_left - 1, dic)\\n        root.right = self.construct(ino, dic[root.val] + 1, in_end, post, post_start + ele_left, post_end - 1, dic)\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304932,
                "title": "easy-peasy-inorder-traversal-and-preorder-traversal",
                "content": "Given conditions:-\\n`````\\ninorder = [9,3,15,20,7]\\npostorder = [9,15,7,20,3]\\n\\nroot = buildTree(inorder, postorder)\\n`````\\nStructure:-\\n```\\n    3\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\n```\\nBehind approch:-\\n- The last element in the postorder traversal is the root of the binary tree.\\n- Find the position of the root in the inorder traversal. This will divide the inorder traversal into two parts - the left subtree and the right subtree.\\n- Recursively build the left subtree using the inorder and postorder traversals of the left subtree.\\n- Recursively build the right subtree using the inorder and postorder traversals of the right subtree.\\n- Return the root of the binary tree.\\n# Code:\\n```java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> inorderMap = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++) {\\n            inorderMap.put(inorder[i], i);\\n        }\\n        return helper(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, inorderMap);\\n    }\\n    \\n    public TreeNode helper(int[] inorder, int inorderStart, int inorderEnd, int[] postorder, int postorderStart, int postorderEnd, Map<Integer, Integer> inorderMap) {\\n        if (inorderStart > inorderEnd || postorderStart > postorderEnd) {\\n            return null;\\n        }\\n        int rootVal = postorder[postorderEnd];\\n        TreeNode root = new TreeNode(rootVal);\\n        int inorderIdx = inorderMap.get(rootVal);\\n        int leftSubtreeSize = inorderIdx - inorderStart;\\n        root.left = helper(inorder, inorderStart, inorderIdx - 1, postorder, postorderStart, postorderStart + leftSubtreeSize - 1, inorderMap);\\n        root.right = helper(inorder, inorderIdx + 1, inorderEnd, postorder, postorderStart + leftSubtreeSize, postorderEnd - 1, inorderMap);\\n        return root;\\n    }\\n}\\n\\nclass TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n    TreeNode(int x) { val = x; }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        int[] inorder = {9,3,15,20,7};\\n        int[] postorder = {9,15,7,20,3};\\n        Solution sol = new Solution();\\n        TreeNode root = sol.buildTree(inorder, postorder);\\n    }\\n}\\n\\n```\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def helper(inorder_start, inorder_end, postorder_start, postorder_end):\\n            if inorder_start > inorder_end or postorder_start > postorder_end:\\n                return None\\n            root_val = postorder[postorder_end]\\n            root = TreeNode(root_val)\\n        \\n            inorder_idx = inorder.index(root_val)\\n            left_subtree_size = inorder_idx - inorder_start\\n        \\n            root.left = helper(inorder_start, inorder_idx - 1, postorder_start, postorder_start + left_subtree_size - 1)\\n            root.right = helper(inorder_idx + 1, inorder_end, postorder_start + left_subtree_size, postorder_end - 1)\\n        \\n            return root\\n    \\n        return helper(0, len(inorder) - 1, 0, len(postorder) - 1)\\n```\\n```C++ []\\n#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\n\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int, int> inorder_map;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            inorder_map[inorder[i]] = i;\\n        }\\n        return helper(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1, inorder_map);\\n    }\\n    \\n    TreeNode* helper(vector<int>& inorder, int inorder_start, int inorder_end, vector<int>& postorder, int postorder_start, int postorder_end, unordered_map<int, int>& inorder_map) {\\n        if (inorder_start > inorder_end || postorder_start > postorder_end) {\\n            return NULL;\\n        }\\n        int root_val = postorder[postorder_end];\\n        TreeNode* root = new TreeNode(root_val);\\n        int inorder_idx = inorder_map[root_val];\\n        int left_subtree_size = inorder_idx - inorder_start;\\n        root->left = helper(inorder, inorder_start, inorder_idx - 1, postorder, postorder_start, postorder_start + left_subtree_size - 1, inorder_map);\\n        root->right = helper(inorder, inorder_idx + 1, inorder_end, postorder, postorder_start + left_subtree_size, postorder_end - 1, inorder_map);\\n        return root;\\n    }\\n};\\n\\nint main() {\\n    vector<int> inorder = {9,3,15,20,7};\\n    vector<int> postorder = {9,15,7,20,3};\\n    Solution sol;\\n    TreeNode* root = sol.buildTree(inorder, postorder);\\n    return 0;\\n}\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "`````\\ninorder = [9,3,15,20,7]\\npostorder = [9,15,7,20,3]\\n\\nroot = buildTree(inorder, postorder)\\n```\n```\\n    3\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\n```\n```java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> inorderMap = new HashMap<>();\\n        for (int i = 0; i < inorder.length; i++) {\\n            inorderMap.put(inorder[i], i);\\n        }\\n        return helper(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, inorderMap);\\n    }\\n    \\n    public TreeNode helper(int[] inorder, int inorderStart, int inorderEnd, int[] postorder, int postorderStart, int postorderEnd, Map<Integer, Integer> inorderMap) {\\n        if (inorderStart > inorderEnd || postorderStart > postorderEnd) {\\n            return null;\\n        }\\n        int rootVal = postorder[postorderEnd];\\n        TreeNode root = new TreeNode(rootVal);\\n        int inorderIdx = inorderMap.get(rootVal);\\n        int leftSubtreeSize = inorderIdx - inorderStart;\\n        root.left = helper(inorder, inorderStart, inorderIdx - 1, postorder, postorderStart, postorderStart + leftSubtreeSize - 1, inorderMap);\\n        root.right = helper(inorder, inorderIdx + 1, inorderEnd, postorder, postorderStart + leftSubtreeSize, postorderEnd - 1, inorderMap);\\n        return root;\\n    }\\n}\\n\\nclass TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n    TreeNode(int x) { val = x; }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        int[] inorder = {9,3,15,20,7};\\n        int[] postorder = {9,15,7,20,3};\\n        Solution sol = new Solution();\\n        TreeNode root = sol.buildTree(inorder, postorder);\\n    }\\n}\\n\\n```\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def helper(inorder_start, inorder_end, postorder_start, postorder_end):\\n            if inorder_start > inorder_end or postorder_start > postorder_end:\\n                return None\\n            root_val = postorder[postorder_end]\\n            root = TreeNode(root_val)\\n        \\n            inorder_idx = inorder.index(root_val)\\n            left_subtree_size = inorder_idx - inorder_start\\n        \\n            root.left = helper(inorder_start, inorder_idx - 1, postorder_start, postorder_start + left_subtree_size - 1)\\n            root.right = helper(inorder_idx + 1, inorder_end, postorder_start + left_subtree_size, postorder_end - 1)\\n        \\n            return root\\n    \\n        return helper(0, len(inorder) - 1, 0, len(postorder) - 1)\\n```\n```C++ []\\n#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\n\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int, int> inorder_map;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            inorder_map[inorder[i]] = i;\\n        }\\n        return helper(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1, inorder_map);\\n    }\\n    \\n    TreeNode* helper(vector<int>& inorder, int inorder_start, int inorder_end, vector<int>& postorder, int postorder_start, int postorder_end, unordered_map<int, int>& inorder_map) {\\n        if (inorder_start > inorder_end || postorder_start > postorder_end) {\\n            return NULL;\\n        }\\n        int root_val = postorder[postorder_end];\\n        TreeNode* root = new TreeNode(root_val);\\n        int inorder_idx = inorder_map[root_val];\\n        int left_subtree_size = inorder_idx - inorder_start;\\n        root->left = helper(inorder, inorder_start, inorder_idx - 1, postorder, postorder_start, postorder_start + left_subtree_size - 1, inorder_map);\\n        root->right = helper(inorder, inorder_idx + 1, inorder_end, postorder, postorder_start + left_subtree_size, postorder_end - 1, inorder_map);\\n        return root;\\n    }\\n};\\n\\nint main() {\\n    vector<int> inorder = {9,3,15,20,7};\\n    vector<int> postorder = {9,15,7,20,3};\\n    Solution sol;\\n    TreeNode* root = sol.buildTree(inorder, postorder);\\n    return 0;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3304900,
                "title": "c-divide-and-conquer-recursion",
                "content": "\\n\\n# Approach: Divide and Conquer || Recursion\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* construct(vector<int>& in, int inS, int inE, vector<int>& post, int postS, int postE, unordered_map<int, int>& ump) {\\n        if(inS > inE || postS > postE) return NULL;\\n        \\n        int post_left_size = ump[post[postE]] - inS;\\n        TreeNode* root = new TreeNode(post[postE]);\\n        root -> left = construct(in, inS, ump[post[postE]] - 1, post, postS, postS + post_left_size - 1, ump);\\n        root -> right = construct(in, ump[post[postE]] + 1, inE, post,postS + post_left_size, postE - 1, ump);\\n        \\n        return root;\\n\\n    }\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int, int> ump;\\n        for(int i=0;i<inorder.size();i++) ump[inorder[i]] = i;\\n        return construct(inorder, 0, inorder.size()-1, postorder, 0, postorder.size()-1, ump);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Divide and Conquer",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* construct(vector<int>& in, int inS, int inE, vector<int>& post, int postS, int postE, unordered_map<int, int>& ump) {\\n        if(inS > inE || postS > postE) return NULL;\\n        \\n        int post_left_size = ump[post[postE]] - inS;\\n        TreeNode* root = new TreeNode(post[postE]);\\n        root -> left = construct(in, inS, ump[post[postE]] - 1, post, postS, postS + post_left_size - 1, ump);\\n        root -> right = construct(in, ump[post[postE]] + 1, inE, post,postS + post_left_size, postE - 1, ump);\\n        \\n        return root;\\n\\n    }\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int, int> ump;\\n        for(int i=0;i<inorder.size();i++) ump[inorder[i]] = i;\\n        return construct(inorder, 0, inorder.size()-1, postorder, 0, postorder.size()-1, ump);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304731,
                "title": "easy-recursive-python-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not inorder:\\n            return \\n        a = postorder.pop()\\n        root = TreeNode(a)\\n        ind = inorder.index(a)\\n        root.right = self.buildTree(inorder[ind+1:], postorder)\\n        root.left = self.buildTree(inorder[:ind], postorder)\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not inorder:\\n            return \\n        a = postorder.pop()\\n        root = TreeNode(a)\\n        ind = inorder.index(a)\\n        root.right = self.buildTree(inorder[ind+1:], postorder)\\n        root.left = self.buildTree(inorder[:ind], postorder)\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304658,
                "title": "easiest-8lines-only-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not inorder or not postorder:\\n            return None\\n        value=postorder[-1]\\n        root=TreeNode(value)\\n        index=inorder.index(value)\\n        root.left=self.buildTree(inorder[:index],postorder[:index])\\n        root.right=self.buildTree(inorder[index+1:],postorder[index:-1])\\n        return root\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not inorder or not postorder:\\n            return None\\n        value=postorder[-1]\\n        root=TreeNode(value)\\n        index=inorder.index(value)\\n        root.left=self.buildTree(inorder[:index],postorder[:index])\\n        root.right=self.buildTree(inorder[index+1:],postorder[index:-1])\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304474,
                "title": "good-code-is-readable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*\"Good code is readable\"*\\n\\n1. What info can we get from an inorder? \\n2. What info can we get from postorder? Last element = root\\n3. How about combining the info from (1) and (2)?\\n-> If we can find root from postorder, we can find root inside inorder\\n-> if we can find root inside inorder, we can find left and right side\\n-> Does this seem like a recursive algorithm?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Get root from postorder\\n1. Find root inside inorder\\n1. split tree into left and right\\n1. Recurse and construct left and right\\n\\n# Complexity\\n- Time complexity: O(n) because each node is visited once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) because hashmap\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Base Solution**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:        \\n        if not inorder: return\\n\\n        root = TreeNode(postorder[-1])      \\n        root_value_i = inorder.index(root.val)\\n\\n        root.left = self.buildTree(inorder[:root_value_i], postorder[:root_value_i]) \\n        root.right = self.buildTree(inorder[root_value_i+1:], postorder[root_value_i:-1]) \\n        return root\\n\\n```\\n\\n**Optimised (Solve question first before looking here)**\\n1. Do we need to store array? or can we store indexes\\n2. After we find root from postorder, we need to linear search inorder for the root. Is there a better way to find its position *instantly*? \\n-> Sacrifice space for time (hashmap)\\n```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        inorder_mapping = { value: index for index, value in enumerate(inorder) }\\n\\n        def build(left, right):\\n            if left > right: return\\n\\n            root = TreeNode(postorder.pop())\\n            index = inorder_mapping[root.val]\\n\\n            # Build right side first since we\\'re popping from postorder\\n            root.right = build(index+1, right) \\n            root.left = build(left, index-1)\\n            return root\\n\\n        return build(0, len(inorder)-1)\\n    \\n\\n```\\n**Further questions**\\n1. Can you do it iteratively? Yes -> stack. \\n2. Why would you want to do it iteratively instead of recursively? No recursive callstack.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:        \\n        if not inorder: return\\n\\n        root = TreeNode(postorder[-1])      \\n        root_value_i = inorder.index(root.val)\\n\\n        root.left = self.buildTree(inorder[:root_value_i], postorder[:root_value_i]) \\n        root.right = self.buildTree(inorder[root_value_i+1:], postorder[root_value_i:-1]) \\n        return root\\n\\n```\n```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        inorder_mapping = { value: index for index, value in enumerate(inorder) }\\n\\n        def build(left, right):\\n            if left > right: return\\n\\n            root = TreeNode(postorder.pop())\\n            index = inorder_mapping[root.val]\\n\\n            # Build right side first since we\\'re popping from postorder\\n            root.right = build(index+1, right) \\n            root.left = build(left, index-1)\\n            return root\\n\\n        return build(0, len(inorder)-1)\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304029,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* ok(vector<int> &in,vector<int> &po,int &idx,int st,int ed,unordered_map<int,int> &mymap){\\n        if(idx<0 || st>ed){\\n            return NULL;\\n        }\\n        \\n        int mid=mymap[po[idx]];\\n        \\n        TreeNode* root=new TreeNode(po[idx--]);\\n        \\n        root->right=ok(in,po,idx,mid+1,ed,mymap);\\n        \\n        root->left=ok(in,po,idx,st,mid-1,mymap);\\n        \\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int,int> mymap;\\n        \\n        for(int i=0;i<inorder.size();i++){\\n            mymap[inorder[i]]=i;\\n        }\\n        \\n        int idx=postorder.size()-1;\\n        \\n        return ok(inorder,postorder,idx,0,inorder.size()-1,mymap);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* ok(vector<int> &in,vector<int> &po,int &idx,int st,int ed,unordered_map<int,int> &mymap){\\n        if(idx<0 || st>ed){\\n            return NULL;\\n        }\\n        \\n        int mid=mymap[po[idx]];\\n        \\n        TreeNode* root=new TreeNode(po[idx--]);\\n        \\n        root->right=ok(in,po,idx,mid+1,ed,mymap);\\n        \\n        root->left=ok(in,po,idx,st,mid-1,mymap);\\n        \\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int,int> mymap;\\n        \\n        for(int i=0;i<inorder.size();i++){\\n            mymap[inorder[i]]=i;\\n        }\\n        \\n        int idx=postorder.size()-1;\\n        \\n        return ok(inorder,postorder,idx,0,inorder.size()-1,mymap);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303255,
                "title": "beats-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        inorderidx = {v : i for i, v in enumerate(inorder)}\\n\\n        def helper(l, r):\\n            if l > r:\\n                return None\\n            \\n            root = TreeNode(postorder.pop())\\n\\n            idx = inorderidx[root.val]\\n            root.right = helper(idx + 1, r)\\n            root.left = helper(l, idx - 1)\\n            return root\\n        \\n        return helper(0, len(inorder) - 1)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        inorderidx = {v : i for i, v in enumerate(inorder)}\\n\\n        def helper(l, r):\\n            if l > r:\\n                return None\\n            \\n            root = TreeNode(postorder.pop())\\n\\n            idx = inorderidx[root.val]\\n            root.right = helper(idx + 1, r)\\n            root.left = helper(l, idx - 1)\\n            return root\\n        \\n        return helper(0, len(inorder) - 1)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303047,
                "title": "106-construct-binary-tree-from-inorder-and-postorder-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode\\n#     attr_accessor :val, :left, :right\\n#     def initialize(val = 0, left = nil, right = nil)\\n#         @val = val\\n#         @left = left\\n#         @right = right\\n#     end\\n# end\\n# @param {Integer[]} inorder\\n# @param {Integer[]} postorder\\n# @return {TreeNode}\\ndef build_tree(inorder, postorder)\\n    return nil if inorder.empty? || postorder.empty?\\n\\n    curr = postorder.pop()\\n    root = TreeNode.new(curr)\\n    root_index = inorder.index(curr)\\n\\n    left_inorder = inorder[0...root_index]\\n    right_inorder = inorder[root_index+1..inorder.length]\\n\\n    left_postorder = postorder.slice(0,left_inorder.size)\\n    right_postorder = postorder.slice(left_inorder.size..)\\n\\n    root.left=build_tree(left_inorder,left_postorder)\\n    root.right=build_tree(right_inorder, right_postorder)\\n\\n    root\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode\\n#     attr_accessor :val, :left, :right\\n#     def initialize(val = 0, left = nil, right = nil)\\n#         @val = val\\n#         @left = left\\n#         @right = right\\n#     end\\n# end\\n# @param {Integer[]} inorder\\n# @param {Integer[]} postorder\\n# @return {TreeNode}\\ndef build_tree(inorder, postorder)\\n    return nil if inorder.empty? || postorder.empty?\\n\\n    curr = postorder.pop()\\n    root = TreeNode.new(curr)\\n    root_index = inorder.index(curr)\\n\\n    left_inorder = inorder[0...root_index]\\n    right_inorder = inorder[root_index+1..inorder.length]\\n\\n    left_postorder = postorder.slice(0,left_inorder.size)\\n    right_postorder = postorder.slice(left_inorder.size..)\\n\\n    root.left=build_tree(left_inorder,left_postorder)\\n    root.right=build_tree(right_inorder, right_postorder)\\n\\n    root\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303031,
                "title": "106-construct-binary-tree-from-inorder-and-postorder-traversal-s-answer",
                "content": "# Table of Contents\\n\\n- [Approach](#approach)\\n- [Complexity](#complexity)\\n- [Code](#code-in-javascript)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCode uses a recursive approach to construct the binary tree from its inorder and postorder traversals. The approach splits the <b>inorder</b> and <b>postorder</b> arrays into <b>left</b> and <b>right</b> subtrees and <b>recursively</b> constructs the <b>left</b> and <b>right</b> subtrees. The root node is selected from the postorder array and inserted into the binary tree. \\n# Complexity\\n- Time complexity: Best Case/Average Case - O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code In JavaScript\\n```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {number[]} inorder\\n * @param {number[]} postorder\\n * @return {TreeNode}\\n */\\nvar buildTree = function(inorder, postorder) {\\n    if (inorder.length == 0 || postorder.length == 0) {\\n        return null;\\n    }\\n    var rootVal = postorder[postorder.length - 1];\\n    var root = new TreeNode(rootVal);\\n    var rootIndex = inorder.indexOf(rootVal);\\n    var leftInorder = inorder.slice(0, rootIndex);\\n    var rightInorder = inorder.slice(rootIndex + 1);\\n    var leftPostorder = postorder.slice(0, leftInorder.length);\\n    var rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);\\n    root.left = buildTree(leftInorder, leftPostorder);\\n    root.right = buildTree(rightInorder, rightPostorder);\\n    return root;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {number[]} inorder\\n * @param {number[]} postorder\\n * @return {TreeNode}\\n */\\nvar buildTree = function(inorder, postorder) {\\n    if (inorder.length == 0 || postorder.length == 0) {\\n        return null;\\n    }\\n    var rootVal = postorder[postorder.length - 1];\\n    var root = new TreeNode(rootVal);\\n    var rootIndex = inorder.indexOf(rootVal);\\n    var leftInorder = inorder.slice(0, rootIndex);\\n    var rightInorder = inorder.slice(rootIndex + 1);\\n    var leftPostorder = postorder.slice(0, leftInorder.length);\\n    var rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);\\n    root.left = buildTree(leftInorder, leftPostorder);\\n    root.right = buildTree(rightInorder, rightPostorder);\\n    return root;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302807,
                "title": "easy-understanding-java-solution-tree",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int instart=0;\\n        int inend=inorder.length-1;\\n        int poststart=0;\\n        int postend=postorder.length-1;\\n\\n        return solve(inorder,instart,inend,postorder,poststart,postend);\\n        \\n    }\\n    public TreeNode solve(int[]inorder,int instart,int inend,int[]postorder,int poststart,int postend){\\n        if(instart>inend || poststart>postend){\\n            return null;\\n        }\\n        int rootValue=postorder[postend];\\n        TreeNode root= new TreeNode(rootValue);\\n\\n        int k=0;\\n        for(int i=0; i<inorder.length; i++){\\n            if(inorder[i]==rootValue){\\n                k=i;\\n                break;\\n            }\\n        }\\n        root.left= solve(inorder,instart,k-1,postorder,poststart,poststart+k-(instart+1));\\n        root.right= solve(inorder,k+1,inend,postorder,poststart+k-instart,postend-1);\\n        return root;\\n    }\\n}\\n```\"UPVOTE IF YOU LIKE THIS SOLUTION!!!\"",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int instart=0;\\n        int inend=inorder.length-1;\\n        int poststart=0;\\n        int postend=postorder.length-1;\\n\\n        return solve(inorder,instart,inend,postorder,poststart,postend);\\n        \\n    }\\n    public TreeNode solve(int[]inorder,int instart,int inend,int[]postorder,int poststart,int postend){\\n        if(instart>inend || poststart>postend){\\n            return null;\\n        }\\n        int rootValue=postorder[postend];\\n        TreeNode root= new TreeNode(rootValue);\\n\\n        int k=0;\\n        for(int i=0; i<inorder.length; i++){\\n            if(inorder[i]==rootValue){\\n                k=i;\\n                break;\\n            }\\n        }\\n        root.left= solve(inorder,instart,k-1,postorder,poststart,poststart+k-(instart+1));\\n        root.right= solve(inorder,k+1,inend,postorder,poststart+k-instart,postend-1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302566,
                "title": "c-full-explained-code-beginner-friendly",
                "content": "# Approach\\n\\nTo construct a binary tree from its inorder and postorder traversals, we can follow the below approach:\\n\\n1. Use the last element in the postorder array as the root node of the binary tree.\\n2. Find the index of the root node in the inorder array.\\n3. Split the inorder array into two parts, left subtree and right subtree, based on the index of the root node.\\n4. Recursively construct the right and left subtrees using the subarrays of inorder and postorder.\\n5. Return the root node of the binary tree.\\n\\n```\\nclass Solution {\\npublic:\\n    int last_index_postorder;\\n\\n    TreeNode *makeTree(vector<int>& inorder, vector<int>& postorder, int start, int end){\\n        if(end < start){\\n            return NULL;\\n        }\\n\\n        last_index_postorder--;\\n        int rootVal = postorder[last_index_postorder];\\n        int rootIdx;\\n\\n        TreeNode *root = new TreeNode(rootVal);\\n\\n        for(int i = start; i <= end; i++){\\n            if(inorder[i] == rootVal){\\n                rootIdx = i;\\n                break;\\n            }\\n        }\\n        root->right = makeTree(inorder, postorder, rootIdx+1, end);\\n        root->left = makeTree(inorder, postorder, start, rootIdx-1);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        last_index_postorder = postorder.size();\\n        return makeTree(inorder, postorder, 0, postorder.size()-1);\\n    }\\n};\\n```\\nWe can further optimize the time complaxity by reducing the search time of finding root index in inorder array in each recursive call. for this we can use hashing.\\n```\\nclass Solution {\\npublic:\\n    int last_index_postorder;\\n    TreeNode *makeTree(unordered_map<int,int> &inorderMap, vector<int>& postorder, int start, int end){\\n        if(end < start){\\n            return NULL;\\n        }\\n        last_index_postorder--;\\n        int rootVal = postorder[last_index_postorder];\\n        int rootIdx = inorderMap[rootVal];\\n\\n        TreeNode *root = new TreeNode(rootVal);\\n        postorder.pop_back();\\n\\n        root->right = makeTree(inorderMap, postorder, rootIdx+1, end);\\n        root->left = makeTree(inorderMap, postorder, start, rootIdx-1);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int,int> inorderMap;\\n        for(int i = 0; i < inorder.size(); i++){\\n            inorderMap[inorder[i]] = i;\\n        }\\n        last_index_postorder = postorder.size();\\n        return makeTree(inorderMap, postorder, 0, postorder.size()-1);\\n    }\\n};\\n```\\n![upVote.jpg](https://assets.leetcode.com/users/images/3c48554b-7cb3-46cd-92a7-a858ab2e21f5_1678940876.7894251.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Divide and Conquer",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int last_index_postorder;\\n\\n    TreeNode *makeTree(vector<int>& inorder, vector<int>& postorder, int start, int end){\\n        if(end < start){\\n            return NULL;\\n        }\\n\\n        last_index_postorder--;\\n        int rootVal = postorder[last_index_postorder];\\n        int rootIdx;\\n\\n        TreeNode *root = new TreeNode(rootVal);\\n\\n        for(int i = start; i <= end; i++){\\n            if(inorder[i] == rootVal){\\n                rootIdx = i;\\n                break;\\n            }\\n        }\\n        root->right = makeTree(inorder, postorder, rootIdx+1, end);\\n        root->left = makeTree(inorder, postorder, start, rootIdx-1);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        last_index_postorder = postorder.size();\\n        return makeTree(inorder, postorder, 0, postorder.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int last_index_postorder;\\n    TreeNode *makeTree(unordered_map<int,int> &inorderMap, vector<int>& postorder, int start, int end){\\n        if(end < start){\\n            return NULL;\\n        }\\n        last_index_postorder--;\\n        int rootVal = postorder[last_index_postorder];\\n        int rootIdx = inorderMap[rootVal];\\n\\n        TreeNode *root = new TreeNode(rootVal);\\n        postorder.pop_back();\\n\\n        root->right = makeTree(inorderMap, postorder, rootIdx+1, end);\\n        root->left = makeTree(inorderMap, postorder, start, rootIdx-1);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int,int> inorderMap;\\n        for(int i = 0; i < inorder.size(); i++){\\n            inorderMap[inorder[i]] = i;\\n        }\\n        last_index_postorder = postorder.size();\\n        return makeTree(inorderMap, postorder, 0, postorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302376,
                "title": "striver-solution",
                "content": "# Intuition: \\nThe inorder traversal of a binary tree visits the left subtree, then the root node, and then the right subtree. The postorder traversal of a binary tree visits the left subtree, then the right subtree, and then the root node. By using these two traversals, we can reconstruct the original binary tree. \\n# Approach: \\nWe start by finding the root node of the binary tree from the last element of the postorder traversal. We then find the index of the root node in the inorder traversal, which allows us to determine the sizes of the left and right subtrees. We recursively construct the left and right subtrees by calling the buildTree function with the appropriate subarrays of the inorder and postorder traversals. We return the root node of the current subtree, which is used by the parent call to construct its own subtree. \\n\\n# Algorithm: \\nDefine a buildTree function that takes two arrays as input: inorder and postorder . Call the buildTree function with the full arrays and return the result. In the buildTree function, define six parameters: inorder , inStart , inEnd , postorder , postStart , and postEnd . If inStart is greater than inEnd or postStart is greater than postEnd , return null . Find the root node of the current subtree by looking at the last element of the postorder array. Create a new TreeNode object with the value of the root node. Find the index of the root node in the inorder array by iterating through the subarray from inStart to inEnd . Determine the sizes of the left and right subtrees using the root index. Recursively construct the left subtree by calling buildTree with the subarrays from inStart to rootIndex - 1 and postStart to postStart + leftSize - 1 . Recursively construct the right subtree by calling buildTree with the subarrays from rootIndex + 1 to inEnd and postEnd - rightSize to postEnd - 1 . Set the left and right subtrees of the current node to the roots of the left and right subtrees, respectively. Return the root node of the current subtree.\\n```java []\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        // Call the recursive function with full arrays and return the result\\n        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\\n    }\\n    \\n    private TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {\\n        // Base case\\n        if (inStart > inEnd || postStart > postEnd) {\\n            return null;\\n        }\\n        \\n        // Find the root node from the last element of postorder traversal\\n        int rootVal = postorder[postEnd];\\n        TreeNode root = new TreeNode(rootVal);\\n        \\n        // Find the index of the root node in inorder traversal\\n        int rootIndex = 0;\\n        for (int i = inStart; i <= inEnd; i++) {\\n            if (inorder[i] == rootVal) {\\n                rootIndex = i;\\n                break;\\n            }\\n        }\\n        \\n        // Recursively build the left and right subtrees\\n        int leftSize = rootIndex - inStart;\\n        int rightSize = inEnd - rootIndex;\\n        root.left = buildTree(inorder, inStart, rootIndex - 1, postorder, postStart, postStart + leftSize - 1);\\n        root.right = buildTree(inorder, rootIndex + 1, inEnd, postorder, postEnd - rightSize, postEnd - 1);\\n        \\n        return root;\\n    }\\n}\\n```\\n# 2nd  \\nThe the basic idea is to take the last element in postorder array as the root, find the position of the root in the inorder array; then locate the range for left sub-tree and right sub-tree and do recursion. Use a HashMap to record the index of root in the inorder array.\\n\\n\\n# recursion tree for the buildTreeFromPostIn() method\\n```\\nbuildTreeFromPostIn(start=0, end=n-1, postorder, inorder, map)\\n                                         |\\n                                         |\\n                                         |\\n                          +--------------+---------------+\\n                          |                              |\\n                          |                              |\\n         buildTreeFromPostIn(start=0, end=2, postorder, inorder, map)\\n                          |                              |\\n                          |                              |\\n           +--------------+--------------+               |\\n           |                             |               |\\n           |                             |               |\\nbuildTreeFromPostIn(start=0, end=0, postorder, inorder, map) buildTreeFromPostIn(start=1, end=2, postorder, inorder, map)\\n           |                             |               |\\n           |                             |               |\\n           |                             |               |\\n         null                          node(2)          |\\n                                                     buildTreeFromPostIn(start=3, end=3, postorder, inorder, map)\\n                                                             |\\n                                                             |\\n                                                             |\\n                                                           null\\n```\\nIn this tree, each node represents a call to the buildTreeFromPostIn() method with specific parameters. The left child represents the recursive call on the left subtree, the right child represents the recursive call on the right subtree, and the leaf nodes represent the base case where the indices are out of bounds and null is returned. The nodes with a value represent the root node of the subtree being built.\\n\\n# Code\\n```\\npublic TreeNode buildTree(int[] inorder, int[] postorder) {\\n    Map<Integer,Integer> inorderMap = new HashMap<>();\\n    for(int i=0;i<inorder.length;i++) inorderMap.put(inorder[i],i);\\n    return buildTreeFromPostIn(0,inorder.length-1,postorder,0,\\n        postorder.length-1,inorderMap);\\n}\\nprivate TreeNode buildTreeFromPostIn(int inorderStart, int inorderEnd, \\nint[] post, int postStart, int postEnd, Map<Integer,Integer> inorderMap){\\n    if(inorderStart>inorderEnd || postStart>postEnd) return null;\\n    TreeNode root = new TreeNode(post[postEnd]);\\n    int rootIndex = inorderMap.get(post[postEnd]);\\n    int leftSubTree= rootIndex-inorderStart;\\n    root.left=buildTreeFromPostIn(inorderStart,rootIndex-1,post,\\n        postStart,postStart+leftSubTree-1,inorderMap);\\n    root.right=buildTreeFromPostIn(rootIndex+1,inorderEnd,post,\\n        postStart+leftSubTree,postEnd-1,inorderMap);\\n    return root;\\n}\\n```\\n# explaination \\n\\nThis code builds a binary tree given its inorder and postorder traversal sequences.\\n\\nmain idea is to use a map to quickly find the index of the root node in the inorder sequence.\\n\\nThen, we can divide the inorder and postorder sequences into left and right subtrees based on the position of the root node.\\n\\nThe buildTree() method takes the inorder and postorder arrays as input, creates a map to store the index of each element in the inorder array, and calls the buildTreeFromPostIn() method with the appropriate parameters.\\n\\nThe buildTreeFromPostIn() method takes the starting and ending indices of the inorder and postorder arrays, as well as the map of indices.\\n\\nIt first checks for the base case where the indices are out of bounds, in which case it returns null.\\n\\nOtherwise, it creates a new TreeNode object with the last element of the postorder array as the root node.\\n\\nIt then finds the index of the root node in the inorder array using the map.\\n\\nUsing the index, it can calculate the size of the left subtree and recursively call buildTreeFromPostIn() to build the left and right subtrees.\\n\\nFinally, it returns the root node of the complete binary tree.\\n\\n\\n# Complexity\\nComplexity Analysis:\\n\\nTime Complexity: O(n), where n is the number of nodes in the binary tree. This is because we are visiting each node exactly once in the inorder and postorder traversals, and performing constant time operations for each node.\\n\\nSpace Complexity: O(n), where n is the number of nodes in the binary tree. This is because we are using a hashmap to store the indices of the nodes in the inorder traversal, which requires O(n) space. Additionally, we are using recursive calls to construct the left and right subtrees, which may require O(n) space in the worst case if the tree is highly unbalanced (e.g., a skewed tree).\\n\\n![MEME.png](https://assets.leetcode.com/users/images/b1924e36-7641-46cb-8731-6764988717d2_1678936005.7254355.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        // Call the recursive function with full arrays and return the result\\n        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\\n    }\\n    \\n    private TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {\\n        // Base case\\n        if (inStart > inEnd || postStart > postEnd) {\\n            return null;\\n        }\\n        \\n        // Find the root node from the last element of postorder traversal\\n        int rootVal = postorder[postEnd];\\n        TreeNode root = new TreeNode(rootVal);\\n        \\n        // Find the index of the root node in inorder traversal\\n        int rootIndex = 0;\\n        for (int i = inStart; i <= inEnd; i++) {\\n            if (inorder[i] == rootVal) {\\n                rootIndex = i;\\n                break;\\n            }\\n        }\\n        \\n        // Recursively build the left and right subtrees\\n        int leftSize = rootIndex - inStart;\\n        int rightSize = inEnd - rootIndex;\\n        root.left = buildTree(inorder, inStart, rootIndex - 1, postorder, postStart, postStart + leftSize - 1);\\n        root.right = buildTree(inorder, rootIndex + 1, inEnd, postorder, postEnd - rightSize, postEnd - 1);\\n        \\n        return root;\\n    }\\n}\\n```\n```\\nbuildTreeFromPostIn(start=0, end=n-1, postorder, inorder, map)\\n                                         |\\n                                         |\\n                                         |\\n                          +--------------+---------------+\\n                          |                              |\\n                          |                              |\\n         buildTreeFromPostIn(start=0, end=2, postorder, inorder, map)\\n                          |                              |\\n                          |                              |\\n           +--------------+--------------+               |\\n           |                             |               |\\n           |                             |               |\\nbuildTreeFromPostIn(start=0, end=0, postorder, inorder, map) buildTreeFromPostIn(start=1, end=2, postorder, inorder, map)\\n           |                             |               |\\n           |                             |               |\\n           |                             |               |\\n         null                          node(2)          |\\n                                                     buildTreeFromPostIn(start=3, end=3, postorder, inorder, map)\\n                                                             |\\n                                                             |\\n                                                             |\\n                                                           null\\n```\n```\\npublic TreeNode buildTree(int[] inorder, int[] postorder) {\\n    Map<Integer,Integer> inorderMap = new HashMap<>();\\n    for(int i=0;i<inorder.length;i++) inorderMap.put(inorder[i],i);\\n    return buildTreeFromPostIn(0,inorder.length-1,postorder,0,\\n        postorder.length-1,inorderMap);\\n}\\nprivate TreeNode buildTreeFromPostIn(int inorderStart, int inorderEnd, \\nint[] post, int postStart, int postEnd, Map<Integer,Integer> inorderMap){\\n    if(inorderStart>inorderEnd || postStart>postEnd) return null;\\n    TreeNode root = new TreeNode(post[postEnd]);\\n    int rootIndex = inorderMap.get(post[postEnd]);\\n    int leftSubTree= rootIndex-inorderStart;\\n    root.left=buildTreeFromPostIn(inorderStart,rootIndex-1,post,\\n        postStart,postStart+leftSubTree-1,inorderMap);\\n    root.right=buildTreeFromPostIn(rootIndex+1,inorderEnd,post,\\n        postStart+leftSubTree,postEnd-1,inorderMap);\\n    return root;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200743,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* ok(vector<int> &in,vector<int> &po,int &idx,int st,int ed,unordered_map<int,int> &mymap){\\n        if(idx<0 || st>ed){\\n            return NULL;\\n        }\\n        \\n        int mid=mymap[po[idx]];\\n        \\n        TreeNode* root=new TreeNode(po[idx--]);\\n        \\n        root->right=ok(in,po,idx,mid+1,ed,mymap);\\n        \\n        root->left=ok(in,po,idx,st,mid-1,mymap);\\n        \\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int,int> mymap;\\n        \\n        for(int i=0;i<inorder.size();i++){\\n            mymap[inorder[i]]=i;\\n        }\\n        \\n        int idx=postorder.size()-1;\\n        \\n        return ok(inorder,postorder,idx,0,inorder.size()-1,mymap);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* ok(vector<int> &in,vector<int> &po,int &idx,int st,int ed,unordered_map<int,int> &mymap){\\n        if(idx<0 || st>ed){\\n            return NULL;\\n        }\\n        \\n        int mid=mymap[po[idx]];\\n        \\n        TreeNode* root=new TreeNode(po[idx--]);\\n        \\n        root->right=ok(in,po,idx,mid+1,ed,mymap);\\n        \\n        root->left=ok(in,po,idx,st,mid-1,mymap);\\n        \\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        unordered_map<int,int> mymap;\\n        \\n        for(int i=0;i<inorder.size();i++){\\n            mymap[inorder[i]]=i;\\n        }\\n        \\n        int idx=postorder.size()-1;\\n        \\n        return ok(inorder,postorder,idx,0,inorder.size()-1,mymap);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156068,
                "title": "c-beats-99-30-recursion",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* construct(vector<int>& in, int inStart, int inEnd, vector<int>& post, int postStart, int postEnd, unordered_map<int, int>& ump) {\\n        if(inStart > inEnd || postStart > postEnd) return NULL;\\n        TreeNode* root = new TreeNode(post[postEnd]);\\n\\n        int in_ind = ump[root -> val];\\n        int ele_left = in_ind - inStart;\\n        root -> left = construct(in, inStart, in_ind - 1, post, postStart, postStart + ele_left - 1, ump);\\n\\n        root -> right = construct(in, in_ind + 1, inEnd, post, postStart + ele_left, postEnd - 1, ump);\\n\\n        return root;\\n    }\\npublic:\\n    TreeNode* buildTree(vector<int>& in, vector<int>& post) {\\n        unordered_map<int, int> ump;\\n        for(int i=0;i<in.size();i++) ump[in[i]] = i;\\n        return construct(in, 0, in.size()-1, post, 0, post.size()-1, ump);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* construct(vector<int>& in, int inStart, int inEnd, vector<int>& post, int postStart, int postEnd, unordered_map<int, int>& ump) {\\n        if(inStart > inEnd || postStart > postEnd) return NULL;\\n        TreeNode* root = new TreeNode(post[postEnd]);\\n\\n        int in_ind = ump[root -> val];\\n        int ele_left = in_ind - inStart;\\n        root -> left = construct(in, inStart, in_ind - 1, post, postStart, postStart + ele_left - 1, ump);\\n\\n        root -> right = construct(in, in_ind + 1, inEnd, post, postStart + ele_left, postEnd - 1, ump);\\n\\n        return root;\\n    }\\npublic:\\n    TreeNode* buildTree(vector<int>& in, vector<int>& post) {\\n        unordered_map<int, int> ump;\\n        for(int i=0;i<in.size();i++) ump[in[i]] = i;\\n        return construct(in, 0, in.size()-1, post, 0, post.size()-1, ump);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128991,
                "title": "c-solution-mind-the-global-variable",
                "content": "```\\nclass Solution {\\npublic:\\n    int curr;  //global variable\\n    \\n    TreeNode* help(vector<int>& in, vector<int>& pos, int inLeft, int inRight){\\n        if(inLeft> inRight)return NULL;\\n        auto ans= new TreeNode(pos[curr]);\\n        int ind= find(in.begin(),in.end(),pos[curr])- in.begin();\\n        curr--;\\n        \\n        ans->right= help(in,pos,ind+1,inRight);\\n        ans->left= help(in,pos, inLeft, ind-1);\\n        \\n        return ans;\\n    }\\n    \\n    \\n    TreeNode* buildTree(vector<int>& in, vector<int>& pos) {\\n        curr= in.size()-1;\\n        return help(in,pos,0,curr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int curr;  //global variable\\n    \\n    TreeNode* help(vector<int>& in, vector<int>& pos, int inLeft, int inRight){\\n        if(inLeft> inRight)return NULL;\\n        auto ans= new TreeNode(pos[curr]);\\n        int ind= find(in.begin(),in.end(),pos[curr])- in.begin();\\n        curr--;\\n        \\n        ans->right= help(in,pos,ind+1,inRight);\\n        ans->left= help(in,pos, inLeft, ind-1);\\n        \\n        return ans;\\n    }\\n    \\n    \\n    TreeNode* buildTree(vector<int>& in, vector<int>& pos) {\\n        curr= in.size()-1;\\n        return help(in,pos,0,curr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090052,
                "title": "easy-beginner-friendly-approach-dfs",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int post_idx;\\n    TreeNode* utilBST(vector<int>& inorder, int is,int ie, vector<int>& postorder){\\n        if(is>ie)return NULL;\\n        TreeNode* root=new TreeNode(postorder[post_idx--]);\\n        int idx;\\n        for(int i=is;i<=ie;i++){\\n            if(inorder[i]==root->val){\\n                idx=i;\\n                break;\\n            }\\n        }\\n        root->right=utilBST(inorder,idx+1,ie,postorder);\\n        root->left=utilBST(inorder,is,idx-1,postorder);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        post_idx=postorder.size()-1;\\n        return utilBST(inorder,0,inorder.size()-1,postorder);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int post_idx;\\n    TreeNode* utilBST(vector<int>& inorder, int is,int ie, vector<int>& postorder){\\n        if(is>ie)return NULL;\\n        TreeNode* root=new TreeNode(postorder[post_idx--]);\\n        int idx;\\n        for(int i=is;i<=ie;i++){\\n            if(inorder[i]==root->val){\\n                idx=i;\\n                break;\\n            }\\n        }\\n        root->right=utilBST(inorder,idx+1,ie,postorder);\\n        root->left=utilBST(inorder,is,idx-1,postorder);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        post_idx=postorder.size()-1;\\n        return utilBST(inorder,0,inorder.size()-1,postorder);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748351,
                "title": "c-recursive-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        map<int, int>m;\\n        for(int i=0; i<inorder.size(); i++){m[inorder[i]]=i;}\\n        TreeNode* root=formtree(inorder, 0, inorder.size()-1, postorder, 0, postorder.size()-1, m);\\n        return root;\\n    }\\n    TreeNode* formtree(vector<int>& inorder, int inst, int inen, vector<int>& postorder, int post, int poen, map<int, int>&m){\\n        if(inst>inen || post>poen){return NULL;}\\n        TreeNode* root= new TreeNode(postorder[poen]);\\n        int pos=m[postorder[poen]];\\n        int rght=pos-inst;\\n        root->left=formtree(inorder, inst, pos-1, postorder, post, post+rght-1, m);\\n        root->right=formtree(inorder, pos+1, inen, postorder, post+rght, poen-1, m);\\n        return root;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        map<int, int>m;\\n        for(int i=0; i<inorder.size(); i++){m[inorder[i]]=i;}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565637,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1670394,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1569467,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1565272,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1833698,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1833769,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1573884,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1833805,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1833833,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1833684,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1565637,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1670394,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1569467,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1565272,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1833698,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1833769,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1573884,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1833805,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1833833,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1833684,
                "content": [
                    {
                        "username": "tejpratapp468",
                        "content": "Completed 400 days of streak today!!! Thank you @LeetCode :)\\n\\n![image](https://assets.leetcode.com/users/images/8b62ff64-d611-4d14-8668-820c2fc31d62_1637483861.5668375.png)\\n"
                    },
                    {
                        "username": "GurinderS120",
                        "content": "[@Abodh5921](/Abodh5921) Do blind 75 list and watch neetcode videos on YouTube if you don't understand something. Good luck."
                    },
                    {
                        "username": "Abodh5921",
                        "content": "congratulations\\n\\nbhai koi tips and idea bataoo \\nkese kara \\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "2 id kyu use kr rhe ho? \\uD83D\\uDE02"
                    },
                    {
                        "username": "wjeevika",
                        "content": "What gives people a feeling of power: Solving this question"
                    },
                    {
                        "username": "Ramonsan07",
                        "content": "honestly it makes me kinda sad that I solved it in more than an hour you are supposed to solve the mediums in halve an hour..."
                    },
                    {
                        "username": "cameron7",
                        "content": "Hi all, \\n\\nIf you were like me and were struggling with this problem, try this one first: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\\n\\nIt has the same recursive approach that you can use in this problem\\n\\nGood luck, I believe in you :)"
                    },
                    {
                        "username": "mvalpha",
                        "content": "Thank you."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Fantastic advice, thank you."
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks :)"
                    },
                    {
                        "username": "lifeng2628qiu",
                        "content": "Thank you so much! that was very helpful. Another tip, try to look the postorder array from backwards. =)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This week we trek the amazon rainforest."
                    },
                    {
                        "username": "Udit2021",
                        "content": "sometimes the tree gives me the feeling I can do anything.\\nthen back to reality need more grind "
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from a preorder and postorder sequence</a>\\n&nbsp;</li>"
                    },
                    {
                        "username": "mohak0",
                        "content": "Thanks!"
                    },
                    {
                        "username": "arghyadas",
                        "content": "201 / 202 testcases passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "harsh788",
                        "content": "Same\\uD83D\\uDE2D"
                    },
                    {
                        "username": "ckvb18",
                        "content": "can feel you."
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel like this is more impressive than having the solution haha"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n1. Create a HashMap to store the indices of each element in the inorder sequence.\\n2. Define a recursive function that takes the inorder and postorder arrays, as well as their start and end indices.\\n3. Check if the start index of either array is greater than its end index. If so, return null to indicate an empty tree.\\n4. Create a new TreeNode object with the last element of the postorder array as its value, which is the root of the current subtree.\\n5. Find the index of the root element in the inorder array by looking it up in the HashMap.\\n6. Use the root index to divide the inorder array into left and right subtrees.\\n7. Use the sizes of the left and right subtrees to divide the postorder array accordingly.\\n8. Recursively call the function to construct the left subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n9. Recursively call the function to construct the right subtree, passing the appropriate subarrays of the inorder and postorder arrays.\\n10. Return the root node of the current subtree."
                    },
                    {
                        "username": "__starboy__",
                        "content": "can you please share your code\\n"
                    },
                    {
                        "username": "__starboy__",
                        "content": "I\\'ve used the same approach but it\\'s showing TLE for 201\\'th test case \\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Without this constraint \"inorder and postorder consist of unique values\", it would be very hard. "
                    },
                    {
                        "username": "mohan_sason",
                        "content": "[@cartesPerforees](/cartesPerforees) Yup Exactly\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Correct me if I'm wrong, but without this constraint the problem isn't hard, it is impossible to solve. You couldn;t unambiguously construct a tree. Consider the inputs inorder=postorder=[1,1], and good luck guessing whether the child goes right or left"
                    }
                ]
            },
            {
                "id": 1833687,
                "content": [
                    {
                        "username": "balleater",
                        "content": "they really determined to make me learn binary trees"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "In postorder traversal the last value is the **root** value."
                    },
                    {
                        "username": "dmskpd",
                        "content": "inorder = [15,20,3,7], postorder = [15,7,20,3], code does nothing and returns None, result - Memory Limit Exceeded?"
                    },
                    {
                        "username": "zali100",
                        "content": "I think the postorder should be [15,20,7,3] or [20,15,7,3] because the current postoder of [15,7,20,3] doesn\\'t match properly with the given inorder. "
                    },
                    {
                        "username": "spec_he123",
                        "content": "https://youtu.be/x2aUTgi-068\\n"
                    },
                    {
                        "username": "Harsh_Gupta_49",
                        "content": "it\\'s definately 106 cm."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "when the input arrays are empty or have different lengths, or when there are duplicate elements in the inorder traversal. These cases require additional checks and special handling to ensure that the algorithm works correctly."
                    },
                    {
                        "username": "sahle123",
                        "content": "This problem was surprisingly challenging..."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "  simple way.. to sol\\n  Use the last element in postorder array as the root of the binary tree.\\n    Find the index of the root in inorder array. This can be done using a map to store the index of each element in inorder array.\\n    Split the inorder array into two parts at the index of the root. The left part will be the left subtree and the right part will be the right subtree.\\n    Split the postorder array into two parts. The left part will contain the elements of the left subtree and the right part will contain the elements of the right subtree.\\n    Recursively construct the left subtree and the right subtree using the left and right parts of the inorder and postorder arrays, respectively.\\n    Return the root of the binary tree."
                    },
                    {
                        "username": "arifulkazi",
                        "content": "Output should be [-1] for example 2 provided in the problem description as shown below.\\n\\nExample 2:\\nInput: inorder = [-1], postorder = [-1]\\nOutput: []\\n"
                    },
                    {
                        "username": "Web_Ghost10",
                        "content": "Real Pain : \nTotal Testcases=202\nTLE occur at 201 testcase  "
                    }
                ]
            },
            {
                "id": 1834024,
                "content": [
                    {
                        "username": "balleater",
                        "content": "they really determined to make me learn binary trees"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "In postorder traversal the last value is the **root** value."
                    },
                    {
                        "username": "dmskpd",
                        "content": "inorder = [15,20,3,7], postorder = [15,7,20,3], code does nothing and returns None, result - Memory Limit Exceeded?"
                    },
                    {
                        "username": "zali100",
                        "content": "I think the postorder should be [15,20,7,3] or [20,15,7,3] because the current postoder of [15,7,20,3] doesn\\'t match properly with the given inorder. "
                    },
                    {
                        "username": "spec_he123",
                        "content": "https://youtu.be/x2aUTgi-068\\n"
                    },
                    {
                        "username": "Harsh_Gupta_49",
                        "content": "it\\'s definately 106 cm."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "when the input arrays are empty or have different lengths, or when there are duplicate elements in the inorder traversal. These cases require additional checks and special handling to ensure that the algorithm works correctly."
                    },
                    {
                        "username": "sahle123",
                        "content": "This problem was surprisingly challenging..."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "  simple way.. to sol\\n  Use the last element in postorder array as the root of the binary tree.\\n    Find the index of the root in inorder array. This can be done using a map to store the index of each element in inorder array.\\n    Split the inorder array into two parts at the index of the root. The left part will be the left subtree and the right part will be the right subtree.\\n    Split the postorder array into two parts. The left part will contain the elements of the left subtree and the right part will contain the elements of the right subtree.\\n    Recursively construct the left subtree and the right subtree using the left and right parts of the inorder and postorder arrays, respectively.\\n    Return the root of the binary tree."
                    },
                    {
                        "username": "arifulkazi",
                        "content": "Output should be [-1] for example 2 provided in the problem description as shown below.\\n\\nExample 2:\\nInput: inorder = [-1], postorder = [-1]\\nOutput: []\\n"
                    },
                    {
                        "username": "Web_Ghost10",
                        "content": "Real Pain : \nTotal Testcases=202\nTLE occur at 201 testcase  "
                    }
                ]
            },
            {
                "id": 1833640,
                "content": [
                    {
                        "username": "balleater",
                        "content": "they really determined to make me learn binary trees"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "In postorder traversal the last value is the **root** value."
                    },
                    {
                        "username": "dmskpd",
                        "content": "inorder = [15,20,3,7], postorder = [15,7,20,3], code does nothing and returns None, result - Memory Limit Exceeded?"
                    },
                    {
                        "username": "zali100",
                        "content": "I think the postorder should be [15,20,7,3] or [20,15,7,3] because the current postoder of [15,7,20,3] doesn\\'t match properly with the given inorder. "
                    },
                    {
                        "username": "spec_he123",
                        "content": "https://youtu.be/x2aUTgi-068\\n"
                    },
                    {
                        "username": "Harsh_Gupta_49",
                        "content": "it\\'s definately 106 cm."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "when the input arrays are empty or have different lengths, or when there are duplicate elements in the inorder traversal. These cases require additional checks and special handling to ensure that the algorithm works correctly."
                    },
                    {
                        "username": "sahle123",
                        "content": "This problem was surprisingly challenging..."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "  simple way.. to sol\\n  Use the last element in postorder array as the root of the binary tree.\\n    Find the index of the root in inorder array. This can be done using a map to store the index of each element in inorder array.\\n    Split the inorder array into two parts at the index of the root. The left part will be the left subtree and the right part will be the right subtree.\\n    Split the postorder array into two parts. The left part will contain the elements of the left subtree and the right part will contain the elements of the right subtree.\\n    Recursively construct the left subtree and the right subtree using the left and right parts of the inorder and postorder arrays, respectively.\\n    Return the root of the binary tree."
                    },
                    {
                        "username": "arifulkazi",
                        "content": "Output should be [-1] for example 2 provided in the problem description as shown below.\\n\\nExample 2:\\nInput: inorder = [-1], postorder = [-1]\\nOutput: []\\n"
                    },
                    {
                        "username": "Web_Ghost10",
                        "content": "Real Pain : \nTotal Testcases=202\nTLE occur at 201 testcase  "
                    }
                ]
            },
            {
                "id": 1570084,
                "content": [
                    {
                        "username": "balleater",
                        "content": "they really determined to make me learn binary trees"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "In postorder traversal the last value is the **root** value."
                    },
                    {
                        "username": "dmskpd",
                        "content": "inorder = [15,20,3,7], postorder = [15,7,20,3], code does nothing and returns None, result - Memory Limit Exceeded?"
                    },
                    {
                        "username": "zali100",
                        "content": "I think the postorder should be [15,20,7,3] or [20,15,7,3] because the current postoder of [15,7,20,3] doesn\\'t match properly with the given inorder. "
                    },
                    {
                        "username": "spec_he123",
                        "content": "https://youtu.be/x2aUTgi-068\\n"
                    },
                    {
                        "username": "Harsh_Gupta_49",
                        "content": "it\\'s definately 106 cm."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "when the input arrays are empty or have different lengths, or when there are duplicate elements in the inorder traversal. These cases require additional checks and special handling to ensure that the algorithm works correctly."
                    },
                    {
                        "username": "sahle123",
                        "content": "This problem was surprisingly challenging..."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "  simple way.. to sol\\n  Use the last element in postorder array as the root of the binary tree.\\n    Find the index of the root in inorder array. This can be done using a map to store the index of each element in inorder array.\\n    Split the inorder array into two parts at the index of the root. The left part will be the left subtree and the right part will be the right subtree.\\n    Split the postorder array into two parts. The left part will contain the elements of the left subtree and the right part will contain the elements of the right subtree.\\n    Recursively construct the left subtree and the right subtree using the left and right parts of the inorder and postorder arrays, respectively.\\n    Return the root of the binary tree."
                    },
                    {
                        "username": "arifulkazi",
                        "content": "Output should be [-1] for example 2 provided in the problem description as shown below.\\n\\nExample 2:\\nInput: inorder = [-1], postorder = [-1]\\nOutput: []\\n"
                    },
                    {
                        "username": "Web_Ghost10",
                        "content": "Real Pain : \nTotal Testcases=202\nTLE occur at 201 testcase  "
                    }
                ]
            },
            {
                "id": 2031264,
                "content": [
                    {
                        "username": "balleater",
                        "content": "they really determined to make me learn binary trees"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "In postorder traversal the last value is the **root** value."
                    },
                    {
                        "username": "dmskpd",
                        "content": "inorder = [15,20,3,7], postorder = [15,7,20,3], code does nothing and returns None, result - Memory Limit Exceeded?"
                    },
                    {
                        "username": "zali100",
                        "content": "I think the postorder should be [15,20,7,3] or [20,15,7,3] because the current postoder of [15,7,20,3] doesn\\'t match properly with the given inorder. "
                    },
                    {
                        "username": "spec_he123",
                        "content": "https://youtu.be/x2aUTgi-068\\n"
                    },
                    {
                        "username": "Harsh_Gupta_49",
                        "content": "it\\'s definately 106 cm."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "when the input arrays are empty or have different lengths, or when there are duplicate elements in the inorder traversal. These cases require additional checks and special handling to ensure that the algorithm works correctly."
                    },
                    {
                        "username": "sahle123",
                        "content": "This problem was surprisingly challenging..."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "  simple way.. to sol\\n  Use the last element in postorder array as the root of the binary tree.\\n    Find the index of the root in inorder array. This can be done using a map to store the index of each element in inorder array.\\n    Split the inorder array into two parts at the index of the root. The left part will be the left subtree and the right part will be the right subtree.\\n    Split the postorder array into two parts. The left part will contain the elements of the left subtree and the right part will contain the elements of the right subtree.\\n    Recursively construct the left subtree and the right subtree using the left and right parts of the inorder and postorder arrays, respectively.\\n    Return the root of the binary tree."
                    },
                    {
                        "username": "arifulkazi",
                        "content": "Output should be [-1] for example 2 provided in the problem description as shown below.\\n\\nExample 2:\\nInput: inorder = [-1], postorder = [-1]\\nOutput: []\\n"
                    },
                    {
                        "username": "Web_Ghost10",
                        "content": "Real Pain : \nTotal Testcases=202\nTLE occur at 201 testcase  "
                    }
                ]
            },
            {
                "id": 1834393,
                "content": [
                    {
                        "username": "balleater",
                        "content": "they really determined to make me learn binary trees"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "In postorder traversal the last value is the **root** value."
                    },
                    {
                        "username": "dmskpd",
                        "content": "inorder = [15,20,3,7], postorder = [15,7,20,3], code does nothing and returns None, result - Memory Limit Exceeded?"
                    },
                    {
                        "username": "zali100",
                        "content": "I think the postorder should be [15,20,7,3] or [20,15,7,3] because the current postoder of [15,7,20,3] doesn\\'t match properly with the given inorder. "
                    },
                    {
                        "username": "spec_he123",
                        "content": "https://youtu.be/x2aUTgi-068\\n"
                    },
                    {
                        "username": "Harsh_Gupta_49",
                        "content": "it\\'s definately 106 cm."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "when the input arrays are empty or have different lengths, or when there are duplicate elements in the inorder traversal. These cases require additional checks and special handling to ensure that the algorithm works correctly."
                    },
                    {
                        "username": "sahle123",
                        "content": "This problem was surprisingly challenging..."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "  simple way.. to sol\\n  Use the last element in postorder array as the root of the binary tree.\\n    Find the index of the root in inorder array. This can be done using a map to store the index of each element in inorder array.\\n    Split the inorder array into two parts at the index of the root. The left part will be the left subtree and the right part will be the right subtree.\\n    Split the postorder array into two parts. The left part will contain the elements of the left subtree and the right part will contain the elements of the right subtree.\\n    Recursively construct the left subtree and the right subtree using the left and right parts of the inorder and postorder arrays, respectively.\\n    Return the root of the binary tree."
                    },
                    {
                        "username": "arifulkazi",
                        "content": "Output should be [-1] for example 2 provided in the problem description as shown below.\\n\\nExample 2:\\nInput: inorder = [-1], postorder = [-1]\\nOutput: []\\n"
                    },
                    {
                        "username": "Web_Ghost10",
                        "content": "Real Pain : \nTotal Testcases=202\nTLE occur at 201 testcase  "
                    }
                ]
            },
            {
                "id": 1834382,
                "content": [
                    {
                        "username": "balleater",
                        "content": "they really determined to make me learn binary trees"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "In postorder traversal the last value is the **root** value."
                    },
                    {
                        "username": "dmskpd",
                        "content": "inorder = [15,20,3,7], postorder = [15,7,20,3], code does nothing and returns None, result - Memory Limit Exceeded?"
                    },
                    {
                        "username": "zali100",
                        "content": "I think the postorder should be [15,20,7,3] or [20,15,7,3] because the current postoder of [15,7,20,3] doesn\\'t match properly with the given inorder. "
                    },
                    {
                        "username": "spec_he123",
                        "content": "https://youtu.be/x2aUTgi-068\\n"
                    },
                    {
                        "username": "Harsh_Gupta_49",
                        "content": "it\\'s definately 106 cm."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "when the input arrays are empty or have different lengths, or when there are duplicate elements in the inorder traversal. These cases require additional checks and special handling to ensure that the algorithm works correctly."
                    },
                    {
                        "username": "sahle123",
                        "content": "This problem was surprisingly challenging..."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "  simple way.. to sol\\n  Use the last element in postorder array as the root of the binary tree.\\n    Find the index of the root in inorder array. This can be done using a map to store the index of each element in inorder array.\\n    Split the inorder array into two parts at the index of the root. The left part will be the left subtree and the right part will be the right subtree.\\n    Split the postorder array into two parts. The left part will contain the elements of the left subtree and the right part will contain the elements of the right subtree.\\n    Recursively construct the left subtree and the right subtree using the left and right parts of the inorder and postorder arrays, respectively.\\n    Return the root of the binary tree."
                    },
                    {
                        "username": "arifulkazi",
                        "content": "Output should be [-1] for example 2 provided in the problem description as shown below.\\n\\nExample 2:\\nInput: inorder = [-1], postorder = [-1]\\nOutput: []\\n"
                    },
                    {
                        "username": "Web_Ghost10",
                        "content": "Real Pain : \nTotal Testcases=202\nTLE occur at 201 testcase  "
                    }
                ]
            },
            {
                "id": 1834355,
                "content": [
                    {
                        "username": "balleater",
                        "content": "they really determined to make me learn binary trees"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "In postorder traversal the last value is the **root** value."
                    },
                    {
                        "username": "dmskpd",
                        "content": "inorder = [15,20,3,7], postorder = [15,7,20,3], code does nothing and returns None, result - Memory Limit Exceeded?"
                    },
                    {
                        "username": "zali100",
                        "content": "I think the postorder should be [15,20,7,3] or [20,15,7,3] because the current postoder of [15,7,20,3] doesn\\'t match properly with the given inorder. "
                    },
                    {
                        "username": "spec_he123",
                        "content": "https://youtu.be/x2aUTgi-068\\n"
                    },
                    {
                        "username": "Harsh_Gupta_49",
                        "content": "it\\'s definately 106 cm."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "when the input arrays are empty or have different lengths, or when there are duplicate elements in the inorder traversal. These cases require additional checks and special handling to ensure that the algorithm works correctly."
                    },
                    {
                        "username": "sahle123",
                        "content": "This problem was surprisingly challenging..."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "  simple way.. to sol\\n  Use the last element in postorder array as the root of the binary tree.\\n    Find the index of the root in inorder array. This can be done using a map to store the index of each element in inorder array.\\n    Split the inorder array into two parts at the index of the root. The left part will be the left subtree and the right part will be the right subtree.\\n    Split the postorder array into two parts. The left part will contain the elements of the left subtree and the right part will contain the elements of the right subtree.\\n    Recursively construct the left subtree and the right subtree using the left and right parts of the inorder and postorder arrays, respectively.\\n    Return the root of the binary tree."
                    },
                    {
                        "username": "arifulkazi",
                        "content": "Output should be [-1] for example 2 provided in the problem description as shown below.\\n\\nExample 2:\\nInput: inorder = [-1], postorder = [-1]\\nOutput: []\\n"
                    },
                    {
                        "username": "Web_Ghost10",
                        "content": "Real Pain : \nTotal Testcases=202\nTLE occur at 201 testcase  "
                    }
                ]
            },
            {
                "id": 1575001,
                "content": [
                    {
                        "username": "balleater",
                        "content": "they really determined to make me learn binary trees"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "In postorder traversal the last value is the **root** value."
                    },
                    {
                        "username": "dmskpd",
                        "content": "inorder = [15,20,3,7], postorder = [15,7,20,3], code does nothing and returns None, result - Memory Limit Exceeded?"
                    },
                    {
                        "username": "zali100",
                        "content": "I think the postorder should be [15,20,7,3] or [20,15,7,3] because the current postoder of [15,7,20,3] doesn\\'t match properly with the given inorder. "
                    },
                    {
                        "username": "spec_he123",
                        "content": "https://youtu.be/x2aUTgi-068\\n"
                    },
                    {
                        "username": "Harsh_Gupta_49",
                        "content": "it\\'s definately 106 cm."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "when the input arrays are empty or have different lengths, or when there are duplicate elements in the inorder traversal. These cases require additional checks and special handling to ensure that the algorithm works correctly."
                    },
                    {
                        "username": "sahle123",
                        "content": "This problem was surprisingly challenging..."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "  simple way.. to sol\\n  Use the last element in postorder array as the root of the binary tree.\\n    Find the index of the root in inorder array. This can be done using a map to store the index of each element in inorder array.\\n    Split the inorder array into two parts at the index of the root. The left part will be the left subtree and the right part will be the right subtree.\\n    Split the postorder array into two parts. The left part will contain the elements of the left subtree and the right part will contain the elements of the right subtree.\\n    Recursively construct the left subtree and the right subtree using the left and right parts of the inorder and postorder arrays, respectively.\\n    Return the root of the binary tree."
                    },
                    {
                        "username": "arifulkazi",
                        "content": "Output should be [-1] for example 2 provided in the problem description as shown below.\\n\\nExample 2:\\nInput: inorder = [-1], postorder = [-1]\\nOutput: []\\n"
                    },
                    {
                        "username": "Web_Ghost10",
                        "content": "Real Pain : \nTotal Testcases=202\nTLE occur at 201 testcase  "
                    }
                ]
            },
            {
                "id": 2057785,
                "content": [
                    {
                        "username": "balleater",
                        "content": "they really determined to make me learn binary trees"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "In postorder traversal the last value is the **root** value."
                    },
                    {
                        "username": "dmskpd",
                        "content": "inorder = [15,20,3,7], postorder = [15,7,20,3], code does nothing and returns None, result - Memory Limit Exceeded?"
                    },
                    {
                        "username": "zali100",
                        "content": "I think the postorder should be [15,20,7,3] or [20,15,7,3] because the current postoder of [15,7,20,3] doesn\\'t match properly with the given inorder. "
                    },
                    {
                        "username": "spec_he123",
                        "content": "https://youtu.be/x2aUTgi-068\\n"
                    },
                    {
                        "username": "Harsh_Gupta_49",
                        "content": "it\\'s definately 106 cm."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "when the input arrays are empty or have different lengths, or when there are duplicate elements in the inorder traversal. These cases require additional checks and special handling to ensure that the algorithm works correctly."
                    },
                    {
                        "username": "sahle123",
                        "content": "This problem was surprisingly challenging..."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "  simple way.. to sol\\n  Use the last element in postorder array as the root of the binary tree.\\n    Find the index of the root in inorder array. This can be done using a map to store the index of each element in inorder array.\\n    Split the inorder array into two parts at the index of the root. The left part will be the left subtree and the right part will be the right subtree.\\n    Split the postorder array into two parts. The left part will contain the elements of the left subtree and the right part will contain the elements of the right subtree.\\n    Recursively construct the left subtree and the right subtree using the left and right parts of the inorder and postorder arrays, respectively.\\n    Return the root of the binary tree."
                    },
                    {
                        "username": "arifulkazi",
                        "content": "Output should be [-1] for example 2 provided in the problem description as shown below.\\n\\nExample 2:\\nInput: inorder = [-1], postorder = [-1]\\nOutput: []\\n"
                    },
                    {
                        "username": "Web_Ghost10",
                        "content": "Real Pain : \nTotal Testcases=202\nTLE occur at 201 testcase  "
                    }
                ]
            },
            {
                "id": 1971060,
                "content": [
                    {
                        "username": "Archit_Srivastava",
                        "content": "Can anyone tell what\\'s wrong in this solution its passing 201/202 testcases .\\n\\n\\nclass Solution {\\n\\n\\npublic:\\nTreeNode *solve(vector<int>& inorder, vector<int>& postorder, map<int,int>mp, int &index, int start, int end, int n)\\n{\\n    if(index<0 || start>end )\\n    return NULL; \\n\\n    int ele=postorder[index--];\\n    TreeNode *root=new TreeNode(ele);\\n    int pos=mp[ele];\\n    //recursion\\n    root->right=solve(inorder,postorder,mp,index,pos+1,end,n);\\n    root->left=solve(inorder,postorder,mp,index,start,pos-1,n);\\n    \\n\\n    return root;\\n\\n}\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        \\n        int n=inorder.size();\\n        int postIdx=n-1;\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        mp[inorder[i]]=i;\\n\\n        TreeNode *ans=solve(inorder,postorder,mp,postIdx,0,n-1,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Putting left recusive call before right is givng wrong ans,, can anyone help\\n\\nint ind;\\n    unordered_map<int,int>mp; \\nTreeNode* build(vector<int> &inorder, vector<int> &postorder, int st, int end){\\n    if(st>end || ind<0)return NULL;\\n    TreeNode* root = new TreeNode(postorder[ind]);\\n    int pos = mp[postorder[ind]];\\n    ind--;\\n            // this is giving correct if i put right before left\\n    root->left = build(inorder,postorder,st,pos-1); \\n    root->right = build(inorder,postorder,pos+1, end);\\n    return root;\\n}\\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    ind = postorder.size()-1;\\n    for(int i = 0; i <= ind; i++)\\n        mp[inorder[i]] = i;\\n    TreeNode* root = build(inorder,postorder,0,inorder.size()-1);\\n    return root;\\n}\\n    "
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "If you get this in interview they don\\'t want to hire you\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Feeling really happy today. Solved this question in 9 minutes sitting with pen and paper when my boring professor delivered his lecture on some other subject lol."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Similar problem - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Tip:\\n\\nRecursive DFS has O(N^2) TC (~ beats 5-11%)\\nRecursive DFS with hashMap has O(N) TC (~beats 90%)\\n\\nHashmap that maps values -> indices (this is 1:1 since values are unique)\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "SOMEONE PLS HELP ME IM SO CLOSE TO THE SOLUTION I FEEL.\\nIm getting the following error, like why. what improvements should i do in my code\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 5\\n  at line 36, Solution.solve\\n  at line 25, Solution.buildTree\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n\\n```\\nclass Solution {\\n\\n        int postIndex;\\n        int inIndex=0;          //inorder index\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int inorderStart=0;\\n        int inorderEnd= inorder.length-1;\\n\\n        postIndex= postorder.length-1;\\n        return solve(inorder, postorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] inorder, int[] postorder, int inorderStart, int inorderEnd)\\n    {\\n        if(inorderStart>inorderEnd ) return null;\\n        TreeNode root= new TreeNode(postorder[postIndex--]);\\n        // postIndex--;\\n\\n        //locate root.val in the inorder array\\n        for(int i=inorderStart; i<= inorderEnd; i--)\\n        {\\n            if(inorder[i]== root.val)\\n                {\\n                    inIndex=i;\\n                    break;\\n                }\\n        }\\n\\n        root.left= solve(inorder, postorder, inorderStart, inIndex-1);\\n        root.right= solve(inorder, postorder, inIndex+1, inorderEnd);\\n\\n            return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&inorder,vector<int>&postorder,int si,int ei,int pi,int pe){\\n        \\n       if(si>ei or pi>pe){\\n           return NULL;\\n       }\\n     \\n\\n       \\n        //reursive case\\n        \\n        TreeNode* root=new TreeNode(postorder[pe]);\\n          pe--;\\n         int indx=-1;\\n        for(int i=si;i<=ei;i++){\\n           if(inorder[i]==postorder[pe]){\\n               indx=i;\\n           }\\n        }\\n        root->left=solve(inorder,postorder,si,indx-1,pi,pe);\\n        root->right=solve(inorder,postorder,indx+1,ei,pi,pe);\\n        return root;\\n\\n\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n       if(inorder.size()==0){\\n           return NULL;\\n       }\\n        int ei=inorder.size()-1;\\n        int pe=postorder.size()-1;\\n        return solve(inorder,postorder,0,ei,0,pe);\\n    }\\n};\\n\\n\\ncan someone tell mistake in my code"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "I got time limit exceeded for only following testcase and I used recursion to solve it. Can someone tell me where i possibly got wrong or any tips to optimize. \\n[-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910,-909,-908,-907,-906,-905,-904,-903,-902,-901,-900,-899,-898,-897,-896,-895,-894,-893,-892,-891,-890,-889,-888,-887,-886,-885,-884,-883,-882,-881,-880,-879,-878,-877,-876,-875,-874,-873,-872,-871,-870,-869,-868,-867,-866,-865,-864,-863,-862,-861,-860,-859,-858,-857,-856,-855,-854,-853,-852,-851,-850,-849,-848,-847,-846,-845,-844,-843,-842,-841,-840,-839,-838,-837,-836,-835,-834,-833,-832,-831,-830,-829,-828,-827,-826,-825,-824,-823,-822,-821,-820,-819,-818,-817,-816,-815,-814,-813,-812,-811,-810,-809,-808,-807,-806,-805,-804,-803,-802,-801,-800,-799,-798,-797,-796,-795,-794,-793,-792,-791,-790,-789,-788,-787,-786,-785,-784,-783,-782,-781,-780,-779,-778,-777,-776,-775,-774,-773,-772,-771,-770,-769,-768,-767,-766,-765,-764,-763,-762,-761,-760,-759,-758,-757,-756,-755,-754,-753,-752,-751,-750,-749,-748,-747,-746,-745,-744,-743,-742,-741,-740,-739,-738,-737,-736,-735,-734,-733,-732,-731,-730,-729,-728,-727,-726,-725,-724,-723,-722,-721,-720,-719,-718,-717,-716,-715,-714,-713,-712,-711,-710,-709,-708,-707,-706,-705,-704,-703,-702,-701,-700,-699,-698,-697,-696,-695,-694,-693,-692,-691,-690,-689,-688,-687,-686,-685,-684,-683,-682,-681,-680,-679,-678,-677,-676,-675,-674,-673,-672,-671,-670,-669,-668,-667,-666,-665,-664,-663,-662,-661,-660,-659,-658,-657,-656,-655,-654,-653,-652,-651,-650,-649,-648,-647,-646,-645,-644,-643,-642,-641,-640,-639,-638,-637,-636,-635,-634,-633,-632,-631,-630,-629,-628,-627,-626,-625,-624,-623,-622,-621,-620,-619,-618,-617,-616,-615,-614,-613,-612,-611,-610,-609,-608,-607,-606,-605,-604,-603,-602,-601,-600,-599,-598,-597,-596,-595,-594,-593,-592,-591,-590,-589,-588,-587,-586,-585,-584,-583,-582,-581,-580,-579,-578,-577,-576,-575,-574,-573,-572,-571,-570,-569,-568,-567,-566,-565,-564,-563,-562,-561,-560,-559,-558,-557,-556,-555,-554,-553,-552,-551,-550,-549,-548,-547,-546,-545,-544,-543,-542,-541,-540,-539,-538,-537,-536,-535,-534,-533,-532,-531,-530,-529,-528,-527,-526,-525,-524,-523,-522,-521,-520,-519,-518,-517,-516,-515,-514,-513,-512,-511,-510,-509,-508,-507,-506,-505,-504,-503,-502,-501,-500,-499,-498,-497,-496,-495,-494,-493,-492,-491,-490,-489,-488,-487,-486,-485,-484,-483,-482,-481,-480,-479,-478,-477,-476,-475,-474,-473,-472,-471,-470,-469,-468,-467,-466,-465,-464,-463,-462,-461,-460,-459,-458,-457,-456,-455,-454,-453,-452,-451,-450,-449,-448,-447,-446,-445,-444,-443,-442,-441,-440,-439,-438,-437,-436,-435,-434,-433,-432,-431,-430,-429,-428,-427,-426,-425,-424,-423,-422,-421,-420,-419,-418,-417,-416,-415,-414,-413,-412,-411,-410,-409,-408,-407,-406,-405,-404,-403,-402,-401,-400,-399,-398,-397,-396,-395,-394,-393,-392,-391,-390,-389,-388,-387,-386,-385,-384,-383,-382,-381,-380,-379,-378,-377,-376,-375,-374,-373,-372,-371,-370,-369,-368,-367,-366,-365,-364,-363,-362,-361,-360,-359,-358,-357,-356,-355,-354,-353,-352,-351,-350,-349,-348,-347,-346,-345,-344,-343,-342,-341,-340,-339,-338,-337,-336,-335,-334,-333,-332,-331,-330,-329,-328,-327,-326,-325,-324,-323,-322,-321,-320,-319,-318,-317,-316,-315,-314,-313,-312,-311,-310,-309,-308,-307,-306,-305,-304,-303,-302,-301,-300,-299,-298,-297,-296,-295,-294,-293,-292,-291,-290,-289,-288,-287,-286,-285,-284,-283,-282,-281,-280,-279,-278,-277,-276,-275,-274,-273,-272,-271,-270,-269,-268,-267,-266,-265,-264,-263,-262,-261,-260,-259,-258,-257,-256,-255,-254,-253,-252,-251,-250,-249,-248,-247,-246,-245,-244,-243,-242,-241,-240,-239,-238,-237,-236,-235,-234,-233,-232,-231,-230,-229,-228,-227,-226,-225,-224,-223,-222,-221,-220,-219,-218,-217,-216,-215,-214,-213,-212,-211,-210,-209,-208,-207,-206,-205,-204,-203,-202,-201,-200,-199,-198,-197,-196,-195,-194,-193,-192,-191,-190,-189,-188,-187,-186,-185,-184,-183,-182,-181,-180,-179,-178,-177,-176,-175,-174,-173,-172,-171,-170,-169,-168,-167,-166,-165,-164,-163,-162,-161,-160,-159,-158,-157,-156,-155,-154,-153,-152,-151,-150,-149,-148,-147,-146,-145,-144,-143,-142,-141,-140,-139,-138,-137,-136,-135,-134,-133,-132,-131,-130,-129,-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,-102,-101,-100,-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-73,-72,-71,-70,-69,-68,-67,-66,-65,-64,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000]\\n\\n"
                    },
                    {
                        "username": "harsh788",
                        "content": "[@Swapnil07072000](/Swapnil07072000) Thanks dude, this helped me. But I am not sure why it solved the problem..."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Faced the same error, solved it by sending reference to vectors and hashmap if used."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Time Limit Exceeded (in red colour) \nEdit: 77%,77% in C :)"
                    }
                ]
            },
            {
                "id": 1966964,
                "content": [
                    {
                        "username": "Archit_Srivastava",
                        "content": "Can anyone tell what\\'s wrong in this solution its passing 201/202 testcases .\\n\\n\\nclass Solution {\\n\\n\\npublic:\\nTreeNode *solve(vector<int>& inorder, vector<int>& postorder, map<int,int>mp, int &index, int start, int end, int n)\\n{\\n    if(index<0 || start>end )\\n    return NULL; \\n\\n    int ele=postorder[index--];\\n    TreeNode *root=new TreeNode(ele);\\n    int pos=mp[ele];\\n    //recursion\\n    root->right=solve(inorder,postorder,mp,index,pos+1,end,n);\\n    root->left=solve(inorder,postorder,mp,index,start,pos-1,n);\\n    \\n\\n    return root;\\n\\n}\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        \\n        int n=inorder.size();\\n        int postIdx=n-1;\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        mp[inorder[i]]=i;\\n\\n        TreeNode *ans=solve(inorder,postorder,mp,postIdx,0,n-1,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Putting left recusive call before right is givng wrong ans,, can anyone help\\n\\nint ind;\\n    unordered_map<int,int>mp; \\nTreeNode* build(vector<int> &inorder, vector<int> &postorder, int st, int end){\\n    if(st>end || ind<0)return NULL;\\n    TreeNode* root = new TreeNode(postorder[ind]);\\n    int pos = mp[postorder[ind]];\\n    ind--;\\n            // this is giving correct if i put right before left\\n    root->left = build(inorder,postorder,st,pos-1); \\n    root->right = build(inorder,postorder,pos+1, end);\\n    return root;\\n}\\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    ind = postorder.size()-1;\\n    for(int i = 0; i <= ind; i++)\\n        mp[inorder[i]] = i;\\n    TreeNode* root = build(inorder,postorder,0,inorder.size()-1);\\n    return root;\\n}\\n    "
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "If you get this in interview they don\\'t want to hire you\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Feeling really happy today. Solved this question in 9 minutes sitting with pen and paper when my boring professor delivered his lecture on some other subject lol."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Similar problem - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Tip:\\n\\nRecursive DFS has O(N^2) TC (~ beats 5-11%)\\nRecursive DFS with hashMap has O(N) TC (~beats 90%)\\n\\nHashmap that maps values -> indices (this is 1:1 since values are unique)\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "SOMEONE PLS HELP ME IM SO CLOSE TO THE SOLUTION I FEEL.\\nIm getting the following error, like why. what improvements should i do in my code\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 5\\n  at line 36, Solution.solve\\n  at line 25, Solution.buildTree\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n\\n```\\nclass Solution {\\n\\n        int postIndex;\\n        int inIndex=0;          //inorder index\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int inorderStart=0;\\n        int inorderEnd= inorder.length-1;\\n\\n        postIndex= postorder.length-1;\\n        return solve(inorder, postorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] inorder, int[] postorder, int inorderStart, int inorderEnd)\\n    {\\n        if(inorderStart>inorderEnd ) return null;\\n        TreeNode root= new TreeNode(postorder[postIndex--]);\\n        // postIndex--;\\n\\n        //locate root.val in the inorder array\\n        for(int i=inorderStart; i<= inorderEnd; i--)\\n        {\\n            if(inorder[i]== root.val)\\n                {\\n                    inIndex=i;\\n                    break;\\n                }\\n        }\\n\\n        root.left= solve(inorder, postorder, inorderStart, inIndex-1);\\n        root.right= solve(inorder, postorder, inIndex+1, inorderEnd);\\n\\n            return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&inorder,vector<int>&postorder,int si,int ei,int pi,int pe){\\n        \\n       if(si>ei or pi>pe){\\n           return NULL;\\n       }\\n     \\n\\n       \\n        //reursive case\\n        \\n        TreeNode* root=new TreeNode(postorder[pe]);\\n          pe--;\\n         int indx=-1;\\n        for(int i=si;i<=ei;i++){\\n           if(inorder[i]==postorder[pe]){\\n               indx=i;\\n           }\\n        }\\n        root->left=solve(inorder,postorder,si,indx-1,pi,pe);\\n        root->right=solve(inorder,postorder,indx+1,ei,pi,pe);\\n        return root;\\n\\n\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n       if(inorder.size()==0){\\n           return NULL;\\n       }\\n        int ei=inorder.size()-1;\\n        int pe=postorder.size()-1;\\n        return solve(inorder,postorder,0,ei,0,pe);\\n    }\\n};\\n\\n\\ncan someone tell mistake in my code"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "I got time limit exceeded for only following testcase and I used recursion to solve it. Can someone tell me where i possibly got wrong or any tips to optimize. \\n[-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910,-909,-908,-907,-906,-905,-904,-903,-902,-901,-900,-899,-898,-897,-896,-895,-894,-893,-892,-891,-890,-889,-888,-887,-886,-885,-884,-883,-882,-881,-880,-879,-878,-877,-876,-875,-874,-873,-872,-871,-870,-869,-868,-867,-866,-865,-864,-863,-862,-861,-860,-859,-858,-857,-856,-855,-854,-853,-852,-851,-850,-849,-848,-847,-846,-845,-844,-843,-842,-841,-840,-839,-838,-837,-836,-835,-834,-833,-832,-831,-830,-829,-828,-827,-826,-825,-824,-823,-822,-821,-820,-819,-818,-817,-816,-815,-814,-813,-812,-811,-810,-809,-808,-807,-806,-805,-804,-803,-802,-801,-800,-799,-798,-797,-796,-795,-794,-793,-792,-791,-790,-789,-788,-787,-786,-785,-784,-783,-782,-781,-780,-779,-778,-777,-776,-775,-774,-773,-772,-771,-770,-769,-768,-767,-766,-765,-764,-763,-762,-761,-760,-759,-758,-757,-756,-755,-754,-753,-752,-751,-750,-749,-748,-747,-746,-745,-744,-743,-742,-741,-740,-739,-738,-737,-736,-735,-734,-733,-732,-731,-730,-729,-728,-727,-726,-725,-724,-723,-722,-721,-720,-719,-718,-717,-716,-715,-714,-713,-712,-711,-710,-709,-708,-707,-706,-705,-704,-703,-702,-701,-700,-699,-698,-697,-696,-695,-694,-693,-692,-691,-690,-689,-688,-687,-686,-685,-684,-683,-682,-681,-680,-679,-678,-677,-676,-675,-674,-673,-672,-671,-670,-669,-668,-667,-666,-665,-664,-663,-662,-661,-660,-659,-658,-657,-656,-655,-654,-653,-652,-651,-650,-649,-648,-647,-646,-645,-644,-643,-642,-641,-640,-639,-638,-637,-636,-635,-634,-633,-632,-631,-630,-629,-628,-627,-626,-625,-624,-623,-622,-621,-620,-619,-618,-617,-616,-615,-614,-613,-612,-611,-610,-609,-608,-607,-606,-605,-604,-603,-602,-601,-600,-599,-598,-597,-596,-595,-594,-593,-592,-591,-590,-589,-588,-587,-586,-585,-584,-583,-582,-581,-580,-579,-578,-577,-576,-575,-574,-573,-572,-571,-570,-569,-568,-567,-566,-565,-564,-563,-562,-561,-560,-559,-558,-557,-556,-555,-554,-553,-552,-551,-550,-549,-548,-547,-546,-545,-544,-543,-542,-541,-540,-539,-538,-537,-536,-535,-534,-533,-532,-531,-530,-529,-528,-527,-526,-525,-524,-523,-522,-521,-520,-519,-518,-517,-516,-515,-514,-513,-512,-511,-510,-509,-508,-507,-506,-505,-504,-503,-502,-501,-500,-499,-498,-497,-496,-495,-494,-493,-492,-491,-490,-489,-488,-487,-486,-485,-484,-483,-482,-481,-480,-479,-478,-477,-476,-475,-474,-473,-472,-471,-470,-469,-468,-467,-466,-465,-464,-463,-462,-461,-460,-459,-458,-457,-456,-455,-454,-453,-452,-451,-450,-449,-448,-447,-446,-445,-444,-443,-442,-441,-440,-439,-438,-437,-436,-435,-434,-433,-432,-431,-430,-429,-428,-427,-426,-425,-424,-423,-422,-421,-420,-419,-418,-417,-416,-415,-414,-413,-412,-411,-410,-409,-408,-407,-406,-405,-404,-403,-402,-401,-400,-399,-398,-397,-396,-395,-394,-393,-392,-391,-390,-389,-388,-387,-386,-385,-384,-383,-382,-381,-380,-379,-378,-377,-376,-375,-374,-373,-372,-371,-370,-369,-368,-367,-366,-365,-364,-363,-362,-361,-360,-359,-358,-357,-356,-355,-354,-353,-352,-351,-350,-349,-348,-347,-346,-345,-344,-343,-342,-341,-340,-339,-338,-337,-336,-335,-334,-333,-332,-331,-330,-329,-328,-327,-326,-325,-324,-323,-322,-321,-320,-319,-318,-317,-316,-315,-314,-313,-312,-311,-310,-309,-308,-307,-306,-305,-304,-303,-302,-301,-300,-299,-298,-297,-296,-295,-294,-293,-292,-291,-290,-289,-288,-287,-286,-285,-284,-283,-282,-281,-280,-279,-278,-277,-276,-275,-274,-273,-272,-271,-270,-269,-268,-267,-266,-265,-264,-263,-262,-261,-260,-259,-258,-257,-256,-255,-254,-253,-252,-251,-250,-249,-248,-247,-246,-245,-244,-243,-242,-241,-240,-239,-238,-237,-236,-235,-234,-233,-232,-231,-230,-229,-228,-227,-226,-225,-224,-223,-222,-221,-220,-219,-218,-217,-216,-215,-214,-213,-212,-211,-210,-209,-208,-207,-206,-205,-204,-203,-202,-201,-200,-199,-198,-197,-196,-195,-194,-193,-192,-191,-190,-189,-188,-187,-186,-185,-184,-183,-182,-181,-180,-179,-178,-177,-176,-175,-174,-173,-172,-171,-170,-169,-168,-167,-166,-165,-164,-163,-162,-161,-160,-159,-158,-157,-156,-155,-154,-153,-152,-151,-150,-149,-148,-147,-146,-145,-144,-143,-142,-141,-140,-139,-138,-137,-136,-135,-134,-133,-132,-131,-130,-129,-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,-102,-101,-100,-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-73,-72,-71,-70,-69,-68,-67,-66,-65,-64,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000]\\n\\n"
                    },
                    {
                        "username": "harsh788",
                        "content": "[@Swapnil07072000](/Swapnil07072000) Thanks dude, this helped me. But I am not sure why it solved the problem..."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Faced the same error, solved it by sending reference to vectors and hashmap if used."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Time Limit Exceeded (in red colour) \nEdit: 77%,77% in C :)"
                    }
                ]
            },
            {
                "id": 1953141,
                "content": [
                    {
                        "username": "Archit_Srivastava",
                        "content": "Can anyone tell what\\'s wrong in this solution its passing 201/202 testcases .\\n\\n\\nclass Solution {\\n\\n\\npublic:\\nTreeNode *solve(vector<int>& inorder, vector<int>& postorder, map<int,int>mp, int &index, int start, int end, int n)\\n{\\n    if(index<0 || start>end )\\n    return NULL; \\n\\n    int ele=postorder[index--];\\n    TreeNode *root=new TreeNode(ele);\\n    int pos=mp[ele];\\n    //recursion\\n    root->right=solve(inorder,postorder,mp,index,pos+1,end,n);\\n    root->left=solve(inorder,postorder,mp,index,start,pos-1,n);\\n    \\n\\n    return root;\\n\\n}\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        \\n        int n=inorder.size();\\n        int postIdx=n-1;\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        mp[inorder[i]]=i;\\n\\n        TreeNode *ans=solve(inorder,postorder,mp,postIdx,0,n-1,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Putting left recusive call before right is givng wrong ans,, can anyone help\\n\\nint ind;\\n    unordered_map<int,int>mp; \\nTreeNode* build(vector<int> &inorder, vector<int> &postorder, int st, int end){\\n    if(st>end || ind<0)return NULL;\\n    TreeNode* root = new TreeNode(postorder[ind]);\\n    int pos = mp[postorder[ind]];\\n    ind--;\\n            // this is giving correct if i put right before left\\n    root->left = build(inorder,postorder,st,pos-1); \\n    root->right = build(inorder,postorder,pos+1, end);\\n    return root;\\n}\\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    ind = postorder.size()-1;\\n    for(int i = 0; i <= ind; i++)\\n        mp[inorder[i]] = i;\\n    TreeNode* root = build(inorder,postorder,0,inorder.size()-1);\\n    return root;\\n}\\n    "
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "If you get this in interview they don\\'t want to hire you\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Feeling really happy today. Solved this question in 9 minutes sitting with pen and paper when my boring professor delivered his lecture on some other subject lol."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Similar problem - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Tip:\\n\\nRecursive DFS has O(N^2) TC (~ beats 5-11%)\\nRecursive DFS with hashMap has O(N) TC (~beats 90%)\\n\\nHashmap that maps values -> indices (this is 1:1 since values are unique)\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "SOMEONE PLS HELP ME IM SO CLOSE TO THE SOLUTION I FEEL.\\nIm getting the following error, like why. what improvements should i do in my code\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 5\\n  at line 36, Solution.solve\\n  at line 25, Solution.buildTree\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n\\n```\\nclass Solution {\\n\\n        int postIndex;\\n        int inIndex=0;          //inorder index\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int inorderStart=0;\\n        int inorderEnd= inorder.length-1;\\n\\n        postIndex= postorder.length-1;\\n        return solve(inorder, postorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] inorder, int[] postorder, int inorderStart, int inorderEnd)\\n    {\\n        if(inorderStart>inorderEnd ) return null;\\n        TreeNode root= new TreeNode(postorder[postIndex--]);\\n        // postIndex--;\\n\\n        //locate root.val in the inorder array\\n        for(int i=inorderStart; i<= inorderEnd; i--)\\n        {\\n            if(inorder[i]== root.val)\\n                {\\n                    inIndex=i;\\n                    break;\\n                }\\n        }\\n\\n        root.left= solve(inorder, postorder, inorderStart, inIndex-1);\\n        root.right= solve(inorder, postorder, inIndex+1, inorderEnd);\\n\\n            return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&inorder,vector<int>&postorder,int si,int ei,int pi,int pe){\\n        \\n       if(si>ei or pi>pe){\\n           return NULL;\\n       }\\n     \\n\\n       \\n        //reursive case\\n        \\n        TreeNode* root=new TreeNode(postorder[pe]);\\n          pe--;\\n         int indx=-1;\\n        for(int i=si;i<=ei;i++){\\n           if(inorder[i]==postorder[pe]){\\n               indx=i;\\n           }\\n        }\\n        root->left=solve(inorder,postorder,si,indx-1,pi,pe);\\n        root->right=solve(inorder,postorder,indx+1,ei,pi,pe);\\n        return root;\\n\\n\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n       if(inorder.size()==0){\\n           return NULL;\\n       }\\n        int ei=inorder.size()-1;\\n        int pe=postorder.size()-1;\\n        return solve(inorder,postorder,0,ei,0,pe);\\n    }\\n};\\n\\n\\ncan someone tell mistake in my code"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "I got time limit exceeded for only following testcase and I used recursion to solve it. Can someone tell me where i possibly got wrong or any tips to optimize. \\n[-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910,-909,-908,-907,-906,-905,-904,-903,-902,-901,-900,-899,-898,-897,-896,-895,-894,-893,-892,-891,-890,-889,-888,-887,-886,-885,-884,-883,-882,-881,-880,-879,-878,-877,-876,-875,-874,-873,-872,-871,-870,-869,-868,-867,-866,-865,-864,-863,-862,-861,-860,-859,-858,-857,-856,-855,-854,-853,-852,-851,-850,-849,-848,-847,-846,-845,-844,-843,-842,-841,-840,-839,-838,-837,-836,-835,-834,-833,-832,-831,-830,-829,-828,-827,-826,-825,-824,-823,-822,-821,-820,-819,-818,-817,-816,-815,-814,-813,-812,-811,-810,-809,-808,-807,-806,-805,-804,-803,-802,-801,-800,-799,-798,-797,-796,-795,-794,-793,-792,-791,-790,-789,-788,-787,-786,-785,-784,-783,-782,-781,-780,-779,-778,-777,-776,-775,-774,-773,-772,-771,-770,-769,-768,-767,-766,-765,-764,-763,-762,-761,-760,-759,-758,-757,-756,-755,-754,-753,-752,-751,-750,-749,-748,-747,-746,-745,-744,-743,-742,-741,-740,-739,-738,-737,-736,-735,-734,-733,-732,-731,-730,-729,-728,-727,-726,-725,-724,-723,-722,-721,-720,-719,-718,-717,-716,-715,-714,-713,-712,-711,-710,-709,-708,-707,-706,-705,-704,-703,-702,-701,-700,-699,-698,-697,-696,-695,-694,-693,-692,-691,-690,-689,-688,-687,-686,-685,-684,-683,-682,-681,-680,-679,-678,-677,-676,-675,-674,-673,-672,-671,-670,-669,-668,-667,-666,-665,-664,-663,-662,-661,-660,-659,-658,-657,-656,-655,-654,-653,-652,-651,-650,-649,-648,-647,-646,-645,-644,-643,-642,-641,-640,-639,-638,-637,-636,-635,-634,-633,-632,-631,-630,-629,-628,-627,-626,-625,-624,-623,-622,-621,-620,-619,-618,-617,-616,-615,-614,-613,-612,-611,-610,-609,-608,-607,-606,-605,-604,-603,-602,-601,-600,-599,-598,-597,-596,-595,-594,-593,-592,-591,-590,-589,-588,-587,-586,-585,-584,-583,-582,-581,-580,-579,-578,-577,-576,-575,-574,-573,-572,-571,-570,-569,-568,-567,-566,-565,-564,-563,-562,-561,-560,-559,-558,-557,-556,-555,-554,-553,-552,-551,-550,-549,-548,-547,-546,-545,-544,-543,-542,-541,-540,-539,-538,-537,-536,-535,-534,-533,-532,-531,-530,-529,-528,-527,-526,-525,-524,-523,-522,-521,-520,-519,-518,-517,-516,-515,-514,-513,-512,-511,-510,-509,-508,-507,-506,-505,-504,-503,-502,-501,-500,-499,-498,-497,-496,-495,-494,-493,-492,-491,-490,-489,-488,-487,-486,-485,-484,-483,-482,-481,-480,-479,-478,-477,-476,-475,-474,-473,-472,-471,-470,-469,-468,-467,-466,-465,-464,-463,-462,-461,-460,-459,-458,-457,-456,-455,-454,-453,-452,-451,-450,-449,-448,-447,-446,-445,-444,-443,-442,-441,-440,-439,-438,-437,-436,-435,-434,-433,-432,-431,-430,-429,-428,-427,-426,-425,-424,-423,-422,-421,-420,-419,-418,-417,-416,-415,-414,-413,-412,-411,-410,-409,-408,-407,-406,-405,-404,-403,-402,-401,-400,-399,-398,-397,-396,-395,-394,-393,-392,-391,-390,-389,-388,-387,-386,-385,-384,-383,-382,-381,-380,-379,-378,-377,-376,-375,-374,-373,-372,-371,-370,-369,-368,-367,-366,-365,-364,-363,-362,-361,-360,-359,-358,-357,-356,-355,-354,-353,-352,-351,-350,-349,-348,-347,-346,-345,-344,-343,-342,-341,-340,-339,-338,-337,-336,-335,-334,-333,-332,-331,-330,-329,-328,-327,-326,-325,-324,-323,-322,-321,-320,-319,-318,-317,-316,-315,-314,-313,-312,-311,-310,-309,-308,-307,-306,-305,-304,-303,-302,-301,-300,-299,-298,-297,-296,-295,-294,-293,-292,-291,-290,-289,-288,-287,-286,-285,-284,-283,-282,-281,-280,-279,-278,-277,-276,-275,-274,-273,-272,-271,-270,-269,-268,-267,-266,-265,-264,-263,-262,-261,-260,-259,-258,-257,-256,-255,-254,-253,-252,-251,-250,-249,-248,-247,-246,-245,-244,-243,-242,-241,-240,-239,-238,-237,-236,-235,-234,-233,-232,-231,-230,-229,-228,-227,-226,-225,-224,-223,-222,-221,-220,-219,-218,-217,-216,-215,-214,-213,-212,-211,-210,-209,-208,-207,-206,-205,-204,-203,-202,-201,-200,-199,-198,-197,-196,-195,-194,-193,-192,-191,-190,-189,-188,-187,-186,-185,-184,-183,-182,-181,-180,-179,-178,-177,-176,-175,-174,-173,-172,-171,-170,-169,-168,-167,-166,-165,-164,-163,-162,-161,-160,-159,-158,-157,-156,-155,-154,-153,-152,-151,-150,-149,-148,-147,-146,-145,-144,-143,-142,-141,-140,-139,-138,-137,-136,-135,-134,-133,-132,-131,-130,-129,-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,-102,-101,-100,-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-73,-72,-71,-70,-69,-68,-67,-66,-65,-64,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000]\\n\\n"
                    },
                    {
                        "username": "harsh788",
                        "content": "[@Swapnil07072000](/Swapnil07072000) Thanks dude, this helped me. But I am not sure why it solved the problem..."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Faced the same error, solved it by sending reference to vectors and hashmap if used."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Time Limit Exceeded (in red colour) \nEdit: 77%,77% in C :)"
                    }
                ]
            },
            {
                "id": 1837716,
                "content": [
                    {
                        "username": "Archit_Srivastava",
                        "content": "Can anyone tell what\\'s wrong in this solution its passing 201/202 testcases .\\n\\n\\nclass Solution {\\n\\n\\npublic:\\nTreeNode *solve(vector<int>& inorder, vector<int>& postorder, map<int,int>mp, int &index, int start, int end, int n)\\n{\\n    if(index<0 || start>end )\\n    return NULL; \\n\\n    int ele=postorder[index--];\\n    TreeNode *root=new TreeNode(ele);\\n    int pos=mp[ele];\\n    //recursion\\n    root->right=solve(inorder,postorder,mp,index,pos+1,end,n);\\n    root->left=solve(inorder,postorder,mp,index,start,pos-1,n);\\n    \\n\\n    return root;\\n\\n}\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        \\n        int n=inorder.size();\\n        int postIdx=n-1;\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        mp[inorder[i]]=i;\\n\\n        TreeNode *ans=solve(inorder,postorder,mp,postIdx,0,n-1,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Putting left recusive call before right is givng wrong ans,, can anyone help\\n\\nint ind;\\n    unordered_map<int,int>mp; \\nTreeNode* build(vector<int> &inorder, vector<int> &postorder, int st, int end){\\n    if(st>end || ind<0)return NULL;\\n    TreeNode* root = new TreeNode(postorder[ind]);\\n    int pos = mp[postorder[ind]];\\n    ind--;\\n            // this is giving correct if i put right before left\\n    root->left = build(inorder,postorder,st,pos-1); \\n    root->right = build(inorder,postorder,pos+1, end);\\n    return root;\\n}\\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    ind = postorder.size()-1;\\n    for(int i = 0; i <= ind; i++)\\n        mp[inorder[i]] = i;\\n    TreeNode* root = build(inorder,postorder,0,inorder.size()-1);\\n    return root;\\n}\\n    "
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "If you get this in interview they don\\'t want to hire you\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Feeling really happy today. Solved this question in 9 minutes sitting with pen and paper when my boring professor delivered his lecture on some other subject lol."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Similar problem - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Tip:\\n\\nRecursive DFS has O(N^2) TC (~ beats 5-11%)\\nRecursive DFS with hashMap has O(N) TC (~beats 90%)\\n\\nHashmap that maps values -> indices (this is 1:1 since values are unique)\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "SOMEONE PLS HELP ME IM SO CLOSE TO THE SOLUTION I FEEL.\\nIm getting the following error, like why. what improvements should i do in my code\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 5\\n  at line 36, Solution.solve\\n  at line 25, Solution.buildTree\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n\\n```\\nclass Solution {\\n\\n        int postIndex;\\n        int inIndex=0;          //inorder index\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int inorderStart=0;\\n        int inorderEnd= inorder.length-1;\\n\\n        postIndex= postorder.length-1;\\n        return solve(inorder, postorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] inorder, int[] postorder, int inorderStart, int inorderEnd)\\n    {\\n        if(inorderStart>inorderEnd ) return null;\\n        TreeNode root= new TreeNode(postorder[postIndex--]);\\n        // postIndex--;\\n\\n        //locate root.val in the inorder array\\n        for(int i=inorderStart; i<= inorderEnd; i--)\\n        {\\n            if(inorder[i]== root.val)\\n                {\\n                    inIndex=i;\\n                    break;\\n                }\\n        }\\n\\n        root.left= solve(inorder, postorder, inorderStart, inIndex-1);\\n        root.right= solve(inorder, postorder, inIndex+1, inorderEnd);\\n\\n            return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&inorder,vector<int>&postorder,int si,int ei,int pi,int pe){\\n        \\n       if(si>ei or pi>pe){\\n           return NULL;\\n       }\\n     \\n\\n       \\n        //reursive case\\n        \\n        TreeNode* root=new TreeNode(postorder[pe]);\\n          pe--;\\n         int indx=-1;\\n        for(int i=si;i<=ei;i++){\\n           if(inorder[i]==postorder[pe]){\\n               indx=i;\\n           }\\n        }\\n        root->left=solve(inorder,postorder,si,indx-1,pi,pe);\\n        root->right=solve(inorder,postorder,indx+1,ei,pi,pe);\\n        return root;\\n\\n\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n       if(inorder.size()==0){\\n           return NULL;\\n       }\\n        int ei=inorder.size()-1;\\n        int pe=postorder.size()-1;\\n        return solve(inorder,postorder,0,ei,0,pe);\\n    }\\n};\\n\\n\\ncan someone tell mistake in my code"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "I got time limit exceeded for only following testcase and I used recursion to solve it. Can someone tell me where i possibly got wrong or any tips to optimize. \\n[-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910,-909,-908,-907,-906,-905,-904,-903,-902,-901,-900,-899,-898,-897,-896,-895,-894,-893,-892,-891,-890,-889,-888,-887,-886,-885,-884,-883,-882,-881,-880,-879,-878,-877,-876,-875,-874,-873,-872,-871,-870,-869,-868,-867,-866,-865,-864,-863,-862,-861,-860,-859,-858,-857,-856,-855,-854,-853,-852,-851,-850,-849,-848,-847,-846,-845,-844,-843,-842,-841,-840,-839,-838,-837,-836,-835,-834,-833,-832,-831,-830,-829,-828,-827,-826,-825,-824,-823,-822,-821,-820,-819,-818,-817,-816,-815,-814,-813,-812,-811,-810,-809,-808,-807,-806,-805,-804,-803,-802,-801,-800,-799,-798,-797,-796,-795,-794,-793,-792,-791,-790,-789,-788,-787,-786,-785,-784,-783,-782,-781,-780,-779,-778,-777,-776,-775,-774,-773,-772,-771,-770,-769,-768,-767,-766,-765,-764,-763,-762,-761,-760,-759,-758,-757,-756,-755,-754,-753,-752,-751,-750,-749,-748,-747,-746,-745,-744,-743,-742,-741,-740,-739,-738,-737,-736,-735,-734,-733,-732,-731,-730,-729,-728,-727,-726,-725,-724,-723,-722,-721,-720,-719,-718,-717,-716,-715,-714,-713,-712,-711,-710,-709,-708,-707,-706,-705,-704,-703,-702,-701,-700,-699,-698,-697,-696,-695,-694,-693,-692,-691,-690,-689,-688,-687,-686,-685,-684,-683,-682,-681,-680,-679,-678,-677,-676,-675,-674,-673,-672,-671,-670,-669,-668,-667,-666,-665,-664,-663,-662,-661,-660,-659,-658,-657,-656,-655,-654,-653,-652,-651,-650,-649,-648,-647,-646,-645,-644,-643,-642,-641,-640,-639,-638,-637,-636,-635,-634,-633,-632,-631,-630,-629,-628,-627,-626,-625,-624,-623,-622,-621,-620,-619,-618,-617,-616,-615,-614,-613,-612,-611,-610,-609,-608,-607,-606,-605,-604,-603,-602,-601,-600,-599,-598,-597,-596,-595,-594,-593,-592,-591,-590,-589,-588,-587,-586,-585,-584,-583,-582,-581,-580,-579,-578,-577,-576,-575,-574,-573,-572,-571,-570,-569,-568,-567,-566,-565,-564,-563,-562,-561,-560,-559,-558,-557,-556,-555,-554,-553,-552,-551,-550,-549,-548,-547,-546,-545,-544,-543,-542,-541,-540,-539,-538,-537,-536,-535,-534,-533,-532,-531,-530,-529,-528,-527,-526,-525,-524,-523,-522,-521,-520,-519,-518,-517,-516,-515,-514,-513,-512,-511,-510,-509,-508,-507,-506,-505,-504,-503,-502,-501,-500,-499,-498,-497,-496,-495,-494,-493,-492,-491,-490,-489,-488,-487,-486,-485,-484,-483,-482,-481,-480,-479,-478,-477,-476,-475,-474,-473,-472,-471,-470,-469,-468,-467,-466,-465,-464,-463,-462,-461,-460,-459,-458,-457,-456,-455,-454,-453,-452,-451,-450,-449,-448,-447,-446,-445,-444,-443,-442,-441,-440,-439,-438,-437,-436,-435,-434,-433,-432,-431,-430,-429,-428,-427,-426,-425,-424,-423,-422,-421,-420,-419,-418,-417,-416,-415,-414,-413,-412,-411,-410,-409,-408,-407,-406,-405,-404,-403,-402,-401,-400,-399,-398,-397,-396,-395,-394,-393,-392,-391,-390,-389,-388,-387,-386,-385,-384,-383,-382,-381,-380,-379,-378,-377,-376,-375,-374,-373,-372,-371,-370,-369,-368,-367,-366,-365,-364,-363,-362,-361,-360,-359,-358,-357,-356,-355,-354,-353,-352,-351,-350,-349,-348,-347,-346,-345,-344,-343,-342,-341,-340,-339,-338,-337,-336,-335,-334,-333,-332,-331,-330,-329,-328,-327,-326,-325,-324,-323,-322,-321,-320,-319,-318,-317,-316,-315,-314,-313,-312,-311,-310,-309,-308,-307,-306,-305,-304,-303,-302,-301,-300,-299,-298,-297,-296,-295,-294,-293,-292,-291,-290,-289,-288,-287,-286,-285,-284,-283,-282,-281,-280,-279,-278,-277,-276,-275,-274,-273,-272,-271,-270,-269,-268,-267,-266,-265,-264,-263,-262,-261,-260,-259,-258,-257,-256,-255,-254,-253,-252,-251,-250,-249,-248,-247,-246,-245,-244,-243,-242,-241,-240,-239,-238,-237,-236,-235,-234,-233,-232,-231,-230,-229,-228,-227,-226,-225,-224,-223,-222,-221,-220,-219,-218,-217,-216,-215,-214,-213,-212,-211,-210,-209,-208,-207,-206,-205,-204,-203,-202,-201,-200,-199,-198,-197,-196,-195,-194,-193,-192,-191,-190,-189,-188,-187,-186,-185,-184,-183,-182,-181,-180,-179,-178,-177,-176,-175,-174,-173,-172,-171,-170,-169,-168,-167,-166,-165,-164,-163,-162,-161,-160,-159,-158,-157,-156,-155,-154,-153,-152,-151,-150,-149,-148,-147,-146,-145,-144,-143,-142,-141,-140,-139,-138,-137,-136,-135,-134,-133,-132,-131,-130,-129,-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,-102,-101,-100,-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-73,-72,-71,-70,-69,-68,-67,-66,-65,-64,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000]\\n\\n"
                    },
                    {
                        "username": "harsh788",
                        "content": "[@Swapnil07072000](/Swapnil07072000) Thanks dude, this helped me. But I am not sure why it solved the problem..."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Faced the same error, solved it by sending reference to vectors and hashmap if used."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Time Limit Exceeded (in red colour) \nEdit: 77%,77% in C :)"
                    }
                ]
            },
            {
                "id": 1836447,
                "content": [
                    {
                        "username": "Archit_Srivastava",
                        "content": "Can anyone tell what\\'s wrong in this solution its passing 201/202 testcases .\\n\\n\\nclass Solution {\\n\\n\\npublic:\\nTreeNode *solve(vector<int>& inorder, vector<int>& postorder, map<int,int>mp, int &index, int start, int end, int n)\\n{\\n    if(index<0 || start>end )\\n    return NULL; \\n\\n    int ele=postorder[index--];\\n    TreeNode *root=new TreeNode(ele);\\n    int pos=mp[ele];\\n    //recursion\\n    root->right=solve(inorder,postorder,mp,index,pos+1,end,n);\\n    root->left=solve(inorder,postorder,mp,index,start,pos-1,n);\\n    \\n\\n    return root;\\n\\n}\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        \\n        int n=inorder.size();\\n        int postIdx=n-1;\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        mp[inorder[i]]=i;\\n\\n        TreeNode *ans=solve(inorder,postorder,mp,postIdx,0,n-1,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Putting left recusive call before right is givng wrong ans,, can anyone help\\n\\nint ind;\\n    unordered_map<int,int>mp; \\nTreeNode* build(vector<int> &inorder, vector<int> &postorder, int st, int end){\\n    if(st>end || ind<0)return NULL;\\n    TreeNode* root = new TreeNode(postorder[ind]);\\n    int pos = mp[postorder[ind]];\\n    ind--;\\n            // this is giving correct if i put right before left\\n    root->left = build(inorder,postorder,st,pos-1); \\n    root->right = build(inorder,postorder,pos+1, end);\\n    return root;\\n}\\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    ind = postorder.size()-1;\\n    for(int i = 0; i <= ind; i++)\\n        mp[inorder[i]] = i;\\n    TreeNode* root = build(inorder,postorder,0,inorder.size()-1);\\n    return root;\\n}\\n    "
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "If you get this in interview they don\\'t want to hire you\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Feeling really happy today. Solved this question in 9 minutes sitting with pen and paper when my boring professor delivered his lecture on some other subject lol."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Similar problem - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Tip:\\n\\nRecursive DFS has O(N^2) TC (~ beats 5-11%)\\nRecursive DFS with hashMap has O(N) TC (~beats 90%)\\n\\nHashmap that maps values -> indices (this is 1:1 since values are unique)\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "SOMEONE PLS HELP ME IM SO CLOSE TO THE SOLUTION I FEEL.\\nIm getting the following error, like why. what improvements should i do in my code\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 5\\n  at line 36, Solution.solve\\n  at line 25, Solution.buildTree\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n\\n```\\nclass Solution {\\n\\n        int postIndex;\\n        int inIndex=0;          //inorder index\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int inorderStart=0;\\n        int inorderEnd= inorder.length-1;\\n\\n        postIndex= postorder.length-1;\\n        return solve(inorder, postorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] inorder, int[] postorder, int inorderStart, int inorderEnd)\\n    {\\n        if(inorderStart>inorderEnd ) return null;\\n        TreeNode root= new TreeNode(postorder[postIndex--]);\\n        // postIndex--;\\n\\n        //locate root.val in the inorder array\\n        for(int i=inorderStart; i<= inorderEnd; i--)\\n        {\\n            if(inorder[i]== root.val)\\n                {\\n                    inIndex=i;\\n                    break;\\n                }\\n        }\\n\\n        root.left= solve(inorder, postorder, inorderStart, inIndex-1);\\n        root.right= solve(inorder, postorder, inIndex+1, inorderEnd);\\n\\n            return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&inorder,vector<int>&postorder,int si,int ei,int pi,int pe){\\n        \\n       if(si>ei or pi>pe){\\n           return NULL;\\n       }\\n     \\n\\n       \\n        //reursive case\\n        \\n        TreeNode* root=new TreeNode(postorder[pe]);\\n          pe--;\\n         int indx=-1;\\n        for(int i=si;i<=ei;i++){\\n           if(inorder[i]==postorder[pe]){\\n               indx=i;\\n           }\\n        }\\n        root->left=solve(inorder,postorder,si,indx-1,pi,pe);\\n        root->right=solve(inorder,postorder,indx+1,ei,pi,pe);\\n        return root;\\n\\n\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n       if(inorder.size()==0){\\n           return NULL;\\n       }\\n        int ei=inorder.size()-1;\\n        int pe=postorder.size()-1;\\n        return solve(inorder,postorder,0,ei,0,pe);\\n    }\\n};\\n\\n\\ncan someone tell mistake in my code"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "I got time limit exceeded for only following testcase and I used recursion to solve it. Can someone tell me where i possibly got wrong or any tips to optimize. \\n[-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910,-909,-908,-907,-906,-905,-904,-903,-902,-901,-900,-899,-898,-897,-896,-895,-894,-893,-892,-891,-890,-889,-888,-887,-886,-885,-884,-883,-882,-881,-880,-879,-878,-877,-876,-875,-874,-873,-872,-871,-870,-869,-868,-867,-866,-865,-864,-863,-862,-861,-860,-859,-858,-857,-856,-855,-854,-853,-852,-851,-850,-849,-848,-847,-846,-845,-844,-843,-842,-841,-840,-839,-838,-837,-836,-835,-834,-833,-832,-831,-830,-829,-828,-827,-826,-825,-824,-823,-822,-821,-820,-819,-818,-817,-816,-815,-814,-813,-812,-811,-810,-809,-808,-807,-806,-805,-804,-803,-802,-801,-800,-799,-798,-797,-796,-795,-794,-793,-792,-791,-790,-789,-788,-787,-786,-785,-784,-783,-782,-781,-780,-779,-778,-777,-776,-775,-774,-773,-772,-771,-770,-769,-768,-767,-766,-765,-764,-763,-762,-761,-760,-759,-758,-757,-756,-755,-754,-753,-752,-751,-750,-749,-748,-747,-746,-745,-744,-743,-742,-741,-740,-739,-738,-737,-736,-735,-734,-733,-732,-731,-730,-729,-728,-727,-726,-725,-724,-723,-722,-721,-720,-719,-718,-717,-716,-715,-714,-713,-712,-711,-710,-709,-708,-707,-706,-705,-704,-703,-702,-701,-700,-699,-698,-697,-696,-695,-694,-693,-692,-691,-690,-689,-688,-687,-686,-685,-684,-683,-682,-681,-680,-679,-678,-677,-676,-675,-674,-673,-672,-671,-670,-669,-668,-667,-666,-665,-664,-663,-662,-661,-660,-659,-658,-657,-656,-655,-654,-653,-652,-651,-650,-649,-648,-647,-646,-645,-644,-643,-642,-641,-640,-639,-638,-637,-636,-635,-634,-633,-632,-631,-630,-629,-628,-627,-626,-625,-624,-623,-622,-621,-620,-619,-618,-617,-616,-615,-614,-613,-612,-611,-610,-609,-608,-607,-606,-605,-604,-603,-602,-601,-600,-599,-598,-597,-596,-595,-594,-593,-592,-591,-590,-589,-588,-587,-586,-585,-584,-583,-582,-581,-580,-579,-578,-577,-576,-575,-574,-573,-572,-571,-570,-569,-568,-567,-566,-565,-564,-563,-562,-561,-560,-559,-558,-557,-556,-555,-554,-553,-552,-551,-550,-549,-548,-547,-546,-545,-544,-543,-542,-541,-540,-539,-538,-537,-536,-535,-534,-533,-532,-531,-530,-529,-528,-527,-526,-525,-524,-523,-522,-521,-520,-519,-518,-517,-516,-515,-514,-513,-512,-511,-510,-509,-508,-507,-506,-505,-504,-503,-502,-501,-500,-499,-498,-497,-496,-495,-494,-493,-492,-491,-490,-489,-488,-487,-486,-485,-484,-483,-482,-481,-480,-479,-478,-477,-476,-475,-474,-473,-472,-471,-470,-469,-468,-467,-466,-465,-464,-463,-462,-461,-460,-459,-458,-457,-456,-455,-454,-453,-452,-451,-450,-449,-448,-447,-446,-445,-444,-443,-442,-441,-440,-439,-438,-437,-436,-435,-434,-433,-432,-431,-430,-429,-428,-427,-426,-425,-424,-423,-422,-421,-420,-419,-418,-417,-416,-415,-414,-413,-412,-411,-410,-409,-408,-407,-406,-405,-404,-403,-402,-401,-400,-399,-398,-397,-396,-395,-394,-393,-392,-391,-390,-389,-388,-387,-386,-385,-384,-383,-382,-381,-380,-379,-378,-377,-376,-375,-374,-373,-372,-371,-370,-369,-368,-367,-366,-365,-364,-363,-362,-361,-360,-359,-358,-357,-356,-355,-354,-353,-352,-351,-350,-349,-348,-347,-346,-345,-344,-343,-342,-341,-340,-339,-338,-337,-336,-335,-334,-333,-332,-331,-330,-329,-328,-327,-326,-325,-324,-323,-322,-321,-320,-319,-318,-317,-316,-315,-314,-313,-312,-311,-310,-309,-308,-307,-306,-305,-304,-303,-302,-301,-300,-299,-298,-297,-296,-295,-294,-293,-292,-291,-290,-289,-288,-287,-286,-285,-284,-283,-282,-281,-280,-279,-278,-277,-276,-275,-274,-273,-272,-271,-270,-269,-268,-267,-266,-265,-264,-263,-262,-261,-260,-259,-258,-257,-256,-255,-254,-253,-252,-251,-250,-249,-248,-247,-246,-245,-244,-243,-242,-241,-240,-239,-238,-237,-236,-235,-234,-233,-232,-231,-230,-229,-228,-227,-226,-225,-224,-223,-222,-221,-220,-219,-218,-217,-216,-215,-214,-213,-212,-211,-210,-209,-208,-207,-206,-205,-204,-203,-202,-201,-200,-199,-198,-197,-196,-195,-194,-193,-192,-191,-190,-189,-188,-187,-186,-185,-184,-183,-182,-181,-180,-179,-178,-177,-176,-175,-174,-173,-172,-171,-170,-169,-168,-167,-166,-165,-164,-163,-162,-161,-160,-159,-158,-157,-156,-155,-154,-153,-152,-151,-150,-149,-148,-147,-146,-145,-144,-143,-142,-141,-140,-139,-138,-137,-136,-135,-134,-133,-132,-131,-130,-129,-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,-102,-101,-100,-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-73,-72,-71,-70,-69,-68,-67,-66,-65,-64,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000]\\n\\n"
                    },
                    {
                        "username": "harsh788",
                        "content": "[@Swapnil07072000](/Swapnil07072000) Thanks dude, this helped me. But I am not sure why it solved the problem..."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Faced the same error, solved it by sending reference to vectors and hashmap if used."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Time Limit Exceeded (in red colour) \nEdit: 77%,77% in C :)"
                    }
                ]
            },
            {
                "id": 1834522,
                "content": [
                    {
                        "username": "Archit_Srivastava",
                        "content": "Can anyone tell what\\'s wrong in this solution its passing 201/202 testcases .\\n\\n\\nclass Solution {\\n\\n\\npublic:\\nTreeNode *solve(vector<int>& inorder, vector<int>& postorder, map<int,int>mp, int &index, int start, int end, int n)\\n{\\n    if(index<0 || start>end )\\n    return NULL; \\n\\n    int ele=postorder[index--];\\n    TreeNode *root=new TreeNode(ele);\\n    int pos=mp[ele];\\n    //recursion\\n    root->right=solve(inorder,postorder,mp,index,pos+1,end,n);\\n    root->left=solve(inorder,postorder,mp,index,start,pos-1,n);\\n    \\n\\n    return root;\\n\\n}\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        \\n        int n=inorder.size();\\n        int postIdx=n-1;\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        mp[inorder[i]]=i;\\n\\n        TreeNode *ans=solve(inorder,postorder,mp,postIdx,0,n-1,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Putting left recusive call before right is givng wrong ans,, can anyone help\\n\\nint ind;\\n    unordered_map<int,int>mp; \\nTreeNode* build(vector<int> &inorder, vector<int> &postorder, int st, int end){\\n    if(st>end || ind<0)return NULL;\\n    TreeNode* root = new TreeNode(postorder[ind]);\\n    int pos = mp[postorder[ind]];\\n    ind--;\\n            // this is giving correct if i put right before left\\n    root->left = build(inorder,postorder,st,pos-1); \\n    root->right = build(inorder,postorder,pos+1, end);\\n    return root;\\n}\\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    ind = postorder.size()-1;\\n    for(int i = 0; i <= ind; i++)\\n        mp[inorder[i]] = i;\\n    TreeNode* root = build(inorder,postorder,0,inorder.size()-1);\\n    return root;\\n}\\n    "
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "If you get this in interview they don\\'t want to hire you\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Feeling really happy today. Solved this question in 9 minutes sitting with pen and paper when my boring professor delivered his lecture on some other subject lol."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Similar problem - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Tip:\\n\\nRecursive DFS has O(N^2) TC (~ beats 5-11%)\\nRecursive DFS with hashMap has O(N) TC (~beats 90%)\\n\\nHashmap that maps values -> indices (this is 1:1 since values are unique)\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "SOMEONE PLS HELP ME IM SO CLOSE TO THE SOLUTION I FEEL.\\nIm getting the following error, like why. what improvements should i do in my code\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 5\\n  at line 36, Solution.solve\\n  at line 25, Solution.buildTree\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n\\n```\\nclass Solution {\\n\\n        int postIndex;\\n        int inIndex=0;          //inorder index\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int inorderStart=0;\\n        int inorderEnd= inorder.length-1;\\n\\n        postIndex= postorder.length-1;\\n        return solve(inorder, postorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] inorder, int[] postorder, int inorderStart, int inorderEnd)\\n    {\\n        if(inorderStart>inorderEnd ) return null;\\n        TreeNode root= new TreeNode(postorder[postIndex--]);\\n        // postIndex--;\\n\\n        //locate root.val in the inorder array\\n        for(int i=inorderStart; i<= inorderEnd; i--)\\n        {\\n            if(inorder[i]== root.val)\\n                {\\n                    inIndex=i;\\n                    break;\\n                }\\n        }\\n\\n        root.left= solve(inorder, postorder, inorderStart, inIndex-1);\\n        root.right= solve(inorder, postorder, inIndex+1, inorderEnd);\\n\\n            return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&inorder,vector<int>&postorder,int si,int ei,int pi,int pe){\\n        \\n       if(si>ei or pi>pe){\\n           return NULL;\\n       }\\n     \\n\\n       \\n        //reursive case\\n        \\n        TreeNode* root=new TreeNode(postorder[pe]);\\n          pe--;\\n         int indx=-1;\\n        for(int i=si;i<=ei;i++){\\n           if(inorder[i]==postorder[pe]){\\n               indx=i;\\n           }\\n        }\\n        root->left=solve(inorder,postorder,si,indx-1,pi,pe);\\n        root->right=solve(inorder,postorder,indx+1,ei,pi,pe);\\n        return root;\\n\\n\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n       if(inorder.size()==0){\\n           return NULL;\\n       }\\n        int ei=inorder.size()-1;\\n        int pe=postorder.size()-1;\\n        return solve(inorder,postorder,0,ei,0,pe);\\n    }\\n};\\n\\n\\ncan someone tell mistake in my code"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "I got time limit exceeded for only following testcase and I used recursion to solve it. Can someone tell me where i possibly got wrong or any tips to optimize. \\n[-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910,-909,-908,-907,-906,-905,-904,-903,-902,-901,-900,-899,-898,-897,-896,-895,-894,-893,-892,-891,-890,-889,-888,-887,-886,-885,-884,-883,-882,-881,-880,-879,-878,-877,-876,-875,-874,-873,-872,-871,-870,-869,-868,-867,-866,-865,-864,-863,-862,-861,-860,-859,-858,-857,-856,-855,-854,-853,-852,-851,-850,-849,-848,-847,-846,-845,-844,-843,-842,-841,-840,-839,-838,-837,-836,-835,-834,-833,-832,-831,-830,-829,-828,-827,-826,-825,-824,-823,-822,-821,-820,-819,-818,-817,-816,-815,-814,-813,-812,-811,-810,-809,-808,-807,-806,-805,-804,-803,-802,-801,-800,-799,-798,-797,-796,-795,-794,-793,-792,-791,-790,-789,-788,-787,-786,-785,-784,-783,-782,-781,-780,-779,-778,-777,-776,-775,-774,-773,-772,-771,-770,-769,-768,-767,-766,-765,-764,-763,-762,-761,-760,-759,-758,-757,-756,-755,-754,-753,-752,-751,-750,-749,-748,-747,-746,-745,-744,-743,-742,-741,-740,-739,-738,-737,-736,-735,-734,-733,-732,-731,-730,-729,-728,-727,-726,-725,-724,-723,-722,-721,-720,-719,-718,-717,-716,-715,-714,-713,-712,-711,-710,-709,-708,-707,-706,-705,-704,-703,-702,-701,-700,-699,-698,-697,-696,-695,-694,-693,-692,-691,-690,-689,-688,-687,-686,-685,-684,-683,-682,-681,-680,-679,-678,-677,-676,-675,-674,-673,-672,-671,-670,-669,-668,-667,-666,-665,-664,-663,-662,-661,-660,-659,-658,-657,-656,-655,-654,-653,-652,-651,-650,-649,-648,-647,-646,-645,-644,-643,-642,-641,-640,-639,-638,-637,-636,-635,-634,-633,-632,-631,-630,-629,-628,-627,-626,-625,-624,-623,-622,-621,-620,-619,-618,-617,-616,-615,-614,-613,-612,-611,-610,-609,-608,-607,-606,-605,-604,-603,-602,-601,-600,-599,-598,-597,-596,-595,-594,-593,-592,-591,-590,-589,-588,-587,-586,-585,-584,-583,-582,-581,-580,-579,-578,-577,-576,-575,-574,-573,-572,-571,-570,-569,-568,-567,-566,-565,-564,-563,-562,-561,-560,-559,-558,-557,-556,-555,-554,-553,-552,-551,-550,-549,-548,-547,-546,-545,-544,-543,-542,-541,-540,-539,-538,-537,-536,-535,-534,-533,-532,-531,-530,-529,-528,-527,-526,-525,-524,-523,-522,-521,-520,-519,-518,-517,-516,-515,-514,-513,-512,-511,-510,-509,-508,-507,-506,-505,-504,-503,-502,-501,-500,-499,-498,-497,-496,-495,-494,-493,-492,-491,-490,-489,-488,-487,-486,-485,-484,-483,-482,-481,-480,-479,-478,-477,-476,-475,-474,-473,-472,-471,-470,-469,-468,-467,-466,-465,-464,-463,-462,-461,-460,-459,-458,-457,-456,-455,-454,-453,-452,-451,-450,-449,-448,-447,-446,-445,-444,-443,-442,-441,-440,-439,-438,-437,-436,-435,-434,-433,-432,-431,-430,-429,-428,-427,-426,-425,-424,-423,-422,-421,-420,-419,-418,-417,-416,-415,-414,-413,-412,-411,-410,-409,-408,-407,-406,-405,-404,-403,-402,-401,-400,-399,-398,-397,-396,-395,-394,-393,-392,-391,-390,-389,-388,-387,-386,-385,-384,-383,-382,-381,-380,-379,-378,-377,-376,-375,-374,-373,-372,-371,-370,-369,-368,-367,-366,-365,-364,-363,-362,-361,-360,-359,-358,-357,-356,-355,-354,-353,-352,-351,-350,-349,-348,-347,-346,-345,-344,-343,-342,-341,-340,-339,-338,-337,-336,-335,-334,-333,-332,-331,-330,-329,-328,-327,-326,-325,-324,-323,-322,-321,-320,-319,-318,-317,-316,-315,-314,-313,-312,-311,-310,-309,-308,-307,-306,-305,-304,-303,-302,-301,-300,-299,-298,-297,-296,-295,-294,-293,-292,-291,-290,-289,-288,-287,-286,-285,-284,-283,-282,-281,-280,-279,-278,-277,-276,-275,-274,-273,-272,-271,-270,-269,-268,-267,-266,-265,-264,-263,-262,-261,-260,-259,-258,-257,-256,-255,-254,-253,-252,-251,-250,-249,-248,-247,-246,-245,-244,-243,-242,-241,-240,-239,-238,-237,-236,-235,-234,-233,-232,-231,-230,-229,-228,-227,-226,-225,-224,-223,-222,-221,-220,-219,-218,-217,-216,-215,-214,-213,-212,-211,-210,-209,-208,-207,-206,-205,-204,-203,-202,-201,-200,-199,-198,-197,-196,-195,-194,-193,-192,-191,-190,-189,-188,-187,-186,-185,-184,-183,-182,-181,-180,-179,-178,-177,-176,-175,-174,-173,-172,-171,-170,-169,-168,-167,-166,-165,-164,-163,-162,-161,-160,-159,-158,-157,-156,-155,-154,-153,-152,-151,-150,-149,-148,-147,-146,-145,-144,-143,-142,-141,-140,-139,-138,-137,-136,-135,-134,-133,-132,-131,-130,-129,-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,-102,-101,-100,-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-73,-72,-71,-70,-69,-68,-67,-66,-65,-64,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000]\\n\\n"
                    },
                    {
                        "username": "harsh788",
                        "content": "[@Swapnil07072000](/Swapnil07072000) Thanks dude, this helped me. But I am not sure why it solved the problem..."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Faced the same error, solved it by sending reference to vectors and hashmap if used."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Time Limit Exceeded (in red colour) \nEdit: 77%,77% in C :)"
                    }
                ]
            },
            {
                "id": 1834450,
                "content": [
                    {
                        "username": "Archit_Srivastava",
                        "content": "Can anyone tell what\\'s wrong in this solution its passing 201/202 testcases .\\n\\n\\nclass Solution {\\n\\n\\npublic:\\nTreeNode *solve(vector<int>& inorder, vector<int>& postorder, map<int,int>mp, int &index, int start, int end, int n)\\n{\\n    if(index<0 || start>end )\\n    return NULL; \\n\\n    int ele=postorder[index--];\\n    TreeNode *root=new TreeNode(ele);\\n    int pos=mp[ele];\\n    //recursion\\n    root->right=solve(inorder,postorder,mp,index,pos+1,end,n);\\n    root->left=solve(inorder,postorder,mp,index,start,pos-1,n);\\n    \\n\\n    return root;\\n\\n}\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        \\n        int n=inorder.size();\\n        int postIdx=n-1;\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        mp[inorder[i]]=i;\\n\\n        TreeNode *ans=solve(inorder,postorder,mp,postIdx,0,n-1,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Putting left recusive call before right is givng wrong ans,, can anyone help\\n\\nint ind;\\n    unordered_map<int,int>mp; \\nTreeNode* build(vector<int> &inorder, vector<int> &postorder, int st, int end){\\n    if(st>end || ind<0)return NULL;\\n    TreeNode* root = new TreeNode(postorder[ind]);\\n    int pos = mp[postorder[ind]];\\n    ind--;\\n            // this is giving correct if i put right before left\\n    root->left = build(inorder,postorder,st,pos-1); \\n    root->right = build(inorder,postorder,pos+1, end);\\n    return root;\\n}\\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    ind = postorder.size()-1;\\n    for(int i = 0; i <= ind; i++)\\n        mp[inorder[i]] = i;\\n    TreeNode* root = build(inorder,postorder,0,inorder.size()-1);\\n    return root;\\n}\\n    "
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "If you get this in interview they don\\'t want to hire you\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Feeling really happy today. Solved this question in 9 minutes sitting with pen and paper when my boring professor delivered his lecture on some other subject lol."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Similar problem - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Tip:\\n\\nRecursive DFS has O(N^2) TC (~ beats 5-11%)\\nRecursive DFS with hashMap has O(N) TC (~beats 90%)\\n\\nHashmap that maps values -> indices (this is 1:1 since values are unique)\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "SOMEONE PLS HELP ME IM SO CLOSE TO THE SOLUTION I FEEL.\\nIm getting the following error, like why. what improvements should i do in my code\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 5\\n  at line 36, Solution.solve\\n  at line 25, Solution.buildTree\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n\\n```\\nclass Solution {\\n\\n        int postIndex;\\n        int inIndex=0;          //inorder index\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int inorderStart=0;\\n        int inorderEnd= inorder.length-1;\\n\\n        postIndex= postorder.length-1;\\n        return solve(inorder, postorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] inorder, int[] postorder, int inorderStart, int inorderEnd)\\n    {\\n        if(inorderStart>inorderEnd ) return null;\\n        TreeNode root= new TreeNode(postorder[postIndex--]);\\n        // postIndex--;\\n\\n        //locate root.val in the inorder array\\n        for(int i=inorderStart; i<= inorderEnd; i--)\\n        {\\n            if(inorder[i]== root.val)\\n                {\\n                    inIndex=i;\\n                    break;\\n                }\\n        }\\n\\n        root.left= solve(inorder, postorder, inorderStart, inIndex-1);\\n        root.right= solve(inorder, postorder, inIndex+1, inorderEnd);\\n\\n            return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&inorder,vector<int>&postorder,int si,int ei,int pi,int pe){\\n        \\n       if(si>ei or pi>pe){\\n           return NULL;\\n       }\\n     \\n\\n       \\n        //reursive case\\n        \\n        TreeNode* root=new TreeNode(postorder[pe]);\\n          pe--;\\n         int indx=-1;\\n        for(int i=si;i<=ei;i++){\\n           if(inorder[i]==postorder[pe]){\\n               indx=i;\\n           }\\n        }\\n        root->left=solve(inorder,postorder,si,indx-1,pi,pe);\\n        root->right=solve(inorder,postorder,indx+1,ei,pi,pe);\\n        return root;\\n\\n\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n       if(inorder.size()==0){\\n           return NULL;\\n       }\\n        int ei=inorder.size()-1;\\n        int pe=postorder.size()-1;\\n        return solve(inorder,postorder,0,ei,0,pe);\\n    }\\n};\\n\\n\\ncan someone tell mistake in my code"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "I got time limit exceeded for only following testcase and I used recursion to solve it. Can someone tell me where i possibly got wrong or any tips to optimize. \\n[-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910,-909,-908,-907,-906,-905,-904,-903,-902,-901,-900,-899,-898,-897,-896,-895,-894,-893,-892,-891,-890,-889,-888,-887,-886,-885,-884,-883,-882,-881,-880,-879,-878,-877,-876,-875,-874,-873,-872,-871,-870,-869,-868,-867,-866,-865,-864,-863,-862,-861,-860,-859,-858,-857,-856,-855,-854,-853,-852,-851,-850,-849,-848,-847,-846,-845,-844,-843,-842,-841,-840,-839,-838,-837,-836,-835,-834,-833,-832,-831,-830,-829,-828,-827,-826,-825,-824,-823,-822,-821,-820,-819,-818,-817,-816,-815,-814,-813,-812,-811,-810,-809,-808,-807,-806,-805,-804,-803,-802,-801,-800,-799,-798,-797,-796,-795,-794,-793,-792,-791,-790,-789,-788,-787,-786,-785,-784,-783,-782,-781,-780,-779,-778,-777,-776,-775,-774,-773,-772,-771,-770,-769,-768,-767,-766,-765,-764,-763,-762,-761,-760,-759,-758,-757,-756,-755,-754,-753,-752,-751,-750,-749,-748,-747,-746,-745,-744,-743,-742,-741,-740,-739,-738,-737,-736,-735,-734,-733,-732,-731,-730,-729,-728,-727,-726,-725,-724,-723,-722,-721,-720,-719,-718,-717,-716,-715,-714,-713,-712,-711,-710,-709,-708,-707,-706,-705,-704,-703,-702,-701,-700,-699,-698,-697,-696,-695,-694,-693,-692,-691,-690,-689,-688,-687,-686,-685,-684,-683,-682,-681,-680,-679,-678,-677,-676,-675,-674,-673,-672,-671,-670,-669,-668,-667,-666,-665,-664,-663,-662,-661,-660,-659,-658,-657,-656,-655,-654,-653,-652,-651,-650,-649,-648,-647,-646,-645,-644,-643,-642,-641,-640,-639,-638,-637,-636,-635,-634,-633,-632,-631,-630,-629,-628,-627,-626,-625,-624,-623,-622,-621,-620,-619,-618,-617,-616,-615,-614,-613,-612,-611,-610,-609,-608,-607,-606,-605,-604,-603,-602,-601,-600,-599,-598,-597,-596,-595,-594,-593,-592,-591,-590,-589,-588,-587,-586,-585,-584,-583,-582,-581,-580,-579,-578,-577,-576,-575,-574,-573,-572,-571,-570,-569,-568,-567,-566,-565,-564,-563,-562,-561,-560,-559,-558,-557,-556,-555,-554,-553,-552,-551,-550,-549,-548,-547,-546,-545,-544,-543,-542,-541,-540,-539,-538,-537,-536,-535,-534,-533,-532,-531,-530,-529,-528,-527,-526,-525,-524,-523,-522,-521,-520,-519,-518,-517,-516,-515,-514,-513,-512,-511,-510,-509,-508,-507,-506,-505,-504,-503,-502,-501,-500,-499,-498,-497,-496,-495,-494,-493,-492,-491,-490,-489,-488,-487,-486,-485,-484,-483,-482,-481,-480,-479,-478,-477,-476,-475,-474,-473,-472,-471,-470,-469,-468,-467,-466,-465,-464,-463,-462,-461,-460,-459,-458,-457,-456,-455,-454,-453,-452,-451,-450,-449,-448,-447,-446,-445,-444,-443,-442,-441,-440,-439,-438,-437,-436,-435,-434,-433,-432,-431,-430,-429,-428,-427,-426,-425,-424,-423,-422,-421,-420,-419,-418,-417,-416,-415,-414,-413,-412,-411,-410,-409,-408,-407,-406,-405,-404,-403,-402,-401,-400,-399,-398,-397,-396,-395,-394,-393,-392,-391,-390,-389,-388,-387,-386,-385,-384,-383,-382,-381,-380,-379,-378,-377,-376,-375,-374,-373,-372,-371,-370,-369,-368,-367,-366,-365,-364,-363,-362,-361,-360,-359,-358,-357,-356,-355,-354,-353,-352,-351,-350,-349,-348,-347,-346,-345,-344,-343,-342,-341,-340,-339,-338,-337,-336,-335,-334,-333,-332,-331,-330,-329,-328,-327,-326,-325,-324,-323,-322,-321,-320,-319,-318,-317,-316,-315,-314,-313,-312,-311,-310,-309,-308,-307,-306,-305,-304,-303,-302,-301,-300,-299,-298,-297,-296,-295,-294,-293,-292,-291,-290,-289,-288,-287,-286,-285,-284,-283,-282,-281,-280,-279,-278,-277,-276,-275,-274,-273,-272,-271,-270,-269,-268,-267,-266,-265,-264,-263,-262,-261,-260,-259,-258,-257,-256,-255,-254,-253,-252,-251,-250,-249,-248,-247,-246,-245,-244,-243,-242,-241,-240,-239,-238,-237,-236,-235,-234,-233,-232,-231,-230,-229,-228,-227,-226,-225,-224,-223,-222,-221,-220,-219,-218,-217,-216,-215,-214,-213,-212,-211,-210,-209,-208,-207,-206,-205,-204,-203,-202,-201,-200,-199,-198,-197,-196,-195,-194,-193,-192,-191,-190,-189,-188,-187,-186,-185,-184,-183,-182,-181,-180,-179,-178,-177,-176,-175,-174,-173,-172,-171,-170,-169,-168,-167,-166,-165,-164,-163,-162,-161,-160,-159,-158,-157,-156,-155,-154,-153,-152,-151,-150,-149,-148,-147,-146,-145,-144,-143,-142,-141,-140,-139,-138,-137,-136,-135,-134,-133,-132,-131,-130,-129,-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,-102,-101,-100,-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-73,-72,-71,-70,-69,-68,-67,-66,-65,-64,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000]\\n\\n"
                    },
                    {
                        "username": "harsh788",
                        "content": "[@Swapnil07072000](/Swapnil07072000) Thanks dude, this helped me. But I am not sure why it solved the problem..."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Faced the same error, solved it by sending reference to vectors and hashmap if used."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Time Limit Exceeded (in red colour) \nEdit: 77%,77% in C :)"
                    }
                ]
            },
            {
                "id": 1834395,
                "content": [
                    {
                        "username": "Archit_Srivastava",
                        "content": "Can anyone tell what\\'s wrong in this solution its passing 201/202 testcases .\\n\\n\\nclass Solution {\\n\\n\\npublic:\\nTreeNode *solve(vector<int>& inorder, vector<int>& postorder, map<int,int>mp, int &index, int start, int end, int n)\\n{\\n    if(index<0 || start>end )\\n    return NULL; \\n\\n    int ele=postorder[index--];\\n    TreeNode *root=new TreeNode(ele);\\n    int pos=mp[ele];\\n    //recursion\\n    root->right=solve(inorder,postorder,mp,index,pos+1,end,n);\\n    root->left=solve(inorder,postorder,mp,index,start,pos-1,n);\\n    \\n\\n    return root;\\n\\n}\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        \\n        int n=inorder.size();\\n        int postIdx=n-1;\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        mp[inorder[i]]=i;\\n\\n        TreeNode *ans=solve(inorder,postorder,mp,postIdx,0,n-1,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Putting left recusive call before right is givng wrong ans,, can anyone help\\n\\nint ind;\\n    unordered_map<int,int>mp; \\nTreeNode* build(vector<int> &inorder, vector<int> &postorder, int st, int end){\\n    if(st>end || ind<0)return NULL;\\n    TreeNode* root = new TreeNode(postorder[ind]);\\n    int pos = mp[postorder[ind]];\\n    ind--;\\n            // this is giving correct if i put right before left\\n    root->left = build(inorder,postorder,st,pos-1); \\n    root->right = build(inorder,postorder,pos+1, end);\\n    return root;\\n}\\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    ind = postorder.size()-1;\\n    for(int i = 0; i <= ind; i++)\\n        mp[inorder[i]] = i;\\n    TreeNode* root = build(inorder,postorder,0,inorder.size()-1);\\n    return root;\\n}\\n    "
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "If you get this in interview they don\\'t want to hire you\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Feeling really happy today. Solved this question in 9 minutes sitting with pen and paper when my boring professor delivered his lecture on some other subject lol."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Similar problem - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Tip:\\n\\nRecursive DFS has O(N^2) TC (~ beats 5-11%)\\nRecursive DFS with hashMap has O(N) TC (~beats 90%)\\n\\nHashmap that maps values -> indices (this is 1:1 since values are unique)\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "SOMEONE PLS HELP ME IM SO CLOSE TO THE SOLUTION I FEEL.\\nIm getting the following error, like why. what improvements should i do in my code\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 5\\n  at line 36, Solution.solve\\n  at line 25, Solution.buildTree\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n\\n```\\nclass Solution {\\n\\n        int postIndex;\\n        int inIndex=0;          //inorder index\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int inorderStart=0;\\n        int inorderEnd= inorder.length-1;\\n\\n        postIndex= postorder.length-1;\\n        return solve(inorder, postorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] inorder, int[] postorder, int inorderStart, int inorderEnd)\\n    {\\n        if(inorderStart>inorderEnd ) return null;\\n        TreeNode root= new TreeNode(postorder[postIndex--]);\\n        // postIndex--;\\n\\n        //locate root.val in the inorder array\\n        for(int i=inorderStart; i<= inorderEnd; i--)\\n        {\\n            if(inorder[i]== root.val)\\n                {\\n                    inIndex=i;\\n                    break;\\n                }\\n        }\\n\\n        root.left= solve(inorder, postorder, inorderStart, inIndex-1);\\n        root.right= solve(inorder, postorder, inIndex+1, inorderEnd);\\n\\n            return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&inorder,vector<int>&postorder,int si,int ei,int pi,int pe){\\n        \\n       if(si>ei or pi>pe){\\n           return NULL;\\n       }\\n     \\n\\n       \\n        //reursive case\\n        \\n        TreeNode* root=new TreeNode(postorder[pe]);\\n          pe--;\\n         int indx=-1;\\n        for(int i=si;i<=ei;i++){\\n           if(inorder[i]==postorder[pe]){\\n               indx=i;\\n           }\\n        }\\n        root->left=solve(inorder,postorder,si,indx-1,pi,pe);\\n        root->right=solve(inorder,postorder,indx+1,ei,pi,pe);\\n        return root;\\n\\n\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n       if(inorder.size()==0){\\n           return NULL;\\n       }\\n        int ei=inorder.size()-1;\\n        int pe=postorder.size()-1;\\n        return solve(inorder,postorder,0,ei,0,pe);\\n    }\\n};\\n\\n\\ncan someone tell mistake in my code"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "I got time limit exceeded for only following testcase and I used recursion to solve it. Can someone tell me where i possibly got wrong or any tips to optimize. \\n[-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910,-909,-908,-907,-906,-905,-904,-903,-902,-901,-900,-899,-898,-897,-896,-895,-894,-893,-892,-891,-890,-889,-888,-887,-886,-885,-884,-883,-882,-881,-880,-879,-878,-877,-876,-875,-874,-873,-872,-871,-870,-869,-868,-867,-866,-865,-864,-863,-862,-861,-860,-859,-858,-857,-856,-855,-854,-853,-852,-851,-850,-849,-848,-847,-846,-845,-844,-843,-842,-841,-840,-839,-838,-837,-836,-835,-834,-833,-832,-831,-830,-829,-828,-827,-826,-825,-824,-823,-822,-821,-820,-819,-818,-817,-816,-815,-814,-813,-812,-811,-810,-809,-808,-807,-806,-805,-804,-803,-802,-801,-800,-799,-798,-797,-796,-795,-794,-793,-792,-791,-790,-789,-788,-787,-786,-785,-784,-783,-782,-781,-780,-779,-778,-777,-776,-775,-774,-773,-772,-771,-770,-769,-768,-767,-766,-765,-764,-763,-762,-761,-760,-759,-758,-757,-756,-755,-754,-753,-752,-751,-750,-749,-748,-747,-746,-745,-744,-743,-742,-741,-740,-739,-738,-737,-736,-735,-734,-733,-732,-731,-730,-729,-728,-727,-726,-725,-724,-723,-722,-721,-720,-719,-718,-717,-716,-715,-714,-713,-712,-711,-710,-709,-708,-707,-706,-705,-704,-703,-702,-701,-700,-699,-698,-697,-696,-695,-694,-693,-692,-691,-690,-689,-688,-687,-686,-685,-684,-683,-682,-681,-680,-679,-678,-677,-676,-675,-674,-673,-672,-671,-670,-669,-668,-667,-666,-665,-664,-663,-662,-661,-660,-659,-658,-657,-656,-655,-654,-653,-652,-651,-650,-649,-648,-647,-646,-645,-644,-643,-642,-641,-640,-639,-638,-637,-636,-635,-634,-633,-632,-631,-630,-629,-628,-627,-626,-625,-624,-623,-622,-621,-620,-619,-618,-617,-616,-615,-614,-613,-612,-611,-610,-609,-608,-607,-606,-605,-604,-603,-602,-601,-600,-599,-598,-597,-596,-595,-594,-593,-592,-591,-590,-589,-588,-587,-586,-585,-584,-583,-582,-581,-580,-579,-578,-577,-576,-575,-574,-573,-572,-571,-570,-569,-568,-567,-566,-565,-564,-563,-562,-561,-560,-559,-558,-557,-556,-555,-554,-553,-552,-551,-550,-549,-548,-547,-546,-545,-544,-543,-542,-541,-540,-539,-538,-537,-536,-535,-534,-533,-532,-531,-530,-529,-528,-527,-526,-525,-524,-523,-522,-521,-520,-519,-518,-517,-516,-515,-514,-513,-512,-511,-510,-509,-508,-507,-506,-505,-504,-503,-502,-501,-500,-499,-498,-497,-496,-495,-494,-493,-492,-491,-490,-489,-488,-487,-486,-485,-484,-483,-482,-481,-480,-479,-478,-477,-476,-475,-474,-473,-472,-471,-470,-469,-468,-467,-466,-465,-464,-463,-462,-461,-460,-459,-458,-457,-456,-455,-454,-453,-452,-451,-450,-449,-448,-447,-446,-445,-444,-443,-442,-441,-440,-439,-438,-437,-436,-435,-434,-433,-432,-431,-430,-429,-428,-427,-426,-425,-424,-423,-422,-421,-420,-419,-418,-417,-416,-415,-414,-413,-412,-411,-410,-409,-408,-407,-406,-405,-404,-403,-402,-401,-400,-399,-398,-397,-396,-395,-394,-393,-392,-391,-390,-389,-388,-387,-386,-385,-384,-383,-382,-381,-380,-379,-378,-377,-376,-375,-374,-373,-372,-371,-370,-369,-368,-367,-366,-365,-364,-363,-362,-361,-360,-359,-358,-357,-356,-355,-354,-353,-352,-351,-350,-349,-348,-347,-346,-345,-344,-343,-342,-341,-340,-339,-338,-337,-336,-335,-334,-333,-332,-331,-330,-329,-328,-327,-326,-325,-324,-323,-322,-321,-320,-319,-318,-317,-316,-315,-314,-313,-312,-311,-310,-309,-308,-307,-306,-305,-304,-303,-302,-301,-300,-299,-298,-297,-296,-295,-294,-293,-292,-291,-290,-289,-288,-287,-286,-285,-284,-283,-282,-281,-280,-279,-278,-277,-276,-275,-274,-273,-272,-271,-270,-269,-268,-267,-266,-265,-264,-263,-262,-261,-260,-259,-258,-257,-256,-255,-254,-253,-252,-251,-250,-249,-248,-247,-246,-245,-244,-243,-242,-241,-240,-239,-238,-237,-236,-235,-234,-233,-232,-231,-230,-229,-228,-227,-226,-225,-224,-223,-222,-221,-220,-219,-218,-217,-216,-215,-214,-213,-212,-211,-210,-209,-208,-207,-206,-205,-204,-203,-202,-201,-200,-199,-198,-197,-196,-195,-194,-193,-192,-191,-190,-189,-188,-187,-186,-185,-184,-183,-182,-181,-180,-179,-178,-177,-176,-175,-174,-173,-172,-171,-170,-169,-168,-167,-166,-165,-164,-163,-162,-161,-160,-159,-158,-157,-156,-155,-154,-153,-152,-151,-150,-149,-148,-147,-146,-145,-144,-143,-142,-141,-140,-139,-138,-137,-136,-135,-134,-133,-132,-131,-130,-129,-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,-102,-101,-100,-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-73,-72,-71,-70,-69,-68,-67,-66,-65,-64,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000]\\n\\n"
                    },
                    {
                        "username": "harsh788",
                        "content": "[@Swapnil07072000](/Swapnil07072000) Thanks dude, this helped me. But I am not sure why it solved the problem..."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Faced the same error, solved it by sending reference to vectors and hashmap if used."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Time Limit Exceeded (in red colour) \nEdit: 77%,77% in C :)"
                    }
                ]
            },
            {
                "id": 1834375,
                "content": [
                    {
                        "username": "Archit_Srivastava",
                        "content": "Can anyone tell what\\'s wrong in this solution its passing 201/202 testcases .\\n\\n\\nclass Solution {\\n\\n\\npublic:\\nTreeNode *solve(vector<int>& inorder, vector<int>& postorder, map<int,int>mp, int &index, int start, int end, int n)\\n{\\n    if(index<0 || start>end )\\n    return NULL; \\n\\n    int ele=postorder[index--];\\n    TreeNode *root=new TreeNode(ele);\\n    int pos=mp[ele];\\n    //recursion\\n    root->right=solve(inorder,postorder,mp,index,pos+1,end,n);\\n    root->left=solve(inorder,postorder,mp,index,start,pos-1,n);\\n    \\n\\n    return root;\\n\\n}\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        \\n        int n=inorder.size();\\n        int postIdx=n-1;\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        mp[inorder[i]]=i;\\n\\n        TreeNode *ans=solve(inorder,postorder,mp,postIdx,0,n-1,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Putting left recusive call before right is givng wrong ans,, can anyone help\\n\\nint ind;\\n    unordered_map<int,int>mp; \\nTreeNode* build(vector<int> &inorder, vector<int> &postorder, int st, int end){\\n    if(st>end || ind<0)return NULL;\\n    TreeNode* root = new TreeNode(postorder[ind]);\\n    int pos = mp[postorder[ind]];\\n    ind--;\\n            // this is giving correct if i put right before left\\n    root->left = build(inorder,postorder,st,pos-1); \\n    root->right = build(inorder,postorder,pos+1, end);\\n    return root;\\n}\\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    ind = postorder.size()-1;\\n    for(int i = 0; i <= ind; i++)\\n        mp[inorder[i]] = i;\\n    TreeNode* root = build(inorder,postorder,0,inorder.size()-1);\\n    return root;\\n}\\n    "
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "If you get this in interview they don\\'t want to hire you\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Feeling really happy today. Solved this question in 9 minutes sitting with pen and paper when my boring professor delivered his lecture on some other subject lol."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Similar problem - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Tip:\\n\\nRecursive DFS has O(N^2) TC (~ beats 5-11%)\\nRecursive DFS with hashMap has O(N) TC (~beats 90%)\\n\\nHashmap that maps values -> indices (this is 1:1 since values are unique)\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "SOMEONE PLS HELP ME IM SO CLOSE TO THE SOLUTION I FEEL.\\nIm getting the following error, like why. what improvements should i do in my code\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 5\\n  at line 36, Solution.solve\\n  at line 25, Solution.buildTree\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n\\n```\\nclass Solution {\\n\\n        int postIndex;\\n        int inIndex=0;          //inorder index\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int inorderStart=0;\\n        int inorderEnd= inorder.length-1;\\n\\n        postIndex= postorder.length-1;\\n        return solve(inorder, postorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] inorder, int[] postorder, int inorderStart, int inorderEnd)\\n    {\\n        if(inorderStart>inorderEnd ) return null;\\n        TreeNode root= new TreeNode(postorder[postIndex--]);\\n        // postIndex--;\\n\\n        //locate root.val in the inorder array\\n        for(int i=inorderStart; i<= inorderEnd; i--)\\n        {\\n            if(inorder[i]== root.val)\\n                {\\n                    inIndex=i;\\n                    break;\\n                }\\n        }\\n\\n        root.left= solve(inorder, postorder, inorderStart, inIndex-1);\\n        root.right= solve(inorder, postorder, inIndex+1, inorderEnd);\\n\\n            return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&inorder,vector<int>&postorder,int si,int ei,int pi,int pe){\\n        \\n       if(si>ei or pi>pe){\\n           return NULL;\\n       }\\n     \\n\\n       \\n        //reursive case\\n        \\n        TreeNode* root=new TreeNode(postorder[pe]);\\n          pe--;\\n         int indx=-1;\\n        for(int i=si;i<=ei;i++){\\n           if(inorder[i]==postorder[pe]){\\n               indx=i;\\n           }\\n        }\\n        root->left=solve(inorder,postorder,si,indx-1,pi,pe);\\n        root->right=solve(inorder,postorder,indx+1,ei,pi,pe);\\n        return root;\\n\\n\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n       if(inorder.size()==0){\\n           return NULL;\\n       }\\n        int ei=inorder.size()-1;\\n        int pe=postorder.size()-1;\\n        return solve(inorder,postorder,0,ei,0,pe);\\n    }\\n};\\n\\n\\ncan someone tell mistake in my code"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "I got time limit exceeded for only following testcase and I used recursion to solve it. Can someone tell me where i possibly got wrong or any tips to optimize. \\n[-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910,-909,-908,-907,-906,-905,-904,-903,-902,-901,-900,-899,-898,-897,-896,-895,-894,-893,-892,-891,-890,-889,-888,-887,-886,-885,-884,-883,-882,-881,-880,-879,-878,-877,-876,-875,-874,-873,-872,-871,-870,-869,-868,-867,-866,-865,-864,-863,-862,-861,-860,-859,-858,-857,-856,-855,-854,-853,-852,-851,-850,-849,-848,-847,-846,-845,-844,-843,-842,-841,-840,-839,-838,-837,-836,-835,-834,-833,-832,-831,-830,-829,-828,-827,-826,-825,-824,-823,-822,-821,-820,-819,-818,-817,-816,-815,-814,-813,-812,-811,-810,-809,-808,-807,-806,-805,-804,-803,-802,-801,-800,-799,-798,-797,-796,-795,-794,-793,-792,-791,-790,-789,-788,-787,-786,-785,-784,-783,-782,-781,-780,-779,-778,-777,-776,-775,-774,-773,-772,-771,-770,-769,-768,-767,-766,-765,-764,-763,-762,-761,-760,-759,-758,-757,-756,-755,-754,-753,-752,-751,-750,-749,-748,-747,-746,-745,-744,-743,-742,-741,-740,-739,-738,-737,-736,-735,-734,-733,-732,-731,-730,-729,-728,-727,-726,-725,-724,-723,-722,-721,-720,-719,-718,-717,-716,-715,-714,-713,-712,-711,-710,-709,-708,-707,-706,-705,-704,-703,-702,-701,-700,-699,-698,-697,-696,-695,-694,-693,-692,-691,-690,-689,-688,-687,-686,-685,-684,-683,-682,-681,-680,-679,-678,-677,-676,-675,-674,-673,-672,-671,-670,-669,-668,-667,-666,-665,-664,-663,-662,-661,-660,-659,-658,-657,-656,-655,-654,-653,-652,-651,-650,-649,-648,-647,-646,-645,-644,-643,-642,-641,-640,-639,-638,-637,-636,-635,-634,-633,-632,-631,-630,-629,-628,-627,-626,-625,-624,-623,-622,-621,-620,-619,-618,-617,-616,-615,-614,-613,-612,-611,-610,-609,-608,-607,-606,-605,-604,-603,-602,-601,-600,-599,-598,-597,-596,-595,-594,-593,-592,-591,-590,-589,-588,-587,-586,-585,-584,-583,-582,-581,-580,-579,-578,-577,-576,-575,-574,-573,-572,-571,-570,-569,-568,-567,-566,-565,-564,-563,-562,-561,-560,-559,-558,-557,-556,-555,-554,-553,-552,-551,-550,-549,-548,-547,-546,-545,-544,-543,-542,-541,-540,-539,-538,-537,-536,-535,-534,-533,-532,-531,-530,-529,-528,-527,-526,-525,-524,-523,-522,-521,-520,-519,-518,-517,-516,-515,-514,-513,-512,-511,-510,-509,-508,-507,-506,-505,-504,-503,-502,-501,-500,-499,-498,-497,-496,-495,-494,-493,-492,-491,-490,-489,-488,-487,-486,-485,-484,-483,-482,-481,-480,-479,-478,-477,-476,-475,-474,-473,-472,-471,-470,-469,-468,-467,-466,-465,-464,-463,-462,-461,-460,-459,-458,-457,-456,-455,-454,-453,-452,-451,-450,-449,-448,-447,-446,-445,-444,-443,-442,-441,-440,-439,-438,-437,-436,-435,-434,-433,-432,-431,-430,-429,-428,-427,-426,-425,-424,-423,-422,-421,-420,-419,-418,-417,-416,-415,-414,-413,-412,-411,-410,-409,-408,-407,-406,-405,-404,-403,-402,-401,-400,-399,-398,-397,-396,-395,-394,-393,-392,-391,-390,-389,-388,-387,-386,-385,-384,-383,-382,-381,-380,-379,-378,-377,-376,-375,-374,-373,-372,-371,-370,-369,-368,-367,-366,-365,-364,-363,-362,-361,-360,-359,-358,-357,-356,-355,-354,-353,-352,-351,-350,-349,-348,-347,-346,-345,-344,-343,-342,-341,-340,-339,-338,-337,-336,-335,-334,-333,-332,-331,-330,-329,-328,-327,-326,-325,-324,-323,-322,-321,-320,-319,-318,-317,-316,-315,-314,-313,-312,-311,-310,-309,-308,-307,-306,-305,-304,-303,-302,-301,-300,-299,-298,-297,-296,-295,-294,-293,-292,-291,-290,-289,-288,-287,-286,-285,-284,-283,-282,-281,-280,-279,-278,-277,-276,-275,-274,-273,-272,-271,-270,-269,-268,-267,-266,-265,-264,-263,-262,-261,-260,-259,-258,-257,-256,-255,-254,-253,-252,-251,-250,-249,-248,-247,-246,-245,-244,-243,-242,-241,-240,-239,-238,-237,-236,-235,-234,-233,-232,-231,-230,-229,-228,-227,-226,-225,-224,-223,-222,-221,-220,-219,-218,-217,-216,-215,-214,-213,-212,-211,-210,-209,-208,-207,-206,-205,-204,-203,-202,-201,-200,-199,-198,-197,-196,-195,-194,-193,-192,-191,-190,-189,-188,-187,-186,-185,-184,-183,-182,-181,-180,-179,-178,-177,-176,-175,-174,-173,-172,-171,-170,-169,-168,-167,-166,-165,-164,-163,-162,-161,-160,-159,-158,-157,-156,-155,-154,-153,-152,-151,-150,-149,-148,-147,-146,-145,-144,-143,-142,-141,-140,-139,-138,-137,-136,-135,-134,-133,-132,-131,-130,-129,-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,-102,-101,-100,-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-73,-72,-71,-70,-69,-68,-67,-66,-65,-64,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000]\\n\\n"
                    },
                    {
                        "username": "harsh788",
                        "content": "[@Swapnil07072000](/Swapnil07072000) Thanks dude, this helped me. But I am not sure why it solved the problem..."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Faced the same error, solved it by sending reference to vectors and hashmap if used."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Time Limit Exceeded (in red colour) \nEdit: 77%,77% in C :)"
                    }
                ]
            },
            {
                "id": 1834219,
                "content": [
                    {
                        "username": "Archit_Srivastava",
                        "content": "Can anyone tell what\\'s wrong in this solution its passing 201/202 testcases .\\n\\n\\nclass Solution {\\n\\n\\npublic:\\nTreeNode *solve(vector<int>& inorder, vector<int>& postorder, map<int,int>mp, int &index, int start, int end, int n)\\n{\\n    if(index<0 || start>end )\\n    return NULL; \\n\\n    int ele=postorder[index--];\\n    TreeNode *root=new TreeNode(ele);\\n    int pos=mp[ele];\\n    //recursion\\n    root->right=solve(inorder,postorder,mp,index,pos+1,end,n);\\n    root->left=solve(inorder,postorder,mp,index,start,pos-1,n);\\n    \\n\\n    return root;\\n\\n}\\n\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        \\n        int n=inorder.size();\\n        int postIdx=n-1;\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        mp[inorder[i]]=i;\\n\\n        TreeNode *ans=solve(inorder,postorder,mp,postIdx,0,n-1,n);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Putting left recusive call before right is givng wrong ans,, can anyone help\\n\\nint ind;\\n    unordered_map<int,int>mp; \\nTreeNode* build(vector<int> &inorder, vector<int> &postorder, int st, int end){\\n    if(st>end || ind<0)return NULL;\\n    TreeNode* root = new TreeNode(postorder[ind]);\\n    int pos = mp[postorder[ind]];\\n    ind--;\\n            // this is giving correct if i put right before left\\n    root->left = build(inorder,postorder,st,pos-1); \\n    root->right = build(inorder,postorder,pos+1, end);\\n    return root;\\n}\\nTreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n    ind = postorder.size()-1;\\n    for(int i = 0; i <= ind; i++)\\n        mp[inorder[i]] = i;\\n    TreeNode* root = build(inorder,postorder,0,inorder.size()-1);\\n    return root;\\n}\\n    "
                    },
                    {
                        "username": "abhijeetkushwaha",
                        "content": "If you get this in interview they don\\'t want to hire you\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Feeling really happy today. Solved this question in 9 minutes sitting with pen and paper when my boring professor delivered his lecture on some other subject lol."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Similar problem - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Tip:\\n\\nRecursive DFS has O(N^2) TC (~ beats 5-11%)\\nRecursive DFS with hashMap has O(N) TC (~beats 90%)\\n\\nHashmap that maps values -> indices (this is 1:1 since values are unique)\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "SOMEONE PLS HELP ME IM SO CLOSE TO THE SOLUTION I FEEL.\\nIm getting the following error, like why. what improvements should i do in my code\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 5\\n  at line 36, Solution.solve\\n  at line 25, Solution.buildTree\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n\\n```\\nclass Solution {\\n\\n        int postIndex;\\n        int inIndex=0;          //inorder index\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int inorderStart=0;\\n        int inorderEnd= inorder.length-1;\\n\\n        postIndex= postorder.length-1;\\n        return solve(inorder, postorder, inorderStart, inorderEnd);\\n    }\\n    public TreeNode solve(int[] inorder, int[] postorder, int inorderStart, int inorderEnd)\\n    {\\n        if(inorderStart>inorderEnd ) return null;\\n        TreeNode root= new TreeNode(postorder[postIndex--]);\\n        // postIndex--;\\n\\n        //locate root.val in the inorder array\\n        for(int i=inorderStart; i<= inorderEnd; i--)\\n        {\\n            if(inorder[i]== root.val)\\n                {\\n                    inIndex=i;\\n                    break;\\n                }\\n        }\\n\\n        root.left= solve(inorder, postorder, inorderStart, inIndex-1);\\n        root.right= solve(inorder, postorder, inIndex+1, inorderEnd);\\n\\n            return root;\\n    }\\n}\\n\\n```"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&inorder,vector<int>&postorder,int si,int ei,int pi,int pe){\\n        \\n       if(si>ei or pi>pe){\\n           return NULL;\\n       }\\n     \\n\\n       \\n        //reursive case\\n        \\n        TreeNode* root=new TreeNode(postorder[pe]);\\n          pe--;\\n         int indx=-1;\\n        for(int i=si;i<=ei;i++){\\n           if(inorder[i]==postorder[pe]){\\n               indx=i;\\n           }\\n        }\\n        root->left=solve(inorder,postorder,si,indx-1,pi,pe);\\n        root->right=solve(inorder,postorder,indx+1,ei,pi,pe);\\n        return root;\\n\\n\\n    }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n       if(inorder.size()==0){\\n           return NULL;\\n       }\\n        int ei=inorder.size()-1;\\n        int pe=postorder.size()-1;\\n        return solve(inorder,postorder,0,ei,0,pe);\\n    }\\n};\\n\\n\\ncan someone tell mistake in my code"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "I got time limit exceeded for only following testcase and I used recursion to solve it. Can someone tell me where i possibly got wrong or any tips to optimize. \\n[-999,-998,-997,-996,-995,-994,-993,-992,-991,-990,-989,-988,-987,-986,-985,-984,-983,-982,-981,-980,-979,-978,-977,-976,-975,-974,-973,-972,-971,-970,-969,-968,-967,-966,-965,-964,-963,-962,-961,-960,-959,-958,-957,-956,-955,-954,-953,-952,-951,-950,-949,-948,-947,-946,-945,-944,-943,-942,-941,-940,-939,-938,-937,-936,-935,-934,-933,-932,-931,-930,-929,-928,-927,-926,-925,-924,-923,-922,-921,-920,-919,-918,-917,-916,-915,-914,-913,-912,-911,-910,-909,-908,-907,-906,-905,-904,-903,-902,-901,-900,-899,-898,-897,-896,-895,-894,-893,-892,-891,-890,-889,-888,-887,-886,-885,-884,-883,-882,-881,-880,-879,-878,-877,-876,-875,-874,-873,-872,-871,-870,-869,-868,-867,-866,-865,-864,-863,-862,-861,-860,-859,-858,-857,-856,-855,-854,-853,-852,-851,-850,-849,-848,-847,-846,-845,-844,-843,-842,-841,-840,-839,-838,-837,-836,-835,-834,-833,-832,-831,-830,-829,-828,-827,-826,-825,-824,-823,-822,-821,-820,-819,-818,-817,-816,-815,-814,-813,-812,-811,-810,-809,-808,-807,-806,-805,-804,-803,-802,-801,-800,-799,-798,-797,-796,-795,-794,-793,-792,-791,-790,-789,-788,-787,-786,-785,-784,-783,-782,-781,-780,-779,-778,-777,-776,-775,-774,-773,-772,-771,-770,-769,-768,-767,-766,-765,-764,-763,-762,-761,-760,-759,-758,-757,-756,-755,-754,-753,-752,-751,-750,-749,-748,-747,-746,-745,-744,-743,-742,-741,-740,-739,-738,-737,-736,-735,-734,-733,-732,-731,-730,-729,-728,-727,-726,-725,-724,-723,-722,-721,-720,-719,-718,-717,-716,-715,-714,-713,-712,-711,-710,-709,-708,-707,-706,-705,-704,-703,-702,-701,-700,-699,-698,-697,-696,-695,-694,-693,-692,-691,-690,-689,-688,-687,-686,-685,-684,-683,-682,-681,-680,-679,-678,-677,-676,-675,-674,-673,-672,-671,-670,-669,-668,-667,-666,-665,-664,-663,-662,-661,-660,-659,-658,-657,-656,-655,-654,-653,-652,-651,-650,-649,-648,-647,-646,-645,-644,-643,-642,-641,-640,-639,-638,-637,-636,-635,-634,-633,-632,-631,-630,-629,-628,-627,-626,-625,-624,-623,-622,-621,-620,-619,-618,-617,-616,-615,-614,-613,-612,-611,-610,-609,-608,-607,-606,-605,-604,-603,-602,-601,-600,-599,-598,-597,-596,-595,-594,-593,-592,-591,-590,-589,-588,-587,-586,-585,-584,-583,-582,-581,-580,-579,-578,-577,-576,-575,-574,-573,-572,-571,-570,-569,-568,-567,-566,-565,-564,-563,-562,-561,-560,-559,-558,-557,-556,-555,-554,-553,-552,-551,-550,-549,-548,-547,-546,-545,-544,-543,-542,-541,-540,-539,-538,-537,-536,-535,-534,-533,-532,-531,-530,-529,-528,-527,-526,-525,-524,-523,-522,-521,-520,-519,-518,-517,-516,-515,-514,-513,-512,-511,-510,-509,-508,-507,-506,-505,-504,-503,-502,-501,-500,-499,-498,-497,-496,-495,-494,-493,-492,-491,-490,-489,-488,-487,-486,-485,-484,-483,-482,-481,-480,-479,-478,-477,-476,-475,-474,-473,-472,-471,-470,-469,-468,-467,-466,-465,-464,-463,-462,-461,-460,-459,-458,-457,-456,-455,-454,-453,-452,-451,-450,-449,-448,-447,-446,-445,-444,-443,-442,-441,-440,-439,-438,-437,-436,-435,-434,-433,-432,-431,-430,-429,-428,-427,-426,-425,-424,-423,-422,-421,-420,-419,-418,-417,-416,-415,-414,-413,-412,-411,-410,-409,-408,-407,-406,-405,-404,-403,-402,-401,-400,-399,-398,-397,-396,-395,-394,-393,-392,-391,-390,-389,-388,-387,-386,-385,-384,-383,-382,-381,-380,-379,-378,-377,-376,-375,-374,-373,-372,-371,-370,-369,-368,-367,-366,-365,-364,-363,-362,-361,-360,-359,-358,-357,-356,-355,-354,-353,-352,-351,-350,-349,-348,-347,-346,-345,-344,-343,-342,-341,-340,-339,-338,-337,-336,-335,-334,-333,-332,-331,-330,-329,-328,-327,-326,-325,-324,-323,-322,-321,-320,-319,-318,-317,-316,-315,-314,-313,-312,-311,-310,-309,-308,-307,-306,-305,-304,-303,-302,-301,-300,-299,-298,-297,-296,-295,-294,-293,-292,-291,-290,-289,-288,-287,-286,-285,-284,-283,-282,-281,-280,-279,-278,-277,-276,-275,-274,-273,-272,-271,-270,-269,-268,-267,-266,-265,-264,-263,-262,-261,-260,-259,-258,-257,-256,-255,-254,-253,-252,-251,-250,-249,-248,-247,-246,-245,-244,-243,-242,-241,-240,-239,-238,-237,-236,-235,-234,-233,-232,-231,-230,-229,-228,-227,-226,-225,-224,-223,-222,-221,-220,-219,-218,-217,-216,-215,-214,-213,-212,-211,-210,-209,-208,-207,-206,-205,-204,-203,-202,-201,-200,-199,-198,-197,-196,-195,-194,-193,-192,-191,-190,-189,-188,-187,-186,-185,-184,-183,-182,-181,-180,-179,-178,-177,-176,-175,-174,-173,-172,-171,-170,-169,-168,-167,-166,-165,-164,-163,-162,-161,-160,-159,-158,-157,-156,-155,-154,-153,-152,-151,-150,-149,-148,-147,-146,-145,-144,-143,-142,-141,-140,-139,-138,-137,-136,-135,-134,-133,-132,-131,-130,-129,-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,-102,-101,-100,-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-81,-80,-79,-78,-77,-76,-75,-74,-73,-72,-71,-70,-69,-68,-67,-66,-65,-64,-63,-62,-61,-60,-59,-58,-57,-56,-55,-54,-53,-52,-51,-50,-49,-48,-47,-46,-45,-44,-43,-42,-41,-40,-39,-38,-37,-36,-35,-34,-33,-32,-31,-30,-29,-28,-27,-26,-25,-24,-23,-22,-21,-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000]\\n\\n"
                    },
                    {
                        "username": "harsh788",
                        "content": "[@Swapnil07072000](/Swapnil07072000) Thanks dude, this helped me. But I am not sure why it solved the problem..."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Faced the same error, solved it by sending reference to vectors and hashmap if used."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Time Limit Exceeded (in red colour) \nEdit: 77%,77% in C :)"
                    }
                ]
            },
            {
                "id": 1833969,
                "content": [
                    {
                        "username": "Alt_Id_hai_Bhai",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n=postorder.length;\\n        TreeNode ans=new TreeNode(postorder[n-1]);\\n        int index=-1;\\n        for(int i=0;i<n;i++) {\\n            if(inorder[i]==postorder[n-1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        ans.left=createTree(0, index-1, inorder);\\n        ans.right=createTree(index+1, n-1, inorder);\\n        return ans;\\n    }\\n    public TreeNode createTree(int low, int high, int inorder[]){\\n        if(low>high) return null;\\n        int mid=low+ (high-low)/2;\\n        TreeNode ans=new TreeNode(inorder[mid]);\\n        ans.left=createTree(low, mid-1, inorder);\\n        ans.right=createTree(mid+1 , high, inorder);\\n        return ans;\\n    }\\n\\n    \\n}\\n\\ncan someone explain why does this code fail?"
                    },
                    {
                        "username": "vijaytech0102",
                        "content": "I think the tree provides me shadow where I can relax during my DSA journey."
                    },
                    {
                        "username": "Msey",
                        "content": "Treeeeeees!!! The whole week!"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "**PAT** **PAT** **PAT** **PAT**!!!"
                    },
                    {
                        "username": "A_Thousand_Miles",
                        "content": "I'm not sure where my logic is going wrong. Please help.\n\n` map<int,int> generateMap(vector<int>& inorder){\n        map<int,int> temp;\n        for(int i = 0 ; i < inorder.size(); i++)\n            temp[inorder[i]] = i;\n        return temp;\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int n = inorder.size();\n        int index = n - 1;\n        int ele = postorder[index--];        \n        map<int,int> m = generateMap(inorder);\n        // for(auto i : m)\n        //     cout<<i.first<<\" \"<<i.second<<endl;\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* ans = solve(m,postorder,index,0,n-1,n);\n        return ans;\n    }\n    TreeNode* solve(map<int,int>& m, vector<int>& postorder, int index, int inStart, int inEnd, int n){\n        if(index < 0 || inStart > inEnd)\n            return NULL;\n        int ele = postorder[index--];\n        int pos = m[ele];\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* root = new TreeNode(ele);\n        root->right = solve(m,postorder,index,pos+1,inEnd,n);\n        root->left = solve(m,postorder,index,inStart,pos-1,n);\n        \n        return root;\n\n        \n    }`"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the second recursive call (`root->left = ...`). Conceptually, the third parameter (`index`) is the index of the root element within `postorder` for that subtree. But this line passes `index` to the recursive function which is the index of the *right* subtree. You have to subtract the number of values in the right subtree to get the index of the root of the left subtree.\\n\\nBTW:  \\nIf you want to post multi-line code snippets please either indent all lines with four *additional* spaces, or put put a line with three backticks before and after the code (see [this cheat sheet](https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet)).  \\nUse meaningful variable names that others can understand. Make it easy for them to help you. I spent quite some time analyzing what `index`, `ele`, `pos`, inStart`, and `inEnd` represent.\\n\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Leetcode cares for the environment, plant more trees people and this is a hint."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe they did [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) before."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "As i expected ,Today is also tree problem.\\nThankyou leetcode ,for making the stronger foundation of tree problem ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1833888,
                "content": [
                    {
                        "username": "Alt_Id_hai_Bhai",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n=postorder.length;\\n        TreeNode ans=new TreeNode(postorder[n-1]);\\n        int index=-1;\\n        for(int i=0;i<n;i++) {\\n            if(inorder[i]==postorder[n-1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        ans.left=createTree(0, index-1, inorder);\\n        ans.right=createTree(index+1, n-1, inorder);\\n        return ans;\\n    }\\n    public TreeNode createTree(int low, int high, int inorder[]){\\n        if(low>high) return null;\\n        int mid=low+ (high-low)/2;\\n        TreeNode ans=new TreeNode(inorder[mid]);\\n        ans.left=createTree(low, mid-1, inorder);\\n        ans.right=createTree(mid+1 , high, inorder);\\n        return ans;\\n    }\\n\\n    \\n}\\n\\ncan someone explain why does this code fail?"
                    },
                    {
                        "username": "vijaytech0102",
                        "content": "I think the tree provides me shadow where I can relax during my DSA journey."
                    },
                    {
                        "username": "Msey",
                        "content": "Treeeeeees!!! The whole week!"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "**PAT** **PAT** **PAT** **PAT**!!!"
                    },
                    {
                        "username": "A_Thousand_Miles",
                        "content": "I'm not sure where my logic is going wrong. Please help.\n\n` map<int,int> generateMap(vector<int>& inorder){\n        map<int,int> temp;\n        for(int i = 0 ; i < inorder.size(); i++)\n            temp[inorder[i]] = i;\n        return temp;\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int n = inorder.size();\n        int index = n - 1;\n        int ele = postorder[index--];        \n        map<int,int> m = generateMap(inorder);\n        // for(auto i : m)\n        //     cout<<i.first<<\" \"<<i.second<<endl;\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* ans = solve(m,postorder,index,0,n-1,n);\n        return ans;\n    }\n    TreeNode* solve(map<int,int>& m, vector<int>& postorder, int index, int inStart, int inEnd, int n){\n        if(index < 0 || inStart > inEnd)\n            return NULL;\n        int ele = postorder[index--];\n        int pos = m[ele];\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* root = new TreeNode(ele);\n        root->right = solve(m,postorder,index,pos+1,inEnd,n);\n        root->left = solve(m,postorder,index,inStart,pos-1,n);\n        \n        return root;\n\n        \n    }`"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the second recursive call (`root->left = ...`). Conceptually, the third parameter (`index`) is the index of the root element within `postorder` for that subtree. But this line passes `index` to the recursive function which is the index of the *right* subtree. You have to subtract the number of values in the right subtree to get the index of the root of the left subtree.\\n\\nBTW:  \\nIf you want to post multi-line code snippets please either indent all lines with four *additional* spaces, or put put a line with three backticks before and after the code (see [this cheat sheet](https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet)).  \\nUse meaningful variable names that others can understand. Make it easy for them to help you. I spent quite some time analyzing what `index`, `ele`, `pos`, inStart`, and `inEnd` represent.\\n\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Leetcode cares for the environment, plant more trees people and this is a hint."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe they did [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) before."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "As i expected ,Today is also tree problem.\\nThankyou leetcode ,for making the stronger foundation of tree problem ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1833810,
                "content": [
                    {
                        "username": "Alt_Id_hai_Bhai",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n=postorder.length;\\n        TreeNode ans=new TreeNode(postorder[n-1]);\\n        int index=-1;\\n        for(int i=0;i<n;i++) {\\n            if(inorder[i]==postorder[n-1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        ans.left=createTree(0, index-1, inorder);\\n        ans.right=createTree(index+1, n-1, inorder);\\n        return ans;\\n    }\\n    public TreeNode createTree(int low, int high, int inorder[]){\\n        if(low>high) return null;\\n        int mid=low+ (high-low)/2;\\n        TreeNode ans=new TreeNode(inorder[mid]);\\n        ans.left=createTree(low, mid-1, inorder);\\n        ans.right=createTree(mid+1 , high, inorder);\\n        return ans;\\n    }\\n\\n    \\n}\\n\\ncan someone explain why does this code fail?"
                    },
                    {
                        "username": "vijaytech0102",
                        "content": "I think the tree provides me shadow where I can relax during my DSA journey."
                    },
                    {
                        "username": "Msey",
                        "content": "Treeeeeees!!! The whole week!"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "**PAT** **PAT** **PAT** **PAT**!!!"
                    },
                    {
                        "username": "A_Thousand_Miles",
                        "content": "I'm not sure where my logic is going wrong. Please help.\n\n` map<int,int> generateMap(vector<int>& inorder){\n        map<int,int> temp;\n        for(int i = 0 ; i < inorder.size(); i++)\n            temp[inorder[i]] = i;\n        return temp;\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int n = inorder.size();\n        int index = n - 1;\n        int ele = postorder[index--];        \n        map<int,int> m = generateMap(inorder);\n        // for(auto i : m)\n        //     cout<<i.first<<\" \"<<i.second<<endl;\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* ans = solve(m,postorder,index,0,n-1,n);\n        return ans;\n    }\n    TreeNode* solve(map<int,int>& m, vector<int>& postorder, int index, int inStart, int inEnd, int n){\n        if(index < 0 || inStart > inEnd)\n            return NULL;\n        int ele = postorder[index--];\n        int pos = m[ele];\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* root = new TreeNode(ele);\n        root->right = solve(m,postorder,index,pos+1,inEnd,n);\n        root->left = solve(m,postorder,index,inStart,pos-1,n);\n        \n        return root;\n\n        \n    }`"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the second recursive call (`root->left = ...`). Conceptually, the third parameter (`index`) is the index of the root element within `postorder` for that subtree. But this line passes `index` to the recursive function which is the index of the *right* subtree. You have to subtract the number of values in the right subtree to get the index of the root of the left subtree.\\n\\nBTW:  \\nIf you want to post multi-line code snippets please either indent all lines with four *additional* spaces, or put put a line with three backticks before and after the code (see [this cheat sheet](https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet)).  \\nUse meaningful variable names that others can understand. Make it easy for them to help you. I spent quite some time analyzing what `index`, `ele`, `pos`, inStart`, and `inEnd` represent.\\n\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Leetcode cares for the environment, plant more trees people and this is a hint."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe they did [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) before."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "As i expected ,Today is also tree problem.\\nThankyou leetcode ,for making the stronger foundation of tree problem ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1833772,
                "content": [
                    {
                        "username": "Alt_Id_hai_Bhai",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n=postorder.length;\\n        TreeNode ans=new TreeNode(postorder[n-1]);\\n        int index=-1;\\n        for(int i=0;i<n;i++) {\\n            if(inorder[i]==postorder[n-1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        ans.left=createTree(0, index-1, inorder);\\n        ans.right=createTree(index+1, n-1, inorder);\\n        return ans;\\n    }\\n    public TreeNode createTree(int low, int high, int inorder[]){\\n        if(low>high) return null;\\n        int mid=low+ (high-low)/2;\\n        TreeNode ans=new TreeNode(inorder[mid]);\\n        ans.left=createTree(low, mid-1, inorder);\\n        ans.right=createTree(mid+1 , high, inorder);\\n        return ans;\\n    }\\n\\n    \\n}\\n\\ncan someone explain why does this code fail?"
                    },
                    {
                        "username": "vijaytech0102",
                        "content": "I think the tree provides me shadow where I can relax during my DSA journey."
                    },
                    {
                        "username": "Msey",
                        "content": "Treeeeeees!!! The whole week!"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "**PAT** **PAT** **PAT** **PAT**!!!"
                    },
                    {
                        "username": "A_Thousand_Miles",
                        "content": "I'm not sure where my logic is going wrong. Please help.\n\n` map<int,int> generateMap(vector<int>& inorder){\n        map<int,int> temp;\n        for(int i = 0 ; i < inorder.size(); i++)\n            temp[inorder[i]] = i;\n        return temp;\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int n = inorder.size();\n        int index = n - 1;\n        int ele = postorder[index--];        \n        map<int,int> m = generateMap(inorder);\n        // for(auto i : m)\n        //     cout<<i.first<<\" \"<<i.second<<endl;\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* ans = solve(m,postorder,index,0,n-1,n);\n        return ans;\n    }\n    TreeNode* solve(map<int,int>& m, vector<int>& postorder, int index, int inStart, int inEnd, int n){\n        if(index < 0 || inStart > inEnd)\n            return NULL;\n        int ele = postorder[index--];\n        int pos = m[ele];\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* root = new TreeNode(ele);\n        root->right = solve(m,postorder,index,pos+1,inEnd,n);\n        root->left = solve(m,postorder,index,inStart,pos-1,n);\n        \n        return root;\n\n        \n    }`"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the second recursive call (`root->left = ...`). Conceptually, the third parameter (`index`) is the index of the root element within `postorder` for that subtree. But this line passes `index` to the recursive function which is the index of the *right* subtree. You have to subtract the number of values in the right subtree to get the index of the root of the left subtree.\\n\\nBTW:  \\nIf you want to post multi-line code snippets please either indent all lines with four *additional* spaces, or put put a line with three backticks before and after the code (see [this cheat sheet](https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet)).  \\nUse meaningful variable names that others can understand. Make it easy for them to help you. I spent quite some time analyzing what `index`, `ele`, `pos`, inStart`, and `inEnd` represent.\\n\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Leetcode cares for the environment, plant more trees people and this is a hint."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe they did [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) before."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "As i expected ,Today is also tree problem.\\nThankyou leetcode ,for making the stronger foundation of tree problem ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1833756,
                "content": [
                    {
                        "username": "Alt_Id_hai_Bhai",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n=postorder.length;\\n        TreeNode ans=new TreeNode(postorder[n-1]);\\n        int index=-1;\\n        for(int i=0;i<n;i++) {\\n            if(inorder[i]==postorder[n-1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        ans.left=createTree(0, index-1, inorder);\\n        ans.right=createTree(index+1, n-1, inorder);\\n        return ans;\\n    }\\n    public TreeNode createTree(int low, int high, int inorder[]){\\n        if(low>high) return null;\\n        int mid=low+ (high-low)/2;\\n        TreeNode ans=new TreeNode(inorder[mid]);\\n        ans.left=createTree(low, mid-1, inorder);\\n        ans.right=createTree(mid+1 , high, inorder);\\n        return ans;\\n    }\\n\\n    \\n}\\n\\ncan someone explain why does this code fail?"
                    },
                    {
                        "username": "vijaytech0102",
                        "content": "I think the tree provides me shadow where I can relax during my DSA journey."
                    },
                    {
                        "username": "Msey",
                        "content": "Treeeeeees!!! The whole week!"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "**PAT** **PAT** **PAT** **PAT**!!!"
                    },
                    {
                        "username": "A_Thousand_Miles",
                        "content": "I'm not sure where my logic is going wrong. Please help.\n\n` map<int,int> generateMap(vector<int>& inorder){\n        map<int,int> temp;\n        for(int i = 0 ; i < inorder.size(); i++)\n            temp[inorder[i]] = i;\n        return temp;\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int n = inorder.size();\n        int index = n - 1;\n        int ele = postorder[index--];        \n        map<int,int> m = generateMap(inorder);\n        // for(auto i : m)\n        //     cout<<i.first<<\" \"<<i.second<<endl;\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* ans = solve(m,postorder,index,0,n-1,n);\n        return ans;\n    }\n    TreeNode* solve(map<int,int>& m, vector<int>& postorder, int index, int inStart, int inEnd, int n){\n        if(index < 0 || inStart > inEnd)\n            return NULL;\n        int ele = postorder[index--];\n        int pos = m[ele];\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* root = new TreeNode(ele);\n        root->right = solve(m,postorder,index,pos+1,inEnd,n);\n        root->left = solve(m,postorder,index,inStart,pos-1,n);\n        \n        return root;\n\n        \n    }`"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the second recursive call (`root->left = ...`). Conceptually, the third parameter (`index`) is the index of the root element within `postorder` for that subtree. But this line passes `index` to the recursive function which is the index of the *right* subtree. You have to subtract the number of values in the right subtree to get the index of the root of the left subtree.\\n\\nBTW:  \\nIf you want to post multi-line code snippets please either indent all lines with four *additional* spaces, or put put a line with three backticks before and after the code (see [this cheat sheet](https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet)).  \\nUse meaningful variable names that others can understand. Make it easy for them to help you. I spent quite some time analyzing what `index`, `ele`, `pos`, inStart`, and `inEnd` represent.\\n\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Leetcode cares for the environment, plant more trees people and this is a hint."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe they did [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) before."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "As i expected ,Today is also tree problem.\\nThankyou leetcode ,for making the stronger foundation of tree problem ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1833699,
                "content": [
                    {
                        "username": "Alt_Id_hai_Bhai",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n=postorder.length;\\n        TreeNode ans=new TreeNode(postorder[n-1]);\\n        int index=-1;\\n        for(int i=0;i<n;i++) {\\n            if(inorder[i]==postorder[n-1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        ans.left=createTree(0, index-1, inorder);\\n        ans.right=createTree(index+1, n-1, inorder);\\n        return ans;\\n    }\\n    public TreeNode createTree(int low, int high, int inorder[]){\\n        if(low>high) return null;\\n        int mid=low+ (high-low)/2;\\n        TreeNode ans=new TreeNode(inorder[mid]);\\n        ans.left=createTree(low, mid-1, inorder);\\n        ans.right=createTree(mid+1 , high, inorder);\\n        return ans;\\n    }\\n\\n    \\n}\\n\\ncan someone explain why does this code fail?"
                    },
                    {
                        "username": "vijaytech0102",
                        "content": "I think the tree provides me shadow where I can relax during my DSA journey."
                    },
                    {
                        "username": "Msey",
                        "content": "Treeeeeees!!! The whole week!"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "**PAT** **PAT** **PAT** **PAT**!!!"
                    },
                    {
                        "username": "A_Thousand_Miles",
                        "content": "I'm not sure where my logic is going wrong. Please help.\n\n` map<int,int> generateMap(vector<int>& inorder){\n        map<int,int> temp;\n        for(int i = 0 ; i < inorder.size(); i++)\n            temp[inorder[i]] = i;\n        return temp;\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int n = inorder.size();\n        int index = n - 1;\n        int ele = postorder[index--];        \n        map<int,int> m = generateMap(inorder);\n        // for(auto i : m)\n        //     cout<<i.first<<\" \"<<i.second<<endl;\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* ans = solve(m,postorder,index,0,n-1,n);\n        return ans;\n    }\n    TreeNode* solve(map<int,int>& m, vector<int>& postorder, int index, int inStart, int inEnd, int n){\n        if(index < 0 || inStart > inEnd)\n            return NULL;\n        int ele = postorder[index--];\n        int pos = m[ele];\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* root = new TreeNode(ele);\n        root->right = solve(m,postorder,index,pos+1,inEnd,n);\n        root->left = solve(m,postorder,index,inStart,pos-1,n);\n        \n        return root;\n\n        \n    }`"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the second recursive call (`root->left = ...`). Conceptually, the third parameter (`index`) is the index of the root element within `postorder` for that subtree. But this line passes `index` to the recursive function which is the index of the *right* subtree. You have to subtract the number of values in the right subtree to get the index of the root of the left subtree.\\n\\nBTW:  \\nIf you want to post multi-line code snippets please either indent all lines with four *additional* spaces, or put put a line with three backticks before and after the code (see [this cheat sheet](https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet)).  \\nUse meaningful variable names that others can understand. Make it easy for them to help you. I spent quite some time analyzing what `index`, `ele`, `pos`, inStart`, and `inEnd` represent.\\n\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Leetcode cares for the environment, plant more trees people and this is a hint."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe they did [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) before."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "As i expected ,Today is also tree problem.\\nThankyou leetcode ,for making the stronger foundation of tree problem ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1833697,
                "content": [
                    {
                        "username": "Alt_Id_hai_Bhai",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n=postorder.length;\\n        TreeNode ans=new TreeNode(postorder[n-1]);\\n        int index=-1;\\n        for(int i=0;i<n;i++) {\\n            if(inorder[i]==postorder[n-1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        ans.left=createTree(0, index-1, inorder);\\n        ans.right=createTree(index+1, n-1, inorder);\\n        return ans;\\n    }\\n    public TreeNode createTree(int low, int high, int inorder[]){\\n        if(low>high) return null;\\n        int mid=low+ (high-low)/2;\\n        TreeNode ans=new TreeNode(inorder[mid]);\\n        ans.left=createTree(low, mid-1, inorder);\\n        ans.right=createTree(mid+1 , high, inorder);\\n        return ans;\\n    }\\n\\n    \\n}\\n\\ncan someone explain why does this code fail?"
                    },
                    {
                        "username": "vijaytech0102",
                        "content": "I think the tree provides me shadow where I can relax during my DSA journey."
                    },
                    {
                        "username": "Msey",
                        "content": "Treeeeeees!!! The whole week!"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "**PAT** **PAT** **PAT** **PAT**!!!"
                    },
                    {
                        "username": "A_Thousand_Miles",
                        "content": "I'm not sure where my logic is going wrong. Please help.\n\n` map<int,int> generateMap(vector<int>& inorder){\n        map<int,int> temp;\n        for(int i = 0 ; i < inorder.size(); i++)\n            temp[inorder[i]] = i;\n        return temp;\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int n = inorder.size();\n        int index = n - 1;\n        int ele = postorder[index--];        \n        map<int,int> m = generateMap(inorder);\n        // for(auto i : m)\n        //     cout<<i.first<<\" \"<<i.second<<endl;\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* ans = solve(m,postorder,index,0,n-1,n);\n        return ans;\n    }\n    TreeNode* solve(map<int,int>& m, vector<int>& postorder, int index, int inStart, int inEnd, int n){\n        if(index < 0 || inStart > inEnd)\n            return NULL;\n        int ele = postorder[index--];\n        int pos = m[ele];\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* root = new TreeNode(ele);\n        root->right = solve(m,postorder,index,pos+1,inEnd,n);\n        root->left = solve(m,postorder,index,inStart,pos-1,n);\n        \n        return root;\n\n        \n    }`"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the second recursive call (`root->left = ...`). Conceptually, the third parameter (`index`) is the index of the root element within `postorder` for that subtree. But this line passes `index` to the recursive function which is the index of the *right* subtree. You have to subtract the number of values in the right subtree to get the index of the root of the left subtree.\\n\\nBTW:  \\nIf you want to post multi-line code snippets please either indent all lines with four *additional* spaces, or put put a line with three backticks before and after the code (see [this cheat sheet](https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet)).  \\nUse meaningful variable names that others can understand. Make it easy for them to help you. I spent quite some time analyzing what `index`, `ele`, `pos`, inStart`, and `inEnd` represent.\\n\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Leetcode cares for the environment, plant more trees people and this is a hint."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe they did [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) before."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "As i expected ,Today is also tree problem.\\nThankyou leetcode ,for making the stronger foundation of tree problem ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1833655,
                "content": [
                    {
                        "username": "Alt_Id_hai_Bhai",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n=postorder.length;\\n        TreeNode ans=new TreeNode(postorder[n-1]);\\n        int index=-1;\\n        for(int i=0;i<n;i++) {\\n            if(inorder[i]==postorder[n-1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        ans.left=createTree(0, index-1, inorder);\\n        ans.right=createTree(index+1, n-1, inorder);\\n        return ans;\\n    }\\n    public TreeNode createTree(int low, int high, int inorder[]){\\n        if(low>high) return null;\\n        int mid=low+ (high-low)/2;\\n        TreeNode ans=new TreeNode(inorder[mid]);\\n        ans.left=createTree(low, mid-1, inorder);\\n        ans.right=createTree(mid+1 , high, inorder);\\n        return ans;\\n    }\\n\\n    \\n}\\n\\ncan someone explain why does this code fail?"
                    },
                    {
                        "username": "vijaytech0102",
                        "content": "I think the tree provides me shadow where I can relax during my DSA journey."
                    },
                    {
                        "username": "Msey",
                        "content": "Treeeeeees!!! The whole week!"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "**PAT** **PAT** **PAT** **PAT**!!!"
                    },
                    {
                        "username": "A_Thousand_Miles",
                        "content": "I'm not sure where my logic is going wrong. Please help.\n\n` map<int,int> generateMap(vector<int>& inorder){\n        map<int,int> temp;\n        for(int i = 0 ; i < inorder.size(); i++)\n            temp[inorder[i]] = i;\n        return temp;\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int n = inorder.size();\n        int index = n - 1;\n        int ele = postorder[index--];        \n        map<int,int> m = generateMap(inorder);\n        // for(auto i : m)\n        //     cout<<i.first<<\" \"<<i.second<<endl;\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* ans = solve(m,postorder,index,0,n-1,n);\n        return ans;\n    }\n    TreeNode* solve(map<int,int>& m, vector<int>& postorder, int index, int inStart, int inEnd, int n){\n        if(index < 0 || inStart > inEnd)\n            return NULL;\n        int ele = postorder[index--];\n        int pos = m[ele];\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* root = new TreeNode(ele);\n        root->right = solve(m,postorder,index,pos+1,inEnd,n);\n        root->left = solve(m,postorder,index,inStart,pos-1,n);\n        \n        return root;\n\n        \n    }`"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the second recursive call (`root->left = ...`). Conceptually, the third parameter (`index`) is the index of the root element within `postorder` for that subtree. But this line passes `index` to the recursive function which is the index of the *right* subtree. You have to subtract the number of values in the right subtree to get the index of the root of the left subtree.\\n\\nBTW:  \\nIf you want to post multi-line code snippets please either indent all lines with four *additional* spaces, or put put a line with three backticks before and after the code (see [this cheat sheet](https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet)).  \\nUse meaningful variable names that others can understand. Make it easy for them to help you. I spent quite some time analyzing what `index`, `ele`, `pos`, inStart`, and `inEnd` represent.\\n\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Leetcode cares for the environment, plant more trees people and this is a hint."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe they did [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) before."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "As i expected ,Today is also tree problem.\\nThankyou leetcode ,for making the stronger foundation of tree problem ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1768455,
                "content": [
                    {
                        "username": "Alt_Id_hai_Bhai",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n=postorder.length;\\n        TreeNode ans=new TreeNode(postorder[n-1]);\\n        int index=-1;\\n        for(int i=0;i<n;i++) {\\n            if(inorder[i]==postorder[n-1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        ans.left=createTree(0, index-1, inorder);\\n        ans.right=createTree(index+1, n-1, inorder);\\n        return ans;\\n    }\\n    public TreeNode createTree(int low, int high, int inorder[]){\\n        if(low>high) return null;\\n        int mid=low+ (high-low)/2;\\n        TreeNode ans=new TreeNode(inorder[mid]);\\n        ans.left=createTree(low, mid-1, inorder);\\n        ans.right=createTree(mid+1 , high, inorder);\\n        return ans;\\n    }\\n\\n    \\n}\\n\\ncan someone explain why does this code fail?"
                    },
                    {
                        "username": "vijaytech0102",
                        "content": "I think the tree provides me shadow where I can relax during my DSA journey."
                    },
                    {
                        "username": "Msey",
                        "content": "Treeeeeees!!! The whole week!"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "**PAT** **PAT** **PAT** **PAT**!!!"
                    },
                    {
                        "username": "A_Thousand_Miles",
                        "content": "I'm not sure where my logic is going wrong. Please help.\n\n` map<int,int> generateMap(vector<int>& inorder){\n        map<int,int> temp;\n        for(int i = 0 ; i < inorder.size(); i++)\n            temp[inorder[i]] = i;\n        return temp;\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int n = inorder.size();\n        int index = n - 1;\n        int ele = postorder[index--];        \n        map<int,int> m = generateMap(inorder);\n        // for(auto i : m)\n        //     cout<<i.first<<\" \"<<i.second<<endl;\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* ans = solve(m,postorder,index,0,n-1,n);\n        return ans;\n    }\n    TreeNode* solve(map<int,int>& m, vector<int>& postorder, int index, int inStart, int inEnd, int n){\n        if(index < 0 || inStart > inEnd)\n            return NULL;\n        int ele = postorder[index--];\n        int pos = m[ele];\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* root = new TreeNode(ele);\n        root->right = solve(m,postorder,index,pos+1,inEnd,n);\n        root->left = solve(m,postorder,index,inStart,pos-1,n);\n        \n        return root;\n\n        \n    }`"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the second recursive call (`root->left = ...`). Conceptually, the third parameter (`index`) is the index of the root element within `postorder` for that subtree. But this line passes `index` to the recursive function which is the index of the *right* subtree. You have to subtract the number of values in the right subtree to get the index of the root of the left subtree.\\n\\nBTW:  \\nIf you want to post multi-line code snippets please either indent all lines with four *additional* spaces, or put put a line with three backticks before and after the code (see [this cheat sheet](https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet)).  \\nUse meaningful variable names that others can understand. Make it easy for them to help you. I spent quite some time analyzing what `index`, `ele`, `pos`, inStart`, and `inEnd` represent.\\n\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Leetcode cares for the environment, plant more trees people and this is a hint."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe they did [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) before."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "As i expected ,Today is also tree problem.\\nThankyou leetcode ,for making the stronger foundation of tree problem ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1754157,
                "content": [
                    {
                        "username": "Alt_Id_hai_Bhai",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        int n=postorder.length;\\n        TreeNode ans=new TreeNode(postorder[n-1]);\\n        int index=-1;\\n        for(int i=0;i<n;i++) {\\n            if(inorder[i]==postorder[n-1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        ans.left=createTree(0, index-1, inorder);\\n        ans.right=createTree(index+1, n-1, inorder);\\n        return ans;\\n    }\\n    public TreeNode createTree(int low, int high, int inorder[]){\\n        if(low>high) return null;\\n        int mid=low+ (high-low)/2;\\n        TreeNode ans=new TreeNode(inorder[mid]);\\n        ans.left=createTree(low, mid-1, inorder);\\n        ans.right=createTree(mid+1 , high, inorder);\\n        return ans;\\n    }\\n\\n    \\n}\\n\\ncan someone explain why does this code fail?"
                    },
                    {
                        "username": "vijaytech0102",
                        "content": "I think the tree provides me shadow where I can relax during my DSA journey."
                    },
                    {
                        "username": "Msey",
                        "content": "Treeeeeees!!! The whole week!"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "**PAT** **PAT** **PAT** **PAT**!!!"
                    },
                    {
                        "username": "A_Thousand_Miles",
                        "content": "I'm not sure where my logic is going wrong. Please help.\n\n` map<int,int> generateMap(vector<int>& inorder){\n        map<int,int> temp;\n        for(int i = 0 ; i < inorder.size(); i++)\n            temp[inorder[i]] = i;\n        return temp;\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int n = inorder.size();\n        int index = n - 1;\n        int ele = postorder[index--];        \n        map<int,int> m = generateMap(inorder);\n        // for(auto i : m)\n        //     cout<<i.first<<\" \"<<i.second<<endl;\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* ans = solve(m,postorder,index,0,n-1,n);\n        return ans;\n    }\n    TreeNode* solve(map<int,int>& m, vector<int>& postorder, int index, int inStart, int inEnd, int n){\n        if(index < 0 || inStart > inEnd)\n            return NULL;\n        int ele = postorder[index--];\n        int pos = m[ele];\n        //cout<<ele<<\" \"<<m[ele]<<endl;\n        TreeNode* root = new TreeNode(ele);\n        root->right = solve(m,postorder,index,pos+1,inEnd,n);\n        root->left = solve(m,postorder,index,inStart,pos-1,n);\n        \n        return root;\n\n        \n    }`"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Take a look at the second recursive call (`root->left = ...`). Conceptually, the third parameter (`index`) is the index of the root element within `postorder` for that subtree. But this line passes `index` to the recursive function which is the index of the *right* subtree. You have to subtract the number of values in the right subtree to get the index of the root of the left subtree.\\n\\nBTW:  \\nIf you want to post multi-line code snippets please either indent all lines with four *additional* spaces, or put put a line with three backticks before and after the code (see [this cheat sheet](https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet)).  \\nUse meaningful variable names that others can understand. Make it easy for them to help you. I spent quite some time analyzing what `index`, `ele`, `pos`, inStart`, and `inEnd` represent.\\n\\n"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Leetcode cares for the environment, plant more trees people and this is a hint."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Maybe they did [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) before."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "As i expected ,Today is also tree problem.\\nThankyou leetcode ,for making the stronger foundation of tree problem ."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Linked List",
        "question_content": "<p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [5,4,3,2,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" style=\"width: 182px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2]\n<strong>Output:</strong> [2,1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> A linked list can be reversed either iteratively or recursively. Could you implement both?</p>\n",
        "solutions": [
            {
                "id": 58125,
                "title": "in-place-iterative-and-recursive-java-solution",
                "content": "    public ListNode reverseList(ListNode head) {\\n        /* iterative solution */\\n        ListNode newHead = null;\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = newHead;\\n            newHead = head;\\n            head = next;\\n        }\\n        return newHead;\\n    }\\n    \\n    public ListNode reverseList(ListNode head) {\\n        /* recursive solution */\\n        return reverseListInt(head, null);\\n    }\\n    \\n    private ListNode reverseListInt(ListNode head, ListNode newHead) {\\n        if (head == null)\\n            return newHead;\\n        ListNode next = head.next;\\n        head.next = newHead;\\n        return reverseListInt(next, head);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode reverseList(ListNode head) {\\n        /* iterative solution */\\n        ListNode newHead = null;\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = newHead;\\n            newHead = head;\\n            head = next;\\n        }\\n        return newHead;\\n    }\\n    \\n    public ListNode reverseList(ListNode head) {\\n        /* recursive solution */\\n        return reverseListInt(head, null);\\n    }\\n    \\n    private ListNode reverseListInt(ListNode head, ListNode newHead) {\\n        if (head == null)\\n            return newHead;\\n        ListNode next = head.next;\\n        head.next = newHead;\\n        return reverseListInt(next, head);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 803955,
                "title": "c-iterative-vs-recursive-solutions-compared-and-explained-99-time-85-space",
                "content": "Not sure how this problem is expecting me to use less memory than this, but here is the deal:\\n* we are going to use 3 variables: `prevNode`, `head` and `nextNode`, that you can easily guess what are meant to represent as we go;\\n* we will initialise `prevNode` to `NULL`, while `nextNode` can stay empty;\\n* we are then going to loop until our current main iterator (`head`) is truthy (ie: not `NULL`), which would imply we reached the end of the list;\\n* during the iteration, we first of all update `nextNode` so that it acquires its namesake value, the one of the next node indeed: `head->next`;\\n* we then proceeding \"reversing\" `head->next` and assigning it the value of `prevNode`, while `prevNode` will become take the current value of `head`;\\n* finally, we update `head` with the value we stored in `nextNode` and go on with the loop until we can. After the loop, we return `prevNode`.\\n\\nI know it is complex, but I find this gif from another platform to make the whole logic much easier to understand (bear in mind we do not need `curr` and will just use `head` in its place):\\n\\n![reverting a list](https://media.geeksforgeeks.org/wp-content/cdn-uploads/RGIF2.gif)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *nextNode, *prevNode = NULL;\\n        while (head) {\\n            nextNode = head->next;\\n            head->next = prevNode;\\n            prevNode = head;\\n            head = nextNode;\\n        }\\n        return prevNode;\\n    }\\n};\\n```\\n\\nRelatively trivial refactor (the function does basically the same) with recursion and comma operator to make it one-line:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode *head, ListNode *nextNode = NULL, ListNode *prevNode = NULL) {\\n        return head ? reverseList(head->next, (head->next = prevNode, nextNode), head) : prevNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *nextNode, *prevNode = NULL;\\n        while (head) {\\n            nextNode = head->next;\\n            head->next = prevNode;\\n            prevNode = head;\\n            head = nextNode;\\n        }\\n        return prevNode;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode *head, ListNode *nextNode = NULL, ListNode *prevNode = NULL) {\\n        return head ? reverseList(head->next, (head->next = prevNode, nextNode), head) : prevNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682085,
                "title": "java-0ms-100-easy-understanding",
                "content": "![image](https://assets.leetcode.com/users/images/9ab10696-3129-414d-8b03-128aac3f640a_1665328906.6477296.png)\\n\\n```\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;  \\n        ListNode current = head;\\n    \\n        \\n        while(current != null) { \\n            ListNode next = current.next; \\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n       return prev; \\n    }\\n}\\n```\\n**WHILE_LOOP EXPLANATION**\\n![image](https://assets.leetcode.com/users/images/50e57eb9-5497-4e60-8e29-d60298c74148_1665329031.0495164.png)\\n![image](https://assets.leetcode.com/users/images/5cd7ac5e-be44-4649-a39b-1026afb2ad34_1665329059.036713.png)\\n\\n**PLEASE UPVOTE**\\nIf you understand the solution\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;  \\n        ListNode current = head;\\n    \\n        \\n        while(current != null) { \\n            ListNode next = current.next; \\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n       return prev; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211778,
                "title": "using-2-methods-iterative-recursive-beats-97-91",
                "content": "# Intuition\\nThe idea is to use three pointers curr, prev, and forward to keep track of nodes to update reverse links.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach 1 - using Iterative Method \\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n\\n        while(curr != NULL){\\n            ListNode* forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            \\n        }\\n        return prev;\\n    }\\n};\\n ```\\n# Intuition\\nThe idea is to reach the last node of the linked list using recursion then start reversing the linked list.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach 2 - using Recrusion\\n\\n\\n# Complexity\\n- Time Complexity: O(N), Visiting over every node one time \\n- Auxiliary Space: O(N), Function call stack space\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* prev = NULL;\\n        ListNode* h2 = reverseList(head->next);\\n        head->next->next = head;\\n        head->next=prev;\\n        return h2;\\n    }\\n\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/4dec8ab6-9dd5-4ee3-a32a-fe898a4ff5b3_1676925905.3408551.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n\\n        while(curr != NULL){\\n            ListNode* forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            \\n        }\\n        return prev;\\n    }\\n};\\n ```\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* prev = NULL;\\n        ListNode* h2 = reverseList(head->next);\\n        head->next->next = head;\\n        head->next=prev;\\n        return h2;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 58127,
                "title": "python-iterative-and-recursive-solution",
                "content": "    class Solution:\\n    # @param {ListNode} head\\n    # @return {ListNode}\\n    def reverseList(self, head):\\n        prev = None\\n        while head:\\n            curr = head\\n            head = head.next\\n            curr.next = prev\\n            prev = curr\\n        return prev\\n\\n\\nRecursion\\n\\n    class Solution:\\n    # @param {ListNode} head\\n    # @return {ListNode}\\n    def reverseList(self, head):\\n        return self._reverse(head)\\n\\n    def _reverse(self, node, prev=None):\\n        if not node:\\n            return prev\\n        n = node.next\\n        node.next = prev\\n        return self._reverse(n, node)",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {ListNode}",
                "codeTag": "Java"
            },
            {
                "id": 58130,
                "title": "c-iterative-and-recursive",
                "content": "Well, since the `head` pointer may also be modified, we create a `pre` that points to it to facilitate the reverse process.\\n\\nFor the example list `1 -> 2 -> 3 -> 4 -> 5` in the problem statement, it will become `0 -> 1 -> 2 -> 3 -> 4 -> 5` (we init `pre -> val` to be `0`). We also set a pointer `cur` to `head`. Then we keep inserting `cur -> next` after `pre` until `cur` becomes the last node. This idea uses three pointers (`pre`, `cur` and `temp`). You may implement it as follows.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *pre = new ListNode(0), *cur = head;\\n        pre -> next = head;\\n        while (cur && cur -> next) {\\n            ListNode* temp = pre -> next;\\n            pre -> next = cur -> next;\\n            cur -> next = cur -> next -> next;\\n            pre -> next -> next = temp;\\n        }\\n        return pre -> next;\\n    }\\n};\\n```\\n\\nOr\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *pre = new ListNode(0), *cur = head;\\n        pre -> next = head;\\n        while (cur && cur -> next) {\\n            ListNode* temp = cur -> next;\\n            cur -> next = temp -> next;\\n            temp -> next = pre -> next;\\n            pre -> next = temp;\\n        }\\n        return pre -> next;\\n    }\\n};\\n```\\n\\nWe can even use fewer pointers. The idea is to reverse one node at a time from the beginning of the list.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* cur = NULL;\\n        while (head) {\\n            ListNode* next = head -> next;\\n            head -> next = cur;\\n            cur = head;\\n            head = next;\\n        }\\n        return cur;\\n    }\\n};\\n```\\n\\nAll the above solutions are iterative. A recursive one is as follows. First reverse all the nodes after `head`. Then we need to set `head` to be the final node in the reversed list. We simply set its next node in the original list (`head -> next`) to point to it and sets its `next` to `NULL`. \\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if (!head || !(head -> next)) {\\n            return head;\\n        }\\n        ListNode* node = reverseList(head -> next);\\n        head -> next -> next = head;\\n        head -> next = NULL;\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *pre = new ListNode(0), *cur = head;\\n        pre -> next = head;\\n        while (cur && cur -> next) {\\n            ListNode* temp = pre -> next;\\n            pre -> next = cur -> next;\\n            cur -> next = cur -> next -> next;\\n            pre -> next -> next = temp;\\n        }\\n        return pre -> next;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *pre = new ListNode(0), *cur = head;\\n        pre -> next = head;\\n        while (cur && cur -> next) {\\n            ListNode* temp = cur -> next;\\n            cur -> next = temp -> next;\\n            temp -> next = pre -> next;\\n            pre -> next = temp;\\n        }\\n        return pre -> next;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* cur = NULL;\\n        while (head) {\\n            ListNode* next = head -> next;\\n            head -> next = cur;\\n            cur = head;\\n            head = next;\\n        }\\n        return cur;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if (!head || !(head -> next)) {\\n            return head;\\n        }\\n        ListNode* node = reverseList(head -> next);\\n        head -> next -> next = head;\\n        head -> next = NULL;\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458632,
                "title": "easy-0-ms-100-fully-explained-java-c-python-js-c-python3-recursive-iterative",
                "content": "# **Java Solution (Recursive Approach):**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.\\n```\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        // Special case...\\n        if (head == null || head.next == null) return head;\\n        // Create a new node to call the function recursively and we get the reverse linked list...\\n        ListNode res = reverseList(head.next);\\n        // Set head node as head.next.next...\\n        head.next.next = head;\\n        //set head\\'s next to be null...\\n        head.next = null;\\n        return res;     // Return the reverse linked list...\\n    }\\n}\\n```\\n\\n# **C++ Solution (Iterative Approach):**\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        // Special case...\\n        if(head == NULL || head->next == NULL)  return head;\\n        // Initialize prev pointer as the head...\\n        ListNode* prev = head;\\n        // Initialize curr pointer as the next pointer of prev...\\n        ListNode* curr = prev->next;\\n        // Initialize next of head pointer as NULL...\\n        head->next = NULL;\\n        // Run a loop till curr and prev points to NULL...\\n        while(prev != NULL && curr != NULL){\\n            // Initialize next pointer as the next pointer of curr...\\n            ListNode* next = curr->next;\\n            // Now assign the prev pointer to curr\\u2019s next pointer.\\n            curr->next = prev;\\n            // Assign curr to prev, next to curr...\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;    // Return the prev pointer to get the reverse linked list...\\n    }\\n};\\n```\\n\\n# **Python Solution (Iterative Approach):**\\nRuntime: 18 ms, faster than 97.75% of Python online submissions for Reverse Linked List.\\n```\\nclass Solution(object):\\n    def reverseList(self, head):\\n        # Initialize prev pointer as NULL...\\n        prev = None\\n        # Initialize the curr pointer as the head...\\n        curr = head\\n        # Run a loop till curr points to NULL...\\n        while curr:\\n            # Initialize next pointer as the next pointer of curr...\\n            next = curr.next\\n            # Now assign the prev pointer to curr\\u2019s next pointer.\\n            curr.next = prev\\n            # Assign curr to prev, next to curr...\\n            prev = curr\\n            curr = next\\n        return prev       # Return the prev pointer to get the reverse linked list...\\n```\\n                \\n# **JavaScript Solution (Recursive Approach):**\\n```\\nvar reverseList = function(head) {\\n    // Special case...\\n    if (head == null || head.next == null) return head;\\n    // Create a new node to call the function recursively and we get the reverse linked list...\\n    var res = reverseList(head.next);\\n    // Set head node as head.next.next...\\n    head.next.next = head;\\n    //set head\\'s next to be null...\\n    head.next = null;\\n    return res;     // Return the reverse linked list...\\n};\\n```\\n\\n# **C Language (Iterative Approach):**\\n```\\nstruct ListNode* reverseList(struct ListNode* head){\\n    // Special case...\\n    if(head == NULL || head->next == NULL)  return head;\\n    // Initialize prev pointer as the head...\\n    struct ListNode* prev = head;\\n    // Initialize curr pointer as the next pointer of prev...\\n    struct ListNode* curr = prev->next;\\n    // Initialize next of head pointer as NULL...\\n    head->next = NULL;\\n    // Run a loop till curr and prev points to NULL...\\n    while(prev != NULL && curr != NULL){\\n        // Initialize next pointer as the next pointer of curr...\\n        struct ListNode* next = curr->next;\\n        // Now assign the prev pointer to curr\\u2019s next pointer.\\n        curr->next = prev;\\n        // Assign curr to prev, next to curr...\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;    // Return the prev pointer to get the reverse linked list...\\n}\\n```\\n\\n# **Python3 Solution (Iterative Approach):**\\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Initialize prev pointer as NULL...\\n        prev = None\\n        # Initialize the curr pointer as the head...\\n        curr = head\\n        # Run a loop till curr points to NULL...\\n        while curr:\\n            # Initialize next pointer as the next pointer of curr...\\n            next = curr.next\\n            # Now assign the prev pointer to curr\\u2019s next pointer.\\n            curr.next = prev\\n            # Assign curr to prev, next to curr...\\n            prev = curr\\n            curr = next\\n        return prev       # Return the prev pointer to get the reverse linked list...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        // Special case...\\n        if (head == null || head.next == null) return head;\\n        // Create a new node to call the function recursively and we get the reverse linked list...\\n        ListNode res = reverseList(head.next);\\n        // Set head node as head.next.next...\\n        head.next.next = head;\\n        //set head\\'s next to be null...\\n        head.next = null;\\n        return res;     // Return the reverse linked list...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        // Special case...\\n        if(head == NULL || head->next == NULL)  return head;\\n        // Initialize prev pointer as the head...\\n        ListNode* prev = head;\\n        // Initialize curr pointer as the next pointer of prev...\\n        ListNode* curr = prev->next;\\n        // Initialize next of head pointer as NULL...\\n        head->next = NULL;\\n        // Run a loop till curr and prev points to NULL...\\n        while(prev != NULL && curr != NULL){\\n            // Initialize next pointer as the next pointer of curr...\\n            ListNode* next = curr->next;\\n            // Now assign the prev pointer to curr\\u2019s next pointer.\\n            curr->next = prev;\\n            // Assign curr to prev, next to curr...\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;    // Return the prev pointer to get the reverse linked list...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def reverseList(self, head):\\n        # Initialize prev pointer as NULL...\\n        prev = None\\n        # Initialize the curr pointer as the head...\\n        curr = head\\n        # Run a loop till curr points to NULL...\\n        while curr:\\n            # Initialize next pointer as the next pointer of curr...\\n            next = curr.next\\n            # Now assign the prev pointer to curr\\u2019s next pointer.\\n            curr.next = prev\\n            # Assign curr to prev, next to curr...\\n            prev = curr\\n            curr = next\\n        return prev       # Return the prev pointer to get the reverse linked list...\\n```\n```\\nvar reverseList = function(head) {\\n    // Special case...\\n    if (head == null || head.next == null) return head;\\n    // Create a new node to call the function recursively and we get the reverse linked list...\\n    var res = reverseList(head.next);\\n    // Set head node as head.next.next...\\n    head.next.next = head;\\n    //set head\\'s next to be null...\\n    head.next = null;\\n    return res;     // Return the reverse linked list...\\n};\\n```\n```\\nstruct ListNode* reverseList(struct ListNode* head){\\n    // Special case...\\n    if(head == NULL || head->next == NULL)  return head;\\n    // Initialize prev pointer as the head...\\n    struct ListNode* prev = head;\\n    // Initialize curr pointer as the next pointer of prev...\\n    struct ListNode* curr = prev->next;\\n    // Initialize next of head pointer as NULL...\\n    head->next = NULL;\\n    // Run a loop till curr and prev points to NULL...\\n    while(prev != NULL && curr != NULL){\\n        // Initialize next pointer as the next pointer of curr...\\n        struct ListNode* next = curr->next;\\n        // Now assign the prev pointer to curr\\u2019s next pointer.\\n        curr->next = prev;\\n        // Assign curr to prev, next to curr...\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;    // Return the prev pointer to get the reverse linked list...\\n}\\n```\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Initialize prev pointer as NULL...\\n        prev = None\\n        # Initialize the curr pointer as the head...\\n        curr = head\\n        # Run a loop till curr points to NULL...\\n        while curr:\\n            # Initialize next pointer as the next pointer of curr...\\n            next = curr.next\\n            # Now assign the prev pointer to curr\\u2019s next pointer.\\n            curr.next = prev\\n            # Assign curr to prev, next to curr...\\n            prev = curr\\n            curr = next\\n        return prev       # Return the prev pointer to get the reverse linked list...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 58156,
                "title": "my-java-recursive-solution",
                "content": "    public class Solution {\\n        public ListNode reverseList(ListNode head) {\\n            if(head==null || head.next==null)\\n                return head;\\n            ListNode nextNode=head.next;\\n            ListNode newHead=reverseList(nextNode);\\n            nextNode.next=head;\\n            head.next=null;\\n            return newHead;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode reverseList(ListNode head) {\\n            if(head==null || head.next==null)\\n                return head;\\n            ListNode nextNode=head.next;\\n            ListNode newHead=reverseList(nextNode);\\n            nextNode.next=head;\\n            head.next=null;\\n            return newHead;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 58338,
                "title": "python-solution-simple-iterative",
                "content": "I'm not sure if it's already posted here, but this is simple iterative approach. The idea is to change next with prev, prev with current, and current with next.\\n\\n    def reverseList(self, head):\\n        prev = None\\n        curr = head\\n\\n        while curr:\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n        \\n        return prev",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "I'm not sure if it's already posted here, but this is simple iterative approach. The idea is to change next with prev, prev with current, and current with next.\\n\\n    def reverseList(self, head):\\n        prev = None\\n        curr = head\\n\\n        while curr:\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n        \\n        return prev",
                "codeTag": "Python3"
            },
            {
                "id": 313728,
                "title": "javascript-es6-less-code-solution",
                "content": "```\\nvar reverseList = function(head) {\\n    let [prev, current] = [null, head]\\n    while(current) {\\n        [current.next, prev, current] = [prev, current, current.next]\\n    }\\n    return prev\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseList = function(head) {\\n    let [prev, current] = [null, head]\\n    while(current) {\\n        [current.next, prev, current] = [prev, current, current.next]\\n    }\\n    return prev\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711202,
                "title": "detailed-explanation-of-recursive-solution-alternate-simpler-recursive-solution",
                "content": "For anyone still trying to understand the recursive solution, here\\'s the step by step explanation, considering the example given in the question:\\n\\n`1 -> 2 -> 3 -> 4 -> 5`\\n\\nFor the first 4 calls of the `reverseList` function, we just go into the call stack, as the base case is not hit. When we call the function for the 5th time, that is, `reverseList(5)`, we reach the base case as `5.next == null`, so we return at this point to the 4th call in the stack, that is, `reverseList(4)`. Now, for this 4th node, p is set equal to the returned value (5th node) and essentially this is the only time p gets updated in the whole solution. After this point, p\\'s value is just passed across stack calls so that it can be returned as the new head.\\nBack to the next line in the 4th stack call, `head.next.next = head`. This line simply means, make the `next node` of the `current node`, point to the `current node`. So, `5.next` is set equal to 4th node.\\nNext line says, `head.next = null` and this seems a bit confusing but it really isn\\'t. This line has no significance for any other node except the (new) last one, that is, for the node containing `1` as value. This statement is just used to set the value of `1.next` as `null`. For all other nodes, this line means nothing as it gets overwritten as we move back further in the call stack. Let\\'s understand by going further in the example:\\nSo, at this point, we have `p = 5`, `5.next = 4`, `4.next = null`, and now we move back in the call stack to `reverseList(3)`. Here again we have `head.next.next = head`, which basically means, `4.next = 3`. So you see, the `head.next = null` had no impact on the 4th node as it was updated in the next call. Going forward in a similar manner, you will observe, the value set by `head.next = null` gets overwritten for every node except for the first one, where there\\'s no next call to update it, which mean, `1.next = null`, which is what we want in the final linked list.\\nLastly, every stack call returns `p` which was just set in the last call when we were going in (`p = 5`) and as I said before, it doesn\\'t get updated in any call after that, so it just serves to return the new head of the reversed list.\\n\\nHope this makes it clearer for you. If you still find the recursive solution difficult to understand, I have an alternative recursive solution which uses 2 variables as a substitute to `head.next.next`, which may seem easier:\\n\\n```\\nclass Solution:\\n    def flipMapping(self, curr, nex):\\n        if nex.next:\\n            self.flipMapping(curr.next, nex.next)\\n        else:\\n            self.new_head = nex\\n        \\n        nex.next = curr\\n    \\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        \\n        self.new_head = None   \\n        self.flipMapping(head, head.next)   \\n        head.next = None   \\n        return(self.new_head)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def flipMapping(self, curr, nex):\\n        if nex.next:\\n            self.flipMapping(curr.next, nex.next)\\n        else:\\n            self.new_head = nex\\n        \\n        nex.next = curr\\n    \\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        \\n        self.new_head = None   \\n        self.flipMapping(head, head.next)   \\n        head.next = None   \\n        return(self.new_head)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246827,
                "title": "python-iterative-recursive",
                "content": "To reverse a linked list, we actually reverse the direction of every next pointer. \\nFor example, we reverse a linked list 1->2->3->4->5 by changing every -> to <- and get the result as 1<-2<-3<-4<-5. And we need to return the pointer to 5 instead of to 1.\\nTo solve it efficiently, we can do it in one loop iteration or recursion.\\n\\nFor iteration, we create a ListNode **rev** to keep track of what we have reversed otherwise we would lose it. Then we iterate linked list and make **head** point to the current node. We change a -> to <- by calling **head.next = rev**, update rev by calling **rev = head**, move to next node by calling **head = head.next**. To save a temporary variable, we could assign these variables **in one line**, but **head.next** and **rev** should be updated before **head** is updated otherwise direction would not be reversed and **rev** would keep pointing to itself.\\nFor example, 1->2->3, 1 is current node **head,** what we have reversed **rev** is None,  2 is **head.next**. Calling **head.next = rev** leads to **None<-1**. Calling **head = head.next** concurrently to make head pointing to 2->3. Updating rev as **1->None**. And in next iteration, we will change 2->3 to 1<-2 and keep changing -> to <- so on so forth.\\n```\\ndef reverseListIter(head):\\n\\trev = None\\n\\twhile head: \\n\\t\\thead.next, rev, head = rev, head, head.next\\n\\treturn rev\\n```\\nFor recursion, the bottom layer is the end of the origin linked list so we just return it. For the outer layer, for example, 4->5, we change -> to <- by calling **head.next.next = head** where **head** points at 4 and **head.next** points at 5. **node**, which is **self.reverseList(head.next)** also points at 5 or 5->4, is what we need to return in this layer. So when we keep returning to the outer layer, reversed linked list keep growing (a -> b becomes a <- b as **head.next.next = head**)\\nAnother example, in some recursion, you have linked list **1->2->3->null**, reversed linked list **5->4->3->null**. **head** points at **2**, **head.next** points at **3**, **5->4->3->null** is what you have reversed and stored in **node=reversedList(head.next)**. Now you need to place 2 to the end of 5->4->3. So you call **head.next.next = head** or **3.next = 2**, and **head.next = null** or **2.next = null**. Then you have original linked list **1->2->null**, and reversed linked list (head node 5 stored in **node**) **5->4->3->2->null**. Then you return these to outer recursion.\\n```\\ndef reverseListRecu(head):\\n\\tif not head or not head.next: return head\\n\\tnode, head.next.next, head.next = reverseListRecu(head.next), head, None\\n\\treturn node\\n```\\nOne thing should be notice that we should always be fully aware of what a variable points at. The **rev** and **reverseList_Recu(node)** point at the head of the reversed linked list while the current node **head** that we are visiting in origin linked list point at the tail of the reversed linked list.\\nBoth methods take a liner scan without extra space. So time complexity is O(n) and space is O(1).",
                "solutionTags": [],
                "code": "```\\ndef reverseListIter(head):\\n\\trev = None\\n\\twhile head: \\n\\t\\thead.next, rev, head = rev, head, head.next\\n\\treturn rev\\n```\n```\\ndef reverseListRecu(head):\\n\\tif not head or not head.next: return head\\n\\tnode, head.next.next, head.next = reverseListRecu(head.next), head, None\\n\\treturn node\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 440696,
                "title": "easy-to-understand-recursive-solution-beats-98-takes-2-arguments",
                "content": "Each call goes something like this : \\n1->2->3 to 3->2->1\\n\\n(1, null ) :\\nnext =2 ;\\n1->next = null;\\nreturn (2,1)\\n\\n(2, 1)\\nnext = 3;\\n2->next = 1;\\nreturn (3,2)\\n\\n(3,2)\\nnext = null;\\n3->next = 2;\\nreturn (null, 3)\\n\\n(null, 3)\\nreturn 3; **( the new head node )**\\n\\n```\\n  ListNode* helper(ListNode* head, ListNode* prev) {\\n        if (!head) return prev;\\n        ListNode* next = head->next;\\n        head->next = prev;\\n        return helper(next, head);\\n      \\n        \\n    }\\n    \\n    ListNode* reverseList(ListNode* head) {       \\n        return helper (head, NULL);\\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "Each call goes something like this : \\n1->2->3 to 3->2->1\\n\\n(1, null ) :\\nnext =2 ;\\n1->next = null;\\nreturn (2,1)\\n\\n(2, 1)\\nnext = 3;\\n2->next = 1;\\nreturn (3,2)\\n\\n(3,2)\\nnext = null;\\n3->next = 2;\\nreturn (null, 3)\\n\\n(null, 3)\\nreturn 3; **( the new head node )**\\n\\n```\\n  ListNode* helper(ListNode* head, ListNode* prev) {\\n        if (!head) return prev;\\n        ListNode* next = head->next;\\n        head->next = prev;\\n        return helper(next, head);\\n      \\n        \\n    }\\n    \\n    ListNode* reverseList(ListNode* head) {       \\n        return helper (head, NULL);\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 58495,
                "title": "accepted-c-solutions-both-iteratively-and-recursively",
                "content": "    struct ListNode* reverseList(struct ListNode* head) {\\n    \\tif(NULL==head) return head;\\n    \\n    \\tstruct ListNode *p=head;\\n    \\tp=head->next;\\n    \\thead->next=NULL;\\n    \\twhile(NULL!=p){\\n    \\t\\tstruct ListNode *ptmp=p->next;\\n    \\t\\tp->next=head;\\n    \\t\\thead=p;\\n    \\t\\tp=ptmp;\\n    \\t}\\n    \\treturn head;\\n    }\\n\\n\\nabove is the iterative one. simple, nothing to explain.\\n----------\\n\\n\\n    struct ListNode* reverseListRe(struct ListNode* head) {\\n    \\tif(NULL==head||NULL==head->next) return head;\\n    \\n    \\tstruct ListNode *p=head->next;\\n    \\thead->next=NULL;\\n    \\tstruct ListNode *newhead=reverseListRe(p);\\n    \\tp->next=head;\\n    \\n    \\treturn newhead;\\n    }\\n\\nabove is the recursively one.Both are accepted.\\n----------",
                "solutionTags": [],
                "code": "    struct ListNode* reverseList(struct ListNode* head) {\\n    \\tif(NULL==head) return head;\\n    \\n    \\tstruct ListNode *p=head;\\n    \\tp=head->next;\\n    \\thead->next=NULL;\\n    \\twhile(NULL!=p){\\n    \\t\\tstruct ListNode *ptmp=p->next;\\n    \\t\\tp->next=head;\\n    \\t\\thead=p;\\n    \\t\\tp=ptmp;\\n    \\t}\\n    \\treturn head;\\n    }\\n\\n\\nabove is the iterative one. simple, nothing to explain.\\n----------\\n\\n\\n    struct ListNode* reverseListRe(struct ListNode* head) {\\n    \\tif(NULL==head||NULL==head->next) return head;\\n    \\n    \\tstruct ListNode *p=head->next;\\n    \\thead->next=NULL;\\n    \\tstruct ListNode *newhead=reverseListRe(p);\\n    \\tp->next=head;\\n    \\n    \\treturn newhead;\\n    }\\n\\nabove is the recursively one.Both are accepted.\\n----------",
                "codeTag": "Unknown"
            },
            {
                "id": 869957,
                "title": "javascript-iterative-and-recursive-solution",
                "content": "My Javascript solution based on [Back To Back SWE](https://www.youtube.com/watch?v=O0By4Zq0OFc&feature=youtu.be)\\n\\n## Iterative\\n- Time: O(n)\\n- Space: O(1)\\n\\n```jsx\\nvar reverseList = function(head) {\\n    let prev = null\\n    let curr = head\\n    let next = null\\n    \\n    while(curr!== null){\\n        // save next\\n        next = curr.next\\n        // reverse\\n        curr.next = prev\\n        // advance prev and curr\\n        prev = curr\\n        curr = next\\n    }\\n    return prev;\\n};\\n```\\n\\n## ES6 code\\n```\\nvar reverseList = function(head) {\\n    let [prev, current] = [null, head]\\n    while(current) {\\n        [current.next, prev, current] = [prev, current, current.next]\\n    }\\n    return prev\\n}\\n```\\n\\n### Recursive\\n\\n- Time: O(n)\\n- Space: O(n)\\n\\n```jsx\\nvar reverseList = function(head) {\\n\\t// base case\\n    if (head == null || head.next == null){\\n        return head;\\n    }\\n\\t// go all the way to the end\\n    let reversedListHead = reverseList(head.next)\\n\\t// add reverse myself\\n    head.next.next = head;\\n    head.next = null;\\n\\t// go up\\n    return reversedListHead\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```jsx\\nvar reverseList = function(head) {\\n    let prev = null\\n    let curr = head\\n    let next = null\\n    \\n    while(curr!== null){\\n        // save next\\n        next = curr.next\\n        // reverse\\n        curr.next = prev\\n        // advance prev and curr\\n        prev = curr\\n        curr = next\\n    }\\n    return prev;\\n};\\n```\n```\\nvar reverseList = function(head) {\\n    let [prev, current] = [null, head]\\n    while(current) {\\n        [current.next, prev, current] = [prev, current, current.next]\\n    }\\n    return prev\\n}\\n```\n```jsx\\nvar reverseList = function(head) {\\n\\t// base case\\n    if (head == null || head.next == null){\\n        return head;\\n    }\\n\\t// go all the way to the end\\n    let reversedListHead = reverseList(head.next)\\n\\t// add reverse myself\\n    head.next.next = head;\\n    head.next = null;\\n\\t// go up\\n    return reversedListHead\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2715387,
                "title": "very-easy-and-fast-python-solution",
                "content": "```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        prev=None\\n        while(head):\\n            nxt=head.next\\n            head.next=prev\\n            prev=head\\n            head=nxt\\n        return prev\\n            \\n```\\n\\n**Explanation**\\nOne think to keep in mind, we are not going change the value of node, actually we are just reversing the link between the nodes. address of nodes will remain same; values will remain same only the connection between nodes get reversed.\\n![image](https://assets.leetcode.com/users/images/3bce9aca-20e6-4bf3-ae4e-770c64a09771_1666187753.9647837.jpeg)\\n",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        prev=None\\n        while(head):\\n            nxt=head.next\\n            head.next=prev\\n            prev=head\\n            head=nxt\\n        return prev\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475050,
                "title": "very-very-easy-c-code",
                "content": "Upvote if you liked it\\n\\n```\\nListNode* reverseList(ListNode* head) {\\n        ListNode *b=NULL,*c=NULL;\\n        \\n        while(head!=NULL)\\n        {\\n            c=b;\\n            b=head;\\n            head=head->next;\\n            b->next=c;\\n        }\\n        return b;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* reverseList(ListNode* head) {\\n        ListNode *b=NULL,*c=NULL;\\n        \\n        while(head!=NULL)\\n        {\\n            c=b;\\n            b=head;\\n            head=head->next;\\n            b->next=c;\\n        }\\n        return b;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 58291,
                "title": "javascript-solution-both-iterative-and-recursive",
                "content": "\\n\\n    function reverseList(head) {\\n        var prev = null;\\n        while (head) {\\n            var next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n    \\n    \\n    function reverseList(head) {\\n        if (!head || !head.next) {\\n            return head;\\n        }\\n        var newHead = reverseList(head.next);\\n        head.next.next = head;\\n        head.next = null;\\n        return newHead;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n    function reverseList(head) {\\n        var prev = null;\\n        while (head) {\\n            var next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n    \\n    \\n    function reverseList(head) {\\n        if (!head || !head.next) {\\n            return head;\\n        }\\n        var newHead = reverseList(head.next);\\n        head.next.next = head;\\n        head.next = null;\\n        return newHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 58293,
                "title": "8ms-golang-solution",
                "content": "    func reverseList(head *ListNode) *ListNode {\\n    \\tvar prev *ListNode\\n    \\tfor head != nil {\\n    \\t\\thead.Next, prev, head = prev, head, head.Next\\n    \\t}\\n    \\treturn prev\\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    func reverseList(head *ListNode) *ListNode {\\n    \\tvar prev *ListNode\\n    \\tfor head != nil {\\n    \\t\\thead.Next, prev, head = prev, head, head.Next\\n    \\t}\\n    \\treturn prev\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 58337,
                "title": "fast-recursive-java-solution",
                "content": "    public class Solution {\\n        public ListNode reverseList(ListNode head) {\\n            if(head == null ||head.next == null){\\n                return head;\\n            }\\n            \\n            ListNode root = reverseList(head.next);\\n            \\n            head.next.next = head;\\n            head.next = null;\\n            return root;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode reverseList(ListNode head) {\\n            if(head == null ||head.next == null){\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 58429,
                "title": "python-iterative-and-recursive-solution-both-o-n-time-complexity",
                "content": "    # Iteratively\\n    def reverseList1(self, head):\\n        node = None\\n        while head:\\n            tmp = head.next\\n            head.next = node\\n            node = head\\n            head = tmp\\n        return node\\n     \\n    # Recursively    \\n    def reverseList(self, head):\\n        return self.helper(head, None)\\n        \\n    def helper(self, head, node):\\n        if not head:\\n            return node\\n        tmp = head.next\\n        head.next = node\\n        return self.helper(tmp, head)",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "    # Iteratively\\n    def reverseList1(self, head):\\n        node = None\\n        while head:\\n            tmp = head.next\\n            head.next = node\\n            node = head\\n            head = tmp\\n        return node\\n     \\n    # Recursively    \\n    def reverseList(self, head):\\n        return self.helper(head, None)\\n        \\n    def helper(self, head, node):\\n        if not head:\\n            return node\\n        tmp = head.next\\n        head.next = node\\n        return self.helper(tmp, head)",
                "codeTag": "Python3"
            },
            {
                "id": 3620367,
                "title": "best-method-100-c-java-python-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code snippet implements the iterative approach to reverse a linked list. The intuition behind it is to use three pointers: `prev`, `head`, and `nxt`. By reversing the pointers between the nodes, we can reverse the linked list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a pointer `prev` and initialize it to `NULL`. This pointer will initially be the new end of the reversed linked list.\\n2. Start iterating through the linked list with a pointer `head`.\\n3. Inside the loop, create a pointer `nxt` and assign it the next node after `head`. This pointer is used to store the next node temporarily.\\n4. Reverse the pointer direction of `head` by setting `head->next` to `prev`. This step effectively reverses the direction of the current node.\\n5. Move the `prev` pointer to `head` and update `head` to `nxt` for the next iteration.\\n6. Repeat steps 3-5 until the end of the linked list is reached (i.e., `head` becomes `NULL`).\\n7. Return `prev`, which will be the new head of the reversed linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;\\n\\n        while(head) {\\n            ListNode* nxt = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = nxt;\\n        }\\n        return prev;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n\\n        while (head != null) {\\n            ListNode nxt = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = nxt;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n\\n        while head:\\n            nxt = head.next\\n            head.next = prev\\n            prev = head\\n            head = nxt\\n\\n        return prev\\n```\\n![LinkedList.png](https://assets.leetcode.com/users/images/cb5a5f31-11f8-4769-b61c-52a030eb1b6f_1686373901.2809415.png)\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/378463b5-c705-4ca8-b219-a4370adb789b_1686373921.123018.png)\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;\\n\\n        while(head) {\\n            ListNode* nxt = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = nxt;\\n        }\\n        return prev;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n\\n        while (head != null) {\\n            ListNode nxt = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = nxt;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n\\n        while head:\\n            nxt = head.next\\n            head.next = prev\\n            prev = head\\n            head = nxt\\n\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477639,
                "title": "rust-100",
                "content": "```\\nimpl Solution {\\n    pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let (mut prev, mut curr) = (None, head);\\n        while let Some(mut node) = curr  {\\n            curr = node.next;\\n      \\n            node.next = prev;\\n            \\n            prev = Some(node);\\n        }\\n        prev\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let (mut prev, mut curr) = (None, head);\\n        while let Some(mut node) = curr  {\\n            curr = node.next;\\n      \\n            node.next = prev;\\n            \\n            prev = Some(node);\\n        }\\n        prev\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 58458,
                "title": "iteratively-and-recursively-java-solution",
                "content": "\\tpublic class Solution {\\n\\t    public ListNode reverseList(ListNode head) {\\n\\t    \\tif(head == null) return head;\\n\\t    \\t\\n\\t    \\tListNode next = head.next;\\n\\t    \\thead.next = null;\\n\\t        \\n\\t    \\twhile(next != null){\\n\\t        \\tListNode temp = next.next;\\n\\t        \\tnext.next = head;\\n\\t        \\thead = next;\\n\\t        \\tnext = temp;\\n\\t        }\\n\\t    \\treturn head;\\n\\t    }\\n\\t}\\n\\n\\n\\tpublic class Solution {\\n\\t    public ListNode reverseList(ListNode head) {\\n\\t    \\tif(head == null) return head;\\n\\t    \\tListNode next = head.next;\\n\\t    \\thead.next = null;\\n\\t    \\t\\n\\t    \\treturn recursive(head,next);\\n\\t    }\\n\\t    \\n\\t    private ListNode recursive(ListNode head, ListNode next){\\n\\t    \\tif(next == null)\\treturn head;\\n\\t    \\tListNode temp = next.next;\\n\\t    \\tnext.next = head;\\n\\t    \\treturn recursive(next,temp);\\n\\t    \\t\\n\\t    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t    public ListNode reverseList(ListNode head) {\\n\\t    \\tif(head == null) return head;\\n\\t    \\t\\n\\t    \\tListNode next = head.next;\\n\\t    \\thead.next = null;\\n\\t        \\n\\t    \\twhile(next != null){\\n\\t        \\tListNode temp = next.next;\\n\\t        \\tnext.next = head;\\n\\t        \\thead = next;\\n\\t        \\tnext = temp;\\n\\t        }",
                "codeTag": "Java"
            },
            {
                "id": 2105240,
                "title": "reverse-linked-list-easy-recursive-solution-with-image-explanation",
                "content": "Easy C++ solution--->\\n Let us take an example->\\n \\n ![image](https://assets.leetcode.com/users/images/96b7d4a6-64b6-4a11-922e-55c148b558a7_1654239510.008161.png)\\n\\n1) reverseByRecursion(node1) is called.\\n2) Neither node1 nor node1->next is NULL, so newHead = reverseList(head2); is called.\\n3) Neither node2 nor node2->next is NULL, so newHead = reverseList(head3); is called.\\n4) head3->next is NULL, so head3 is returned from reverseList(head3).\\n5) head = node2 and head->next = node3, so head->next->next = head; will set node3->next to node2.\\n6) head->next = NULL; will set node2->next to NULL. (image 2)\\n7) newHead, which is node3, is returned from reverseList(head2).\\n8) head = node1 and head->next = node2, so head->next->next = head; will set node2->next to node1.\\n9) head->next = NULL; will set node1->next to NULL. (image 3)\\n10) newHead, which is node3, is returned from reverseList(node1).\\n11) Now the list is reversed with having node3 as the head.\\n       \\n\\t   **image 2**\\n  \\n       ![image](https://assets.leetcode.com/users/images/2e6f2ddf-4f5e-4892-bdc0-99d27289ff9d_1654239786.5388136.png)\\n\\n   **image 3**\\n\\n![image](https://assets.leetcode.com/users/images/9791019b-b072-42e3-ac2a-622cef5e9aa2_1654239949.2522185.png)\\n\\nimplimentation--->\\n\\n```\\n    ListNode* reverseList(ListNode* head) {\\n        \\n   if (head == NULL || head->next == NULL) return head;\\n        \\n        ListNode* newHead  = reverseList(head->next);\\n        \\n        head->next->next = head;\\n        head->next = NULL;\\n        \\n        return newHead ;\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n    ListNode* reverseList(ListNode* head) {\\n        \\n   if (head == NULL || head->next == NULL) return head;\\n        \\n        ListNode* newHead  = reverseList(head->next);\\n        \\n        head->next->next = head;\\n        head->next = NULL;\\n        \\n        return newHead ;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514220,
                "title": "c-python-simple-iterative-solution",
                "content": "**C++ :**\\n\\n```\\nListNode* reverseList(ListNode* head) {\\n\\tListNode *nextNode, *prevNode = NULL;\\n\\twhile (head) {\\n\\t\\tnextNode = head->next;\\n\\t\\thead->next = prevNode;\\n\\t\\tprevNode = head;\\n\\t\\thead = nextNode;\\n\\t}\\n\\treturn prevNode;\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tprev = None\\n\\n\\twhile head:\\n\\t\\tnext_node = head.next\\n\\t\\thead.next = prev\\n\\t\\tprev = head\\n\\t\\thead = next_node\\n\\n\\treturn prev\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nListNode* reverseList(ListNode* head) {\\n\\tListNode *nextNode, *prevNode = NULL;\\n\\twhile (head) {\\n\\t\\tnextNode = head->next;\\n\\t\\thead->next = prevNode;\\n\\t\\tprevNode = head;\\n\\t\\thead = nextNode;\\n\\t}\\n\\treturn prevNode;\\n}\\n```\n```\\ndef reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tprev = None\\n\\n\\twhile head:\\n\\t\\tnext_node = head.next\\n\\t\\thead.next = prev\\n\\t\\tprev = head\\n\\t\\thead = next_node\\n\\n\\treturn prev\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 645833,
                "title": "0ms-100-faster-100-less-memory",
                "content": "Iterative solution\\nLanguage: Go\\nSpeed: 0ms\\nMemory: 2.5 MB\\n```\\nfunc reverseList(head *ListNode) (prev *ListNode) {\\n\\tfor head != nil {\\n\\t\\thead.Next, prev, head = prev, head, head.Next\\n\\t}\\n\\treturn\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reverseList(head *ListNode) (prev *ListNode) {\\n\\tfor head != nil {\\n\\t\\thead.Next, prev, head = prev, head, head.Next\\n\\t}\\n\\treturn\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 58272,
                "title": "java-iterative-0ms-solution-with-explanation",
                "content": "This seems to be a classic question that I have received multiple times in real interviews.  Typically, it is asked as a phone screen or initial screening questions.  Regardless, it can seem a bit tricky but it really doesn't take a whole lot of code to accomplish this.  \\n\\nMy solution is as follows:\\n\\n    public ListNode reverseList(ListNode head) {\\n        // is there something to reverse?\\n        if (head != null && head.next != null)\\n        {\\n            ListNode pivot = head;\\n            ListNode frontier = null;\\n            while (pivot != null && pivot.next != null)\\n            {\\n                frontier = pivot.next;\\n                pivot.next = pivot.next.next;\\n                frontier.next = head;\\n                head = frontier;\\n            }\\n        }\\n        \\n        return head;\\n    } \\n\\nThis is a very quick, O(n) reversal that times at 0ms in Leetcode OJ.  The trick is to think of the first element  as the new last item in the list.  After reversing, this must be true.  Then, we just move the element that pivot .next points to (the initial head of the list) and we move it to become the new head.  This essentially grows the list backwards until the initial pivot no longer has anything to move.  \\n\\nFor example; if we have a list [1, 2, 3, 4], the algorithm will do the following:\\n- Set pivot to 1, set frontier to 2, keep head at 1\\n- We see that pivot still has items after it, so set pivots .next to .next.next, and move the pivot to be set to the current head\\n- Now move the head back to point to the new head, which is the frontier node we just set\\n- Now reset frontier to pivots .next and repeat. \\n\\nSo with each iteration of the loop the list becomes:\\n- [1, 2, 3, 4]\\n- [2, 1, 3, 4]\\n- [3, 2, 1, 4]\\n- [4, 3, 2, 1]\\n\\nThen we return the new final head which points to 4.",
                "solutionTags": [],
                "code": "This seems to be a classic question that I have received multiple times in real interviews.  Typically, it is asked as a phone screen or initial screening questions.  Regardless, it can seem a bit tricky but it really doesn't take a whole lot of code to accomplish this.  \\n\\nMy solution is as follows:\\n\\n    public ListNode reverseList(ListNode head) {\\n        // is there something to reverse?\\n        if (head != null && head.next != null)\\n        {\\n            ListNode pivot = head;\\n            ListNode frontier = null;\\n            while (pivot != null && pivot.next != null)\\n            {\\n                frontier = pivot.next;\\n                pivot.next = pivot.next.next;\\n                frontier.next = head;\\n                head = frontier;\\n            }\\n        }\\n        \\n        return head;\\n    } \\n\\nThis is a very quick, O(n) reversal that times at 0ms in Leetcode OJ.  The trick is to think of the first element  as the new last item in the list.  After reversing, this must be true.  Then, we just move the element that pivot .next points to (the initial head of the list) and we move it to become the new head.  This essentially grows the list backwards until the initial pivot no longer has anything to move.  \\n\\nFor example; if we have a list [1, 2, 3, 4], the algorithm will do the following:\\n- Set pivot to 1, set frontier to 2, keep head at 1\\n- We see that pivot still has items after it, so set pivots .next to .next.next, and move the pivot to be set to the current head\\n- Now move the head back to point to the new head, which is the frontier node we just set\\n- Now reset frontier to pivots .next and repeat. \\n\\nSo with each iteration of the loop the list becomes:\\n- [1, 2, 3, 4]\\n- [2, 1, 3, 4]\\n- [3, 2, 1, 4]\\n- [4, 3, 2, 1]\\n\\nThen we return the new final head which points to 4.",
                "codeTag": "Java"
            },
            {
                "id": 58360,
                "title": "my-0ms-10-line-java-solution",
                "content": "    public ListNode reverseList(ListNode head) {\\n        ListNode curr = null;\\n        ListNode temp = head;\\n        ListNode prev = null;\\n        while(temp != null){\\n            prev = curr;\\n            curr = temp;\\n            temp = curr.next;\\n            curr.next = prev;\\n        }\\n        return curr; \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode reverseList(ListNode head) {\\n        ListNode curr = null;\\n        ListNode temp = head;\\n        ListNode prev = null;\\n        while(temp != null){\\n            prev = curr;\\n            curr = temp;\\n            temp = curr.next;\\n            curr.next = prev;\\n        }\\n        return curr; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 58460,
                "title": "the-simplest-way-on-javascript",
                "content": "    var reverseList = function(head){\\n      \\n      var tmp = null;\\n      var newHead = null;\\n      while(head !== null){\\n        tmp = head;\\n        head = head.next;\\n        tmp.next = newHead;\\n        newHead = tmp;\\n      }\\n      \\n      return newHead;\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var reverseList = function(head){\\n      \\n      var tmp = null;\\n      var newHead = null;\\n      while(head !== null){\\n        tmp = head;\\n        head = head.next;\\n        tmp.next = newHead;\\n        newHead = tmp;\\n      }\\n      \\n      return newHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 210873,
                "title": "javascript",
                "content": "```\\nvar reverseList = function(head) {\\n    let pre = null\\n    while(head){\\n        const next = head.next\\n        head.next = pre\\n        pre = head\\n        head = next\\n    }\\n    return pre\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseList = function(head) {\\n    let pre = null\\n    while(head){\\n        const next = head.next\\n        head.next = pre\\n        pre = head\\n        head = next\\n    }\\n    return pre\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2445567,
                "title": "very-easy-to-understand-in-python",
                "content": "\\n![image](https://assets.leetcode.com/users/images/2b86378e-05fd-4bff-a789-2e0b9224feaa_1661265253.8641996.png)\\n  \\n\\nref :: https://learnersbucket.com/examples/algorithms/learn-how-to-reverse-a-linked-list/ \\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        pre = None\\n        nxt = None\\n        while(curr):\\n            nxt = curr.next # hold the next address of curr\\n            curr.next = pre # connect current to pre \" <- \" (reverse node)\\n            pre = curr # move previous\\n            curr = nxt # move curr \\n            \\n        return pre\\n        \\n```\\nplease upvote if you like",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n        pre = None\\n        nxt = None\\n        while(curr):\\n            nxt = curr.next # hold the next address of curr\\n            curr.next = pre # connect current to pre \" <- \" (reverse node)\\n            pre = curr # move previous\\n            curr = nxt # move curr \\n            \\n        return pre\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449640,
                "title": "python-2-pointers-solution-explained",
                "content": "The idea is to keep `2` pointers for current and next node and then iterate through nodes and reconnect nodes. The best way to understand this solution is to take some small list, for example `1 -> 2 -> 3 -> 4 -> None` and see what is going on on the each step.\\n\\n1. In the beginning `curr = None, nxt = 1`.\\n2. On the first step we have: `tmp = 2`, `nxt.next = None`, `curr = 1`, `nxt = 2`. So what we have is the following: `None <- 1  2 -> 3 -> 4 -> None`. That is we cut one link between `1` and `2` and create new link `1 -> None`.\\n3. On the next step we have `None <- 1 <- 2  3 -> 4 -> None` and so on.\\n\\nTry to draw it on the paper, step by step, it is the best way to feel it.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def reverseList(self, head):\\n        curr = None\\n        nxt = head\\n        while nxt:\\n            tmp = nxt.next\\n            nxt.next = curr\\n            curr = nxt\\n            nxt = tmp\\n            \\n        return curr\\n```",
                "solutionTags": [
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseList(self, head):\\n        curr = None\\n        nxt = head\\n        while nxt:\\n            tmp = nxt.next\\n            nxt.next = curr\\n            curr = nxt\\n            nxt = tmp\\n            \\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609282,
                "title": "python-recursion-highly-commented-99",
                "content": "Standard recursive approach. Traverse to end of linked list with recursive calls. Now ```orig_head``` is end node, and head is the node before that. Then swap nodes at each step and finally return the ```orig_head``` as the ```head``` of the reversed linked list.\\n``` \\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        if not head: return head #Empty.\\n        if not head.next: return head #We reached end.\\n        orig_head = self.reverseList(head.next) #Traverse to end, orig_head is now end node.\\n        head.next.next = head #Swap head with right node.\\n        head.next = None #So we don\\'t wind up in infinite loop.\\n        return orig_head #Very last thing returned. End node!\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```orig_head```\n```orig_head```\n```head```\n``` \\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        if not head: return head #Empty.\\n        if not head.next: return head #We reached end.\\n        orig_head = self.reverseList(head.next) #Traverse to end, orig_head is now end node.\\n        head.next.next = head #Swap head with right node.\\n        head.next = None #So we don\\'t wind up in infinite loop.\\n        return orig_head #Very last thing returned. End node!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 370958,
                "title": "js-iterative-solution-with-comments",
                "content": "```\\n// Time Complexity: O(n), Linear - traverse linked list only once\\n// Space Complexity: O(1), Constant - we will only have 2 pointers regardless of size of input; prev and temp\\n\\nvar reverseList = function(head) {\\n    // End of the reversed linked list set to null\\n    let prev = null;\\n    \\n    // Traverse through the given linked list\\n    while (head) {\\n        const temp = head.next;     // References the next Node of given linked list\\n        head.next = prev;       // head.next point to previous Node, instead of the next Node of the given linked list\\n        prev = head;        // Move the prev Node pointer up to head\\n        head = temp;        // Move the head up to next Node of the given linked list\\n    }\\n    \\n    // Prev is the reversed linked list\\n    return prev;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Time Complexity: O(n), Linear - traverse linked list only once\\n// Space Complexity: O(1), Constant - we will only have 2 pointers regardless of size of input; prev and temp\\n\\nvar reverseList = function(head) {\\n    // End of the reversed linked list set to null\\n    let prev = null;\\n    \\n    // Traverse through the given linked list\\n    while (head) {\\n        const temp = head.next;     // References the next Node of given linked list\\n        head.next = prev;       // head.next point to previous Node, instead of the next Node of the given linked list\\n        prev = head;        // Move the prev Node pointer up to head\\n        head = temp;        // Move the head up to next Node of the given linked list\\n    }\\n    \\n    // Prev is the reversed linked list\\n    return prev;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1501014,
                "title": "c-2-short-o-n-code-iterative-recursive-easy-code",
                "content": "**Approach 1: Iterative**\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *pre = NULL, *cur = head, *nex;\\n        \\n        while(cur != NULL){\\n            nex = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = nex;\\n        }\\n        \\n        return pre;\\n    }\\n};\\n```\\n**Approach 2: Recursive**\\n```\\nclass Solution {        \\n    public:\\n        \\n        ListNode* helper(ListNode *pre, ListNode *root){\\n            if(root == NULL)\\n                return pre;\\n            ListNode *t = root->next;\\n            root->next = pre;\\n            return helper(root,t);            \\n        }\\n    \\n        ListNode* reverseList(ListNode* root) {\\n            return helper(NULL, root);\\n        }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *pre = NULL, *cur = head, *nex;\\n        \\n        while(cur != NULL){\\n            nex = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = nex;\\n        }\\n        \\n        return pre;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899654,
                "title": "java-simple-solution-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n------\\n\\n1. We use three pointers to perform the reversing: prev, next, head.\\n2. Point the current node to head and assign its next value to the prev node.\\n3. Iteratively repeat the step 2 for all the nodes in the list.\\n4. Assign head to the prev node.\\n\\n![image.png](https://assets.leetcode.com/users/images/315ddef6-bde6-487c-91b5-819452fd0868_1691849968.8248606.png)\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode cur = head;\\n        ListNode temp = null;\\n\\n        while(cur != null)\\n        {   \\n            temp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = temp;\\n        }\\n            head = prev;\\n        \\n            return head;\\n        \\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/38c23ad1-23e9-4425-86ec-a7538326cc78_1691849749.8522763.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode cur = head;\\n        ListNode temp = null;\\n\\n        while(cur != null)\\n        {   \\n            temp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = temp;\\n        }\\n            head = prev;\\n        \\n            return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223171,
                "title": "206-space-beats-99-79-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo reverse a singly linked list, we need to change the pointers of each node to point to the previous node instead of the next node.\\n\\nWe can start by initializing three pointers:\\n\\n- prev: a pointer to the previous node, initially None.\\n- curr: a pointer to the current node, initially the head of the linked list.\\n- nxt: a pointer to the next node, initially None.\\n- We can then iterate over the linked list while updating the pointers as follows:\\n\\nFirst, we set nxt to the next node of curr.\\n- We then update curr\\'s next pointer to point to prev (i.e., reverse the next pointer).\\n- We then set prev to curr, and curr to nxt, effectively moving the pointers one node ahead.\\n- We repeat this process until curr becomes None, at which point we return prev as the new head of the reversed linked list.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n40.90%\\n\\n- Space complexity:\\nBeats\\n99.79%\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n  def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n    prev = None\\n    curr = head\\n    \\n    while curr:\\n        nxt = curr.next\\n        curr.next = prev\\n        prev = curr\\n        curr = nxt\\n    \\n    return prev\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n  def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n    prev = None\\n    curr = head\\n    \\n    while curr:\\n        nxt = curr.next\\n        curr.next = prev\\n        prev = curr\\n        curr = nxt\\n    \\n    return prev\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809481,
                "title": "simple-iterative-recursive-solution-with-diagram-beats-100",
                "content": "# **Iterative**\\n\\n![image](https://assets.leetcode.com/users/images/fafda29b-cbe2-48ae-9748-4cc004495e77_1668327909.7633712.jpeg)\\n```\\nfunc reverseList(head *ListNode) *ListNode {\\n    if head == nil {\\n        return nil\\n    }\\n    \\n    var revHead *ListNode\\n\\n    for head != nil {\\n        tmp := head.Next\\n        head.Next = revHead\\n        revHead = head\\n        head = tmp\\n    }\\n    return revHead\\n}\\n```\\n\\n\\n*same logic, lesser code :*\\n```\\nfunc reverseList(head *ListNode) *ListNode {\\n    var revHead *ListNode\\n    for head != nil {\\n        head.Next, revHead, head = revHead, head, head.Next\\n    }\\n    return revHead\\n}\\n```\\n\\n# **Recursive**\\n\\n![image](https://assets.leetcode.com/users/images/740eac1a-0f76-4270-b266-908c253bcce8_1668335922.776485.jpeg)\\n\\n```\\nfunc reverseList(head *ListNode) *ListNode {\\n    if head == nil {\\n        return nil\\n    }\\n    rev, _ := reverse(head)\\n    return rev\\n}\\n\\nfunc reverse(head *ListNode) (root, tail *ListNode) {\\n    root, tail = head, head                     \\n\\t\\n    if head.Next != nil {                       \\n        root, tail = reverse(head.Next)         \\n        head.Next = nil                            \\n        tail.Next = head                           \\n        tail = head                                \\n    }\\n    \\n    return root, tail                           \\n}\\n```\\n\\n*lesser code, but complex:*\\n```\\nfunc reverseList(head *ListNode) *ListNode {\\n    revHead := head\\n\\n    if head != nil && head.Next != nil {\\n        revHead = reverseList(head.Next)\\n        head.Next.Next = head\\n        head.Next = nil\\n    }\\n\\n    return revHead\\n}\\n```\\n\\n#### PS: Please upvote if you liked the explanatoin and appreciate my effort, helps it reaching others who need it. Thanks :)\\nStay motivated. \\n\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reverseList(head *ListNode) *ListNode {\\n    if head == nil {\\n        return nil\\n    }\\n    \\n    var revHead *ListNode\\n\\n    for head != nil {\\n        tmp := head.Next\\n        head.Next = revHead\\n        revHead = head\\n        head = tmp\\n    }\\n    return revHead\\n}\\n```\n```\\nfunc reverseList(head *ListNode) *ListNode {\\n    var revHead *ListNode\\n    for head != nil {\\n        head.Next, revHead, head = revHead, head, head.Next\\n    }\\n    return revHead\\n}\\n```\n```\\nfunc reverseList(head *ListNode) *ListNode {\\n    if head == nil {\\n        return nil\\n    }\\n    rev, _ := reverse(head)\\n    return rev\\n}\\n\\nfunc reverse(head *ListNode) (root, tail *ListNode) {\\n    root, tail = head, head                     \\n\\t\\n    if head.Next != nil {                       \\n        root, tail = reverse(head.Next)         \\n        head.Next = nil                            \\n        tail.Next = head                           \\n        tail = head                                \\n    }\\n    \\n    return root, tail                           \\n}\\n```\n```\\nfunc reverseList(head *ListNode) *ListNode {\\n    revHead := head\\n\\n    if head != nil && head.Next != nil {\\n        revHead = reverseList(head.Next)\\n        head.Next.Next = head\\n        head.Next = nil\\n    }\\n\\n    return revHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362108,
                "title": "cpp-recursive-solution-explained",
                "content": "The base case for recursion is if list is empty i.e. head points to null or head-> next is null i.e. single element in the list, then the reverse of single element is that element itself so we return head itself.\\n\\nGenerally, in recursion we break the problem into 1 and (n-1) parts where we handle 1 part and let recursion handle (n-1) parts, so we pass head->next (i.e. from the second node to the end of the list) to the recursive call.\\n\\nSo, after the recursive function is called, our list is almost reversed except the first node. Say, our original list was 1->2->3->4->5, then we have 5->4->3->2 after recursion. Now, we just have to add the first element of orginal list to the end. \\n\\nTo clearly explain the last 2 lines lets take an example:\\n\\nSay 1 is stored at 100, 2 at 200 and so on... head->next->next = head means head->next i.e. 200\\'s next i.e. 300 is now changed to head i.e. 100. So now the node with val 2 points to the head i.e 2->1 which is exactly what we wanted. The last line head->next = NULL means that the head node will point to null thus, marking the end of our list. So, finally our list becomes 5->4->3->2->1->NULL\\n\\nBelow is my code if you want to refer to it:\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        // base case for recursion is if head is null:\\n      if (head == NULL || head -> next == NULL) {\\n            return head;\\n        }\\n        // recursive call so passing all elements except first because in recursion we break nodes as 1 and (n-1) and we handle 1 and recursion handles (n-1) part:\\n        ListNode* node = reverseList(head -> next);\\n        head -> next -> next = head;\\n        head -> next = NULL;\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        // base case for recursion is if head is null:\\n      if (head == NULL || head -> next == NULL) {\\n            return head;\\n        }\\n        // recursive call so passing all elements except first because in recursion we break nodes as 1 and (n-1) and we handle 1 and recursion handles (n-1) part:\\n        ListNode* node = reverseList(head -> next);\\n        head -> next -> next = head;\\n        head -> next = NULL;\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866153,
                "title": "java-2-solutons-in-place-operation-beats-100-and-create-a-new-linked-list-beats-100",
                "content": "***Please upvote if it helps,it\\'s important for me\\uD83D\\uDE0A.***\\n\\nHere are two methods :\\n**1\\u3001In place operations(We should master it)**\\n![image](https://assets.leetcode.com/users/images/86ed2e34-f975-4310-b4b8-f9924416081e_1647755954.9587948.jpeg)\\n```\\npublic ListNode reverseList(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        ListNode next;\\n        while(curr != null){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n```\\n**2\\u3001Create a new linked list.**\\n```\\npublic ListNode reverseList(ListNode head) {\\n        ListNode result = null;\\n        while(head != null){\\n            result = new ListNode(head.val,result);\\n            head = head.next;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode reverseList(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        ListNode next;\\n        while(curr != null){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n```\n```\\npublic ListNode reverseList(ListNode head) {\\n        ListNode result = null;\\n        while(head != null){\\n            result = new ListNode(head.val,result);\\n            head = head.next;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3092785,
                "title": "c-shortest-fastest-iterative-solution-time-o-n",
                "content": "# Complexity\\n- **Time complexity**: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity**: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic ListNode ReverseList(ListNode head)\\n{\\n    ListNode resultNode = null;\\n    while(head != null)\\n    {\\n        resultNode = new ListNode(head.val, resultNode);\\n        head = head.next;\\n    }\\n    return resultNode;\\n}\\n```\\n\\nOr even **shorter** :\\n\\n```\\npublic ListNode ReverseList(ListNode h)\\n{\\n    ListNode r = null;\\n    while(h != null) (r, h) = (new(h.val, r), h.next);\\n    return r;\\n}\\n```\\n",
                "solutionTags": [
                    "C#",
                    "Linked List"
                ],
                "code": "```\\npublic ListNode ReverseList(ListNode head)\\n{\\n    ListNode resultNode = null;\\n    while(head != null)\\n    {\\n        resultNode = new ListNode(head.val, resultNode);\\n        head = head.next;\\n    }\\n    return resultNode;\\n}\\n```\n```\\npublic ListNode ReverseList(ListNode h)\\n{\\n    ListNode r = null;\\n    while(h != null) (r, h) = (new(h.val, r), h.next);\\n    return r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 251638,
                "title": "python-iterative-and-recursive-solutions",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n\\tdef reverseList_i(self, head: ListNode) -> ListNode:  # iterative\\n\\t# O(n) Time / O(1) Space\\n\\t\\tprev = None\\n\\t\\tcur = head\\n\\t\\twhile cur:\\n\\t\\t\\ttmp_next = cur.next\\n\\t\\t\\tcur.next = prev\\n\\t\\t\\tprev = cur\\n\\t\\t\\tcur = tmp_next\\n\\t\\treturn prev\\n    \\n    def reverseList_r(self, head: ListNode) -> ListNode: # recursive\\n\\t# O(n) Time / O(n) Space\\n        if not head or not head.next: return head\\n        p = self.reverseList(head.next)\\n        head.next.next = head\\n        head.next = None\\n        return p\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n\\tdef reverseList_i(self, head: ListNode) -> ListNode:  # iterative\\n\\t# O(n) Time / O(1) Space\\n\\t\\tprev = None\\n\\t\\tcur = head\\n\\t\\twhile cur:\\n\\t\\t\\ttmp_next = cur.next\\n\\t\\t\\tcur.next = prev\\n\\t\\t\\tprev = cur\\n\\t\\t\\tcur = tmp_next\\n\\t\\treturn prev\\n    \\n    def reverseList_r(self, head: ListNode) -> ListNode: # recursive\\n\\t# O(n) Time / O(n) Space\\n        if not head or not head.next: return head\\n        p = self.reverseList(head.next)\\n        head.next.next = head\\n        head.next = None\\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961711,
                "title": "simple-recursive-c-solution-o-n-time-o-n-space",
                "content": "This solution uses a recursive function to reverse a singly linked list. It starts at the head of the list and follows the next links until it reaches the end of the list. Then it reverses the next links back to the head of the list, building the reversed list as it goes. When it reaches the head of the original list again, it returns the head of the reversed list as the result.\\n\\n# Approach\\nRecursion\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    private ListNode _reversedHead;\\n\\n    public ListNode ReverseList(ListNode head)\\n    {\\n        if (head == null) return head;\\n        var last = RecursionReverse(head);\\n        last.next = null;\\n\\n        return _reversedHead;\\n    }\\n\\n    public ListNode RecursionReverse(ListNode node)\\n    {\\n        if (node.next == null)\\n        {\\n            _reversedHead = node;\\n            return node;\\n        }\\n        var next = RecursionReverse(node.next);\\n        next.next = node;\\n        return node;\\n\\n    }\\n}\\n```\\n\\nIf you found my solution helpful, please consider upvoting it to let others know!",
                "solutionTags": [
                    "C#",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private ListNode _reversedHead;\\n\\n    public ListNode ReverseList(ListNode head)\\n    {\\n        if (head == null) return head;\\n        var last = RecursionReverse(head);\\n        last.next = null;\\n\\n        return _reversedHead;\\n    }\\n\\n    public ListNode RecursionReverse(ListNode node)\\n    {\\n        if (node.next == null)\\n        {\\n            _reversedHead = node;\\n            return node;\\n        }\\n        var next = RecursionReverse(node.next);\\n        next.next = node;\\n        return node;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510152,
                "title": "easiest-way-to-reverse-linked-list-explained-with-images",
                "content": "// **Hi Devs if you like my post and it helps you please do vote so that it reaches more Devs**\\n\\n\\n// In this approach we uses a three pointers \\n// p --> previous , c --> current , n --> next\\n// in every itration we reverse link between p and c , Then move pointers .\\n\\n![image](https://assets.leetcode.com/users/images/8a170425-7f78-496a-8c48-0e219f1b2b74_1661964315.967118.png)\\n\\n\\n\\n```\\nvar reverseList = function(head) {\\n    let p =null;\\n    let c = head ;\\n   \\n    \\n    while(c){\\n        let n = c.next //next\\n        c.next =p;  //reverse link and break link between c and n\\n        p=c;  // move p\\n        c=n;  // move c\\n     \\n    }\\n    return p;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nvar reverseList = function(head) {\\n    let p =null;\\n    let c = head ;\\n   \\n    \\n    while(c){\\n        let n = c.next //next\\n        c.next =p;  //reverse link and break link between c and n\\n        p=c;  // move p\\n        c=n;  // move c\\n     \\n    }\\n    return p;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2180315,
                "title": "super-ez-python-solution-graph-explanation-two-pointers-faster-than-93",
                "content": "1. \\u628Acur.next\\u5B58\\u5230nextnode\\u4E2D\\uFF0C\\u9632\\u6B62\\u65AD\\u5F00\\u540E\\u627E\\u4E0D\\u5230\\nStore cur.next in nextnode, because we will disconnect the cur->nextnode for the reverse\\n\\n2. \\u8BA9cur\\u6307\\u5411prev, \\u5373 cur.next = prev\\nLet cur -> prev for reversing, which is cur.next = prev\\n\\n3. prev\\u548Ccur\\u90FD\\u5F80\\u524D\\u79FB\\u4E00\\u4F4D\\uFF0Cnextnode\\u4F1A\\u81EA\\u52A8\\u5728\\u4E0B\\u4E00\\u6B21\\u5FAA\\u73AF\\u4E2D\\u5F80\\u524D\\u79FB\\u4E00\\u4F4D\\nMove prev and cur to the next number, which is prev = cur, cur = nextnode\\n\\n4. \\u5F53cur\\u4E3A\\u7A7A\\u7684\\u65F6\\u5019\\u8BF4\\u660E\\u53CD\\u8F6C\\u5DF2\\u7ECF\\u7ED3\\u675F\\u4E86\\uFF0C\\u6211\\u4EEC\\u8981\\u8FD4\\u56DEcur\\u524D\\u4E00\\u4E2A\\u8282\\u70B9\\uFF0C\\u6240\\u4EE5return prev\\nFinish list reversing when cur is Null and the loop end, we need to return the point before cur, so is return prev\\n\\n\\u542C\\u61C2\\u638C\\u58F0\\uFF01\\npls upvote me if u understand! :)\\n![image](https://assets.leetcode.com/users/images/39a9a7bf-a4a9-45a6-a8d6-56ff176fcdde_1655848048.2144887.png)\\n```  \\ndef reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n        prev = None\\n        cur = head\\n        while cur:\\n            nextnode = cur.next\\n            cur.next = prev\\n            prev = cur\\n            cur = nextnode\\n        return prev\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "1. \\u628Acur.next\\u5B58\\u5230nextnode\\u4E2D\\uFF0C\\u9632\\u6B62\\u65AD\\u5F00\\u540E\\u627E\\u4E0D\\u5230\\nStore cur.next in nextnode, because we will disconnect the cur->nextnode for the reverse\\n\\n2. \\u8BA9cur\\u6307\\u5411prev, \\u5373 cur.next = prev\\nLet cur -> prev for reversing, which is cur.next = prev\\n\\n3. prev\\u548Ccur\\u90FD\\u5F80\\u524D\\u79FB\\u4E00\\u4F4D\\uFF0Cnextnode\\u4F1A\\u81EA\\u52A8\\u5728\\u4E0B\\u4E00\\u6B21\\u5FAA\\u73AF\\u4E2D\\u5F80\\u524D\\u79FB\\u4E00\\u4F4D\\nMove prev and cur to the next number, which is prev = cur, cur = nextnode\\n\\n4. \\u5F53cur\\u4E3A\\u7A7A\\u7684\\u65F6\\u5019\\u8BF4\\u660E\\u53CD\\u8F6C\\u5DF2\\u7ECF\\u7ED3\\u675F\\u4E86\\uFF0C\\u6211\\u4EEC\\u8981\\u8FD4\\u56DEcur\\u524D\\u4E00\\u4E2A\\u8282\\u70B9\\uFF0C\\u6240\\u4EE5return prev\\nFinish list reversing when cur is Null and the loop end, we need to return the point before cur, so is return prev\\n\\n\\u542C\\u61C2\\u638C\\u58F0\\uFF01\\npls upvote me if u understand! :)\\n![image](https://assets.leetcode.com/users/images/39a9a7bf-a4a9-45a6-a8d6-56ff176fcdde_1655848048.2144887.png)\\n```  \\ndef reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n        prev = None\\n        cur = head\\n        while cur:\\n            nextnode = cur.next\\n            cur.next = prev\\n            prev = cur\\n            cur = nextnode\\n        return prev\\n",
                "codeTag": "Python3"
            },
            {
                "id": 58312,
                "title": "0ms-simple-java-solution",
                "content": "    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        while(head != null){\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        while(head != null){\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 58402,
                "title": "java-solution-recursion-and-iteration-methods",
                "content": "// Recursion: \\n\\n    public ListNode reverseList(ListNode head) {\\n        return helper(null, head);\\n    }\\n    \\n    ListNode helper(ListNode reversed, ListNode remaining) {\\n        if(remaining==null) return reversed;\\n        ListNode tmp = remaining.next;\\n        remaining.next = reversed;\\n        \\n        return helper(remaining, tmp);\\n    }\\n\\n// Iteration:\\n\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null) return head;\\n        \\n        ListNode newhead = new ListNode(0);\\n        newhead.next = head;\\n        \\n        while(head.next!=null) {\\n            ListNode tmp = head.next;\\n            head.next = head.next.next;\\n            \\n            tmp.next = newhead.next;\\n            newhead.next = tmp;\\n        }\\n        return newhead.next;\\n    }",
                "solutionTags": [],
                "code": "// Recursion: \\n\\n    public ListNode reverseList(ListNode head) {\\n        return helper(null, head);\\n    }\\n    \\n    ListNode helper(ListNode reversed, ListNode remaining) {\\n        if(remaining==null) return reversed;\\n        ListNode tmp = remaining.next;\\n        remaining.next = reversed;\\n        \\n        return helper(remaining, tmp);\\n    }\\n\\n// Iteration:\\n\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null) return head;\\n        \\n        ListNode newhead = new ListNode(0);\\n        newhead.next = head;\\n        \\n        while(head.next!=null) {\\n            ListNode tmp = head.next;\\n            head.next = head.next.next;\\n            \\n            tmp.next = newhead.next;\\n            newhead.next = tmp;\\n        }\\n        return newhead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 58434,
                "title": "c-solution-very-easy",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        ListNode* reverseList(ListNode* head) {\\n            ListNode *temp = NULL , *nextNode = NULL;\\n            while(head){\\n                nextNode = head->next;\\n                head->next = temp;\\n                temp = head;\\n                head = nextNode;\\n            }\\n            return temp;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* reverseList(ListNode* head) {\\n            ListNode *temp = NULL , *nextNode = NULL;\\n            while(head){\\n                nextNode = head->next;\\n                head->next = temp;\\n                temp = head;\\n                head = nextNode;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2578707,
                "title": "python-explained-recursive-iterative",
                "content": "![image](https://assets.leetcode.com/users/images/1caa5168-a9c7-4716-8a7f-0202926c8dff_1663236706.4428494.png)\\n\\n\\nRecursive:\\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:            # nothing to reverse\\n            return head\\n\\t\\tnewHead = self.reverseList(head.next)    #  see what\\'s happening on the diagram above\\n\\t\\thead.next.next = head\\n\\t\\thead.next = None                         # see \"head off\" column\\n\\t\\treturn newHead\\n```\\nIterative:\\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        newHead = None               # \"newHead\" is to be returned. By now it\\'s tail.\\n        while head:\\n            previous = newHead\\n            newHead = head           # Now any doing with \"newHead\" makes the same doing with \"head\".\\n            head = head.next         # !!! That\\'s why this line can\\'t be placed after the next.  \\n            newHead.next = previous  # Since \"head\" is freed, \"newHead.next = previous\" will not cause \"head.next = previous\".\\n        return newHead\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:            # nothing to reverse\\n            return head\\n\\t\\tnewHead = self.reverseList(head.next)    #  see what\\'s happening on the diagram above\\n\\t\\thead.next.next = head\\n\\t\\thead.next = None                         # see \"head off\" column\\n\\t\\treturn newHead\\n```\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        newHead = None               # \"newHead\" is to be returned. By now it\\'s tail.\\n        while head:\\n            previous = newHead\\n            newHead = head           # Now any doing with \"newHead\" makes the same doing with \"head\".\\n            head = head.next         # !!! That\\'s why this line can\\'t be placed after the next.  \\n            newHead.next = previous  # Since \"head\" is freed, \"newHead.next = previous\" will not cause \"head.next = previous\".\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571922,
                "title": "python-iterative-really-really-really-simple-solution",
                "content": "The approach is the following: we need to point current node\\'s next to the last node we saw, update the last node to be this current node, and move to the next node (which is the current node\\'s next before any changes). In Python we can do these 3 operations at the same time with the help of tuple (un)packing sintax without the need of temporary swap variables.\\n\\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        last = None\\n        while head:\\n            last, head.next, head = head, last, head.next\\n            \\n        return last\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        last = None\\n        while head:\\n            last, head.next, head = head, last, head.next\\n            \\n        return last\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548247,
                "title": "javascript-recursion",
                "content": "```\\n// time complexity - O (n)\\n// space complexity - O (n)\\nvar reverseList = function(head) {\\n    const helper = (current, prev) => {\\n        if(current === null) return prev;\\n\\t\\t// next node\\n        let next = current.next;\\n\\t\\t// append previous nodes in current\\n        current.next = prev;\\n        return helper(next, current)\\n    }\\n    return helper(head, null);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n// time complexity - O (n)\\n// space complexity - O (n)\\nvar reverseList = function(head) {\\n    const helper = (current, prev) => {\\n        if(current === null) return prev;\\n\\t\\t// next node\\n        let next = current.next;\\n\\t\\t// append previous nodes in current\\n        current.next = prev;\\n        return helper(next, current)\\n    }\\n    return helper(head, null);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506355,
                "title": "java-iterative-and-recursive-solutions-both-0ms-and-100-faster",
                "content": "**Iteratively:**\\n```\\npublic ListNode reverseList(ListNode head) {\\n    ListNode prev = null;\\n    ListNode node = head;\\n\\n    while (node != null) {\\n        ListNode aux = node.next;\\n        node.next = prev;\\n        \\n        prev = node;\\n        node = aux;\\n    }\\n    \\n    return prev;\\n}\\n```\\n\\n**Recursively:**\\n```\\npublic ListNode reverseList(ListNode head) {\\n    return reverseList(null, head);\\n}\\n\\npublic ListNode reverseList(ListNode prev, ListNode node) {\\n    if (node == null) {\\n        return prev;\\n    }\\n    \\n    ListNode aux = node.next;\\n    node.next = prev;\\n    \\n    return reverseList(node, aux);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic ListNode reverseList(ListNode head) {\\n    ListNode prev = null;\\n    ListNode node = head;\\n\\n    while (node != null) {\\n        ListNode aux = node.next;\\n        node.next = prev;\\n        \\n        prev = node;\\n        node = aux;\\n    }\\n    \\n    return prev;\\n}\\n```\n```\\npublic ListNode reverseList(ListNode head) {\\n    return reverseList(null, head);\\n}\\n\\npublic ListNode reverseList(ListNode prev, ListNode node) {\\n    if (node == null) {\\n        return prev;\\n    }\\n    \\n    ListNode aux = node.next;\\n    node.next = prev;\\n    \\n    return reverseList(node, aux);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381942,
                "title": "python-solutions",
                "content": "# Iterative\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        node = head\\n        while node:\\n            next = node.next\\n            node.next = prev\\n            prev = node\\n            node = next\\n        return prev\\n```\\n\\n# Recursive\\nThis first solution reverse the current node right away and continues with reversing the rest of the list.\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    \\n    def reverseListRec(self, node, prev):\\n        if node is None:\\n            return prev\\n        tmp = node.next\\n        node.next = prev\\n        return self.reverseListRec(tmp, node)\\n        \\n    def reverseList(self, head: ListNode) -> ListNode:\\n        return self.reverseListRec(head, None)\\n```\\n\\nThis solution defer reversing the current node until the remainder of the list is reversed\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        p = self.reverseList(head.next)\\n        head.next.next = head\\n        head.next = None\\n        return p\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        node = head\\n        while node:\\n            next = node.next\\n            node.next = prev\\n            prev = node\\n            node = next\\n        return prev\\n```\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    \\n    def reverseListRec(self, node, prev):\\n        if node is None:\\n            return prev\\n        tmp = node.next\\n        node.next = prev\\n        return self.reverseListRec(tmp, node)\\n        \\n    def reverseList(self, head: ListNode) -> ListNode:\\n        return self.reverseListRec(head, None)\\n```\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        p = self.reverseList(head.next)\\n        head.next.next = head\\n        head.next = None\\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 58124,
                "title": "python-recursion-implemention",
                "content": "Python  Recursion Implemention\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reverseList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n            return head\\n        second = head.next\\n        reverse = self.reverseList(second)\\n        second.next = head\\n        head.next = None\\n        \\n        return reverse\\n\\n\\n```",
                "solutionTags": [],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reverseList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n            return head\\n        second = head.next\\n        reverse = self.reverseList(second)\\n        second.next = head\\n        head.next = None\\n        \\n        return reverse\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 58463,
                "title": "66ms-python-recursive-5-lines",
                "content": "\\n    def reverseList(self, head, last = None):\\n        if not head:\\n            return last\\n        next = head.next\\n        head.next = last\\n        return self.reverseList(next, head)",
                "solutionTags": [],
                "code": "\\n    def reverseList(self, head, last = None):\\n        if not head:\\n            return last\\n        next = head.next\\n        head.next = last\\n        return self.reverseList(next, head)",
                "codeTag": "Python3"
            },
            {
                "id": 547834,
                "title": "one-line-of-code-to-remember-the-approach",
                "content": "This problem can be a part of a bigger problem. One can get confused even after solving it previously.  \\nYou have to remember that we have to manage three updates , and all updates can be done in one line.\\n```\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        first = head\\n        if (not first) or (not first.next): return first\\n\\n        first.next, curr, prev = None, first.next, first\\n        \\n        #1. Reverse  (curr.next = prev)\\n        #2. Update Current\\n        #3. Update previous\\n        \\n        while curr.next:\\n            curr.next, curr, prev = prev, curr.next, curr\\n\\n        curr.next = prev\\n        return curr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        first = head\\n        if (not first) or (not first.next): return first\\n\\n        first.next, curr, prev = None, first.next, first\\n        \\n        #1. Reverse  (curr.next = prev)\\n        #2. Update Current\\n        #3. Update previous\\n        \\n        while curr.next:\\n            curr.next, curr, prev = prev, curr.next, curr\\n\\n        curr.next = prev\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460383,
                "title": "golang",
                "content": "```\\nfunc reverseList(head *ListNode) *ListNode {\\n\\tvar prev *ListNode\\n\\tcur := head\\n\\tfor cur != nil {\\n\\t\\tprev, cur, cur.Next = cur, cur.Next, prev\\n\\t}\\n\\n\\treturn prev\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc reverseList(head *ListNode) *ListNode {\\n\\tvar prev *ListNode\\n\\tcur := head\\n\\tfor cur != nil {\\n\\t\\tprev, cur, cur.Next = cur, cur.Next, prev\\n\\t}\\n\\n\\treturn prev\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094191,
                "title": "video-step-by-step-visualization-of-o-n-solution",
                "content": "https://youtu.be/W1BLGgWZhK8\\n\\nThe key is to use two pointers to traverse the linked list, and to build the new list starting from the back (since we can only traverse the linked list from the front).\\n\\n`current` is used to traverse the list and point the `next` attribute of the current node to the node before it (by pointing it to `new_list`), while `next_node` keeps track of the next node in the original list so it can be accessed next.\\n\\nBy using this method instead of repeatedly traversing to the end of the linked list to build the new list, the time complexity can be reduced from O(n\\xB2) to O(n).\\n\\n# Code\\n```\\ndef reverseList(self, head):\\n    new_list = None\\n    current = head\\n\\n    while current:\\n        next_node = current.next\\n        current.next = new_list\\n        new_list = current\\n        current = next_node\\n    \\n    return new_list\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\ndef reverseList(self, head):\\n    new_list = None\\n    current = head\\n\\n    while current:\\n        next_node = current.next\\n        current.next = new_list\\n        new_list = current\\n        current = next_node\\n    \\n    return new_list\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3545982,
                "title": "c-java-python-javascript-space-o-1-simple-solution-easy-to-understand",
                "content": "# Intuition\\nTake the head of a singly-linked list as input and reverses the list.\\n\\n# Approach\\n\\n1. Check if the head is NULL. If it is, it means the list is empty, so we return the head as it is.\\n\\n2. Create two pointers, \"current\" and \"previous,\" and initialize \"current\" with the head of the list and \"previous\" with NULL.\\n\\n3. Enter a loop that continues until \"current\" becomes NULL.\\n\\n4. Inside the loop, create a temporary pointer, \"temp,\" and store the next node of the current node.\\n\\n5. Set the \"next\" pointer of the current node to the previous node, effectively reversing the pointer direction.\\n\\n6. Update the \"previous\" pointer to the current node.\\n\\n7. Update the \"current\" pointer to the next node (stored in \"temp\") for the next iteration.\\n\\n8. Once the loop finishes, all the pointers have been reversed, and the \"previous\" pointer will be pointing to the new head of the reversed list.\\n\\n9. Return the \"previous\" pointer as the new head of the reversed list.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of nodes in the linked list, as we need to traverse the entire list once.\\n\\n- Space complexity: O(1) as we are using a constant amount of extra space to store the pointers.\\n\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        ListNode* current=head;\\n        ListNode* previous=NULL;\\n        while(current!=NULL){\\n            ListNode* temp = current->next;\\n            current->next=previous;\\n            previous=current;\\n            current=temp;\\n        }\\n        return previous;\\n    }\\n};\\n```\\n# JAVA\\n```java\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null) {\\n            return head;\\n        }\\n        \\n        ListNode current = head;\\n        ListNode previous = null;\\n        \\n        while (current != null) {\\n            ListNode temp = current.next;\\n            current.next = previous;\\n            previous = current;\\n            current = temp;\\n        }\\n        \\n        return previous;\\n    }\\n}\\n```\\n# JavaScript\\n```js\\nvar reverseList = function(head) {\\n    if (head === null) {\\n        return head;\\n    }\\n    \\n    let current = head;\\n    let previous = null;\\n    \\n    while (current !== null) {\\n        let temp = current.next;\\n        current.next = previous;\\n        previous = current;\\n        current = temp;\\n    }\\n    \\n    return previous;\\n};\\n```\\n# Python\\n```py\\nclass Solution(object):\\n    def reverseList(self, head):\\n        if head is None:\\n            return head\\n        \\n        current = head\\n        previous = None\\n        \\n        while current is not None:\\n            temp = current.next\\n            current.next = previous\\n            previous = current\\n            current = temp\\n        \\n        return previous\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        ListNode* current=head;\\n        ListNode* previous=NULL;\\n        while(current!=NULL){\\n            ListNode* temp = current->next;\\n            current->next=previous;\\n            previous=current;\\n            current=temp;\\n        }\\n        return previous;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null) {\\n            return head;\\n        }\\n        \\n        ListNode current = head;\\n        ListNode previous = null;\\n        \\n        while (current != null) {\\n            ListNode temp = current.next;\\n            current.next = previous;\\n            previous = current;\\n            current = temp;\\n        }\\n        \\n        return previous;\\n    }\\n}\\n```\n```js\\nvar reverseList = function(head) {\\n    if (head === null) {\\n        return head;\\n    }\\n    \\n    let current = head;\\n    let previous = null;\\n    \\n    while (current !== null) {\\n        let temp = current.next;\\n        current.next = previous;\\n        previous = current;\\n        current = temp;\\n    }\\n    \\n    return previous;\\n};\\n```\n```py\\nclass Solution(object):\\n    def reverseList(self, head):\\n        if head is None:\\n            return head\\n        \\n        current = head\\n        previous = None\\n        \\n        while current is not None:\\n            temp = current.next\\n            current.next = previous\\n            previous = current\\n            current = temp\\n        \\n        return previous\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034431,
                "title": "python-easy-understanding-clear-and-intuitive-with-illustration-for-beginners",
                "content": "Given a linked list: \\n```\\n\\t 0\\uFE0F\\u20E3 \\u279D 1\\uFE0F\\u20E3 \\u279D 2\\uFE0F\\u20E3 \\u279D 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n\\t \\u261D\\uFE0E\\n\\thead\\n```\\n\\nFrom a beginner\\'s point of view, what we need to do is:\\n\\n_________________________________________________________\\n\\n**Step 0. Initialize the new linked list with an empty head, `reversed_head`**\\n\\n```\\nreversed_head = None\\n```\\n\\n_________________________________________________________\\n **Step 1. Break the original link between the current `head` and `head.next`**\\n\\n0\\uFE0F\\u20E3 \\u21CF 1\\uFE0F\\u20E3 \\u279D 2\\uFE0F\\u20E3 \\u279D 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n\\n***by cutting the original list into two seperate linked lists***\\n\\u21E4 0\\uFE0F\\u20E3 ..../.... 1\\uFE0F\\u20E3 \\u219B 2\\uFE0F\\u20E3 \\u279D 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n... \\u261D\\uFE0E ......... \\u270C\\uFE0F ~~(head.next)~~`next_head` \\u279D remaining of original list\\n....~~(head)~~`reversed_head` \\u279D new reversed list building up\\n\\n\\n_________________________________________________________\\n\\n*  ***1.1 set current `head.next` as the new head for the linked list on the right, using the second pointer \\u270C\\uFE0F, name it `nexthead`*** \\n\\u21E4 0\\uFE0F\\u20E3 ..../.... 1\\uFE0F\\u20E3 \\u279D 2\\uFE0F\\u20E3 \\u279D 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n... \\u261D\\uFE0E ......... \\u270C\\uFE0F ~~(head.next)~~`next_head`\\n(head)\\n\\n\\n\\n\\n*  ***1.2 update `head.next`, to `reversedhead`, break the original link, prepare for next new head of the new reversed list***\\n\\u2205\\n\\uD83E\\uDD0C\\n(head.next)\\n__\\n\\u2205 \\u290E 0\\uFE0F\\u20E3 ..../.... 1\\uFE0F\\u20E3 \\u219B 2\\uFE0F\\u20E3 \\u279D 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3    \\n...... \\u261D\\uFE0E ......... \\u270C\\uFE0F ~~(head.next)~~`next_head` \\n....(head)\\n\\n\\n\\n\\n\\n*  ***1.3 set `reversedhead`, the head of the new linked list,  to the first pointer\\u261D\\uFE0E\\'s, `head`\\'s value***\\n\\u21E4 0\\uFE0F\\u20E3 ..../.... 1\\uFE0F\\u20E3 \\u219B 2\\uFE0F\\u20E3 \\u279D 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n... \\u261D\\uFE0E ..........\\u270C\\uFE0F ~~(head.next)~~`next_head`\\n~~(head)~~ `reversed_head` \\n\\n\\n\\n\\n\\n*  ***1.4 push the first pointer \\u261D\\uFE0E onward, to the its origianl `next`, prepare for next iteration***\\n\\u21E4 0\\uFE0F\\u20E3 ..../.... 1\\uFE0F\\u20E3 \\u279D  2\\uFE0F\\u20E3 \\u279D 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n................. \\u261D\\uFE0E \\n.............. (head)\\n\\n\\n\\n\\n_________________________________________________________\\n### **Step 2.  Keep repeating above steps until traversed**\\n#### ***keep detaching the head from the original list, and attaching it as new head to the new reversed list , until there is now more `head` in the original list***\\n\\n#### ***Detailed illustration of next iteration:***\\n\\u21E4 0\\uFE0F\\u20E3 ..../.... 1\\uFE0F\\u20E3 \\u279D  2\\uFE0F\\u20E3 \\u279D 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n................. \\u261D\\uFE0E \\n.............. (head)\\n\\n\\u21E9\\n\\n\\u21E4 0\\uFE0F\\u20E3 ..../.... 1\\uFE0F\\u20E3 \\u219B 2\\uFE0F\\u20E3 \\u279D 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n.................. \\u261D\\uFE0E ... \\u270C\\uFE0F ~~(head.next)~~`next_head`\\n.............. (head)\\n\\n\\u21E9\\n\\n 0\\uFE0F\\u20E3 \\n\\uD83E\\uDD0C\\n(head.next)\\n\\n\\u21E4 0\\uFE0F\\u20E3 \\u290E 1\\uFE0F\\u20E3 .../... 2\\uFE0F\\u20E3 \\u219B 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n........... \\u261D\\uFE0E ....... \\u270C\\uFE0F ~~(head.next)~~`next_head`\\n........ (head)\\n\\n\\u21E9\\n\\n\\u21E4 0\\uFE0F\\u20E3 \\u290E 1\\uFE0F\\u20E3  ......... 2\\uFE0F\\u20E3 \\u219B 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n............\\u261D\\uFE0E........... \\u270C\\uFE0F ~~(head.next)~~`next_head`\\n........ ~~(head)~~ `reversed_head` \\n\\n\\u21E9\\n\\n\\u21E4 0\\uFE0F\\u20E3 \\u290E 1\\uFE0F\\u20E3  ......... 2\\uFE0F\\u20E3 \\u279D 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n........................... \\u261D\\uFE0E \\n........................ (head)\\n\\n\\n_________________________________________________________\\n### ***Further iterations***:\\n\\u267B\\uFE0F\\u2674\\n\\u21E4 0\\uFE0F\\u20E3 \\u290E 1\\uFE0F\\u20E3 \\u290E 2\\uFE0F\\u20E3 ........  \\u279D 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n....................\\u261D\\uFE0E........... \\u270C\\uFE0F ~~(head.next)~~`next_head`\\n........ ~~(head)~~ `reversed_head` \\n\\u267B\\uFE0F\\u2675\\n\\u21E4 0\\uFE0F\\u20E3 \\u290E 1\\uFE0F\\u20E3 \\u290E 2\\uFE0F\\u20E3 \\u290E 3\\uFE0F\\u20E3 ........ 4\\uFE0F\\u20E3\\n........................... \\u261D\\uFE0E ........ \\u270C\\uFE0F ~~(head.next)~~`next_head`\\n....................... ~~(head)~~ `reversed_head` \\n\\u267B\\uFE0F\\u2676\\n\\u21E4 0\\uFE0F\\u20E3 \\u290E 1\\uFE0F\\u20E3 \\u290E 2\\uFE0F\\u20E3 \\u290E 3\\uFE0F\\u20E3 \\u290E 4\\uFE0F\\u20E3\\n................................... \\u261D\\uFE0E.... \\u270C\\uFE0F ~~(head.next)~~`next_head`\\n............................... ~~(head)~~ `reversed_head` \\n\\uD83D\\uDED1\\n\\n_________________________________________________________\\n### **Step by step solution:**\\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        reversed_head = None\\n        \\n        while head:\\n            next_head = head.next\\n            head.next = reversed_head\\n            reversed_head = head \\n            head = next_head\\n            \\n        return reversed_head \\n```\\n\\n_________________________________________________________\\n## **4-line solution:**\\nAs observed in while loops, the 4 linked assignment statements can be simplified using Python swap:\\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        reversed_head, next_head = None, head\\n        while head:\\n            head.next, reversed_head, head = reversed_head, head, head.next\\n        return reversed_head\\n```\\n\\n\\n_________________________________________________________\\nI am also a beginner, writing these all out to help myself, and hopefully also help anyone out there who is like me at the same time. \\n\\nPlease upvote\\u2B06\\uFE0F if you find this helpful or worth-reading in anyway.  Your upvote is more than just supportive to me. \\uD83D\\uDE33\\uD83E\\uDD13\\uD83E\\uDD70\\n\\nIf you find this is not helpful, needs improvement, or questionable, would you please leave a quick comment below to point out the problem before you decide to downvote?  It will be very very helpful for me to learn as a beginner. \\n\\nThank you very much either way \\uD83E\\uDD13.",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\n\\t 0\\uFE0F\\u20E3 \\u279D 1\\uFE0F\\u20E3 \\u279D 2\\uFE0F\\u20E3 \\u279D 3\\uFE0F\\u20E3 \\u279D 4\\uFE0F\\u20E3\\n\\t \\u261D\\uFE0E\\n\\thead\\n```\n```\\nreversed_head = None\\n```\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        reversed_head = None\\n        \\n        while head:\\n            next_head = head.next\\n            head.next = reversed_head\\n            reversed_head = head \\n            head = next_head\\n            \\n        return reversed_head \\n```\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        reversed_head, next_head = None, head\\n        while head:\\n            head.next, reversed_head, head = reversed_head, head, head.next\\n        return reversed_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185022,
                "title": "python-3-liner-to-memorize-for-interviews-with-mnemonic",
                "content": "I had an interview where I solved a LeetCode-medium problem in 15 minutes, but took 10-15 minutes to reverse a linked list in another problem because I kept stumbling over stupid trivial things under pressure. I didn\\'t get the job because the interviewer assumed I\\'d seen the hard problem before but \"couldn\\'t even do simple things like reverse a linked list\", which was completely unfair to me. But people suck and there\\'s nothing that can be done about it. To be fair, I also sucked because I really should know how to reverse a linked list under pressure.\\n\\n---\\n\\nI got home and came up with these solutions in 2 minutes (they\\'re very similar, just pick one):\\n```python\\ndef reverseList(head):\\n    prev = None\\n    while head: head.next, head, prev = prev, head.next, head\\n    return prev\\n\\ndef reverseList(head):\\n    prev = None\\n    while head: head.next, prev, head = prev, head, head.next\\n    return prev\\n```\\nIt sucks to suck. Don\\'t be like me. If you\\'re like me and struggle to write perfect code for simple things under pressure, I hope this helps you.\\n\\n---\\n\\nHere\\'s an easy mnemonic for the body of the `while` loop. Imagine the linked list going from left to right, then you can think of the 3 relevant nodes as `0`, `1`, and `2`:\\n```abc\\n[prev] -> [head] -> [head.next]\\n  0         1            2\\n```\\nThe assignment in the `while` loop can be thought of as a cycle `2 <- 0 <- 1 <- 2` (where `a <- b` means \"assign `b` to `a`\"):\\n```abc\\n2, 1, 0 = 0, 2, 1\\n\\nor\\n\\n2, 0, 1 = 0, 1, 2\\n```\\nThe important thing is that `head.next = prev` _must_ be the first assignment. The other 2 assignments can be done in any order.",
                "solutionTags": [],
                "code": "```python\\ndef reverseList(head):\\n    prev = None\\n    while head: head.next, head, prev = prev, head.next, head\\n    return prev\\n\\ndef reverseList(head):\\n    prev = None\\n    while head: head.next, prev, head = prev, head, head.next\\n    return prev\\n```\n```abc\\n[prev] -> [head] -> [head.next]\\n  0         1            2\\n```\n```abc\\n2, 1, 0 = 0, 2, 1\\n\\nor\\n\\n2, 0, 1 = 0, 1, 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 58341,
                "title": "clear-iterative-python-solution",
                "content": "    class Solution(object):\\n        def reverseList(self, head):\\n            \\n            if not head: return head\\n            \\n            p, q = head, head.next\\n            p.next = None\\n            \\n            while q:\\n                tmp, q.next = q.next, p\\n                p, q = q, tmp\\n            \\n            return p",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "    class Solution(object):\\n        def reverseList(self, head):\\n            \\n            if not head: return head\\n            \\n            p, q = head, head.next\\n            p.next = None\\n            \\n            while q:\\n                tmp, q.next = q.next, p\\n                p, q = q, tmp\\n            \\n            return p",
                "codeTag": "Java"
            },
            {
                "id": 58392,
                "title": "c-accepted-recursive-with-simple-explanations",
                "content": "Given: \\n1->2->3->4\\n\\nReverse the list after first node: \\n1->(2->3->4)\\n\\nBecame: \\n4->3->2, \\n1->2\\n\\nNow we need to let: \\n2->1, 1->null\\n\\nand get result: \\n4->3->2->1->null\\n\\n       public ListNode ReverseList(ListNode head)\\n        {\\n            if (head == null || head.next == null)\\n            {\\n                return head;\\n            }\\n            \\n            ListNode newHead = ReverseList(head.next);\\n            head.next.next = head;\\n            head.next = null;\\n            \\n            return newHead;\\n        }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "Given: \\n1->2->3->4\\n\\nReverse the list after first node: \\n1->(2->3->4)\\n\\nBecame: \\n4->3->2, \\n1->2\\n\\nNow we need to let: \\n2->1, 1->null\\n\\nand get result: \\n4->3->2->1->null\\n\\n       public ListNode ReverseList(ListNode head)\\n        {\\n            if (head == null || head.next == null)\\n            {\\n                return head;\\n            }\\n            \\n            ListNode newHead = ReverseList(head.next);\\n            head.next.next = head;\\n            head.next = null;\\n            \\n            return newHead;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2850243,
                "title": "python-93-68-faster-iterative-o-n-solution",
                "content": "```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None: return head\\n        prev,curr,temp=head,head.next,head.next.next\\n        prev.next=None\\n        while temp:\\n            curr.next=prev\\n            prev=curr\\n            curr=temp\\n            temp=temp.next\\n        curr.next=prev\\n        return curr\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None: return head\\n        prev,curr,temp=head,head.next,head.next.next\\n        prev.next=None\\n        while temp:\\n            curr.next=prev\\n            prev=curr\\n            curr=temp\\n            temp=temp.next\\n        curr.next=prev\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027824,
                "title": "java-0ms-100-faster-recursion-easy-intution-explained",
                "content": "***Intution : We have to manipulate (reverse) the pointer of the linked list, in order to reverse the entire linked list.\\nRecursive Intution : We\\'ll reverse one pointer, others will be done by the function itself (recursive leap of faith ) !***\\n\\n```\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev=null; //previous pointer\\n        ListNode cPtr = head; //current pointer\\n        ListNode nxt = null; //head pointer\\n        \\n        return reverse (cPtr, prev, nxt);\\n    }\\n    \\n    public ListNode reverse(ListNode cPtr, ListNode prev, ListNode nxt){\\n        if(cPtr == null){  //base condition\\n            return prev;\\n        }\\n        nxt = cPtr.next;\\n        cPtr.next = prev;\\n        prev = cPtr; \\n        cPtr = nxt;\\n        \\n        return reverse(cPtr, prev, nxt);\\n    }\\n}\\n```\\n\\n**Perform a dry run for better understanding !\\nHappy Coding !\\nDo Upvote if it helped !**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev=null; //previous pointer\\n        ListNode cPtr = head; //current pointer\\n        ListNode nxt = null; //head pointer\\n        \\n        return reverse (cPtr, prev, nxt);\\n    }\\n    \\n    public ListNode reverse(ListNode cPtr, ListNode prev, ListNode nxt){\\n        if(cPtr == null){  //base condition\\n            return prev;\\n        }\\n        nxt = cPtr.next;\\n        cPtr.next = prev;\\n        prev = cPtr; \\n        cPtr = nxt;\\n        \\n        return reverse(cPtr, prev, nxt);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668873,
                "title": "c-simplest-iterative-approach",
                "content": "\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        \\n        ListNode* previous = NULL;\\n        ListNode* current = head;\\n        ListNode* next;\\n        while(current != NULL)\\n        {\\n            next = current -> next;\\n            current -> next = previous;\\n            \\n            previous = current;\\n            current = next;\\n        }\\n        return previous;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        \\n        ListNode* previous = NULL;\\n        ListNode* current = head;\\n        ListNode* next;\\n        while(current != NULL)\\n        {\\n            next = current -> next;\\n            current -> next = previous;\\n            \\n            previous = current;\\n            current = next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1305119,
                "title": "c",
                "content": "Runtime: 92 ms, faster than 72.27% of C# online submissions for Reverse Linked List.\\nMemory Usage: 25.2 MB, less than 40.36% of C# online submissions for Reverse Linked List.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode ReverseList(ListNode head) {\\n        \\n        if(head == null) return head;\\n        \\n        //Auctually we will have to reverse the link direction only\\n        //1 -> 2 -> 3 -> null(tail) To (null)<-1 <- 2 <-3\\n        \\n        \\n        ListNode prev_node = null;\\n        \\n        //iterate through list till the end, change link direction (next) of each item \\n        //point to just before node (previos)\\n        while(head != null){\\n            ListNode next_node = head.next; // 2 , kept a track of next item\\n            head.next = prev_node; //direction changed right to left\\n            //This also means head is now broke link to its earlier next ie 2\\n            //(null) <- 1  2\\n            // prev_node, head, next_node all one step right\\n            prev_node = head; //1\\n            head = next_node; //2            \\n            //first line #26 will take care of sliding of next_node   \\n        }\\n        \\n        //finally now retrun the prev_node, which is reversed ie head is at 3\\n        return prev_node;\\n        \\n        \\n        \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode ReverseList(ListNode head) {\\n        \\n        if(head == null) return head;\\n        \\n        //Auctually we will have to reverse the link direction only\\n        //1 -> 2 -> 3 -> null(tail) To (null)<-1 <- 2 <-3\\n        \\n        \\n        ListNode prev_node = null;\\n        \\n        //iterate through list till the end, change link direction (next) of each item \\n        //point to just before node (previos)\\n        while(head != null){\\n            ListNode next_node = head.next; // 2 , kept a track of next item\\n            head.next = prev_node; //direction changed right to left\\n            //This also means head is now broke link to its earlier next ie 2\\n            //(null) <- 1  2\\n            // prev_node, head, next_node all one step right\\n            prev_node = head; //1\\n            head = next_node; //2            \\n            //first line #26 will take care of sliding of next_node   \\n        }\\n        \\n        //finally now retrun the prev_node, which is reversed ie head is at 3\\n        return prev_node;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672767,
                "title": "rust-move-only-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut prev: Option<Box<ListNode>> = None;\\n        let mut curr = head;\\n        \\n        while let Some(mut boxed_node) = curr {\\n            let mut next = boxed_node.next.take();\\n            boxed_node.next = prev.take();\\n            prev = Some(boxed_node);\\n            curr = next.take();\\n        }\\n        \\n        prev\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut prev: Option<Box<ListNode>> = None;\\n        let mut curr = head;\\n        \\n        while let Some(mut boxed_node) = curr {\\n            let mut next = boxed_node.next.take();\\n            boxed_node.next = prev.take();\\n            prev = Some(boxed_node);\\n            curr = next.take();\\n        }\\n        \\n        prev\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537014,
                "title": "go",
                "content": "```\\nfunc reverseList(head *ListNode) *ListNode {\\n    var front *ListNode\\n    mid, end := head, head\\n    for mid != nil {\\n        end = mid.Next\\n        mid.Next = front\\n        front, mid = mid, end\\n    }\\n    return front\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc reverseList(head *ListNode) *ListNode {\\n    var front *ListNode\\n    mid, end := head, head\\n    for mid != nil {\\n        end = mid.Next\\n        mid.Next = front\\n        front, mid = mid, end\\n    }\\n    return front\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 339428,
                "title": "javascript-iterative-recursive",
                "content": "**Iterative**\\n```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseList = function(head) {\\n    let prev = null;\\n    while (head) {\\n        const next = head.next;\\n        const curr = head;\\n        curr.next = prev;\\n        head = next;\\n        prev = curr;\\n    }\\n    \\n    return prev;\\n};\\n```\\n\\n**Recursive**\\n```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseList = function(head, prev = null) {\\n    if (head === null) {\\n        return null;\\n    }\\n    const next = reverseList(head.next, head);\\n    head.next = prev;\\n    return next || head;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseList = function(head) {\\n    let prev = null;\\n    while (head) {\\n        const next = head.next;\\n        const curr = head;\\n        curr.next = prev;\\n        head = next;\\n        prev = curr;\\n    }\\n    \\n    return prev;\\n};\\n```\n```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseList = function(head, prev = null) {\\n    if (head === null) {\\n        return null;\\n    }\\n    const next = reverseList(head.next, head);\\n    head.next = prev;\\n    return next || head;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 58329,
                "title": "ac-solution-code",
                "content": "**Solution1. Iterative Solution**\\n\\n    public ListNode reverseList(ListNode head) {\\n    \\tListNode prev = null, curr = head;\\n    \\twhile (curr != null) { \\n    \\t    ListNode next = curr.next;// Save current's next \\n    \\t\\tcurr.next = prev;// Point current.next to prev\\n    \\t\\tprev = curr;// Set the current node as prev\\n    \\t\\tcurr = next;// Forward current node to next \\n    \\t}\\n    \\treturn prev;\\n    }\\n\\n**Solution2. Recursive Solution**\\n \\n    public ListNode reverseList(ListNode head) {\\n    \\treturn reverseList(head, null);\\n    }\\t  \\n    public ListNode reverseList(ListNode curr, ListNode prev) {\\n    \\tif (curr == null) return prev;\\n    \\tListNode next = curr.next;// Save current's next \\n    \\tcurr.next = prev;// Point current.next to prev\\n    \\treturn reverseList(next, curr);// // Forward current node to next; Set the current node as prev\\n    }",
                "solutionTags": [],
                "code": "**Solution1. Iterative Solution**\\n\\n    public ListNode reverseList(ListNode head) {\\n    \\tListNode prev = null, curr = head;\\n    \\twhile (curr != null) { \\n    \\t    ListNode next = curr.next;// Save current's next \\n    \\t\\tcurr.next = prev;// Point current.next to prev\\n    \\t\\tprev = curr;// Set the current node as prev\\n    \\t\\tcurr = next;// Forward current node to next \\n    \\t}\\n    \\treturn prev;\\n    }\\n\\n**Solution2. Recursive Solution**\\n \\n    public ListNode reverseList(ListNode head) {\\n    \\treturn reverseList(head, null);\\n    }\\t  \\n    public ListNode reverseList(ListNode curr, ListNode prev) {\\n    \\tif (curr == null) return prev;\\n    \\tListNode next = curr.next;// Save current's next \\n    \\tcurr.next = prev;// Point current.next to prev\\n    \\treturn reverseList(next, curr);// // Forward current node to next; Set the current node as prev\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 58422,
                "title": "share-my-accepted-java-solution-iteratively-and-recursively",
                "content": "**Iteratively:**\\n\\n    public ListNode reverseList(ListNode head) {\\n            if(head == null || head.next == null)\\n                return head;\\n            ListNode pre = null;\\n            ListNode curr = head;\\n            while(curr != null){\\n                ListNode next = curr.next;\\n                curr.next = pre;\\n                pre = curr;\\n                curr = next;\\n            }\\n            return pre;\\n        }\\n\\n**Recursively:**\\n\\n    public class Solution {     \\n         public ListNode reverseList(ListNode head) {         \\n                 if(head == null || head.next == null)             \\n                         return head;         \\n                 ListNode second = head.next;        \\n                 head.next = null;         \\n                ListNode newHead = reverseList(second);         \\n                second.next = head;         \\n                return newHead;     \\n            } \\n         }\\n\\nAny suggestions for improvements are welcome.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {     \\n         public ListNode reverseList(ListNode head) {         \\n                 if(head == null || head.next == null)             \\n                         return head;         \\n                 ListNode second = head.next;        \\n                 head.next = null;         \\n                ListNode newHead = reverseList(second);         \\n                second.next = head;         \\n                return newHead;     \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4029852,
                "title": "c-java-python-javascript",
                "content": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\nRead Whole article : https://www.nileshblog.tech/reverse-linked-list/\\n\\nExplanation with Human Hand Eg.\\n\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nTime Complexity :\\nO(n)\\n\\nRead Whole article : https://www.nileshblog.tech/reverse-linked-list/\\n![image](https://assets.leetcode.com/users/images/3c802501-f4d5-473b-b3b0-89d5fea1b7db_1694412968.676702.png)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\nRead Whole article : https://www.nileshblog.tech/reverse-linked-list/\\n\\nExplanation with Human Hand Eg.\\n\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nTime Complexity :\\nO(n)\\n\\nRead Whole article : https://www.nileshblog.tech/reverse-linked-list/\\n![image](https://assets.leetcode.com/users/images/3c802501-f4d5-473b-b3b0-89d5fea1b7db_1694412968.676702.png)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3701487,
                "title": "easy-explained-solution-beats-100",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThink of a linked list as a chain of nodes where each node points to the next node in the chain. Reversing a linked list means changing the direction of the chain, making the last node the new head, and the previous head the new tail.\\n# Approach\\n1. We\\'ll use two pointers, temp and head2, to help us manipulate the linked list during the reversal process. Both pointers are initially set to **null**.\\n1. Starting from the original head of the linked list, we\\'ll traverse the list one node at a time using a loop.\\n1. At each step, we\\'ll save the reference to the current node in temp. This is like \"grasping\" the current link in the chain.\\n1. We\\'ll then move the head pointer to the next node to proceed further in the original list. It\\'s like \"breaking\" the link we just grasped and preparing to move on to the next link.\\n1. Now, the temp node has been removed from the original chain. To reverse the direction, we\\'ll make its next pointer point to head2.\\n1. Finally, we\\'ll move the head2 pointer to the current node (temp), effectively extending the reversed chain backward. The current node becomes the new head of the reversed list.\\n1. We\\'ll repeat steps 3 to 6 until we have traversed the entire original linked list.\\n1. After the loop completes, the head2 pointer will be pointing to the new head of the reversed linked list.\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is $$O(n)$$, where n is the number of nodes in the linked list. We need to visit each node once to reverse the list.\\n\\n- Space complexity:\\nThe space complexity of the solution is $$O(1)$$. We only use a constant amount of extra space, regardless of the size of the input linked list. The algorithm modifies the pointers in place and does not use any additional data structures.\\n\\n# Code\\n\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        // Initialize temp and head2 as null, to be used for manipulation\\n        ListNode temp = null;\\n        ListNode head2 = null;\\n\\n        // Traverse the linked list while head is not null\\n        while (head != null) {\\n            // Save the reference to the current node in the temp variable\\n            temp = head;\\n\\n            // Move the head pointer to the next node\\n            head = head.next;\\n\\n            // Point the next pointer of the current node to the head2,\\n            // effectively reversing the pointer direction\\n            temp.next = head2;\\n\\n            // Move the head2 pointer to the current node,\\n            // so that it becomes the new head of the reversed linked list\\n            head2 = temp;\\n        }\\n\\n        // Once the loop finishes, head2 will be pointing to the new head\\n        // of the reversed linked list\\n        return head2;\\n    }\\n}\\n```\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def reverseList(self, head):\\n        \"\"\"\\n        Reverse a singly linked list.\\n\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Initialize temp and head2 as None, to be used for manipulation\\n        temp = None\\n        head2 = None\\n\\n        # Traverse the linked list while head is not None\\n        while head is not None:\\n            # Save the reference to the current node in the temp variable\\n            temp = head\\n\\n            # Move the head pointer to the next node\\n            head = head.next\\n\\n            # Point the next pointer of the current node to head2,\\n            # effectively reversing the pointer direction\\n            temp.next = head2\\n\\n            # Move the head2 pointer to the current node,\\n            # so that it becomes the new head of the reversed linked list\\n            head2 = temp\\n\\n        # Once the loop finishes, head2 will be pointing to the new head\\n        # of the reversed linked list\\n        return head2\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        // Initialize two pointers: temp to store the current node and head2 for the new head\\n        ListNode* temp = nullptr;\\n        ListNode* head2 = nullptr;\\n\\n        // Traverse the linked list while head is not nullptr\\n        while (head != nullptr) {\\n            // Save the reference to the current node in the temp pointer\\n            temp = head;\\n\\n            // Move the head pointer to the next node\\n            head = head->next;\\n\\n            // Point the next pointer of the current node to head2,\\n            // effectively reversing the pointer direction\\n            temp->next = head2;\\n\\n            // Move the head2 pointer to the current node,\\n            // so that it becomes the new head of the reversed linked list\\n            head2 = temp;\\n        }\\n\\n        // Once the loop finishes, head2 will be pointing to the new head\\n        // of the reversed linked list\\n        return head2;\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/c47627af-be86-437f-8053-08e9229d6750_1688146390.8061645.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        // Initialize temp and head2 as null, to be used for manipulation\\n        ListNode temp = null;\\n        ListNode head2 = null;\\n\\n        // Traverse the linked list while head is not null\\n        while (head != null) {\\n            // Save the reference to the current node in the temp variable\\n            temp = head;\\n\\n            // Move the head pointer to the next node\\n            head = head.next;\\n\\n            // Point the next pointer of the current node to the head2,\\n            // effectively reversing the pointer direction\\n            temp.next = head2;\\n\\n            // Move the head2 pointer to the current node,\\n            // so that it becomes the new head of the reversed linked list\\n            head2 = temp;\\n        }\\n\\n        // Once the loop finishes, head2 will be pointing to the new head\\n        // of the reversed linked list\\n        return head2;\\n    }\\n}\\n```\n```python []\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def reverseList(self, head):\\n        \"\"\"\\n        Reverse a singly linked list.\\n\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Initialize temp and head2 as None, to be used for manipulation\\n        temp = None\\n        head2 = None\\n\\n        # Traverse the linked list while head is not None\\n        while head is not None:\\n            # Save the reference to the current node in the temp variable\\n            temp = head\\n\\n            # Move the head pointer to the next node\\n            head = head.next\\n\\n            # Point the next pointer of the current node to head2,\\n            # effectively reversing the pointer direction\\n            temp.next = head2\\n\\n            # Move the head2 pointer to the current node,\\n            # so that it becomes the new head of the reversed linked list\\n            head2 = temp\\n\\n        # Once the loop finishes, head2 will be pointing to the new head\\n        # of the reversed linked list\\n        return head2\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        // Initialize two pointers: temp to store the current node and head2 for the new head\\n        ListNode* temp = nullptr;\\n        ListNode* head2 = nullptr;\\n\\n        // Traverse the linked list while head is not nullptr\\n        while (head != nullptr) {\\n            // Save the reference to the current node in the temp pointer\\n            temp = head;\\n\\n            // Move the head pointer to the next node\\n            head = head->next;\\n\\n            // Point the next pointer of the current node to head2,\\n            // effectively reversing the pointer direction\\n            temp->next = head2;\\n\\n            // Move the head2 pointer to the current node,\\n            // so that it becomes the new head of the reversed linked list\\n            head2 = temp;\\n        }\\n\\n        // Once the loop finishes, head2 will be pointing to the new head\\n        // of the reversed linked list\\n        return head2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353402,
                "title": "simple-javascript-98-beats-easy-explanation",
                "content": "\\n![Screenshot 2023-03-29 at 01.46.25.png](https://assets.leetcode.com/users/images/b170e5a6-c2fd-4bca-ab07-6d4cc9fb3b46_1680047222.5570757.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The reverseList function takes a head parameter representing the head of the linked list.\\n2. The first thing the function does is check if the linked list is empty or has only one node. If it does, the function simply returns the head node, since a list with only one node is already reversed.\\n3. If the linked list has more than one node, the function calls itself recursively with the next node as the new head. This recursively reverses the rest of the list.\\n4. The reversedList variable now contains the reversed list from the next node to the end of the list.\\n5. The function now sets the next node\\'s next pointer to the current node, effectively reversing the current node\\'s next pointer.\\n6. Finally, the function sets the current node\\'s next pointer to null to break the link with the next node and return the new head node, which is the last node of the original linked list.\\n\\n# Complexity\\nThe time complexity of the reverseList function is O(n), where n is the number of nodes in the linked list. This is because the function iterates through each node in the list exactly once, performing a constant amount of work on each node.\\n\\n- Space complexity:\\nThe space complexity of the function is O(1), because it only uses a constant amount of additional space to keep track of the current, previous, and next nodes as it iterates through the list. This means that the space used by the function does not depend on the size of the input, and is therefore constant.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseList = function(head) {\\n    let prev = null;\\n    let current = head;\\n    let next = null;\\n    \\n    while (current) {\\n        next = current.next;\\n        current.next = prev;\\n        prev = current;\\n        current = next;\\n    }\\n    \\n    return prev;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseList = function(head) {\\n    let prev = null;\\n    let current = head;\\n    let next = null;\\n    \\n    while (current) {\\n        next = current.next;\\n        current.next = prev;\\n        prev = current;\\n        current = next;\\n    }\\n    \\n    return prev;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3176400,
                "title": "simple-c-solution-using-3-pointer-iterative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n// if it helps plzz upvote it \\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;\\n        ListNode* curr=head;\\n        while(curr){\\n            ListNode* next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        return prev;\\n    }\\n};\\n// if it helps plzz upvote it \\uD83D\\uDE09\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n// if it helps plzz upvote it \\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;\\n        ListNode* curr=head;\\n        while(curr){\\n            ListNode* next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        return prev;\\n    }\\n};\\n// if it helps plzz upvote it \\uD83D\\uDE09\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697121,
                "title": "javascript-solution-iterative-and-recursive",
                "content": "```\\n// Iterative solution\\nvar reverseList = function(head) {\\n    if (head === null) return null;\\n    let previous = null\\n    let next = null;\\n    \\n    while (head) {\\n        next = head.next\\n        head.next = previous;\\n        previous = head;\\n        head = next;\\n    }\\n    return previous;   \\n};\\n\\n// Recursive solution\\nvar reverseList = function(head, previous = null) {\\n    if (head === null) return previous;\\n    let next = head.next;\\n    head.next = previous;\\n    return reverseList(next, head);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Iterative solution\\nvar reverseList = function(head) {\\n    if (head === null) return null;\\n    let previous = null\\n    let next = null;\\n    \\n    while (head) {\\n        next = head.next\\n        head.next = previous;\\n        previous = head;\\n        head = next;\\n    }\\n    return previous;   \\n};\\n\\n// Recursive solution\\nvar reverseList = function(head, previous = null) {\\n    if (head === null) return previous;\\n    let next = head.next;\\n    head.next = previous;\\n    return reverseList(next, head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 58117,
                "title": "easy-to-understand-python-iterative-solution",
                "content": "```\\n        current = head\\n        prev = None\\n        next = None\\n        while current:\\n            next = current.next\\n            current.next = prev\\n            prev = current\\n            current = next\\n        return prev\\n```",
                "solutionTags": [],
                "code": "```\\n        current = head\\n        prev = None\\n        next = None\\n        while current:\\n            next = current.next\\n            current.next = prev\\n            prev = current\\n            current = next\\n        return prev\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 58330,
                "title": "three-concise-python-solution",
                "content": "Method 1: uses self as a dummy node for swapping\\n\\n    def reverseList(self, head):\\n        pre, pre.next, tail = self, head, head\\n        while tail and tail.next:\\n            pre.next, pre.next.next, tail.next = \\\\\\n                      tail.next, pre.next, tail.next.next\\n        return self.next\\n\\nMethod 2: swapping using two variable, pre and cur\\n\\n    def reverseList(self, head):\\n        pre, cur = None, head\\n        while cur:\\n            cur.next, pre, cur = pre, cur, cur.next\\n        return pre\\n\\nMethod 3: Recursive method by storing previous node in the function argument.\\n\\n    def reverseList(self, head, pre = None):\\n        if not head: return pre\\n        cur, head.next = head.next, pre\\n        return self.reverseList(cur, head)",
                "solutionTags": [],
                "code": "Method 1: uses self as a dummy node for swapping\\n\\n    def reverseList(self, head):\\n        pre, pre.next, tail = self, head, head\\n        while tail and tail.next:\\n            pre.next, pre.next.next, tail.next = \\\\\\n                      tail.next, pre.next, tail.next.next\\n        return self.next\\n\\nMethod 2: swapping using two variable, pre and cur\\n\\n    def reverseList(self, head):\\n        pre, cur = None, head\\n        while cur:\\n            cur.next, pre, cur = pre, cur, cur.next\\n        return pre\\n\\nMethod 3: Recursive method by storing previous node in the function argument.\\n\\n    def reverseList(self, head, pre = None):\\n        if not head: return pre\\n        cur, head.next = head.next, pre\\n        return self.reverseList(cur, head)",
                "codeTag": "Python3"
            },
            {
                "id": 3741826,
                "title": "using-stacks-in-c",
                "content": "# Intuition\\nuse stacks just push the elements of the given list into new list in LIFO order \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n int isfull(struct ListNode *t)\\n{\\n    struct ListNode *q=(struct ListNode *)malloc(sizeof(struct ListNode));\\n    if(q==NULL)\\n    {\\n        return 1;\\n    }\\n    else\\n    return 0;\\n}\\nint isempty(struct ListNode *t)\\n{\\n    if(t==NULL)\\n    {\\n        return 1;\\n    }\\n    else\\n    return 0;\\n}\\nstruct ListNode *push(struct ListNode *t,int val)\\n{\\n    if(isfull(t))\\n    printf(\"stack full\");\\n    else\\n    {\\n        struct ListNode *q=(struct ListNode *)malloc(sizeof(struct ListNode));\\n        q->val=val;\\n        q->next=t;\\n        t=q;\\n        return t;\\n    }\\n    return t;\\n}\\nstruct ListNode* reverseList(struct ListNode* head){\\n    struct ListNode *u=head;\\n     struct ListNode *top=NULL;\\n    while(u!=NULL)\\n    {\\n        top=push(top,u->val);\\n        u=u->next;\\n    }\\n    return top;\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n int isfull(struct ListNode *t)\\n{\\n    struct ListNode *q=(struct ListNode *)malloc(sizeof(struct ListNode));\\n    if(q==NULL)\\n    {\\n        return 1;\\n    }\\n    else\\n    return 0;\\n}\\nint isempty(struct ListNode *t)\\n{\\n    if(t==NULL)\\n    {\\n        return 1;\\n    }\\n    else\\n    return 0;\\n}\\nstruct ListNode *push(struct ListNode *t,int val)\\n{\\n    if(isfull(t))\\n    printf(\"stack full\");\\n    else\\n    {\\n        struct ListNode *q=(struct ListNode *)malloc(sizeof(struct ListNode));\\n        q->val=val;\\n        q->next=t;\\n        t=q;\\n        return t;\\n    }\\n    return t;\\n}\\nstruct ListNode* reverseList(struct ListNode* head){\\n    struct ListNode *u=head;\\n     struct ListNode *top=NULL;\\n    while(u!=NULL)\\n    {\\n        top=push(top,u->val);\\n        u=u->next;\\n    }\\n    return top;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162279,
                "title": "idiomatic-rust-with-recursion-analysis",
                "content": "# Intuition\\n1. encounter a node \\n2. If node is None, return prev.\\n3. save its next node as tmp\\n4. swap its next and prev\\n5. move to tmp adn do 1\\n\\n# Approach\\nRecursion: using the call-stack\\nThe std::mem::replace in Rust nicely combines 3/4\\nThe `match` syntax bit does 2/3\\nCould also use `if let` and `else` instead of `match`\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\ntype T = Option<Box<ListNode>>;\\nimpl Solution {\\n    pub fn reverse_list(head: T) -> T {\\n               cur_prev(head, None)\\n    }\\n}\\n\\nfn cur_prev(cur: T, prev: T) -> T{\\n    match cur{\\n        Some(mut node) => cur_prev(std::mem::replace(&mut node.next, prev), Some(node)),\\n        None => prev\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```\\ntype T = Option<Box<ListNode>>;\\nimpl Solution {\\n    pub fn reverse_list(head: T) -> T {\\n               cur_prev(head, None)\\n    }\\n}\\n\\nfn cur_prev(cur: T, prev: T) -> T{\\n    match cur{\\n        Some(mut node) => cur_prev(std::mem::replace(&mut node.next, prev), Some(node)),\\n        None => prev\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3130091,
                "title": "simple-js-solution-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n JavaScript function that reverses a singly linked list\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Store the next node in a variable \"next\".\\n2. Reverse the \"next\" pointer of the current node, pointing it to the previous node \"prev\".\\n3. Move \"prev\" one step forward to the current node.\\n4. Move \"curr\" one step forward to the next node.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1).\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseList = function(head) {\\n    let prev = null;\\n    let curr = head;\\n  while (curr !== null) {\\n    let next = curr.next;\\n    curr.next = prev;\\n    prev = curr;\\n    curr = next;\\n  }\\n  \\n  return prev;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseList = function(head) {\\n    let prev = null;\\n    let curr = head;\\n  while (curr !== null) {\\n    let next = curr.next;\\n    curr.next = prev;\\n    prev = curr;\\n    curr = next;\\n  }\\n  \\n  return prev;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676861,
                "title": "easy-recursive-and-iterative-both-method-o-n",
                "content": "Iterative method\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode *curr = head, *prev = NULL;\\n        while(curr){\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n        \\n    }\\n};\\n```\\n\\nRecursive \\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode *curr, ListNode *prev){\\n        if(!curr) return prev;\\n        ListNode *temp = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = temp;\\n        prev = reverse(curr,prev);\\n        return prev;\\n    }\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode *prev = NULL;\\n        return reverse(head,prev);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode *curr = head, *prev = NULL;\\n        while(curr){\\n            ListNode *temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode *curr, ListNode *prev){\\n        if(!curr) return prev;\\n        ListNode *temp = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = temp;\\n        prev = reverse(curr,prev);\\n        return prev;\\n    }\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode *prev = NULL;\\n        return reverse(head,prev);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773099,
                "title": "python-solution",
                "content": "Here\\'s my solution:\\n```\\n# Runtime: 55 ms, faster than 37.85% of Python3 online submissions for Reverse Linked List.\\n# Memory Usage: 15.4 MB, less than 98.38% of Python3 online submissions for Reverse Linked List.\\nclass Solution:\\n    def reverseList(self, head):\\n        if head == None:\\n            return head\\n        else:\\n            prevNode, currNode = head, head\\n            while currNode != None:\\n                if prevNode == currNode:\\n                    currNode = currNode.next\\n                    prevNode.next = None\\n                else:\\n                    nextNode = currNode.next\\n                    currNode.next = prevNode\\n                    prevNode = currNode\\n                    currNode = nextNode\\n        return prevNode\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Runtime: 55 ms, faster than 37.85% of Python3 online submissions for Reverse Linked List.\\n# Memory Usage: 15.4 MB, less than 98.38% of Python3 online submissions for Reverse Linked List.\\nclass Solution:\\n    def reverseList(self, head):\\n        if head == None:\\n            return head\\n        else:\\n            prevNode, currNode = head, head\\n            while currNode != None:\\n                if prevNode == currNode:\\n                    currNode = currNode.next\\n                    prevNode.next = None\\n                else:\\n                    nextNode = currNode.next\\n                    currNode.next = prevNode\\n                    prevNode = currNode\\n                    currNode = nextNode\\n        return prevNode\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526339,
                "title": "recursive-bottom-up-and-top-down-approach-explained-line-by-line-c",
                "content": "The main difference between the bottom-up and top-down approach is the order of the recursion calls.\\n\\nIn the bottom-up, we first call the recursion, and then work with the pointers, so we start to create our linked list from the latest element to the first element.\\n\\nOn the other hand, in the top-down approach, we first work if our pointers, and then call the recursion function, so we\\'ll build our linked list from the first element to the latest.\\n\\nBottom-up:\\n```\\n\\t// Take as example: 1 2 3 4 5\\n    ListNode* reverseList(ListNode* head){\\n\\t\\t// In a recursion function, first provide the stop conditions\\n        if(!head || !head->next) return head;\\n\\t\\t\\n\\t\\t// So, we\\'ll to the last element (5->next == nullptr) and the penult element (5 == nullptr)\\n        ListNode* p = reverseList(head->next);\\n\\t\\t\\n\\t\\t// Then the first element (from the right to left) will be 4\\n\\t\\t// So, 4->next->next is a smart way to say 5->next\\n\\t\\t// And head in this case is 4, this way we are saying: 5->next = 4 (and it makes sense, draw it!)\\n        head->next->next = head;\\n\\t\\t\\n\\t\\t// After that, head->next is the same as 4->next = nullptr\\n\\t\\t// It make sense too, because we need that the 4 don\\'t point anymore to 5\\n        head->next = nullptr;\\n\\t\\t\\n\\t\\t// Here we return bp Note that we didn\\'t make any changes in p\\n\\t\\t// We only obtain p one time, when we were in the 4 element\\n\\t\\t// then we just pass this pointer to the other elements (parents) just to keep the head of the revert list (amazing!)\\n        return p;\\n    }\\n```\\n\\nTop-down: (this approach was implemented by [rtsouza15](https://leetcode.com/rtsouza15/)).\\n```\\n   // Taking as an example: 1 2 3 4 5\\n   ListNode* reverse(ListNode* curr, ListNode* next){ // curr -> nullptr  next -> 1\\n\\t   // in our recursive function, first we need to create a stop condition\\n        if (next == nullptr) // 1 != nullptr\\n            return curr;\\n\\n\\t\\t// Then, we need to keep save the next element, in order to don\\'t miss the linked list\\n        ListNode* right = next->next; // right -> 2 \\n\\t\\t\\n\\t\\t// So, we point the next element to our current element\\n        next->next = curr; // 1-> nullptr\\n\\n\\t\\t// Finally, we call the recurtion giving as current element our next element, and as next element our saved node (right)\\n        return reverse(next, right);\\n    }\\n    \\n    ListNode* reverseList(ListNode* head) {\\n        if (head == NULL || head->next == NULL) // here we check some edge cases\\n            return head;\\n\\t\\t\\t\\n\\t\\t// as we need to keep save the current node and the next node\\n\\t\\t// we need to create a reverse function with more parameters\\n        return reverse(NULL, head); \\n    }\\n```\\nIf it helped you, please upvote, else tell me what I should improve :)\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\t// Take as example: 1 2 3 4 5\\n    ListNode* reverseList(ListNode* head){\\n\\t\\t// In a recursion function, first provide the stop conditions\\n        if(!head || !head->next) return head;\\n\\t\\t\\n\\t\\t// So, we\\'ll to the last element (5->next == nullptr) and the penult element (5 == nullptr)\\n        ListNode* p = reverseList(head->next);\\n\\t\\t\\n\\t\\t// Then the first element (from the right to left) will be 4\\n\\t\\t// So, 4->next->next is a smart way to say 5->next\\n\\t\\t// And head in this case is 4, this way we are saying: 5->next = 4 (and it makes sense, draw it!)\\n        head->next->next = head;\\n\\t\\t\\n\\t\\t// After that, head->next is the same as 4->next = nullptr\\n\\t\\t// It make sense too, because we need that the 4 don\\'t point anymore to 5\\n        head->next = nullptr;\\n\\t\\t\\n\\t\\t// Here we return bp Note that we didn\\'t make any changes in p\\n\\t\\t// We only obtain p one time, when we were in the 4 element\\n\\t\\t// then we just pass this pointer to the other elements (parents) just to keep the head of the revert list (amazing!)\\n        return p;\\n    }\\n```\n```\\n   // Taking as an example: 1 2 3 4 5\\n   ListNode* reverse(ListNode* curr, ListNode* next){ // curr -> nullptr  next -> 1\\n\\t   // in our recursive function, first we need to create a stop condition\\n        if (next == nullptr) // 1 != nullptr\\n            return curr;\\n\\n\\t\\t// Then, we need to keep save the next element, in order to don\\'t miss the linked list\\n        ListNode* right = next->next; // right -> 2 \\n\\t\\t\\n\\t\\t// So, we point the next element to our current element\\n        next->next = curr; // 1-> nullptr\\n\\n\\t\\t// Finally, we call the recurtion giving as current element our next element, and as next element our saved node (right)\\n        return reverse(next, right);\\n    }\\n    \\n    ListNode* reverseList(ListNode* head) {\\n        if (head == NULL || head->next == NULL) // here we check some edge cases\\n            return head;\\n\\t\\t\\t\\n\\t\\t// as we need to keep save the current node and the next node\\n\\t\\t// we need to create a reverse function with more parameters\\n        return reverse(NULL, head); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1451236,
                "title": "javascript-easy-to-understand-loop-and-recursion",
                "content": "To reverse a linked list with O(n) time and O(1) space, we could traversal the whole linked list and relink the `next` pointer to the prev node. The only thing we need to do is using a variable to keep the `prev` node.\\nThe strategy is straight forward, if you have any question, please comment and I\\'ll reply.\\n\\nHere\\'s the loop solution code:\\n\\n```js\\nconst reverseList = (head) => {\\n  let prev = null;\\n  while (head) {\\n    const next = head.next;\\n    head.next = prev;\\n    prev = head;\\n    head = next;\\n  }\\n  return prev;\\n};\\n```\\n\\nAnd, sure, we could do it via recursion:\\n\\n```js\\nconst reverseList = (cur, prev = null) => {\\n  if (!cur) return prev;\\n  const next = cur.next;\\n  cur.next = prev;\\n  return reverseList(next, cur);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst reverseList = (head) => {\\n  let prev = null;\\n  while (head) {\\n    const next = head.next;\\n    head.next = prev;\\n    prev = head;\\n    head = next;\\n  }\\n  return prev;\\n};\\n```\n```js\\nconst reverseList = (cur, prev = null) => {\\n  if (!cur) return prev;\\n  const next = cur.next;\\n  cur.next = prev;\\n  return reverseList(next, cur);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1127135,
                "title": "python-code-with-full-detailed-explanations",
                "content": "The comments are already added regarding the logic although its pretty staright forward and simple\\n\\n        # SO bacially we will take 3 pointers one is \\n        #curr = head\\n        #prev\\n        #next i.e. curr.next coz if we will directly point our curr.next to prev then we loose connection with curr.next\\n        \\n        \\n        curr = head\\n        next = None\\n        prev = None\\n        \\n        while curr!=None:\\n            #firstly initalize next\\n            next = curr.next\\n            \\n            #now prev\\n            curr.next = prev\\n            \\n            \\n            #Also keep updating the prev so that we know what is the prev element to curr\\n            \\n            prev = curr\\n            \\n            \\n            #Now update curr as next --> which current.next\\n            curr = next\\n            \\n        # returning prev beacuse when curr = None and next is None then we are left with prev     \\n        return prev\\n\\t\\t\\n**UPVOTE IF YOU FIND IT HELPFUL**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "The comments are already added regarding the logic although its pretty staright forward and simple\\n\\n        # SO bacially we will take 3 pointers one is \\n        #curr = head\\n        #prev\\n        #next i.e. curr.next coz if we will directly point our curr.next to prev then we loose connection with curr.next\\n        \\n        \\n        curr = head\\n        next = None\\n        prev = None\\n        \\n        while curr!=None:\\n            #firstly initalize next\\n            next = curr.next\\n            \\n            #now prev\\n            curr.next = prev\\n            \\n            \\n            #Also keep updating the prev so that we know what is the prev element to curr\\n            \\n            prev = curr\\n            \\n            \\n            #Now update curr as next --> which current.next\\n            curr = next\\n            \\n        # returning prev beacuse when curr = None and next is None then we are left with prev     \\n        return prev\\n\\t\\t\\n**UPVOTE IF YOU FIND IT HELPFUL**",
                "codeTag": "Unknown"
            },
            {
                "id": 528296,
                "title": "c-minimalizm",
                "content": "```cpp\\nListNode* reverseList(ListNode* cur, ListNode* prev = nullptr) {\\n    while (cur != nullptr) {\\n        swap(cur->next, prev);\\n        swap(prev, cur);     \\n    }\\n    return prev;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nListNode* reverseList(ListNode* cur, ListNode* prev = nullptr) {\\n    while (cur != nullptr) {\\n        swap(cur->next, prev);\\n        swap(prev, cur);     \\n    }\\n    return prev;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 469204,
                "title": "python-js-java-c-o-n-by-recursion-w-comment",
                "content": "Python/JS/Java/C++ O(n) by recursion \\n\\n-------------------------\\n**Implementation** by Python\\n\\n```\\nclass Solution:\\n    \\n    def helper(self, prev, cur):\\n        \\n        if cur:\\n\\n            # locate next hopping node\\n            next_hop = cur.next\\n            \\n            # reverse direction\\n            cur.next = prev\\n        \\n            return self.helper( cur, next_hop)\\n        \\n        else:\\n\\n            # new head of reverse linked list\\n            return prev    \\n            \\n    \\n    def reverseList(self, head: ListNode) -> ListNode:\\n        \\n        return self.helper( None, head)\\n```\\n\\nExtra sharing of iterative implementaiton\\n\\n\\n```\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        \\n        prev, cur = None, head\\n        \\n        while cur:\\n            \\n            # locate next hoppoing node\\n            next_hop = cur.next\\n            \\n            # reverse direction\\n            cur.next = prev\\n                \\n            prev = cur\\n            cur = next_hop\\n\\n        # new head of reverse linked list    \\n        return prev\\n```\\n\\n---\\n\\n**Implementation** by Javascript:\\n\\n```\\nvar reverseList = function(head) {\\n\\n    var reverseLink =function( prev, cur){\\n\\n        if( cur == null ){\\n            // Base case aka stop condition\\n            return prev;\\n        }\\n\\n        // General cases:\\n\\n        // backup original next node\\n        let nextNode = cur.next;\\n\\n        // reverse current node\\n        cur.next = prev;\\n\\n        // reverse next node recursively\\n        return reverseLink( cur, nextNode);\\n    };\\n\\n    return reverseLink( null, head);    \\n\\n};\\n```\\n\\n---\\n\\n**Implementation** by Java:\\n\\n```\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n            \\n        return reverseLink( null, head);\\n    }\\n    \\n    private ListNode reverseLink( ListNode prev, ListNode cur){\\n        \\n        if( cur == null ){\\n            // Base case aka stop condition\\n            return prev;\\n        }\\n\\n        // General cases:\\n\\n        // backup original next node\\n        ListNode nextNode = cur.next;\\n\\n        // reverse current node\\n        cur.next = prev;\\n\\n        // reverse next node recursively\\n        return reverseLink( cur, nextNode);        \\n        \\n    }\\n\\n}\\n```\\n\\n---\\n\\n**Implementation** by C++\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        \\n        std::function< ListNode* (ListNode*, ListNode* ) > reverseLink;\\n        reverseLink =[&](ListNode* prev, ListNode* cur)->ListNode*{\\n            \\n            if( cur == nullptr ){\\n                // Base case aka stop condition\\n                return prev;\\n            }\\n            \\n            // General cases:\\n            \\n            // backup original next node\\n            ListNode *nextNode = cur->next;\\n            \\n            // reverse current node\\n            cur->next = prev;\\n            \\n            // reverse next node recursively\\n            return reverseLink( cur, nextNode);\\n        };\\n        \\n        return reverseLink( nullptr, head);\\n    }\\n};\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #92 Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def helper(self, prev, cur):\\n        \\n        if cur:\\n\\n            # locate next hopping node\\n            next_hop = cur.next\\n            \\n            # reverse direction\\n            cur.next = prev\\n        \\n            return self.helper( cur, next_hop)\\n        \\n        else:\\n\\n            # new head of reverse linked list\\n            return prev    \\n            \\n    \\n    def reverseList(self, head: ListNode) -> ListNode:\\n        \\n        return self.helper( None, head)\\n```\n```\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        \\n        prev, cur = None, head\\n        \\n        while cur:\\n            \\n            # locate next hoppoing node\\n            next_hop = cur.next\\n            \\n            # reverse direction\\n            cur.next = prev\\n                \\n            prev = cur\\n            cur = next_hop\\n\\n        # new head of reverse linked list    \\n        return prev\\n```\n```\\nvar reverseList = function(head) {\\n\\n    var reverseLink =function( prev, cur){\\n\\n        if( cur == null ){\\n            // Base case aka stop condition\\n            return prev;\\n        }\\n\\n        // General cases:\\n\\n        // backup original next node\\n        let nextNode = cur.next;\\n\\n        // reverse current node\\n        cur.next = prev;\\n\\n        // reverse next node recursively\\n        return reverseLink( cur, nextNode);\\n    };\\n\\n    return reverseLink( null, head);    \\n\\n};\\n```\n```\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n            \\n        return reverseLink( null, head);\\n    }\\n    \\n    private ListNode reverseLink( ListNode prev, ListNode cur){\\n        \\n        if( cur == null ){\\n            // Base case aka stop condition\\n            return prev;\\n        }\\n\\n        // General cases:\\n\\n        // backup original next node\\n        ListNode nextNode = cur.next;\\n\\n        // reverse current node\\n        cur.next = prev;\\n\\n        // reverse next node recursively\\n        return reverseLink( cur, nextNode);        \\n        \\n    }\\n\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        \\n        std::function< ListNode* (ListNode*, ListNode* ) > reverseLink;\\n        reverseLink =[&](ListNode* prev, ListNode* cur)->ListNode*{\\n            \\n            if( cur == nullptr ){\\n                // Base case aka stop condition\\n                return prev;\\n            }\\n            \\n            // General cases:\\n            \\n            // backup original next node\\n            ListNode *nextNode = cur->next;\\n            \\n            // reverse current node\\n            cur->next = prev;\\n            \\n            // reverse next node recursively\\n            return reverseLink( cur, nextNode);\\n        };\\n        \\n        return reverseLink( nullptr, head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434665,
                "title": "simple-in-place-python-solution",
                "content": "Your initial instinct might be to iterate through and store values in a stack (list in Python).  Then you would have to iterate through again and pop off items off the stack and build a new linked list in reverse order (a stack data structure will naturally help you do that).  However, storing the stack structure and building a new linked list data structure would result in O(n) space complexity.  So you\\'ll want to think of a way to do this in-place while iterating through the linked list (yielding O(1) space complexity).\\n\\nYou can do this by reversing the links of the existing linked list.  As you traverse the linked list you\\'ll want to keep track of the previous node, and modify the next point of the current node to point to the previous node.  But what happens if you just modify the next pointer to point to the previous node?  You\\'ll lose the pointer to the next node.  So you\\'ll also want to keep track of the next node itself.  \\n\\nHere\\'s the Python solution in-place keeping track of the previous and next nodes.\\n\\n```\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        node = head\\n        prev = None\\n        while node:\\n            _next = node.next\\n            node.next = prev\\n            prev = node\\n            node = _next\\n        return prev\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        node = head\\n        prev = None\\n        while node:\\n            _next = node.next\\n            node.next = prev\\n            prev = node\\n            node = _next\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 58175,
                "title": "my-java-solution",
                "content": "    public class Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n\\t\\twhile (head != null) {\\n\\t\\t\\tListNode temp = head.next;\\n\\t\\t\\thead.next = prev;\\n\\t\\t\\tprev = head;\\n\\t\\t\\thead = temp;\\n\\t\\t}\\n\\t\\treturn prev;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n\\t\\twhile (head != null) {\\n\\t\\t\\tListNode temp = head.next;\\n\\t\\t\\thead.next = prev;\\n\\t\\t\\tprev = head;\\n\\t\\t\\thead = temp;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 58502,
                "title": "simple-c-iterative-solution",
                "content": "    class Solution {\\n    public:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head) return head;\\n        \\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        ListNode* next = NULL;\\n        \\n        while(cur) {\\n            next = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        \\n        return prev;\\n     }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head) return head;\\n        \\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        ListNode* next = NULL;\\n        \\n        while(cur) {\\n            next = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4069546,
                "title": "c-java-python-javascript",
                "content": "\\uD83D\\uDCAF\\uD83D\\uDD25 C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\nRead Whole article :https://www.nileshblog.tech/reverse-linked-list/\\n\\nExplanation Eg.\\nTime Complexity:\\n\\nAddress Manipulation .\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/reverse-linked-list/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3872823,
                "title": "easy-c-solution-beats-100-of-the-solutions-play-with-pointers",
                "content": "# Intuition\\nReverse the list one by one i.e. Node by Node\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe use 3 pointers curr, prev & next where curr will be there to point on the current element, prev will start from null and will be one step behind the current and next to take care of the elements after the current element in the list.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**$$O(N)$$**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**$$O(1)$$**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n     if(head==nullptr || head->next==nullptr)\\n     {\\n         return head;\\n     }\\n     ListNode *curr, *prev, *next;\\n     curr=head;\\n     prev=nullptr;\\n     while(curr!=nullptr)\\n     {\\n         next=curr->next;\\n         curr->next=prev;\\n         prev=curr;\\n         curr=next;\\n     }\\n     return prev;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n     if(head==nullptr || head->next==nullptr)\\n     {\\n         return head;\\n     }\\n     ListNode *curr, *prev, *next;\\n     curr=head;\\n     prev=nullptr;\\n     while(curr!=nullptr)\\n     {\\n         next=curr->next;\\n         curr->next=prev;\\n         prev=curr;\\n         curr=next;\\n     }\\n     return prev;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170391,
                "title": "js-solution-easy",
                "content": "# Intuition\\nThree pointers to reverse the linked list.\\n\\n# Approach\\nprev pointer keeps track of the reversed list\\ncurrent pointer used to traverse the list\\nnext pointer is used to temporarily store the next node in the original list so we can reverse the pointers for each node.\\n\\n# Complexity\\n- Time complexity:\\nO(n): where n is the number of nodes in the linked list, this is because we traversed the list once to reverse the pointers in each node\\n\\n- Space complexity:\\nO(1): we are only using 3 additional variables to store the pointers. The reversed list uses the same nodes, so there is no additional memory used.\\n\\n# Code\\n```\\nconst reverseList = (head) => {\\n    let current = head\\n    let prev = null\\n    let next = null\\n    \\n    while (current) {\\n        next = current.next\\n        current.next = prev\\n        prev = current\\n        current = next\\n    }\\n\\n    return prev\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst reverseList = (head) => {\\n    let current = head\\n    let prev = null\\n    let next = null\\n    \\n    while (current) {\\n        next = current.next\\n        current.next = prev\\n        prev = current\\n        current = next\\n    }\\n\\n    return prev\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3132455,
                "title": "conversion-of-linked-list-to-list-using-python",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst=[]\\n\\n        while head:\\n            lst.append(head.val) #Conversion of linked list\\n            head=head.next\\n        lst=lst[::-1] #reverse list\\n\\n        ans=ListNode(0) #staring index val 0\\n        tmp=ans\\n        for i in lst:\\n            tmp.next=ListNode(i) #conversion of list vales to linked list\\n            tmp=tmp.next\\n        return ans.next \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst=[]\\n\\n        while head:\\n            lst.append(head.val) #Conversion of linked list\\n            head=head.next\\n        lst=lst[::-1] #reverse list\\n\\n        ans=ListNode(0) #staring index val 0\\n        tmp=ans\\n        for i in lst:\\n            tmp.next=ListNode(i) #conversion of list vales to linked list\\n            tmp=tmp.next\\n        return ans.next \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847884,
                "title": "golang-simple-recursive-with-explanation",
                "content": "# Solution\\n<!-- Describe your approach to solving the problem. -->\\nThis is the explanation for this recursive solution. For simplicity, we will use an input head that points to 1 -> 2 -> 3.\\n\\nI\\'ll run through the recursive solution in chronological layers.\\n\\n### Outer Layer:\\nInput 1 (current) = 1 -> 2 -> 3 -> nil\\nInput 2 (prev) = nil\\n\\nnext = 2 -> 3 -> nil `next := current.Next`\\ncurrent = 1 -> nil `current.Next = prev`\\n\\n### Layer 2:\\nInput 1 (current) = 2 -> 3 -> nil\\nInput 2 (prev) = 1 -> nil\\n\\nnext = 3 -> nil `next := current.Next`\\ncurrent = 2 -> 1 -> nil `current.Next = prev`\\n\\n### Layer 3:\\nInput 1 (current) = 3 -> nil\\nInput 2 (prev) = 2 -> 1 -> nil\\n\\nnext = nil `next := current.Next`\\ncurrent = 3 -> 2 -> 1 -> nil `current.Next = prev`\\n\\n### Layer 4:\\nInput 1 (current) = nil\\nInput 2 (prev) = 3 -> 2 -> 1 -> nil\\n\\nSince current == nil, return prev which is the reverse linked list 3 -> 2 -> 1 -> nil<br />`if current == nil{return prev}`\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc helper(current *ListNode, prev *ListNode) *ListNode {\\n    if current == nil{\\n        return prev\\n    }\\n    next := current.Next\\n    current.Next = prev\\n    return helper(next, current)\\n}\\n\\nfunc reverseList(head *ListNode) *ListNode {\\n    return helper(head, nil)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc helper(current *ListNode, prev *ListNode) *ListNode {\\n    if current == nil{\\n        return prev\\n    }\\n    next := current.Next\\n    current.Next = prev\\n    return helper(next, current)\\n}\\n\\nfunc reverseList(head *ListNode) *ListNode {\\n    return helper(head, nil)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2201727,
                "title": "206-reverse-linked-list-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == NULL or head->next == NULL)\\n        {\\n            return head;\\n        }\\n        \\n        ListNode* previous = NULL;\\n        ListNode* current = head;\\n        ListNode* ahead = current->next;\\n        \\n        while(current != NULL)\\n        {\\n            current->next = previous;\\n            previous = current;\\n            current = ahead;\\n            if(current != NULL)\\n            {\\n                ahead = current->next;\\n            }\\n        }\\n        return previous;\\n    }\\n};\\n```\\n\\n**pls UPVOTE : )**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == NULL or head->next == NULL)\\n        {\\n            return head;\\n        }\\n        \\n        ListNode* previous = NULL;\\n        ListNode* current = head;\\n        ListNode* ahead = current->next;\\n        \\n        while(current != NULL)\\n        {\\n            current->next = previous;\\n            previous = current;\\n            current = ahead;\\n            if(current != NULL)\\n            {\\n                ahead = current->next;\\n            }\\n        }\\n        return previous;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624113,
                "title": "typescript-solution-o-n-time-o-1-space-faster-than-93-just-6-lines",
                "content": "```\\nfunction reverseList(head: ListNode | null): ListNode | null {\\n//     const n = new ListNode(head.val)\\n//     const n1 = new ListNode(head.next.val,n);\\n//     const n2 = new ListNode(head.next.next.val,n1);\\n//     ...\\n\\n    let n = null, h = head;\\n    while(h!==null){\\n        n = new ListNode(h.val,n)\\n        h = h.next;\\n    }\\n    return n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction reverseList(head: ListNode | null): ListNode | null {\\n//     const n = new ListNode(head.val)\\n//     const n1 = new ListNode(head.next.val,n);\\n//     const n2 = new ListNode(head.next.next.val,n1);\\n//     ...\\n\\n    let n = null, h = head;\\n    while(h!==null){\\n        n = new ListNode(h.val,n)\\n        h = h.next;\\n    }\\n    return n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139247,
                "title": "easy-simple-super-fast-javascript-code",
                "content": "```\\nvar reverseList = function(head) {\\n    prev= null;\\n    while(head){\\n        [head.next, prev, head] = [prev, head, head.next]\\n    }\\n    \\n    return prev\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseList = function(head) {\\n    prev= null;\\n    while(head){\\n        [head.next, prev, head] = [prev, head, head.next]\\n    }\\n    \\n    return prev\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 800334,
                "title": "javascript-solution-206",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nlet reverseList = function(head) {\\n    let prev = null, next = null;\\n    while (head) {\\n        next = head.next\\n        head.next = prev;\\n        prev = head;\\n        head = next;\\n    }\\n    return prev;\\n};\\n```\\n\\n**Runtime: 84 ms, faster than 45.28% of JavaScript online submissions for Reverse Linked List.**\\n\\n**Memory Usage: 38.5 MB, less than 36.98% of JavaScript online submissions for Reverse Linked List.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nlet reverseList = function(head) {\\n    let prev = null, next = null;\\n    while (head) {\\n        next = head.next\\n        head.next = prev;\\n        prev = head;\\n        head = next;\\n    }\\n    return prev;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796499,
                "title": "basic-js-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseList = function(head) {\\n    let prev = null, cur = head, next = null;\\n    while (cur != null) {\\n        next = cur.next;\\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n    }\\n    return prev;\\n    \\n    /*\\n    Test Cases:\\n    [] => null\\n    [1] => [1]\\n    [1,2,3] => [3,2,1]\\n    \\n    Time Complexity: O(n)\\n    Space Complexity: O(1)\\n    */\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseList = function(head) {\\n    let prev = null, cur = head, next = null;\\n    while (cur != null) {\\n        next = cur.next;\\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n    }\\n    return prev;\\n    \\n    /*\\n    Test Cases:\\n    [] => null\\n    [1] => [1]\\n    [1,2,3] => [3,2,1]\\n    \\n    Time Complexity: O(n)\\n    Space Complexity: O(1)\\n    */\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 578100,
                "title": "elegant-scala-solution-using-recursive-and-match",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode(var _x: Int = 0) {\\n *   var next: ListNode = null\\n *   var x: Int = _x\\n * }\\n */\\nobject Solution {\\n    def reverseList(head: ListNode): ListNode = {\\n        \\n        def loop(head: ListNode, result: ListNode) : ListNode = {\\n            head match {\\n                case null => result\\n                case h => {\\n                    val current = h.next\\n                    h.next = result\\n                    loop(current, h)\\n                }\\n            }\\n        }\\n                \\n        loop(head, null)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode(var _x: Int = 0) {\\n *   var next: ListNode = null\\n *   var x: Int = _x\\n * }\\n */\\nobject Solution {\\n    def reverseList(head: ListNode): ListNode = {\\n        \\n        def loop(head: ListNode, result: ListNode) : ListNode = {\\n            head match {\\n                case null => result\\n                case h => {\\n                    val current = h.next\\n                    h.next = result\\n                    loop(current, h)\\n                }\\n            }\\n        }\\n                \\n        loop(head, null)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 58116,
                "title": "simple-java-code-without-recursive",
                "content": "\\n```\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null) return head;\\n        ListNode temp = head.next;\\n        head.next = null;\\n        while(temp!=null){\\n            ListNode t = temp.next;\\n            temp.next = head;\\n            head = temp;\\n            temp = t;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null) return head;\\n        ListNode temp = head.next;\\n        head.next = null;\\n        while(temp!=null){\\n            ListNode t = temp.next;\\n            temp.next = head;\\n            head = temp;\\n            temp = t;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 58194,
                "title": "intuitive-recursive-javascript-solution",
                "content": "```\\nvar reverseList = function(head) {\\n    return head ? reverse(head, null) : head;\\n};\\n\\nfunction reverse (node, previous) {\\n    let newHead = node;\\n\\n    // recursive call to tail\\n    if (node.next) newHead = reverse(node.next, node);\\n    // reverse from tail all the way up to head\\n    node.next = previous;\\n    \\n    return newHead;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseList = function(head) {\\n    return head ? reverse(head, null) : head;\\n};\\n\\nfunction reverse (node, previous) {\\n    let newHead = node;\\n\\n    // recursive call to tail\\n    if (node.next) newHead = reverse(node.next, node);\\n    // reverse from tail all the way up to head\\n    node.next = previous;\\n    \\n    return newHead;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 58328,
                "title": "simple-0ms-iterative-and-recursive-solutions-in-c",
                "content": "    struct ListNode* reverseList(struct ListNode* head) {\\n        if(head==NULL||head->next==NULL)\\n        return head;\\n        struct ListNode *root=reverseList(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return root;\\n    }\\n    \\n    \\n    struct ListNode* reverseList(struct ListNode* head) {\\n        struct ListNode *prev=NULL,*next;\\n        while(head)\\n        {\\n            next=head->next;\\n            head->next=prev;\\n            prev=head;\\n            head=next;\\n        }\\n        return prev;\\n    }",
                "solutionTags": [],
                "code": "    struct ListNode* reverseList(struct ListNode* head) {\\n        if(head==NULL||head->next==NULL)\\n        return head;\\n        struct ListNode *root=reverseList(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return root;\\n    }\\n    \\n    \\n    struct ListNode* reverseList(struct ListNode* head) {\\n        struct ListNode *prev=NULL,*next;\\n        while(head)\\n        {\\n            next=head->next;\\n            head->next=prev;\\n            prev=head;\\n            head=next;\\n        }\\n        return prev;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 58371,
                "title": "c-iterative-and-recursive-solutions",
                "content": "        \\n    ListNode* reverseList1(ListNode* head) {\\n        ListNode *node = NULL;\\n        while (head) {\\n            ListNode *nxt = head->next;\\n            head->next = node;\\n            node = head;\\n            head = nxt;\\n        }\\n        return node;\\n    }\\n    \\n    ListNode* reverseList(ListNode* head) {\\n        return reverse(head, NULL);\\n    }\\n    \\n    ListNode* reverse(ListNode* head, ListNode* node) {\\n        if (head==nullptr)\\n            return node;\\n        ListNode *nxt = head->next;\\n        head->next = node;\\n        return reverse(nxt, head);\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    ListNode* reverseList1(ListNode* head) {\\n        ListNode *node = NULL;\\n        while (head) {\\n            ListNode *nxt = head->next;\\n            head->next = node;\\n            node = head;\\n            head = nxt;\\n        }\\n        return node;\\n    }\\n    \\n    ListNode* reverseList(ListNode* head) {\\n        return reverse(head, NULL);\\n    }\\n    \\n    ListNode* reverse(ListNode* head, ListNode* node) {\\n        if (head==nullptr)\\n            return node;\\n        ListNode *nxt = head->next;\\n        head->next = node;\\n        return reverse(nxt, head);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 58443,
                "title": "my-iterative-solution-in-java-ac",
                "content": "My solution is below:\\n\\n    public ListNode reverseList(ListNode head) {\\n        ListNode first = null;\\n        ListNode tail = head;\\n        while (tail != null) {\\n            ListNode tmp = tail;\\n            tail = tail.next;\\n            tmp.next = first;\\n            first = tmp;\\n        }\\n        return first;\\n    }\\n\\n    \\nBtw, I thought there is no need to judge the NULL Pointer in my solution.",
                "solutionTags": [],
                "code": "My solution is below:\\n\\n    public ListNode reverseList(ListNode head) {\\n        ListNode first = null;\\n        ListNode tail = head;\\n        while (tail != null) {\\n            ListNode tmp = tail;\\n            tail = tail.next;\\n            tmp.next = first;\\n            first = tmp;\\n        }\\n        return first;\\n    }\\n\\n    \\nBtw, I thought there is no need to judge the NULL Pointer in my solution.",
                "codeTag": "Unknown"
            },
            {
                "id": 58492,
                "title": "4ms-simple-c-solution",
                "content": "The idea is simple, just iterate all nodes and process reverse meanwhile.\\n\\n    struct ListNode* newHead = NULL;\\n    while (head) {\\n        struct ListNode* tmpNode = head->next;\\n        head->next = newHead;\\n        newHead = head;\\n        head = tmpNode;\\n    }\\n    return newHead;",
                "solutionTags": [],
                "code": "The idea is simple, just iterate all nodes and process reverse meanwhile.\\n\\n    struct ListNode* newHead = NULL;\\n    while (head) {\\n        struct ListNode* tmpNode = head->next;\\n        head->next = newHead;\\n        newHead = head;\\n        head = tmpNode;\\n    }\\n    return newHead;",
                "codeTag": "Unknown"
            },
            {
                "id": 3916772,
                "title": "python3-beats-95-efficient-reversal-of-a-linked-list",
                "content": "# Intuition\\nThe core principle behind reversing a linked list is to alter the pointers between nodes to change the flow of the list. The introduction of the \"holder\" (stored in the holder variable) plays a vital role in maintaining the continuity of the process. It allows you to temporarily store the upcoming node\\'s reference, preserving the link that would otherwise be broken during the pointer reassignment.\\n\\n# Approach\\n1. Begin by identifying the start of the linked list, represented by the head node.\\n1. Initialize two pointers, prev and curr, where prev starts as None and curr starts at the head.\\n1. The \"holder\" (holder variable) is an intermediary that holds the reference to the upcoming node while you reverse the connection between the current node and the previous node.\\n1. Iterate through the list while curr is not None:\\n1. Store the next node\\'s reference in holder.\\n1. Update curr.next to point to the previous node (prev), reversing the direction of the connection.\\n1. Advance both prev and curr.\\n1. Repeat this process until the end of the original list is reached.\\n1. At this point, the prev pointer points to the newly reversed list\\'s beginning, and this becomes the returned head of the reversed linked list.\\n\\n# Complexity\\n- Time complexity:\\nWith each node visited exactly once, the time complexity remains O(n), where n stands for the number of nodes in the linked list.\\n\\n- Space complexity:\\nThe space complexity is O(1), as you employ a constant amount of extra space for variables (prev, curr, and holder)\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        prev = None\\n        curr = head\\n        holder = curr\\n\\n        while curr:\\n            holder = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = holder\\n\\n        return prev\\n\\n\\n\\n\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        prev = None\\n        curr = head\\n        holder = curr\\n\\n        while curr:\\n            holder = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = holder\\n\\n        return prev\\n\\n\\n\\n\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768326,
                "title": "two-approach-iterative-recursive-easy-java-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n//################ RECURSIVE APPROACH ##################\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        \\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        ListNode revHead = reverseList(head.next);\\n        \\n        ListNode temp = head.next;\\n        temp.next = head;\\n        head.next = null;\\n\\n        return revHead;\\n    }\\n}\\n\\n\\n//################ ITERATIVE APPROACH ##################\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode forw = null;\\n\\n        while (curr != null)\\n        {\\n\\n            forw = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forw;\\n\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/e074d223-5cba-49f1-83d7-fb09a8c3cc5b_1689419354.7035532.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n//################ RECURSIVE APPROACH ##################\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        \\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        ListNode revHead = reverseList(head.next);\\n        \\n        ListNode temp = head.next;\\n        temp.next = head;\\n        head.next = null;\\n\\n        return revHead;\\n    }\\n}\\n\\n\\n//################ ITERATIVE APPROACH ##################\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode forw = null;\\n\\n        while (curr != null)\\n        {\\n\\n            forw = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forw;\\n\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469664,
                "title": "n-1-recursive-iterative-solutions-explained",
                "content": "There are multiple possible approaches to solving this problem. In this post, I have outlined 4 approaches that are either the most performant or most mathematically interesting.\\n\\n# Impure Recursive\\n\\nTo reverse the list with recursion:\\n\\n- Add an optional parameter to keep track of the parent node\\n- If the current node is empty, bail\\n- Keep a reference to the next node\\n- Flip the direction of the current node\\'s edge\\n- If there is a next node, recurse\\n- Otherwise, return the current node\\n\\nThis will effectively iterate through the list and flip the direction of each node\\'s edge, then return the tail of the original list. To use as little memory as possible, we can make our changes directly to the input instead of creating a new list.\\n\\nThis algorithm\\'s time complexity is $$\\u0398(n)$$ (where n is the size of the original list) because it calls itself exactly once per node in the original list. The space complexity is $$\\u0398(n)$$ because a new scope is created for each level of recursion.\\n\\n```ts\\nfunction reverseList(\\n  head: ListNode | null,\\n  parent: ListNode | null = null,\\n): ListNode | null {\\n  if (!head) return parent;\\n\\n  const next = head.next;\\n  head.next = parent;\\n\\n  return reverseList(next, head);\\n};\\n```\\n\\n# Pure Recursive\\n\\nWith a slight change to the impure recursive algorithm, we can produce the same result while leaving the original list in-tact.\\n\\nThis algorithm\\'s time complexity is $$\\u0398(n)$$ (where n is the size of the original list) because it calls itself exactly once per node in the original list. The space complexity is $$\\u0398(n)$$ because the caller scope will always persist while the function recurses and the algorithm creates exactly one new node for each node in the original list.\\n\\n```ts\\nfunction reverseList(head: ListNode | null): ListNode | null {\\n  if (!head) return head;\\n\\n  function reverse(curr: ListNode, parent: ListNode | null): ListNode {\\n    const next = curr.next;\\n\\n    curr = new ListNode(curr.val, parent);\\n\\n    if (!next) return curr;\\n    return reverse(next, curr);\\n  }\\n\\n  return reverse(head, null);\\n};\\n```\\n\\n# Impure Iterative\\n\\nTo reverse the list with iteration:\\n\\n- If the current node is empty, bail\\n- Keep a reference to the previous node\\n- Do the following until the current node is empty:\\n  - Keep a reference to the next node\\n  - Flip the direction of the current node\\'s edge\\n  - Move to the next node (prev <= current, current <= next)\\n\\nTo use as little memory as possible, we can make our changes directly to the input instead of creating a new list.\\n\\nThis algorithm\\'s time complexity is $$\\u0398(n)$$ (where n is the size of the original list) because it iterates exactly once per node in the original list. The space complexity is $$\\u0398(1)$$ because it does not create any new objects and does not call and functions.\\n\\n```ts\\nfunction reverseList(head: ListNode | null): ListNode | null {\\n  let prev = null;\\n\\n  while (head) {\\n    let next = head.next;\\n    head.next = prev;\\n    prev = head;\\n    head = next;\\n  }\\n\\n  return prev;\\n}\\n```\\n\\n# Pure Iterative\\n\\nWith a small change to the impure iterative algorithm, we can keep the original list in-tact at the cost of a linear space complexity. \\n\\nThis algorithm\\'s time complexity is $$\\u0398(n)$$ (where n is the size of the original list) because it iterates exactly once per node in the original list. The space complexity is $$\\u0398(n)$$ because it creates a new node for each node found in the original list.\\n\\n```ts\\nfunction reverseList(head: ListNode | null): ListNode | null {\\n  let prev: ListNode | null = null;\\n\\n  while (head) {\\n    prev = new ListNode(head.val, prev);\\n    head = head.next;\\n  }\\n\\n  return prev;\\n}\\n```\\n\\n# Conclusion\\n\\nIn most cases, the pure iterative algorithm is preferred as it provides the best real-world performance (no bloated call stacks) while keeping the function pure. Pure functions are preferred in many cases, especially when there may be multiple algorithms running in parallel on the same list.\\n\\nIn cases where parameter ownership is known, the impure iterative algorithm is prefferred as it provides the best time and space complexity in the tight case. Keep in mind that the TypeScript compiler cannot determine parameter ownership at compile time, so new code may break this constraint. Short of rewriting your solution in Rust, documentation is the best remedy for this.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction reverseList(\\n  head: ListNode | null,\\n  parent: ListNode | null = null,\\n): ListNode | null {\\n  if (!head) return parent;\\n\\n  const next = head.next;\\n  head.next = parent;\\n\\n  return reverseList(next, head);\\n};\\n```\n```ts\\nfunction reverseList(head: ListNode | null): ListNode | null {\\n  if (!head) return head;\\n\\n  function reverse(curr: ListNode, parent: ListNode | null): ListNode {\\n    const next = curr.next;\\n\\n    curr = new ListNode(curr.val, parent);\\n\\n    if (!next) return curr;\\n    return reverse(next, curr);\\n  }\\n\\n  return reverse(head, null);\\n};\\n```\n```ts\\nfunction reverseList(head: ListNode | null): ListNode | null {\\n  let prev = null;\\n\\n  while (head) {\\n    let next = head.next;\\n    head.next = prev;\\n    prev = head;\\n    head = next;\\n  }\\n\\n  return prev;\\n}\\n```\n```ts\\nfunction reverseList(head: ListNode | null): ListNode | null {\\n  let prev: ListNode | null = null;\\n\\n  while (head) {\\n    prev = new ListNode(head.val, prev);\\n    head = head.next;\\n  }\\n\\n  return prev;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445352,
                "title": "easy-java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![IMG_20230423_020331.jpg](https://assets.leetcode.com/users/images/6b7b93ab-769d-4870-9c52-860a6ab0962a_1682204732.427848.jpeg)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode prev = null;\\n        ListNode current = head;\\n\\n        while (current != null) {\\n            ListNode next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode prev = null;\\n        ListNode current = head;\\n\\n        while (current != null) {\\n            ListNode next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389694,
                "title": "cpp-solution-iterative-recursion-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are asked to reverse the linked list, we have to point every node to its previous node.\\n\\n# Iterative Approach \\n<!-- Describe your approach to solving the problem. -->\\n1. declare two pointer, prev to null and curr to head.\\n2. keep the track of curr-> next in another node.\\n3. just set curr-> to prev and update prev to curr..\\n4. update curr to curr-> next.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        ListNode* temp = NULL;\\n        while(curr != NULL){\\n            temp = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n    }\\n};\\n```\\n# Recursive Approach\\n1. base case is when head is null or next is null.\\n2. handle first node, rest will be taken care by recursion.\\n3. call the function with head-> next.\\n4. set head -> to null.\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* &head){\\n        if(head == NULL|| head -> next == NULL)\\n        return head;\\n    \\n        ListNode* head1 = reverse(head -> next); will reverse and set head on last node. \\n        head -> next -> next = head; //(1,2,3,4,5), this will point 2 with 1.\\n        head -> next = NULL; // this will point 1 will null\\n        return head1;\\n    }\\n\\n    ListNode* reverseList(ListNode* head) {\\n        return reverse(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        ListNode* temp = NULL;\\n        while(curr != NULL){\\n            temp = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* &head){\\n        if(head == NULL|| head -> next == NULL)\\n        return head;\\n    \\n        ListNode* head1 = reverse(head -> next); will reverse and set head on last node. \\n        head -> next -> next = head; //(1,2,3,4,5), this will point 2 with 1.\\n        head -> next = NULL; // this will point 1 will null\\n        return head1;\\n    }\\n\\n    ListNode* reverseList(ListNode* head) {\\n        return reverse(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897032,
                "title": "o-n-easy-to-understand-c-soln",
                "content": "# Intuition\\nlinking each node to its previous nodes(head to null) by using two pointers next and previous ,  next pointing to current node next and previous pointing to current node previous.\\n\\n# Approach\\nI linked each node to its previous nodes(head to null) by using two pointers next and previous ,  next pointing to current node next and previous pointing to current node previous.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* pre=NULL;\\n        ListNode* next=NULL;\\n        while(head!=NULL){\\n            next=head->next;\\n            head->next=pre;\\n            pre=head;\\n            head=next;\\n        }\\n        return pre;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* pre=NULL;\\n        ListNode* next=NULL;\\n        while(head!=NULL){\\n            next=head->next;\\n            head->next=pre;\\n            pre=head;\\n            head=next;\\n        }\\n        return pre;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760720,
                "title": "3-approaches-0-ms-easy-short",
                "content": "\\n```Approach 1:```\\n\\ncode:\\n\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *reverseList(ListNode *head)\\n    {\\n        ListNode *nextNode, *prevNode = NULL;\\n        while (head)\\n        {\\n            nextNode = head->next;\\n            head->next = prevNode;\\n            prevNode = head;\\n            head = nextNode;\\n        }\\n        return prevNode;\\n    }\\n};\\n```\\n\\n```Approach 2:```\\n\\ncode:\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *reverseList(ListNode *head)\\n    {\\n\\n        if (!head || !(head->next))\\n        {\\n            return head;\\n        }\\n        ListNode *node = reverseList(head->next);\\n        head->next->next = head;\\n        head->next = NULL;\\n        return node;\\n    }\\n};\\n```\\n\\n```Approach 3:```\\n\\ncode:\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *reverseList(ListNode *head)\\n    {\\n\\n        ListNode *cur = head, *prev = NULL, *next;\\n        while (cur != NULL)\\n        {\\n            next = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        head = prev;\\n        return head;\\n    }\\n};\\n```\\n\\nHope It will help you \\uD83D\\uDE4C.\\nThank you!",
                "solutionTags": [
                    "Java",
                    "C",
                    "Linked List"
                ],
                "code": "```Approach 1:```\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *reverseList(ListNode *head)\\n    {\\n        ListNode *nextNode, *prevNode = NULL;\\n        while (head)\\n        {\\n            nextNode = head->next;\\n            head->next = prevNode;\\n            prevNode = head;\\n            head = nextNode;\\n        }\\n        return prevNode;\\n    }\\n};\\n```\n```Approach 2:```\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *reverseList(ListNode *head)\\n    {\\n\\n        if (!head || !(head->next))\\n        {\\n            return head;\\n        }\\n        ListNode *node = reverseList(head->next);\\n        head->next->next = head;\\n        head->next = NULL;\\n        return node;\\n    }\\n};\\n```\n```Approach 3:```\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *reverseList(ListNode *head)\\n    {\\n\\n        ListNode *cur = head, *prev = NULL, *next;\\n        while (cur != NULL)\\n        {\\n            next = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        head = prev;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677374,
                "title": "java-100-faster-both-iterative-recursive-solution",
                "content": "There are 2 different ways to solve this problem :\\n\\n**1. Iterative Approach  ||   TC : O(N) ,  SC :  O(1)**\\n```\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null, next = null, cur = head;\\n        \\n        while(cur!=null) {\\n            next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        return prev;\\n    }\\n```\\n\\n**2. Recursive Approach  ||   TC : O(N) ,  SC :  O(N)  for reursive stack space**\\n```\\n    public ListNode reverseList(ListNode head) {\\n        return reverseLL(null, head);\\n    }\\n    \\n    ListNode reverseLL(ListNode prev, ListNode head){\\n        // base case or termination condition - which is already solved.\\n        if(head == null)\\n            return prev;\\n        \\n        // solve single pattern - in this case, revert the \\'next\\' pointer to prev node.\\n        ListNode next = head.next;\\n        head.next = prev;\\n        \\n        return reverseLL(head, next);\\n    }\\n```\\n\\n#### Please Upvote if it helps !!",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null, next = null, cur = head;\\n        \\n        while(cur!=null) {\\n            next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        return prev;\\n    }\\n```\n```\\n    public ListNode reverseList(ListNode head) {\\n        return reverseLL(null, head);\\n    }\\n    \\n    ListNode reverseLL(ListNode prev, ListNode head){\\n        // base case or termination condition - which is already solved.\\n        if(head == null)\\n            return prev;\\n        \\n        // solve single pattern - in this case, revert the \\'next\\' pointer to prev node.\\n        ListNode next = head.next;\\n        head.next = prev;\\n        \\n        return reverseLL(head, next);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2606967,
                "title": "c-all-3-approaches-discussed-with-dry-run-easy-understanding-with-explanation",
                "content": "**Problem:** Given to us is LL and we need to reverse the same\\n**Solution:**\\nI have discussed 3 approaches here \\n1. Using stack\\n2. Using iterative (2 pointers and 3 pointers)\\n3. Using recursive approach\\n\\n**Approch 1: Using stack**\\n\\n* We will create one `stack` (as stack works on LIFO we are using the same property of stacks)\\n* Now put the nodes in LL into the` stack s`\\n* Now in the stack the first node will be at the bottom and last node will be at the top\\n* we can assign and pop out stack one by one and assign the first top element of the stack to the head\\n* thus we have reversed the LL using stack.\\n\\n![image](https://assets.leetcode.com/users/images/35ffa0be-12f7-418a-859b-cb3ff6b6983c_1663783983.5716927.jpeg)\\n\\n```\\n//using stack\\n        \\n        stack<int> s; // stack to contain the nodes in the LL\\n        \\n        ListNode* temp = head; // assign the temp varible to the head\\n        \\n        while(temp != NULL)\\n        {\\n            s.push(temp->val); // insert the values in the stack\\n            \\n            temp = temp->next; // move temp to next node\\n        }\\n        \\n        temp = head; //assign the temp to head this will work as reversal of the LL\\n        \\n        while(temp != NULL)\\n        {\\n            temp->val = s.top(); //top element in the stack will be the first element in the reversed LL\\n            \\n            s.pop(); //pop out the elements in the stack\\n            \\n            temp = temp->next; //move temo to next node\\n        }\\n        \\n        return head;\\n```\\n\\n**Approach 2: using iterative (2 pointers and 3 pointers)**\\n\\nI have found this nice animation which describes the problem approaches -  \\n\\n![image](https://assets.leetcode.com/users/images/c13b58b4-3682-40e6-baf8-d5232b04e521_1663783453.6115704.png)\\n(source of the animation: GeekForGeeks)\\n\\n3 pointers -\\n```\\n//using the iterative approach\\n        \\n        ListNode* current = head; //current element will have starting head node\\n        \\n        ListNode* previous = NULL; // null\\n        \\n        ListNode* future = NULL; // null\\n        \\n        while(current != NULL)\\n        {\\n            future = current->next;\\n            \\n            current->next = previous;\\n            \\n            previous = current;\\n            \\n            current = future;\\n        }\\n        return previous;\\n```\\n\\n2 pointers-\\n```\\n//using the iterative approach\\n        \\n        ListNode* previous = NULL; // null\\n        \\n        ListNode* future = NULL; // null\\n        \\n        while(head != NULL)\\n        {\\n            future = head->next;\\n            \\n            head->next = previous;\\n            \\n            previous = head;\\n            \\n            head = future;\\n        }\\n        return previous;\\n```\\n\\n**Approach 3: Using recursive function call**\\n\\n```\\n//recursive method\\n        \\n        if(!head || !(head->next)) return head;\\n        \\n        ListNode* temp = reverseList(head->next);\\n        \\n            head->next->next = head;\\n            \\n            head->next = NULL;\\n                \\n        return temp; \\n```\\n\\n**if you like my approach and explanation please do upvote and happy coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n//using stack\\n        \\n        stack<int> s; // stack to contain the nodes in the LL\\n        \\n        ListNode* temp = head; // assign the temp varible to the head\\n        \\n        while(temp != NULL)\\n        {\\n            s.push(temp->val); // insert the values in the stack\\n            \\n            temp = temp->next; // move temp to next node\\n        }\\n        \\n        temp = head; //assign the temp to head this will work as reversal of the LL\\n        \\n        while(temp != NULL)\\n        {\\n            temp->val = s.top(); //top element in the stack will be the first element in the reversed LL\\n            \\n            s.pop(); //pop out the elements in the stack\\n            \\n            temp = temp->next; //move temo to next node\\n        }\\n        \\n        return head;\\n```\n```\\n//using the iterative approach\\n        \\n        ListNode* current = head; //current element will have starting head node\\n        \\n        ListNode* previous = NULL; // null\\n        \\n        ListNode* future = NULL; // null\\n        \\n        while(current != NULL)\\n        {\\n            future = current->next;\\n            \\n            current->next = previous;\\n            \\n            previous = current;\\n            \\n            current = future;\\n        }\\n        return previous;\\n```\n```\\n//using the iterative approach\\n        \\n        ListNode* previous = NULL; // null\\n        \\n        ListNode* future = NULL; // null\\n        \\n        while(head != NULL)\\n        {\\n            future = head->next;\\n            \\n            head->next = previous;\\n            \\n            previous = head;\\n            \\n            head = future;\\n        }\\n        return previous;\\n```\n```\\n//recursive method\\n        \\n        if(!head || !(head->next)) return head;\\n        \\n        ListNode* temp = reverseList(head->next);\\n        \\n            head->next->next = head;\\n            \\n            head->next = NULL;\\n                \\n        return temp; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2592508,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr= head\\n        prev= None\\n        while curr!= None:\\n            next= curr.next\\n            curr.next= prev\\n            prev= curr\\n            curr= next\\n        return prev\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr= head\\n        prev= None\\n        while curr!= None:\\n            next= curr.next\\n            curr.next= prev\\n            prev= curr\\n            curr= next\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536131,
                "title": "javascript-with-heavy-comments-and-diagram",
                "content": "```\\nconst reverseList = (head) => {\\n    // Reversing a LinkedList involves using 2 pointer(cur, prev)\\n    let cur = head; // We set current node to the head\\n    let prev = null; // We set previous to NULL, because its the node BEFORE the current, aka NULL\\n    \\n    // Now we start our loop\\n    while(cur) { // We keep going as long as current exists\\n        // First create a temp variable to hold our new current\\n        let temp = cur.next; // We move to the right while flipping our pointers, so cur.next will be our new current at the end\\n        cur.next = prev; // Since we are reversing pointers, we want to point cur.next at the previous\\n        prev = cur; // We can now update previous, which will be our current since we move to the right \\n        cur = temp; // Current become cur.next, which we saved in the temp var\\n    }\\n    \\n    /** Diagram of process */ \\n    \\n     /** \\n     head\\n     1 -> 2 -> 3  Say the head/linked list starts with this, and head is the 1 node\\n     \\n     We set up out pointers like this\\n     prev   cur\\n     null -> 1 -> 2 -> 3\\n     \\n     In the while loop, after processing, the pointers basically just move to the right after reversing the current pointer\\n     So...\\n            prev cur\\n     null <- 1 -> 2 -> 3\\n     ^^ Notice the pointer is flipped for the 1\\n     \\n     We do this till the list looks like this\\n                      prev  cur \\n     null <- 1 <- 2 <- 3 <- null\\n     \\n     This is why the prev variable is the new head\\n     \\n    /*******/\\n    \\n    return prev; // The new head of our reversed linked list will be the prev variable\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nconst reverseList = (head) => {\\n    // Reversing a LinkedList involves using 2 pointer(cur, prev)\\n    let cur = head; // We set current node to the head\\n    let prev = null; // We set previous to NULL, because its the node BEFORE the current, aka NULL\\n    \\n    // Now we start our loop\\n    while(cur) { // We keep going as long as current exists\\n        // First create a temp variable to hold our new current\\n        let temp = cur.next; // We move to the right while flipping our pointers, so cur.next will be our new current at the end\\n        cur.next = prev; // Since we are reversing pointers, we want to point cur.next at the previous\\n        prev = cur; // We can now update previous, which will be our current since we move to the right \\n        cur = temp; // Current become cur.next, which we saved in the temp var\\n    }\\n    \\n    /** Diagram of process */ \\n    \\n     /** \\n     head\\n     1 -> 2 -> 3  Say the head/linked list starts with this, and head is the 1 node\\n     \\n     We set up out pointers like this\\n     prev   cur\\n     null -> 1 -> 2 -> 3\\n     \\n     In the while loop, after processing, the pointers basically just move to the right after reversing the current pointer\\n     So...\\n            prev cur\\n     null <- 1 -> 2 -> 3\\n     ^^ Notice the pointer is flipped for the 1\\n     \\n     We do this till the list looks like this\\n                      prev  cur \\n     null <- 1 <- 2 <- 3 <- null\\n     \\n     This is why the prev variable is the new head\\n     \\n    /*******/\\n    \\n    return prev; // The new head of our reversed linked list will be the prev variable\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2470442,
                "title": "java-solution-two-methods-t-o-n-s-o-1-100-fast",
                "content": "**Explanation:**\\n* This question can be solved by two methods; iterative as well as recursive.\\n* In iterative approach, we use three pointers; using the concept the breaking the node and reversing it direction and the repeating it again until we reach the end of list.\\n* In recursive approach, we use the internal stack memory to keep track of node visited and then back tracking - reverse the direction of node.\\n* Tip: This is one of the common problems being asked in interviews.\\n\\n**Code:**\\n*Iterative -- T: O(N) & S: O(1)*\\n\\n        if(head == null)\\n            return head;\\n        ListNode prev = null;\\n        ListNode next = null;\\n        while(head != null){\\n            next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n\\n*Recursive -- T: O(N) S: O(1) (if we don\\'t consider internal stack memory of recursion*\\n\\n      if(head == null || head.next == null)\\n           return head;\\n       ListNode nNode = reverseList(head.next); // recursive call\\n       head.next.next = head; // back tracking.\\n       head.next = null;\\n       return nNode;\\n\\t  \\n  **Please upvote and doubts & mistakes will be highly appreciated.**",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "**Explanation:**\\n* This question can be solved by two methods; iterative as well as recursive.\\n* In iterative approach, we use three pointers; using the concept the breaking the node and reversing it direction and the repeating it again until we reach the end of list.\\n* In recursive approach, we use the internal stack memory to keep track of node visited and then back tracking - reverse the direction of node.\\n* Tip: This is one of the common problems being asked in interviews.\\n\\n**Code:**\\n*Iterative -- T: O(N) & S: O(1)*\\n\\n        if(head == null)\\n            return head;\\n        ListNode prev = null;\\n        ListNode next = null;\\n        while(head != null){\\n            next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n\\n*Recursive -- T: O(N) S: O(1) (if we don\\'t consider internal stack memory of recursion*\\n\\n      if(head == null || head.next == null)\\n           return head;\\n       ListNode nNode = reverseList(head.next); // recursive call\\n       head.next.next = head; // back tracking.\\n       head.next = null;\\n       return nNode;\\n\\t  \\n  **Please upvote and doubts & mistakes will be highly appreciated.**",
                "codeTag": "Unknown"
            },
            {
                "id": 2415236,
                "title": "python-iterative-beats-99-recursive-beats-87-with-full-working-explanation",
                "content": "# Iterative\\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:  # Time: O(n) and Space: O(1)\\n        prev, cur = None, head\\n        while cur:               # let cur 3 \\n            temp = cur.next      # nxt = 4\\n            cur.next = prev      # 3 -> 2\\n            prev = cur           # prev = 3\\n            cur = temp           # 5 <- cur(4) <- 3(prev) -> 2 -> 1 -> Null\\n        return prev\\n```\\nFor example,\\nLet **head = [1, 2, 3, 4, 5]**\\n1. prev = None\\n1. cur =  head[0]=1\\n1. while cur=1,2,3,4,5 = True:\\n* cur=1: temp = 1.nxt=2 --> 1.next = None --> prev = 1 --> cur = 2  i.e. 1(prev) -> Null then 2(cur)\\n* cur=2: temp = 2.nxt=3 --> 2.next = 1 --> prev = 2 --> cur = 3  i.e. 2(prev) -> 1 -> Null then 3(cur)\\n* cur=3: temp = 3.nxt=4 --> 3.next = 2 --> prev = 3 --> cur = 4  i.e. 3(prev) -> 2 -> 1 -> Null then 4(cur)\\n* cur=4: temp = 4.nxt=5 --> 4.next = 3 --> prev = 4 --> cur = 5  i.e. 4(prev) -> 3 -> 2 -> 1 -> Null then 5(cur)\\n* cur=5: temp = 5.nxt=Null --> 5.next = 4 --> prev = 5 --> cur = Null  i.e. 5(prev) -> 4 -> 3 -> 2 -> 1 -> Null then Null(cur)\\n4. Return the first node i.e. **prev = 5.**\\n# Recursive\\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:  # Time: O(n) and Space: O(n)\\n        if head == None or head.next == None:  # head = 2 & 2 -> 3\\n            return head\\n\\n        newHead = self.reverseList(head.next)  # newHead = Func(head=3) returns head = 3\\n        head.next.next = head                  # head.next = 3 & 3.next = 2\\n        head.next = None                       # 2.next = None\\n        return newHead                         # returns newHead = 3 to when head = 1, and so on\\n```\\nFor example,\\nLet **head = [1, 2, 3]**\\n* reverse(1):\\n    * if head == None or head.next == None = False\\n    * newHead = self.reverseList(2)\\n* reverse(2):\\n   * if head == None or head.next == None = False\\n   * newHead = self.reverseList(3) = { if head == None or head.next == None = True: return 3 }\\n   * head.next.next i.e 3.next = 2 --> 2.next = None --> return newHead=3\\n* --> reverse(1)   \\n    * newHead = 3 --> 2.next = 1 --> 1.next = None --> return newHead=3",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:  # Time: O(n) and Space: O(1)\\n        prev, cur = None, head\\n        while cur:               # let cur 3 \\n            temp = cur.next      # nxt = 4\\n            cur.next = prev      # 3 -> 2\\n            prev = cur           # prev = 3\\n            cur = temp           # 5 <- cur(4) <- 3(prev) -> 2 -> 1 -> Null\\n        return prev\\n```\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:  # Time: O(n) and Space: O(n)\\n        if head == None or head.next == None:  # head = 2 & 2 -> 3\\n            return head\\n\\n        newHead = self.reverseList(head.next)  # newHead = Func(head=3) returns head = 3\\n        head.next.next = head                  # head.next = 3 & 3.next = 2\\n        head.next = None                       # 2.next = None\\n        return newHead                         # returns newHead = 3 to when head = 1, and so on\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260303,
                "title": "java-solution-with-explanation",
                "content": "**Thought process**: Start thinking to reverse the first node, as its next should be null we will store its next to dummy node and point it to a previous pointer initialised with null. Just keep doing it till curr is null.\\n```\\npublic ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while(curr!=null){\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n\\t\\t//since curr will be null at this point, we will return its prev value\\n        return prev;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while(curr!=null){\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n\\t\\t//since curr will be null at this point, we will return its prev value\\n        return prev;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2156138,
                "title": "how-to-understand-recursive-solution-step-by-step",
                "content": "Exampe 1:\\t\\n* \\thead : 1 -> 2 -> 3 -> None\\n* \\toutput : 3 -> 2 -> 1 -> None\\n\\nThe ideal of Pointer is important for understanding linklist.\\n\\t\\nIn recursive solution we need to break down the reverseList function to two parts:\\n1. base case: when the input reach this point will ruturn to avoid stack overflow.\\n\\t* \\tWhen head or head.next is None, then return head.\\n2. A set of rules to break down the original problem to subproblems.\\n\\t* \\tRedirect current head.next.next to itself.\\n\\t\\t* \\tFor example: After the first return from base case, p -> 3 -> None and current head -> 2 -> 3 -> None. What we do here is move link from \"3 point to None\" to \"3 point to 2\". \\n\\t\\t* \\tThen current head : 2 <-> 3\\n\\t* \\tRedirect current head.next to None.\\n\\t\\t* \\tMove link from \"2 point to 3\" to \"2 point to None\".\\n\\t\\t* \\tThen p -> 3 -> 2 -> None\\n\\n```\\ncall reverseList(head) (Here the head = 1 -> 2 -> 3 -> None)\\n\\t\\n\\tp = reverseList(head.next) (Here the head.next = 2 -> 3 -> None)\\n\\t\\n\\t\\tp = reverseList(head.next) (Here the head.next = 3 -> None)\\n\\t\\t\\thead = 3 -> None\\n\\t\\t\\tmatch with base case return 3 -> None\\n\\t\\tp = 3 -> None (Here you can see there is a new point, p, point to 3 -> None)\\n\\t\\t\\n\\t\\t\\t\\t\\tp\\n\\t\\t\\t\\t\\t\\u2193\\n\\t\\thead = 2 -> 3 -> None\\n\\t\\t\\t\\tfigure 1\\n\\t\\t\\n\\t\\thead.next.next = head (Here you redirect 2.next.next to 2, which means redirect 3.next to 2.)\\n\\t\\t\\n\\t\\t\\t\\t\\tp\\n\\t\\t            \\u2193\\n\\t\\thead = 2 -> 3\\n\\t\\t\\t   \\u2191    \\u2193\\n\\t\\t\\t    <---\\n\\t\\t\\tfigure 2\\n\\t\\t\\t\\t \\n\\t\\thead.next = head (Here you redirect 2.next from 3 to None)\\n\\t\\t\\n\\t\\t\\t\\t\\tp\\n\\t\\t            \\u2193\\n\\t\\thead = 2 <- 3\\n\\t\\t\\t   \\u2193\\n\\t\\t\\t  None\\n\\t\\t\\tfigure 3\\n\\t\\t\\t  \\n\\t\\treturn 3 -> 2 -> None\\n\\tp = 3 -> 2 -> None\\n\\thead.next.next = head (Here you redirect 1.next.next to 1, which means redirect 2.next to 1)\\n\\t\\n\\t\\t\\t   p    1 <-\\n\\t\\t       \\u2193    \\u2193   \\u2191\\n\\t\\thead = 3 -> 2 -> \\n\\t\\t\\tfigure 4\\n\\n\\thead.next = head (Here you redirect 1.next from 2 to None)\\n\\t\\n\\t\\n\\t\\t\\t   p    \\n\\t\\t       \\u2193    \\n\\t\\thead = 3 -> 2 -> 1 -> None\\n\\t\\t\\t\\tfigure 5\\n\\t\\n\\treturn 3 -> 2 -> 1 -> None\\noutput: 3 -> 2 -> 1 -> None\\n```\\n\\t\\t\\t\\t \\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ncall reverseList(head) (Here the head = 1 -> 2 -> 3 -> None)\\n\\t\\n\\tp = reverseList(head.next) (Here the head.next = 2 -> 3 -> None)\\n\\t\\n\\t\\tp = reverseList(head.next) (Here the head.next = 3 -> None)\\n\\t\\t\\thead = 3 -> None\\n\\t\\t\\tmatch with base case return 3 -> None\\n\\t\\tp = 3 -> None (Here you can see there is a new point, p, point to 3 -> None)\\n\\t\\t\\n\\t\\t\\t\\t\\tp\\n\\t\\t\\t\\t\\t\\u2193\\n\\t\\thead = 2 -> 3 -> None\\n\\t\\t\\t\\tfigure 1\\n\\t\\t\\n\\t\\thead.next.next = head (Here you redirect 2.next.next to 2, which means redirect 3.next to 2.)\\n\\t\\t\\n\\t\\t\\t\\t\\tp\\n\\t\\t            \\u2193\\n\\t\\thead = 2 -> 3\\n\\t\\t\\t   \\u2191    \\u2193\\n\\t\\t\\t    <---\\n\\t\\t\\tfigure 2\\n\\t\\t\\t\\t \\n\\t\\thead.next = head (Here you redirect 2.next from 3 to None)\\n\\t\\t\\n\\t\\t\\t\\t\\tp\\n\\t\\t            \\u2193\\n\\t\\thead = 2 <- 3\\n\\t\\t\\t   \\u2193\\n\\t\\t\\t  None\\n\\t\\t\\tfigure 3\\n\\t\\t\\t  \\n\\t\\treturn 3 -> 2 -> None\\n\\tp = 3 -> 2 -> None\\n\\thead.next.next = head (Here you redirect 1.next.next to 1, which means redirect 2.next to 1)\\n\\t\\n\\t\\t\\t   p    1 <-\\n\\t\\t       \\u2193    \\u2193   \\u2191\\n\\t\\thead = 3 -> 2 -> \\n\\t\\t\\tfigure 4\\n\\n\\thead.next = head (Here you redirect 1.next from 2 to None)\\n\\t\\n\\t\\n\\t\\t\\t   p    \\n\\t\\t       \\u2193    \\n\\t\\thead = 3 -> 2 -> 1 -> None\\n\\t\\t\\t\\tfigure 5\\n\\t\\n\\treturn 3 -> 2 -> 1 -> None\\noutput: 3 -> 2 -> 1 -> None\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2060407,
                "title": "python3-3-solutions-iterative-recursive-and-stack",
                "content": "The three solutions contains stack, recursive, iterative solution\\nyou can clearly see the best runtime, I\\'ve got is come with stack, but we can do better, with O(1) memory, leetcode servers result comes different everytime you hit submit.\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverseWithStack(head)          \\n        # return self.iterativeReverse(head)\\n        # return self.recursiveReverse(head)\\n            \\n    # O(N) || O(1)\\n    # Runtime: 45ms 61.29%\\n    def iterativeReverse(self, head):\\n        if not head:\\n            return head\\n        \\n        prev = None\\n        while head is not None:\\n            next = head.next\\n            head.next = prev\\n            prev = head\\n            head = next\\n            \\n        return prev\\n    \\n    # O(N) || O(N)\\n    # Runtime: 50ms 47.81%\\n    def recursiveReverse(self, head):\\n        if not head:\\n            return head\\n        if not head.next:\\n            return head\\n        \\n        newHead = self.recursiveReverse(head.next)\\n        head.next.next = head\\n        head.next = None\\n        \\n        return newHead\\n    \\n    # O(N) || O(N)\\n    # Runtime: 33ms 94.92%    \\n    def reverseWithStack(self, head):\\n        if not head:\\n            return head\\n        \\n        stack = []\\n        newHead = head\\n        while newHead is not None:\\n            stack.append(newHead.val)\\n            newHead = newHead.next\\n            \\n        newHead = head\\n        \\n        for i in range(len(stack)):\\n            newHead.val = stack.pop()\\n            newHead = newHead.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverseWithStack(head)          \\n        # return self.iterativeReverse(head)\\n        # return self.recursiveReverse(head)\\n            \\n    # O(N) || O(1)\\n    # Runtime: 45ms 61.29%\\n    def iterativeReverse(self, head):\\n        if not head:\\n            return head\\n        \\n        prev = None\\n        while head is not None:\\n            next = head.next\\n            head.next = prev\\n            prev = head\\n            head = next\\n            \\n        return prev\\n    \\n    # O(N) || O(N)\\n    # Runtime: 50ms 47.81%\\n    def recursiveReverse(self, head):\\n        if not head:\\n            return head\\n        if not head.next:\\n            return head\\n        \\n        newHead = self.recursiveReverse(head.next)\\n        head.next.next = head\\n        head.next = None\\n        \\n        return newHead\\n    \\n    # O(N) || O(N)\\n    # Runtime: 33ms 94.92%    \\n    def reverseWithStack(self, head):\\n        if not head:\\n            return head\\n        \\n        stack = []\\n        newHead = head\\n        while newHead is not None:\\n            stack.append(newHead.val)\\n            newHead = newHead.next\\n            \\n        newHead = head\\n        \\n        for i in range(len(stack)):\\n            newHead.val = stack.pop()\\n            newHead = newHead.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963782,
                "title": "sss-swift-simple-solution-iterative-recursive-approaches",
                "content": "**Iterative Approach**\\n\\n```\\nfunc reverseList(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tguard var current = head.next else { return head }\\n\\n\\tvar prev = head\\n\\tprev.next = nil\\n\\n\\twhile let next = current.next {\\n\\t\\tcurrent.next = prev\\n\\t\\tprev = current\\n\\t\\tcurrent = next\\n\\t}\\n\\tcurrent.next = prev\\n\\n\\treturn current\\n}\\n```\\n\\nor\\n\\n```\\nfunc reverseList(_ head: ListNode?) -> ListNode? {\\n    var prev = head, node = head?.next\\n    prev?.next = nil\\n\\n    while node != nil {\\n        let next = node!.next\\n        node!.next = prev\\n        prev = node\\n        node = next\\n    }\\n\\n    return prev\\n}\\n```\\n\\n**Recursive Approach** \\uD83D\\uDCA3 *my brain exploded* \\uD83E\\uDD2F\\n\\n```\\nfunc reverseList(_ head: ListNode?) -> ListNode? {\\n\\tguard var current = head else { return nil }\\n\\tguard let next = current.next else { return current }\\n\\n\\tlet newHead = reverseList(next)\\n\\tnext.next = current\\n\\tcurrent.next = nil\\n\\n\\treturn newHead\\n}\\n```\\nor\\n\\n```\\nfunc reverseList(_ head: ListNode?) -> ListNode? {\\n    guard head != nil, head?.next != nil else { return head }\\n\\n    let tail = reverseList(head!.next)\\n    head!.next?.next = head\\n    head!.next = nil\\n\\n    return tail\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc reverseList(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tguard var current = head.next else { return head }\\n\\n\\tvar prev = head\\n\\tprev.next = nil\\n\\n\\twhile let next = current.next {\\n\\t\\tcurrent.next = prev\\n\\t\\tprev = current\\n\\t\\tcurrent = next\\n\\t}\\n\\tcurrent.next = prev\\n\\n\\treturn current\\n}\\n```\n```\\nfunc reverseList(_ head: ListNode?) -> ListNode? {\\n    var prev = head, node = head?.next\\n    prev?.next = nil\\n\\n    while node != nil {\\n        let next = node!.next\\n        node!.next = prev\\n        prev = node\\n        node = next\\n    }\\n\\n    return prev\\n}\\n```\n```\\nfunc reverseList(_ head: ListNode?) -> ListNode? {\\n\\tguard var current = head else { return nil }\\n\\tguard let next = current.next else { return current }\\n\\n\\tlet newHead = reverseList(next)\\n\\tnext.next = current\\n\\tcurrent.next = nil\\n\\n\\treturn newHead\\n}\\n```\n```\\nfunc reverseList(_ head: ListNode?) -> ListNode? {\\n    guard head != nil, head?.next != nil else { return head }\\n\\n    let tail = reverseList(head!.next)\\n    head!.next?.next = head\\n    head!.next = nil\\n\\n    return tail\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125813,
                "title": "go-solution",
                "content": "```\\n\\nfunc reverseLinkedList(head *ListNode) *ListNode{\\n    var cur,next,prev *ListNode\\n    cur = head\\n    for (cur != nil){\\n        next = cur.Next  // saving the next point\\n        cur.Next = prev // changing it previous\\n        prev = cur // setting previous to current\\n        cur = next //setting next to current\\n    }\\n    return prev\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc reverseLinkedList(head *ListNode) *ListNode{\\n    var cur,next,prev *ListNode\\n    cur = head\\n    for (cur != nil){\\n        next = cur.Next  // saving the next point\\n        cur.Next = prev // changing it previous\\n        prev = cur // setting previous to current\\n        cur = next //setting next to current\\n    }\\n    return prev\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751054,
                "title": "python-iterative-recursive-solution",
                "content": "Iterative Solution - T.C - O(n) , S.P - O(1)\\n```\\ndef reverseList(self, head: ListNode, prev=None) -> ListNode:\\n\\t\\tprev , curr = None , head\\n        while curr is not None:\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n        \\n        head = prev\\n        return head\\n```\\nRecursive Solution - T.C - O(n) , S.P - O(n)\\n```\\ndef reverseList(self, head: ListNode, prev=None) -> ListNode:\\n\\t\\tif head is None or head.next is None:\\n            return head\\n        smallHead = self.reverseList(head.next)\\n        tail = head.next\\n        tail.next = head\\n        head.next = None\\n        return smallHead\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef reverseList(self, head: ListNode, prev=None) -> ListNode:\\n\\t\\tprev , curr = None , head\\n        while curr is not None:\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n        \\n        head = prev\\n        return head\\n```\n```\\ndef reverseList(self, head: ListNode, prev=None) -> ListNode:\\n\\t\\tif head is None or head.next is None:\\n            return head\\n        smallHead = self.reverseList(head.next)\\n        tail = head.next\\n        tail.next = head\\n        head.next = None\\n        return smallHead\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 642637,
                "title": "faster-than-95-78-in-python-iterative-solution",
                "content": "```\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        #I will use the following head, prev, temp\\n        \\n        prev = None\\n        \\n        while head: #while head is present then this loop executes\\n            #first I will assign the value of head to the temp variable\\n            temp = head\\n            \\n            #now head can be pused to the next element\\n            head = head.next\\n            \\n            #now using temp in such a way to reverse the direction of the pointers\\n            temp.next = prev #this changes the current nodes pointer direction from right to left\\n            \\n            #now making prev come to the current node so that this same cycle can be repeated \\n            prev = temp #this temp is the old value of temp that it carried before head gave and moved away\\n        return prev\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        #I will use the following head, prev, temp\\n        \\n        prev = None\\n        \\n        while head: #while head is present then this loop executes\\n            #first I will assign the value of head to the temp variable\\n            temp = head\\n            \\n            #now head can be pused to the next element\\n            head = head.next\\n            \\n            #now using temp in such a way to reverse the direction of the pointers\\n            temp.next = prev #this changes the current nodes pointer direction from right to left\\n            \\n            #now making prev come to the current node so that this same cycle can be repeated \\n            prev = temp #this temp is the old value of temp that it carried before head gave and moved away\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518137,
                "title": "c-90-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == NULL)\\n            return head;\\n        ListNode* prevNode = NULL;\\n        ListNode* currNode = head;\\n        while(currNode) {\\n            ListNode* nextNode = currNode->next;\\n            currNode->next = prevNode;\\n            prevNode = currNode;\\n            currNode = nextNode;\\n        }\\n        return prevNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == NULL)\\n            return head;\\n        ListNode* prevNode = NULL;\\n        ListNode* currNode = head;\\n        while(currNode) {\\n            ListNode* nextNode = currNode->next;\\n            currNode->next = prevNode;\\n            prevNode = currNode;\\n            currNode = nextNode;\\n        }\\n        return prevNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392507,
                "title": "solved-video-editorial-for-reversing-a-linked-list-leetcode",
                "content": "Hi all,\\n\\nClick on the below link for the solved video editorial for finding the Linked List Cycle problem.\\nAlso, i will be adding more problems to my collection. Please follow and feedback is always appreciated.\\n\\nClick here - [Link](https://www.youtube.com/watch?v=bWbMtMebyK8&feature=youtu.be)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "Hi all,\\n\\nClick on the below link for the solved video editorial for finding the Linked List Cycle problem.\\nAlso, i will be adding more problems to my collection. Please follow and feedback is always appreciated.\\n\\nClick here - [Link](https://www.youtube.com/watch?v=bWbMtMebyK8&feature=youtu.be)",
                "codeTag": "Unknown"
            },
            {
                "id": 204528,
                "title": "swift-quick-iterative-solution-okay-it-s-eazy",
                "content": "```\\nclass Solution {\\n    func reverseList(_ head: ListNode?) -> ListNode? {\\n        var node = head\\n        var next = head?.next\\n        node?.next = nil\\n        while next != nil {\\n            var hold = next!.next\\n            next!.next = node\\n            node = next\\n            next = hold\\n        }\\n        return node\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseList(_ head: ListNode?) -> ListNode? {\\n        var node = head\\n        var next = head?.next\\n        node?.next = nil\\n        while next != nil {\\n            var hold = next!.next\\n            next!.next = node\\n            node = next\\n            next = hold\\n        }\\n        return node\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159642,
                "title": "swift-100-recursive",
                "content": "Thanks for @BraydenCN solution for Java posted in a different thread. \\nI adapted it for Swift and slightly changed some naming.\\n\\n```\\n  func reverseList(_ head: ListNode?) -> ListNode? {\\n    return reverseListInternal(head, nil)            \\n  }\\n                                \\n  func reverseListInternal(_ current: ListNode?, _ previous: ListNode?) -> ListNode? {\\n    if current == nil { return previous }\\n      \\n    var next = current!.next      \\n    current!.next = previous              \\n      \\n    return reverseListInternal(next, current)      \\n  }",
                "solutionTags": [],
                "code": "Thanks for @BraydenCN solution for Java posted in a different thread. \\nI adapted it for Swift and slightly changed some naming.\\n\\n```\\n  func reverseList(_ head: ListNode?) -> ListNode? {\\n    return reverseListInternal(head, nil)            \\n  }\\n                                \\n  func reverseListInternal(_ current: ListNode?, _ previous: ListNode?) -> ListNode? {\\n    if current == nil { return previous }\\n      \\n    var next = current!.next      \\n    current!.next = previous              \\n      \\n    return reverseListInternal(next, current)      \\n  }",
                "codeTag": "Unknown"
            },
            {
                "id": 58119,
                "title": "my-12-line-9ms-simple-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *tail = NULL; // tail is the head node of the reversed list\\n        ListNode *cur = head; // you can just use head here, without delaring a new pointer\\n        ListNode *pre = head;\\n        while(cur)\\n        {\\n            cur = cur->next; //record the node we will insert to the reversed list next\\n            pre->next = tail;//set the node previous to cur points to tail\\n            tail = pre;// set the  tail pointer points to  the newly inserted node, which is pre\\n            pre = cur; // move pre forward\\n        }\\n        return tail;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *tail = NULL; // tail is the head node of the reversed list\\n        ListNode *cur = head; // you can just use head here, without delaring a new pointer\\n        ListNode *pre = head;\\n        while(cur)\\n        {\\n            cur = cur->next; //record the node we will insert to the reversed list next\\n            pre->next = tail;//set the node previous to cur points to tail\\n            tail = pre;// set the  tail pointer points to  the newly inserted node, which is pre\\n            pre = cur; // move pre forward\\n        }\\n        return tail;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 58120,
                "title": "c-iteration-and-recursion-beautiful-solution",
                "content": "Iteration:\\n```\\nListNode* reverseList(ListNode* head) {\\n        ListNode* cur = head;\\n        ListNode* pre = NULL;\\n        while(cur){\\n            ListNode* next = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = next;\\n        }\\n        return pre;\\n    }\\n```\\n\\nRecursion:\\n```\\nListNode* reverseList(ListNode* head) {\\n        return help(head, NULL);\\n    }\\n    ListNode* help(ListNode* cur, ListNode* pre){\\n        if(!cur) return cur;\\n        ListNode* next = cur->next;\\n        cur->next = pre;\\n        return !next ? cur : help(next, cur);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* reverseList(ListNode* head) {\\n        ListNode* cur = head;\\n        ListNode* pre = NULL;\\n        while(cur){\\n            ListNode* next = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = next;\\n        }\\n        return pre;\\n    }\\n```\n```\\nListNode* reverseList(ListNode* head) {\\n        return help(head, NULL);\\n    }\\n    ListNode* help(ListNode* cur, ListNode* pre){\\n        if(!cur) return cur;\\n        ListNode* next = cur->next;\\n        cur->next = pre;\\n        return !next ? cur : help(next, cur);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 58146,
                "title": "python-one-pass-concise-solution",
                "content": "```\\ndef reverseList(self, head):\\n        prev = None\\n        while head:\\n            prev, head.next, head = head, prev, head.next\\n        \\n        return prev\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef reverseList(self, head):\\n        prev = None\\n        while head:\\n            prev, head.next, head = head, prev, head.next\\n        \\n        return prev\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 58261,
                "title": "python-4-lines-iterative",
                "content": "```\\nclass Solution(object):\\n    def reverseList(self, head):\\n        rev = None\\n        while head:\\n            head.next,rev,head = rev,head,head.next\\n        return rev\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def reverseList(self, head):\\n        rev = None\\n        while head:\\n            head.next,rev,head = rev,head,head.next\\n        return rev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 58287,
                "title": "java-1ms-6-lines-of-code-using-recursion",
                "content": "    public ListNode reverseList(ListNode head) {\\n    \\t\\tif (head == null)  return null;\\n            if (head.next == null) return head;\\n            ListNode node = reverseList(head.next);\\n            head.next.next = head;\\n            head.next = null;\\n            return node;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode reverseList(ListNode head) {\\n    \\t\\tif (head == null)  return null;\\n            if (head.next == null) return head;\\n            ListNode node = reverseList(head.next);\\n            head.next.next = head;\\n            head.next = null;\\n            return node;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 58364,
                "title": "java-recursive-without-helper",
                "content": "Just another way of doing it.\\n\\n    public class Solution {\\n        public ListNode reverseList(ListNode head) {\\n            if(head == null) return null;\\n            \\n            ListNode next = head.next;\\n\\n            // Used to set next of root to null. It will get overridden by \"next.next = head\" in the method that \\n            // called this one if \"head\" is not root\\n            head.next = null;\\n            \\n            if(next != null) {\\n                ListNode root = reverseList(next);\\n                next.next = head;\\n                return root;\\n            }\\n            \\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public ListNode reverseList(ListNode head) {\\n            if(head == null) return null;\\n            \\n            ListNode next = head.next;\\n\\n            // Used to set next of root to null. It will get overridden by \"next.next = head\" in the method that \\n            // called this one if \"head\" is not root\\n            head.next = null;\\n            \\n            if(next != null) {\\n                ListNode root = reverseList(next);\\n                next.next = head;\\n                return root;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 58377,
                "title": "my-5-lines-c-program-using-recursion",
                "content": "    class Solution {\\n    public:\\n    \\tListNode* reverseList(ListNode* head) {\\n    \\t\\tif (head == NULL || head->next == NULL) {\\n    \\t\\t\\treturn head;\\n    \\t\\t}\\n    \\t\\tListNode* root = reverseList(head->next);\\n    \\t\\thead->next->next = head;\\n    \\t\\thead->next = NULL;\\n    \\t\\treturn root;\\n    \\t}\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n    \\tListNode* reverseList(ListNode* head) {\\n    \\t\\tif (head == NULL || head->next == NULL) {\\n    \\t\\t\\treturn head;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 58410,
                "title": "my-simple-recursive-java-solution",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * public class ListNode {\\n     *     int val;\\n     *     ListNode next;\\n     *     ListNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n    \\tpublic ListNode reverseList(ListNode curr){\\n        \\tif(curr==null) return curr;\\n        \\tListNode rest = curr.next;\\n        \\tif(rest==null) return curr;\\n        \\trest = reverseList(rest);\\n        \\tcurr.next.next = curr;    //  Here is the trick\\n        \\tcurr.next =null;          //\\n        \\treturn rest;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\tpublic ListNode reverseList(ListNode curr){\\n        \\tif(curr==null) return curr;\\n        \\tListNode rest = curr.next;\\n        \\tif(rest==null) return curr;\\n        \\trest = reverseList(rest);\\n        \\tcurr.next.next = curr;    //  Here is the trick\\n        \\tcurr.next =null;          //\\n        \\treturn rest;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3779287,
                "title": "2-methods-recursive-iterative",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(length_of_linkedlist)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Method #1\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        ListNode* curNext = head;\\n        \\n        while(cur!= NULL){\\n            curNext = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = curNext;\\n        }\\n        return prev;\\n    }\\n};\\n```\\n\\n# Method #2\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* prev = NULL;\\n        ListNode* h2 = reverseList(head->next);\\n        head->next->next = head;\\n        head->next=prev;\\n        return h2;\\n    }\\n\\n};",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        ListNode* curNext = head;\\n        \\n        while(cur!= NULL){\\n            curNext = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = curNext;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180918,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == NULL) {\\n            return head;\\n        }\\n        ListNode* next = head->next;\\n        head->next = NULL;\\n        while(next != NULL) {\\n            ListNode* temp = next;\\n            next = next->next;\\n            temp->next = head;\\n            head = temp;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        prev = None\\n        curr = head\\n\\n        while curr:\\n            old_next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = old_next\\n\\n        return prev\\n```\\n\\n```Java []\\nclass Solution {\\n  public ListNode reverseList(ListNode head) {\\n    ListNode prev = null;\\n\\n    while (head != null) {\\n      ListNode next = head.next;\\n      head.next = prev;\\n      prev = head;\\n      head = next;\\n    }\\n\\n    return prev;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == NULL) {\\n            return head;\\n        }\\n        ListNode* next = head->next;\\n        head->next = NULL;\\n        while(next != NULL) {\\n            ListNode* temp = next;\\n            next = next->next;\\n            temp->next = head;\\n            head = temp;\\n        }\\n        return head;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        prev = None\\n        curr = head\\n\\n        while curr:\\n            old_next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = old_next\\n\\n        return prev\\n```\n```Java []\\nclass Solution {\\n  public ListNode reverseList(ListNode head) {\\n    ListNode prev = null;\\n\\n    while (head != null) {\\n      ListNode next = head.next;\\n      head.next = prev;\\n      prev = head;\\n      head = next;\\n    }\\n\\n    return prev;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147362,
                "title": "easy-few-lines-of-c-code-using-stack",
                "content": "```\\n#include <stack>\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        stack<int> s1;\\n        ListNode* ptr=head;\\n        while(ptr!=NULL)\\n        {\\n            s1.push(ptr->val);\\n            ptr=ptr->next;\\n        }\\n        ptr=head;\\n        while(ptr!=NULL)\\n        {\\n            ptr->val=s1.top();\\n            s1.pop();\\n            ptr=ptr->next;\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        stack<int> s1;\\n        ListNode* ptr=head;\\n        while(ptr!=NULL)\\n        {\\n            s1.push(ptr->val);\\n            ptr=ptr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3140644,
                "title": "best-o-n-solution",
                "content": "\\n# Approach 1\\nIterative\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL, * curr = head, * next;\\n        while (curr != NULL) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        head = prev;\\n        return head;\\n    }\\n};\\n```\\n\\n# Approach 2\\nRecursive\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if (head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* newHead = reverseList(head->next);\\n        head->next->next = head;\\n        head->next = NULL;  \\n        return newHead;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL, * curr = head, * next;\\n        while (curr != NULL) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        head = prev;\\n        return head;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if (head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* newHead = reverseList(head->next);\\n        head->next->next = head;\\n        head->next = NULL;  \\n        return newHead;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105904,
                "title": "beats-91-73-reverse-a-linked-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        prev = None\\n        while head!=None:\\n            temp=head\\n            head=head.next\\n            temp.next=prev\\n            prev=temp\\n        return prev\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        prev = None\\n        while head!=None:\\n            temp=head\\n            head=head.next\\n            temp.next=prev\\n            prev=temp\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061433,
                "title": "python3-easy-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = None\\n        while head:\\n            var = head.next\\n            head.next = dummy\\n            dummy = head\\n            head = var\\n       \\n        return dummy\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = None\\n        while head:\\n            var = head.next\\n            head.next = dummy\\n            dummy = head\\n            head = var\\n       \\n        return dummy\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889684,
                "title": "recursion",
                "content": "# Intuition\\nRecursively traverse the linked list until the end and do the job when returning\\n\\n# Approach\\n- rucursively traverse the linked list until you reach the last node\\n- Now, from the last call you will get a new node, which is the end node. We will return this new node all the way down to the first recursive call\\n- What\\'s left is that changing the pointers of nodes. To do that, make head.next.next = head. This will reverse the pointers between nodes. Note we can\\'t say new_head.next = head\\n- One last thing, make head.next = None, this is used to make the end node (originally the first node) point to None\\n\\n## example\\nlet\\'s say we have this linked list\\n  - [1] -> [2] -> None\\n  - Node 1 is our original head\\n  - Node 2 is our new_node we got from recursive call\\n  - Now, make head.next.next = head\\n  - did you notice how we changed the pointer of node 2 from None to node 1? Do this for all the nodes in the linked list when returning from recursive call\\n  - Then make node 1 next pointer to None\\n  - Return the new_node all the way down the recursion call\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head == None or head.next == None:\\n            return head\\n        new_head = self.reverseList(head.next)\\n        head.next.next = head\\n        head.next = None\\n        return new_head\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head == None or head.next == None:\\n            return head\\n        new_head = self.reverseList(head.next)\\n        head.next.next = head\\n        head.next = None\\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845755,
                "title": "java-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode cur=head;\\n        ListNode prev=null;\\n        while(cur!=null){\\n            ListNode temp=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=temp;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode cur=head;\\n        ListNode prev=null;\\n        while(cur!=null){\\n            ListNode temp=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=temp;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1779172,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1716755,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1811694,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1575779,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1806884,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1574660,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1869253,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1811696,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1806099,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1807641,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1779172,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1716755,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1811694,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1575779,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1806884,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1574660,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1869253,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1811696,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1806099,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1807641,
                "content": [
                    {
                        "username": "rajat_171",
                        "content": "I believe that this is not an easy problem. "
                    },
                    {
                        "username": "hippybonus",
                        "content": "It is definitely an easy problem. When you do medium linked list problems, you will use this reversing function as a side problem to solve your medium. A medium problem would involve 2 or 3 of small functions like this."
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "it is one of easiest question if you solve it in C"
                    },
                    {
                        "username": "diego007lopez",
                        "content": "I agree with [@alighraibeh87](/alighraibeh87). You\\'re missing pieces of the puzzle, [@Vectorido](/Vectorido). Gotta go fill those gaps out prior to trying."
                    },
                    {
                        "username": "dvijay96",
                        "content": "[@gbiems](/gbiems) [[@Rajat Kalotra](/rajat_171)] I would say it didn't cross the medium level threshold to be a medium problem. It may be considered somewhat towards medium.\nI too don't revise LL problems every day but still was able to solve this under 10 mins (with code). I see LL problems as a visualization problem, it helps in understanding it more easily than array or strings. Its one of the topic which i feel i can solve in an interview without much practice."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@Vectorido](/Vectorido) \\ngo and learn linked list data strucutre and then come back\\n"
                    },
                    {
                        "username": "gbiems",
                        "content": "I agree, mainly because I come back to this problem every couple of months. I deliberately don\\'t memorize the answer, I make sure I\\'m able to reason through it and write an implementation. And I while I do manage to solve it, I always have to puzzle over it for a while. There are a lot of moving parts and things to get wrong, and it\\'s not especially easy. "
                    },
                    {
                        "username": "Vectorido",
                        "content": "Truly medium at least. I have about 1.5 years of experience in Python programming and I just don\\'t know where to start and how to approach this task."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video that visualizes and clearly explains the O(n) solution in Python: \n\nhttps://youtu.be/W1BLGgWZhK8"
                    },
                    {
                        "username": "amaboshilc",
                        "content": "Amazing explanation!"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Awesome thanks :)\\n"
                    },
                    {
                        "username": "harimwoo",
                        "content": "This was very helpful thank you jkim!\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "The links of this linked list was linking my head to hell.. \\nlesson: small code doesn\\'t mean easy Logic"
                    },
                    {
                        "username": "bagasbudhi",
                        "content": "HAHAHAHA lmaoo"
                    },
                    {
                        "username": "Aditya_A",
                        "content": "I code in Python and I am not able to wrap my head around this even after watching a few of the good YouTube videos about reversing the linked list. I am so sad that I am not able understand this easy problem. I don\\'t know what to do with harder problems. Can someone please help..."
                    },
                    {
                        "username": "hippybonus",
                        "content": "I felt the same after the first day doing Linked List and doing this problem, but after 20-30 linked list questions, you will kick in the understanding."
                    },
                    {
                        "username": "vinay1135",
                        "content": "I suggest you start by implementing linked list on your own and how it references to other node in the memory."
                    },
                    {
                        "username": "EnzoPay",
                        "content": "Don\\'t be depressed bro, this problem should be a medium one and i have the same feeling.."
                    },
                    {
                        "username": "lu284918171",
                        "content": "i have the same feeling, good pytho solution looks good and simple but i don\\'t know why it work, even stare at the answer more then 10 min, so i give up this question hahah"
                    },
                    {
                        "username": "aramazani100",
                        "content": "I code in python too and I was having a hard time solving this problem. The picture in the top helped me understand it a lot better. I highly recommend opening the paint app in your computer and try running the algorithm from the picture on an example. Think of curr.next = prev; as reversing the arrow. Use the eraser to update your drawing each step of the algorithm. I actually used Java for this problem and it\\'s very easy to code it in java. "
                    },
                    {
                        "username": "jblac8",
                        "content": "It helped me to think about the \".next\" call as referring to the arrows connecting the nodes. So with the recursive call, you recurse through the linked list until you hit the base case (the last node, or where node.next == null), at which point you assign the last node as the new head. Now, this is where I got stuck for a while - it's important to recognize that because you called \"return head\" on the last node, the recursive reverseList call is not called. Thus the recursive execution actually begins with the second-to-last node, where \"head.next.next = head\" is called (assigning the pointer of the last node to point to the second-to-last node), and then where \"head.next = null\" is called (assigning the pointer of the second-to-last node to null, allowing its pointer to be reassigned when the next recursive call executes). This continues until \"head.next = null\" is called for the original head node, at which point the recursion stops (as the initial recursive call was executed on this node). I hope this explanation helped, it may even help to draw it out as well."
                    },
                    {
                        "username": "isaac87",
                        "content": "[@areebhqureshi](/areebhqureshi) If it makes you feel any better .. this is pretty useless as almost 99% of SWE positions."
                    },
                    {
                        "username": "areebhqureshi",
                        "content": "Just keep going. Copy Source code. Look at code from C++ or Java if you still understand the Python implementation. Repetition will make it easier"
                    },
                    {
                        "username": "erinlau",
                        "content": "Hey, I have a question about the input \"head = [1,2,3,4,5]\", Actually in all the linked list questions, the input is given in this array-like format. In my understanding it should represent a linked list with 1 to be the head and next pointing to 2. Why it is written like this? "
                    },
                    {
                        "username": "divyesh032040",
                        "content": "than how they should write ? like this =  1 -> 2 -> 3 -> 4 -> 5 -> NULL "
                    },
                    {
                        "username": "Haftisha",
                        "content": "I don\\'t think they will use it directy as input while testing. They will create the linkedlist and pass the first node(head) as input"
                    },
                    {
                        "username": "vxlkx",
                        "content": "The head is simply the pointer to the linked list."
                    },
                    {
                        "username": "akthrow",
                        "content": "leetcode is attempting to simplify the output for us here but I also feel it just adds to the confusion. In javascript for example you can get a better idea of the true shape of the data with something like `console.log(JSON.stringify(head))`"
                    },
                    {
                        "username": "Demugun",
                        "content": "Hi, can I ask if we need to consider both the cases that\\n\\nhead == null \\n\\nor\\n\\nhead.next == null\\n\\nin this question? \\n\\nWhy can\\'t we just check \\'head.next == null\\' in the base case, and set the curr head as the head of the reversed linked lists?"
                    },
                    {
                        "username": "praful_132002",
                        "content": "because , there is not any next of Null , you will get an error;"
                    },
                    {
                        "username": "rafael1mc",
                        "content": "Because an input can be nil too. For example: reverse linked list of [].\\nAccessing head.Next when head is nill will panic with \"invalid memory address or nil pointer dereference\"."
                    },
                    {
                        "username": "phoenixwazz",
                        "content": "Here is suggestion for approach... \\n1.)Making an array and copying the content of list then reverse the array and copy back the content to the list.\\n2.)Reverse the address of the nodes. You can reverse nodes using 2 extra pointers, lets say p and q which are initiased with null. Then loop through the list using while , just assign p=q\\nq=head;\\nhead=head->next \\nq->next = p.\\nUsing the this approach u can just reverse the nodes.\\n3.)Using recursive approach.\\nAs you know that the recursion deletes its stack while returning back using , we can use it as an advantage to link the next node to previous node.2 pointers are required for this. So while returning, we can just assign the pointer to the previous pointer without even manually assigning the pointer to go for the next.\\n\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I just ran from daily problem coz it was hard and here I am solving the easy question in 30 min.. bruh \\uD83D\\uDE02"
                    },
                    {
                        "username": "elhalvers",
                        "content": "Are you supposed to use the commented out class ListNode? Is your reverse_list method supposed to me an instance method inside the class?\\n\\nIs the \\'head\\' input not an array? does it represent a linked list of ListNode instances?\\n\\nThanks for any assistance!  : )"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "[@elhalvers](/elhalvers) Yeah, I just switched to Ruby and it looks strange (even though I am not familiar with Ruby)"
                    },
                    {
                        "username": "elhalvers",
                        "content": "[@volkoff5566](/volkoff5566) Thank you for the assistance! The method outside of any class seems a little odd. When I put p head inside of the method body, the Stdout section in the result shows that there are instances of the class ListNode with instance method values for each of the values in the head \\'array\\'. My assumption is that there is another class with methods that control the linked list and the method that we are supposed to write is an instance method of that class.\\n"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "Yes, the commented out class will be used, but you don't need to uncomment it or do any other actions with (at least for this task). It's there just for information, so you can see hot it's implemented and what to expect from it.\n\nThe input is not an array. The head is a first link of the chain of nodes.\nHere is Java code that can help to see the ListNode structure yourself. \n\n`class ListNode {\n     int val;\n     ListNode next;\n     ListNode() {}\n\n    @Override\n    public String toString() {\n        return val +\"->\"+ next;\n    }\n\n    ListNode(int val) {\n         this.val = val;\n     }\n     ListNode(int val, ListNode next) {\n         this.val = val; this.next = next;\n     }\n}`\nthen in the main method create a ListNode and print it.\n\nListNode listNode2 =\n                new ListNode(1,\n                        new ListNode(2,\n                                new ListNode(3,\n                                        new ListNode(4))));\n\nit will print 1->2->3->4->null\n\nthe last link is null because we are using \"new ListNode(4)\" without specifying the \"next\" node (see the constructors) and by default the \"next\" = null; "
                    },
                    {
                        "username": "cemrecodes",
                        "content": "I keep getting runtime error when I want to use head.val , why is that?"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "[@greenchalk](/greenchalk) if given any empty list in any case, then accessing the value of nullpointer gives an error i.e for an empty list head is null so accessing the head for val gives run time error"
                    },
                    {
                        "username": "KevinKant210",
                        "content": "[@greenchalk](/greenchalk) if you are using c/c++ accessing a pointer (var with *)using . does not dereference it (meaning its just a memory address you are accessing instead of the value at that memory address). Try using an arrow  \"->\" inplace of dot \".\" in your code."
                    },
                    {
                        "username": "chaotic_10",
                        "content": "[@greenchalk](/greenchalk) Could you share your code  ?"
                    },
                    {
                        "username": "greenchalk",
                        "content": "Same issue, please someone explain."
                    }
                ]
            },
            {
                "id": 1787429,
                "content": [
                    {
                        "username": "sharankarchella",
                        "content": "This is my Python code explanation\n--------------------------\nTo Summarize , \nTwo Pointer Approach\nprev = Previous\ncurr = current\n------------------------------\nFirst Step\n------------------\nhead\n1----->2--->3\ncurr  \n        \nSecond step\n---------------------------------------------------\n\nNone--->1------------>2--->3\nprev-----curr\n\nThird step\n---------------------------\n                       \nNone<----------1--->2--->3\n prev ---------- curr\n\nFourth step\n---------------------------\n          \nNone<----------1<----2---->3\n----------------prev---curr\n\nFifth step\n---------------------------\n        \nNone<----------1<----2---->3\n-----------------------prev---curr\n\nSixth step\n---------------------------\nNone<----1<----2<----3<---None\n-------------------------prev---curr\n\n\nUnderstanding code:-\n\ntemp = curr.nxt  #While reversing Linked list curr.nxt link will be broken for that we are storing curr.nxt in temporary variable i.e temp = curr.nxt\nAnd We are linking our prev to curr.nxt as shown in third step\ncurr.nxt = prev\n\nprev = curr  #curr will be our prev\n\nSo, curr = curr.nxt  #Since we already linked Previous to curr.nxt \ncurr = temp  #temp will be our curr.nxt\n\nHope it helps you all :)\n--------------------------------"
                    },
                    {
                        "username": "Avi_007",
                        "content": "Thanks bro, for you detailed explanation.\\n It\\'s really help me to think clearly on my logic and implement it,\\nI was thinking in same line but could not able to reach to my final logic and it\\'s implementation. "
                    },
                    {
                        "username": "cagils",
                        "content": "1-line loop solution beating 99.7% using array deconstructed assignment in JS:\\n\\n```js\\nvar reverseList = function(head) {\\n    let prev = null;\\n    while (head) [head.next, prev, head] = [prev, head, head.next]\\n    return prev\\n};\\n```\\n\\nThe array to array deconstructed assignment can be expanded as:\\n\\n```js\\nlet temp = head.next\\nhead.next = prev\\nprev = head\\nhead = temp\\n```\\nUsing array deconstruction we can skip the temp variable.\\n\\n"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "No solutions..."
                    },
                    {
                        "username": "raularajuoliveira",
                        "content": "Hi\\nBased on the other posts in this discussion, I think I got a solution to the problem. However, when I test it I keep getting this weird error:  `=================================================================\\n==31==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000078 at pc 0x000000370e5d bp 0x7ffdcdaf7940 sp 0x7ffdcdaf7938`\\n\\nHere is my code:\\n\\n `class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head) \\n            return nullptr;\\n        ListNode* ptr1 = head;\\n        ListNode* ptr2 = head->next;\\n        ListNode* temp;\\n        while(ptr2 != nullptr){\\n            temp = ptr2->next;\\n            ptr2->next = ptr1;\\n            ptr1 = ptr2;\\n            ptr2 = temp; \\n        }\\n        return ptr1;\\n    }\\n};`\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "if(!head)\n       return nullptr;\n        ListNode*ptr1=head;\n        ListNode*ptr2=head->next;\n        ListNode*temp;\n      \n         ptr1->next=nullptr;\n       while(ptr2!=nullptr ){"
                    },
                    {
                        "username": "8oh8",
                        "content": "In previous examples (pascal\\'s triangle), the recursive relation was expressed mathematically as f(j,k) = f(j-1,k-1) + f(j-1,k)\\nwith base case being f(j-1,k) = 1 where j = 1 or j = k\\n\\nBut this linked list problem is different because it does not compute something.\\n\\nHow would you express the recursive relation?"
                    },
                    {
                        "username": "capdlx",
                        "content": "func reverseList(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlist := reverseList(head.Next)\\n\\thead.Next.Next = head\\n    head.Next=nil\\n\\treturn list\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/2249915/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "dude no solutions \\n"
                    },
                    {
                        "username": "Z3R0",
                        "content": "why am i getting error when i am simply trying to print(head.val)\\uD83E\\uDD72"
                    },
                    {
                        "username": "KostiaHoward",
                        "content": "Check that head is not null first. It\\'s the third test case."
                    },
                    {
                        "username": "alexfoto",
                        "content": "I\\'m trying to solve this using javascript. I understand how linked-lists and nodes work, but I am confused about how Leetcode is implementing them behind the scenes. Could anyone please provide a clear explanation of what the node/linked-list look like and how to access their \"val\" and \"next\" values.\\n\\nAs I\\'ve tried to solve this, I get frequent errors saying is cannot read a property of \"val\" or \"next\" on some node, and it\\'s just really throwing me off.\\n\\nAny help is greatly appreciated!"
                    },
                    {
                        "username": "Neeraj_svgh",
                        "content": "we shouldnt use val"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I don\\'t quite understand the example: \\ngive a head [1,2,6,3,4,5,6]\\nIn my understanding a head is a single node, how is it possible that the head has seven values? "
                    },
                    {
                        "username": "mujtabawaqas",
                        "content": "The head is the first node in a sequence of nodes, that point to the next node. The head doesn\\'t hold \"7\" values only its value and the address to the next node. The linked list is stored dynamically, so the head is the way to access the linked list."
                    },
                    {
                        "username": "chiradipcodes",
                        "content": "Easiest C++ Code:\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n           ListNode* forward=curr->next;\\n           curr->next=prev;\\n           prev=curr;\\n           curr=forward;\\n        }\\n        return prev;\\n    }\\n};"
                    },
                    {
                        "username": "shirshendhu",
                        "content": "We are advised to not post solutions on the discussions section."
                    },
                    {
                        "username": "Suresh_Vuppala",
                        "content": "C++ Reverse Linked List O(N) O(1) Simple Solution, Recursion and  Iterative.\\n**Leetcode 206. Reverse Linked List - Yellow Coding**\\nhttps://yellowcoding.com/leetcode-206-reverse-linked-list-2/\\n\\nCoding Interview made easy - Yellow Coding\\nPlease forward it to your friends.\\nhttps://t.me/YellowCoding"
                    }
                ]
            },
            {
                "id": 1821410,
                "content": [
                    {
                        "username": "sharankarchella",
                        "content": "This is my Python code explanation\n--------------------------\nTo Summarize , \nTwo Pointer Approach\nprev = Previous\ncurr = current\n------------------------------\nFirst Step\n------------------\nhead\n1----->2--->3\ncurr  \n        \nSecond step\n---------------------------------------------------\n\nNone--->1------------>2--->3\nprev-----curr\n\nThird step\n---------------------------\n                       \nNone<----------1--->2--->3\n prev ---------- curr\n\nFourth step\n---------------------------\n          \nNone<----------1<----2---->3\n----------------prev---curr\n\nFifth step\n---------------------------\n        \nNone<----------1<----2---->3\n-----------------------prev---curr\n\nSixth step\n---------------------------\nNone<----1<----2<----3<---None\n-------------------------prev---curr\n\n\nUnderstanding code:-\n\ntemp = curr.nxt  #While reversing Linked list curr.nxt link will be broken for that we are storing curr.nxt in temporary variable i.e temp = curr.nxt\nAnd We are linking our prev to curr.nxt as shown in third step\ncurr.nxt = prev\n\nprev = curr  #curr will be our prev\n\nSo, curr = curr.nxt  #Since we already linked Previous to curr.nxt \ncurr = temp  #temp will be our curr.nxt\n\nHope it helps you all :)\n--------------------------------"
                    },
                    {
                        "username": "Avi_007",
                        "content": "Thanks bro, for you detailed explanation.\\n It\\'s really help me to think clearly on my logic and implement it,\\nI was thinking in same line but could not able to reach to my final logic and it\\'s implementation. "
                    },
                    {
                        "username": "cagils",
                        "content": "1-line loop solution beating 99.7% using array deconstructed assignment in JS:\\n\\n```js\\nvar reverseList = function(head) {\\n    let prev = null;\\n    while (head) [head.next, prev, head] = [prev, head, head.next]\\n    return prev\\n};\\n```\\n\\nThe array to array deconstructed assignment can be expanded as:\\n\\n```js\\nlet temp = head.next\\nhead.next = prev\\nprev = head\\nhead = temp\\n```\\nUsing array deconstruction we can skip the temp variable.\\n\\n"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "No solutions..."
                    },
                    {
                        "username": "raularajuoliveira",
                        "content": "Hi\\nBased on the other posts in this discussion, I think I got a solution to the problem. However, when I test it I keep getting this weird error:  `=================================================================\\n==31==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000078 at pc 0x000000370e5d bp 0x7ffdcdaf7940 sp 0x7ffdcdaf7938`\\n\\nHere is my code:\\n\\n `class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head) \\n            return nullptr;\\n        ListNode* ptr1 = head;\\n        ListNode* ptr2 = head->next;\\n        ListNode* temp;\\n        while(ptr2 != nullptr){\\n            temp = ptr2->next;\\n            ptr2->next = ptr1;\\n            ptr1 = ptr2;\\n            ptr2 = temp; \\n        }\\n        return ptr1;\\n    }\\n};`\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "if(!head)\n       return nullptr;\n        ListNode*ptr1=head;\n        ListNode*ptr2=head->next;\n        ListNode*temp;\n      \n         ptr1->next=nullptr;\n       while(ptr2!=nullptr ){"
                    },
                    {
                        "username": "8oh8",
                        "content": "In previous examples (pascal\\'s triangle), the recursive relation was expressed mathematically as f(j,k) = f(j-1,k-1) + f(j-1,k)\\nwith base case being f(j-1,k) = 1 where j = 1 or j = k\\n\\nBut this linked list problem is different because it does not compute something.\\n\\nHow would you express the recursive relation?"
                    },
                    {
                        "username": "capdlx",
                        "content": "func reverseList(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlist := reverseList(head.Next)\\n\\thead.Next.Next = head\\n    head.Next=nil\\n\\treturn list\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/2249915/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "dude no solutions \\n"
                    },
                    {
                        "username": "Z3R0",
                        "content": "why am i getting error when i am simply trying to print(head.val)\\uD83E\\uDD72"
                    },
                    {
                        "username": "KostiaHoward",
                        "content": "Check that head is not null first. It\\'s the third test case."
                    },
                    {
                        "username": "alexfoto",
                        "content": "I\\'m trying to solve this using javascript. I understand how linked-lists and nodes work, but I am confused about how Leetcode is implementing them behind the scenes. Could anyone please provide a clear explanation of what the node/linked-list look like and how to access their \"val\" and \"next\" values.\\n\\nAs I\\'ve tried to solve this, I get frequent errors saying is cannot read a property of \"val\" or \"next\" on some node, and it\\'s just really throwing me off.\\n\\nAny help is greatly appreciated!"
                    },
                    {
                        "username": "Neeraj_svgh",
                        "content": "we shouldnt use val"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I don\\'t quite understand the example: \\ngive a head [1,2,6,3,4,5,6]\\nIn my understanding a head is a single node, how is it possible that the head has seven values? "
                    },
                    {
                        "username": "mujtabawaqas",
                        "content": "The head is the first node in a sequence of nodes, that point to the next node. The head doesn\\'t hold \"7\" values only its value and the address to the next node. The linked list is stored dynamically, so the head is the way to access the linked list."
                    },
                    {
                        "username": "chiradipcodes",
                        "content": "Easiest C++ Code:\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n           ListNode* forward=curr->next;\\n           curr->next=prev;\\n           prev=curr;\\n           curr=forward;\\n        }\\n        return prev;\\n    }\\n};"
                    },
                    {
                        "username": "shirshendhu",
                        "content": "We are advised to not post solutions on the discussions section."
                    },
                    {
                        "username": "Suresh_Vuppala",
                        "content": "C++ Reverse Linked List O(N) O(1) Simple Solution, Recursion and  Iterative.\\n**Leetcode 206. Reverse Linked List - Yellow Coding**\\nhttps://yellowcoding.com/leetcode-206-reverse-linked-list-2/\\n\\nCoding Interview made easy - Yellow Coding\\nPlease forward it to your friends.\\nhttps://t.me/YellowCoding"
                    }
                ]
            },
            {
                "id": 1789613,
                "content": [
                    {
                        "username": "sharankarchella",
                        "content": "This is my Python code explanation\n--------------------------\nTo Summarize , \nTwo Pointer Approach\nprev = Previous\ncurr = current\n------------------------------\nFirst Step\n------------------\nhead\n1----->2--->3\ncurr  \n        \nSecond step\n---------------------------------------------------\n\nNone--->1------------>2--->3\nprev-----curr\n\nThird step\n---------------------------\n                       \nNone<----------1--->2--->3\n prev ---------- curr\n\nFourth step\n---------------------------\n          \nNone<----------1<----2---->3\n----------------prev---curr\n\nFifth step\n---------------------------\n        \nNone<----------1<----2---->3\n-----------------------prev---curr\n\nSixth step\n---------------------------\nNone<----1<----2<----3<---None\n-------------------------prev---curr\n\n\nUnderstanding code:-\n\ntemp = curr.nxt  #While reversing Linked list curr.nxt link will be broken for that we are storing curr.nxt in temporary variable i.e temp = curr.nxt\nAnd We are linking our prev to curr.nxt as shown in third step\ncurr.nxt = prev\n\nprev = curr  #curr will be our prev\n\nSo, curr = curr.nxt  #Since we already linked Previous to curr.nxt \ncurr = temp  #temp will be our curr.nxt\n\nHope it helps you all :)\n--------------------------------"
                    },
                    {
                        "username": "Avi_007",
                        "content": "Thanks bro, for you detailed explanation.\\n It\\'s really help me to think clearly on my logic and implement it,\\nI was thinking in same line but could not able to reach to my final logic and it\\'s implementation. "
                    },
                    {
                        "username": "cagils",
                        "content": "1-line loop solution beating 99.7% using array deconstructed assignment in JS:\\n\\n```js\\nvar reverseList = function(head) {\\n    let prev = null;\\n    while (head) [head.next, prev, head] = [prev, head, head.next]\\n    return prev\\n};\\n```\\n\\nThe array to array deconstructed assignment can be expanded as:\\n\\n```js\\nlet temp = head.next\\nhead.next = prev\\nprev = head\\nhead = temp\\n```\\nUsing array deconstruction we can skip the temp variable.\\n\\n"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "No solutions..."
                    },
                    {
                        "username": "raularajuoliveira",
                        "content": "Hi\\nBased on the other posts in this discussion, I think I got a solution to the problem. However, when I test it I keep getting this weird error:  `=================================================================\\n==31==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000078 at pc 0x000000370e5d bp 0x7ffdcdaf7940 sp 0x7ffdcdaf7938`\\n\\nHere is my code:\\n\\n `class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head) \\n            return nullptr;\\n        ListNode* ptr1 = head;\\n        ListNode* ptr2 = head->next;\\n        ListNode* temp;\\n        while(ptr2 != nullptr){\\n            temp = ptr2->next;\\n            ptr2->next = ptr1;\\n            ptr1 = ptr2;\\n            ptr2 = temp; \\n        }\\n        return ptr1;\\n    }\\n};`\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "if(!head)\n       return nullptr;\n        ListNode*ptr1=head;\n        ListNode*ptr2=head->next;\n        ListNode*temp;\n      \n         ptr1->next=nullptr;\n       while(ptr2!=nullptr ){"
                    },
                    {
                        "username": "8oh8",
                        "content": "In previous examples (pascal\\'s triangle), the recursive relation was expressed mathematically as f(j,k) = f(j-1,k-1) + f(j-1,k)\\nwith base case being f(j-1,k) = 1 where j = 1 or j = k\\n\\nBut this linked list problem is different because it does not compute something.\\n\\nHow would you express the recursive relation?"
                    },
                    {
                        "username": "capdlx",
                        "content": "func reverseList(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlist := reverseList(head.Next)\\n\\thead.Next.Next = head\\n    head.Next=nil\\n\\treturn list\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/2249915/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "dude no solutions \\n"
                    },
                    {
                        "username": "Z3R0",
                        "content": "why am i getting error when i am simply trying to print(head.val)\\uD83E\\uDD72"
                    },
                    {
                        "username": "KostiaHoward",
                        "content": "Check that head is not null first. It\\'s the third test case."
                    },
                    {
                        "username": "alexfoto",
                        "content": "I\\'m trying to solve this using javascript. I understand how linked-lists and nodes work, but I am confused about how Leetcode is implementing them behind the scenes. Could anyone please provide a clear explanation of what the node/linked-list look like and how to access their \"val\" and \"next\" values.\\n\\nAs I\\'ve tried to solve this, I get frequent errors saying is cannot read a property of \"val\" or \"next\" on some node, and it\\'s just really throwing me off.\\n\\nAny help is greatly appreciated!"
                    },
                    {
                        "username": "Neeraj_svgh",
                        "content": "we shouldnt use val"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I don\\'t quite understand the example: \\ngive a head [1,2,6,3,4,5,6]\\nIn my understanding a head is a single node, how is it possible that the head has seven values? "
                    },
                    {
                        "username": "mujtabawaqas",
                        "content": "The head is the first node in a sequence of nodes, that point to the next node. The head doesn\\'t hold \"7\" values only its value and the address to the next node. The linked list is stored dynamically, so the head is the way to access the linked list."
                    },
                    {
                        "username": "chiradipcodes",
                        "content": "Easiest C++ Code:\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n           ListNode* forward=curr->next;\\n           curr->next=prev;\\n           prev=curr;\\n           curr=forward;\\n        }\\n        return prev;\\n    }\\n};"
                    },
                    {
                        "username": "shirshendhu",
                        "content": "We are advised to not post solutions on the discussions section."
                    },
                    {
                        "username": "Suresh_Vuppala",
                        "content": "C++ Reverse Linked List O(N) O(1) Simple Solution, Recursion and  Iterative.\\n**Leetcode 206. Reverse Linked List - Yellow Coding**\\nhttps://yellowcoding.com/leetcode-206-reverse-linked-list-2/\\n\\nCoding Interview made easy - Yellow Coding\\nPlease forward it to your friends.\\nhttps://t.me/YellowCoding"
                    }
                ]
            },
            {
                "id": 1569565,
                "content": [
                    {
                        "username": "sharankarchella",
                        "content": "This is my Python code explanation\n--------------------------\nTo Summarize , \nTwo Pointer Approach\nprev = Previous\ncurr = current\n------------------------------\nFirst Step\n------------------\nhead\n1----->2--->3\ncurr  \n        \nSecond step\n---------------------------------------------------\n\nNone--->1------------>2--->3\nprev-----curr\n\nThird step\n---------------------------\n                       \nNone<----------1--->2--->3\n prev ---------- curr\n\nFourth step\n---------------------------\n          \nNone<----------1<----2---->3\n----------------prev---curr\n\nFifth step\n---------------------------\n        \nNone<----------1<----2---->3\n-----------------------prev---curr\n\nSixth step\n---------------------------\nNone<----1<----2<----3<---None\n-------------------------prev---curr\n\n\nUnderstanding code:-\n\ntemp = curr.nxt  #While reversing Linked list curr.nxt link will be broken for that we are storing curr.nxt in temporary variable i.e temp = curr.nxt\nAnd We are linking our prev to curr.nxt as shown in third step\ncurr.nxt = prev\n\nprev = curr  #curr will be our prev\n\nSo, curr = curr.nxt  #Since we already linked Previous to curr.nxt \ncurr = temp  #temp will be our curr.nxt\n\nHope it helps you all :)\n--------------------------------"
                    },
                    {
                        "username": "Avi_007",
                        "content": "Thanks bro, for you detailed explanation.\\n It\\'s really help me to think clearly on my logic and implement it,\\nI was thinking in same line but could not able to reach to my final logic and it\\'s implementation. "
                    },
                    {
                        "username": "cagils",
                        "content": "1-line loop solution beating 99.7% using array deconstructed assignment in JS:\\n\\n```js\\nvar reverseList = function(head) {\\n    let prev = null;\\n    while (head) [head.next, prev, head] = [prev, head, head.next]\\n    return prev\\n};\\n```\\n\\nThe array to array deconstructed assignment can be expanded as:\\n\\n```js\\nlet temp = head.next\\nhead.next = prev\\nprev = head\\nhead = temp\\n```\\nUsing array deconstruction we can skip the temp variable.\\n\\n"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "No solutions..."
                    },
                    {
                        "username": "raularajuoliveira",
                        "content": "Hi\\nBased on the other posts in this discussion, I think I got a solution to the problem. However, when I test it I keep getting this weird error:  `=================================================================\\n==31==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000078 at pc 0x000000370e5d bp 0x7ffdcdaf7940 sp 0x7ffdcdaf7938`\\n\\nHere is my code:\\n\\n `class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head) \\n            return nullptr;\\n        ListNode* ptr1 = head;\\n        ListNode* ptr2 = head->next;\\n        ListNode* temp;\\n        while(ptr2 != nullptr){\\n            temp = ptr2->next;\\n            ptr2->next = ptr1;\\n            ptr1 = ptr2;\\n            ptr2 = temp; \\n        }\\n        return ptr1;\\n    }\\n};`\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "if(!head)\n       return nullptr;\n        ListNode*ptr1=head;\n        ListNode*ptr2=head->next;\n        ListNode*temp;\n      \n         ptr1->next=nullptr;\n       while(ptr2!=nullptr ){"
                    },
                    {
                        "username": "8oh8",
                        "content": "In previous examples (pascal\\'s triangle), the recursive relation was expressed mathematically as f(j,k) = f(j-1,k-1) + f(j-1,k)\\nwith base case being f(j-1,k) = 1 where j = 1 or j = k\\n\\nBut this linked list problem is different because it does not compute something.\\n\\nHow would you express the recursive relation?"
                    },
                    {
                        "username": "capdlx",
                        "content": "func reverseList(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlist := reverseList(head.Next)\\n\\thead.Next.Next = head\\n    head.Next=nil\\n\\treturn list\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/2249915/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "dude no solutions \\n"
                    },
                    {
                        "username": "Z3R0",
                        "content": "why am i getting error when i am simply trying to print(head.val)\\uD83E\\uDD72"
                    },
                    {
                        "username": "KostiaHoward",
                        "content": "Check that head is not null first. It\\'s the third test case."
                    },
                    {
                        "username": "alexfoto",
                        "content": "I\\'m trying to solve this using javascript. I understand how linked-lists and nodes work, but I am confused about how Leetcode is implementing them behind the scenes. Could anyone please provide a clear explanation of what the node/linked-list look like and how to access their \"val\" and \"next\" values.\\n\\nAs I\\'ve tried to solve this, I get frequent errors saying is cannot read a property of \"val\" or \"next\" on some node, and it\\'s just really throwing me off.\\n\\nAny help is greatly appreciated!"
                    },
                    {
                        "username": "Neeraj_svgh",
                        "content": "we shouldnt use val"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I don\\'t quite understand the example: \\ngive a head [1,2,6,3,4,5,6]\\nIn my understanding a head is a single node, how is it possible that the head has seven values? "
                    },
                    {
                        "username": "mujtabawaqas",
                        "content": "The head is the first node in a sequence of nodes, that point to the next node. The head doesn\\'t hold \"7\" values only its value and the address to the next node. The linked list is stored dynamically, so the head is the way to access the linked list."
                    },
                    {
                        "username": "chiradipcodes",
                        "content": "Easiest C++ Code:\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n           ListNode* forward=curr->next;\\n           curr->next=prev;\\n           prev=curr;\\n           curr=forward;\\n        }\\n        return prev;\\n    }\\n};"
                    },
                    {
                        "username": "shirshendhu",
                        "content": "We are advised to not post solutions on the discussions section."
                    },
                    {
                        "username": "Suresh_Vuppala",
                        "content": "C++ Reverse Linked List O(N) O(1) Simple Solution, Recursion and  Iterative.\\n**Leetcode 206. Reverse Linked List - Yellow Coding**\\nhttps://yellowcoding.com/leetcode-206-reverse-linked-list-2/\\n\\nCoding Interview made easy - Yellow Coding\\nPlease forward it to your friends.\\nhttps://t.me/YellowCoding"
                    }
                ]
            },
            {
                "id": 1575897,
                "content": [
                    {
                        "username": "sharankarchella",
                        "content": "This is my Python code explanation\n--------------------------\nTo Summarize , \nTwo Pointer Approach\nprev = Previous\ncurr = current\n------------------------------\nFirst Step\n------------------\nhead\n1----->2--->3\ncurr  \n        \nSecond step\n---------------------------------------------------\n\nNone--->1------------>2--->3\nprev-----curr\n\nThird step\n---------------------------\n                       \nNone<----------1--->2--->3\n prev ---------- curr\n\nFourth step\n---------------------------\n          \nNone<----------1<----2---->3\n----------------prev---curr\n\nFifth step\n---------------------------\n        \nNone<----------1<----2---->3\n-----------------------prev---curr\n\nSixth step\n---------------------------\nNone<----1<----2<----3<---None\n-------------------------prev---curr\n\n\nUnderstanding code:-\n\ntemp = curr.nxt  #While reversing Linked list curr.nxt link will be broken for that we are storing curr.nxt in temporary variable i.e temp = curr.nxt\nAnd We are linking our prev to curr.nxt as shown in third step\ncurr.nxt = prev\n\nprev = curr  #curr will be our prev\n\nSo, curr = curr.nxt  #Since we already linked Previous to curr.nxt \ncurr = temp  #temp will be our curr.nxt\n\nHope it helps you all :)\n--------------------------------"
                    },
                    {
                        "username": "Avi_007",
                        "content": "Thanks bro, for you detailed explanation.\\n It\\'s really help me to think clearly on my logic and implement it,\\nI was thinking in same line but could not able to reach to my final logic and it\\'s implementation. "
                    },
                    {
                        "username": "cagils",
                        "content": "1-line loop solution beating 99.7% using array deconstructed assignment in JS:\\n\\n```js\\nvar reverseList = function(head) {\\n    let prev = null;\\n    while (head) [head.next, prev, head] = [prev, head, head.next]\\n    return prev\\n};\\n```\\n\\nThe array to array deconstructed assignment can be expanded as:\\n\\n```js\\nlet temp = head.next\\nhead.next = prev\\nprev = head\\nhead = temp\\n```\\nUsing array deconstruction we can skip the temp variable.\\n\\n"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "No solutions..."
                    },
                    {
                        "username": "raularajuoliveira",
                        "content": "Hi\\nBased on the other posts in this discussion, I think I got a solution to the problem. However, when I test it I keep getting this weird error:  `=================================================================\\n==31==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000078 at pc 0x000000370e5d bp 0x7ffdcdaf7940 sp 0x7ffdcdaf7938`\\n\\nHere is my code:\\n\\n `class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head) \\n            return nullptr;\\n        ListNode* ptr1 = head;\\n        ListNode* ptr2 = head->next;\\n        ListNode* temp;\\n        while(ptr2 != nullptr){\\n            temp = ptr2->next;\\n            ptr2->next = ptr1;\\n            ptr1 = ptr2;\\n            ptr2 = temp; \\n        }\\n        return ptr1;\\n    }\\n};`\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "if(!head)\n       return nullptr;\n        ListNode*ptr1=head;\n        ListNode*ptr2=head->next;\n        ListNode*temp;\n      \n         ptr1->next=nullptr;\n       while(ptr2!=nullptr ){"
                    },
                    {
                        "username": "8oh8",
                        "content": "In previous examples (pascal\\'s triangle), the recursive relation was expressed mathematically as f(j,k) = f(j-1,k-1) + f(j-1,k)\\nwith base case being f(j-1,k) = 1 where j = 1 or j = k\\n\\nBut this linked list problem is different because it does not compute something.\\n\\nHow would you express the recursive relation?"
                    },
                    {
                        "username": "capdlx",
                        "content": "func reverseList(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlist := reverseList(head.Next)\\n\\thead.Next.Next = head\\n    head.Next=nil\\n\\treturn list\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/2249915/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "dude no solutions \\n"
                    },
                    {
                        "username": "Z3R0",
                        "content": "why am i getting error when i am simply trying to print(head.val)\\uD83E\\uDD72"
                    },
                    {
                        "username": "KostiaHoward",
                        "content": "Check that head is not null first. It\\'s the third test case."
                    },
                    {
                        "username": "alexfoto",
                        "content": "I\\'m trying to solve this using javascript. I understand how linked-lists and nodes work, but I am confused about how Leetcode is implementing them behind the scenes. Could anyone please provide a clear explanation of what the node/linked-list look like and how to access their \"val\" and \"next\" values.\\n\\nAs I\\'ve tried to solve this, I get frequent errors saying is cannot read a property of \"val\" or \"next\" on some node, and it\\'s just really throwing me off.\\n\\nAny help is greatly appreciated!"
                    },
                    {
                        "username": "Neeraj_svgh",
                        "content": "we shouldnt use val"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I don\\'t quite understand the example: \\ngive a head [1,2,6,3,4,5,6]\\nIn my understanding a head is a single node, how is it possible that the head has seven values? "
                    },
                    {
                        "username": "mujtabawaqas",
                        "content": "The head is the first node in a sequence of nodes, that point to the next node. The head doesn\\'t hold \"7\" values only its value and the address to the next node. The linked list is stored dynamically, so the head is the way to access the linked list."
                    },
                    {
                        "username": "chiradipcodes",
                        "content": "Easiest C++ Code:\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n           ListNode* forward=curr->next;\\n           curr->next=prev;\\n           prev=curr;\\n           curr=forward;\\n        }\\n        return prev;\\n    }\\n};"
                    },
                    {
                        "username": "shirshendhu",
                        "content": "We are advised to not post solutions on the discussions section."
                    },
                    {
                        "username": "Suresh_Vuppala",
                        "content": "C++ Reverse Linked List O(N) O(1) Simple Solution, Recursion and  Iterative.\\n**Leetcode 206. Reverse Linked List - Yellow Coding**\\nhttps://yellowcoding.com/leetcode-206-reverse-linked-list-2/\\n\\nCoding Interview made easy - Yellow Coding\\nPlease forward it to your friends.\\nhttps://t.me/YellowCoding"
                    }
                ]
            },
            {
                "id": 1931487,
                "content": [
                    {
                        "username": "sharankarchella",
                        "content": "This is my Python code explanation\n--------------------------\nTo Summarize , \nTwo Pointer Approach\nprev = Previous\ncurr = current\n------------------------------\nFirst Step\n------------------\nhead\n1----->2--->3\ncurr  \n        \nSecond step\n---------------------------------------------------\n\nNone--->1------------>2--->3\nprev-----curr\n\nThird step\n---------------------------\n                       \nNone<----------1--->2--->3\n prev ---------- curr\n\nFourth step\n---------------------------\n          \nNone<----------1<----2---->3\n----------------prev---curr\n\nFifth step\n---------------------------\n        \nNone<----------1<----2---->3\n-----------------------prev---curr\n\nSixth step\n---------------------------\nNone<----1<----2<----3<---None\n-------------------------prev---curr\n\n\nUnderstanding code:-\n\ntemp = curr.nxt  #While reversing Linked list curr.nxt link will be broken for that we are storing curr.nxt in temporary variable i.e temp = curr.nxt\nAnd We are linking our prev to curr.nxt as shown in third step\ncurr.nxt = prev\n\nprev = curr  #curr will be our prev\n\nSo, curr = curr.nxt  #Since we already linked Previous to curr.nxt \ncurr = temp  #temp will be our curr.nxt\n\nHope it helps you all :)\n--------------------------------"
                    },
                    {
                        "username": "Avi_007",
                        "content": "Thanks bro, for you detailed explanation.\\n It\\'s really help me to think clearly on my logic and implement it,\\nI was thinking in same line but could not able to reach to my final logic and it\\'s implementation. "
                    },
                    {
                        "username": "cagils",
                        "content": "1-line loop solution beating 99.7% using array deconstructed assignment in JS:\\n\\n```js\\nvar reverseList = function(head) {\\n    let prev = null;\\n    while (head) [head.next, prev, head] = [prev, head, head.next]\\n    return prev\\n};\\n```\\n\\nThe array to array deconstructed assignment can be expanded as:\\n\\n```js\\nlet temp = head.next\\nhead.next = prev\\nprev = head\\nhead = temp\\n```\\nUsing array deconstruction we can skip the temp variable.\\n\\n"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "No solutions..."
                    },
                    {
                        "username": "raularajuoliveira",
                        "content": "Hi\\nBased on the other posts in this discussion, I think I got a solution to the problem. However, when I test it I keep getting this weird error:  `=================================================================\\n==31==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000078 at pc 0x000000370e5d bp 0x7ffdcdaf7940 sp 0x7ffdcdaf7938`\\n\\nHere is my code:\\n\\n `class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head) \\n            return nullptr;\\n        ListNode* ptr1 = head;\\n        ListNode* ptr2 = head->next;\\n        ListNode* temp;\\n        while(ptr2 != nullptr){\\n            temp = ptr2->next;\\n            ptr2->next = ptr1;\\n            ptr1 = ptr2;\\n            ptr2 = temp; \\n        }\\n        return ptr1;\\n    }\\n};`\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "if(!head)\n       return nullptr;\n        ListNode*ptr1=head;\n        ListNode*ptr2=head->next;\n        ListNode*temp;\n      \n         ptr1->next=nullptr;\n       while(ptr2!=nullptr ){"
                    },
                    {
                        "username": "8oh8",
                        "content": "In previous examples (pascal\\'s triangle), the recursive relation was expressed mathematically as f(j,k) = f(j-1,k-1) + f(j-1,k)\\nwith base case being f(j-1,k) = 1 where j = 1 or j = k\\n\\nBut this linked list problem is different because it does not compute something.\\n\\nHow would you express the recursive relation?"
                    },
                    {
                        "username": "capdlx",
                        "content": "func reverseList(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlist := reverseList(head.Next)\\n\\thead.Next.Next = head\\n    head.Next=nil\\n\\treturn list\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/2249915/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "dude no solutions \\n"
                    },
                    {
                        "username": "Z3R0",
                        "content": "why am i getting error when i am simply trying to print(head.val)\\uD83E\\uDD72"
                    },
                    {
                        "username": "KostiaHoward",
                        "content": "Check that head is not null first. It\\'s the third test case."
                    },
                    {
                        "username": "alexfoto",
                        "content": "I\\'m trying to solve this using javascript. I understand how linked-lists and nodes work, but I am confused about how Leetcode is implementing them behind the scenes. Could anyone please provide a clear explanation of what the node/linked-list look like and how to access their \"val\" and \"next\" values.\\n\\nAs I\\'ve tried to solve this, I get frequent errors saying is cannot read a property of \"val\" or \"next\" on some node, and it\\'s just really throwing me off.\\n\\nAny help is greatly appreciated!"
                    },
                    {
                        "username": "Neeraj_svgh",
                        "content": "we shouldnt use val"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I don\\'t quite understand the example: \\ngive a head [1,2,6,3,4,5,6]\\nIn my understanding a head is a single node, how is it possible that the head has seven values? "
                    },
                    {
                        "username": "mujtabawaqas",
                        "content": "The head is the first node in a sequence of nodes, that point to the next node. The head doesn\\'t hold \"7\" values only its value and the address to the next node. The linked list is stored dynamically, so the head is the way to access the linked list."
                    },
                    {
                        "username": "chiradipcodes",
                        "content": "Easiest C++ Code:\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n           ListNode* forward=curr->next;\\n           curr->next=prev;\\n           prev=curr;\\n           curr=forward;\\n        }\\n        return prev;\\n    }\\n};"
                    },
                    {
                        "username": "shirshendhu",
                        "content": "We are advised to not post solutions on the discussions section."
                    },
                    {
                        "username": "Suresh_Vuppala",
                        "content": "C++ Reverse Linked List O(N) O(1) Simple Solution, Recursion and  Iterative.\\n**Leetcode 206. Reverse Linked List - Yellow Coding**\\nhttps://yellowcoding.com/leetcode-206-reverse-linked-list-2/\\n\\nCoding Interview made easy - Yellow Coding\\nPlease forward it to your friends.\\nhttps://t.me/YellowCoding"
                    }
                ]
            },
            {
                "id": 1866850,
                "content": [
                    {
                        "username": "sharankarchella",
                        "content": "This is my Python code explanation\n--------------------------\nTo Summarize , \nTwo Pointer Approach\nprev = Previous\ncurr = current\n------------------------------\nFirst Step\n------------------\nhead\n1----->2--->3\ncurr  \n        \nSecond step\n---------------------------------------------------\n\nNone--->1------------>2--->3\nprev-----curr\n\nThird step\n---------------------------\n                       \nNone<----------1--->2--->3\n prev ---------- curr\n\nFourth step\n---------------------------\n          \nNone<----------1<----2---->3\n----------------prev---curr\n\nFifth step\n---------------------------\n        \nNone<----------1<----2---->3\n-----------------------prev---curr\n\nSixth step\n---------------------------\nNone<----1<----2<----3<---None\n-------------------------prev---curr\n\n\nUnderstanding code:-\n\ntemp = curr.nxt  #While reversing Linked list curr.nxt link will be broken for that we are storing curr.nxt in temporary variable i.e temp = curr.nxt\nAnd We are linking our prev to curr.nxt as shown in third step\ncurr.nxt = prev\n\nprev = curr  #curr will be our prev\n\nSo, curr = curr.nxt  #Since we already linked Previous to curr.nxt \ncurr = temp  #temp will be our curr.nxt\n\nHope it helps you all :)\n--------------------------------"
                    },
                    {
                        "username": "Avi_007",
                        "content": "Thanks bro, for you detailed explanation.\\n It\\'s really help me to think clearly on my logic and implement it,\\nI was thinking in same line but could not able to reach to my final logic and it\\'s implementation. "
                    },
                    {
                        "username": "cagils",
                        "content": "1-line loop solution beating 99.7% using array deconstructed assignment in JS:\\n\\n```js\\nvar reverseList = function(head) {\\n    let prev = null;\\n    while (head) [head.next, prev, head] = [prev, head, head.next]\\n    return prev\\n};\\n```\\n\\nThe array to array deconstructed assignment can be expanded as:\\n\\n```js\\nlet temp = head.next\\nhead.next = prev\\nprev = head\\nhead = temp\\n```\\nUsing array deconstruction we can skip the temp variable.\\n\\n"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "No solutions..."
                    },
                    {
                        "username": "raularajuoliveira",
                        "content": "Hi\\nBased on the other posts in this discussion, I think I got a solution to the problem. However, when I test it I keep getting this weird error:  `=================================================================\\n==31==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000078 at pc 0x000000370e5d bp 0x7ffdcdaf7940 sp 0x7ffdcdaf7938`\\n\\nHere is my code:\\n\\n `class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head) \\n            return nullptr;\\n        ListNode* ptr1 = head;\\n        ListNode* ptr2 = head->next;\\n        ListNode* temp;\\n        while(ptr2 != nullptr){\\n            temp = ptr2->next;\\n            ptr2->next = ptr1;\\n            ptr1 = ptr2;\\n            ptr2 = temp; \\n        }\\n        return ptr1;\\n    }\\n};`\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "if(!head)\n       return nullptr;\n        ListNode*ptr1=head;\n        ListNode*ptr2=head->next;\n        ListNode*temp;\n      \n         ptr1->next=nullptr;\n       while(ptr2!=nullptr ){"
                    },
                    {
                        "username": "8oh8",
                        "content": "In previous examples (pascal\\'s triangle), the recursive relation was expressed mathematically as f(j,k) = f(j-1,k-1) + f(j-1,k)\\nwith base case being f(j-1,k) = 1 where j = 1 or j = k\\n\\nBut this linked list problem is different because it does not compute something.\\n\\nHow would you express the recursive relation?"
                    },
                    {
                        "username": "capdlx",
                        "content": "func reverseList(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlist := reverseList(head.Next)\\n\\thead.Next.Next = head\\n    head.Next=nil\\n\\treturn list\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/2249915/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "dude no solutions \\n"
                    },
                    {
                        "username": "Z3R0",
                        "content": "why am i getting error when i am simply trying to print(head.val)\\uD83E\\uDD72"
                    },
                    {
                        "username": "KostiaHoward",
                        "content": "Check that head is not null first. It\\'s the third test case."
                    },
                    {
                        "username": "alexfoto",
                        "content": "I\\'m trying to solve this using javascript. I understand how linked-lists and nodes work, but I am confused about how Leetcode is implementing them behind the scenes. Could anyone please provide a clear explanation of what the node/linked-list look like and how to access their \"val\" and \"next\" values.\\n\\nAs I\\'ve tried to solve this, I get frequent errors saying is cannot read a property of \"val\" or \"next\" on some node, and it\\'s just really throwing me off.\\n\\nAny help is greatly appreciated!"
                    },
                    {
                        "username": "Neeraj_svgh",
                        "content": "we shouldnt use val"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I don\\'t quite understand the example: \\ngive a head [1,2,6,3,4,5,6]\\nIn my understanding a head is a single node, how is it possible that the head has seven values? "
                    },
                    {
                        "username": "mujtabawaqas",
                        "content": "The head is the first node in a sequence of nodes, that point to the next node. The head doesn\\'t hold \"7\" values only its value and the address to the next node. The linked list is stored dynamically, so the head is the way to access the linked list."
                    },
                    {
                        "username": "chiradipcodes",
                        "content": "Easiest C++ Code:\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n           ListNode* forward=curr->next;\\n           curr->next=prev;\\n           prev=curr;\\n           curr=forward;\\n        }\\n        return prev;\\n    }\\n};"
                    },
                    {
                        "username": "shirshendhu",
                        "content": "We are advised to not post solutions on the discussions section."
                    },
                    {
                        "username": "Suresh_Vuppala",
                        "content": "C++ Reverse Linked List O(N) O(1) Simple Solution, Recursion and  Iterative.\\n**Leetcode 206. Reverse Linked List - Yellow Coding**\\nhttps://yellowcoding.com/leetcode-206-reverse-linked-list-2/\\n\\nCoding Interview made easy - Yellow Coding\\nPlease forward it to your friends.\\nhttps://t.me/YellowCoding"
                    }
                ]
            },
            {
                "id": 1795736,
                "content": [
                    {
                        "username": "sharankarchella",
                        "content": "This is my Python code explanation\n--------------------------\nTo Summarize , \nTwo Pointer Approach\nprev = Previous\ncurr = current\n------------------------------\nFirst Step\n------------------\nhead\n1----->2--->3\ncurr  \n        \nSecond step\n---------------------------------------------------\n\nNone--->1------------>2--->3\nprev-----curr\n\nThird step\n---------------------------\n                       \nNone<----------1--->2--->3\n prev ---------- curr\n\nFourth step\n---------------------------\n          \nNone<----------1<----2---->3\n----------------prev---curr\n\nFifth step\n---------------------------\n        \nNone<----------1<----2---->3\n-----------------------prev---curr\n\nSixth step\n---------------------------\nNone<----1<----2<----3<---None\n-------------------------prev---curr\n\n\nUnderstanding code:-\n\ntemp = curr.nxt  #While reversing Linked list curr.nxt link will be broken for that we are storing curr.nxt in temporary variable i.e temp = curr.nxt\nAnd We are linking our prev to curr.nxt as shown in third step\ncurr.nxt = prev\n\nprev = curr  #curr will be our prev\n\nSo, curr = curr.nxt  #Since we already linked Previous to curr.nxt \ncurr = temp  #temp will be our curr.nxt\n\nHope it helps you all :)\n--------------------------------"
                    },
                    {
                        "username": "Avi_007",
                        "content": "Thanks bro, for you detailed explanation.\\n It\\'s really help me to think clearly on my logic and implement it,\\nI was thinking in same line but could not able to reach to my final logic and it\\'s implementation. "
                    },
                    {
                        "username": "cagils",
                        "content": "1-line loop solution beating 99.7% using array deconstructed assignment in JS:\\n\\n```js\\nvar reverseList = function(head) {\\n    let prev = null;\\n    while (head) [head.next, prev, head] = [prev, head, head.next]\\n    return prev\\n};\\n```\\n\\nThe array to array deconstructed assignment can be expanded as:\\n\\n```js\\nlet temp = head.next\\nhead.next = prev\\nprev = head\\nhead = temp\\n```\\nUsing array deconstruction we can skip the temp variable.\\n\\n"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "No solutions..."
                    },
                    {
                        "username": "raularajuoliveira",
                        "content": "Hi\\nBased on the other posts in this discussion, I think I got a solution to the problem. However, when I test it I keep getting this weird error:  `=================================================================\\n==31==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000078 at pc 0x000000370e5d bp 0x7ffdcdaf7940 sp 0x7ffdcdaf7938`\\n\\nHere is my code:\\n\\n `class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head) \\n            return nullptr;\\n        ListNode* ptr1 = head;\\n        ListNode* ptr2 = head->next;\\n        ListNode* temp;\\n        while(ptr2 != nullptr){\\n            temp = ptr2->next;\\n            ptr2->next = ptr1;\\n            ptr1 = ptr2;\\n            ptr2 = temp; \\n        }\\n        return ptr1;\\n    }\\n};`\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "if(!head)\n       return nullptr;\n        ListNode*ptr1=head;\n        ListNode*ptr2=head->next;\n        ListNode*temp;\n      \n         ptr1->next=nullptr;\n       while(ptr2!=nullptr ){"
                    },
                    {
                        "username": "8oh8",
                        "content": "In previous examples (pascal\\'s triangle), the recursive relation was expressed mathematically as f(j,k) = f(j-1,k-1) + f(j-1,k)\\nwith base case being f(j-1,k) = 1 where j = 1 or j = k\\n\\nBut this linked list problem is different because it does not compute something.\\n\\nHow would you express the recursive relation?"
                    },
                    {
                        "username": "capdlx",
                        "content": "func reverseList(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlist := reverseList(head.Next)\\n\\thead.Next.Next = head\\n    head.Next=nil\\n\\treturn list\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/2249915/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "dude no solutions \\n"
                    },
                    {
                        "username": "Z3R0",
                        "content": "why am i getting error when i am simply trying to print(head.val)\\uD83E\\uDD72"
                    },
                    {
                        "username": "KostiaHoward",
                        "content": "Check that head is not null first. It\\'s the third test case."
                    },
                    {
                        "username": "alexfoto",
                        "content": "I\\'m trying to solve this using javascript. I understand how linked-lists and nodes work, but I am confused about how Leetcode is implementing them behind the scenes. Could anyone please provide a clear explanation of what the node/linked-list look like and how to access their \"val\" and \"next\" values.\\n\\nAs I\\'ve tried to solve this, I get frequent errors saying is cannot read a property of \"val\" or \"next\" on some node, and it\\'s just really throwing me off.\\n\\nAny help is greatly appreciated!"
                    },
                    {
                        "username": "Neeraj_svgh",
                        "content": "we shouldnt use val"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I don\\'t quite understand the example: \\ngive a head [1,2,6,3,4,5,6]\\nIn my understanding a head is a single node, how is it possible that the head has seven values? "
                    },
                    {
                        "username": "mujtabawaqas",
                        "content": "The head is the first node in a sequence of nodes, that point to the next node. The head doesn\\'t hold \"7\" values only its value and the address to the next node. The linked list is stored dynamically, so the head is the way to access the linked list."
                    },
                    {
                        "username": "chiradipcodes",
                        "content": "Easiest C++ Code:\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n           ListNode* forward=curr->next;\\n           curr->next=prev;\\n           prev=curr;\\n           curr=forward;\\n        }\\n        return prev;\\n    }\\n};"
                    },
                    {
                        "username": "shirshendhu",
                        "content": "We are advised to not post solutions on the discussions section."
                    },
                    {
                        "username": "Suresh_Vuppala",
                        "content": "C++ Reverse Linked List O(N) O(1) Simple Solution, Recursion and  Iterative.\\n**Leetcode 206. Reverse Linked List - Yellow Coding**\\nhttps://yellowcoding.com/leetcode-206-reverse-linked-list-2/\\n\\nCoding Interview made easy - Yellow Coding\\nPlease forward it to your friends.\\nhttps://t.me/YellowCoding"
                    }
                ]
            },
            {
                "id": 1786823,
                "content": [
                    {
                        "username": "sharankarchella",
                        "content": "This is my Python code explanation\n--------------------------\nTo Summarize , \nTwo Pointer Approach\nprev = Previous\ncurr = current\n------------------------------\nFirst Step\n------------------\nhead\n1----->2--->3\ncurr  \n        \nSecond step\n---------------------------------------------------\n\nNone--->1------------>2--->3\nprev-----curr\n\nThird step\n---------------------------\n                       \nNone<----------1--->2--->3\n prev ---------- curr\n\nFourth step\n---------------------------\n          \nNone<----------1<----2---->3\n----------------prev---curr\n\nFifth step\n---------------------------\n        \nNone<----------1<----2---->3\n-----------------------prev---curr\n\nSixth step\n---------------------------\nNone<----1<----2<----3<---None\n-------------------------prev---curr\n\n\nUnderstanding code:-\n\ntemp = curr.nxt  #While reversing Linked list curr.nxt link will be broken for that we are storing curr.nxt in temporary variable i.e temp = curr.nxt\nAnd We are linking our prev to curr.nxt as shown in third step\ncurr.nxt = prev\n\nprev = curr  #curr will be our prev\n\nSo, curr = curr.nxt  #Since we already linked Previous to curr.nxt \ncurr = temp  #temp will be our curr.nxt\n\nHope it helps you all :)\n--------------------------------"
                    },
                    {
                        "username": "Avi_007",
                        "content": "Thanks bro, for you detailed explanation.\\n It\\'s really help me to think clearly on my logic and implement it,\\nI was thinking in same line but could not able to reach to my final logic and it\\'s implementation. "
                    },
                    {
                        "username": "cagils",
                        "content": "1-line loop solution beating 99.7% using array deconstructed assignment in JS:\\n\\n```js\\nvar reverseList = function(head) {\\n    let prev = null;\\n    while (head) [head.next, prev, head] = [prev, head, head.next]\\n    return prev\\n};\\n```\\n\\nThe array to array deconstructed assignment can be expanded as:\\n\\n```js\\nlet temp = head.next\\nhead.next = prev\\nprev = head\\nhead = temp\\n```\\nUsing array deconstruction we can skip the temp variable.\\n\\n"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "No solutions..."
                    },
                    {
                        "username": "raularajuoliveira",
                        "content": "Hi\\nBased on the other posts in this discussion, I think I got a solution to the problem. However, when I test it I keep getting this weird error:  `=================================================================\\n==31==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000078 at pc 0x000000370e5d bp 0x7ffdcdaf7940 sp 0x7ffdcdaf7938`\\n\\nHere is my code:\\n\\n `class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head) \\n            return nullptr;\\n        ListNode* ptr1 = head;\\n        ListNode* ptr2 = head->next;\\n        ListNode* temp;\\n        while(ptr2 != nullptr){\\n            temp = ptr2->next;\\n            ptr2->next = ptr1;\\n            ptr1 = ptr2;\\n            ptr2 = temp; \\n        }\\n        return ptr1;\\n    }\\n};`\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "if(!head)\n       return nullptr;\n        ListNode*ptr1=head;\n        ListNode*ptr2=head->next;\n        ListNode*temp;\n      \n         ptr1->next=nullptr;\n       while(ptr2!=nullptr ){"
                    },
                    {
                        "username": "8oh8",
                        "content": "In previous examples (pascal\\'s triangle), the recursive relation was expressed mathematically as f(j,k) = f(j-1,k-1) + f(j-1,k)\\nwith base case being f(j-1,k) = 1 where j = 1 or j = k\\n\\nBut this linked list problem is different because it does not compute something.\\n\\nHow would you express the recursive relation?"
                    },
                    {
                        "username": "capdlx",
                        "content": "func reverseList(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlist := reverseList(head.Next)\\n\\thead.Next.Next = head\\n    head.Next=nil\\n\\treturn list\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/2249915/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "dude no solutions \\n"
                    },
                    {
                        "username": "Z3R0",
                        "content": "why am i getting error when i am simply trying to print(head.val)\\uD83E\\uDD72"
                    },
                    {
                        "username": "KostiaHoward",
                        "content": "Check that head is not null first. It\\'s the third test case."
                    },
                    {
                        "username": "alexfoto",
                        "content": "I\\'m trying to solve this using javascript. I understand how linked-lists and nodes work, but I am confused about how Leetcode is implementing them behind the scenes. Could anyone please provide a clear explanation of what the node/linked-list look like and how to access their \"val\" and \"next\" values.\\n\\nAs I\\'ve tried to solve this, I get frequent errors saying is cannot read a property of \"val\" or \"next\" on some node, and it\\'s just really throwing me off.\\n\\nAny help is greatly appreciated!"
                    },
                    {
                        "username": "Neeraj_svgh",
                        "content": "we shouldnt use val"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I don\\'t quite understand the example: \\ngive a head [1,2,6,3,4,5,6]\\nIn my understanding a head is a single node, how is it possible that the head has seven values? "
                    },
                    {
                        "username": "mujtabawaqas",
                        "content": "The head is the first node in a sequence of nodes, that point to the next node. The head doesn\\'t hold \"7\" values only its value and the address to the next node. The linked list is stored dynamically, so the head is the way to access the linked list."
                    },
                    {
                        "username": "chiradipcodes",
                        "content": "Easiest C++ Code:\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n           ListNode* forward=curr->next;\\n           curr->next=prev;\\n           prev=curr;\\n           curr=forward;\\n        }\\n        return prev;\\n    }\\n};"
                    },
                    {
                        "username": "shirshendhu",
                        "content": "We are advised to not post solutions on the discussions section."
                    },
                    {
                        "username": "Suresh_Vuppala",
                        "content": "C++ Reverse Linked List O(N) O(1) Simple Solution, Recursion and  Iterative.\\n**Leetcode 206. Reverse Linked List - Yellow Coding**\\nhttps://yellowcoding.com/leetcode-206-reverse-linked-list-2/\\n\\nCoding Interview made easy - Yellow Coding\\nPlease forward it to your friends.\\nhttps://t.me/YellowCoding"
                    }
                ]
            },
            {
                "id": 1574714,
                "content": [
                    {
                        "username": "sharankarchella",
                        "content": "This is my Python code explanation\n--------------------------\nTo Summarize , \nTwo Pointer Approach\nprev = Previous\ncurr = current\n------------------------------\nFirst Step\n------------------\nhead\n1----->2--->3\ncurr  \n        \nSecond step\n---------------------------------------------------\n\nNone--->1------------>2--->3\nprev-----curr\n\nThird step\n---------------------------\n                       \nNone<----------1--->2--->3\n prev ---------- curr\n\nFourth step\n---------------------------\n          \nNone<----------1<----2---->3\n----------------prev---curr\n\nFifth step\n---------------------------\n        \nNone<----------1<----2---->3\n-----------------------prev---curr\n\nSixth step\n---------------------------\nNone<----1<----2<----3<---None\n-------------------------prev---curr\n\n\nUnderstanding code:-\n\ntemp = curr.nxt  #While reversing Linked list curr.nxt link will be broken for that we are storing curr.nxt in temporary variable i.e temp = curr.nxt\nAnd We are linking our prev to curr.nxt as shown in third step\ncurr.nxt = prev\n\nprev = curr  #curr will be our prev\n\nSo, curr = curr.nxt  #Since we already linked Previous to curr.nxt \ncurr = temp  #temp will be our curr.nxt\n\nHope it helps you all :)\n--------------------------------"
                    },
                    {
                        "username": "Avi_007",
                        "content": "Thanks bro, for you detailed explanation.\\n It\\'s really help me to think clearly on my logic and implement it,\\nI was thinking in same line but could not able to reach to my final logic and it\\'s implementation. "
                    },
                    {
                        "username": "cagils",
                        "content": "1-line loop solution beating 99.7% using array deconstructed assignment in JS:\\n\\n```js\\nvar reverseList = function(head) {\\n    let prev = null;\\n    while (head) [head.next, prev, head] = [prev, head, head.next]\\n    return prev\\n};\\n```\\n\\nThe array to array deconstructed assignment can be expanded as:\\n\\n```js\\nlet temp = head.next\\nhead.next = prev\\nprev = head\\nhead = temp\\n```\\nUsing array deconstruction we can skip the temp variable.\\n\\n"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "No solutions..."
                    },
                    {
                        "username": "raularajuoliveira",
                        "content": "Hi\\nBased on the other posts in this discussion, I think I got a solution to the problem. However, when I test it I keep getting this weird error:  `=================================================================\\n==31==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000078 at pc 0x000000370e5d bp 0x7ffdcdaf7940 sp 0x7ffdcdaf7938`\\n\\nHere is my code:\\n\\n `class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head) \\n            return nullptr;\\n        ListNode* ptr1 = head;\\n        ListNode* ptr2 = head->next;\\n        ListNode* temp;\\n        while(ptr2 != nullptr){\\n            temp = ptr2->next;\\n            ptr2->next = ptr1;\\n            ptr1 = ptr2;\\n            ptr2 = temp; \\n        }\\n        return ptr1;\\n    }\\n};`\\n"
                    },
                    {
                        "username": "hacanand",
                        "content": "if(!head)\n       return nullptr;\n        ListNode*ptr1=head;\n        ListNode*ptr2=head->next;\n        ListNode*temp;\n      \n         ptr1->next=nullptr;\n       while(ptr2!=nullptr ){"
                    },
                    {
                        "username": "8oh8",
                        "content": "In previous examples (pascal\\'s triangle), the recursive relation was expressed mathematically as f(j,k) = f(j-1,k-1) + f(j-1,k)\\nwith base case being f(j-1,k) = 1 where j = 1 or j = k\\n\\nBut this linked list problem is different because it does not compute something.\\n\\nHow would you express the recursive relation?"
                    },
                    {
                        "username": "capdlx",
                        "content": "func reverseList(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlist := reverseList(head.Next)\\n\\thead.Next.Next = head\\n    head.Next=nil\\n\\treturn list\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/2249915/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "_akash_kukreti_73",
                        "content": "dude no solutions \\n"
                    },
                    {
                        "username": "Z3R0",
                        "content": "why am i getting error when i am simply trying to print(head.val)\\uD83E\\uDD72"
                    },
                    {
                        "username": "KostiaHoward",
                        "content": "Check that head is not null first. It\\'s the third test case."
                    },
                    {
                        "username": "alexfoto",
                        "content": "I\\'m trying to solve this using javascript. I understand how linked-lists and nodes work, but I am confused about how Leetcode is implementing them behind the scenes. Could anyone please provide a clear explanation of what the node/linked-list look like and how to access their \"val\" and \"next\" values.\\n\\nAs I\\'ve tried to solve this, I get frequent errors saying is cannot read a property of \"val\" or \"next\" on some node, and it\\'s just really throwing me off.\\n\\nAny help is greatly appreciated!"
                    },
                    {
                        "username": "Neeraj_svgh",
                        "content": "we shouldnt use val"
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I don\\'t quite understand the example: \\ngive a head [1,2,6,3,4,5,6]\\nIn my understanding a head is a single node, how is it possible that the head has seven values? "
                    },
                    {
                        "username": "mujtabawaqas",
                        "content": "The head is the first node in a sequence of nodes, that point to the next node. The head doesn\\'t hold \"7\" values only its value and the address to the next node. The linked list is stored dynamically, so the head is the way to access the linked list."
                    },
                    {
                        "username": "chiradipcodes",
                        "content": "Easiest C++ Code:\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n           ListNode* forward=curr->next;\\n           curr->next=prev;\\n           prev=curr;\\n           curr=forward;\\n        }\\n        return prev;\\n    }\\n};"
                    },
                    {
                        "username": "shirshendhu",
                        "content": "We are advised to not post solutions on the discussions section."
                    },
                    {
                        "username": "Suresh_Vuppala",
                        "content": "C++ Reverse Linked List O(N) O(1) Simple Solution, Recursion and  Iterative.\\n**Leetcode 206. Reverse Linked List - Yellow Coding**\\nhttps://yellowcoding.com/leetcode-206-reverse-linked-list-2/\\n\\nCoding Interview made easy - Yellow Coding\\nPlease forward it to your friends.\\nhttps://t.me/YellowCoding"
                    }
                ]
            },
            {
                "id": 2073351,
                "content": [
                    {
                        "username": "Aditya1647",
                        "content": "First problem after kunal kushwaha\\'s LL lecture xD\\n"
                    },
                    {
                        "username": "user9730QF",
                        "content": "Do we have to return the same object of the linkedlist or can we create a new object and return the new object with the values in reverse order?"
                    },
                    {
                        "username": "hellomyworld23",
                        "content": "In interviews, if we\\'re able to do the iterative approach, is that enough? Or will we need to implement the recursive approach as well? (Recursion is confusing to me.)"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "This is the important concept of Linked list.\\ni have two approach to reverse the list :\\n1- By using Recursion.\\n2- By using Iterative approach.\\n\\n# Approach\\nI will use here Iterative approach :\\n1- Initialize 3 pointers : previous, present and next.\\n2- At initial stage previous will point to null, Present point to head and Next will point to present.next;\\n3- At each move they will swap their value.\\n4- But keep in mind that when next move ahead then need to check NPE.\\n5- If present pointer will reach to end means point to null then previous pointer will point to last node (tail).\\n6- Then simply return previous node."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH- 2  | |   ITERATION  \\n\\nIn this approach instead of creating another linked and storing values in reverse order , here we are simply changing the position of the head to last element of linked list.\\n\\nWe can do the above said by simply changing the order of our linked list , i.e each node contains address of next node , but we will modify it now each node will contain address previos element , and we will update the head at last;\\n\\n1. We will create 3 pointer namely \\'prev\\' , \\'curr\\' and \\'forward\\' . \\n\\n2. Initialize prev with NULL, curr to 1st element of list and forward to next element of current i.e 2nd positon .\\n\\n3. Iteratre over the linked list with the help of curr until curr becomes NULL.\\n\\n4. During each iteration point the curr->next to prev element , (doing this we are pointing each node element to its previous node).\\n\\n5. Now update curr , so that curr now points next position i.e curr = forward , and also update \\'prev\\' so that \\'prev\\' also points to next position , i.e prev = curr.\\n\\n6. Note : during each iteration our forward is also updating , i.e forward = curr->next.\\n\\n7. After we come out of the loop our list is reveresed but \\'head\\' is still pointing to the 1st postion so update the head , i.e head = prev.\\n\\n8. return head, and you got your answer."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH-1   | |     BEGINNER FRIENDLY\\n   \\nAlthough this approach is not recomended but still , something is better then nothing.\\n1. Create an empty node . (this node will become 2nd linked list which will store the reverse elements.)\\n\\n2. Now traverse the original linked list and add each data of original linked list into our 2nd linked list at head positon . (If you don\\'t know how to add element at head position then I would recomend you to please study about operations on linked list.)\\n\\n3. While inserting elements at head position our 2nd linked list will become a reverse linked list automatically.  : )\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "I'm a beginner still solved it in just 3 min. Donno why feeling very happy  "
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Please help\\n\\nI cannot understand how to do it here. I know the logic, know how to work with linked lists.\\n\\nBut in this case - instead of just head - we have the whole list whish is kind of represented as an array of numbers. And nothing has val and next properties... "
                    },
                    {
                        "username": "rajat_171",
                        "content": "head of the list is given, you can traverse the head using that and accordingly change the links of each node using either recursion or iteration. \\nTRY TO DO THE LINKED LIST QUESTIONS BY DREWING THE LIST ON THE PAPER."
                    },
                    {
                        "username": "lengthOfUndefined",
                        "content": "This video will help you if you like to understand how the recursive solution works. https://www.youtube.com/watch?v=MRe3UsRadKw"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "60ms\\nBeats 34.07%of users with JavaScript\\nhow can it be better? "
                    }
                ]
            },
            {
                "id": 2065434,
                "content": [
                    {
                        "username": "Aditya1647",
                        "content": "First problem after kunal kushwaha\\'s LL lecture xD\\n"
                    },
                    {
                        "username": "user9730QF",
                        "content": "Do we have to return the same object of the linkedlist or can we create a new object and return the new object with the values in reverse order?"
                    },
                    {
                        "username": "hellomyworld23",
                        "content": "In interviews, if we\\'re able to do the iterative approach, is that enough? Or will we need to implement the recursive approach as well? (Recursion is confusing to me.)"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "This is the important concept of Linked list.\\ni have two approach to reverse the list :\\n1- By using Recursion.\\n2- By using Iterative approach.\\n\\n# Approach\\nI will use here Iterative approach :\\n1- Initialize 3 pointers : previous, present and next.\\n2- At initial stage previous will point to null, Present point to head and Next will point to present.next;\\n3- At each move they will swap their value.\\n4- But keep in mind that when next move ahead then need to check NPE.\\n5- If present pointer will reach to end means point to null then previous pointer will point to last node (tail).\\n6- Then simply return previous node."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH- 2  | |   ITERATION  \\n\\nIn this approach instead of creating another linked and storing values in reverse order , here we are simply changing the position of the head to last element of linked list.\\n\\nWe can do the above said by simply changing the order of our linked list , i.e each node contains address of next node , but we will modify it now each node will contain address previos element , and we will update the head at last;\\n\\n1. We will create 3 pointer namely \\'prev\\' , \\'curr\\' and \\'forward\\' . \\n\\n2. Initialize prev with NULL, curr to 1st element of list and forward to next element of current i.e 2nd positon .\\n\\n3. Iteratre over the linked list with the help of curr until curr becomes NULL.\\n\\n4. During each iteration point the curr->next to prev element , (doing this we are pointing each node element to its previous node).\\n\\n5. Now update curr , so that curr now points next position i.e curr = forward , and also update \\'prev\\' so that \\'prev\\' also points to next position , i.e prev = curr.\\n\\n6. Note : during each iteration our forward is also updating , i.e forward = curr->next.\\n\\n7. After we come out of the loop our list is reveresed but \\'head\\' is still pointing to the 1st postion so update the head , i.e head = prev.\\n\\n8. return head, and you got your answer."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH-1   | |     BEGINNER FRIENDLY\\n   \\nAlthough this approach is not recomended but still , something is better then nothing.\\n1. Create an empty node . (this node will become 2nd linked list which will store the reverse elements.)\\n\\n2. Now traverse the original linked list and add each data of original linked list into our 2nd linked list at head positon . (If you don\\'t know how to add element at head position then I would recomend you to please study about operations on linked list.)\\n\\n3. While inserting elements at head position our 2nd linked list will become a reverse linked list automatically.  : )\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "I'm a beginner still solved it in just 3 min. Donno why feeling very happy  "
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Please help\\n\\nI cannot understand how to do it here. I know the logic, know how to work with linked lists.\\n\\nBut in this case - instead of just head - we have the whole list whish is kind of represented as an array of numbers. And nothing has val and next properties... "
                    },
                    {
                        "username": "rajat_171",
                        "content": "head of the list is given, you can traverse the head using that and accordingly change the links of each node using either recursion or iteration. \\nTRY TO DO THE LINKED LIST QUESTIONS BY DREWING THE LIST ON THE PAPER."
                    },
                    {
                        "username": "lengthOfUndefined",
                        "content": "This video will help you if you like to understand how the recursive solution works. https://www.youtube.com/watch?v=MRe3UsRadKw"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "60ms\\nBeats 34.07%of users with JavaScript\\nhow can it be better? "
                    }
                ]
            },
            {
                "id": 2065072,
                "content": [
                    {
                        "username": "Aditya1647",
                        "content": "First problem after kunal kushwaha\\'s LL lecture xD\\n"
                    },
                    {
                        "username": "user9730QF",
                        "content": "Do we have to return the same object of the linkedlist or can we create a new object and return the new object with the values in reverse order?"
                    },
                    {
                        "username": "hellomyworld23",
                        "content": "In interviews, if we\\'re able to do the iterative approach, is that enough? Or will we need to implement the recursive approach as well? (Recursion is confusing to me.)"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "This is the important concept of Linked list.\\ni have two approach to reverse the list :\\n1- By using Recursion.\\n2- By using Iterative approach.\\n\\n# Approach\\nI will use here Iterative approach :\\n1- Initialize 3 pointers : previous, present and next.\\n2- At initial stage previous will point to null, Present point to head and Next will point to present.next;\\n3- At each move they will swap their value.\\n4- But keep in mind that when next move ahead then need to check NPE.\\n5- If present pointer will reach to end means point to null then previous pointer will point to last node (tail).\\n6- Then simply return previous node."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH- 2  | |   ITERATION  \\n\\nIn this approach instead of creating another linked and storing values in reverse order , here we are simply changing the position of the head to last element of linked list.\\n\\nWe can do the above said by simply changing the order of our linked list , i.e each node contains address of next node , but we will modify it now each node will contain address previos element , and we will update the head at last;\\n\\n1. We will create 3 pointer namely \\'prev\\' , \\'curr\\' and \\'forward\\' . \\n\\n2. Initialize prev with NULL, curr to 1st element of list and forward to next element of current i.e 2nd positon .\\n\\n3. Iteratre over the linked list with the help of curr until curr becomes NULL.\\n\\n4. During each iteration point the curr->next to prev element , (doing this we are pointing each node element to its previous node).\\n\\n5. Now update curr , so that curr now points next position i.e curr = forward , and also update \\'prev\\' so that \\'prev\\' also points to next position , i.e prev = curr.\\n\\n6. Note : during each iteration our forward is also updating , i.e forward = curr->next.\\n\\n7. After we come out of the loop our list is reveresed but \\'head\\' is still pointing to the 1st postion so update the head , i.e head = prev.\\n\\n8. return head, and you got your answer."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH-1   | |     BEGINNER FRIENDLY\\n   \\nAlthough this approach is not recomended but still , something is better then nothing.\\n1. Create an empty node . (this node will become 2nd linked list which will store the reverse elements.)\\n\\n2. Now traverse the original linked list and add each data of original linked list into our 2nd linked list at head positon . (If you don\\'t know how to add element at head position then I would recomend you to please study about operations on linked list.)\\n\\n3. While inserting elements at head position our 2nd linked list will become a reverse linked list automatically.  : )\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "I'm a beginner still solved it in just 3 min. Donno why feeling very happy  "
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Please help\\n\\nI cannot understand how to do it here. I know the logic, know how to work with linked lists.\\n\\nBut in this case - instead of just head - we have the whole list whish is kind of represented as an array of numbers. And nothing has val and next properties... "
                    },
                    {
                        "username": "rajat_171",
                        "content": "head of the list is given, you can traverse the head using that and accordingly change the links of each node using either recursion or iteration. \\nTRY TO DO THE LINKED LIST QUESTIONS BY DREWING THE LIST ON THE PAPER."
                    },
                    {
                        "username": "lengthOfUndefined",
                        "content": "This video will help you if you like to understand how the recursive solution works. https://www.youtube.com/watch?v=MRe3UsRadKw"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "60ms\\nBeats 34.07%of users with JavaScript\\nhow can it be better? "
                    }
                ]
            },
            {
                "id": 2043539,
                "content": [
                    {
                        "username": "Aditya1647",
                        "content": "First problem after kunal kushwaha\\'s LL lecture xD\\n"
                    },
                    {
                        "username": "user9730QF",
                        "content": "Do we have to return the same object of the linkedlist or can we create a new object and return the new object with the values in reverse order?"
                    },
                    {
                        "username": "hellomyworld23",
                        "content": "In interviews, if we\\'re able to do the iterative approach, is that enough? Or will we need to implement the recursive approach as well? (Recursion is confusing to me.)"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "This is the important concept of Linked list.\\ni have two approach to reverse the list :\\n1- By using Recursion.\\n2- By using Iterative approach.\\n\\n# Approach\\nI will use here Iterative approach :\\n1- Initialize 3 pointers : previous, present and next.\\n2- At initial stage previous will point to null, Present point to head and Next will point to present.next;\\n3- At each move they will swap their value.\\n4- But keep in mind that when next move ahead then need to check NPE.\\n5- If present pointer will reach to end means point to null then previous pointer will point to last node (tail).\\n6- Then simply return previous node."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH- 2  | |   ITERATION  \\n\\nIn this approach instead of creating another linked and storing values in reverse order , here we are simply changing the position of the head to last element of linked list.\\n\\nWe can do the above said by simply changing the order of our linked list , i.e each node contains address of next node , but we will modify it now each node will contain address previos element , and we will update the head at last;\\n\\n1. We will create 3 pointer namely \\'prev\\' , \\'curr\\' and \\'forward\\' . \\n\\n2. Initialize prev with NULL, curr to 1st element of list and forward to next element of current i.e 2nd positon .\\n\\n3. Iteratre over the linked list with the help of curr until curr becomes NULL.\\n\\n4. During each iteration point the curr->next to prev element , (doing this we are pointing each node element to its previous node).\\n\\n5. Now update curr , so that curr now points next position i.e curr = forward , and also update \\'prev\\' so that \\'prev\\' also points to next position , i.e prev = curr.\\n\\n6. Note : during each iteration our forward is also updating , i.e forward = curr->next.\\n\\n7. After we come out of the loop our list is reveresed but \\'head\\' is still pointing to the 1st postion so update the head , i.e head = prev.\\n\\n8. return head, and you got your answer."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH-1   | |     BEGINNER FRIENDLY\\n   \\nAlthough this approach is not recomended but still , something is better then nothing.\\n1. Create an empty node . (this node will become 2nd linked list which will store the reverse elements.)\\n\\n2. Now traverse the original linked list and add each data of original linked list into our 2nd linked list at head positon . (If you don\\'t know how to add element at head position then I would recomend you to please study about operations on linked list.)\\n\\n3. While inserting elements at head position our 2nd linked list will become a reverse linked list automatically.  : )\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "I'm a beginner still solved it in just 3 min. Donno why feeling very happy  "
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Please help\\n\\nI cannot understand how to do it here. I know the logic, know how to work with linked lists.\\n\\nBut in this case - instead of just head - we have the whole list whish is kind of represented as an array of numbers. And nothing has val and next properties... "
                    },
                    {
                        "username": "rajat_171",
                        "content": "head of the list is given, you can traverse the head using that and accordingly change the links of each node using either recursion or iteration. \\nTRY TO DO THE LINKED LIST QUESTIONS BY DREWING THE LIST ON THE PAPER."
                    },
                    {
                        "username": "lengthOfUndefined",
                        "content": "This video will help you if you like to understand how the recursive solution works. https://www.youtube.com/watch?v=MRe3UsRadKw"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "60ms\\nBeats 34.07%of users with JavaScript\\nhow can it be better? "
                    }
                ]
            },
            {
                "id": 2042457,
                "content": [
                    {
                        "username": "Aditya1647",
                        "content": "First problem after kunal kushwaha\\'s LL lecture xD\\n"
                    },
                    {
                        "username": "user9730QF",
                        "content": "Do we have to return the same object of the linkedlist or can we create a new object and return the new object with the values in reverse order?"
                    },
                    {
                        "username": "hellomyworld23",
                        "content": "In interviews, if we\\'re able to do the iterative approach, is that enough? Or will we need to implement the recursive approach as well? (Recursion is confusing to me.)"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "This is the important concept of Linked list.\\ni have two approach to reverse the list :\\n1- By using Recursion.\\n2- By using Iterative approach.\\n\\n# Approach\\nI will use here Iterative approach :\\n1- Initialize 3 pointers : previous, present and next.\\n2- At initial stage previous will point to null, Present point to head and Next will point to present.next;\\n3- At each move they will swap their value.\\n4- But keep in mind that when next move ahead then need to check NPE.\\n5- If present pointer will reach to end means point to null then previous pointer will point to last node (tail).\\n6- Then simply return previous node."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH- 2  | |   ITERATION  \\n\\nIn this approach instead of creating another linked and storing values in reverse order , here we are simply changing the position of the head to last element of linked list.\\n\\nWe can do the above said by simply changing the order of our linked list , i.e each node contains address of next node , but we will modify it now each node will contain address previos element , and we will update the head at last;\\n\\n1. We will create 3 pointer namely \\'prev\\' , \\'curr\\' and \\'forward\\' . \\n\\n2. Initialize prev with NULL, curr to 1st element of list and forward to next element of current i.e 2nd positon .\\n\\n3. Iteratre over the linked list with the help of curr until curr becomes NULL.\\n\\n4. During each iteration point the curr->next to prev element , (doing this we are pointing each node element to its previous node).\\n\\n5. Now update curr , so that curr now points next position i.e curr = forward , and also update \\'prev\\' so that \\'prev\\' also points to next position , i.e prev = curr.\\n\\n6. Note : during each iteration our forward is also updating , i.e forward = curr->next.\\n\\n7. After we come out of the loop our list is reveresed but \\'head\\' is still pointing to the 1st postion so update the head , i.e head = prev.\\n\\n8. return head, and you got your answer."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH-1   | |     BEGINNER FRIENDLY\\n   \\nAlthough this approach is not recomended but still , something is better then nothing.\\n1. Create an empty node . (this node will become 2nd linked list which will store the reverse elements.)\\n\\n2. Now traverse the original linked list and add each data of original linked list into our 2nd linked list at head positon . (If you don\\'t know how to add element at head position then I would recomend you to please study about operations on linked list.)\\n\\n3. While inserting elements at head position our 2nd linked list will become a reverse linked list automatically.  : )\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "I'm a beginner still solved it in just 3 min. Donno why feeling very happy  "
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Please help\\n\\nI cannot understand how to do it here. I know the logic, know how to work with linked lists.\\n\\nBut in this case - instead of just head - we have the whole list whish is kind of represented as an array of numbers. And nothing has val and next properties... "
                    },
                    {
                        "username": "rajat_171",
                        "content": "head of the list is given, you can traverse the head using that and accordingly change the links of each node using either recursion or iteration. \\nTRY TO DO THE LINKED LIST QUESTIONS BY DREWING THE LIST ON THE PAPER."
                    },
                    {
                        "username": "lengthOfUndefined",
                        "content": "This video will help you if you like to understand how the recursive solution works. https://www.youtube.com/watch?v=MRe3UsRadKw"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "60ms\\nBeats 34.07%of users with JavaScript\\nhow can it be better? "
                    }
                ]
            },
            {
                "id": 2042436,
                "content": [
                    {
                        "username": "Aditya1647",
                        "content": "First problem after kunal kushwaha\\'s LL lecture xD\\n"
                    },
                    {
                        "username": "user9730QF",
                        "content": "Do we have to return the same object of the linkedlist or can we create a new object and return the new object with the values in reverse order?"
                    },
                    {
                        "username": "hellomyworld23",
                        "content": "In interviews, if we\\'re able to do the iterative approach, is that enough? Or will we need to implement the recursive approach as well? (Recursion is confusing to me.)"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "This is the important concept of Linked list.\\ni have two approach to reverse the list :\\n1- By using Recursion.\\n2- By using Iterative approach.\\n\\n# Approach\\nI will use here Iterative approach :\\n1- Initialize 3 pointers : previous, present and next.\\n2- At initial stage previous will point to null, Present point to head and Next will point to present.next;\\n3- At each move they will swap their value.\\n4- But keep in mind that when next move ahead then need to check NPE.\\n5- If present pointer will reach to end means point to null then previous pointer will point to last node (tail).\\n6- Then simply return previous node."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH- 2  | |   ITERATION  \\n\\nIn this approach instead of creating another linked and storing values in reverse order , here we are simply changing the position of the head to last element of linked list.\\n\\nWe can do the above said by simply changing the order of our linked list , i.e each node contains address of next node , but we will modify it now each node will contain address previos element , and we will update the head at last;\\n\\n1. We will create 3 pointer namely \\'prev\\' , \\'curr\\' and \\'forward\\' . \\n\\n2. Initialize prev with NULL, curr to 1st element of list and forward to next element of current i.e 2nd positon .\\n\\n3. Iteratre over the linked list with the help of curr until curr becomes NULL.\\n\\n4. During each iteration point the curr->next to prev element , (doing this we are pointing each node element to its previous node).\\n\\n5. Now update curr , so that curr now points next position i.e curr = forward , and also update \\'prev\\' so that \\'prev\\' also points to next position , i.e prev = curr.\\n\\n6. Note : during each iteration our forward is also updating , i.e forward = curr->next.\\n\\n7. After we come out of the loop our list is reveresed but \\'head\\' is still pointing to the 1st postion so update the head , i.e head = prev.\\n\\n8. return head, and you got your answer."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH-1   | |     BEGINNER FRIENDLY\\n   \\nAlthough this approach is not recomended but still , something is better then nothing.\\n1. Create an empty node . (this node will become 2nd linked list which will store the reverse elements.)\\n\\n2. Now traverse the original linked list and add each data of original linked list into our 2nd linked list at head positon . (If you don\\'t know how to add element at head position then I would recomend you to please study about operations on linked list.)\\n\\n3. While inserting elements at head position our 2nd linked list will become a reverse linked list automatically.  : )\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "I'm a beginner still solved it in just 3 min. Donno why feeling very happy  "
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Please help\\n\\nI cannot understand how to do it here. I know the logic, know how to work with linked lists.\\n\\nBut in this case - instead of just head - we have the whole list whish is kind of represented as an array of numbers. And nothing has val and next properties... "
                    },
                    {
                        "username": "rajat_171",
                        "content": "head of the list is given, you can traverse the head using that and accordingly change the links of each node using either recursion or iteration. \\nTRY TO DO THE LINKED LIST QUESTIONS BY DREWING THE LIST ON THE PAPER."
                    },
                    {
                        "username": "lengthOfUndefined",
                        "content": "This video will help you if you like to understand how the recursive solution works. https://www.youtube.com/watch?v=MRe3UsRadKw"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "60ms\\nBeats 34.07%of users with JavaScript\\nhow can it be better? "
                    }
                ]
            },
            {
                "id": 2038292,
                "content": [
                    {
                        "username": "Aditya1647",
                        "content": "First problem after kunal kushwaha\\'s LL lecture xD\\n"
                    },
                    {
                        "username": "user9730QF",
                        "content": "Do we have to return the same object of the linkedlist or can we create a new object and return the new object with the values in reverse order?"
                    },
                    {
                        "username": "hellomyworld23",
                        "content": "In interviews, if we\\'re able to do the iterative approach, is that enough? Or will we need to implement the recursive approach as well? (Recursion is confusing to me.)"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "This is the important concept of Linked list.\\ni have two approach to reverse the list :\\n1- By using Recursion.\\n2- By using Iterative approach.\\n\\n# Approach\\nI will use here Iterative approach :\\n1- Initialize 3 pointers : previous, present and next.\\n2- At initial stage previous will point to null, Present point to head and Next will point to present.next;\\n3- At each move they will swap their value.\\n4- But keep in mind that when next move ahead then need to check NPE.\\n5- If present pointer will reach to end means point to null then previous pointer will point to last node (tail).\\n6- Then simply return previous node."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH- 2  | |   ITERATION  \\n\\nIn this approach instead of creating another linked and storing values in reverse order , here we are simply changing the position of the head to last element of linked list.\\n\\nWe can do the above said by simply changing the order of our linked list , i.e each node contains address of next node , but we will modify it now each node will contain address previos element , and we will update the head at last;\\n\\n1. We will create 3 pointer namely \\'prev\\' , \\'curr\\' and \\'forward\\' . \\n\\n2. Initialize prev with NULL, curr to 1st element of list and forward to next element of current i.e 2nd positon .\\n\\n3. Iteratre over the linked list with the help of curr until curr becomes NULL.\\n\\n4. During each iteration point the curr->next to prev element , (doing this we are pointing each node element to its previous node).\\n\\n5. Now update curr , so that curr now points next position i.e curr = forward , and also update \\'prev\\' so that \\'prev\\' also points to next position , i.e prev = curr.\\n\\n6. Note : during each iteration our forward is also updating , i.e forward = curr->next.\\n\\n7. After we come out of the loop our list is reveresed but \\'head\\' is still pointing to the 1st postion so update the head , i.e head = prev.\\n\\n8. return head, and you got your answer."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH-1   | |     BEGINNER FRIENDLY\\n   \\nAlthough this approach is not recomended but still , something is better then nothing.\\n1. Create an empty node . (this node will become 2nd linked list which will store the reverse elements.)\\n\\n2. Now traverse the original linked list and add each data of original linked list into our 2nd linked list at head positon . (If you don\\'t know how to add element at head position then I would recomend you to please study about operations on linked list.)\\n\\n3. While inserting elements at head position our 2nd linked list will become a reverse linked list automatically.  : )\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "I'm a beginner still solved it in just 3 min. Donno why feeling very happy  "
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Please help\\n\\nI cannot understand how to do it here. I know the logic, know how to work with linked lists.\\n\\nBut in this case - instead of just head - we have the whole list whish is kind of represented as an array of numbers. And nothing has val and next properties... "
                    },
                    {
                        "username": "rajat_171",
                        "content": "head of the list is given, you can traverse the head using that and accordingly change the links of each node using either recursion or iteration. \\nTRY TO DO THE LINKED LIST QUESTIONS BY DREWING THE LIST ON THE PAPER."
                    },
                    {
                        "username": "lengthOfUndefined",
                        "content": "This video will help you if you like to understand how the recursive solution works. https://www.youtube.com/watch?v=MRe3UsRadKw"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "60ms\\nBeats 34.07%of users with JavaScript\\nhow can it be better? "
                    }
                ]
            },
            {
                "id": 2035555,
                "content": [
                    {
                        "username": "Aditya1647",
                        "content": "First problem after kunal kushwaha\\'s LL lecture xD\\n"
                    },
                    {
                        "username": "user9730QF",
                        "content": "Do we have to return the same object of the linkedlist or can we create a new object and return the new object with the values in reverse order?"
                    },
                    {
                        "username": "hellomyworld23",
                        "content": "In interviews, if we\\'re able to do the iterative approach, is that enough? Or will we need to implement the recursive approach as well? (Recursion is confusing to me.)"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "This is the important concept of Linked list.\\ni have two approach to reverse the list :\\n1- By using Recursion.\\n2- By using Iterative approach.\\n\\n# Approach\\nI will use here Iterative approach :\\n1- Initialize 3 pointers : previous, present and next.\\n2- At initial stage previous will point to null, Present point to head and Next will point to present.next;\\n3- At each move they will swap their value.\\n4- But keep in mind that when next move ahead then need to check NPE.\\n5- If present pointer will reach to end means point to null then previous pointer will point to last node (tail).\\n6- Then simply return previous node."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH- 2  | |   ITERATION  \\n\\nIn this approach instead of creating another linked and storing values in reverse order , here we are simply changing the position of the head to last element of linked list.\\n\\nWe can do the above said by simply changing the order of our linked list , i.e each node contains address of next node , but we will modify it now each node will contain address previos element , and we will update the head at last;\\n\\n1. We will create 3 pointer namely \\'prev\\' , \\'curr\\' and \\'forward\\' . \\n\\n2. Initialize prev with NULL, curr to 1st element of list and forward to next element of current i.e 2nd positon .\\n\\n3. Iteratre over the linked list with the help of curr until curr becomes NULL.\\n\\n4. During each iteration point the curr->next to prev element , (doing this we are pointing each node element to its previous node).\\n\\n5. Now update curr , so that curr now points next position i.e curr = forward , and also update \\'prev\\' so that \\'prev\\' also points to next position , i.e prev = curr.\\n\\n6. Note : during each iteration our forward is also updating , i.e forward = curr->next.\\n\\n7. After we come out of the loop our list is reveresed but \\'head\\' is still pointing to the 1st postion so update the head , i.e head = prev.\\n\\n8. return head, and you got your answer."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH-1   | |     BEGINNER FRIENDLY\\n   \\nAlthough this approach is not recomended but still , something is better then nothing.\\n1. Create an empty node . (this node will become 2nd linked list which will store the reverse elements.)\\n\\n2. Now traverse the original linked list and add each data of original linked list into our 2nd linked list at head positon . (If you don\\'t know how to add element at head position then I would recomend you to please study about operations on linked list.)\\n\\n3. While inserting elements at head position our 2nd linked list will become a reverse linked list automatically.  : )\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "I'm a beginner still solved it in just 3 min. Donno why feeling very happy  "
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Please help\\n\\nI cannot understand how to do it here. I know the logic, know how to work with linked lists.\\n\\nBut in this case - instead of just head - we have the whole list whish is kind of represented as an array of numbers. And nothing has val and next properties... "
                    },
                    {
                        "username": "rajat_171",
                        "content": "head of the list is given, you can traverse the head using that and accordingly change the links of each node using either recursion or iteration. \\nTRY TO DO THE LINKED LIST QUESTIONS BY DREWING THE LIST ON THE PAPER."
                    },
                    {
                        "username": "lengthOfUndefined",
                        "content": "This video will help you if you like to understand how the recursive solution works. https://www.youtube.com/watch?v=MRe3UsRadKw"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "60ms\\nBeats 34.07%of users with JavaScript\\nhow can it be better? "
                    }
                ]
            },
            {
                "id": 2031525,
                "content": [
                    {
                        "username": "Aditya1647",
                        "content": "First problem after kunal kushwaha\\'s LL lecture xD\\n"
                    },
                    {
                        "username": "user9730QF",
                        "content": "Do we have to return the same object of the linkedlist or can we create a new object and return the new object with the values in reverse order?"
                    },
                    {
                        "username": "hellomyworld23",
                        "content": "In interviews, if we\\'re able to do the iterative approach, is that enough? Or will we need to implement the recursive approach as well? (Recursion is confusing to me.)"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "This is the important concept of Linked list.\\ni have two approach to reverse the list :\\n1- By using Recursion.\\n2- By using Iterative approach.\\n\\n# Approach\\nI will use here Iterative approach :\\n1- Initialize 3 pointers : previous, present and next.\\n2- At initial stage previous will point to null, Present point to head and Next will point to present.next;\\n3- At each move they will swap their value.\\n4- But keep in mind that when next move ahead then need to check NPE.\\n5- If present pointer will reach to end means point to null then previous pointer will point to last node (tail).\\n6- Then simply return previous node."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH- 2  | |   ITERATION  \\n\\nIn this approach instead of creating another linked and storing values in reverse order , here we are simply changing the position of the head to last element of linked list.\\n\\nWe can do the above said by simply changing the order of our linked list , i.e each node contains address of next node , but we will modify it now each node will contain address previos element , and we will update the head at last;\\n\\n1. We will create 3 pointer namely \\'prev\\' , \\'curr\\' and \\'forward\\' . \\n\\n2. Initialize prev with NULL, curr to 1st element of list and forward to next element of current i.e 2nd positon .\\n\\n3. Iteratre over the linked list with the help of curr until curr becomes NULL.\\n\\n4. During each iteration point the curr->next to prev element , (doing this we are pointing each node element to its previous node).\\n\\n5. Now update curr , so that curr now points next position i.e curr = forward , and also update \\'prev\\' so that \\'prev\\' also points to next position , i.e prev = curr.\\n\\n6. Note : during each iteration our forward is also updating , i.e forward = curr->next.\\n\\n7. After we come out of the loop our list is reveresed but \\'head\\' is still pointing to the 1st postion so update the head , i.e head = prev.\\n\\n8. return head, and you got your answer."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH-1   | |     BEGINNER FRIENDLY\\n   \\nAlthough this approach is not recomended but still , something is better then nothing.\\n1. Create an empty node . (this node will become 2nd linked list which will store the reverse elements.)\\n\\n2. Now traverse the original linked list and add each data of original linked list into our 2nd linked list at head positon . (If you don\\'t know how to add element at head position then I would recomend you to please study about operations on linked list.)\\n\\n3. While inserting elements at head position our 2nd linked list will become a reverse linked list automatically.  : )\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "I'm a beginner still solved it in just 3 min. Donno why feeling very happy  "
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Please help\\n\\nI cannot understand how to do it here. I know the logic, know how to work with linked lists.\\n\\nBut in this case - instead of just head - we have the whole list whish is kind of represented as an array of numbers. And nothing has val and next properties... "
                    },
                    {
                        "username": "rajat_171",
                        "content": "head of the list is given, you can traverse the head using that and accordingly change the links of each node using either recursion or iteration. \\nTRY TO DO THE LINKED LIST QUESTIONS BY DREWING THE LIST ON THE PAPER."
                    },
                    {
                        "username": "lengthOfUndefined",
                        "content": "This video will help you if you like to understand how the recursive solution works. https://www.youtube.com/watch?v=MRe3UsRadKw"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "60ms\\nBeats 34.07%of users with JavaScript\\nhow can it be better? "
                    }
                ]
            },
            {
                "id": 2024369,
                "content": [
                    {
                        "username": "Aditya1647",
                        "content": "First problem after kunal kushwaha\\'s LL lecture xD\\n"
                    },
                    {
                        "username": "user9730QF",
                        "content": "Do we have to return the same object of the linkedlist or can we create a new object and return the new object with the values in reverse order?"
                    },
                    {
                        "username": "hellomyworld23",
                        "content": "In interviews, if we\\'re able to do the iterative approach, is that enough? Or will we need to implement the recursive approach as well? (Recursion is confusing to me.)"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "This is the important concept of Linked list.\\ni have two approach to reverse the list :\\n1- By using Recursion.\\n2- By using Iterative approach.\\n\\n# Approach\\nI will use here Iterative approach :\\n1- Initialize 3 pointers : previous, present and next.\\n2- At initial stage previous will point to null, Present point to head and Next will point to present.next;\\n3- At each move they will swap their value.\\n4- But keep in mind that when next move ahead then need to check NPE.\\n5- If present pointer will reach to end means point to null then previous pointer will point to last node (tail).\\n6- Then simply return previous node."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH- 2  | |   ITERATION  \\n\\nIn this approach instead of creating another linked and storing values in reverse order , here we are simply changing the position of the head to last element of linked list.\\n\\nWe can do the above said by simply changing the order of our linked list , i.e each node contains address of next node , but we will modify it now each node will contain address previos element , and we will update the head at last;\\n\\n1. We will create 3 pointer namely \\'prev\\' , \\'curr\\' and \\'forward\\' . \\n\\n2. Initialize prev with NULL, curr to 1st element of list and forward to next element of current i.e 2nd positon .\\n\\n3. Iteratre over the linked list with the help of curr until curr becomes NULL.\\n\\n4. During each iteration point the curr->next to prev element , (doing this we are pointing each node element to its previous node).\\n\\n5. Now update curr , so that curr now points next position i.e curr = forward , and also update \\'prev\\' so that \\'prev\\' also points to next position , i.e prev = curr.\\n\\n6. Note : during each iteration our forward is also updating , i.e forward = curr->next.\\n\\n7. After we come out of the loop our list is reveresed but \\'head\\' is still pointing to the 1st postion so update the head , i.e head = prev.\\n\\n8. return head, and you got your answer."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH-1   | |     BEGINNER FRIENDLY\\n   \\nAlthough this approach is not recomended but still , something is better then nothing.\\n1. Create an empty node . (this node will become 2nd linked list which will store the reverse elements.)\\n\\n2. Now traverse the original linked list and add each data of original linked list into our 2nd linked list at head positon . (If you don\\'t know how to add element at head position then I would recomend you to please study about operations on linked list.)\\n\\n3. While inserting elements at head position our 2nd linked list will become a reverse linked list automatically.  : )\\n"
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "I'm a beginner still solved it in just 3 min. Donno why feeling very happy  "
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "Please help\\n\\nI cannot understand how to do it here. I know the logic, know how to work with linked lists.\\n\\nBut in this case - instead of just head - we have the whole list whish is kind of represented as an array of numbers. And nothing has val and next properties... "
                    },
                    {
                        "username": "rajat_171",
                        "content": "head of the list is given, you can traverse the head using that and accordingly change the links of each node using either recursion or iteration. \\nTRY TO DO THE LINKED LIST QUESTIONS BY DREWING THE LIST ON THE PAPER."
                    },
                    {
                        "username": "lengthOfUndefined",
                        "content": "This video will help you if you like to understand how the recursive solution works. https://www.youtube.com/watch?v=MRe3UsRadKw"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "60ms\\nBeats 34.07%of users with JavaScript\\nhow can it be better? "
                    }
                ]
            },
            {
                "id": 2007749,
                "content": [
                    {
                        "username": "Valyez",
                        "content": "I can\\'t figure out what the problem is with my solution. I have solved before the problem \"No. 876. Middle of the Linked List\" and used a loop \\nwhile(i.next != null) {\\n...\\n}\\nand everything worked. This time I get a NullPointerException: Cannot read field \"next\" because \"<local2>\" is null\\nWhy?"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Because its \\n`while (head != null)` or `while (i != null)` in your case. Because when i is null it does not have a next element and so you get  NullPointerException\\n"
                    },
                    {
                        "username": "arsen172317",
                        "content": "Hi guys, can anyone please explain to me what\\'s wrong with my solution, in webstorm it works well done.\\n\\n`var reverseList = function(head,y=0) {\\n    if (y !== Math.floor(head.length / 2)) {\\n        [head[y], head[head.length - 1 - y]] = [head[head.length - 1 - y], head[y]];\\n        // ++y;\\n        reverseList(head,y+1);\\n    }\\n    return head\\n};`"
                    },
                    {
                        "username": "arsen172317",
                        "content": "[@yassineseddaoui](/yassineseddaoui) \\nthanks.\\nbut if it linked list, then why in head is` Input: head = [1,2,3,4,5]"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "You misunderstood what a linked list is. It\\'s not an array. It\\'s just multiples Node object defined like this:\\n```\\n function ListNode(val, next) {\\n     this.val = (val===undefined ? 0 : val)\\n     this.next = (next===undefined ? null : next)\\n  }\\n```\\nAnd so you can\\'t just do head[y] or head.length. \\nIf you want to move in the linked list you have to do: \\n`head = head.next`  and so the head will become the next element. \\nEvery node object has next element and the last node in the list has `next = null`\\n"
                    },
                    {
                        "username": "sswp08",
                        "content": "ListNode* reverseList(ListNode* head)\\n{\\n    ListNode* prev = NULL;\\n    ListNode* curr = head;\\n    while (curr != NULL)\\n    {\\n        ListNode* next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;\\n}\\n\\nExplanation:\\n1.\\tThis function takes the head of a linked list as input and reverses the order of the nodes in the list. It does this by using three pointers: prev, curr, and next. \\n2.\\tInitially, prev is set to NULL and curr is set to the head of the list. The function then enters a loop that continues until curr becomes NULL, indicating that all nodes have been processed.\\n3.\\tInside the loop, the next pointer is used to store the next node in the original list. Then, the next pointer of the current node (curr->next) is set to prev, effectively reversing the link between the current node and its next node.\\n4.\\tAfter that, prev is updated to be the current node and curr is updated to be the next node (which was stored in the next pointer).\\n5.\\tOnce the loop ends, prev will be pointing to the last node in the original list, which is now the head of the reversed list. So, the function returns prev.\\n6.\\tOverall, this function reverses the order of the nodes in the linked list by modifying the next pointers of each node.\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Start at the head of the linked list and keep track of the previous node, the current node, and the next node. The next node is then assigned to the previous node, and the previous node is assigned to the current node. This process is repeated until the end of the linked list is reached, at which point the previous node becomes the new head of the reversed linked list"
                    },
                    {
                        "username": "ryandougc",
                        "content": "Am I the only one confused as to why if we\\'re working with linked lists, we can\\'t actually use linked list properties? Calling head.val or head.net doesn\\'t work. How am I supposed to solve this then?"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "head.val literally works... "
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "head.val and head.next works. If you want to move forward you can do :\n```\nwhile head: \n      head = head.next\n```"
                    },
                    {
                        "username": "checsm",
                        "content": "Does anyone understand why recursive solution runs slower, even though it has the same time complexity?"
                    },
                    {
                        "username": "checsm",
                        "content": "[@yassineseddaoui](/yassineseddaoui) hey! thanks so much for the response! really appreciate it."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "When using recursion the programs needs to call the function over and over. And every times it wants to execute that function, it needs to push the parameters of that function in the stack and also push the return address. This is why sometimes, recursion is slower than iteration. "
                    },
                    {
                        "username": "mng48301",
                        "content": "To anyone struggling, get used to drawing out and creating an algorithm to solve problems. It really helps to visualize and understand the process. "
                    },
                    {
                        "username": "codewithsk27",
                        "content": "Hey, can anyone please tell why the code below works perfectly in printing \"head -> val\" in line 10 but throws a runtime error for line 5.\\n\\nclass Solution {\\nvoid reverse (ListNode*& head, ListNode* curr, ListNode* prev) {\\n// base case\\nif(curr == NULL){\\nhead = prev;\\ncout << \"head -> data \" << head -> val << endl;\\nreturn;\\n}\\n// recursion\\ncout << \"head -> data \" << head -> val << endl;\\nreverse(head, curr -> next, curr);\\ncurr -> next = prev;\\n}\\npublic:\\nListNode* reverseList(ListNode* head) {\\nreverse(head, head, NULL);\\nreturn head;\\n}\\n};"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "Brev a \\'list\\' object, like the one Leetcode are giving as input, has no attribute \\'next\\'. How does this code even run?!"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "[@Magikarp1](/Magikarp1)  \n\n[1,2,3,4,5] is just to show the order but its not really a list. But if you want to run it in your own IDE, you create multiple nodes like so : \n\nl3 = ListNode(3, None)\nl2 = ListNode(2, l3)\nl1 = ListNode(1, l2)\nAnd this means that the List of Nodes looks like this: l1 -> l2 -> l3 \n\nAnd the head would be l1 \nsolution = Solution()\nsolution.reverseList(l1)"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "[@yassineseddaoui](/yassineseddaoui) But how does the leetcode IDE convert \"head = [1,2,3,4,5]\" into nodes with value and next attributes? If I were to run this in my own IDE, how can I get it to work?\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n def __init__(self, val=0, next=None):\\n     self.val = val\\n     self.next = next\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        return prev\\n\\n        ```"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Its not a traditional list. It\\'s a bunch of Object nodes \\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nand they have the attribute next. The next is pointing to the next node. "
                    },
                    {
                        "username": "Duggy",
                        "content": "I noticed a bug with the test casing.\n\nIn my solution (below), I get a bug if I allow the list_of_nodes to inherit the default value.  It looks like the code uses the solution prior as the list.\n\n```\ndef recursive_get_last_node(listNode: ListNode, list_of_node: list = []) -> list:\n    if listNode.next:\n        recursive_get_last_node(listNode.next, list_of_node)\n    list_of_node.append(listNode)\n    return list_of_node\n\nclass Solution:\n    def reverseList(self, head):\n        if not head:\n            return head\n        # list_of_nodes_reversed = recursive_get_last_node(head) # Problem is here!  If I do not specify empty array and allow default value, my code inherits list from first testcase run\n        list_of_nodes_reversed = recursive_get_last_node(head, [])  # <-- This Works\n        first_in_list = list_of_nodes_reversed[0]\n        sliding_node = first_in_list\n        # Wipe last node so we dont loop list\n        list_of_nodes_reversed[-1].next = None\n        for node in list_of_nodes_reversed[1:]:\n            sliding_node.next = node\n            sliding_node = node\n        return first_in_list\n```\n\nDoes anyone know why this behavior would be?"
                    }
                ]
            },
            {
                "id": 1987539,
                "content": [
                    {
                        "username": "Valyez",
                        "content": "I can\\'t figure out what the problem is with my solution. I have solved before the problem \"No. 876. Middle of the Linked List\" and used a loop \\nwhile(i.next != null) {\\n...\\n}\\nand everything worked. This time I get a NullPointerException: Cannot read field \"next\" because \"<local2>\" is null\\nWhy?"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Because its \\n`while (head != null)` or `while (i != null)` in your case. Because when i is null it does not have a next element and so you get  NullPointerException\\n"
                    },
                    {
                        "username": "arsen172317",
                        "content": "Hi guys, can anyone please explain to me what\\'s wrong with my solution, in webstorm it works well done.\\n\\n`var reverseList = function(head,y=0) {\\n    if (y !== Math.floor(head.length / 2)) {\\n        [head[y], head[head.length - 1 - y]] = [head[head.length - 1 - y], head[y]];\\n        // ++y;\\n        reverseList(head,y+1);\\n    }\\n    return head\\n};`"
                    },
                    {
                        "username": "arsen172317",
                        "content": "[@yassineseddaoui](/yassineseddaoui) \\nthanks.\\nbut if it linked list, then why in head is` Input: head = [1,2,3,4,5]"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "You misunderstood what a linked list is. It\\'s not an array. It\\'s just multiples Node object defined like this:\\n```\\n function ListNode(val, next) {\\n     this.val = (val===undefined ? 0 : val)\\n     this.next = (next===undefined ? null : next)\\n  }\\n```\\nAnd so you can\\'t just do head[y] or head.length. \\nIf you want to move in the linked list you have to do: \\n`head = head.next`  and so the head will become the next element. \\nEvery node object has next element and the last node in the list has `next = null`\\n"
                    },
                    {
                        "username": "sswp08",
                        "content": "ListNode* reverseList(ListNode* head)\\n{\\n    ListNode* prev = NULL;\\n    ListNode* curr = head;\\n    while (curr != NULL)\\n    {\\n        ListNode* next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;\\n}\\n\\nExplanation:\\n1.\\tThis function takes the head of a linked list as input and reverses the order of the nodes in the list. It does this by using three pointers: prev, curr, and next. \\n2.\\tInitially, prev is set to NULL and curr is set to the head of the list. The function then enters a loop that continues until curr becomes NULL, indicating that all nodes have been processed.\\n3.\\tInside the loop, the next pointer is used to store the next node in the original list. Then, the next pointer of the current node (curr->next) is set to prev, effectively reversing the link between the current node and its next node.\\n4.\\tAfter that, prev is updated to be the current node and curr is updated to be the next node (which was stored in the next pointer).\\n5.\\tOnce the loop ends, prev will be pointing to the last node in the original list, which is now the head of the reversed list. So, the function returns prev.\\n6.\\tOverall, this function reverses the order of the nodes in the linked list by modifying the next pointers of each node.\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Start at the head of the linked list and keep track of the previous node, the current node, and the next node. The next node is then assigned to the previous node, and the previous node is assigned to the current node. This process is repeated until the end of the linked list is reached, at which point the previous node becomes the new head of the reversed linked list"
                    },
                    {
                        "username": "ryandougc",
                        "content": "Am I the only one confused as to why if we\\'re working with linked lists, we can\\'t actually use linked list properties? Calling head.val or head.net doesn\\'t work. How am I supposed to solve this then?"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "head.val literally works... "
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "head.val and head.next works. If you want to move forward you can do :\n```\nwhile head: \n      head = head.next\n```"
                    },
                    {
                        "username": "checsm",
                        "content": "Does anyone understand why recursive solution runs slower, even though it has the same time complexity?"
                    },
                    {
                        "username": "checsm",
                        "content": "[@yassineseddaoui](/yassineseddaoui) hey! thanks so much for the response! really appreciate it."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "When using recursion the programs needs to call the function over and over. And every times it wants to execute that function, it needs to push the parameters of that function in the stack and also push the return address. This is why sometimes, recursion is slower than iteration. "
                    },
                    {
                        "username": "mng48301",
                        "content": "To anyone struggling, get used to drawing out and creating an algorithm to solve problems. It really helps to visualize and understand the process. "
                    },
                    {
                        "username": "codewithsk27",
                        "content": "Hey, can anyone please tell why the code below works perfectly in printing \"head -> val\" in line 10 but throws a runtime error for line 5.\\n\\nclass Solution {\\nvoid reverse (ListNode*& head, ListNode* curr, ListNode* prev) {\\n// base case\\nif(curr == NULL){\\nhead = prev;\\ncout << \"head -> data \" << head -> val << endl;\\nreturn;\\n}\\n// recursion\\ncout << \"head -> data \" << head -> val << endl;\\nreverse(head, curr -> next, curr);\\ncurr -> next = prev;\\n}\\npublic:\\nListNode* reverseList(ListNode* head) {\\nreverse(head, head, NULL);\\nreturn head;\\n}\\n};"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "Brev a \\'list\\' object, like the one Leetcode are giving as input, has no attribute \\'next\\'. How does this code even run?!"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "[@Magikarp1](/Magikarp1)  \n\n[1,2,3,4,5] is just to show the order but its not really a list. But if you want to run it in your own IDE, you create multiple nodes like so : \n\nl3 = ListNode(3, None)\nl2 = ListNode(2, l3)\nl1 = ListNode(1, l2)\nAnd this means that the List of Nodes looks like this: l1 -> l2 -> l3 \n\nAnd the head would be l1 \nsolution = Solution()\nsolution.reverseList(l1)"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "[@yassineseddaoui](/yassineseddaoui) But how does the leetcode IDE convert \"head = [1,2,3,4,5]\" into nodes with value and next attributes? If I were to run this in my own IDE, how can I get it to work?\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n def __init__(self, val=0, next=None):\\n     self.val = val\\n     self.next = next\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        return prev\\n\\n        ```"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Its not a traditional list. It\\'s a bunch of Object nodes \\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nand they have the attribute next. The next is pointing to the next node. "
                    },
                    {
                        "username": "Duggy",
                        "content": "I noticed a bug with the test casing.\n\nIn my solution (below), I get a bug if I allow the list_of_nodes to inherit the default value.  It looks like the code uses the solution prior as the list.\n\n```\ndef recursive_get_last_node(listNode: ListNode, list_of_node: list = []) -> list:\n    if listNode.next:\n        recursive_get_last_node(listNode.next, list_of_node)\n    list_of_node.append(listNode)\n    return list_of_node\n\nclass Solution:\n    def reverseList(self, head):\n        if not head:\n            return head\n        # list_of_nodes_reversed = recursive_get_last_node(head) # Problem is here!  If I do not specify empty array and allow default value, my code inherits list from first testcase run\n        list_of_nodes_reversed = recursive_get_last_node(head, [])  # <-- This Works\n        first_in_list = list_of_nodes_reversed[0]\n        sliding_node = first_in_list\n        # Wipe last node so we dont loop list\n        list_of_nodes_reversed[-1].next = None\n        for node in list_of_nodes_reversed[1:]:\n            sliding_node.next = node\n            sliding_node = node\n        return first_in_list\n```\n\nDoes anyone know why this behavior would be?"
                    }
                ]
            },
            {
                "id": 1981290,
                "content": [
                    {
                        "username": "Valyez",
                        "content": "I can\\'t figure out what the problem is with my solution. I have solved before the problem \"No. 876. Middle of the Linked List\" and used a loop \\nwhile(i.next != null) {\\n...\\n}\\nand everything worked. This time I get a NullPointerException: Cannot read field \"next\" because \"<local2>\" is null\\nWhy?"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Because its \\n`while (head != null)` or `while (i != null)` in your case. Because when i is null it does not have a next element and so you get  NullPointerException\\n"
                    },
                    {
                        "username": "arsen172317",
                        "content": "Hi guys, can anyone please explain to me what\\'s wrong with my solution, in webstorm it works well done.\\n\\n`var reverseList = function(head,y=0) {\\n    if (y !== Math.floor(head.length / 2)) {\\n        [head[y], head[head.length - 1 - y]] = [head[head.length - 1 - y], head[y]];\\n        // ++y;\\n        reverseList(head,y+1);\\n    }\\n    return head\\n};`"
                    },
                    {
                        "username": "arsen172317",
                        "content": "[@yassineseddaoui](/yassineseddaoui) \\nthanks.\\nbut if it linked list, then why in head is` Input: head = [1,2,3,4,5]"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "You misunderstood what a linked list is. It\\'s not an array. It\\'s just multiples Node object defined like this:\\n```\\n function ListNode(val, next) {\\n     this.val = (val===undefined ? 0 : val)\\n     this.next = (next===undefined ? null : next)\\n  }\\n```\\nAnd so you can\\'t just do head[y] or head.length. \\nIf you want to move in the linked list you have to do: \\n`head = head.next`  and so the head will become the next element. \\nEvery node object has next element and the last node in the list has `next = null`\\n"
                    },
                    {
                        "username": "sswp08",
                        "content": "ListNode* reverseList(ListNode* head)\\n{\\n    ListNode* prev = NULL;\\n    ListNode* curr = head;\\n    while (curr != NULL)\\n    {\\n        ListNode* next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;\\n}\\n\\nExplanation:\\n1.\\tThis function takes the head of a linked list as input and reverses the order of the nodes in the list. It does this by using three pointers: prev, curr, and next. \\n2.\\tInitially, prev is set to NULL and curr is set to the head of the list. The function then enters a loop that continues until curr becomes NULL, indicating that all nodes have been processed.\\n3.\\tInside the loop, the next pointer is used to store the next node in the original list. Then, the next pointer of the current node (curr->next) is set to prev, effectively reversing the link between the current node and its next node.\\n4.\\tAfter that, prev is updated to be the current node and curr is updated to be the next node (which was stored in the next pointer).\\n5.\\tOnce the loop ends, prev will be pointing to the last node in the original list, which is now the head of the reversed list. So, the function returns prev.\\n6.\\tOverall, this function reverses the order of the nodes in the linked list by modifying the next pointers of each node.\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Start at the head of the linked list and keep track of the previous node, the current node, and the next node. The next node is then assigned to the previous node, and the previous node is assigned to the current node. This process is repeated until the end of the linked list is reached, at which point the previous node becomes the new head of the reversed linked list"
                    },
                    {
                        "username": "ryandougc",
                        "content": "Am I the only one confused as to why if we\\'re working with linked lists, we can\\'t actually use linked list properties? Calling head.val or head.net doesn\\'t work. How am I supposed to solve this then?"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "head.val literally works... "
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "head.val and head.next works. If you want to move forward you can do :\n```\nwhile head: \n      head = head.next\n```"
                    },
                    {
                        "username": "checsm",
                        "content": "Does anyone understand why recursive solution runs slower, even though it has the same time complexity?"
                    },
                    {
                        "username": "checsm",
                        "content": "[@yassineseddaoui](/yassineseddaoui) hey! thanks so much for the response! really appreciate it."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "When using recursion the programs needs to call the function over and over. And every times it wants to execute that function, it needs to push the parameters of that function in the stack and also push the return address. This is why sometimes, recursion is slower than iteration. "
                    },
                    {
                        "username": "mng48301",
                        "content": "To anyone struggling, get used to drawing out and creating an algorithm to solve problems. It really helps to visualize and understand the process. "
                    },
                    {
                        "username": "codewithsk27",
                        "content": "Hey, can anyone please tell why the code below works perfectly in printing \"head -> val\" in line 10 but throws a runtime error for line 5.\\n\\nclass Solution {\\nvoid reverse (ListNode*& head, ListNode* curr, ListNode* prev) {\\n// base case\\nif(curr == NULL){\\nhead = prev;\\ncout << \"head -> data \" << head -> val << endl;\\nreturn;\\n}\\n// recursion\\ncout << \"head -> data \" << head -> val << endl;\\nreverse(head, curr -> next, curr);\\ncurr -> next = prev;\\n}\\npublic:\\nListNode* reverseList(ListNode* head) {\\nreverse(head, head, NULL);\\nreturn head;\\n}\\n};"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "Brev a \\'list\\' object, like the one Leetcode are giving as input, has no attribute \\'next\\'. How does this code even run?!"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "[@Magikarp1](/Magikarp1)  \n\n[1,2,3,4,5] is just to show the order but its not really a list. But if you want to run it in your own IDE, you create multiple nodes like so : \n\nl3 = ListNode(3, None)\nl2 = ListNode(2, l3)\nl1 = ListNode(1, l2)\nAnd this means that the List of Nodes looks like this: l1 -> l2 -> l3 \n\nAnd the head would be l1 \nsolution = Solution()\nsolution.reverseList(l1)"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "[@yassineseddaoui](/yassineseddaoui) But how does the leetcode IDE convert \"head = [1,2,3,4,5]\" into nodes with value and next attributes? If I were to run this in my own IDE, how can I get it to work?\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n def __init__(self, val=0, next=None):\\n     self.val = val\\n     self.next = next\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        return prev\\n\\n        ```"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Its not a traditional list. It\\'s a bunch of Object nodes \\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nand they have the attribute next. The next is pointing to the next node. "
                    },
                    {
                        "username": "Duggy",
                        "content": "I noticed a bug with the test casing.\n\nIn my solution (below), I get a bug if I allow the list_of_nodes to inherit the default value.  It looks like the code uses the solution prior as the list.\n\n```\ndef recursive_get_last_node(listNode: ListNode, list_of_node: list = []) -> list:\n    if listNode.next:\n        recursive_get_last_node(listNode.next, list_of_node)\n    list_of_node.append(listNode)\n    return list_of_node\n\nclass Solution:\n    def reverseList(self, head):\n        if not head:\n            return head\n        # list_of_nodes_reversed = recursive_get_last_node(head) # Problem is here!  If I do not specify empty array and allow default value, my code inherits list from first testcase run\n        list_of_nodes_reversed = recursive_get_last_node(head, [])  # <-- This Works\n        first_in_list = list_of_nodes_reversed[0]\n        sliding_node = first_in_list\n        # Wipe last node so we dont loop list\n        list_of_nodes_reversed[-1].next = None\n        for node in list_of_nodes_reversed[1:]:\n            sliding_node.next = node\n            sliding_node = node\n        return first_in_list\n```\n\nDoes anyone know why this behavior would be?"
                    }
                ]
            },
            {
                "id": 1978675,
                "content": [
                    {
                        "username": "Valyez",
                        "content": "I can\\'t figure out what the problem is with my solution. I have solved before the problem \"No. 876. Middle of the Linked List\" and used a loop \\nwhile(i.next != null) {\\n...\\n}\\nand everything worked. This time I get a NullPointerException: Cannot read field \"next\" because \"<local2>\" is null\\nWhy?"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Because its \\n`while (head != null)` or `while (i != null)` in your case. Because when i is null it does not have a next element and so you get  NullPointerException\\n"
                    },
                    {
                        "username": "arsen172317",
                        "content": "Hi guys, can anyone please explain to me what\\'s wrong with my solution, in webstorm it works well done.\\n\\n`var reverseList = function(head,y=0) {\\n    if (y !== Math.floor(head.length / 2)) {\\n        [head[y], head[head.length - 1 - y]] = [head[head.length - 1 - y], head[y]];\\n        // ++y;\\n        reverseList(head,y+1);\\n    }\\n    return head\\n};`"
                    },
                    {
                        "username": "arsen172317",
                        "content": "[@yassineseddaoui](/yassineseddaoui) \\nthanks.\\nbut if it linked list, then why in head is` Input: head = [1,2,3,4,5]"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "You misunderstood what a linked list is. It\\'s not an array. It\\'s just multiples Node object defined like this:\\n```\\n function ListNode(val, next) {\\n     this.val = (val===undefined ? 0 : val)\\n     this.next = (next===undefined ? null : next)\\n  }\\n```\\nAnd so you can\\'t just do head[y] or head.length. \\nIf you want to move in the linked list you have to do: \\n`head = head.next`  and so the head will become the next element. \\nEvery node object has next element and the last node in the list has `next = null`\\n"
                    },
                    {
                        "username": "sswp08",
                        "content": "ListNode* reverseList(ListNode* head)\\n{\\n    ListNode* prev = NULL;\\n    ListNode* curr = head;\\n    while (curr != NULL)\\n    {\\n        ListNode* next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;\\n}\\n\\nExplanation:\\n1.\\tThis function takes the head of a linked list as input and reverses the order of the nodes in the list. It does this by using three pointers: prev, curr, and next. \\n2.\\tInitially, prev is set to NULL and curr is set to the head of the list. The function then enters a loop that continues until curr becomes NULL, indicating that all nodes have been processed.\\n3.\\tInside the loop, the next pointer is used to store the next node in the original list. Then, the next pointer of the current node (curr->next) is set to prev, effectively reversing the link between the current node and its next node.\\n4.\\tAfter that, prev is updated to be the current node and curr is updated to be the next node (which was stored in the next pointer).\\n5.\\tOnce the loop ends, prev will be pointing to the last node in the original list, which is now the head of the reversed list. So, the function returns prev.\\n6.\\tOverall, this function reverses the order of the nodes in the linked list by modifying the next pointers of each node.\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Start at the head of the linked list and keep track of the previous node, the current node, and the next node. The next node is then assigned to the previous node, and the previous node is assigned to the current node. This process is repeated until the end of the linked list is reached, at which point the previous node becomes the new head of the reversed linked list"
                    },
                    {
                        "username": "ryandougc",
                        "content": "Am I the only one confused as to why if we\\'re working with linked lists, we can\\'t actually use linked list properties? Calling head.val or head.net doesn\\'t work. How am I supposed to solve this then?"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "head.val literally works... "
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "head.val and head.next works. If you want to move forward you can do :\n```\nwhile head: \n      head = head.next\n```"
                    },
                    {
                        "username": "checsm",
                        "content": "Does anyone understand why recursive solution runs slower, even though it has the same time complexity?"
                    },
                    {
                        "username": "checsm",
                        "content": "[@yassineseddaoui](/yassineseddaoui) hey! thanks so much for the response! really appreciate it."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "When using recursion the programs needs to call the function over and over. And every times it wants to execute that function, it needs to push the parameters of that function in the stack and also push the return address. This is why sometimes, recursion is slower than iteration. "
                    },
                    {
                        "username": "mng48301",
                        "content": "To anyone struggling, get used to drawing out and creating an algorithm to solve problems. It really helps to visualize and understand the process. "
                    },
                    {
                        "username": "codewithsk27",
                        "content": "Hey, can anyone please tell why the code below works perfectly in printing \"head -> val\" in line 10 but throws a runtime error for line 5.\\n\\nclass Solution {\\nvoid reverse (ListNode*& head, ListNode* curr, ListNode* prev) {\\n// base case\\nif(curr == NULL){\\nhead = prev;\\ncout << \"head -> data \" << head -> val << endl;\\nreturn;\\n}\\n// recursion\\ncout << \"head -> data \" << head -> val << endl;\\nreverse(head, curr -> next, curr);\\ncurr -> next = prev;\\n}\\npublic:\\nListNode* reverseList(ListNode* head) {\\nreverse(head, head, NULL);\\nreturn head;\\n}\\n};"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "Brev a \\'list\\' object, like the one Leetcode are giving as input, has no attribute \\'next\\'. How does this code even run?!"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "[@Magikarp1](/Magikarp1)  \n\n[1,2,3,4,5] is just to show the order but its not really a list. But if you want to run it in your own IDE, you create multiple nodes like so : \n\nl3 = ListNode(3, None)\nl2 = ListNode(2, l3)\nl1 = ListNode(1, l2)\nAnd this means that the List of Nodes looks like this: l1 -> l2 -> l3 \n\nAnd the head would be l1 \nsolution = Solution()\nsolution.reverseList(l1)"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "[@yassineseddaoui](/yassineseddaoui) But how does the leetcode IDE convert \"head = [1,2,3,4,5]\" into nodes with value and next attributes? If I were to run this in my own IDE, how can I get it to work?\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n def __init__(self, val=0, next=None):\\n     self.val = val\\n     self.next = next\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        return prev\\n\\n        ```"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Its not a traditional list. It\\'s a bunch of Object nodes \\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nand they have the attribute next. The next is pointing to the next node. "
                    },
                    {
                        "username": "Duggy",
                        "content": "I noticed a bug with the test casing.\n\nIn my solution (below), I get a bug if I allow the list_of_nodes to inherit the default value.  It looks like the code uses the solution prior as the list.\n\n```\ndef recursive_get_last_node(listNode: ListNode, list_of_node: list = []) -> list:\n    if listNode.next:\n        recursive_get_last_node(listNode.next, list_of_node)\n    list_of_node.append(listNode)\n    return list_of_node\n\nclass Solution:\n    def reverseList(self, head):\n        if not head:\n            return head\n        # list_of_nodes_reversed = recursive_get_last_node(head) # Problem is here!  If I do not specify empty array and allow default value, my code inherits list from first testcase run\n        list_of_nodes_reversed = recursive_get_last_node(head, [])  # <-- This Works\n        first_in_list = list_of_nodes_reversed[0]\n        sliding_node = first_in_list\n        # Wipe last node so we dont loop list\n        list_of_nodes_reversed[-1].next = None\n        for node in list_of_nodes_reversed[1:]:\n            sliding_node.next = node\n            sliding_node = node\n        return first_in_list\n```\n\nDoes anyone know why this behavior would be?"
                    }
                ]
            },
            {
                "id": 1977474,
                "content": [
                    {
                        "username": "Valyez",
                        "content": "I can\\'t figure out what the problem is with my solution. I have solved before the problem \"No. 876. Middle of the Linked List\" and used a loop \\nwhile(i.next != null) {\\n...\\n}\\nand everything worked. This time I get a NullPointerException: Cannot read field \"next\" because \"<local2>\" is null\\nWhy?"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Because its \\n`while (head != null)` or `while (i != null)` in your case. Because when i is null it does not have a next element and so you get  NullPointerException\\n"
                    },
                    {
                        "username": "arsen172317",
                        "content": "Hi guys, can anyone please explain to me what\\'s wrong with my solution, in webstorm it works well done.\\n\\n`var reverseList = function(head,y=0) {\\n    if (y !== Math.floor(head.length / 2)) {\\n        [head[y], head[head.length - 1 - y]] = [head[head.length - 1 - y], head[y]];\\n        // ++y;\\n        reverseList(head,y+1);\\n    }\\n    return head\\n};`"
                    },
                    {
                        "username": "arsen172317",
                        "content": "[@yassineseddaoui](/yassineseddaoui) \\nthanks.\\nbut if it linked list, then why in head is` Input: head = [1,2,3,4,5]"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "You misunderstood what a linked list is. It\\'s not an array. It\\'s just multiples Node object defined like this:\\n```\\n function ListNode(val, next) {\\n     this.val = (val===undefined ? 0 : val)\\n     this.next = (next===undefined ? null : next)\\n  }\\n```\\nAnd so you can\\'t just do head[y] or head.length. \\nIf you want to move in the linked list you have to do: \\n`head = head.next`  and so the head will become the next element. \\nEvery node object has next element and the last node in the list has `next = null`\\n"
                    },
                    {
                        "username": "sswp08",
                        "content": "ListNode* reverseList(ListNode* head)\\n{\\n    ListNode* prev = NULL;\\n    ListNode* curr = head;\\n    while (curr != NULL)\\n    {\\n        ListNode* next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;\\n}\\n\\nExplanation:\\n1.\\tThis function takes the head of a linked list as input and reverses the order of the nodes in the list. It does this by using three pointers: prev, curr, and next. \\n2.\\tInitially, prev is set to NULL and curr is set to the head of the list. The function then enters a loop that continues until curr becomes NULL, indicating that all nodes have been processed.\\n3.\\tInside the loop, the next pointer is used to store the next node in the original list. Then, the next pointer of the current node (curr->next) is set to prev, effectively reversing the link between the current node and its next node.\\n4.\\tAfter that, prev is updated to be the current node and curr is updated to be the next node (which was stored in the next pointer).\\n5.\\tOnce the loop ends, prev will be pointing to the last node in the original list, which is now the head of the reversed list. So, the function returns prev.\\n6.\\tOverall, this function reverses the order of the nodes in the linked list by modifying the next pointers of each node.\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Start at the head of the linked list and keep track of the previous node, the current node, and the next node. The next node is then assigned to the previous node, and the previous node is assigned to the current node. This process is repeated until the end of the linked list is reached, at which point the previous node becomes the new head of the reversed linked list"
                    },
                    {
                        "username": "ryandougc",
                        "content": "Am I the only one confused as to why if we\\'re working with linked lists, we can\\'t actually use linked list properties? Calling head.val or head.net doesn\\'t work. How am I supposed to solve this then?"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "head.val literally works... "
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "head.val and head.next works. If you want to move forward you can do :\n```\nwhile head: \n      head = head.next\n```"
                    },
                    {
                        "username": "checsm",
                        "content": "Does anyone understand why recursive solution runs slower, even though it has the same time complexity?"
                    },
                    {
                        "username": "checsm",
                        "content": "[@yassineseddaoui](/yassineseddaoui) hey! thanks so much for the response! really appreciate it."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "When using recursion the programs needs to call the function over and over. And every times it wants to execute that function, it needs to push the parameters of that function in the stack and also push the return address. This is why sometimes, recursion is slower than iteration. "
                    },
                    {
                        "username": "mng48301",
                        "content": "To anyone struggling, get used to drawing out and creating an algorithm to solve problems. It really helps to visualize and understand the process. "
                    },
                    {
                        "username": "codewithsk27",
                        "content": "Hey, can anyone please tell why the code below works perfectly in printing \"head -> val\" in line 10 but throws a runtime error for line 5.\\n\\nclass Solution {\\nvoid reverse (ListNode*& head, ListNode* curr, ListNode* prev) {\\n// base case\\nif(curr == NULL){\\nhead = prev;\\ncout << \"head -> data \" << head -> val << endl;\\nreturn;\\n}\\n// recursion\\ncout << \"head -> data \" << head -> val << endl;\\nreverse(head, curr -> next, curr);\\ncurr -> next = prev;\\n}\\npublic:\\nListNode* reverseList(ListNode* head) {\\nreverse(head, head, NULL);\\nreturn head;\\n}\\n};"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "Brev a \\'list\\' object, like the one Leetcode are giving as input, has no attribute \\'next\\'. How does this code even run?!"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "[@Magikarp1](/Magikarp1)  \n\n[1,2,3,4,5] is just to show the order but its not really a list. But if you want to run it in your own IDE, you create multiple nodes like so : \n\nl3 = ListNode(3, None)\nl2 = ListNode(2, l3)\nl1 = ListNode(1, l2)\nAnd this means that the List of Nodes looks like this: l1 -> l2 -> l3 \n\nAnd the head would be l1 \nsolution = Solution()\nsolution.reverseList(l1)"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "[@yassineseddaoui](/yassineseddaoui) But how does the leetcode IDE convert \"head = [1,2,3,4,5]\" into nodes with value and next attributes? If I were to run this in my own IDE, how can I get it to work?\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n def __init__(self, val=0, next=None):\\n     self.val = val\\n     self.next = next\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        return prev\\n\\n        ```"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Its not a traditional list. It\\'s a bunch of Object nodes \\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nand they have the attribute next. The next is pointing to the next node. "
                    },
                    {
                        "username": "Duggy",
                        "content": "I noticed a bug with the test casing.\n\nIn my solution (below), I get a bug if I allow the list_of_nodes to inherit the default value.  It looks like the code uses the solution prior as the list.\n\n```\ndef recursive_get_last_node(listNode: ListNode, list_of_node: list = []) -> list:\n    if listNode.next:\n        recursive_get_last_node(listNode.next, list_of_node)\n    list_of_node.append(listNode)\n    return list_of_node\n\nclass Solution:\n    def reverseList(self, head):\n        if not head:\n            return head\n        # list_of_nodes_reversed = recursive_get_last_node(head) # Problem is here!  If I do not specify empty array and allow default value, my code inherits list from first testcase run\n        list_of_nodes_reversed = recursive_get_last_node(head, [])  # <-- This Works\n        first_in_list = list_of_nodes_reversed[0]\n        sliding_node = first_in_list\n        # Wipe last node so we dont loop list\n        list_of_nodes_reversed[-1].next = None\n        for node in list_of_nodes_reversed[1:]:\n            sliding_node.next = node\n            sliding_node = node\n        return first_in_list\n```\n\nDoes anyone know why this behavior would be?"
                    }
                ]
            },
            {
                "id": 1975851,
                "content": [
                    {
                        "username": "Valyez",
                        "content": "I can\\'t figure out what the problem is with my solution. I have solved before the problem \"No. 876. Middle of the Linked List\" and used a loop \\nwhile(i.next != null) {\\n...\\n}\\nand everything worked. This time I get a NullPointerException: Cannot read field \"next\" because \"<local2>\" is null\\nWhy?"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Because its \\n`while (head != null)` or `while (i != null)` in your case. Because when i is null it does not have a next element and so you get  NullPointerException\\n"
                    },
                    {
                        "username": "arsen172317",
                        "content": "Hi guys, can anyone please explain to me what\\'s wrong with my solution, in webstorm it works well done.\\n\\n`var reverseList = function(head,y=0) {\\n    if (y !== Math.floor(head.length / 2)) {\\n        [head[y], head[head.length - 1 - y]] = [head[head.length - 1 - y], head[y]];\\n        // ++y;\\n        reverseList(head,y+1);\\n    }\\n    return head\\n};`"
                    },
                    {
                        "username": "arsen172317",
                        "content": "[@yassineseddaoui](/yassineseddaoui) \\nthanks.\\nbut if it linked list, then why in head is` Input: head = [1,2,3,4,5]"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "You misunderstood what a linked list is. It\\'s not an array. It\\'s just multiples Node object defined like this:\\n```\\n function ListNode(val, next) {\\n     this.val = (val===undefined ? 0 : val)\\n     this.next = (next===undefined ? null : next)\\n  }\\n```\\nAnd so you can\\'t just do head[y] or head.length. \\nIf you want to move in the linked list you have to do: \\n`head = head.next`  and so the head will become the next element. \\nEvery node object has next element and the last node in the list has `next = null`\\n"
                    },
                    {
                        "username": "sswp08",
                        "content": "ListNode* reverseList(ListNode* head)\\n{\\n    ListNode* prev = NULL;\\n    ListNode* curr = head;\\n    while (curr != NULL)\\n    {\\n        ListNode* next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;\\n}\\n\\nExplanation:\\n1.\\tThis function takes the head of a linked list as input and reverses the order of the nodes in the list. It does this by using three pointers: prev, curr, and next. \\n2.\\tInitially, prev is set to NULL and curr is set to the head of the list. The function then enters a loop that continues until curr becomes NULL, indicating that all nodes have been processed.\\n3.\\tInside the loop, the next pointer is used to store the next node in the original list. Then, the next pointer of the current node (curr->next) is set to prev, effectively reversing the link between the current node and its next node.\\n4.\\tAfter that, prev is updated to be the current node and curr is updated to be the next node (which was stored in the next pointer).\\n5.\\tOnce the loop ends, prev will be pointing to the last node in the original list, which is now the head of the reversed list. So, the function returns prev.\\n6.\\tOverall, this function reverses the order of the nodes in the linked list by modifying the next pointers of each node.\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Start at the head of the linked list and keep track of the previous node, the current node, and the next node. The next node is then assigned to the previous node, and the previous node is assigned to the current node. This process is repeated until the end of the linked list is reached, at which point the previous node becomes the new head of the reversed linked list"
                    },
                    {
                        "username": "ryandougc",
                        "content": "Am I the only one confused as to why if we\\'re working with linked lists, we can\\'t actually use linked list properties? Calling head.val or head.net doesn\\'t work. How am I supposed to solve this then?"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "head.val literally works... "
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "head.val and head.next works. If you want to move forward you can do :\n```\nwhile head: \n      head = head.next\n```"
                    },
                    {
                        "username": "checsm",
                        "content": "Does anyone understand why recursive solution runs slower, even though it has the same time complexity?"
                    },
                    {
                        "username": "checsm",
                        "content": "[@yassineseddaoui](/yassineseddaoui) hey! thanks so much for the response! really appreciate it."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "When using recursion the programs needs to call the function over and over. And every times it wants to execute that function, it needs to push the parameters of that function in the stack and also push the return address. This is why sometimes, recursion is slower than iteration. "
                    },
                    {
                        "username": "mng48301",
                        "content": "To anyone struggling, get used to drawing out and creating an algorithm to solve problems. It really helps to visualize and understand the process. "
                    },
                    {
                        "username": "codewithsk27",
                        "content": "Hey, can anyone please tell why the code below works perfectly in printing \"head -> val\" in line 10 but throws a runtime error for line 5.\\n\\nclass Solution {\\nvoid reverse (ListNode*& head, ListNode* curr, ListNode* prev) {\\n// base case\\nif(curr == NULL){\\nhead = prev;\\ncout << \"head -> data \" << head -> val << endl;\\nreturn;\\n}\\n// recursion\\ncout << \"head -> data \" << head -> val << endl;\\nreverse(head, curr -> next, curr);\\ncurr -> next = prev;\\n}\\npublic:\\nListNode* reverseList(ListNode* head) {\\nreverse(head, head, NULL);\\nreturn head;\\n}\\n};"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "Brev a \\'list\\' object, like the one Leetcode are giving as input, has no attribute \\'next\\'. How does this code even run?!"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "[@Magikarp1](/Magikarp1)  \n\n[1,2,3,4,5] is just to show the order but its not really a list. But if you want to run it in your own IDE, you create multiple nodes like so : \n\nl3 = ListNode(3, None)\nl2 = ListNode(2, l3)\nl1 = ListNode(1, l2)\nAnd this means that the List of Nodes looks like this: l1 -> l2 -> l3 \n\nAnd the head would be l1 \nsolution = Solution()\nsolution.reverseList(l1)"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "[@yassineseddaoui](/yassineseddaoui) But how does the leetcode IDE convert \"head = [1,2,3,4,5]\" into nodes with value and next attributes? If I were to run this in my own IDE, how can I get it to work?\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n def __init__(self, val=0, next=None):\\n     self.val = val\\n     self.next = next\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        return prev\\n\\n        ```"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Its not a traditional list. It\\'s a bunch of Object nodes \\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nand they have the attribute next. The next is pointing to the next node. "
                    },
                    {
                        "username": "Duggy",
                        "content": "I noticed a bug with the test casing.\n\nIn my solution (below), I get a bug if I allow the list_of_nodes to inherit the default value.  It looks like the code uses the solution prior as the list.\n\n```\ndef recursive_get_last_node(listNode: ListNode, list_of_node: list = []) -> list:\n    if listNode.next:\n        recursive_get_last_node(listNode.next, list_of_node)\n    list_of_node.append(listNode)\n    return list_of_node\n\nclass Solution:\n    def reverseList(self, head):\n        if not head:\n            return head\n        # list_of_nodes_reversed = recursive_get_last_node(head) # Problem is here!  If I do not specify empty array and allow default value, my code inherits list from first testcase run\n        list_of_nodes_reversed = recursive_get_last_node(head, [])  # <-- This Works\n        first_in_list = list_of_nodes_reversed[0]\n        sliding_node = first_in_list\n        # Wipe last node so we dont loop list\n        list_of_nodes_reversed[-1].next = None\n        for node in list_of_nodes_reversed[1:]:\n            sliding_node.next = node\n            sliding_node = node\n        return first_in_list\n```\n\nDoes anyone know why this behavior would be?"
                    }
                ]
            },
            {
                "id": 1968409,
                "content": [
                    {
                        "username": "Valyez",
                        "content": "I can\\'t figure out what the problem is with my solution. I have solved before the problem \"No. 876. Middle of the Linked List\" and used a loop \\nwhile(i.next != null) {\\n...\\n}\\nand everything worked. This time I get a NullPointerException: Cannot read field \"next\" because \"<local2>\" is null\\nWhy?"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Because its \\n`while (head != null)` or `while (i != null)` in your case. Because when i is null it does not have a next element and so you get  NullPointerException\\n"
                    },
                    {
                        "username": "arsen172317",
                        "content": "Hi guys, can anyone please explain to me what\\'s wrong with my solution, in webstorm it works well done.\\n\\n`var reverseList = function(head,y=0) {\\n    if (y !== Math.floor(head.length / 2)) {\\n        [head[y], head[head.length - 1 - y]] = [head[head.length - 1 - y], head[y]];\\n        // ++y;\\n        reverseList(head,y+1);\\n    }\\n    return head\\n};`"
                    },
                    {
                        "username": "arsen172317",
                        "content": "[@yassineseddaoui](/yassineseddaoui) \\nthanks.\\nbut if it linked list, then why in head is` Input: head = [1,2,3,4,5]"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "You misunderstood what a linked list is. It\\'s not an array. It\\'s just multiples Node object defined like this:\\n```\\n function ListNode(val, next) {\\n     this.val = (val===undefined ? 0 : val)\\n     this.next = (next===undefined ? null : next)\\n  }\\n```\\nAnd so you can\\'t just do head[y] or head.length. \\nIf you want to move in the linked list you have to do: \\n`head = head.next`  and so the head will become the next element. \\nEvery node object has next element and the last node in the list has `next = null`\\n"
                    },
                    {
                        "username": "sswp08",
                        "content": "ListNode* reverseList(ListNode* head)\\n{\\n    ListNode* prev = NULL;\\n    ListNode* curr = head;\\n    while (curr != NULL)\\n    {\\n        ListNode* next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;\\n}\\n\\nExplanation:\\n1.\\tThis function takes the head of a linked list as input and reverses the order of the nodes in the list. It does this by using three pointers: prev, curr, and next. \\n2.\\tInitially, prev is set to NULL and curr is set to the head of the list. The function then enters a loop that continues until curr becomes NULL, indicating that all nodes have been processed.\\n3.\\tInside the loop, the next pointer is used to store the next node in the original list. Then, the next pointer of the current node (curr->next) is set to prev, effectively reversing the link between the current node and its next node.\\n4.\\tAfter that, prev is updated to be the current node and curr is updated to be the next node (which was stored in the next pointer).\\n5.\\tOnce the loop ends, prev will be pointing to the last node in the original list, which is now the head of the reversed list. So, the function returns prev.\\n6.\\tOverall, this function reverses the order of the nodes in the linked list by modifying the next pointers of each node.\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Start at the head of the linked list and keep track of the previous node, the current node, and the next node. The next node is then assigned to the previous node, and the previous node is assigned to the current node. This process is repeated until the end of the linked list is reached, at which point the previous node becomes the new head of the reversed linked list"
                    },
                    {
                        "username": "ryandougc",
                        "content": "Am I the only one confused as to why if we\\'re working with linked lists, we can\\'t actually use linked list properties? Calling head.val or head.net doesn\\'t work. How am I supposed to solve this then?"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "head.val literally works... "
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "head.val and head.next works. If you want to move forward you can do :\n```\nwhile head: \n      head = head.next\n```"
                    },
                    {
                        "username": "checsm",
                        "content": "Does anyone understand why recursive solution runs slower, even though it has the same time complexity?"
                    },
                    {
                        "username": "checsm",
                        "content": "[@yassineseddaoui](/yassineseddaoui) hey! thanks so much for the response! really appreciate it."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "When using recursion the programs needs to call the function over and over. And every times it wants to execute that function, it needs to push the parameters of that function in the stack and also push the return address. This is why sometimes, recursion is slower than iteration. "
                    },
                    {
                        "username": "mng48301",
                        "content": "To anyone struggling, get used to drawing out and creating an algorithm to solve problems. It really helps to visualize and understand the process. "
                    },
                    {
                        "username": "codewithsk27",
                        "content": "Hey, can anyone please tell why the code below works perfectly in printing \"head -> val\" in line 10 but throws a runtime error for line 5.\\n\\nclass Solution {\\nvoid reverse (ListNode*& head, ListNode* curr, ListNode* prev) {\\n// base case\\nif(curr == NULL){\\nhead = prev;\\ncout << \"head -> data \" << head -> val << endl;\\nreturn;\\n}\\n// recursion\\ncout << \"head -> data \" << head -> val << endl;\\nreverse(head, curr -> next, curr);\\ncurr -> next = prev;\\n}\\npublic:\\nListNode* reverseList(ListNode* head) {\\nreverse(head, head, NULL);\\nreturn head;\\n}\\n};"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "Brev a \\'list\\' object, like the one Leetcode are giving as input, has no attribute \\'next\\'. How does this code even run?!"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "[@Magikarp1](/Magikarp1)  \n\n[1,2,3,4,5] is just to show the order but its not really a list. But if you want to run it in your own IDE, you create multiple nodes like so : \n\nl3 = ListNode(3, None)\nl2 = ListNode(2, l3)\nl1 = ListNode(1, l2)\nAnd this means that the List of Nodes looks like this: l1 -> l2 -> l3 \n\nAnd the head would be l1 \nsolution = Solution()\nsolution.reverseList(l1)"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "[@yassineseddaoui](/yassineseddaoui) But how does the leetcode IDE convert \"head = [1,2,3,4,5]\" into nodes with value and next attributes? If I were to run this in my own IDE, how can I get it to work?\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n def __init__(self, val=0, next=None):\\n     self.val = val\\n     self.next = next\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        return prev\\n\\n        ```"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Its not a traditional list. It\\'s a bunch of Object nodes \\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nand they have the attribute next. The next is pointing to the next node. "
                    },
                    {
                        "username": "Duggy",
                        "content": "I noticed a bug with the test casing.\n\nIn my solution (below), I get a bug if I allow the list_of_nodes to inherit the default value.  It looks like the code uses the solution prior as the list.\n\n```\ndef recursive_get_last_node(listNode: ListNode, list_of_node: list = []) -> list:\n    if listNode.next:\n        recursive_get_last_node(listNode.next, list_of_node)\n    list_of_node.append(listNode)\n    return list_of_node\n\nclass Solution:\n    def reverseList(self, head):\n        if not head:\n            return head\n        # list_of_nodes_reversed = recursive_get_last_node(head) # Problem is here!  If I do not specify empty array and allow default value, my code inherits list from first testcase run\n        list_of_nodes_reversed = recursive_get_last_node(head, [])  # <-- This Works\n        first_in_list = list_of_nodes_reversed[0]\n        sliding_node = first_in_list\n        # Wipe last node so we dont loop list\n        list_of_nodes_reversed[-1].next = None\n        for node in list_of_nodes_reversed[1:]:\n            sliding_node.next = node\n            sliding_node = node\n        return first_in_list\n```\n\nDoes anyone know why this behavior would be?"
                    }
                ]
            },
            {
                "id": 1959651,
                "content": [
                    {
                        "username": "Valyez",
                        "content": "I can\\'t figure out what the problem is with my solution. I have solved before the problem \"No. 876. Middle of the Linked List\" and used a loop \\nwhile(i.next != null) {\\n...\\n}\\nand everything worked. This time I get a NullPointerException: Cannot read field \"next\" because \"<local2>\" is null\\nWhy?"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Because its \\n`while (head != null)` or `while (i != null)` in your case. Because when i is null it does not have a next element and so you get  NullPointerException\\n"
                    },
                    {
                        "username": "arsen172317",
                        "content": "Hi guys, can anyone please explain to me what\\'s wrong with my solution, in webstorm it works well done.\\n\\n`var reverseList = function(head,y=0) {\\n    if (y !== Math.floor(head.length / 2)) {\\n        [head[y], head[head.length - 1 - y]] = [head[head.length - 1 - y], head[y]];\\n        // ++y;\\n        reverseList(head,y+1);\\n    }\\n    return head\\n};`"
                    },
                    {
                        "username": "arsen172317",
                        "content": "[@yassineseddaoui](/yassineseddaoui) \\nthanks.\\nbut if it linked list, then why in head is` Input: head = [1,2,3,4,5]"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "You misunderstood what a linked list is. It\\'s not an array. It\\'s just multiples Node object defined like this:\\n```\\n function ListNode(val, next) {\\n     this.val = (val===undefined ? 0 : val)\\n     this.next = (next===undefined ? null : next)\\n  }\\n```\\nAnd so you can\\'t just do head[y] or head.length. \\nIf you want to move in the linked list you have to do: \\n`head = head.next`  and so the head will become the next element. \\nEvery node object has next element and the last node in the list has `next = null`\\n"
                    },
                    {
                        "username": "sswp08",
                        "content": "ListNode* reverseList(ListNode* head)\\n{\\n    ListNode* prev = NULL;\\n    ListNode* curr = head;\\n    while (curr != NULL)\\n    {\\n        ListNode* next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;\\n}\\n\\nExplanation:\\n1.\\tThis function takes the head of a linked list as input and reverses the order of the nodes in the list. It does this by using three pointers: prev, curr, and next. \\n2.\\tInitially, prev is set to NULL and curr is set to the head of the list. The function then enters a loop that continues until curr becomes NULL, indicating that all nodes have been processed.\\n3.\\tInside the loop, the next pointer is used to store the next node in the original list. Then, the next pointer of the current node (curr->next) is set to prev, effectively reversing the link between the current node and its next node.\\n4.\\tAfter that, prev is updated to be the current node and curr is updated to be the next node (which was stored in the next pointer).\\n5.\\tOnce the loop ends, prev will be pointing to the last node in the original list, which is now the head of the reversed list. So, the function returns prev.\\n6.\\tOverall, this function reverses the order of the nodes in the linked list by modifying the next pointers of each node.\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Start at the head of the linked list and keep track of the previous node, the current node, and the next node. The next node is then assigned to the previous node, and the previous node is assigned to the current node. This process is repeated until the end of the linked list is reached, at which point the previous node becomes the new head of the reversed linked list"
                    },
                    {
                        "username": "ryandougc",
                        "content": "Am I the only one confused as to why if we\\'re working with linked lists, we can\\'t actually use linked list properties? Calling head.val or head.net doesn\\'t work. How am I supposed to solve this then?"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "head.val literally works... "
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "head.val and head.next works. If you want to move forward you can do :\n```\nwhile head: \n      head = head.next\n```"
                    },
                    {
                        "username": "checsm",
                        "content": "Does anyone understand why recursive solution runs slower, even though it has the same time complexity?"
                    },
                    {
                        "username": "checsm",
                        "content": "[@yassineseddaoui](/yassineseddaoui) hey! thanks so much for the response! really appreciate it."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "When using recursion the programs needs to call the function over and over. And every times it wants to execute that function, it needs to push the parameters of that function in the stack and also push the return address. This is why sometimes, recursion is slower than iteration. "
                    },
                    {
                        "username": "mng48301",
                        "content": "To anyone struggling, get used to drawing out and creating an algorithm to solve problems. It really helps to visualize and understand the process. "
                    },
                    {
                        "username": "codewithsk27",
                        "content": "Hey, can anyone please tell why the code below works perfectly in printing \"head -> val\" in line 10 but throws a runtime error for line 5.\\n\\nclass Solution {\\nvoid reverse (ListNode*& head, ListNode* curr, ListNode* prev) {\\n// base case\\nif(curr == NULL){\\nhead = prev;\\ncout << \"head -> data \" << head -> val << endl;\\nreturn;\\n}\\n// recursion\\ncout << \"head -> data \" << head -> val << endl;\\nreverse(head, curr -> next, curr);\\ncurr -> next = prev;\\n}\\npublic:\\nListNode* reverseList(ListNode* head) {\\nreverse(head, head, NULL);\\nreturn head;\\n}\\n};"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "Brev a \\'list\\' object, like the one Leetcode are giving as input, has no attribute \\'next\\'. How does this code even run?!"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "[@Magikarp1](/Magikarp1)  \n\n[1,2,3,4,5] is just to show the order but its not really a list. But if you want to run it in your own IDE, you create multiple nodes like so : \n\nl3 = ListNode(3, None)\nl2 = ListNode(2, l3)\nl1 = ListNode(1, l2)\nAnd this means that the List of Nodes looks like this: l1 -> l2 -> l3 \n\nAnd the head would be l1 \nsolution = Solution()\nsolution.reverseList(l1)"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "[@yassineseddaoui](/yassineseddaoui) But how does the leetcode IDE convert \"head = [1,2,3,4,5]\" into nodes with value and next attributes? If I were to run this in my own IDE, how can I get it to work?\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n def __init__(self, val=0, next=None):\\n     self.val = val\\n     self.next = next\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        return prev\\n\\n        ```"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Its not a traditional list. It\\'s a bunch of Object nodes \\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nand they have the attribute next. The next is pointing to the next node. "
                    },
                    {
                        "username": "Duggy",
                        "content": "I noticed a bug with the test casing.\n\nIn my solution (below), I get a bug if I allow the list_of_nodes to inherit the default value.  It looks like the code uses the solution prior as the list.\n\n```\ndef recursive_get_last_node(listNode: ListNode, list_of_node: list = []) -> list:\n    if listNode.next:\n        recursive_get_last_node(listNode.next, list_of_node)\n    list_of_node.append(listNode)\n    return list_of_node\n\nclass Solution:\n    def reverseList(self, head):\n        if not head:\n            return head\n        # list_of_nodes_reversed = recursive_get_last_node(head) # Problem is here!  If I do not specify empty array and allow default value, my code inherits list from first testcase run\n        list_of_nodes_reversed = recursive_get_last_node(head, [])  # <-- This Works\n        first_in_list = list_of_nodes_reversed[0]\n        sliding_node = first_in_list\n        # Wipe last node so we dont loop list\n        list_of_nodes_reversed[-1].next = None\n        for node in list_of_nodes_reversed[1:]:\n            sliding_node.next = node\n            sliding_node = node\n        return first_in_list\n```\n\nDoes anyone know why this behavior would be?"
                    }
                ]
            },
            {
                "id": 1955219,
                "content": [
                    {
                        "username": "Valyez",
                        "content": "I can\\'t figure out what the problem is with my solution. I have solved before the problem \"No. 876. Middle of the Linked List\" and used a loop \\nwhile(i.next != null) {\\n...\\n}\\nand everything worked. This time I get a NullPointerException: Cannot read field \"next\" because \"<local2>\" is null\\nWhy?"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Because its \\n`while (head != null)` or `while (i != null)` in your case. Because when i is null it does not have a next element and so you get  NullPointerException\\n"
                    },
                    {
                        "username": "arsen172317",
                        "content": "Hi guys, can anyone please explain to me what\\'s wrong with my solution, in webstorm it works well done.\\n\\n`var reverseList = function(head,y=0) {\\n    if (y !== Math.floor(head.length / 2)) {\\n        [head[y], head[head.length - 1 - y]] = [head[head.length - 1 - y], head[y]];\\n        // ++y;\\n        reverseList(head,y+1);\\n    }\\n    return head\\n};`"
                    },
                    {
                        "username": "arsen172317",
                        "content": "[@yassineseddaoui](/yassineseddaoui) \\nthanks.\\nbut if it linked list, then why in head is` Input: head = [1,2,3,4,5]"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "You misunderstood what a linked list is. It\\'s not an array. It\\'s just multiples Node object defined like this:\\n```\\n function ListNode(val, next) {\\n     this.val = (val===undefined ? 0 : val)\\n     this.next = (next===undefined ? null : next)\\n  }\\n```\\nAnd so you can\\'t just do head[y] or head.length. \\nIf you want to move in the linked list you have to do: \\n`head = head.next`  and so the head will become the next element. \\nEvery node object has next element and the last node in the list has `next = null`\\n"
                    },
                    {
                        "username": "sswp08",
                        "content": "ListNode* reverseList(ListNode* head)\\n{\\n    ListNode* prev = NULL;\\n    ListNode* curr = head;\\n    while (curr != NULL)\\n    {\\n        ListNode* next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;\\n}\\n\\nExplanation:\\n1.\\tThis function takes the head of a linked list as input and reverses the order of the nodes in the list. It does this by using three pointers: prev, curr, and next. \\n2.\\tInitially, prev is set to NULL and curr is set to the head of the list. The function then enters a loop that continues until curr becomes NULL, indicating that all nodes have been processed.\\n3.\\tInside the loop, the next pointer is used to store the next node in the original list. Then, the next pointer of the current node (curr->next) is set to prev, effectively reversing the link between the current node and its next node.\\n4.\\tAfter that, prev is updated to be the current node and curr is updated to be the next node (which was stored in the next pointer).\\n5.\\tOnce the loop ends, prev will be pointing to the last node in the original list, which is now the head of the reversed list. So, the function returns prev.\\n6.\\tOverall, this function reverses the order of the nodes in the linked list by modifying the next pointers of each node.\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Start at the head of the linked list and keep track of the previous node, the current node, and the next node. The next node is then assigned to the previous node, and the previous node is assigned to the current node. This process is repeated until the end of the linked list is reached, at which point the previous node becomes the new head of the reversed linked list"
                    },
                    {
                        "username": "ryandougc",
                        "content": "Am I the only one confused as to why if we\\'re working with linked lists, we can\\'t actually use linked list properties? Calling head.val or head.net doesn\\'t work. How am I supposed to solve this then?"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "head.val literally works... "
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "head.val and head.next works. If you want to move forward you can do :\n```\nwhile head: \n      head = head.next\n```"
                    },
                    {
                        "username": "checsm",
                        "content": "Does anyone understand why recursive solution runs slower, even though it has the same time complexity?"
                    },
                    {
                        "username": "checsm",
                        "content": "[@yassineseddaoui](/yassineseddaoui) hey! thanks so much for the response! really appreciate it."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "When using recursion the programs needs to call the function over and over. And every times it wants to execute that function, it needs to push the parameters of that function in the stack and also push the return address. This is why sometimes, recursion is slower than iteration. "
                    },
                    {
                        "username": "mng48301",
                        "content": "To anyone struggling, get used to drawing out and creating an algorithm to solve problems. It really helps to visualize and understand the process. "
                    },
                    {
                        "username": "codewithsk27",
                        "content": "Hey, can anyone please tell why the code below works perfectly in printing \"head -> val\" in line 10 but throws a runtime error for line 5.\\n\\nclass Solution {\\nvoid reverse (ListNode*& head, ListNode* curr, ListNode* prev) {\\n// base case\\nif(curr == NULL){\\nhead = prev;\\ncout << \"head -> data \" << head -> val << endl;\\nreturn;\\n}\\n// recursion\\ncout << \"head -> data \" << head -> val << endl;\\nreverse(head, curr -> next, curr);\\ncurr -> next = prev;\\n}\\npublic:\\nListNode* reverseList(ListNode* head) {\\nreverse(head, head, NULL);\\nreturn head;\\n}\\n};"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "Brev a \\'list\\' object, like the one Leetcode are giving as input, has no attribute \\'next\\'. How does this code even run?!"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "[@Magikarp1](/Magikarp1)  \n\n[1,2,3,4,5] is just to show the order but its not really a list. But if you want to run it in your own IDE, you create multiple nodes like so : \n\nl3 = ListNode(3, None)\nl2 = ListNode(2, l3)\nl1 = ListNode(1, l2)\nAnd this means that the List of Nodes looks like this: l1 -> l2 -> l3 \n\nAnd the head would be l1 \nsolution = Solution()\nsolution.reverseList(l1)"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "[@yassineseddaoui](/yassineseddaoui) But how does the leetcode IDE convert \"head = [1,2,3,4,5]\" into nodes with value and next attributes? If I were to run this in my own IDE, how can I get it to work?\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n def __init__(self, val=0, next=None):\\n     self.val = val\\n     self.next = next\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        return prev\\n\\n        ```"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Its not a traditional list. It\\'s a bunch of Object nodes \\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nand they have the attribute next. The next is pointing to the next node. "
                    },
                    {
                        "username": "Duggy",
                        "content": "I noticed a bug with the test casing.\n\nIn my solution (below), I get a bug if I allow the list_of_nodes to inherit the default value.  It looks like the code uses the solution prior as the list.\n\n```\ndef recursive_get_last_node(listNode: ListNode, list_of_node: list = []) -> list:\n    if listNode.next:\n        recursive_get_last_node(listNode.next, list_of_node)\n    list_of_node.append(listNode)\n    return list_of_node\n\nclass Solution:\n    def reverseList(self, head):\n        if not head:\n            return head\n        # list_of_nodes_reversed = recursive_get_last_node(head) # Problem is here!  If I do not specify empty array and allow default value, my code inherits list from first testcase run\n        list_of_nodes_reversed = recursive_get_last_node(head, [])  # <-- This Works\n        first_in_list = list_of_nodes_reversed[0]\n        sliding_node = first_in_list\n        # Wipe last node so we dont loop list\n        list_of_nodes_reversed[-1].next = None\n        for node in list_of_nodes_reversed[1:]:\n            sliding_node.next = node\n            sliding_node = node\n        return first_in_list\n```\n\nDoes anyone know why this behavior would be?"
                    }
                ]
            },
            {
                "id": 1953060,
                "content": [
                    {
                        "username": "Valyez",
                        "content": "I can\\'t figure out what the problem is with my solution. I have solved before the problem \"No. 876. Middle of the Linked List\" and used a loop \\nwhile(i.next != null) {\\n...\\n}\\nand everything worked. This time I get a NullPointerException: Cannot read field \"next\" because \"<local2>\" is null\\nWhy?"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Because its \\n`while (head != null)` or `while (i != null)` in your case. Because when i is null it does not have a next element and so you get  NullPointerException\\n"
                    },
                    {
                        "username": "arsen172317",
                        "content": "Hi guys, can anyone please explain to me what\\'s wrong with my solution, in webstorm it works well done.\\n\\n`var reverseList = function(head,y=0) {\\n    if (y !== Math.floor(head.length / 2)) {\\n        [head[y], head[head.length - 1 - y]] = [head[head.length - 1 - y], head[y]];\\n        // ++y;\\n        reverseList(head,y+1);\\n    }\\n    return head\\n};`"
                    },
                    {
                        "username": "arsen172317",
                        "content": "[@yassineseddaoui](/yassineseddaoui) \\nthanks.\\nbut if it linked list, then why in head is` Input: head = [1,2,3,4,5]"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "You misunderstood what a linked list is. It\\'s not an array. It\\'s just multiples Node object defined like this:\\n```\\n function ListNode(val, next) {\\n     this.val = (val===undefined ? 0 : val)\\n     this.next = (next===undefined ? null : next)\\n  }\\n```\\nAnd so you can\\'t just do head[y] or head.length. \\nIf you want to move in the linked list you have to do: \\n`head = head.next`  and so the head will become the next element. \\nEvery node object has next element and the last node in the list has `next = null`\\n"
                    },
                    {
                        "username": "sswp08",
                        "content": "ListNode* reverseList(ListNode* head)\\n{\\n    ListNode* prev = NULL;\\n    ListNode* curr = head;\\n    while (curr != NULL)\\n    {\\n        ListNode* next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;\\n}\\n\\nExplanation:\\n1.\\tThis function takes the head of a linked list as input and reverses the order of the nodes in the list. It does this by using three pointers: prev, curr, and next. \\n2.\\tInitially, prev is set to NULL and curr is set to the head of the list. The function then enters a loop that continues until curr becomes NULL, indicating that all nodes have been processed.\\n3.\\tInside the loop, the next pointer is used to store the next node in the original list. Then, the next pointer of the current node (curr->next) is set to prev, effectively reversing the link between the current node and its next node.\\n4.\\tAfter that, prev is updated to be the current node and curr is updated to be the next node (which was stored in the next pointer).\\n5.\\tOnce the loop ends, prev will be pointing to the last node in the original list, which is now the head of the reversed list. So, the function returns prev.\\n6.\\tOverall, this function reverses the order of the nodes in the linked list by modifying the next pointers of each node.\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Start at the head of the linked list and keep track of the previous node, the current node, and the next node. The next node is then assigned to the previous node, and the previous node is assigned to the current node. This process is repeated until the end of the linked list is reached, at which point the previous node becomes the new head of the reversed linked list"
                    },
                    {
                        "username": "ryandougc",
                        "content": "Am I the only one confused as to why if we\\'re working with linked lists, we can\\'t actually use linked list properties? Calling head.val or head.net doesn\\'t work. How am I supposed to solve this then?"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "head.val literally works... "
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "head.val and head.next works. If you want to move forward you can do :\n```\nwhile head: \n      head = head.next\n```"
                    },
                    {
                        "username": "checsm",
                        "content": "Does anyone understand why recursive solution runs slower, even though it has the same time complexity?"
                    },
                    {
                        "username": "checsm",
                        "content": "[@yassineseddaoui](/yassineseddaoui) hey! thanks so much for the response! really appreciate it."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "When using recursion the programs needs to call the function over and over. And every times it wants to execute that function, it needs to push the parameters of that function in the stack and also push the return address. This is why sometimes, recursion is slower than iteration. "
                    },
                    {
                        "username": "mng48301",
                        "content": "To anyone struggling, get used to drawing out and creating an algorithm to solve problems. It really helps to visualize and understand the process. "
                    },
                    {
                        "username": "codewithsk27",
                        "content": "Hey, can anyone please tell why the code below works perfectly in printing \"head -> val\" in line 10 but throws a runtime error for line 5.\\n\\nclass Solution {\\nvoid reverse (ListNode*& head, ListNode* curr, ListNode* prev) {\\n// base case\\nif(curr == NULL){\\nhead = prev;\\ncout << \"head -> data \" << head -> val << endl;\\nreturn;\\n}\\n// recursion\\ncout << \"head -> data \" << head -> val << endl;\\nreverse(head, curr -> next, curr);\\ncurr -> next = prev;\\n}\\npublic:\\nListNode* reverseList(ListNode* head) {\\nreverse(head, head, NULL);\\nreturn head;\\n}\\n};"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "Brev a \\'list\\' object, like the one Leetcode are giving as input, has no attribute \\'next\\'. How does this code even run?!"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "[@Magikarp1](/Magikarp1)  \n\n[1,2,3,4,5] is just to show the order but its not really a list. But if you want to run it in your own IDE, you create multiple nodes like so : \n\nl3 = ListNode(3, None)\nl2 = ListNode(2, l3)\nl1 = ListNode(1, l2)\nAnd this means that the List of Nodes looks like this: l1 -> l2 -> l3 \n\nAnd the head would be l1 \nsolution = Solution()\nsolution.reverseList(l1)"
                    },
                    {
                        "username": "Magikarp1",
                        "content": "[@yassineseddaoui](/yassineseddaoui) But how does the leetcode IDE convert \"head = [1,2,3,4,5]\" into nodes with value and next attributes? If I were to run this in my own IDE, how can I get it to work?\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n def __init__(self, val=0, next=None):\\n     self.val = val\\n     self.next = next\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        return prev\\n\\n        ```"
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "Its not a traditional list. It\\'s a bunch of Object nodes \\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nand they have the attribute next. The next is pointing to the next node. "
                    },
                    {
                        "username": "Duggy",
                        "content": "I noticed a bug with the test casing.\n\nIn my solution (below), I get a bug if I allow the list_of_nodes to inherit the default value.  It looks like the code uses the solution prior as the list.\n\n```\ndef recursive_get_last_node(listNode: ListNode, list_of_node: list = []) -> list:\n    if listNode.next:\n        recursive_get_last_node(listNode.next, list_of_node)\n    list_of_node.append(listNode)\n    return list_of_node\n\nclass Solution:\n    def reverseList(self, head):\n        if not head:\n            return head\n        # list_of_nodes_reversed = recursive_get_last_node(head) # Problem is here!  If I do not specify empty array and allow default value, my code inherits list from first testcase run\n        list_of_nodes_reversed = recursive_get_last_node(head, [])  # <-- This Works\n        first_in_list = list_of_nodes_reversed[0]\n        sliding_node = first_in_list\n        # Wipe last node so we dont loop list\n        list_of_nodes_reversed[-1].next = None\n        for node in list_of_nodes_reversed[1:]:\n            sliding_node.next = node\n            sliding_node = node\n        return first_in_list\n```\n\nDoes anyone know why this behavior would be?"
                    }
                ]
            },
            {
                "id": 1937700,
                "content": [
                    {
                        "username": "deki5",
                        "content": "Why doesn\\'t this recursive solution work in python 3 ?\\nIt keeps recursing even though we reached the base case at \\'return pointer\\'\\n ```\\nclass Solution:\\n\\n    def reverse(self,currpointer,nexthead):\\n        if not currpointer.next:\\n            print(\"final node\",currpointer.val)\\n            currpointer.next = nexthead\\n            print(\"NOW WE RETURN\")\\n            return currpointer\\n        else:\\n            print(f\"Currpointer = {currpointer.val}\")\\n            temp = currpointer.next\\n            print(\"temp val = \",temp.val)\\n            currpointer.next = nexthead\\n            return self.reverse(temp,currpointer)\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverse(head,None)```\\n\\n"
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand this part where output is assign as a new ListNode object, but then we return it at the end. Is it because tmp is a reference of output?\\n\\n` output = ListNode(0)\\n\\n        # Creates a temporary value for the list Node.\\n        tmp = output\\n\\n        for i in lst:\\n\\n            # Assign the list node object to the next value.\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n\\n        \\n        return output.next\\n`\\n"
                    },
                    {
                        "username": "samsagume",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nI am repeatedly getting this error.\nI ran the same code in VS-Code and it ran perfectly.\nI just want to know that is this error due to the LeetCode IDE or my code."
                    },
                    {
                        "username": "akshaydusad",
                        "content": "I can wrap my head around Linked Lists in Python"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "Can someone please explain why just returning head acts as returning whole linked list?\\nLike for example one : \\nI am just returning head [5] of reversed linked list [5, 4 ,3, 2, 1], so why is whole linked list being returned?"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "[@yassineseddaoui](/yassineseddaoui) I think i get it.Thanks for answering."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "returning the head acts as returning whole linked list because the head is pointing to another ListNode which is pointing to another ListNode etc. So if you have a linked list 1 -> 2 -> 3 you can only return the first node and from there you will be able to traverse the linked list. \\nDoes this answer your question?"
                    },
                    {
                        "username": "GamerBoy65",
                        "content": "Cant we use collections framework?"
                    },
                    {
                        "username": "myeong_ju",
                        "content": "Why do I keep getting this error?\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:26:21\\nSomeone plz help!!\\nHere\\'s my code in c++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        int cnt=1;\\n        ListNode* temp= head;\\n        ListNode* temp2;\\n        while(temp->next != NULL)\\n        {\\n            temp= temp->next; \\n            cnt++;\\n        } \\n        temp2= temp;\\n        for(int i=1; i<cnt; i++)\\n        {\\n            temp=head;\\n            while(temp->next->next!= NULL)\\n            {\\n                temp= temp->next;\\n            }\\n            \\n            temp->next->next= temp;\\n            temp->next= NULL;\\n        }\\n        return temp2;\\n    }\\n};"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "yes in some cases when your temp variable points to a nullptr or empty address that it is  doesnt have any node address , in that case if u try to access the attribute like val or next with that temp variable then it throws the error u have shown . \\nto avoid this use temp!=nullptr instead of temp->next!=nullptr in loops "
                    },
                    {
                        "username": "Tanisha36",
                        "content": "I have a doubt that in some linkedlist what is the difference between these two\\n\\ncurr=head\\ncurr=head=ListNode\\n\\nas in some question we use first method and in some the other one I am literally confuse between two\\nplease help me "
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "could u tell where u have seen the second one \\nas ListNode is a struct we cannot directly set curr to it we definitely take use of its members or by referencing it we can assign curr . pls correct if i\\'m wrong..."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Why am I getting error for the below code when I use `n->next = head;`\nbut not when I use `head->next->next = head;` aren't they supposed to be the same\n```\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n       if(!head || !(head->next))\n       {\n           return head;\n       }\n       ListNode* n = reverseList(head->next);\n       n->next = head;\n       head->next = NULL;\n       return n;\n    }\n};\n"
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s not an easy question unless you haven\\'t had an experience with linked lists"
                    }
                ]
            },
            {
                "id": 1937349,
                "content": [
                    {
                        "username": "deki5",
                        "content": "Why doesn\\'t this recursive solution work in python 3 ?\\nIt keeps recursing even though we reached the base case at \\'return pointer\\'\\n ```\\nclass Solution:\\n\\n    def reverse(self,currpointer,nexthead):\\n        if not currpointer.next:\\n            print(\"final node\",currpointer.val)\\n            currpointer.next = nexthead\\n            print(\"NOW WE RETURN\")\\n            return currpointer\\n        else:\\n            print(f\"Currpointer = {currpointer.val}\")\\n            temp = currpointer.next\\n            print(\"temp val = \",temp.val)\\n            currpointer.next = nexthead\\n            return self.reverse(temp,currpointer)\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverse(head,None)```\\n\\n"
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand this part where output is assign as a new ListNode object, but then we return it at the end. Is it because tmp is a reference of output?\\n\\n` output = ListNode(0)\\n\\n        # Creates a temporary value for the list Node.\\n        tmp = output\\n\\n        for i in lst:\\n\\n            # Assign the list node object to the next value.\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n\\n        \\n        return output.next\\n`\\n"
                    },
                    {
                        "username": "samsagume",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nI am repeatedly getting this error.\nI ran the same code in VS-Code and it ran perfectly.\nI just want to know that is this error due to the LeetCode IDE or my code."
                    },
                    {
                        "username": "akshaydusad",
                        "content": "I can wrap my head around Linked Lists in Python"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "Can someone please explain why just returning head acts as returning whole linked list?\\nLike for example one : \\nI am just returning head [5] of reversed linked list [5, 4 ,3, 2, 1], so why is whole linked list being returned?"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "[@yassineseddaoui](/yassineseddaoui) I think i get it.Thanks for answering."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "returning the head acts as returning whole linked list because the head is pointing to another ListNode which is pointing to another ListNode etc. So if you have a linked list 1 -> 2 -> 3 you can only return the first node and from there you will be able to traverse the linked list. \\nDoes this answer your question?"
                    },
                    {
                        "username": "GamerBoy65",
                        "content": "Cant we use collections framework?"
                    },
                    {
                        "username": "myeong_ju",
                        "content": "Why do I keep getting this error?\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:26:21\\nSomeone plz help!!\\nHere\\'s my code in c++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        int cnt=1;\\n        ListNode* temp= head;\\n        ListNode* temp2;\\n        while(temp->next != NULL)\\n        {\\n            temp= temp->next; \\n            cnt++;\\n        } \\n        temp2= temp;\\n        for(int i=1; i<cnt; i++)\\n        {\\n            temp=head;\\n            while(temp->next->next!= NULL)\\n            {\\n                temp= temp->next;\\n            }\\n            \\n            temp->next->next= temp;\\n            temp->next= NULL;\\n        }\\n        return temp2;\\n    }\\n};"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "yes in some cases when your temp variable points to a nullptr or empty address that it is  doesnt have any node address , in that case if u try to access the attribute like val or next with that temp variable then it throws the error u have shown . \\nto avoid this use temp!=nullptr instead of temp->next!=nullptr in loops "
                    },
                    {
                        "username": "Tanisha36",
                        "content": "I have a doubt that in some linkedlist what is the difference between these two\\n\\ncurr=head\\ncurr=head=ListNode\\n\\nas in some question we use first method and in some the other one I am literally confuse between two\\nplease help me "
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "could u tell where u have seen the second one \\nas ListNode is a struct we cannot directly set curr to it we definitely take use of its members or by referencing it we can assign curr . pls correct if i\\'m wrong..."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Why am I getting error for the below code when I use `n->next = head;`\nbut not when I use `head->next->next = head;` aren't they supposed to be the same\n```\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n       if(!head || !(head->next))\n       {\n           return head;\n       }\n       ListNode* n = reverseList(head->next);\n       n->next = head;\n       head->next = NULL;\n       return n;\n    }\n};\n"
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s not an easy question unless you haven\\'t had an experience with linked lists"
                    }
                ]
            },
            {
                "id": 1931004,
                "content": [
                    {
                        "username": "deki5",
                        "content": "Why doesn\\'t this recursive solution work in python 3 ?\\nIt keeps recursing even though we reached the base case at \\'return pointer\\'\\n ```\\nclass Solution:\\n\\n    def reverse(self,currpointer,nexthead):\\n        if not currpointer.next:\\n            print(\"final node\",currpointer.val)\\n            currpointer.next = nexthead\\n            print(\"NOW WE RETURN\")\\n            return currpointer\\n        else:\\n            print(f\"Currpointer = {currpointer.val}\")\\n            temp = currpointer.next\\n            print(\"temp val = \",temp.val)\\n            currpointer.next = nexthead\\n            return self.reverse(temp,currpointer)\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverse(head,None)```\\n\\n"
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand this part where output is assign as a new ListNode object, but then we return it at the end. Is it because tmp is a reference of output?\\n\\n` output = ListNode(0)\\n\\n        # Creates a temporary value for the list Node.\\n        tmp = output\\n\\n        for i in lst:\\n\\n            # Assign the list node object to the next value.\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n\\n        \\n        return output.next\\n`\\n"
                    },
                    {
                        "username": "samsagume",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nI am repeatedly getting this error.\nI ran the same code in VS-Code and it ran perfectly.\nI just want to know that is this error due to the LeetCode IDE or my code."
                    },
                    {
                        "username": "akshaydusad",
                        "content": "I can wrap my head around Linked Lists in Python"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "Can someone please explain why just returning head acts as returning whole linked list?\\nLike for example one : \\nI am just returning head [5] of reversed linked list [5, 4 ,3, 2, 1], so why is whole linked list being returned?"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "[@yassineseddaoui](/yassineseddaoui) I think i get it.Thanks for answering."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "returning the head acts as returning whole linked list because the head is pointing to another ListNode which is pointing to another ListNode etc. So if you have a linked list 1 -> 2 -> 3 you can only return the first node and from there you will be able to traverse the linked list. \\nDoes this answer your question?"
                    },
                    {
                        "username": "GamerBoy65",
                        "content": "Cant we use collections framework?"
                    },
                    {
                        "username": "myeong_ju",
                        "content": "Why do I keep getting this error?\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:26:21\\nSomeone plz help!!\\nHere\\'s my code in c++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        int cnt=1;\\n        ListNode* temp= head;\\n        ListNode* temp2;\\n        while(temp->next != NULL)\\n        {\\n            temp= temp->next; \\n            cnt++;\\n        } \\n        temp2= temp;\\n        for(int i=1; i<cnt; i++)\\n        {\\n            temp=head;\\n            while(temp->next->next!= NULL)\\n            {\\n                temp= temp->next;\\n            }\\n            \\n            temp->next->next= temp;\\n            temp->next= NULL;\\n        }\\n        return temp2;\\n    }\\n};"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "yes in some cases when your temp variable points to a nullptr or empty address that it is  doesnt have any node address , in that case if u try to access the attribute like val or next with that temp variable then it throws the error u have shown . \\nto avoid this use temp!=nullptr instead of temp->next!=nullptr in loops "
                    },
                    {
                        "username": "Tanisha36",
                        "content": "I have a doubt that in some linkedlist what is the difference between these two\\n\\ncurr=head\\ncurr=head=ListNode\\n\\nas in some question we use first method and in some the other one I am literally confuse between two\\nplease help me "
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "could u tell where u have seen the second one \\nas ListNode is a struct we cannot directly set curr to it we definitely take use of its members or by referencing it we can assign curr . pls correct if i\\'m wrong..."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Why am I getting error for the below code when I use `n->next = head;`\nbut not when I use `head->next->next = head;` aren't they supposed to be the same\n```\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n       if(!head || !(head->next))\n       {\n           return head;\n       }\n       ListNode* n = reverseList(head->next);\n       n->next = head;\n       head->next = NULL;\n       return n;\n    }\n};\n"
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s not an easy question unless you haven\\'t had an experience with linked lists"
                    }
                ]
            },
            {
                "id": 1929397,
                "content": [
                    {
                        "username": "deki5",
                        "content": "Why doesn\\'t this recursive solution work in python 3 ?\\nIt keeps recursing even though we reached the base case at \\'return pointer\\'\\n ```\\nclass Solution:\\n\\n    def reverse(self,currpointer,nexthead):\\n        if not currpointer.next:\\n            print(\"final node\",currpointer.val)\\n            currpointer.next = nexthead\\n            print(\"NOW WE RETURN\")\\n            return currpointer\\n        else:\\n            print(f\"Currpointer = {currpointer.val}\")\\n            temp = currpointer.next\\n            print(\"temp val = \",temp.val)\\n            currpointer.next = nexthead\\n            return self.reverse(temp,currpointer)\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverse(head,None)```\\n\\n"
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand this part where output is assign as a new ListNode object, but then we return it at the end. Is it because tmp is a reference of output?\\n\\n` output = ListNode(0)\\n\\n        # Creates a temporary value for the list Node.\\n        tmp = output\\n\\n        for i in lst:\\n\\n            # Assign the list node object to the next value.\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n\\n        \\n        return output.next\\n`\\n"
                    },
                    {
                        "username": "samsagume",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nI am repeatedly getting this error.\nI ran the same code in VS-Code and it ran perfectly.\nI just want to know that is this error due to the LeetCode IDE or my code."
                    },
                    {
                        "username": "akshaydusad",
                        "content": "I can wrap my head around Linked Lists in Python"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "Can someone please explain why just returning head acts as returning whole linked list?\\nLike for example one : \\nI am just returning head [5] of reversed linked list [5, 4 ,3, 2, 1], so why is whole linked list being returned?"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "[@yassineseddaoui](/yassineseddaoui) I think i get it.Thanks for answering."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "returning the head acts as returning whole linked list because the head is pointing to another ListNode which is pointing to another ListNode etc. So if you have a linked list 1 -> 2 -> 3 you can only return the first node and from there you will be able to traverse the linked list. \\nDoes this answer your question?"
                    },
                    {
                        "username": "GamerBoy65",
                        "content": "Cant we use collections framework?"
                    },
                    {
                        "username": "myeong_ju",
                        "content": "Why do I keep getting this error?\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:26:21\\nSomeone plz help!!\\nHere\\'s my code in c++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        int cnt=1;\\n        ListNode* temp= head;\\n        ListNode* temp2;\\n        while(temp->next != NULL)\\n        {\\n            temp= temp->next; \\n            cnt++;\\n        } \\n        temp2= temp;\\n        for(int i=1; i<cnt; i++)\\n        {\\n            temp=head;\\n            while(temp->next->next!= NULL)\\n            {\\n                temp= temp->next;\\n            }\\n            \\n            temp->next->next= temp;\\n            temp->next= NULL;\\n        }\\n        return temp2;\\n    }\\n};"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "yes in some cases when your temp variable points to a nullptr or empty address that it is  doesnt have any node address , in that case if u try to access the attribute like val or next with that temp variable then it throws the error u have shown . \\nto avoid this use temp!=nullptr instead of temp->next!=nullptr in loops "
                    },
                    {
                        "username": "Tanisha36",
                        "content": "I have a doubt that in some linkedlist what is the difference between these two\\n\\ncurr=head\\ncurr=head=ListNode\\n\\nas in some question we use first method and in some the other one I am literally confuse between two\\nplease help me "
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "could u tell where u have seen the second one \\nas ListNode is a struct we cannot directly set curr to it we definitely take use of its members or by referencing it we can assign curr . pls correct if i\\'m wrong..."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Why am I getting error for the below code when I use `n->next = head;`\nbut not when I use `head->next->next = head;` aren't they supposed to be the same\n```\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n       if(!head || !(head->next))\n       {\n           return head;\n       }\n       ListNode* n = reverseList(head->next);\n       n->next = head;\n       head->next = NULL;\n       return n;\n    }\n};\n"
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s not an easy question unless you haven\\'t had an experience with linked lists"
                    }
                ]
            },
            {
                "id": 1913373,
                "content": [
                    {
                        "username": "deki5",
                        "content": "Why doesn\\'t this recursive solution work in python 3 ?\\nIt keeps recursing even though we reached the base case at \\'return pointer\\'\\n ```\\nclass Solution:\\n\\n    def reverse(self,currpointer,nexthead):\\n        if not currpointer.next:\\n            print(\"final node\",currpointer.val)\\n            currpointer.next = nexthead\\n            print(\"NOW WE RETURN\")\\n            return currpointer\\n        else:\\n            print(f\"Currpointer = {currpointer.val}\")\\n            temp = currpointer.next\\n            print(\"temp val = \",temp.val)\\n            currpointer.next = nexthead\\n            return self.reverse(temp,currpointer)\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverse(head,None)```\\n\\n"
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand this part where output is assign as a new ListNode object, but then we return it at the end. Is it because tmp is a reference of output?\\n\\n` output = ListNode(0)\\n\\n        # Creates a temporary value for the list Node.\\n        tmp = output\\n\\n        for i in lst:\\n\\n            # Assign the list node object to the next value.\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n\\n        \\n        return output.next\\n`\\n"
                    },
                    {
                        "username": "samsagume",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nI am repeatedly getting this error.\nI ran the same code in VS-Code and it ran perfectly.\nI just want to know that is this error due to the LeetCode IDE or my code."
                    },
                    {
                        "username": "akshaydusad",
                        "content": "I can wrap my head around Linked Lists in Python"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "Can someone please explain why just returning head acts as returning whole linked list?\\nLike for example one : \\nI am just returning head [5] of reversed linked list [5, 4 ,3, 2, 1], so why is whole linked list being returned?"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "[@yassineseddaoui](/yassineseddaoui) I think i get it.Thanks for answering."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "returning the head acts as returning whole linked list because the head is pointing to another ListNode which is pointing to another ListNode etc. So if you have a linked list 1 -> 2 -> 3 you can only return the first node and from there you will be able to traverse the linked list. \\nDoes this answer your question?"
                    },
                    {
                        "username": "GamerBoy65",
                        "content": "Cant we use collections framework?"
                    },
                    {
                        "username": "myeong_ju",
                        "content": "Why do I keep getting this error?\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:26:21\\nSomeone plz help!!\\nHere\\'s my code in c++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        int cnt=1;\\n        ListNode* temp= head;\\n        ListNode* temp2;\\n        while(temp->next != NULL)\\n        {\\n            temp= temp->next; \\n            cnt++;\\n        } \\n        temp2= temp;\\n        for(int i=1; i<cnt; i++)\\n        {\\n            temp=head;\\n            while(temp->next->next!= NULL)\\n            {\\n                temp= temp->next;\\n            }\\n            \\n            temp->next->next= temp;\\n            temp->next= NULL;\\n        }\\n        return temp2;\\n    }\\n};"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "yes in some cases when your temp variable points to a nullptr or empty address that it is  doesnt have any node address , in that case if u try to access the attribute like val or next with that temp variable then it throws the error u have shown . \\nto avoid this use temp!=nullptr instead of temp->next!=nullptr in loops "
                    },
                    {
                        "username": "Tanisha36",
                        "content": "I have a doubt that in some linkedlist what is the difference between these two\\n\\ncurr=head\\ncurr=head=ListNode\\n\\nas in some question we use first method and in some the other one I am literally confuse between two\\nplease help me "
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "could u tell where u have seen the second one \\nas ListNode is a struct we cannot directly set curr to it we definitely take use of its members or by referencing it we can assign curr . pls correct if i\\'m wrong..."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Why am I getting error for the below code when I use `n->next = head;`\nbut not when I use `head->next->next = head;` aren't they supposed to be the same\n```\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n       if(!head || !(head->next))\n       {\n           return head;\n       }\n       ListNode* n = reverseList(head->next);\n       n->next = head;\n       head->next = NULL;\n       return n;\n    }\n};\n"
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s not an easy question unless you haven\\'t had an experience with linked lists"
                    }
                ]
            },
            {
                "id": 1912716,
                "content": [
                    {
                        "username": "deki5",
                        "content": "Why doesn\\'t this recursive solution work in python 3 ?\\nIt keeps recursing even though we reached the base case at \\'return pointer\\'\\n ```\\nclass Solution:\\n\\n    def reverse(self,currpointer,nexthead):\\n        if not currpointer.next:\\n            print(\"final node\",currpointer.val)\\n            currpointer.next = nexthead\\n            print(\"NOW WE RETURN\")\\n            return currpointer\\n        else:\\n            print(f\"Currpointer = {currpointer.val}\")\\n            temp = currpointer.next\\n            print(\"temp val = \",temp.val)\\n            currpointer.next = nexthead\\n            return self.reverse(temp,currpointer)\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverse(head,None)```\\n\\n"
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand this part where output is assign as a new ListNode object, but then we return it at the end. Is it because tmp is a reference of output?\\n\\n` output = ListNode(0)\\n\\n        # Creates a temporary value for the list Node.\\n        tmp = output\\n\\n        for i in lst:\\n\\n            # Assign the list node object to the next value.\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n\\n        \\n        return output.next\\n`\\n"
                    },
                    {
                        "username": "samsagume",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nI am repeatedly getting this error.\nI ran the same code in VS-Code and it ran perfectly.\nI just want to know that is this error due to the LeetCode IDE or my code."
                    },
                    {
                        "username": "akshaydusad",
                        "content": "I can wrap my head around Linked Lists in Python"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "Can someone please explain why just returning head acts as returning whole linked list?\\nLike for example one : \\nI am just returning head [5] of reversed linked list [5, 4 ,3, 2, 1], so why is whole linked list being returned?"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "[@yassineseddaoui](/yassineseddaoui) I think i get it.Thanks for answering."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "returning the head acts as returning whole linked list because the head is pointing to another ListNode which is pointing to another ListNode etc. So if you have a linked list 1 -> 2 -> 3 you can only return the first node and from there you will be able to traverse the linked list. \\nDoes this answer your question?"
                    },
                    {
                        "username": "GamerBoy65",
                        "content": "Cant we use collections framework?"
                    },
                    {
                        "username": "myeong_ju",
                        "content": "Why do I keep getting this error?\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:26:21\\nSomeone plz help!!\\nHere\\'s my code in c++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        int cnt=1;\\n        ListNode* temp= head;\\n        ListNode* temp2;\\n        while(temp->next != NULL)\\n        {\\n            temp= temp->next; \\n            cnt++;\\n        } \\n        temp2= temp;\\n        for(int i=1; i<cnt; i++)\\n        {\\n            temp=head;\\n            while(temp->next->next!= NULL)\\n            {\\n                temp= temp->next;\\n            }\\n            \\n            temp->next->next= temp;\\n            temp->next= NULL;\\n        }\\n        return temp2;\\n    }\\n};"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "yes in some cases when your temp variable points to a nullptr or empty address that it is  doesnt have any node address , in that case if u try to access the attribute like val or next with that temp variable then it throws the error u have shown . \\nto avoid this use temp!=nullptr instead of temp->next!=nullptr in loops "
                    },
                    {
                        "username": "Tanisha36",
                        "content": "I have a doubt that in some linkedlist what is the difference between these two\\n\\ncurr=head\\ncurr=head=ListNode\\n\\nas in some question we use first method and in some the other one I am literally confuse between two\\nplease help me "
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "could u tell where u have seen the second one \\nas ListNode is a struct we cannot directly set curr to it we definitely take use of its members or by referencing it we can assign curr . pls correct if i\\'m wrong..."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Why am I getting error for the below code when I use `n->next = head;`\nbut not when I use `head->next->next = head;` aren't they supposed to be the same\n```\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n       if(!head || !(head->next))\n       {\n           return head;\n       }\n       ListNode* n = reverseList(head->next);\n       n->next = head;\n       head->next = NULL;\n       return n;\n    }\n};\n"
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s not an easy question unless you haven\\'t had an experience with linked lists"
                    }
                ]
            },
            {
                "id": 1901376,
                "content": [
                    {
                        "username": "deki5",
                        "content": "Why doesn\\'t this recursive solution work in python 3 ?\\nIt keeps recursing even though we reached the base case at \\'return pointer\\'\\n ```\\nclass Solution:\\n\\n    def reverse(self,currpointer,nexthead):\\n        if not currpointer.next:\\n            print(\"final node\",currpointer.val)\\n            currpointer.next = nexthead\\n            print(\"NOW WE RETURN\")\\n            return currpointer\\n        else:\\n            print(f\"Currpointer = {currpointer.val}\")\\n            temp = currpointer.next\\n            print(\"temp val = \",temp.val)\\n            currpointer.next = nexthead\\n            return self.reverse(temp,currpointer)\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverse(head,None)```\\n\\n"
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand this part where output is assign as a new ListNode object, but then we return it at the end. Is it because tmp is a reference of output?\\n\\n` output = ListNode(0)\\n\\n        # Creates a temporary value for the list Node.\\n        tmp = output\\n\\n        for i in lst:\\n\\n            # Assign the list node object to the next value.\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n\\n        \\n        return output.next\\n`\\n"
                    },
                    {
                        "username": "samsagume",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nI am repeatedly getting this error.\nI ran the same code in VS-Code and it ran perfectly.\nI just want to know that is this error due to the LeetCode IDE or my code."
                    },
                    {
                        "username": "akshaydusad",
                        "content": "I can wrap my head around Linked Lists in Python"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "Can someone please explain why just returning head acts as returning whole linked list?\\nLike for example one : \\nI am just returning head [5] of reversed linked list [5, 4 ,3, 2, 1], so why is whole linked list being returned?"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "[@yassineseddaoui](/yassineseddaoui) I think i get it.Thanks for answering."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "returning the head acts as returning whole linked list because the head is pointing to another ListNode which is pointing to another ListNode etc. So if you have a linked list 1 -> 2 -> 3 you can only return the first node and from there you will be able to traverse the linked list. \\nDoes this answer your question?"
                    },
                    {
                        "username": "GamerBoy65",
                        "content": "Cant we use collections framework?"
                    },
                    {
                        "username": "myeong_ju",
                        "content": "Why do I keep getting this error?\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:26:21\\nSomeone plz help!!\\nHere\\'s my code in c++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        int cnt=1;\\n        ListNode* temp= head;\\n        ListNode* temp2;\\n        while(temp->next != NULL)\\n        {\\n            temp= temp->next; \\n            cnt++;\\n        } \\n        temp2= temp;\\n        for(int i=1; i<cnt; i++)\\n        {\\n            temp=head;\\n            while(temp->next->next!= NULL)\\n            {\\n                temp= temp->next;\\n            }\\n            \\n            temp->next->next= temp;\\n            temp->next= NULL;\\n        }\\n        return temp2;\\n    }\\n};"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "yes in some cases when your temp variable points to a nullptr or empty address that it is  doesnt have any node address , in that case if u try to access the attribute like val or next with that temp variable then it throws the error u have shown . \\nto avoid this use temp!=nullptr instead of temp->next!=nullptr in loops "
                    },
                    {
                        "username": "Tanisha36",
                        "content": "I have a doubt that in some linkedlist what is the difference between these two\\n\\ncurr=head\\ncurr=head=ListNode\\n\\nas in some question we use first method and in some the other one I am literally confuse between two\\nplease help me "
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "could u tell where u have seen the second one \\nas ListNode is a struct we cannot directly set curr to it we definitely take use of its members or by referencing it we can assign curr . pls correct if i\\'m wrong..."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Why am I getting error for the below code when I use `n->next = head;`\nbut not when I use `head->next->next = head;` aren't they supposed to be the same\n```\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n       if(!head || !(head->next))\n       {\n           return head;\n       }\n       ListNode* n = reverseList(head->next);\n       n->next = head;\n       head->next = NULL;\n       return n;\n    }\n};\n"
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s not an easy question unless you haven\\'t had an experience with linked lists"
                    }
                ]
            },
            {
                "id": 1898203,
                "content": [
                    {
                        "username": "deki5",
                        "content": "Why doesn\\'t this recursive solution work in python 3 ?\\nIt keeps recursing even though we reached the base case at \\'return pointer\\'\\n ```\\nclass Solution:\\n\\n    def reverse(self,currpointer,nexthead):\\n        if not currpointer.next:\\n            print(\"final node\",currpointer.val)\\n            currpointer.next = nexthead\\n            print(\"NOW WE RETURN\")\\n            return currpointer\\n        else:\\n            print(f\"Currpointer = {currpointer.val}\")\\n            temp = currpointer.next\\n            print(\"temp val = \",temp.val)\\n            currpointer.next = nexthead\\n            return self.reverse(temp,currpointer)\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverse(head,None)```\\n\\n"
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand this part where output is assign as a new ListNode object, but then we return it at the end. Is it because tmp is a reference of output?\\n\\n` output = ListNode(0)\\n\\n        # Creates a temporary value for the list Node.\\n        tmp = output\\n\\n        for i in lst:\\n\\n            # Assign the list node object to the next value.\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n\\n        \\n        return output.next\\n`\\n"
                    },
                    {
                        "username": "samsagume",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nI am repeatedly getting this error.\nI ran the same code in VS-Code and it ran perfectly.\nI just want to know that is this error due to the LeetCode IDE or my code."
                    },
                    {
                        "username": "akshaydusad",
                        "content": "I can wrap my head around Linked Lists in Python"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "Can someone please explain why just returning head acts as returning whole linked list?\\nLike for example one : \\nI am just returning head [5] of reversed linked list [5, 4 ,3, 2, 1], so why is whole linked list being returned?"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "[@yassineseddaoui](/yassineseddaoui) I think i get it.Thanks for answering."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "returning the head acts as returning whole linked list because the head is pointing to another ListNode which is pointing to another ListNode etc. So if you have a linked list 1 -> 2 -> 3 you can only return the first node and from there you will be able to traverse the linked list. \\nDoes this answer your question?"
                    },
                    {
                        "username": "GamerBoy65",
                        "content": "Cant we use collections framework?"
                    },
                    {
                        "username": "myeong_ju",
                        "content": "Why do I keep getting this error?\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:26:21\\nSomeone plz help!!\\nHere\\'s my code in c++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        int cnt=1;\\n        ListNode* temp= head;\\n        ListNode* temp2;\\n        while(temp->next != NULL)\\n        {\\n            temp= temp->next; \\n            cnt++;\\n        } \\n        temp2= temp;\\n        for(int i=1; i<cnt; i++)\\n        {\\n            temp=head;\\n            while(temp->next->next!= NULL)\\n            {\\n                temp= temp->next;\\n            }\\n            \\n            temp->next->next= temp;\\n            temp->next= NULL;\\n        }\\n        return temp2;\\n    }\\n};"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "yes in some cases when your temp variable points to a nullptr or empty address that it is  doesnt have any node address , in that case if u try to access the attribute like val or next with that temp variable then it throws the error u have shown . \\nto avoid this use temp!=nullptr instead of temp->next!=nullptr in loops "
                    },
                    {
                        "username": "Tanisha36",
                        "content": "I have a doubt that in some linkedlist what is the difference between these two\\n\\ncurr=head\\ncurr=head=ListNode\\n\\nas in some question we use first method and in some the other one I am literally confuse between two\\nplease help me "
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "could u tell where u have seen the second one \\nas ListNode is a struct we cannot directly set curr to it we definitely take use of its members or by referencing it we can assign curr . pls correct if i\\'m wrong..."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Why am I getting error for the below code when I use `n->next = head;`\nbut not when I use `head->next->next = head;` aren't they supposed to be the same\n```\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n       if(!head || !(head->next))\n       {\n           return head;\n       }\n       ListNode* n = reverseList(head->next);\n       n->next = head;\n       head->next = NULL;\n       return n;\n    }\n};\n"
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s not an easy question unless you haven\\'t had an experience with linked lists"
                    }
                ]
            },
            {
                "id": 1860316,
                "content": [
                    {
                        "username": "deki5",
                        "content": "Why doesn\\'t this recursive solution work in python 3 ?\\nIt keeps recursing even though we reached the base case at \\'return pointer\\'\\n ```\\nclass Solution:\\n\\n    def reverse(self,currpointer,nexthead):\\n        if not currpointer.next:\\n            print(\"final node\",currpointer.val)\\n            currpointer.next = nexthead\\n            print(\"NOW WE RETURN\")\\n            return currpointer\\n        else:\\n            print(f\"Currpointer = {currpointer.val}\")\\n            temp = currpointer.next\\n            print(\"temp val = \",temp.val)\\n            currpointer.next = nexthead\\n            return self.reverse(temp,currpointer)\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverse(head,None)```\\n\\n"
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand this part where output is assign as a new ListNode object, but then we return it at the end. Is it because tmp is a reference of output?\\n\\n` output = ListNode(0)\\n\\n        # Creates a temporary value for the list Node.\\n        tmp = output\\n\\n        for i in lst:\\n\\n            # Assign the list node object to the next value.\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n\\n        \\n        return output.next\\n`\\n"
                    },
                    {
                        "username": "samsagume",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nI am repeatedly getting this error.\nI ran the same code in VS-Code and it ran perfectly.\nI just want to know that is this error due to the LeetCode IDE or my code."
                    },
                    {
                        "username": "akshaydusad",
                        "content": "I can wrap my head around Linked Lists in Python"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "Can someone please explain why just returning head acts as returning whole linked list?\\nLike for example one : \\nI am just returning head [5] of reversed linked list [5, 4 ,3, 2, 1], so why is whole linked list being returned?"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "[@yassineseddaoui](/yassineseddaoui) I think i get it.Thanks for answering."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "returning the head acts as returning whole linked list because the head is pointing to another ListNode which is pointing to another ListNode etc. So if you have a linked list 1 -> 2 -> 3 you can only return the first node and from there you will be able to traverse the linked list. \\nDoes this answer your question?"
                    },
                    {
                        "username": "GamerBoy65",
                        "content": "Cant we use collections framework?"
                    },
                    {
                        "username": "myeong_ju",
                        "content": "Why do I keep getting this error?\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:26:21\\nSomeone plz help!!\\nHere\\'s my code in c++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        int cnt=1;\\n        ListNode* temp= head;\\n        ListNode* temp2;\\n        while(temp->next != NULL)\\n        {\\n            temp= temp->next; \\n            cnt++;\\n        } \\n        temp2= temp;\\n        for(int i=1; i<cnt; i++)\\n        {\\n            temp=head;\\n            while(temp->next->next!= NULL)\\n            {\\n                temp= temp->next;\\n            }\\n            \\n            temp->next->next= temp;\\n            temp->next= NULL;\\n        }\\n        return temp2;\\n    }\\n};"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "yes in some cases when your temp variable points to a nullptr or empty address that it is  doesnt have any node address , in that case if u try to access the attribute like val or next with that temp variable then it throws the error u have shown . \\nto avoid this use temp!=nullptr instead of temp->next!=nullptr in loops "
                    },
                    {
                        "username": "Tanisha36",
                        "content": "I have a doubt that in some linkedlist what is the difference between these two\\n\\ncurr=head\\ncurr=head=ListNode\\n\\nas in some question we use first method and in some the other one I am literally confuse between two\\nplease help me "
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "could u tell where u have seen the second one \\nas ListNode is a struct we cannot directly set curr to it we definitely take use of its members or by referencing it we can assign curr . pls correct if i\\'m wrong..."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Why am I getting error for the below code when I use `n->next = head;`\nbut not when I use `head->next->next = head;` aren't they supposed to be the same\n```\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n       if(!head || !(head->next))\n       {\n           return head;\n       }\n       ListNode* n = reverseList(head->next);\n       n->next = head;\n       head->next = NULL;\n       return n;\n    }\n};\n"
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s not an easy question unless you haven\\'t had an experience with linked lists"
                    }
                ]
            },
            {
                "id": 1856892,
                "content": [
                    {
                        "username": "deki5",
                        "content": "Why doesn\\'t this recursive solution work in python 3 ?\\nIt keeps recursing even though we reached the base case at \\'return pointer\\'\\n ```\\nclass Solution:\\n\\n    def reverse(self,currpointer,nexthead):\\n        if not currpointer.next:\\n            print(\"final node\",currpointer.val)\\n            currpointer.next = nexthead\\n            print(\"NOW WE RETURN\")\\n            return currpointer\\n        else:\\n            print(f\"Currpointer = {currpointer.val}\")\\n            temp = currpointer.next\\n            print(\"temp val = \",temp.val)\\n            currpointer.next = nexthead\\n            return self.reverse(temp,currpointer)\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverse(head,None)```\\n\\n"
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "I don\\'t understand this part where output is assign as a new ListNode object, but then we return it at the end. Is it because tmp is a reference of output?\\n\\n` output = ListNode(0)\\n\\n        # Creates a temporary value for the list Node.\\n        tmp = output\\n\\n        for i in lst:\\n\\n            # Assign the list node object to the next value.\\n            tmp.next = ListNode(i)\\n            tmp = tmp.next\\n\\n        \\n        return output.next\\n`\\n"
                    },
                    {
                        "username": "samsagume",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n\nI am repeatedly getting this error.\nI ran the same code in VS-Code and it ran perfectly.\nI just want to know that is this error due to the LeetCode IDE or my code."
                    },
                    {
                        "username": "akshaydusad",
                        "content": "I can wrap my head around Linked Lists in Python"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "Can someone please explain why just returning head acts as returning whole linked list?\\nLike for example one : \\nI am just returning head [5] of reversed linked list [5, 4 ,3, 2, 1], so why is whole linked list being returned?"
                    },
                    {
                        "username": "TarantulaNebula",
                        "content": "[@yassineseddaoui](/yassineseddaoui) I think i get it.Thanks for answering."
                    },
                    {
                        "username": "yassineseddaoui",
                        "content": "returning the head acts as returning whole linked list because the head is pointing to another ListNode which is pointing to another ListNode etc. So if you have a linked list 1 -> 2 -> 3 you can only return the first node and from there you will be able to traverse the linked list. \\nDoes this answer your question?"
                    },
                    {
                        "username": "GamerBoy65",
                        "content": "Cant we use collections framework?"
                    },
                    {
                        "username": "myeong_ju",
                        "content": "Why do I keep getting this error?\\nLine 17: Char 21: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:26:21\\nSomeone plz help!!\\nHere\\'s my code in c++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        int cnt=1;\\n        ListNode* temp= head;\\n        ListNode* temp2;\\n        while(temp->next != NULL)\\n        {\\n            temp= temp->next; \\n            cnt++;\\n        } \\n        temp2= temp;\\n        for(int i=1; i<cnt; i++)\\n        {\\n            temp=head;\\n            while(temp->next->next!= NULL)\\n            {\\n                temp= temp->next;\\n            }\\n            \\n            temp->next->next= temp;\\n            temp->next= NULL;\\n        }\\n        return temp2;\\n    }\\n};"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "yes in some cases when your temp variable points to a nullptr or empty address that it is  doesnt have any node address , in that case if u try to access the attribute like val or next with that temp variable then it throws the error u have shown . \\nto avoid this use temp!=nullptr instead of temp->next!=nullptr in loops "
                    },
                    {
                        "username": "Tanisha36",
                        "content": "I have a doubt that in some linkedlist what is the difference between these two\\n\\ncurr=head\\ncurr=head=ListNode\\n\\nas in some question we use first method and in some the other one I am literally confuse between two\\nplease help me "
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "could u tell where u have seen the second one \\nas ListNode is a struct we cannot directly set curr to it we definitely take use of its members or by referencing it we can assign curr . pls correct if i\\'m wrong..."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Why am I getting error for the below code when I use `n->next = head;`\nbut not when I use `head->next->next = head;` aren't they supposed to be the same\n```\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n       if(!head || !(head->next))\n       {\n           return head;\n       }\n       ListNode* n = reverseList(head->next);\n       n->next = head;\n       head->next = NULL;\n       return n;\n    }\n};\n"
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s not an easy question unless you haven\\'t had an experience with linked lists"
                    }
                ]
            },
            {
                "id": 1853401,
                "content": [
                    {
                        "username": "noahmedoff",
                        "content": "In python I can not access .val or .next, I get the following error:\\nAttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n    print(head.val)\\nOr \\nAttributeError: \\'NoneType\\' object has no attribute \\'next\\'\\n    print(head.next)\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Optional[ListNode] means that a head can be None.\\nOf course None type doesn\\'t has any value. You can avoid this problem by checking first if the head is not empty (equal None)."
                    },
                    {
                        "username": "myLtcdId",
                        "content": "Hey LeetCode Pro a question for you:\\nIn recursion, I know that if in a future call an object\\'s value is updated then the change is reflected in the previous calls.\\nso to reverse the LL , I have used two variables first and last and thought to update them when i reach the final node via recursion as\\n\\nfirst = last = head;\\nreturn;\\n\\nand then keep updating the last node at each prev call.\\nbut the last and first pointers are not getting updated. \\ncould u plz tell me why?\\nAnd the code is below :\\n \\n public ListNode reverseList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode first = null;\\n        ListNode last = null;\\n        reverse(head, first, last);\\n        return first;\\n\\n    }\\n\\n    public void reverse(ListNode head, ListNode first, ListNode last){\\n        if(head.next == null){\\n           first = last = head;\\n            \\n            return;\\n        }\\n        reverse(head.next, first, last);\\n       \\n       last.next = head;\\n       last = head;\\n       last.next = null;\\n       \\n        \\n    }\\n\\nA BIG THANKS TO U"
                    },
                    {
                        "username": "zalars",
                        "content": "In solutions I see new nodes referencing to old nodes, i.e. values of new nodes depend on values of old ones. Is that right?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Easy C++ solution: \\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3326036/easy-c-solution-to-reverse-linked-list/"
                    },
                    {
                        "username": "MadhurDixit13",
                        "content": "When i try to print my new reversed LinkedIn lists-->Val at the end it gives me an error of null pointer reference. Any idea why?"
                    },
                    {
                        "username": "swisstackle",
                        "content": "Why is this one time exceeding? Locally it works like a charm.\\n\\n```\\nstruct ListNode* reverseList(struct ListNode* head){\\n\\tif(head == NULL) {\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(head->next == NULL) {\\n\\t\\treturn head;\\n\\t}\\n\\tif(head->next->next == NULL) {\\n\\t\\thead->next->next = head;\\n\\t\\thead->next = NULL;\\n\\t\\treturn head->next;\\n\\t}\\n\\tstruct ListNode *current = head->next;\\n\\tstruct ListNode *last = head;\\n\\tstruct ListNode *third = head->next->next;\\n\\twhile(current != NULL) {\\n\\t\\tif(current->next != NULL) {\\n\\t\\t\\tthird = current->next;\\n\\t\\t} else {\\n\\t\\t\\tthird = NULL;\\n\\t\\t}\\n\\t\\tcurrent->next = last;\\n\\t\\tlast = current;\\n\\t\\tcurrent = third;\\t\\n\\t}\\n\\treturn last;\\n}\\n```"
                    },
                    {
                        "username": "elhalvers",
                        "content": "In Ruby, what do lines 9 and 10:\\nparam {ListNode} head\\nreturn {ListNode}  mean?"
                    },
                    {
                        "username": "chkhd",
                        "content": "I found the iterative way of solving this much neater, and easier to reason about than the recursive one.\\n\\nIn my humble opinion whole point of recursion is to make it elegant, and this one does not look at all elegant in that guise. An elegant recursive function is a pure recursive function, just like any other function.\\n"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "When we try to reverse **[1, 2, 3, 4, 5]** using while loop and two variables **previousNode** and **currentNode** it suppose to look like this:\n\n```\nLOOP 1:\npreviousNode = nil -> nil\ncurrentNode = head -> 1\n\nnextNode = currentNode?.next -> 2\ncurrentNode?.next = previousNode -> nil\npreviousNode = currentNode -> 1\ncurrentNode = nextNode -> 2\n\nLOOP 2:\npreviousNode -> 1\ncurrentNode -> 2\n\nnextNode = currentNode?.next -> 3\ncurrentNode?.next = previousNode -> 1\npreviousNode = currentNode = -> 2\ncurrentNode = nextNode -> 3\n\nLOOP 3:\npreviousNode -> 2\ncurrentNode -> 3\n\nnextNode = currentNode?.next -> 4\ncurrentNode?.next = previousNode -> 2\npreviousNode = currentNode = -> 3\ncurrentNode = nextNode -> 4\n\nLOOP 4:\npreviousNode -> 3\ncurrentNode -> 4\n\nnextNode = currentNode?.next -> 5\ncurrentNode?.next = previousNode -> 3\npreviousNode = currentNode = -> 4\ncurrentNode = nextNode -> 5\n\nLOOP 5:\npreviousNode -> 4\ncurrentNode -> 5\n\nnextNode = currentNode?.next -> nil\ncurrentNode?.next = previousNode -> 4\npreviousNode = currentNode = -> 5\ncurrentNode = nextNode -> nil\n```\n\nHope it will be helpful to visualize."
                    },
                    {
                        "username": "shivasoni8528",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL){return head;}\\n        ListNode *prev=NULL;\\n        ListNode *curr=head;\\n        ListNode *forward;\\n        while(curr){\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1852425,
                "content": [
                    {
                        "username": "noahmedoff",
                        "content": "In python I can not access .val or .next, I get the following error:\\nAttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n    print(head.val)\\nOr \\nAttributeError: \\'NoneType\\' object has no attribute \\'next\\'\\n    print(head.next)\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Optional[ListNode] means that a head can be None.\\nOf course None type doesn\\'t has any value. You can avoid this problem by checking first if the head is not empty (equal None)."
                    },
                    {
                        "username": "myLtcdId",
                        "content": "Hey LeetCode Pro a question for you:\\nIn recursion, I know that if in a future call an object\\'s value is updated then the change is reflected in the previous calls.\\nso to reverse the LL , I have used two variables first and last and thought to update them when i reach the final node via recursion as\\n\\nfirst = last = head;\\nreturn;\\n\\nand then keep updating the last node at each prev call.\\nbut the last and first pointers are not getting updated. \\ncould u plz tell me why?\\nAnd the code is below :\\n \\n public ListNode reverseList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode first = null;\\n        ListNode last = null;\\n        reverse(head, first, last);\\n        return first;\\n\\n    }\\n\\n    public void reverse(ListNode head, ListNode first, ListNode last){\\n        if(head.next == null){\\n           first = last = head;\\n            \\n            return;\\n        }\\n        reverse(head.next, first, last);\\n       \\n       last.next = head;\\n       last = head;\\n       last.next = null;\\n       \\n        \\n    }\\n\\nA BIG THANKS TO U"
                    },
                    {
                        "username": "zalars",
                        "content": "In solutions I see new nodes referencing to old nodes, i.e. values of new nodes depend on values of old ones. Is that right?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Easy C++ solution: \\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3326036/easy-c-solution-to-reverse-linked-list/"
                    },
                    {
                        "username": "MadhurDixit13",
                        "content": "When i try to print my new reversed LinkedIn lists-->Val at the end it gives me an error of null pointer reference. Any idea why?"
                    },
                    {
                        "username": "swisstackle",
                        "content": "Why is this one time exceeding? Locally it works like a charm.\\n\\n```\\nstruct ListNode* reverseList(struct ListNode* head){\\n\\tif(head == NULL) {\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(head->next == NULL) {\\n\\t\\treturn head;\\n\\t}\\n\\tif(head->next->next == NULL) {\\n\\t\\thead->next->next = head;\\n\\t\\thead->next = NULL;\\n\\t\\treturn head->next;\\n\\t}\\n\\tstruct ListNode *current = head->next;\\n\\tstruct ListNode *last = head;\\n\\tstruct ListNode *third = head->next->next;\\n\\twhile(current != NULL) {\\n\\t\\tif(current->next != NULL) {\\n\\t\\t\\tthird = current->next;\\n\\t\\t} else {\\n\\t\\t\\tthird = NULL;\\n\\t\\t}\\n\\t\\tcurrent->next = last;\\n\\t\\tlast = current;\\n\\t\\tcurrent = third;\\t\\n\\t}\\n\\treturn last;\\n}\\n```"
                    },
                    {
                        "username": "elhalvers",
                        "content": "In Ruby, what do lines 9 and 10:\\nparam {ListNode} head\\nreturn {ListNode}  mean?"
                    },
                    {
                        "username": "chkhd",
                        "content": "I found the iterative way of solving this much neater, and easier to reason about than the recursive one.\\n\\nIn my humble opinion whole point of recursion is to make it elegant, and this one does not look at all elegant in that guise. An elegant recursive function is a pure recursive function, just like any other function.\\n"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "When we try to reverse **[1, 2, 3, 4, 5]** using while loop and two variables **previousNode** and **currentNode** it suppose to look like this:\n\n```\nLOOP 1:\npreviousNode = nil -> nil\ncurrentNode = head -> 1\n\nnextNode = currentNode?.next -> 2\ncurrentNode?.next = previousNode -> nil\npreviousNode = currentNode -> 1\ncurrentNode = nextNode -> 2\n\nLOOP 2:\npreviousNode -> 1\ncurrentNode -> 2\n\nnextNode = currentNode?.next -> 3\ncurrentNode?.next = previousNode -> 1\npreviousNode = currentNode = -> 2\ncurrentNode = nextNode -> 3\n\nLOOP 3:\npreviousNode -> 2\ncurrentNode -> 3\n\nnextNode = currentNode?.next -> 4\ncurrentNode?.next = previousNode -> 2\npreviousNode = currentNode = -> 3\ncurrentNode = nextNode -> 4\n\nLOOP 4:\npreviousNode -> 3\ncurrentNode -> 4\n\nnextNode = currentNode?.next -> 5\ncurrentNode?.next = previousNode -> 3\npreviousNode = currentNode = -> 4\ncurrentNode = nextNode -> 5\n\nLOOP 5:\npreviousNode -> 4\ncurrentNode -> 5\n\nnextNode = currentNode?.next -> nil\ncurrentNode?.next = previousNode -> 4\npreviousNode = currentNode = -> 5\ncurrentNode = nextNode -> nil\n```\n\nHope it will be helpful to visualize."
                    },
                    {
                        "username": "shivasoni8528",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL){return head;}\\n        ListNode *prev=NULL;\\n        ListNode *curr=head;\\n        ListNode *forward;\\n        while(curr){\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1845358,
                "content": [
                    {
                        "username": "noahmedoff",
                        "content": "In python I can not access .val or .next, I get the following error:\\nAttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n    print(head.val)\\nOr \\nAttributeError: \\'NoneType\\' object has no attribute \\'next\\'\\n    print(head.next)\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Optional[ListNode] means that a head can be None.\\nOf course None type doesn\\'t has any value. You can avoid this problem by checking first if the head is not empty (equal None)."
                    },
                    {
                        "username": "myLtcdId",
                        "content": "Hey LeetCode Pro a question for you:\\nIn recursion, I know that if in a future call an object\\'s value is updated then the change is reflected in the previous calls.\\nso to reverse the LL , I have used two variables first and last and thought to update them when i reach the final node via recursion as\\n\\nfirst = last = head;\\nreturn;\\n\\nand then keep updating the last node at each prev call.\\nbut the last and first pointers are not getting updated. \\ncould u plz tell me why?\\nAnd the code is below :\\n \\n public ListNode reverseList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode first = null;\\n        ListNode last = null;\\n        reverse(head, first, last);\\n        return first;\\n\\n    }\\n\\n    public void reverse(ListNode head, ListNode first, ListNode last){\\n        if(head.next == null){\\n           first = last = head;\\n            \\n            return;\\n        }\\n        reverse(head.next, first, last);\\n       \\n       last.next = head;\\n       last = head;\\n       last.next = null;\\n       \\n        \\n    }\\n\\nA BIG THANKS TO U"
                    },
                    {
                        "username": "zalars",
                        "content": "In solutions I see new nodes referencing to old nodes, i.e. values of new nodes depend on values of old ones. Is that right?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Easy C++ solution: \\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3326036/easy-c-solution-to-reverse-linked-list/"
                    },
                    {
                        "username": "MadhurDixit13",
                        "content": "When i try to print my new reversed LinkedIn lists-->Val at the end it gives me an error of null pointer reference. Any idea why?"
                    },
                    {
                        "username": "swisstackle",
                        "content": "Why is this one time exceeding? Locally it works like a charm.\\n\\n```\\nstruct ListNode* reverseList(struct ListNode* head){\\n\\tif(head == NULL) {\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(head->next == NULL) {\\n\\t\\treturn head;\\n\\t}\\n\\tif(head->next->next == NULL) {\\n\\t\\thead->next->next = head;\\n\\t\\thead->next = NULL;\\n\\t\\treturn head->next;\\n\\t}\\n\\tstruct ListNode *current = head->next;\\n\\tstruct ListNode *last = head;\\n\\tstruct ListNode *third = head->next->next;\\n\\twhile(current != NULL) {\\n\\t\\tif(current->next != NULL) {\\n\\t\\t\\tthird = current->next;\\n\\t\\t} else {\\n\\t\\t\\tthird = NULL;\\n\\t\\t}\\n\\t\\tcurrent->next = last;\\n\\t\\tlast = current;\\n\\t\\tcurrent = third;\\t\\n\\t}\\n\\treturn last;\\n}\\n```"
                    },
                    {
                        "username": "elhalvers",
                        "content": "In Ruby, what do lines 9 and 10:\\nparam {ListNode} head\\nreturn {ListNode}  mean?"
                    },
                    {
                        "username": "chkhd",
                        "content": "I found the iterative way of solving this much neater, and easier to reason about than the recursive one.\\n\\nIn my humble opinion whole point of recursion is to make it elegant, and this one does not look at all elegant in that guise. An elegant recursive function is a pure recursive function, just like any other function.\\n"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "When we try to reverse **[1, 2, 3, 4, 5]** using while loop and two variables **previousNode** and **currentNode** it suppose to look like this:\n\n```\nLOOP 1:\npreviousNode = nil -> nil\ncurrentNode = head -> 1\n\nnextNode = currentNode?.next -> 2\ncurrentNode?.next = previousNode -> nil\npreviousNode = currentNode -> 1\ncurrentNode = nextNode -> 2\n\nLOOP 2:\npreviousNode -> 1\ncurrentNode -> 2\n\nnextNode = currentNode?.next -> 3\ncurrentNode?.next = previousNode -> 1\npreviousNode = currentNode = -> 2\ncurrentNode = nextNode -> 3\n\nLOOP 3:\npreviousNode -> 2\ncurrentNode -> 3\n\nnextNode = currentNode?.next -> 4\ncurrentNode?.next = previousNode -> 2\npreviousNode = currentNode = -> 3\ncurrentNode = nextNode -> 4\n\nLOOP 4:\npreviousNode -> 3\ncurrentNode -> 4\n\nnextNode = currentNode?.next -> 5\ncurrentNode?.next = previousNode -> 3\npreviousNode = currentNode = -> 4\ncurrentNode = nextNode -> 5\n\nLOOP 5:\npreviousNode -> 4\ncurrentNode -> 5\n\nnextNode = currentNode?.next -> nil\ncurrentNode?.next = previousNode -> 4\npreviousNode = currentNode = -> 5\ncurrentNode = nextNode -> nil\n```\n\nHope it will be helpful to visualize."
                    },
                    {
                        "username": "shivasoni8528",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL){return head;}\\n        ListNode *prev=NULL;\\n        ListNode *curr=head;\\n        ListNode *forward;\\n        while(curr){\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1839868,
                "content": [
                    {
                        "username": "noahmedoff",
                        "content": "In python I can not access .val or .next, I get the following error:\\nAttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n    print(head.val)\\nOr \\nAttributeError: \\'NoneType\\' object has no attribute \\'next\\'\\n    print(head.next)\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Optional[ListNode] means that a head can be None.\\nOf course None type doesn\\'t has any value. You can avoid this problem by checking first if the head is not empty (equal None)."
                    },
                    {
                        "username": "myLtcdId",
                        "content": "Hey LeetCode Pro a question for you:\\nIn recursion, I know that if in a future call an object\\'s value is updated then the change is reflected in the previous calls.\\nso to reverse the LL , I have used two variables first and last and thought to update them when i reach the final node via recursion as\\n\\nfirst = last = head;\\nreturn;\\n\\nand then keep updating the last node at each prev call.\\nbut the last and first pointers are not getting updated. \\ncould u plz tell me why?\\nAnd the code is below :\\n \\n public ListNode reverseList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode first = null;\\n        ListNode last = null;\\n        reverse(head, first, last);\\n        return first;\\n\\n    }\\n\\n    public void reverse(ListNode head, ListNode first, ListNode last){\\n        if(head.next == null){\\n           first = last = head;\\n            \\n            return;\\n        }\\n        reverse(head.next, first, last);\\n       \\n       last.next = head;\\n       last = head;\\n       last.next = null;\\n       \\n        \\n    }\\n\\nA BIG THANKS TO U"
                    },
                    {
                        "username": "zalars",
                        "content": "In solutions I see new nodes referencing to old nodes, i.e. values of new nodes depend on values of old ones. Is that right?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Easy C++ solution: \\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3326036/easy-c-solution-to-reverse-linked-list/"
                    },
                    {
                        "username": "MadhurDixit13",
                        "content": "When i try to print my new reversed LinkedIn lists-->Val at the end it gives me an error of null pointer reference. Any idea why?"
                    },
                    {
                        "username": "swisstackle",
                        "content": "Why is this one time exceeding? Locally it works like a charm.\\n\\n```\\nstruct ListNode* reverseList(struct ListNode* head){\\n\\tif(head == NULL) {\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(head->next == NULL) {\\n\\t\\treturn head;\\n\\t}\\n\\tif(head->next->next == NULL) {\\n\\t\\thead->next->next = head;\\n\\t\\thead->next = NULL;\\n\\t\\treturn head->next;\\n\\t}\\n\\tstruct ListNode *current = head->next;\\n\\tstruct ListNode *last = head;\\n\\tstruct ListNode *third = head->next->next;\\n\\twhile(current != NULL) {\\n\\t\\tif(current->next != NULL) {\\n\\t\\t\\tthird = current->next;\\n\\t\\t} else {\\n\\t\\t\\tthird = NULL;\\n\\t\\t}\\n\\t\\tcurrent->next = last;\\n\\t\\tlast = current;\\n\\t\\tcurrent = third;\\t\\n\\t}\\n\\treturn last;\\n}\\n```"
                    },
                    {
                        "username": "elhalvers",
                        "content": "In Ruby, what do lines 9 and 10:\\nparam {ListNode} head\\nreturn {ListNode}  mean?"
                    },
                    {
                        "username": "chkhd",
                        "content": "I found the iterative way of solving this much neater, and easier to reason about than the recursive one.\\n\\nIn my humble opinion whole point of recursion is to make it elegant, and this one does not look at all elegant in that guise. An elegant recursive function is a pure recursive function, just like any other function.\\n"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "When we try to reverse **[1, 2, 3, 4, 5]** using while loop and two variables **previousNode** and **currentNode** it suppose to look like this:\n\n```\nLOOP 1:\npreviousNode = nil -> nil\ncurrentNode = head -> 1\n\nnextNode = currentNode?.next -> 2\ncurrentNode?.next = previousNode -> nil\npreviousNode = currentNode -> 1\ncurrentNode = nextNode -> 2\n\nLOOP 2:\npreviousNode -> 1\ncurrentNode -> 2\n\nnextNode = currentNode?.next -> 3\ncurrentNode?.next = previousNode -> 1\npreviousNode = currentNode = -> 2\ncurrentNode = nextNode -> 3\n\nLOOP 3:\npreviousNode -> 2\ncurrentNode -> 3\n\nnextNode = currentNode?.next -> 4\ncurrentNode?.next = previousNode -> 2\npreviousNode = currentNode = -> 3\ncurrentNode = nextNode -> 4\n\nLOOP 4:\npreviousNode -> 3\ncurrentNode -> 4\n\nnextNode = currentNode?.next -> 5\ncurrentNode?.next = previousNode -> 3\npreviousNode = currentNode = -> 4\ncurrentNode = nextNode -> 5\n\nLOOP 5:\npreviousNode -> 4\ncurrentNode -> 5\n\nnextNode = currentNode?.next -> nil\ncurrentNode?.next = previousNode -> 4\npreviousNode = currentNode = -> 5\ncurrentNode = nextNode -> nil\n```\n\nHope it will be helpful to visualize."
                    },
                    {
                        "username": "shivasoni8528",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL){return head;}\\n        ListNode *prev=NULL;\\n        ListNode *curr=head;\\n        ListNode *forward;\\n        while(curr){\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1836685,
                "content": [
                    {
                        "username": "noahmedoff",
                        "content": "In python I can not access .val or .next, I get the following error:\\nAttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n    print(head.val)\\nOr \\nAttributeError: \\'NoneType\\' object has no attribute \\'next\\'\\n    print(head.next)\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Optional[ListNode] means that a head can be None.\\nOf course None type doesn\\'t has any value. You can avoid this problem by checking first if the head is not empty (equal None)."
                    },
                    {
                        "username": "myLtcdId",
                        "content": "Hey LeetCode Pro a question for you:\\nIn recursion, I know that if in a future call an object\\'s value is updated then the change is reflected in the previous calls.\\nso to reverse the LL , I have used two variables first and last and thought to update them when i reach the final node via recursion as\\n\\nfirst = last = head;\\nreturn;\\n\\nand then keep updating the last node at each prev call.\\nbut the last and first pointers are not getting updated. \\ncould u plz tell me why?\\nAnd the code is below :\\n \\n public ListNode reverseList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode first = null;\\n        ListNode last = null;\\n        reverse(head, first, last);\\n        return first;\\n\\n    }\\n\\n    public void reverse(ListNode head, ListNode first, ListNode last){\\n        if(head.next == null){\\n           first = last = head;\\n            \\n            return;\\n        }\\n        reverse(head.next, first, last);\\n       \\n       last.next = head;\\n       last = head;\\n       last.next = null;\\n       \\n        \\n    }\\n\\nA BIG THANKS TO U"
                    },
                    {
                        "username": "zalars",
                        "content": "In solutions I see new nodes referencing to old nodes, i.e. values of new nodes depend on values of old ones. Is that right?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Easy C++ solution: \\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3326036/easy-c-solution-to-reverse-linked-list/"
                    },
                    {
                        "username": "MadhurDixit13",
                        "content": "When i try to print my new reversed LinkedIn lists-->Val at the end it gives me an error of null pointer reference. Any idea why?"
                    },
                    {
                        "username": "swisstackle",
                        "content": "Why is this one time exceeding? Locally it works like a charm.\\n\\n```\\nstruct ListNode* reverseList(struct ListNode* head){\\n\\tif(head == NULL) {\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(head->next == NULL) {\\n\\t\\treturn head;\\n\\t}\\n\\tif(head->next->next == NULL) {\\n\\t\\thead->next->next = head;\\n\\t\\thead->next = NULL;\\n\\t\\treturn head->next;\\n\\t}\\n\\tstruct ListNode *current = head->next;\\n\\tstruct ListNode *last = head;\\n\\tstruct ListNode *third = head->next->next;\\n\\twhile(current != NULL) {\\n\\t\\tif(current->next != NULL) {\\n\\t\\t\\tthird = current->next;\\n\\t\\t} else {\\n\\t\\t\\tthird = NULL;\\n\\t\\t}\\n\\t\\tcurrent->next = last;\\n\\t\\tlast = current;\\n\\t\\tcurrent = third;\\t\\n\\t}\\n\\treturn last;\\n}\\n```"
                    },
                    {
                        "username": "elhalvers",
                        "content": "In Ruby, what do lines 9 and 10:\\nparam {ListNode} head\\nreturn {ListNode}  mean?"
                    },
                    {
                        "username": "chkhd",
                        "content": "I found the iterative way of solving this much neater, and easier to reason about than the recursive one.\\n\\nIn my humble opinion whole point of recursion is to make it elegant, and this one does not look at all elegant in that guise. An elegant recursive function is a pure recursive function, just like any other function.\\n"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "When we try to reverse **[1, 2, 3, 4, 5]** using while loop and two variables **previousNode** and **currentNode** it suppose to look like this:\n\n```\nLOOP 1:\npreviousNode = nil -> nil\ncurrentNode = head -> 1\n\nnextNode = currentNode?.next -> 2\ncurrentNode?.next = previousNode -> nil\npreviousNode = currentNode -> 1\ncurrentNode = nextNode -> 2\n\nLOOP 2:\npreviousNode -> 1\ncurrentNode -> 2\n\nnextNode = currentNode?.next -> 3\ncurrentNode?.next = previousNode -> 1\npreviousNode = currentNode = -> 2\ncurrentNode = nextNode -> 3\n\nLOOP 3:\npreviousNode -> 2\ncurrentNode -> 3\n\nnextNode = currentNode?.next -> 4\ncurrentNode?.next = previousNode -> 2\npreviousNode = currentNode = -> 3\ncurrentNode = nextNode -> 4\n\nLOOP 4:\npreviousNode -> 3\ncurrentNode -> 4\n\nnextNode = currentNode?.next -> 5\ncurrentNode?.next = previousNode -> 3\npreviousNode = currentNode = -> 4\ncurrentNode = nextNode -> 5\n\nLOOP 5:\npreviousNode -> 4\ncurrentNode -> 5\n\nnextNode = currentNode?.next -> nil\ncurrentNode?.next = previousNode -> 4\npreviousNode = currentNode = -> 5\ncurrentNode = nextNode -> nil\n```\n\nHope it will be helpful to visualize."
                    },
                    {
                        "username": "shivasoni8528",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL){return head;}\\n        ListNode *prev=NULL;\\n        ListNode *curr=head;\\n        ListNode *forward;\\n        while(curr){\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1830385,
                "content": [
                    {
                        "username": "noahmedoff",
                        "content": "In python I can not access .val or .next, I get the following error:\\nAttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n    print(head.val)\\nOr \\nAttributeError: \\'NoneType\\' object has no attribute \\'next\\'\\n    print(head.next)\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Optional[ListNode] means that a head can be None.\\nOf course None type doesn\\'t has any value. You can avoid this problem by checking first if the head is not empty (equal None)."
                    },
                    {
                        "username": "myLtcdId",
                        "content": "Hey LeetCode Pro a question for you:\\nIn recursion, I know that if in a future call an object\\'s value is updated then the change is reflected in the previous calls.\\nso to reverse the LL , I have used two variables first and last and thought to update them when i reach the final node via recursion as\\n\\nfirst = last = head;\\nreturn;\\n\\nand then keep updating the last node at each prev call.\\nbut the last and first pointers are not getting updated. \\ncould u plz tell me why?\\nAnd the code is below :\\n \\n public ListNode reverseList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode first = null;\\n        ListNode last = null;\\n        reverse(head, first, last);\\n        return first;\\n\\n    }\\n\\n    public void reverse(ListNode head, ListNode first, ListNode last){\\n        if(head.next == null){\\n           first = last = head;\\n            \\n            return;\\n        }\\n        reverse(head.next, first, last);\\n       \\n       last.next = head;\\n       last = head;\\n       last.next = null;\\n       \\n        \\n    }\\n\\nA BIG THANKS TO U"
                    },
                    {
                        "username": "zalars",
                        "content": "In solutions I see new nodes referencing to old nodes, i.e. values of new nodes depend on values of old ones. Is that right?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Easy C++ solution: \\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3326036/easy-c-solution-to-reverse-linked-list/"
                    },
                    {
                        "username": "MadhurDixit13",
                        "content": "When i try to print my new reversed LinkedIn lists-->Val at the end it gives me an error of null pointer reference. Any idea why?"
                    },
                    {
                        "username": "swisstackle",
                        "content": "Why is this one time exceeding? Locally it works like a charm.\\n\\n```\\nstruct ListNode* reverseList(struct ListNode* head){\\n\\tif(head == NULL) {\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(head->next == NULL) {\\n\\t\\treturn head;\\n\\t}\\n\\tif(head->next->next == NULL) {\\n\\t\\thead->next->next = head;\\n\\t\\thead->next = NULL;\\n\\t\\treturn head->next;\\n\\t}\\n\\tstruct ListNode *current = head->next;\\n\\tstruct ListNode *last = head;\\n\\tstruct ListNode *third = head->next->next;\\n\\twhile(current != NULL) {\\n\\t\\tif(current->next != NULL) {\\n\\t\\t\\tthird = current->next;\\n\\t\\t} else {\\n\\t\\t\\tthird = NULL;\\n\\t\\t}\\n\\t\\tcurrent->next = last;\\n\\t\\tlast = current;\\n\\t\\tcurrent = third;\\t\\n\\t}\\n\\treturn last;\\n}\\n```"
                    },
                    {
                        "username": "elhalvers",
                        "content": "In Ruby, what do lines 9 and 10:\\nparam {ListNode} head\\nreturn {ListNode}  mean?"
                    },
                    {
                        "username": "chkhd",
                        "content": "I found the iterative way of solving this much neater, and easier to reason about than the recursive one.\\n\\nIn my humble opinion whole point of recursion is to make it elegant, and this one does not look at all elegant in that guise. An elegant recursive function is a pure recursive function, just like any other function.\\n"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "When we try to reverse **[1, 2, 3, 4, 5]** using while loop and two variables **previousNode** and **currentNode** it suppose to look like this:\n\n```\nLOOP 1:\npreviousNode = nil -> nil\ncurrentNode = head -> 1\n\nnextNode = currentNode?.next -> 2\ncurrentNode?.next = previousNode -> nil\npreviousNode = currentNode -> 1\ncurrentNode = nextNode -> 2\n\nLOOP 2:\npreviousNode -> 1\ncurrentNode -> 2\n\nnextNode = currentNode?.next -> 3\ncurrentNode?.next = previousNode -> 1\npreviousNode = currentNode = -> 2\ncurrentNode = nextNode -> 3\n\nLOOP 3:\npreviousNode -> 2\ncurrentNode -> 3\n\nnextNode = currentNode?.next -> 4\ncurrentNode?.next = previousNode -> 2\npreviousNode = currentNode = -> 3\ncurrentNode = nextNode -> 4\n\nLOOP 4:\npreviousNode -> 3\ncurrentNode -> 4\n\nnextNode = currentNode?.next -> 5\ncurrentNode?.next = previousNode -> 3\npreviousNode = currentNode = -> 4\ncurrentNode = nextNode -> 5\n\nLOOP 5:\npreviousNode -> 4\ncurrentNode -> 5\n\nnextNode = currentNode?.next -> nil\ncurrentNode?.next = previousNode -> 4\npreviousNode = currentNode = -> 5\ncurrentNode = nextNode -> nil\n```\n\nHope it will be helpful to visualize."
                    },
                    {
                        "username": "shivasoni8528",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL){return head;}\\n        ListNode *prev=NULL;\\n        ListNode *curr=head;\\n        ListNode *forward;\\n        while(curr){\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1806098,
                "content": [
                    {
                        "username": "noahmedoff",
                        "content": "In python I can not access .val or .next, I get the following error:\\nAttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n    print(head.val)\\nOr \\nAttributeError: \\'NoneType\\' object has no attribute \\'next\\'\\n    print(head.next)\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Optional[ListNode] means that a head can be None.\\nOf course None type doesn\\'t has any value. You can avoid this problem by checking first if the head is not empty (equal None)."
                    },
                    {
                        "username": "myLtcdId",
                        "content": "Hey LeetCode Pro a question for you:\\nIn recursion, I know that if in a future call an object\\'s value is updated then the change is reflected in the previous calls.\\nso to reverse the LL , I have used two variables first and last and thought to update them when i reach the final node via recursion as\\n\\nfirst = last = head;\\nreturn;\\n\\nand then keep updating the last node at each prev call.\\nbut the last and first pointers are not getting updated. \\ncould u plz tell me why?\\nAnd the code is below :\\n \\n public ListNode reverseList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode first = null;\\n        ListNode last = null;\\n        reverse(head, first, last);\\n        return first;\\n\\n    }\\n\\n    public void reverse(ListNode head, ListNode first, ListNode last){\\n        if(head.next == null){\\n           first = last = head;\\n            \\n            return;\\n        }\\n        reverse(head.next, first, last);\\n       \\n       last.next = head;\\n       last = head;\\n       last.next = null;\\n       \\n        \\n    }\\n\\nA BIG THANKS TO U"
                    },
                    {
                        "username": "zalars",
                        "content": "In solutions I see new nodes referencing to old nodes, i.e. values of new nodes depend on values of old ones. Is that right?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Easy C++ solution: \\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3326036/easy-c-solution-to-reverse-linked-list/"
                    },
                    {
                        "username": "MadhurDixit13",
                        "content": "When i try to print my new reversed LinkedIn lists-->Val at the end it gives me an error of null pointer reference. Any idea why?"
                    },
                    {
                        "username": "swisstackle",
                        "content": "Why is this one time exceeding? Locally it works like a charm.\\n\\n```\\nstruct ListNode* reverseList(struct ListNode* head){\\n\\tif(head == NULL) {\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(head->next == NULL) {\\n\\t\\treturn head;\\n\\t}\\n\\tif(head->next->next == NULL) {\\n\\t\\thead->next->next = head;\\n\\t\\thead->next = NULL;\\n\\t\\treturn head->next;\\n\\t}\\n\\tstruct ListNode *current = head->next;\\n\\tstruct ListNode *last = head;\\n\\tstruct ListNode *third = head->next->next;\\n\\twhile(current != NULL) {\\n\\t\\tif(current->next != NULL) {\\n\\t\\t\\tthird = current->next;\\n\\t\\t} else {\\n\\t\\t\\tthird = NULL;\\n\\t\\t}\\n\\t\\tcurrent->next = last;\\n\\t\\tlast = current;\\n\\t\\tcurrent = third;\\t\\n\\t}\\n\\treturn last;\\n}\\n```"
                    },
                    {
                        "username": "elhalvers",
                        "content": "In Ruby, what do lines 9 and 10:\\nparam {ListNode} head\\nreturn {ListNode}  mean?"
                    },
                    {
                        "username": "chkhd",
                        "content": "I found the iterative way of solving this much neater, and easier to reason about than the recursive one.\\n\\nIn my humble opinion whole point of recursion is to make it elegant, and this one does not look at all elegant in that guise. An elegant recursive function is a pure recursive function, just like any other function.\\n"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "When we try to reverse **[1, 2, 3, 4, 5]** using while loop and two variables **previousNode** and **currentNode** it suppose to look like this:\n\n```\nLOOP 1:\npreviousNode = nil -> nil\ncurrentNode = head -> 1\n\nnextNode = currentNode?.next -> 2\ncurrentNode?.next = previousNode -> nil\npreviousNode = currentNode -> 1\ncurrentNode = nextNode -> 2\n\nLOOP 2:\npreviousNode -> 1\ncurrentNode -> 2\n\nnextNode = currentNode?.next -> 3\ncurrentNode?.next = previousNode -> 1\npreviousNode = currentNode = -> 2\ncurrentNode = nextNode -> 3\n\nLOOP 3:\npreviousNode -> 2\ncurrentNode -> 3\n\nnextNode = currentNode?.next -> 4\ncurrentNode?.next = previousNode -> 2\npreviousNode = currentNode = -> 3\ncurrentNode = nextNode -> 4\n\nLOOP 4:\npreviousNode -> 3\ncurrentNode -> 4\n\nnextNode = currentNode?.next -> 5\ncurrentNode?.next = previousNode -> 3\npreviousNode = currentNode = -> 4\ncurrentNode = nextNode -> 5\n\nLOOP 5:\npreviousNode -> 4\ncurrentNode -> 5\n\nnextNode = currentNode?.next -> nil\ncurrentNode?.next = previousNode -> 4\npreviousNode = currentNode = -> 5\ncurrentNode = nextNode -> nil\n```\n\nHope it will be helpful to visualize."
                    },
                    {
                        "username": "shivasoni8528",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL){return head;}\\n        ListNode *prev=NULL;\\n        ListNode *curr=head;\\n        ListNode *forward;\\n        while(curr){\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1794888,
                "content": [
                    {
                        "username": "noahmedoff",
                        "content": "In python I can not access .val or .next, I get the following error:\\nAttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n    print(head.val)\\nOr \\nAttributeError: \\'NoneType\\' object has no attribute \\'next\\'\\n    print(head.next)\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Optional[ListNode] means that a head can be None.\\nOf course None type doesn\\'t has any value. You can avoid this problem by checking first if the head is not empty (equal None)."
                    },
                    {
                        "username": "myLtcdId",
                        "content": "Hey LeetCode Pro a question for you:\\nIn recursion, I know that if in a future call an object\\'s value is updated then the change is reflected in the previous calls.\\nso to reverse the LL , I have used two variables first and last and thought to update them when i reach the final node via recursion as\\n\\nfirst = last = head;\\nreturn;\\n\\nand then keep updating the last node at each prev call.\\nbut the last and first pointers are not getting updated. \\ncould u plz tell me why?\\nAnd the code is below :\\n \\n public ListNode reverseList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode first = null;\\n        ListNode last = null;\\n        reverse(head, first, last);\\n        return first;\\n\\n    }\\n\\n    public void reverse(ListNode head, ListNode first, ListNode last){\\n        if(head.next == null){\\n           first = last = head;\\n            \\n            return;\\n        }\\n        reverse(head.next, first, last);\\n       \\n       last.next = head;\\n       last = head;\\n       last.next = null;\\n       \\n        \\n    }\\n\\nA BIG THANKS TO U"
                    },
                    {
                        "username": "zalars",
                        "content": "In solutions I see new nodes referencing to old nodes, i.e. values of new nodes depend on values of old ones. Is that right?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Easy C++ solution: \\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3326036/easy-c-solution-to-reverse-linked-list/"
                    },
                    {
                        "username": "MadhurDixit13",
                        "content": "When i try to print my new reversed LinkedIn lists-->Val at the end it gives me an error of null pointer reference. Any idea why?"
                    },
                    {
                        "username": "swisstackle",
                        "content": "Why is this one time exceeding? Locally it works like a charm.\\n\\n```\\nstruct ListNode* reverseList(struct ListNode* head){\\n\\tif(head == NULL) {\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(head->next == NULL) {\\n\\t\\treturn head;\\n\\t}\\n\\tif(head->next->next == NULL) {\\n\\t\\thead->next->next = head;\\n\\t\\thead->next = NULL;\\n\\t\\treturn head->next;\\n\\t}\\n\\tstruct ListNode *current = head->next;\\n\\tstruct ListNode *last = head;\\n\\tstruct ListNode *third = head->next->next;\\n\\twhile(current != NULL) {\\n\\t\\tif(current->next != NULL) {\\n\\t\\t\\tthird = current->next;\\n\\t\\t} else {\\n\\t\\t\\tthird = NULL;\\n\\t\\t}\\n\\t\\tcurrent->next = last;\\n\\t\\tlast = current;\\n\\t\\tcurrent = third;\\t\\n\\t}\\n\\treturn last;\\n}\\n```"
                    },
                    {
                        "username": "elhalvers",
                        "content": "In Ruby, what do lines 9 and 10:\\nparam {ListNode} head\\nreturn {ListNode}  mean?"
                    },
                    {
                        "username": "chkhd",
                        "content": "I found the iterative way of solving this much neater, and easier to reason about than the recursive one.\\n\\nIn my humble opinion whole point of recursion is to make it elegant, and this one does not look at all elegant in that guise. An elegant recursive function is a pure recursive function, just like any other function.\\n"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "When we try to reverse **[1, 2, 3, 4, 5]** using while loop and two variables **previousNode** and **currentNode** it suppose to look like this:\n\n```\nLOOP 1:\npreviousNode = nil -> nil\ncurrentNode = head -> 1\n\nnextNode = currentNode?.next -> 2\ncurrentNode?.next = previousNode -> nil\npreviousNode = currentNode -> 1\ncurrentNode = nextNode -> 2\n\nLOOP 2:\npreviousNode -> 1\ncurrentNode -> 2\n\nnextNode = currentNode?.next -> 3\ncurrentNode?.next = previousNode -> 1\npreviousNode = currentNode = -> 2\ncurrentNode = nextNode -> 3\n\nLOOP 3:\npreviousNode -> 2\ncurrentNode -> 3\n\nnextNode = currentNode?.next -> 4\ncurrentNode?.next = previousNode -> 2\npreviousNode = currentNode = -> 3\ncurrentNode = nextNode -> 4\n\nLOOP 4:\npreviousNode -> 3\ncurrentNode -> 4\n\nnextNode = currentNode?.next -> 5\ncurrentNode?.next = previousNode -> 3\npreviousNode = currentNode = -> 4\ncurrentNode = nextNode -> 5\n\nLOOP 5:\npreviousNode -> 4\ncurrentNode -> 5\n\nnextNode = currentNode?.next -> nil\ncurrentNode?.next = previousNode -> 4\npreviousNode = currentNode = -> 5\ncurrentNode = nextNode -> nil\n```\n\nHope it will be helpful to visualize."
                    },
                    {
                        "username": "shivasoni8528",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL){return head;}\\n        ListNode *prev=NULL;\\n        ListNode *curr=head;\\n        ListNode *forward;\\n        while(curr){\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1792083,
                "content": [
                    {
                        "username": "noahmedoff",
                        "content": "In python I can not access .val or .next, I get the following error:\\nAttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n    print(head.val)\\nOr \\nAttributeError: \\'NoneType\\' object has no attribute \\'next\\'\\n    print(head.next)\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Optional[ListNode] means that a head can be None.\\nOf course None type doesn\\'t has any value. You can avoid this problem by checking first if the head is not empty (equal None)."
                    },
                    {
                        "username": "myLtcdId",
                        "content": "Hey LeetCode Pro a question for you:\\nIn recursion, I know that if in a future call an object\\'s value is updated then the change is reflected in the previous calls.\\nso to reverse the LL , I have used two variables first and last and thought to update them when i reach the final node via recursion as\\n\\nfirst = last = head;\\nreturn;\\n\\nand then keep updating the last node at each prev call.\\nbut the last and first pointers are not getting updated. \\ncould u plz tell me why?\\nAnd the code is below :\\n \\n public ListNode reverseList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode first = null;\\n        ListNode last = null;\\n        reverse(head, first, last);\\n        return first;\\n\\n    }\\n\\n    public void reverse(ListNode head, ListNode first, ListNode last){\\n        if(head.next == null){\\n           first = last = head;\\n            \\n            return;\\n        }\\n        reverse(head.next, first, last);\\n       \\n       last.next = head;\\n       last = head;\\n       last.next = null;\\n       \\n        \\n    }\\n\\nA BIG THANKS TO U"
                    },
                    {
                        "username": "zalars",
                        "content": "In solutions I see new nodes referencing to old nodes, i.e. values of new nodes depend on values of old ones. Is that right?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Easy C++ solution: \\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3326036/easy-c-solution-to-reverse-linked-list/"
                    },
                    {
                        "username": "MadhurDixit13",
                        "content": "When i try to print my new reversed LinkedIn lists-->Val at the end it gives me an error of null pointer reference. Any idea why?"
                    },
                    {
                        "username": "swisstackle",
                        "content": "Why is this one time exceeding? Locally it works like a charm.\\n\\n```\\nstruct ListNode* reverseList(struct ListNode* head){\\n\\tif(head == NULL) {\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(head->next == NULL) {\\n\\t\\treturn head;\\n\\t}\\n\\tif(head->next->next == NULL) {\\n\\t\\thead->next->next = head;\\n\\t\\thead->next = NULL;\\n\\t\\treturn head->next;\\n\\t}\\n\\tstruct ListNode *current = head->next;\\n\\tstruct ListNode *last = head;\\n\\tstruct ListNode *third = head->next->next;\\n\\twhile(current != NULL) {\\n\\t\\tif(current->next != NULL) {\\n\\t\\t\\tthird = current->next;\\n\\t\\t} else {\\n\\t\\t\\tthird = NULL;\\n\\t\\t}\\n\\t\\tcurrent->next = last;\\n\\t\\tlast = current;\\n\\t\\tcurrent = third;\\t\\n\\t}\\n\\treturn last;\\n}\\n```"
                    },
                    {
                        "username": "elhalvers",
                        "content": "In Ruby, what do lines 9 and 10:\\nparam {ListNode} head\\nreturn {ListNode}  mean?"
                    },
                    {
                        "username": "chkhd",
                        "content": "I found the iterative way of solving this much neater, and easier to reason about than the recursive one.\\n\\nIn my humble opinion whole point of recursion is to make it elegant, and this one does not look at all elegant in that guise. An elegant recursive function is a pure recursive function, just like any other function.\\n"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "When we try to reverse **[1, 2, 3, 4, 5]** using while loop and two variables **previousNode** and **currentNode** it suppose to look like this:\n\n```\nLOOP 1:\npreviousNode = nil -> nil\ncurrentNode = head -> 1\n\nnextNode = currentNode?.next -> 2\ncurrentNode?.next = previousNode -> nil\npreviousNode = currentNode -> 1\ncurrentNode = nextNode -> 2\n\nLOOP 2:\npreviousNode -> 1\ncurrentNode -> 2\n\nnextNode = currentNode?.next -> 3\ncurrentNode?.next = previousNode -> 1\npreviousNode = currentNode = -> 2\ncurrentNode = nextNode -> 3\n\nLOOP 3:\npreviousNode -> 2\ncurrentNode -> 3\n\nnextNode = currentNode?.next -> 4\ncurrentNode?.next = previousNode -> 2\npreviousNode = currentNode = -> 3\ncurrentNode = nextNode -> 4\n\nLOOP 4:\npreviousNode -> 3\ncurrentNode -> 4\n\nnextNode = currentNode?.next -> 5\ncurrentNode?.next = previousNode -> 3\npreviousNode = currentNode = -> 4\ncurrentNode = nextNode -> 5\n\nLOOP 5:\npreviousNode -> 4\ncurrentNode -> 5\n\nnextNode = currentNode?.next -> nil\ncurrentNode?.next = previousNode -> 4\npreviousNode = currentNode = -> 5\ncurrentNode = nextNode -> nil\n```\n\nHope it will be helpful to visualize."
                    },
                    {
                        "username": "shivasoni8528",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL){return head;}\\n        ListNode *prev=NULL;\\n        ListNode *curr=head;\\n        ListNode *forward;\\n        while(curr){\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1786301,
                "content": [
                    {
                        "username": "noahmedoff",
                        "content": "In python I can not access .val or .next, I get the following error:\\nAttributeError: \\'NoneType\\' object has no attribute \\'val\\'\\n    print(head.val)\\nOr \\nAttributeError: \\'NoneType\\' object has no attribute \\'next\\'\\n    print(head.next)\\n"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Optional[ListNode] means that a head can be None.\\nOf course None type doesn\\'t has any value. You can avoid this problem by checking first if the head is not empty (equal None)."
                    },
                    {
                        "username": "myLtcdId",
                        "content": "Hey LeetCode Pro a question for you:\\nIn recursion, I know that if in a future call an object\\'s value is updated then the change is reflected in the previous calls.\\nso to reverse the LL , I have used two variables first and last and thought to update them when i reach the final node via recursion as\\n\\nfirst = last = head;\\nreturn;\\n\\nand then keep updating the last node at each prev call.\\nbut the last and first pointers are not getting updated. \\ncould u plz tell me why?\\nAnd the code is below :\\n \\n public ListNode reverseList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode first = null;\\n        ListNode last = null;\\n        reverse(head, first, last);\\n        return first;\\n\\n    }\\n\\n    public void reverse(ListNode head, ListNode first, ListNode last){\\n        if(head.next == null){\\n           first = last = head;\\n            \\n            return;\\n        }\\n        reverse(head.next, first, last);\\n       \\n       last.next = head;\\n       last = head;\\n       last.next = null;\\n       \\n        \\n    }\\n\\nA BIG THANKS TO U"
                    },
                    {
                        "username": "zalars",
                        "content": "In solutions I see new nodes referencing to old nodes, i.e. values of new nodes depend on values of old ones. Is that right?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Easy C++ solution: \\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3326036/easy-c-solution-to-reverse-linked-list/"
                    },
                    {
                        "username": "MadhurDixit13",
                        "content": "When i try to print my new reversed LinkedIn lists-->Val at the end it gives me an error of null pointer reference. Any idea why?"
                    },
                    {
                        "username": "swisstackle",
                        "content": "Why is this one time exceeding? Locally it works like a charm.\\n\\n```\\nstruct ListNode* reverseList(struct ListNode* head){\\n\\tif(head == NULL) {\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(head->next == NULL) {\\n\\t\\treturn head;\\n\\t}\\n\\tif(head->next->next == NULL) {\\n\\t\\thead->next->next = head;\\n\\t\\thead->next = NULL;\\n\\t\\treturn head->next;\\n\\t}\\n\\tstruct ListNode *current = head->next;\\n\\tstruct ListNode *last = head;\\n\\tstruct ListNode *third = head->next->next;\\n\\twhile(current != NULL) {\\n\\t\\tif(current->next != NULL) {\\n\\t\\t\\tthird = current->next;\\n\\t\\t} else {\\n\\t\\t\\tthird = NULL;\\n\\t\\t}\\n\\t\\tcurrent->next = last;\\n\\t\\tlast = current;\\n\\t\\tcurrent = third;\\t\\n\\t}\\n\\treturn last;\\n}\\n```"
                    },
                    {
                        "username": "elhalvers",
                        "content": "In Ruby, what do lines 9 and 10:\\nparam {ListNode} head\\nreturn {ListNode}  mean?"
                    },
                    {
                        "username": "chkhd",
                        "content": "I found the iterative way of solving this much neater, and easier to reason about than the recursive one.\\n\\nIn my humble opinion whole point of recursion is to make it elegant, and this one does not look at all elegant in that guise. An elegant recursive function is a pure recursive function, just like any other function.\\n"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "When we try to reverse **[1, 2, 3, 4, 5]** using while loop and two variables **previousNode** and **currentNode** it suppose to look like this:\n\n```\nLOOP 1:\npreviousNode = nil -> nil\ncurrentNode = head -> 1\n\nnextNode = currentNode?.next -> 2\ncurrentNode?.next = previousNode -> nil\npreviousNode = currentNode -> 1\ncurrentNode = nextNode -> 2\n\nLOOP 2:\npreviousNode -> 1\ncurrentNode -> 2\n\nnextNode = currentNode?.next -> 3\ncurrentNode?.next = previousNode -> 1\npreviousNode = currentNode = -> 2\ncurrentNode = nextNode -> 3\n\nLOOP 3:\npreviousNode -> 2\ncurrentNode -> 3\n\nnextNode = currentNode?.next -> 4\ncurrentNode?.next = previousNode -> 2\npreviousNode = currentNode = -> 3\ncurrentNode = nextNode -> 4\n\nLOOP 4:\npreviousNode -> 3\ncurrentNode -> 4\n\nnextNode = currentNode?.next -> 5\ncurrentNode?.next = previousNode -> 3\npreviousNode = currentNode = -> 4\ncurrentNode = nextNode -> 5\n\nLOOP 5:\npreviousNode -> 4\ncurrentNode -> 5\n\nnextNode = currentNode?.next -> nil\ncurrentNode?.next = previousNode -> 4\npreviousNode = currentNode = -> 5\ncurrentNode = nextNode -> nil\n```\n\nHope it will be helpful to visualize."
                    },
                    {
                        "username": "shivasoni8528",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL){return head;}\\n        ListNode *prev=NULL;\\n        ListNode *curr=head;\\n        ListNode *forward;\\n        while(curr){\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1774079,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/206_reverse_linked_list.cpp\\nLEAVE A STAR PLS !!!!!!"
                    },
                    {
                        "username": "ankitpatel8770",
                        "content": "Time complexity  O(n)\\nSpace complexity  O(1)\\n"
                    },
                    {
                        "username": "willjspencer10",
                        "content": "Can someone show me a link for C# ListNodes? There\\'s no documentation for it at ALL"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "upup1904",
                        "content": "Not clear from question if solution should handle the case of  circular or list with other cycles"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "two pointer technique with contanst space and linear time solution with explanation\\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3055564/js-o-n-time-o-1-space-explanation/"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;  //create a pointer that points to NULL\\n        ListNode* curr = head;  //create a pointer that points the head position \\n        ListNode* forward = NULL;  //create a pointer that we will use to store the value\\n\\n        while(curr != NULL){.     //iteration till NULL\\n            forward = curr -> next;  // Pointing forward to current\\'s next (curr->next) value (stored the value so that the list is not lost. \\n            curr->next = prev;  //pointing a node to previous \\n            prev = curr; //putting prev to curr \\'s positionn \\n            curr = forward;  \\n\\n        }\\n\\n        return prev;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "amandag14",
                        "content": "can anyone help explain why this solution (js) does not work?\\n\\nvar reverseList = function(head) {\\n    if (!head || !head.next) { return head };\\n    let res = reverseList(head.next);\\n    head.next.next = new ListNode(head.val);\\n    return res;\\n} \\n\\nmuch appreciated"
                    },
                    {
                        "username": "Spaceman31415",
                        "content": "Guys, could anyone plz explain me why this code doesn\\'t work?\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* cur = head;\\n        if (!head) return head;\\n        ListNode* next = head->next;\\n        ListNode* prev;\\n        while (next){\\n            prev = cur;\\n            cur = next;\\n            next = next->next;\\n            cur->next = prev;\\n        }\\n        return cur;\\n    }\\n};```"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think is C++, right?\\nI don\\'t really understand the language, but I think your code does not reverse the ListNode, but duplicate it. And the reason for that is... I think, an example is more efficient than any words (for me at least). \\nExample; 1->2->3->4->5\\n\\nhead == 1->2->3->4->5\\ncur    == 1->2->3->4->5\\nnext  == 2->3->4->5\\nThat before the while loop.\\nIn the first iteration, I think we must have the followings values:\\nprev  == 1->2->3->4->5\\ncur    == 2->3->4->5\\nnext  == 3->4->5\\ncur->next == 1->2->3->4->5\\nThe last line means that cur has as value:\\ncur == 2->1->2->3->4->5\\nI think, in the second iteration we will have:\\ncur == 3->2->1->2->3->4->5"
                    }
                ]
            },
            {
                "id": 1772422,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/206_reverse_linked_list.cpp\\nLEAVE A STAR PLS !!!!!!"
                    },
                    {
                        "username": "ankitpatel8770",
                        "content": "Time complexity  O(n)\\nSpace complexity  O(1)\\n"
                    },
                    {
                        "username": "willjspencer10",
                        "content": "Can someone show me a link for C# ListNodes? There\\'s no documentation for it at ALL"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "upup1904",
                        "content": "Not clear from question if solution should handle the case of  circular or list with other cycles"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "two pointer technique with contanst space and linear time solution with explanation\\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3055564/js-o-n-time-o-1-space-explanation/"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;  //create a pointer that points to NULL\\n        ListNode* curr = head;  //create a pointer that points the head position \\n        ListNode* forward = NULL;  //create a pointer that we will use to store the value\\n\\n        while(curr != NULL){.     //iteration till NULL\\n            forward = curr -> next;  // Pointing forward to current\\'s next (curr->next) value (stored the value so that the list is not lost. \\n            curr->next = prev;  //pointing a node to previous \\n            prev = curr; //putting prev to curr \\'s positionn \\n            curr = forward;  \\n\\n        }\\n\\n        return prev;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "amandag14",
                        "content": "can anyone help explain why this solution (js) does not work?\\n\\nvar reverseList = function(head) {\\n    if (!head || !head.next) { return head };\\n    let res = reverseList(head.next);\\n    head.next.next = new ListNode(head.val);\\n    return res;\\n} \\n\\nmuch appreciated"
                    },
                    {
                        "username": "Spaceman31415",
                        "content": "Guys, could anyone plz explain me why this code doesn\\'t work?\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* cur = head;\\n        if (!head) return head;\\n        ListNode* next = head->next;\\n        ListNode* prev;\\n        while (next){\\n            prev = cur;\\n            cur = next;\\n            next = next->next;\\n            cur->next = prev;\\n        }\\n        return cur;\\n    }\\n};```"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think is C++, right?\\nI don\\'t really understand the language, but I think your code does not reverse the ListNode, but duplicate it. And the reason for that is... I think, an example is more efficient than any words (for me at least). \\nExample; 1->2->3->4->5\\n\\nhead == 1->2->3->4->5\\ncur    == 1->2->3->4->5\\nnext  == 2->3->4->5\\nThat before the while loop.\\nIn the first iteration, I think we must have the followings values:\\nprev  == 1->2->3->4->5\\ncur    == 2->3->4->5\\nnext  == 3->4->5\\ncur->next == 1->2->3->4->5\\nThe last line means that cur has as value:\\ncur == 2->1->2->3->4->5\\nI think, in the second iteration we will have:\\ncur == 3->2->1->2->3->4->5"
                    }
                ]
            },
            {
                "id": 1763679,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/206_reverse_linked_list.cpp\\nLEAVE A STAR PLS !!!!!!"
                    },
                    {
                        "username": "ankitpatel8770",
                        "content": "Time complexity  O(n)\\nSpace complexity  O(1)\\n"
                    },
                    {
                        "username": "willjspencer10",
                        "content": "Can someone show me a link for C# ListNodes? There\\'s no documentation for it at ALL"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "upup1904",
                        "content": "Not clear from question if solution should handle the case of  circular or list with other cycles"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "two pointer technique with contanst space and linear time solution with explanation\\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3055564/js-o-n-time-o-1-space-explanation/"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;  //create a pointer that points to NULL\\n        ListNode* curr = head;  //create a pointer that points the head position \\n        ListNode* forward = NULL;  //create a pointer that we will use to store the value\\n\\n        while(curr != NULL){.     //iteration till NULL\\n            forward = curr -> next;  // Pointing forward to current\\'s next (curr->next) value (stored the value so that the list is not lost. \\n            curr->next = prev;  //pointing a node to previous \\n            prev = curr; //putting prev to curr \\'s positionn \\n            curr = forward;  \\n\\n        }\\n\\n        return prev;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "amandag14",
                        "content": "can anyone help explain why this solution (js) does not work?\\n\\nvar reverseList = function(head) {\\n    if (!head || !head.next) { return head };\\n    let res = reverseList(head.next);\\n    head.next.next = new ListNode(head.val);\\n    return res;\\n} \\n\\nmuch appreciated"
                    },
                    {
                        "username": "Spaceman31415",
                        "content": "Guys, could anyone plz explain me why this code doesn\\'t work?\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* cur = head;\\n        if (!head) return head;\\n        ListNode* next = head->next;\\n        ListNode* prev;\\n        while (next){\\n            prev = cur;\\n            cur = next;\\n            next = next->next;\\n            cur->next = prev;\\n        }\\n        return cur;\\n    }\\n};```"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think is C++, right?\\nI don\\'t really understand the language, but I think your code does not reverse the ListNode, but duplicate it. And the reason for that is... I think, an example is more efficient than any words (for me at least). \\nExample; 1->2->3->4->5\\n\\nhead == 1->2->3->4->5\\ncur    == 1->2->3->4->5\\nnext  == 2->3->4->5\\nThat before the while loop.\\nIn the first iteration, I think we must have the followings values:\\nprev  == 1->2->3->4->5\\ncur    == 2->3->4->5\\nnext  == 3->4->5\\ncur->next == 1->2->3->4->5\\nThe last line means that cur has as value:\\ncur == 2->1->2->3->4->5\\nI think, in the second iteration we will have:\\ncur == 3->2->1->2->3->4->5"
                    }
                ]
            },
            {
                "id": 1761832,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/206_reverse_linked_list.cpp\\nLEAVE A STAR PLS !!!!!!"
                    },
                    {
                        "username": "ankitpatel8770",
                        "content": "Time complexity  O(n)\\nSpace complexity  O(1)\\n"
                    },
                    {
                        "username": "willjspencer10",
                        "content": "Can someone show me a link for C# ListNodes? There\\'s no documentation for it at ALL"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "upup1904",
                        "content": "Not clear from question if solution should handle the case of  circular or list with other cycles"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "two pointer technique with contanst space and linear time solution with explanation\\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3055564/js-o-n-time-o-1-space-explanation/"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;  //create a pointer that points to NULL\\n        ListNode* curr = head;  //create a pointer that points the head position \\n        ListNode* forward = NULL;  //create a pointer that we will use to store the value\\n\\n        while(curr != NULL){.     //iteration till NULL\\n            forward = curr -> next;  // Pointing forward to current\\'s next (curr->next) value (stored the value so that the list is not lost. \\n            curr->next = prev;  //pointing a node to previous \\n            prev = curr; //putting prev to curr \\'s positionn \\n            curr = forward;  \\n\\n        }\\n\\n        return prev;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "amandag14",
                        "content": "can anyone help explain why this solution (js) does not work?\\n\\nvar reverseList = function(head) {\\n    if (!head || !head.next) { return head };\\n    let res = reverseList(head.next);\\n    head.next.next = new ListNode(head.val);\\n    return res;\\n} \\n\\nmuch appreciated"
                    },
                    {
                        "username": "Spaceman31415",
                        "content": "Guys, could anyone plz explain me why this code doesn\\'t work?\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* cur = head;\\n        if (!head) return head;\\n        ListNode* next = head->next;\\n        ListNode* prev;\\n        while (next){\\n            prev = cur;\\n            cur = next;\\n            next = next->next;\\n            cur->next = prev;\\n        }\\n        return cur;\\n    }\\n};```"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think is C++, right?\\nI don\\'t really understand the language, but I think your code does not reverse the ListNode, but duplicate it. And the reason for that is... I think, an example is more efficient than any words (for me at least). \\nExample; 1->2->3->4->5\\n\\nhead == 1->2->3->4->5\\ncur    == 1->2->3->4->5\\nnext  == 2->3->4->5\\nThat before the while loop.\\nIn the first iteration, I think we must have the followings values:\\nprev  == 1->2->3->4->5\\ncur    == 2->3->4->5\\nnext  == 3->4->5\\ncur->next == 1->2->3->4->5\\nThe last line means that cur has as value:\\ncur == 2->1->2->3->4->5\\nI think, in the second iteration we will have:\\ncur == 3->2->1->2->3->4->5"
                    }
                ]
            },
            {
                "id": 1760434,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/206_reverse_linked_list.cpp\\nLEAVE A STAR PLS !!!!!!"
                    },
                    {
                        "username": "ankitpatel8770",
                        "content": "Time complexity  O(n)\\nSpace complexity  O(1)\\n"
                    },
                    {
                        "username": "willjspencer10",
                        "content": "Can someone show me a link for C# ListNodes? There\\'s no documentation for it at ALL"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "upup1904",
                        "content": "Not clear from question if solution should handle the case of  circular or list with other cycles"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "two pointer technique with contanst space and linear time solution with explanation\\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3055564/js-o-n-time-o-1-space-explanation/"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;  //create a pointer that points to NULL\\n        ListNode* curr = head;  //create a pointer that points the head position \\n        ListNode* forward = NULL;  //create a pointer that we will use to store the value\\n\\n        while(curr != NULL){.     //iteration till NULL\\n            forward = curr -> next;  // Pointing forward to current\\'s next (curr->next) value (stored the value so that the list is not lost. \\n            curr->next = prev;  //pointing a node to previous \\n            prev = curr; //putting prev to curr \\'s positionn \\n            curr = forward;  \\n\\n        }\\n\\n        return prev;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "amandag14",
                        "content": "can anyone help explain why this solution (js) does not work?\\n\\nvar reverseList = function(head) {\\n    if (!head || !head.next) { return head };\\n    let res = reverseList(head.next);\\n    head.next.next = new ListNode(head.val);\\n    return res;\\n} \\n\\nmuch appreciated"
                    },
                    {
                        "username": "Spaceman31415",
                        "content": "Guys, could anyone plz explain me why this code doesn\\'t work?\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* cur = head;\\n        if (!head) return head;\\n        ListNode* next = head->next;\\n        ListNode* prev;\\n        while (next){\\n            prev = cur;\\n            cur = next;\\n            next = next->next;\\n            cur->next = prev;\\n        }\\n        return cur;\\n    }\\n};```"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think is C++, right?\\nI don\\'t really understand the language, but I think your code does not reverse the ListNode, but duplicate it. And the reason for that is... I think, an example is more efficient than any words (for me at least). \\nExample; 1->2->3->4->5\\n\\nhead == 1->2->3->4->5\\ncur    == 1->2->3->4->5\\nnext  == 2->3->4->5\\nThat before the while loop.\\nIn the first iteration, I think we must have the followings values:\\nprev  == 1->2->3->4->5\\ncur    == 2->3->4->5\\nnext  == 3->4->5\\ncur->next == 1->2->3->4->5\\nThe last line means that cur has as value:\\ncur == 2->1->2->3->4->5\\nI think, in the second iteration we will have:\\ncur == 3->2->1->2->3->4->5"
                    }
                ]
            },
            {
                "id": 1759376,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/206_reverse_linked_list.cpp\\nLEAVE A STAR PLS !!!!!!"
                    },
                    {
                        "username": "ankitpatel8770",
                        "content": "Time complexity  O(n)\\nSpace complexity  O(1)\\n"
                    },
                    {
                        "username": "willjspencer10",
                        "content": "Can someone show me a link for C# ListNodes? There\\'s no documentation for it at ALL"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "upup1904",
                        "content": "Not clear from question if solution should handle the case of  circular or list with other cycles"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "two pointer technique with contanst space and linear time solution with explanation\\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3055564/js-o-n-time-o-1-space-explanation/"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;  //create a pointer that points to NULL\\n        ListNode* curr = head;  //create a pointer that points the head position \\n        ListNode* forward = NULL;  //create a pointer that we will use to store the value\\n\\n        while(curr != NULL){.     //iteration till NULL\\n            forward = curr -> next;  // Pointing forward to current\\'s next (curr->next) value (stored the value so that the list is not lost. \\n            curr->next = prev;  //pointing a node to previous \\n            prev = curr; //putting prev to curr \\'s positionn \\n            curr = forward;  \\n\\n        }\\n\\n        return prev;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "amandag14",
                        "content": "can anyone help explain why this solution (js) does not work?\\n\\nvar reverseList = function(head) {\\n    if (!head || !head.next) { return head };\\n    let res = reverseList(head.next);\\n    head.next.next = new ListNode(head.val);\\n    return res;\\n} \\n\\nmuch appreciated"
                    },
                    {
                        "username": "Spaceman31415",
                        "content": "Guys, could anyone plz explain me why this code doesn\\'t work?\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* cur = head;\\n        if (!head) return head;\\n        ListNode* next = head->next;\\n        ListNode* prev;\\n        while (next){\\n            prev = cur;\\n            cur = next;\\n            next = next->next;\\n            cur->next = prev;\\n        }\\n        return cur;\\n    }\\n};```"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think is C++, right?\\nI don\\'t really understand the language, but I think your code does not reverse the ListNode, but duplicate it. And the reason for that is... I think, an example is more efficient than any words (for me at least). \\nExample; 1->2->3->4->5\\n\\nhead == 1->2->3->4->5\\ncur    == 1->2->3->4->5\\nnext  == 2->3->4->5\\nThat before the while loop.\\nIn the first iteration, I think we must have the followings values:\\nprev  == 1->2->3->4->5\\ncur    == 2->3->4->5\\nnext  == 3->4->5\\ncur->next == 1->2->3->4->5\\nThe last line means that cur has as value:\\ncur == 2->1->2->3->4->5\\nI think, in the second iteration we will have:\\ncur == 3->2->1->2->3->4->5"
                    }
                ]
            },
            {
                "id": 1757816,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/206_reverse_linked_list.cpp\\nLEAVE A STAR PLS !!!!!!"
                    },
                    {
                        "username": "ankitpatel8770",
                        "content": "Time complexity  O(n)\\nSpace complexity  O(1)\\n"
                    },
                    {
                        "username": "willjspencer10",
                        "content": "Can someone show me a link for C# ListNodes? There\\'s no documentation for it at ALL"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "upup1904",
                        "content": "Not clear from question if solution should handle the case of  circular or list with other cycles"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "two pointer technique with contanst space and linear time solution with explanation\\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3055564/js-o-n-time-o-1-space-explanation/"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;  //create a pointer that points to NULL\\n        ListNode* curr = head;  //create a pointer that points the head position \\n        ListNode* forward = NULL;  //create a pointer that we will use to store the value\\n\\n        while(curr != NULL){.     //iteration till NULL\\n            forward = curr -> next;  // Pointing forward to current\\'s next (curr->next) value (stored the value so that the list is not lost. \\n            curr->next = prev;  //pointing a node to previous \\n            prev = curr; //putting prev to curr \\'s positionn \\n            curr = forward;  \\n\\n        }\\n\\n        return prev;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "amandag14",
                        "content": "can anyone help explain why this solution (js) does not work?\\n\\nvar reverseList = function(head) {\\n    if (!head || !head.next) { return head };\\n    let res = reverseList(head.next);\\n    head.next.next = new ListNode(head.val);\\n    return res;\\n} \\n\\nmuch appreciated"
                    },
                    {
                        "username": "Spaceman31415",
                        "content": "Guys, could anyone plz explain me why this code doesn\\'t work?\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* cur = head;\\n        if (!head) return head;\\n        ListNode* next = head->next;\\n        ListNode* prev;\\n        while (next){\\n            prev = cur;\\n            cur = next;\\n            next = next->next;\\n            cur->next = prev;\\n        }\\n        return cur;\\n    }\\n};```"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think is C++, right?\\nI don\\'t really understand the language, but I think your code does not reverse the ListNode, but duplicate it. And the reason for that is... I think, an example is more efficient than any words (for me at least). \\nExample; 1->2->3->4->5\\n\\nhead == 1->2->3->4->5\\ncur    == 1->2->3->4->5\\nnext  == 2->3->4->5\\nThat before the while loop.\\nIn the first iteration, I think we must have the followings values:\\nprev  == 1->2->3->4->5\\ncur    == 2->3->4->5\\nnext  == 3->4->5\\ncur->next == 1->2->3->4->5\\nThe last line means that cur has as value:\\ncur == 2->1->2->3->4->5\\nI think, in the second iteration we will have:\\ncur == 3->2->1->2->3->4->5"
                    }
                ]
            },
            {
                "id": 1757024,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/206_reverse_linked_list.cpp\\nLEAVE A STAR PLS !!!!!!"
                    },
                    {
                        "username": "ankitpatel8770",
                        "content": "Time complexity  O(n)\\nSpace complexity  O(1)\\n"
                    },
                    {
                        "username": "willjspencer10",
                        "content": "Can someone show me a link for C# ListNodes? There\\'s no documentation for it at ALL"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "upup1904",
                        "content": "Not clear from question if solution should handle the case of  circular or list with other cycles"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "two pointer technique with contanst space and linear time solution with explanation\\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3055564/js-o-n-time-o-1-space-explanation/"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;  //create a pointer that points to NULL\\n        ListNode* curr = head;  //create a pointer that points the head position \\n        ListNode* forward = NULL;  //create a pointer that we will use to store the value\\n\\n        while(curr != NULL){.     //iteration till NULL\\n            forward = curr -> next;  // Pointing forward to current\\'s next (curr->next) value (stored the value so that the list is not lost. \\n            curr->next = prev;  //pointing a node to previous \\n            prev = curr; //putting prev to curr \\'s positionn \\n            curr = forward;  \\n\\n        }\\n\\n        return prev;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "amandag14",
                        "content": "can anyone help explain why this solution (js) does not work?\\n\\nvar reverseList = function(head) {\\n    if (!head || !head.next) { return head };\\n    let res = reverseList(head.next);\\n    head.next.next = new ListNode(head.val);\\n    return res;\\n} \\n\\nmuch appreciated"
                    },
                    {
                        "username": "Spaceman31415",
                        "content": "Guys, could anyone plz explain me why this code doesn\\'t work?\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* cur = head;\\n        if (!head) return head;\\n        ListNode* next = head->next;\\n        ListNode* prev;\\n        while (next){\\n            prev = cur;\\n            cur = next;\\n            next = next->next;\\n            cur->next = prev;\\n        }\\n        return cur;\\n    }\\n};```"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think is C++, right?\\nI don\\'t really understand the language, but I think your code does not reverse the ListNode, but duplicate it. And the reason for that is... I think, an example is more efficient than any words (for me at least). \\nExample; 1->2->3->4->5\\n\\nhead == 1->2->3->4->5\\ncur    == 1->2->3->4->5\\nnext  == 2->3->4->5\\nThat before the while loop.\\nIn the first iteration, I think we must have the followings values:\\nprev  == 1->2->3->4->5\\ncur    == 2->3->4->5\\nnext  == 3->4->5\\ncur->next == 1->2->3->4->5\\nThe last line means that cur has as value:\\ncur == 2->1->2->3->4->5\\nI think, in the second iteration we will have:\\ncur == 3->2->1->2->3->4->5"
                    }
                ]
            },
            {
                "id": 1755627,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/206_reverse_linked_list.cpp\\nLEAVE A STAR PLS !!!!!!"
                    },
                    {
                        "username": "ankitpatel8770",
                        "content": "Time complexity  O(n)\\nSpace complexity  O(1)\\n"
                    },
                    {
                        "username": "willjspencer10",
                        "content": "Can someone show me a link for C# ListNodes? There\\'s no documentation for it at ALL"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "upup1904",
                        "content": "Not clear from question if solution should handle the case of  circular or list with other cycles"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "two pointer technique with contanst space and linear time solution with explanation\\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3055564/js-o-n-time-o-1-space-explanation/"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;  //create a pointer that points to NULL\\n        ListNode* curr = head;  //create a pointer that points the head position \\n        ListNode* forward = NULL;  //create a pointer that we will use to store the value\\n\\n        while(curr != NULL){.     //iteration till NULL\\n            forward = curr -> next;  // Pointing forward to current\\'s next (curr->next) value (stored the value so that the list is not lost. \\n            curr->next = prev;  //pointing a node to previous \\n            prev = curr; //putting prev to curr \\'s positionn \\n            curr = forward;  \\n\\n        }\\n\\n        return prev;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "amandag14",
                        "content": "can anyone help explain why this solution (js) does not work?\\n\\nvar reverseList = function(head) {\\n    if (!head || !head.next) { return head };\\n    let res = reverseList(head.next);\\n    head.next.next = new ListNode(head.val);\\n    return res;\\n} \\n\\nmuch appreciated"
                    },
                    {
                        "username": "Spaceman31415",
                        "content": "Guys, could anyone plz explain me why this code doesn\\'t work?\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* cur = head;\\n        if (!head) return head;\\n        ListNode* next = head->next;\\n        ListNode* prev;\\n        while (next){\\n            prev = cur;\\n            cur = next;\\n            next = next->next;\\n            cur->next = prev;\\n        }\\n        return cur;\\n    }\\n};```"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think is C++, right?\\nI don\\'t really understand the language, but I think your code does not reverse the ListNode, but duplicate it. And the reason for that is... I think, an example is more efficient than any words (for me at least). \\nExample; 1->2->3->4->5\\n\\nhead == 1->2->3->4->5\\ncur    == 1->2->3->4->5\\nnext  == 2->3->4->5\\nThat before the while loop.\\nIn the first iteration, I think we must have the followings values:\\nprev  == 1->2->3->4->5\\ncur    == 2->3->4->5\\nnext  == 3->4->5\\ncur->next == 1->2->3->4->5\\nThe last line means that cur has as value:\\ncur == 2->1->2->3->4->5\\nI think, in the second iteration we will have:\\ncur == 3->2->1->2->3->4->5"
                    }
                ]
            },
            {
                "id": 1749456,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/206_reverse_linked_list.cpp\\nLEAVE A STAR PLS !!!!!!"
                    },
                    {
                        "username": "ankitpatel8770",
                        "content": "Time complexity  O(n)\\nSpace complexity  O(1)\\n"
                    },
                    {
                        "username": "willjspencer10",
                        "content": "Can someone show me a link for C# ListNodes? There\\'s no documentation for it at ALL"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "upup1904",
                        "content": "Not clear from question if solution should handle the case of  circular or list with other cycles"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "two pointer technique with contanst space and linear time solution with explanation\\n\\nhttps://leetcode.com/problems/reverse-linked-list/solutions/3055564/js-o-n-time-o-1-space-explanation/"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;  //create a pointer that points to NULL\\n        ListNode* curr = head;  //create a pointer that points the head position \\n        ListNode* forward = NULL;  //create a pointer that we will use to store the value\\n\\n        while(curr != NULL){.     //iteration till NULL\\n            forward = curr -> next;  // Pointing forward to current\\'s next (curr->next) value (stored the value so that the list is not lost. \\n            curr->next = prev;  //pointing a node to previous \\n            prev = curr; //putting prev to curr \\'s positionn \\n            curr = forward;  \\n\\n        }\\n\\n        return prev;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "amandag14",
                        "content": "can anyone help explain why this solution (js) does not work?\\n\\nvar reverseList = function(head) {\\n    if (!head || !head.next) { return head };\\n    let res = reverseList(head.next);\\n    head.next.next = new ListNode(head.val);\\n    return res;\\n} \\n\\nmuch appreciated"
                    },
                    {
                        "username": "Spaceman31415",
                        "content": "Guys, could anyone plz explain me why this code doesn\\'t work?\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* cur = head;\\n        if (!head) return head;\\n        ListNode* next = head->next;\\n        ListNode* prev;\\n        while (next){\\n            prev = cur;\\n            cur = next;\\n            next = next->next;\\n            cur->next = prev;\\n        }\\n        return cur;\\n    }\\n};```"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I think is C++, right?\\nI don\\'t really understand the language, but I think your code does not reverse the ListNode, but duplicate it. And the reason for that is... I think, an example is more efficient than any words (for me at least). \\nExample; 1->2->3->4->5\\n\\nhead == 1->2->3->4->5\\ncur    == 1->2->3->4->5\\nnext  == 2->3->4->5\\nThat before the while loop.\\nIn the first iteration, I think we must have the followings values:\\nprev  == 1->2->3->4->5\\ncur    == 2->3->4->5\\nnext  == 3->4->5\\ncur->next == 1->2->3->4->5\\nThe last line means that cur has as value:\\ncur == 2->1->2->3->4->5\\nI think, in the second iteration we will have:\\ncur == 3->2->1->2->3->4->5"
                    }
                ]
            },
            {
                "id": 1744477,
                "content": [
                    {
                        "username": "hitler_fitler",
                        "content": " `\\nif head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head\\n`"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": " `if head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Hi, I\\'ve been testing some usage on linked list, can someone tell me why this is happening? Where did the list [1,2] of the last line come from? And why is it keep throwing this error? I kind of know that I should use `if head is None` to check, but why can\\'t I use `if  head.next is None`? Thanks in advance!\\n\\n![](https://i.imgur.com/R51Ie74.png)"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@JackChen890311](/JackChen890311) \\nI think you are right. And the [1,2] are from the second test.\\nThe runtime error is because of the third test case. The head is empty."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@kukakasymov](/kukakasymov) Yes, but the while loop should break before I access a non existing node, if there is no .next value? And where did [1,2] come from?"
                    },
                    {
                        "username": "kukakasymov",
                        "content": "you are trying to access .next value of non existing variable"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "imsej_al",
                        "content": "class Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\nif(head == NULL || head->next == NULL){\\n    return head;\\n}\\n//2nd step\\nListNode* ans = reverse(head->next);\\n//3rd step\\nhead->next->next = head;\\nhead->next = NULL;\\n\\nreturn ans;\\n}\\n    ListNode* reverseList(ListNode* head) {\\n// recursive solution\\nreturn reverse(head);\\n"
                    },
                    {
                        "username": "imsej_al",
                        "content": "       //ITERATIVE Solution\\nListNode* prev = NULL;\\nListNode* curr = head;\\nwhile(curr!=NULL){\\n  ListNode* frwrd = curr->next;\\n  curr->next = prev;\\n  prev = curr;\\n  curr = frwrd;\\n \\n}    \\n  return prev;  \\n\\n"
                    },
                    {
                        "username": "rukshad198",
                        "content": "Easy "
                    },
                    {
                        "username": "user5204v",
                        "content": "Thanks for the great explnation guys, I think that for this question, what makes my interpretation failed is that we always store the result from the next call stack in a variable called reverse_head. \\n\\nThis variable is not modified during the callback, it makes sense as this is the head of the reversed list, which should alwasy be 4. \\n\\nWhat I don\\'t understnad is that how does modifiying the curr pointer in the existing call stack, leads to changes in the reverse_head ListNode. "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "https://leetcode.com/problems/reverse-linked-list/submissions\\n\\nHELP Java : When I am using (curr.next!=null ) in while Loop, it will give null pointer Runtime Error while using only (Curr!=null) it run sucessfully.\\nCan anyone pls tell me why it is given Runtime error ??"
                    },
                    {
                        "username": "truptinarvekar",
                        "content": "Reverse List using Java T.C=o(N)\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode rh=null;\\n        ListNode temp=head;\\n        while(head!=null){\\n            temp=head;\\n            head=head.next;\\n            temp.next=null;\\n            temp.next=rh;\\n            rh=temp;\\n        }\\n    return rh;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1744475,
                "content": [
                    {
                        "username": "hitler_fitler",
                        "content": " `\\nif head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head\\n`"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": " `if head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Hi, I\\'ve been testing some usage on linked list, can someone tell me why this is happening? Where did the list [1,2] of the last line come from? And why is it keep throwing this error? I kind of know that I should use `if head is None` to check, but why can\\'t I use `if  head.next is None`? Thanks in advance!\\n\\n![](https://i.imgur.com/R51Ie74.png)"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@JackChen890311](/JackChen890311) \\nI think you are right. And the [1,2] are from the second test.\\nThe runtime error is because of the third test case. The head is empty."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@kukakasymov](/kukakasymov) Yes, but the while loop should break before I access a non existing node, if there is no .next value? And where did [1,2] come from?"
                    },
                    {
                        "username": "kukakasymov",
                        "content": "you are trying to access .next value of non existing variable"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "imsej_al",
                        "content": "class Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\nif(head == NULL || head->next == NULL){\\n    return head;\\n}\\n//2nd step\\nListNode* ans = reverse(head->next);\\n//3rd step\\nhead->next->next = head;\\nhead->next = NULL;\\n\\nreturn ans;\\n}\\n    ListNode* reverseList(ListNode* head) {\\n// recursive solution\\nreturn reverse(head);\\n"
                    },
                    {
                        "username": "imsej_al",
                        "content": "       //ITERATIVE Solution\\nListNode* prev = NULL;\\nListNode* curr = head;\\nwhile(curr!=NULL){\\n  ListNode* frwrd = curr->next;\\n  curr->next = prev;\\n  prev = curr;\\n  curr = frwrd;\\n \\n}    \\n  return prev;  \\n\\n"
                    },
                    {
                        "username": "rukshad198",
                        "content": "Easy "
                    },
                    {
                        "username": "user5204v",
                        "content": "Thanks for the great explnation guys, I think that for this question, what makes my interpretation failed is that we always store the result from the next call stack in a variable called reverse_head. \\n\\nThis variable is not modified during the callback, it makes sense as this is the head of the reversed list, which should alwasy be 4. \\n\\nWhat I don\\'t understnad is that how does modifiying the curr pointer in the existing call stack, leads to changes in the reverse_head ListNode. "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "https://leetcode.com/problems/reverse-linked-list/submissions\\n\\nHELP Java : When I am using (curr.next!=null ) in while Loop, it will give null pointer Runtime Error while using only (Curr!=null) it run sucessfully.\\nCan anyone pls tell me why it is given Runtime error ??"
                    },
                    {
                        "username": "truptinarvekar",
                        "content": "Reverse List using Java T.C=o(N)\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode rh=null;\\n        ListNode temp=head;\\n        while(head!=null){\\n            temp=head;\\n            head=head.next;\\n            temp.next=null;\\n            temp.next=rh;\\n            rh=temp;\\n        }\\n    return rh;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1743975,
                "content": [
                    {
                        "username": "hitler_fitler",
                        "content": " `\\nif head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head\\n`"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": " `if head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Hi, I\\'ve been testing some usage on linked list, can someone tell me why this is happening? Where did the list [1,2] of the last line come from? And why is it keep throwing this error? I kind of know that I should use `if head is None` to check, but why can\\'t I use `if  head.next is None`? Thanks in advance!\\n\\n![](https://i.imgur.com/R51Ie74.png)"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@JackChen890311](/JackChen890311) \\nI think you are right. And the [1,2] are from the second test.\\nThe runtime error is because of the third test case. The head is empty."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@kukakasymov](/kukakasymov) Yes, but the while loop should break before I access a non existing node, if there is no .next value? And where did [1,2] come from?"
                    },
                    {
                        "username": "kukakasymov",
                        "content": "you are trying to access .next value of non existing variable"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "imsej_al",
                        "content": "class Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\nif(head == NULL || head->next == NULL){\\n    return head;\\n}\\n//2nd step\\nListNode* ans = reverse(head->next);\\n//3rd step\\nhead->next->next = head;\\nhead->next = NULL;\\n\\nreturn ans;\\n}\\n    ListNode* reverseList(ListNode* head) {\\n// recursive solution\\nreturn reverse(head);\\n"
                    },
                    {
                        "username": "imsej_al",
                        "content": "       //ITERATIVE Solution\\nListNode* prev = NULL;\\nListNode* curr = head;\\nwhile(curr!=NULL){\\n  ListNode* frwrd = curr->next;\\n  curr->next = prev;\\n  prev = curr;\\n  curr = frwrd;\\n \\n}    \\n  return prev;  \\n\\n"
                    },
                    {
                        "username": "rukshad198",
                        "content": "Easy "
                    },
                    {
                        "username": "user5204v",
                        "content": "Thanks for the great explnation guys, I think that for this question, what makes my interpretation failed is that we always store the result from the next call stack in a variable called reverse_head. \\n\\nThis variable is not modified during the callback, it makes sense as this is the head of the reversed list, which should alwasy be 4. \\n\\nWhat I don\\'t understnad is that how does modifiying the curr pointer in the existing call stack, leads to changes in the reverse_head ListNode. "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "https://leetcode.com/problems/reverse-linked-list/submissions\\n\\nHELP Java : When I am using (curr.next!=null ) in while Loop, it will give null pointer Runtime Error while using only (Curr!=null) it run sucessfully.\\nCan anyone pls tell me why it is given Runtime error ??"
                    },
                    {
                        "username": "truptinarvekar",
                        "content": "Reverse List using Java T.C=o(N)\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode rh=null;\\n        ListNode temp=head;\\n        while(head!=null){\\n            temp=head;\\n            head=head.next;\\n            temp.next=null;\\n            temp.next=rh;\\n            rh=temp;\\n        }\\n    return rh;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1735516,
                "content": [
                    {
                        "username": "hitler_fitler",
                        "content": " `\\nif head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head\\n`"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": " `if head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Hi, I\\'ve been testing some usage on linked list, can someone tell me why this is happening? Where did the list [1,2] of the last line come from? And why is it keep throwing this error? I kind of know that I should use `if head is None` to check, but why can\\'t I use `if  head.next is None`? Thanks in advance!\\n\\n![](https://i.imgur.com/R51Ie74.png)"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@JackChen890311](/JackChen890311) \\nI think you are right. And the [1,2] are from the second test.\\nThe runtime error is because of the third test case. The head is empty."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@kukakasymov](/kukakasymov) Yes, but the while loop should break before I access a non existing node, if there is no .next value? And where did [1,2] come from?"
                    },
                    {
                        "username": "kukakasymov",
                        "content": "you are trying to access .next value of non existing variable"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "imsej_al",
                        "content": "class Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\nif(head == NULL || head->next == NULL){\\n    return head;\\n}\\n//2nd step\\nListNode* ans = reverse(head->next);\\n//3rd step\\nhead->next->next = head;\\nhead->next = NULL;\\n\\nreturn ans;\\n}\\n    ListNode* reverseList(ListNode* head) {\\n// recursive solution\\nreturn reverse(head);\\n"
                    },
                    {
                        "username": "imsej_al",
                        "content": "       //ITERATIVE Solution\\nListNode* prev = NULL;\\nListNode* curr = head;\\nwhile(curr!=NULL){\\n  ListNode* frwrd = curr->next;\\n  curr->next = prev;\\n  prev = curr;\\n  curr = frwrd;\\n \\n}    \\n  return prev;  \\n\\n"
                    },
                    {
                        "username": "rukshad198",
                        "content": "Easy "
                    },
                    {
                        "username": "user5204v",
                        "content": "Thanks for the great explnation guys, I think that for this question, what makes my interpretation failed is that we always store the result from the next call stack in a variable called reverse_head. \\n\\nThis variable is not modified during the callback, it makes sense as this is the head of the reversed list, which should alwasy be 4. \\n\\nWhat I don\\'t understnad is that how does modifiying the curr pointer in the existing call stack, leads to changes in the reverse_head ListNode. "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "https://leetcode.com/problems/reverse-linked-list/submissions\\n\\nHELP Java : When I am using (curr.next!=null ) in while Loop, it will give null pointer Runtime Error while using only (Curr!=null) it run sucessfully.\\nCan anyone pls tell me why it is given Runtime error ??"
                    },
                    {
                        "username": "truptinarvekar",
                        "content": "Reverse List using Java T.C=o(N)\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode rh=null;\\n        ListNode temp=head;\\n        while(head!=null){\\n            temp=head;\\n            head=head.next;\\n            temp.next=null;\\n            temp.next=rh;\\n            rh=temp;\\n        }\\n    return rh;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1734431,
                "content": [
                    {
                        "username": "hitler_fitler",
                        "content": " `\\nif head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head\\n`"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": " `if head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Hi, I\\'ve been testing some usage on linked list, can someone tell me why this is happening? Where did the list [1,2] of the last line come from? And why is it keep throwing this error? I kind of know that I should use `if head is None` to check, but why can\\'t I use `if  head.next is None`? Thanks in advance!\\n\\n![](https://i.imgur.com/R51Ie74.png)"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@JackChen890311](/JackChen890311) \\nI think you are right. And the [1,2] are from the second test.\\nThe runtime error is because of the third test case. The head is empty."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@kukakasymov](/kukakasymov) Yes, but the while loop should break before I access a non existing node, if there is no .next value? And where did [1,2] come from?"
                    },
                    {
                        "username": "kukakasymov",
                        "content": "you are trying to access .next value of non existing variable"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "imsej_al",
                        "content": "class Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\nif(head == NULL || head->next == NULL){\\n    return head;\\n}\\n//2nd step\\nListNode* ans = reverse(head->next);\\n//3rd step\\nhead->next->next = head;\\nhead->next = NULL;\\n\\nreturn ans;\\n}\\n    ListNode* reverseList(ListNode* head) {\\n// recursive solution\\nreturn reverse(head);\\n"
                    },
                    {
                        "username": "imsej_al",
                        "content": "       //ITERATIVE Solution\\nListNode* prev = NULL;\\nListNode* curr = head;\\nwhile(curr!=NULL){\\n  ListNode* frwrd = curr->next;\\n  curr->next = prev;\\n  prev = curr;\\n  curr = frwrd;\\n \\n}    \\n  return prev;  \\n\\n"
                    },
                    {
                        "username": "rukshad198",
                        "content": "Easy "
                    },
                    {
                        "username": "user5204v",
                        "content": "Thanks for the great explnation guys, I think that for this question, what makes my interpretation failed is that we always store the result from the next call stack in a variable called reverse_head. \\n\\nThis variable is not modified during the callback, it makes sense as this is the head of the reversed list, which should alwasy be 4. \\n\\nWhat I don\\'t understnad is that how does modifiying the curr pointer in the existing call stack, leads to changes in the reverse_head ListNode. "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "https://leetcode.com/problems/reverse-linked-list/submissions\\n\\nHELP Java : When I am using (curr.next!=null ) in while Loop, it will give null pointer Runtime Error while using only (Curr!=null) it run sucessfully.\\nCan anyone pls tell me why it is given Runtime error ??"
                    },
                    {
                        "username": "truptinarvekar",
                        "content": "Reverse List using Java T.C=o(N)\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode rh=null;\\n        ListNode temp=head;\\n        while(head!=null){\\n            temp=head;\\n            head=head.next;\\n            temp.next=null;\\n            temp.next=rh;\\n            rh=temp;\\n        }\\n    return rh;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1734430,
                "content": [
                    {
                        "username": "hitler_fitler",
                        "content": " `\\nif head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head\\n`"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": " `if head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Hi, I\\'ve been testing some usage on linked list, can someone tell me why this is happening? Where did the list [1,2] of the last line come from? And why is it keep throwing this error? I kind of know that I should use `if head is None` to check, but why can\\'t I use `if  head.next is None`? Thanks in advance!\\n\\n![](https://i.imgur.com/R51Ie74.png)"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@JackChen890311](/JackChen890311) \\nI think you are right. And the [1,2] are from the second test.\\nThe runtime error is because of the third test case. The head is empty."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@kukakasymov](/kukakasymov) Yes, but the while loop should break before I access a non existing node, if there is no .next value? And where did [1,2] come from?"
                    },
                    {
                        "username": "kukakasymov",
                        "content": "you are trying to access .next value of non existing variable"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "imsej_al",
                        "content": "class Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\nif(head == NULL || head->next == NULL){\\n    return head;\\n}\\n//2nd step\\nListNode* ans = reverse(head->next);\\n//3rd step\\nhead->next->next = head;\\nhead->next = NULL;\\n\\nreturn ans;\\n}\\n    ListNode* reverseList(ListNode* head) {\\n// recursive solution\\nreturn reverse(head);\\n"
                    },
                    {
                        "username": "imsej_al",
                        "content": "       //ITERATIVE Solution\\nListNode* prev = NULL;\\nListNode* curr = head;\\nwhile(curr!=NULL){\\n  ListNode* frwrd = curr->next;\\n  curr->next = prev;\\n  prev = curr;\\n  curr = frwrd;\\n \\n}    \\n  return prev;  \\n\\n"
                    },
                    {
                        "username": "rukshad198",
                        "content": "Easy "
                    },
                    {
                        "username": "user5204v",
                        "content": "Thanks for the great explnation guys, I think that for this question, what makes my interpretation failed is that we always store the result from the next call stack in a variable called reverse_head. \\n\\nThis variable is not modified during the callback, it makes sense as this is the head of the reversed list, which should alwasy be 4. \\n\\nWhat I don\\'t understnad is that how does modifiying the curr pointer in the existing call stack, leads to changes in the reverse_head ListNode. "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "https://leetcode.com/problems/reverse-linked-list/submissions\\n\\nHELP Java : When I am using (curr.next!=null ) in while Loop, it will give null pointer Runtime Error while using only (Curr!=null) it run sucessfully.\\nCan anyone pls tell me why it is given Runtime error ??"
                    },
                    {
                        "username": "truptinarvekar",
                        "content": "Reverse List using Java T.C=o(N)\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode rh=null;\\n        ListNode temp=head;\\n        while(head!=null){\\n            temp=head;\\n            head=head.next;\\n            temp.next=null;\\n            temp.next=rh;\\n            rh=temp;\\n        }\\n    return rh;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1733372,
                "content": [
                    {
                        "username": "hitler_fitler",
                        "content": " `\\nif head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head\\n`"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": " `if head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Hi, I\\'ve been testing some usage on linked list, can someone tell me why this is happening? Where did the list [1,2] of the last line come from? And why is it keep throwing this error? I kind of know that I should use `if head is None` to check, but why can\\'t I use `if  head.next is None`? Thanks in advance!\\n\\n![](https://i.imgur.com/R51Ie74.png)"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@JackChen890311](/JackChen890311) \\nI think you are right. And the [1,2] are from the second test.\\nThe runtime error is because of the third test case. The head is empty."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@kukakasymov](/kukakasymov) Yes, but the while loop should break before I access a non existing node, if there is no .next value? And where did [1,2] come from?"
                    },
                    {
                        "username": "kukakasymov",
                        "content": "you are trying to access .next value of non existing variable"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "imsej_al",
                        "content": "class Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\nif(head == NULL || head->next == NULL){\\n    return head;\\n}\\n//2nd step\\nListNode* ans = reverse(head->next);\\n//3rd step\\nhead->next->next = head;\\nhead->next = NULL;\\n\\nreturn ans;\\n}\\n    ListNode* reverseList(ListNode* head) {\\n// recursive solution\\nreturn reverse(head);\\n"
                    },
                    {
                        "username": "imsej_al",
                        "content": "       //ITERATIVE Solution\\nListNode* prev = NULL;\\nListNode* curr = head;\\nwhile(curr!=NULL){\\n  ListNode* frwrd = curr->next;\\n  curr->next = prev;\\n  prev = curr;\\n  curr = frwrd;\\n \\n}    \\n  return prev;  \\n\\n"
                    },
                    {
                        "username": "rukshad198",
                        "content": "Easy "
                    },
                    {
                        "username": "user5204v",
                        "content": "Thanks for the great explnation guys, I think that for this question, what makes my interpretation failed is that we always store the result from the next call stack in a variable called reverse_head. \\n\\nThis variable is not modified during the callback, it makes sense as this is the head of the reversed list, which should alwasy be 4. \\n\\nWhat I don\\'t understnad is that how does modifiying the curr pointer in the existing call stack, leads to changes in the reverse_head ListNode. "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "https://leetcode.com/problems/reverse-linked-list/submissions\\n\\nHELP Java : When I am using (curr.next!=null ) in while Loop, it will give null pointer Runtime Error while using only (Curr!=null) it run sucessfully.\\nCan anyone pls tell me why it is given Runtime error ??"
                    },
                    {
                        "username": "truptinarvekar",
                        "content": "Reverse List using Java T.C=o(N)\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode rh=null;\\n        ListNode temp=head;\\n        while(head!=null){\\n            temp=head;\\n            head=head.next;\\n            temp.next=null;\\n            temp.next=rh;\\n            rh=temp;\\n        }\\n    return rh;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1731554,
                "content": [
                    {
                        "username": "hitler_fitler",
                        "content": " `\\nif head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head\\n`"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": " `if head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Hi, I\\'ve been testing some usage on linked list, can someone tell me why this is happening? Where did the list [1,2] of the last line come from? And why is it keep throwing this error? I kind of know that I should use `if head is None` to check, but why can\\'t I use `if  head.next is None`? Thanks in advance!\\n\\n![](https://i.imgur.com/R51Ie74.png)"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@JackChen890311](/JackChen890311) \\nI think you are right. And the [1,2] are from the second test.\\nThe runtime error is because of the third test case. The head is empty."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@kukakasymov](/kukakasymov) Yes, but the while loop should break before I access a non existing node, if there is no .next value? And where did [1,2] come from?"
                    },
                    {
                        "username": "kukakasymov",
                        "content": "you are trying to access .next value of non existing variable"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "imsej_al",
                        "content": "class Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\nif(head == NULL || head->next == NULL){\\n    return head;\\n}\\n//2nd step\\nListNode* ans = reverse(head->next);\\n//3rd step\\nhead->next->next = head;\\nhead->next = NULL;\\n\\nreturn ans;\\n}\\n    ListNode* reverseList(ListNode* head) {\\n// recursive solution\\nreturn reverse(head);\\n"
                    },
                    {
                        "username": "imsej_al",
                        "content": "       //ITERATIVE Solution\\nListNode* prev = NULL;\\nListNode* curr = head;\\nwhile(curr!=NULL){\\n  ListNode* frwrd = curr->next;\\n  curr->next = prev;\\n  prev = curr;\\n  curr = frwrd;\\n \\n}    \\n  return prev;  \\n\\n"
                    },
                    {
                        "username": "rukshad198",
                        "content": "Easy "
                    },
                    {
                        "username": "user5204v",
                        "content": "Thanks for the great explnation guys, I think that for this question, what makes my interpretation failed is that we always store the result from the next call stack in a variable called reverse_head. \\n\\nThis variable is not modified during the callback, it makes sense as this is the head of the reversed list, which should alwasy be 4. \\n\\nWhat I don\\'t understnad is that how does modifiying the curr pointer in the existing call stack, leads to changes in the reverse_head ListNode. "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "https://leetcode.com/problems/reverse-linked-list/submissions\\n\\nHELP Java : When I am using (curr.next!=null ) in while Loop, it will give null pointer Runtime Error while using only (Curr!=null) it run sucessfully.\\nCan anyone pls tell me why it is given Runtime error ??"
                    },
                    {
                        "username": "truptinarvekar",
                        "content": "Reverse List using Java T.C=o(N)\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode rh=null;\\n        ListNode temp=head;\\n        while(head!=null){\\n            temp=head;\\n            head=head.next;\\n            temp.next=null;\\n            temp.next=rh;\\n            rh=temp;\\n        }\\n    return rh;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1731483,
                "content": [
                    {
                        "username": "hitler_fitler",
                        "content": " `\\nif head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head\\n`"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": " `if head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Hi, I\\'ve been testing some usage on linked list, can someone tell me why this is happening? Where did the list [1,2] of the last line come from? And why is it keep throwing this error? I kind of know that I should use `if head is None` to check, but why can\\'t I use `if  head.next is None`? Thanks in advance!\\n\\n![](https://i.imgur.com/R51Ie74.png)"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@JackChen890311](/JackChen890311) \\nI think you are right. And the [1,2] are from the second test.\\nThe runtime error is because of the third test case. The head is empty."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@kukakasymov](/kukakasymov) Yes, but the while loop should break before I access a non existing node, if there is no .next value? And where did [1,2] come from?"
                    },
                    {
                        "username": "kukakasymov",
                        "content": "you are trying to access .next value of non existing variable"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "imsej_al",
                        "content": "class Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\nif(head == NULL || head->next == NULL){\\n    return head;\\n}\\n//2nd step\\nListNode* ans = reverse(head->next);\\n//3rd step\\nhead->next->next = head;\\nhead->next = NULL;\\n\\nreturn ans;\\n}\\n    ListNode* reverseList(ListNode* head) {\\n// recursive solution\\nreturn reverse(head);\\n"
                    },
                    {
                        "username": "imsej_al",
                        "content": "       //ITERATIVE Solution\\nListNode* prev = NULL;\\nListNode* curr = head;\\nwhile(curr!=NULL){\\n  ListNode* frwrd = curr->next;\\n  curr->next = prev;\\n  prev = curr;\\n  curr = frwrd;\\n \\n}    \\n  return prev;  \\n\\n"
                    },
                    {
                        "username": "rukshad198",
                        "content": "Easy "
                    },
                    {
                        "username": "user5204v",
                        "content": "Thanks for the great explnation guys, I think that for this question, what makes my interpretation failed is that we always store the result from the next call stack in a variable called reverse_head. \\n\\nThis variable is not modified during the callback, it makes sense as this is the head of the reversed list, which should alwasy be 4. \\n\\nWhat I don\\'t understnad is that how does modifiying the curr pointer in the existing call stack, leads to changes in the reverse_head ListNode. "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "https://leetcode.com/problems/reverse-linked-list/submissions\\n\\nHELP Java : When I am using (curr.next!=null ) in while Loop, it will give null pointer Runtime Error while using only (Curr!=null) it run sucessfully.\\nCan anyone pls tell me why it is given Runtime error ??"
                    },
                    {
                        "username": "truptinarvekar",
                        "content": "Reverse List using Java T.C=o(N)\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode rh=null;\\n        ListNode temp=head;\\n        while(head!=null){\\n            temp=head;\\n            head=head.next;\\n            temp.next=null;\\n            temp.next=rh;\\n            rh=temp;\\n        }\\n    return rh;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1727888,
                "content": [
                    {
                        "username": "hitler_fitler",
                        "content": " `\\nif head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head\\n`"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": " `if head == None:\\n            return None\\n\\n        p = head\\n        while p.next:\\n            n = p.next\\n            p.next = n.next\\n            n.next = head\\n            head = n\\n\\n        return head`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Hi, I\\'ve been testing some usage on linked list, can someone tell me why this is happening? Where did the list [1,2] of the last line come from? And why is it keep throwing this error? I kind of know that I should use `if head is None` to check, but why can\\'t I use `if  head.next is None`? Thanks in advance!\\n\\n![](https://i.imgur.com/R51Ie74.png)"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@JackChen890311](/JackChen890311) \\nI think you are right. And the [1,2] are from the second test.\\nThe runtime error is because of the third test case. The head is empty."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@kukakasymov](/kukakasymov) Yes, but the while loop should break before I access a non existing node, if there is no .next value? And where did [1,2] come from?"
                    },
                    {
                        "username": "kukakasymov",
                        "content": "you are trying to access .next value of non existing variable"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/reverse-linked-list-leet-code-206/"
                    },
                    {
                        "username": "imsej_al",
                        "content": "class Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\nif(head == NULL || head->next == NULL){\\n    return head;\\n}\\n//2nd step\\nListNode* ans = reverse(head->next);\\n//3rd step\\nhead->next->next = head;\\nhead->next = NULL;\\n\\nreturn ans;\\n}\\n    ListNode* reverseList(ListNode* head) {\\n// recursive solution\\nreturn reverse(head);\\n"
                    },
                    {
                        "username": "imsej_al",
                        "content": "       //ITERATIVE Solution\\nListNode* prev = NULL;\\nListNode* curr = head;\\nwhile(curr!=NULL){\\n  ListNode* frwrd = curr->next;\\n  curr->next = prev;\\n  prev = curr;\\n  curr = frwrd;\\n \\n}    \\n  return prev;  \\n\\n"
                    },
                    {
                        "username": "rukshad198",
                        "content": "Easy "
                    },
                    {
                        "username": "user5204v",
                        "content": "Thanks for the great explnation guys, I think that for this question, what makes my interpretation failed is that we always store the result from the next call stack in a variable called reverse_head. \\n\\nThis variable is not modified during the callback, it makes sense as this is the head of the reversed list, which should alwasy be 4. \\n\\nWhat I don\\'t understnad is that how does modifiying the curr pointer in the existing call stack, leads to changes in the reverse_head ListNode. "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "https://leetcode.com/problems/reverse-linked-list/submissions\\n\\nHELP Java : When I am using (curr.next!=null ) in while Loop, it will give null pointer Runtime Error while using only (Curr!=null) it run sucessfully.\\nCan anyone pls tell me why it is given Runtime error ??"
                    },
                    {
                        "username": "truptinarvekar",
                        "content": "Reverse List using Java T.C=o(N)\\n\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode rh=null;\\n        ListNode temp=head;\\n        while(head!=null){\\n            temp=head;\\n            head=head.next;\\n            temp.next=null;\\n            temp.next=rh;\\n            rh=temp;\\n        }\\n    return rh;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1726366,
                "content": [
                    {
                        "username": "ozigun1988",
                        "content": "reverse() function doesn work. but when i try it in my console its ok. i dont know why"
                    },
                    {
                        "username": "wle",
                        "content": "Really cannot wrap my head around the recursive function:\\nwhy simply line  p = self.reverseList(head.next) is able to reverse the rest of the nodes?? It looks like it does not do anything until the head of head.next is null. Please help.. I am feeling stupid"
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "There\\'s no way that itself can reverse the entire node. Recursive functions need stop conditions. What was the full context of the code?"
                    },
                    {
                        "username": "mia_mi",
                        "content": "Hi, is there anyone who could kindly explain why the while loop goes forever in my code?\\n\\n        tmp = currpoint = head\\n        reverse = None\\n        \\n        while tmp:\\n            currpoint = tmp\\n            currpoint.next = reverse\\n            reverse = currpoint\\n            tmp = tmp.next\\n\\n        return reverse\\n\\nI have no idea what\\'s going on. I believe the tmp became circular in some way, but cannot get an idea why this happens."
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "Hey [@mia_mi](/mia_mi), tmp is assigned to be both `currpoint` and `head`. As such, I imagine whenever you update `currpoint`, `tmp` updates its value to ressemble `currpoint` as well. Try printing the contents of tmp and current point after `reverse = currpoint` and see if `tmp` and `currpoint` are indeed the same."
                    },
                    {
                        "username": "rv4474990",
                        "content": "Just Use two extra pointers of Node type. Initially assign them as NULL and use tricky replacement among these pointers and head.\\nThats all...."
                    },
                    {
                        "username": "seifsoliman",
                        "content": "class Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        x = []\\n        while(head):\\n            x.append(head.val)\\n            head = head.next\\n        y = z = ListNode(0)\\n        for i in x[-1::-1]:\\n            y.next = ListNode(i)\\n            y = y.next\\n        return z.next"
                    },
                    {
                        "username": "prashast_chugh",
                        "content": "My code runs perfectly on my compiler but it is showing \"java.util.EmptyStackException\" on line 7 \"head = stack.pop();\". Please help\\n\\n\\npublic static ListNode reverseList(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        while(head != null){\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        head = stack.pop();\\n        ListNode t = head;\\n        while(!stack.isEmpty()){\\n            t.next = stack.pop();\\n            t = t.next;\\n        }\\n        t.next = null;\\n        return head;\\n    }"
                    },
                    {
                        "username": "user6957Vg",
                        "content": "add an \"if statement\" to check for empty stack before \"head = stack.pop()\" as the stack will be empty if the input list is empty"
                    },
                    {
                        "username": "Fluentee",
                        "content": "When giving an empty list case, `stack.pop()` will fail.\nSo, before using `pop()` method, maybe you should add an `if` statement. \n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        // return null if head is null\n        if (head == null) return null;\n        // add type: ListNode to Stack\n        Stack<ListNode> stack = new Stack<>(); \n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        head = stack.pop();\n        ListNode t = head;\n        while(!stack.isEmpty()){\n            t.next = stack.pop();\n            t = t.next;\n        }\n        t.next = null;\n        return head;\n    }\n}\n```"
                    },
                    {
                        "username": "priyanshusingh2800",
                        "content": "rem=0;\\nm=a%10;\\nrem=rem*10+m;\\na=a/10;\\n"
                    },
                    {
                        "username": "Fluentee",
                        "content": "I don\\'t know what\\'s wrong with my solution, I need help!\\n ```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        stack<ListNode*> stk;\\n        auto temp = head;\\n        while (temp != nullptr) {\\n            stk.push(temp);\\n            temp = temp->next;\\n        }\\n        auto ptr = head;\\n        while (!stk.empty()) { \\n            ptr->next = stk.top();\\n            stk.pop();\\n            ptr = ptr->next;\\n        }\\n        ptr->next = nullptr;\\n        return head->next;\\n    }\\n};\\n/*\\nLine 26: Char 14: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:35:14\\n*/\\n```"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy C++ solution \nTime complexity - O(n)\nSpace complexity - O(1)\n\nListNode* reverseList(ListNode* head) {\n        \n        ListNode* prev = NULL ;\n        ListNode* curr = head ;\n        ListNode* forward = NULL ;\n       \n       while( curr != NULL ){\n            forward = curr -> next ;\n            curr -> next = prev ;\n            prev = curr ;\n            curr = forward ;\n        }\n        return prev ;"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n    ListNode*p=head;\\n    ListNode*q=NULL;\\n    ListNode*r=NULL;\\n    while(p!=NULL)\\n    {\\n    r=q;\\n    q=p;\\n  p=p->next;\\n   q->next=r;\\n    }    \\n    head=q;\\n    return head;\\n    }\\n};\\nso this concept involves sliding pointers where r moves to q .q moves to p and p moves to next node and q will be pointing back on the previous address basically previous loop and finally head will be pointed on q making it the first node"
                    }
                ]
            },
            {
                "id": 1723988,
                "content": [
                    {
                        "username": "ozigun1988",
                        "content": "reverse() function doesn work. but when i try it in my console its ok. i dont know why"
                    },
                    {
                        "username": "wle",
                        "content": "Really cannot wrap my head around the recursive function:\\nwhy simply line  p = self.reverseList(head.next) is able to reverse the rest of the nodes?? It looks like it does not do anything until the head of head.next is null. Please help.. I am feeling stupid"
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "There\\'s no way that itself can reverse the entire node. Recursive functions need stop conditions. What was the full context of the code?"
                    },
                    {
                        "username": "mia_mi",
                        "content": "Hi, is there anyone who could kindly explain why the while loop goes forever in my code?\\n\\n        tmp = currpoint = head\\n        reverse = None\\n        \\n        while tmp:\\n            currpoint = tmp\\n            currpoint.next = reverse\\n            reverse = currpoint\\n            tmp = tmp.next\\n\\n        return reverse\\n\\nI have no idea what\\'s going on. I believe the tmp became circular in some way, but cannot get an idea why this happens."
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "Hey [@mia_mi](/mia_mi), tmp is assigned to be both `currpoint` and `head`. As such, I imagine whenever you update `currpoint`, `tmp` updates its value to ressemble `currpoint` as well. Try printing the contents of tmp and current point after `reverse = currpoint` and see if `tmp` and `currpoint` are indeed the same."
                    },
                    {
                        "username": "rv4474990",
                        "content": "Just Use two extra pointers of Node type. Initially assign them as NULL and use tricky replacement among these pointers and head.\\nThats all...."
                    },
                    {
                        "username": "seifsoliman",
                        "content": "class Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        x = []\\n        while(head):\\n            x.append(head.val)\\n            head = head.next\\n        y = z = ListNode(0)\\n        for i in x[-1::-1]:\\n            y.next = ListNode(i)\\n            y = y.next\\n        return z.next"
                    },
                    {
                        "username": "prashast_chugh",
                        "content": "My code runs perfectly on my compiler but it is showing \"java.util.EmptyStackException\" on line 7 \"head = stack.pop();\". Please help\\n\\n\\npublic static ListNode reverseList(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        while(head != null){\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        head = stack.pop();\\n        ListNode t = head;\\n        while(!stack.isEmpty()){\\n            t.next = stack.pop();\\n            t = t.next;\\n        }\\n        t.next = null;\\n        return head;\\n    }"
                    },
                    {
                        "username": "user6957Vg",
                        "content": "add an \"if statement\" to check for empty stack before \"head = stack.pop()\" as the stack will be empty if the input list is empty"
                    },
                    {
                        "username": "Fluentee",
                        "content": "When giving an empty list case, `stack.pop()` will fail.\nSo, before using `pop()` method, maybe you should add an `if` statement. \n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        // return null if head is null\n        if (head == null) return null;\n        // add type: ListNode to Stack\n        Stack<ListNode> stack = new Stack<>(); \n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        head = stack.pop();\n        ListNode t = head;\n        while(!stack.isEmpty()){\n            t.next = stack.pop();\n            t = t.next;\n        }\n        t.next = null;\n        return head;\n    }\n}\n```"
                    },
                    {
                        "username": "priyanshusingh2800",
                        "content": "rem=0;\\nm=a%10;\\nrem=rem*10+m;\\na=a/10;\\n"
                    },
                    {
                        "username": "Fluentee",
                        "content": "I don\\'t know what\\'s wrong with my solution, I need help!\\n ```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        stack<ListNode*> stk;\\n        auto temp = head;\\n        while (temp != nullptr) {\\n            stk.push(temp);\\n            temp = temp->next;\\n        }\\n        auto ptr = head;\\n        while (!stk.empty()) { \\n            ptr->next = stk.top();\\n            stk.pop();\\n            ptr = ptr->next;\\n        }\\n        ptr->next = nullptr;\\n        return head->next;\\n    }\\n};\\n/*\\nLine 26: Char 14: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:35:14\\n*/\\n```"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy C++ solution \nTime complexity - O(n)\nSpace complexity - O(1)\n\nListNode* reverseList(ListNode* head) {\n        \n        ListNode* prev = NULL ;\n        ListNode* curr = head ;\n        ListNode* forward = NULL ;\n       \n       while( curr != NULL ){\n            forward = curr -> next ;\n            curr -> next = prev ;\n            prev = curr ;\n            curr = forward ;\n        }\n        return prev ;"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n    ListNode*p=head;\\n    ListNode*q=NULL;\\n    ListNode*r=NULL;\\n    while(p!=NULL)\\n    {\\n    r=q;\\n    q=p;\\n  p=p->next;\\n   q->next=r;\\n    }    \\n    head=q;\\n    return head;\\n    }\\n};\\nso this concept involves sliding pointers where r moves to q .q moves to p and p moves to next node and q will be pointing back on the previous address basically previous loop and finally head will be pointed on q making it the first node"
                    }
                ]
            },
            {
                "id": 1722768,
                "content": [
                    {
                        "username": "ozigun1988",
                        "content": "reverse() function doesn work. but when i try it in my console its ok. i dont know why"
                    },
                    {
                        "username": "wle",
                        "content": "Really cannot wrap my head around the recursive function:\\nwhy simply line  p = self.reverseList(head.next) is able to reverse the rest of the nodes?? It looks like it does not do anything until the head of head.next is null. Please help.. I am feeling stupid"
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "There\\'s no way that itself can reverse the entire node. Recursive functions need stop conditions. What was the full context of the code?"
                    },
                    {
                        "username": "mia_mi",
                        "content": "Hi, is there anyone who could kindly explain why the while loop goes forever in my code?\\n\\n        tmp = currpoint = head\\n        reverse = None\\n        \\n        while tmp:\\n            currpoint = tmp\\n            currpoint.next = reverse\\n            reverse = currpoint\\n            tmp = tmp.next\\n\\n        return reverse\\n\\nI have no idea what\\'s going on. I believe the tmp became circular in some way, but cannot get an idea why this happens."
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "Hey [@mia_mi](/mia_mi), tmp is assigned to be both `currpoint` and `head`. As such, I imagine whenever you update `currpoint`, `tmp` updates its value to ressemble `currpoint` as well. Try printing the contents of tmp and current point after `reverse = currpoint` and see if `tmp` and `currpoint` are indeed the same."
                    },
                    {
                        "username": "rv4474990",
                        "content": "Just Use two extra pointers of Node type. Initially assign them as NULL and use tricky replacement among these pointers and head.\\nThats all...."
                    },
                    {
                        "username": "seifsoliman",
                        "content": "class Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        x = []\\n        while(head):\\n            x.append(head.val)\\n            head = head.next\\n        y = z = ListNode(0)\\n        for i in x[-1::-1]:\\n            y.next = ListNode(i)\\n            y = y.next\\n        return z.next"
                    },
                    {
                        "username": "prashast_chugh",
                        "content": "My code runs perfectly on my compiler but it is showing \"java.util.EmptyStackException\" on line 7 \"head = stack.pop();\". Please help\\n\\n\\npublic static ListNode reverseList(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        while(head != null){\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        head = stack.pop();\\n        ListNode t = head;\\n        while(!stack.isEmpty()){\\n            t.next = stack.pop();\\n            t = t.next;\\n        }\\n        t.next = null;\\n        return head;\\n    }"
                    },
                    {
                        "username": "user6957Vg",
                        "content": "add an \"if statement\" to check for empty stack before \"head = stack.pop()\" as the stack will be empty if the input list is empty"
                    },
                    {
                        "username": "Fluentee",
                        "content": "When giving an empty list case, `stack.pop()` will fail.\nSo, before using `pop()` method, maybe you should add an `if` statement. \n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        // return null if head is null\n        if (head == null) return null;\n        // add type: ListNode to Stack\n        Stack<ListNode> stack = new Stack<>(); \n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        head = stack.pop();\n        ListNode t = head;\n        while(!stack.isEmpty()){\n            t.next = stack.pop();\n            t = t.next;\n        }\n        t.next = null;\n        return head;\n    }\n}\n```"
                    },
                    {
                        "username": "priyanshusingh2800",
                        "content": "rem=0;\\nm=a%10;\\nrem=rem*10+m;\\na=a/10;\\n"
                    },
                    {
                        "username": "Fluentee",
                        "content": "I don\\'t know what\\'s wrong with my solution, I need help!\\n ```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        stack<ListNode*> stk;\\n        auto temp = head;\\n        while (temp != nullptr) {\\n            stk.push(temp);\\n            temp = temp->next;\\n        }\\n        auto ptr = head;\\n        while (!stk.empty()) { \\n            ptr->next = stk.top();\\n            stk.pop();\\n            ptr = ptr->next;\\n        }\\n        ptr->next = nullptr;\\n        return head->next;\\n    }\\n};\\n/*\\nLine 26: Char 14: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:35:14\\n*/\\n```"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy C++ solution \nTime complexity - O(n)\nSpace complexity - O(1)\n\nListNode* reverseList(ListNode* head) {\n        \n        ListNode* prev = NULL ;\n        ListNode* curr = head ;\n        ListNode* forward = NULL ;\n       \n       while( curr != NULL ){\n            forward = curr -> next ;\n            curr -> next = prev ;\n            prev = curr ;\n            curr = forward ;\n        }\n        return prev ;"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n    ListNode*p=head;\\n    ListNode*q=NULL;\\n    ListNode*r=NULL;\\n    while(p!=NULL)\\n    {\\n    r=q;\\n    q=p;\\n  p=p->next;\\n   q->next=r;\\n    }    \\n    head=q;\\n    return head;\\n    }\\n};\\nso this concept involves sliding pointers where r moves to q .q moves to p and p moves to next node and q will be pointing back on the previous address basically previous loop and finally head will be pointed on q making it the first node"
                    }
                ]
            },
            {
                "id": 1717479,
                "content": [
                    {
                        "username": "ozigun1988",
                        "content": "reverse() function doesn work. but when i try it in my console its ok. i dont know why"
                    },
                    {
                        "username": "wle",
                        "content": "Really cannot wrap my head around the recursive function:\\nwhy simply line  p = self.reverseList(head.next) is able to reverse the rest of the nodes?? It looks like it does not do anything until the head of head.next is null. Please help.. I am feeling stupid"
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "There\\'s no way that itself can reverse the entire node. Recursive functions need stop conditions. What was the full context of the code?"
                    },
                    {
                        "username": "mia_mi",
                        "content": "Hi, is there anyone who could kindly explain why the while loop goes forever in my code?\\n\\n        tmp = currpoint = head\\n        reverse = None\\n        \\n        while tmp:\\n            currpoint = tmp\\n            currpoint.next = reverse\\n            reverse = currpoint\\n            tmp = tmp.next\\n\\n        return reverse\\n\\nI have no idea what\\'s going on. I believe the tmp became circular in some way, but cannot get an idea why this happens."
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "Hey [@mia_mi](/mia_mi), tmp is assigned to be both `currpoint` and `head`. As such, I imagine whenever you update `currpoint`, `tmp` updates its value to ressemble `currpoint` as well. Try printing the contents of tmp and current point after `reverse = currpoint` and see if `tmp` and `currpoint` are indeed the same."
                    },
                    {
                        "username": "rv4474990",
                        "content": "Just Use two extra pointers of Node type. Initially assign them as NULL and use tricky replacement among these pointers and head.\\nThats all...."
                    },
                    {
                        "username": "seifsoliman",
                        "content": "class Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        x = []\\n        while(head):\\n            x.append(head.val)\\n            head = head.next\\n        y = z = ListNode(0)\\n        for i in x[-1::-1]:\\n            y.next = ListNode(i)\\n            y = y.next\\n        return z.next"
                    },
                    {
                        "username": "prashast_chugh",
                        "content": "My code runs perfectly on my compiler but it is showing \"java.util.EmptyStackException\" on line 7 \"head = stack.pop();\". Please help\\n\\n\\npublic static ListNode reverseList(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        while(head != null){\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        head = stack.pop();\\n        ListNode t = head;\\n        while(!stack.isEmpty()){\\n            t.next = stack.pop();\\n            t = t.next;\\n        }\\n        t.next = null;\\n        return head;\\n    }"
                    },
                    {
                        "username": "user6957Vg",
                        "content": "add an \"if statement\" to check for empty stack before \"head = stack.pop()\" as the stack will be empty if the input list is empty"
                    },
                    {
                        "username": "Fluentee",
                        "content": "When giving an empty list case, `stack.pop()` will fail.\nSo, before using `pop()` method, maybe you should add an `if` statement. \n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        // return null if head is null\n        if (head == null) return null;\n        // add type: ListNode to Stack\n        Stack<ListNode> stack = new Stack<>(); \n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        head = stack.pop();\n        ListNode t = head;\n        while(!stack.isEmpty()){\n            t.next = stack.pop();\n            t = t.next;\n        }\n        t.next = null;\n        return head;\n    }\n}\n```"
                    },
                    {
                        "username": "priyanshusingh2800",
                        "content": "rem=0;\\nm=a%10;\\nrem=rem*10+m;\\na=a/10;\\n"
                    },
                    {
                        "username": "Fluentee",
                        "content": "I don\\'t know what\\'s wrong with my solution, I need help!\\n ```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        stack<ListNode*> stk;\\n        auto temp = head;\\n        while (temp != nullptr) {\\n            stk.push(temp);\\n            temp = temp->next;\\n        }\\n        auto ptr = head;\\n        while (!stk.empty()) { \\n            ptr->next = stk.top();\\n            stk.pop();\\n            ptr = ptr->next;\\n        }\\n        ptr->next = nullptr;\\n        return head->next;\\n    }\\n};\\n/*\\nLine 26: Char 14: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:35:14\\n*/\\n```"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy C++ solution \nTime complexity - O(n)\nSpace complexity - O(1)\n\nListNode* reverseList(ListNode* head) {\n        \n        ListNode* prev = NULL ;\n        ListNode* curr = head ;\n        ListNode* forward = NULL ;\n       \n       while( curr != NULL ){\n            forward = curr -> next ;\n            curr -> next = prev ;\n            prev = curr ;\n            curr = forward ;\n        }\n        return prev ;"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n    ListNode*p=head;\\n    ListNode*q=NULL;\\n    ListNode*r=NULL;\\n    while(p!=NULL)\\n    {\\n    r=q;\\n    q=p;\\n  p=p->next;\\n   q->next=r;\\n    }    \\n    head=q;\\n    return head;\\n    }\\n};\\nso this concept involves sliding pointers where r moves to q .q moves to p and p moves to next node and q will be pointing back on the previous address basically previous loop and finally head will be pointed on q making it the first node"
                    }
                ]
            },
            {
                "id": 1716479,
                "content": [
                    {
                        "username": "ozigun1988",
                        "content": "reverse() function doesn work. but when i try it in my console its ok. i dont know why"
                    },
                    {
                        "username": "wle",
                        "content": "Really cannot wrap my head around the recursive function:\\nwhy simply line  p = self.reverseList(head.next) is able to reverse the rest of the nodes?? It looks like it does not do anything until the head of head.next is null. Please help.. I am feeling stupid"
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "There\\'s no way that itself can reverse the entire node. Recursive functions need stop conditions. What was the full context of the code?"
                    },
                    {
                        "username": "mia_mi",
                        "content": "Hi, is there anyone who could kindly explain why the while loop goes forever in my code?\\n\\n        tmp = currpoint = head\\n        reverse = None\\n        \\n        while tmp:\\n            currpoint = tmp\\n            currpoint.next = reverse\\n            reverse = currpoint\\n            tmp = tmp.next\\n\\n        return reverse\\n\\nI have no idea what\\'s going on. I believe the tmp became circular in some way, but cannot get an idea why this happens."
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "Hey [@mia_mi](/mia_mi), tmp is assigned to be both `currpoint` and `head`. As such, I imagine whenever you update `currpoint`, `tmp` updates its value to ressemble `currpoint` as well. Try printing the contents of tmp and current point after `reverse = currpoint` and see if `tmp` and `currpoint` are indeed the same."
                    },
                    {
                        "username": "rv4474990",
                        "content": "Just Use two extra pointers of Node type. Initially assign them as NULL and use tricky replacement among these pointers and head.\\nThats all...."
                    },
                    {
                        "username": "seifsoliman",
                        "content": "class Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        x = []\\n        while(head):\\n            x.append(head.val)\\n            head = head.next\\n        y = z = ListNode(0)\\n        for i in x[-1::-1]:\\n            y.next = ListNode(i)\\n            y = y.next\\n        return z.next"
                    },
                    {
                        "username": "prashast_chugh",
                        "content": "My code runs perfectly on my compiler but it is showing \"java.util.EmptyStackException\" on line 7 \"head = stack.pop();\". Please help\\n\\n\\npublic static ListNode reverseList(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        while(head != null){\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        head = stack.pop();\\n        ListNode t = head;\\n        while(!stack.isEmpty()){\\n            t.next = stack.pop();\\n            t = t.next;\\n        }\\n        t.next = null;\\n        return head;\\n    }"
                    },
                    {
                        "username": "user6957Vg",
                        "content": "add an \"if statement\" to check for empty stack before \"head = stack.pop()\" as the stack will be empty if the input list is empty"
                    },
                    {
                        "username": "Fluentee",
                        "content": "When giving an empty list case, `stack.pop()` will fail.\nSo, before using `pop()` method, maybe you should add an `if` statement. \n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        // return null if head is null\n        if (head == null) return null;\n        // add type: ListNode to Stack\n        Stack<ListNode> stack = new Stack<>(); \n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        head = stack.pop();\n        ListNode t = head;\n        while(!stack.isEmpty()){\n            t.next = stack.pop();\n            t = t.next;\n        }\n        t.next = null;\n        return head;\n    }\n}\n```"
                    },
                    {
                        "username": "priyanshusingh2800",
                        "content": "rem=0;\\nm=a%10;\\nrem=rem*10+m;\\na=a/10;\\n"
                    },
                    {
                        "username": "Fluentee",
                        "content": "I don\\'t know what\\'s wrong with my solution, I need help!\\n ```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        stack<ListNode*> stk;\\n        auto temp = head;\\n        while (temp != nullptr) {\\n            stk.push(temp);\\n            temp = temp->next;\\n        }\\n        auto ptr = head;\\n        while (!stk.empty()) { \\n            ptr->next = stk.top();\\n            stk.pop();\\n            ptr = ptr->next;\\n        }\\n        ptr->next = nullptr;\\n        return head->next;\\n    }\\n};\\n/*\\nLine 26: Char 14: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:35:14\\n*/\\n```"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy C++ solution \nTime complexity - O(n)\nSpace complexity - O(1)\n\nListNode* reverseList(ListNode* head) {\n        \n        ListNode* prev = NULL ;\n        ListNode* curr = head ;\n        ListNode* forward = NULL ;\n       \n       while( curr != NULL ){\n            forward = curr -> next ;\n            curr -> next = prev ;\n            prev = curr ;\n            curr = forward ;\n        }\n        return prev ;"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n    ListNode*p=head;\\n    ListNode*q=NULL;\\n    ListNode*r=NULL;\\n    while(p!=NULL)\\n    {\\n    r=q;\\n    q=p;\\n  p=p->next;\\n   q->next=r;\\n    }    \\n    head=q;\\n    return head;\\n    }\\n};\\nso this concept involves sliding pointers where r moves to q .q moves to p and p moves to next node and q will be pointing back on the previous address basically previous loop and finally head will be pointed on q making it the first node"
                    }
                ]
            },
            {
                "id": 1708660,
                "content": [
                    {
                        "username": "ozigun1988",
                        "content": "reverse() function doesn work. but when i try it in my console its ok. i dont know why"
                    },
                    {
                        "username": "wle",
                        "content": "Really cannot wrap my head around the recursive function:\\nwhy simply line  p = self.reverseList(head.next) is able to reverse the rest of the nodes?? It looks like it does not do anything until the head of head.next is null. Please help.. I am feeling stupid"
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "There\\'s no way that itself can reverse the entire node. Recursive functions need stop conditions. What was the full context of the code?"
                    },
                    {
                        "username": "mia_mi",
                        "content": "Hi, is there anyone who could kindly explain why the while loop goes forever in my code?\\n\\n        tmp = currpoint = head\\n        reverse = None\\n        \\n        while tmp:\\n            currpoint = tmp\\n            currpoint.next = reverse\\n            reverse = currpoint\\n            tmp = tmp.next\\n\\n        return reverse\\n\\nI have no idea what\\'s going on. I believe the tmp became circular in some way, but cannot get an idea why this happens."
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "Hey [@mia_mi](/mia_mi), tmp is assigned to be both `currpoint` and `head`. As such, I imagine whenever you update `currpoint`, `tmp` updates its value to ressemble `currpoint` as well. Try printing the contents of tmp and current point after `reverse = currpoint` and see if `tmp` and `currpoint` are indeed the same."
                    },
                    {
                        "username": "rv4474990",
                        "content": "Just Use two extra pointers of Node type. Initially assign them as NULL and use tricky replacement among these pointers and head.\\nThats all...."
                    },
                    {
                        "username": "seifsoliman",
                        "content": "class Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        x = []\\n        while(head):\\n            x.append(head.val)\\n            head = head.next\\n        y = z = ListNode(0)\\n        for i in x[-1::-1]:\\n            y.next = ListNode(i)\\n            y = y.next\\n        return z.next"
                    },
                    {
                        "username": "prashast_chugh",
                        "content": "My code runs perfectly on my compiler but it is showing \"java.util.EmptyStackException\" on line 7 \"head = stack.pop();\". Please help\\n\\n\\npublic static ListNode reverseList(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        while(head != null){\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        head = stack.pop();\\n        ListNode t = head;\\n        while(!stack.isEmpty()){\\n            t.next = stack.pop();\\n            t = t.next;\\n        }\\n        t.next = null;\\n        return head;\\n    }"
                    },
                    {
                        "username": "user6957Vg",
                        "content": "add an \"if statement\" to check for empty stack before \"head = stack.pop()\" as the stack will be empty if the input list is empty"
                    },
                    {
                        "username": "Fluentee",
                        "content": "When giving an empty list case, `stack.pop()` will fail.\nSo, before using `pop()` method, maybe you should add an `if` statement. \n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        // return null if head is null\n        if (head == null) return null;\n        // add type: ListNode to Stack\n        Stack<ListNode> stack = new Stack<>(); \n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        head = stack.pop();\n        ListNode t = head;\n        while(!stack.isEmpty()){\n            t.next = stack.pop();\n            t = t.next;\n        }\n        t.next = null;\n        return head;\n    }\n}\n```"
                    },
                    {
                        "username": "priyanshusingh2800",
                        "content": "rem=0;\\nm=a%10;\\nrem=rem*10+m;\\na=a/10;\\n"
                    },
                    {
                        "username": "Fluentee",
                        "content": "I don\\'t know what\\'s wrong with my solution, I need help!\\n ```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        stack<ListNode*> stk;\\n        auto temp = head;\\n        while (temp != nullptr) {\\n            stk.push(temp);\\n            temp = temp->next;\\n        }\\n        auto ptr = head;\\n        while (!stk.empty()) { \\n            ptr->next = stk.top();\\n            stk.pop();\\n            ptr = ptr->next;\\n        }\\n        ptr->next = nullptr;\\n        return head->next;\\n    }\\n};\\n/*\\nLine 26: Char 14: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:35:14\\n*/\\n```"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy C++ solution \nTime complexity - O(n)\nSpace complexity - O(1)\n\nListNode* reverseList(ListNode* head) {\n        \n        ListNode* prev = NULL ;\n        ListNode* curr = head ;\n        ListNode* forward = NULL ;\n       \n       while( curr != NULL ){\n            forward = curr -> next ;\n            curr -> next = prev ;\n            prev = curr ;\n            curr = forward ;\n        }\n        return prev ;"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n    ListNode*p=head;\\n    ListNode*q=NULL;\\n    ListNode*r=NULL;\\n    while(p!=NULL)\\n    {\\n    r=q;\\n    q=p;\\n  p=p->next;\\n   q->next=r;\\n    }    \\n    head=q;\\n    return head;\\n    }\\n};\\nso this concept involves sliding pointers where r moves to q .q moves to p and p moves to next node and q will be pointing back on the previous address basically previous loop and finally head will be pointed on q making it the first node"
                    }
                ]
            },
            {
                "id": 1707860,
                "content": [
                    {
                        "username": "ozigun1988",
                        "content": "reverse() function doesn work. but when i try it in my console its ok. i dont know why"
                    },
                    {
                        "username": "wle",
                        "content": "Really cannot wrap my head around the recursive function:\\nwhy simply line  p = self.reverseList(head.next) is able to reverse the rest of the nodes?? It looks like it does not do anything until the head of head.next is null. Please help.. I am feeling stupid"
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "There\\'s no way that itself can reverse the entire node. Recursive functions need stop conditions. What was the full context of the code?"
                    },
                    {
                        "username": "mia_mi",
                        "content": "Hi, is there anyone who could kindly explain why the while loop goes forever in my code?\\n\\n        tmp = currpoint = head\\n        reverse = None\\n        \\n        while tmp:\\n            currpoint = tmp\\n            currpoint.next = reverse\\n            reverse = currpoint\\n            tmp = tmp.next\\n\\n        return reverse\\n\\nI have no idea what\\'s going on. I believe the tmp became circular in some way, but cannot get an idea why this happens."
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "Hey [@mia_mi](/mia_mi), tmp is assigned to be both `currpoint` and `head`. As such, I imagine whenever you update `currpoint`, `tmp` updates its value to ressemble `currpoint` as well. Try printing the contents of tmp and current point after `reverse = currpoint` and see if `tmp` and `currpoint` are indeed the same."
                    },
                    {
                        "username": "rv4474990",
                        "content": "Just Use two extra pointers of Node type. Initially assign them as NULL and use tricky replacement among these pointers and head.\\nThats all...."
                    },
                    {
                        "username": "seifsoliman",
                        "content": "class Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        x = []\\n        while(head):\\n            x.append(head.val)\\n            head = head.next\\n        y = z = ListNode(0)\\n        for i in x[-1::-1]:\\n            y.next = ListNode(i)\\n            y = y.next\\n        return z.next"
                    },
                    {
                        "username": "prashast_chugh",
                        "content": "My code runs perfectly on my compiler but it is showing \"java.util.EmptyStackException\" on line 7 \"head = stack.pop();\". Please help\\n\\n\\npublic static ListNode reverseList(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        while(head != null){\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        head = stack.pop();\\n        ListNode t = head;\\n        while(!stack.isEmpty()){\\n            t.next = stack.pop();\\n            t = t.next;\\n        }\\n        t.next = null;\\n        return head;\\n    }"
                    },
                    {
                        "username": "user6957Vg",
                        "content": "add an \"if statement\" to check for empty stack before \"head = stack.pop()\" as the stack will be empty if the input list is empty"
                    },
                    {
                        "username": "Fluentee",
                        "content": "When giving an empty list case, `stack.pop()` will fail.\nSo, before using `pop()` method, maybe you should add an `if` statement. \n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        // return null if head is null\n        if (head == null) return null;\n        // add type: ListNode to Stack\n        Stack<ListNode> stack = new Stack<>(); \n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        head = stack.pop();\n        ListNode t = head;\n        while(!stack.isEmpty()){\n            t.next = stack.pop();\n            t = t.next;\n        }\n        t.next = null;\n        return head;\n    }\n}\n```"
                    },
                    {
                        "username": "priyanshusingh2800",
                        "content": "rem=0;\\nm=a%10;\\nrem=rem*10+m;\\na=a/10;\\n"
                    },
                    {
                        "username": "Fluentee",
                        "content": "I don\\'t know what\\'s wrong with my solution, I need help!\\n ```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        stack<ListNode*> stk;\\n        auto temp = head;\\n        while (temp != nullptr) {\\n            stk.push(temp);\\n            temp = temp->next;\\n        }\\n        auto ptr = head;\\n        while (!stk.empty()) { \\n            ptr->next = stk.top();\\n            stk.pop();\\n            ptr = ptr->next;\\n        }\\n        ptr->next = nullptr;\\n        return head->next;\\n    }\\n};\\n/*\\nLine 26: Char 14: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:35:14\\n*/\\n```"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy C++ solution \nTime complexity - O(n)\nSpace complexity - O(1)\n\nListNode* reverseList(ListNode* head) {\n        \n        ListNode* prev = NULL ;\n        ListNode* curr = head ;\n        ListNode* forward = NULL ;\n       \n       while( curr != NULL ){\n            forward = curr -> next ;\n            curr -> next = prev ;\n            prev = curr ;\n            curr = forward ;\n        }\n        return prev ;"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n    ListNode*p=head;\\n    ListNode*q=NULL;\\n    ListNode*r=NULL;\\n    while(p!=NULL)\\n    {\\n    r=q;\\n    q=p;\\n  p=p->next;\\n   q->next=r;\\n    }    \\n    head=q;\\n    return head;\\n    }\\n};\\nso this concept involves sliding pointers where r moves to q .q moves to p and p moves to next node and q will be pointing back on the previous address basically previous loop and finally head will be pointed on q making it the first node"
                    }
                ]
            },
            {
                "id": 1704086,
                "content": [
                    {
                        "username": "ozigun1988",
                        "content": "reverse() function doesn work. but when i try it in my console its ok. i dont know why"
                    },
                    {
                        "username": "wle",
                        "content": "Really cannot wrap my head around the recursive function:\\nwhy simply line  p = self.reverseList(head.next) is able to reverse the rest of the nodes?? It looks like it does not do anything until the head of head.next is null. Please help.. I am feeling stupid"
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "There\\'s no way that itself can reverse the entire node. Recursive functions need stop conditions. What was the full context of the code?"
                    },
                    {
                        "username": "mia_mi",
                        "content": "Hi, is there anyone who could kindly explain why the while loop goes forever in my code?\\n\\n        tmp = currpoint = head\\n        reverse = None\\n        \\n        while tmp:\\n            currpoint = tmp\\n            currpoint.next = reverse\\n            reverse = currpoint\\n            tmp = tmp.next\\n\\n        return reverse\\n\\nI have no idea what\\'s going on. I believe the tmp became circular in some way, but cannot get an idea why this happens."
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "Hey [@mia_mi](/mia_mi), tmp is assigned to be both `currpoint` and `head`. As such, I imagine whenever you update `currpoint`, `tmp` updates its value to ressemble `currpoint` as well. Try printing the contents of tmp and current point after `reverse = currpoint` and see if `tmp` and `currpoint` are indeed the same."
                    },
                    {
                        "username": "rv4474990",
                        "content": "Just Use two extra pointers of Node type. Initially assign them as NULL and use tricky replacement among these pointers and head.\\nThats all...."
                    },
                    {
                        "username": "seifsoliman",
                        "content": "class Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        x = []\\n        while(head):\\n            x.append(head.val)\\n            head = head.next\\n        y = z = ListNode(0)\\n        for i in x[-1::-1]:\\n            y.next = ListNode(i)\\n            y = y.next\\n        return z.next"
                    },
                    {
                        "username": "prashast_chugh",
                        "content": "My code runs perfectly on my compiler but it is showing \"java.util.EmptyStackException\" on line 7 \"head = stack.pop();\". Please help\\n\\n\\npublic static ListNode reverseList(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        while(head != null){\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        head = stack.pop();\\n        ListNode t = head;\\n        while(!stack.isEmpty()){\\n            t.next = stack.pop();\\n            t = t.next;\\n        }\\n        t.next = null;\\n        return head;\\n    }"
                    },
                    {
                        "username": "user6957Vg",
                        "content": "add an \"if statement\" to check for empty stack before \"head = stack.pop()\" as the stack will be empty if the input list is empty"
                    },
                    {
                        "username": "Fluentee",
                        "content": "When giving an empty list case, `stack.pop()` will fail.\nSo, before using `pop()` method, maybe you should add an `if` statement. \n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        // return null if head is null\n        if (head == null) return null;\n        // add type: ListNode to Stack\n        Stack<ListNode> stack = new Stack<>(); \n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        head = stack.pop();\n        ListNode t = head;\n        while(!stack.isEmpty()){\n            t.next = stack.pop();\n            t = t.next;\n        }\n        t.next = null;\n        return head;\n    }\n}\n```"
                    },
                    {
                        "username": "priyanshusingh2800",
                        "content": "rem=0;\\nm=a%10;\\nrem=rem*10+m;\\na=a/10;\\n"
                    },
                    {
                        "username": "Fluentee",
                        "content": "I don\\'t know what\\'s wrong with my solution, I need help!\\n ```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        stack<ListNode*> stk;\\n        auto temp = head;\\n        while (temp != nullptr) {\\n            stk.push(temp);\\n            temp = temp->next;\\n        }\\n        auto ptr = head;\\n        while (!stk.empty()) { \\n            ptr->next = stk.top();\\n            stk.pop();\\n            ptr = ptr->next;\\n        }\\n        ptr->next = nullptr;\\n        return head->next;\\n    }\\n};\\n/*\\nLine 26: Char 14: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:35:14\\n*/\\n```"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy C++ solution \nTime complexity - O(n)\nSpace complexity - O(1)\n\nListNode* reverseList(ListNode* head) {\n        \n        ListNode* prev = NULL ;\n        ListNode* curr = head ;\n        ListNode* forward = NULL ;\n       \n       while( curr != NULL ){\n            forward = curr -> next ;\n            curr -> next = prev ;\n            prev = curr ;\n            curr = forward ;\n        }\n        return prev ;"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n    ListNode*p=head;\\n    ListNode*q=NULL;\\n    ListNode*r=NULL;\\n    while(p!=NULL)\\n    {\\n    r=q;\\n    q=p;\\n  p=p->next;\\n   q->next=r;\\n    }    \\n    head=q;\\n    return head;\\n    }\\n};\\nso this concept involves sliding pointers where r moves to q .q moves to p and p moves to next node and q will be pointing back on the previous address basically previous loop and finally head will be pointed on q making it the first node"
                    }
                ]
            },
            {
                "id": 1700104,
                "content": [
                    {
                        "username": "ozigun1988",
                        "content": "reverse() function doesn work. but when i try it in my console its ok. i dont know why"
                    },
                    {
                        "username": "wle",
                        "content": "Really cannot wrap my head around the recursive function:\\nwhy simply line  p = self.reverseList(head.next) is able to reverse the rest of the nodes?? It looks like it does not do anything until the head of head.next is null. Please help.. I am feeling stupid"
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "There\\'s no way that itself can reverse the entire node. Recursive functions need stop conditions. What was the full context of the code?"
                    },
                    {
                        "username": "mia_mi",
                        "content": "Hi, is there anyone who could kindly explain why the while loop goes forever in my code?\\n\\n        tmp = currpoint = head\\n        reverse = None\\n        \\n        while tmp:\\n            currpoint = tmp\\n            currpoint.next = reverse\\n            reverse = currpoint\\n            tmp = tmp.next\\n\\n        return reverse\\n\\nI have no idea what\\'s going on. I believe the tmp became circular in some way, but cannot get an idea why this happens."
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "Hey [@mia_mi](/mia_mi), tmp is assigned to be both `currpoint` and `head`. As such, I imagine whenever you update `currpoint`, `tmp` updates its value to ressemble `currpoint` as well. Try printing the contents of tmp and current point after `reverse = currpoint` and see if `tmp` and `currpoint` are indeed the same."
                    },
                    {
                        "username": "rv4474990",
                        "content": "Just Use two extra pointers of Node type. Initially assign them as NULL and use tricky replacement among these pointers and head.\\nThats all...."
                    },
                    {
                        "username": "seifsoliman",
                        "content": "class Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        x = []\\n        while(head):\\n            x.append(head.val)\\n            head = head.next\\n        y = z = ListNode(0)\\n        for i in x[-1::-1]:\\n            y.next = ListNode(i)\\n            y = y.next\\n        return z.next"
                    },
                    {
                        "username": "prashast_chugh",
                        "content": "My code runs perfectly on my compiler but it is showing \"java.util.EmptyStackException\" on line 7 \"head = stack.pop();\". Please help\\n\\n\\npublic static ListNode reverseList(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        while(head != null){\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        head = stack.pop();\\n        ListNode t = head;\\n        while(!stack.isEmpty()){\\n            t.next = stack.pop();\\n            t = t.next;\\n        }\\n        t.next = null;\\n        return head;\\n    }"
                    },
                    {
                        "username": "user6957Vg",
                        "content": "add an \"if statement\" to check for empty stack before \"head = stack.pop()\" as the stack will be empty if the input list is empty"
                    },
                    {
                        "username": "Fluentee",
                        "content": "When giving an empty list case, `stack.pop()` will fail.\nSo, before using `pop()` method, maybe you should add an `if` statement. \n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        // return null if head is null\n        if (head == null) return null;\n        // add type: ListNode to Stack\n        Stack<ListNode> stack = new Stack<>(); \n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        head = stack.pop();\n        ListNode t = head;\n        while(!stack.isEmpty()){\n            t.next = stack.pop();\n            t = t.next;\n        }\n        t.next = null;\n        return head;\n    }\n}\n```"
                    },
                    {
                        "username": "priyanshusingh2800",
                        "content": "rem=0;\\nm=a%10;\\nrem=rem*10+m;\\na=a/10;\\n"
                    },
                    {
                        "username": "Fluentee",
                        "content": "I don\\'t know what\\'s wrong with my solution, I need help!\\n ```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        stack<ListNode*> stk;\\n        auto temp = head;\\n        while (temp != nullptr) {\\n            stk.push(temp);\\n            temp = temp->next;\\n        }\\n        auto ptr = head;\\n        while (!stk.empty()) { \\n            ptr->next = stk.top();\\n            stk.pop();\\n            ptr = ptr->next;\\n        }\\n        ptr->next = nullptr;\\n        return head->next;\\n    }\\n};\\n/*\\nLine 26: Char 14: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:35:14\\n*/\\n```"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy C++ solution \nTime complexity - O(n)\nSpace complexity - O(1)\n\nListNode* reverseList(ListNode* head) {\n        \n        ListNode* prev = NULL ;\n        ListNode* curr = head ;\n        ListNode* forward = NULL ;\n       \n       while( curr != NULL ){\n            forward = curr -> next ;\n            curr -> next = prev ;\n            prev = curr ;\n            curr = forward ;\n        }\n        return prev ;"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n    ListNode*p=head;\\n    ListNode*q=NULL;\\n    ListNode*r=NULL;\\n    while(p!=NULL)\\n    {\\n    r=q;\\n    q=p;\\n  p=p->next;\\n   q->next=r;\\n    }    \\n    head=q;\\n    return head;\\n    }\\n};\\nso this concept involves sliding pointers where r moves to q .q moves to p and p moves to next node and q will be pointing back on the previous address basically previous loop and finally head will be pointed on q making it the first node"
                    }
                ]
            },
            {
                "id": 1697672,
                "content": [
                    {
                        "username": "ozigun1988",
                        "content": "reverse() function doesn work. but when i try it in my console its ok. i dont know why"
                    },
                    {
                        "username": "wle",
                        "content": "Really cannot wrap my head around the recursive function:\\nwhy simply line  p = self.reverseList(head.next) is able to reverse the rest of the nodes?? It looks like it does not do anything until the head of head.next is null. Please help.. I am feeling stupid"
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "There\\'s no way that itself can reverse the entire node. Recursive functions need stop conditions. What was the full context of the code?"
                    },
                    {
                        "username": "mia_mi",
                        "content": "Hi, is there anyone who could kindly explain why the while loop goes forever in my code?\\n\\n        tmp = currpoint = head\\n        reverse = None\\n        \\n        while tmp:\\n            currpoint = tmp\\n            currpoint.next = reverse\\n            reverse = currpoint\\n            tmp = tmp.next\\n\\n        return reverse\\n\\nI have no idea what\\'s going on. I believe the tmp became circular in some way, but cannot get an idea why this happens."
                    },
                    {
                        "username": "Catcatcher33",
                        "content": "Hey [@mia_mi](/mia_mi), tmp is assigned to be both `currpoint` and `head`. As such, I imagine whenever you update `currpoint`, `tmp` updates its value to ressemble `currpoint` as well. Try printing the contents of tmp and current point after `reverse = currpoint` and see if `tmp` and `currpoint` are indeed the same."
                    },
                    {
                        "username": "rv4474990",
                        "content": "Just Use two extra pointers of Node type. Initially assign them as NULL and use tricky replacement among these pointers and head.\\nThats all...."
                    },
                    {
                        "username": "seifsoliman",
                        "content": "class Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        x = []\\n        while(head):\\n            x.append(head.val)\\n            head = head.next\\n        y = z = ListNode(0)\\n        for i in x[-1::-1]:\\n            y.next = ListNode(i)\\n            y = y.next\\n        return z.next"
                    },
                    {
                        "username": "prashast_chugh",
                        "content": "My code runs perfectly on my compiler but it is showing \"java.util.EmptyStackException\" on line 7 \"head = stack.pop();\". Please help\\n\\n\\npublic static ListNode reverseList(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        while(head != null){\\n            stack.push(head);\\n            head = head.next;\\n        }\\n        head = stack.pop();\\n        ListNode t = head;\\n        while(!stack.isEmpty()){\\n            t.next = stack.pop();\\n            t = t.next;\\n        }\\n        t.next = null;\\n        return head;\\n    }"
                    },
                    {
                        "username": "user6957Vg",
                        "content": "add an \"if statement\" to check for empty stack before \"head = stack.pop()\" as the stack will be empty if the input list is empty"
                    },
                    {
                        "username": "Fluentee",
                        "content": "When giving an empty list case, `stack.pop()` will fail.\nSo, before using `pop()` method, maybe you should add an `if` statement. \n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        // return null if head is null\n        if (head == null) return null;\n        // add type: ListNode to Stack\n        Stack<ListNode> stack = new Stack<>(); \n        while(head != null){\n            stack.push(head);\n            head = head.next;\n        }\n        head = stack.pop();\n        ListNode t = head;\n        while(!stack.isEmpty()){\n            t.next = stack.pop();\n            t = t.next;\n        }\n        t.next = null;\n        return head;\n    }\n}\n```"
                    },
                    {
                        "username": "priyanshusingh2800",
                        "content": "rem=0;\\nm=a%10;\\nrem=rem*10+m;\\na=a/10;\\n"
                    },
                    {
                        "username": "Fluentee",
                        "content": "I don\\'t know what\\'s wrong with my solution, I need help!\\n ```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        stack<ListNode*> stk;\\n        auto temp = head;\\n        while (temp != nullptr) {\\n            stk.push(temp);\\n            temp = temp->next;\\n        }\\n        auto ptr = head;\\n        while (!stk.empty()) { \\n            ptr->next = stk.top();\\n            stk.pop();\\n            ptr = ptr->next;\\n        }\\n        ptr->next = nullptr;\\n        return head->next;\\n    }\\n};\\n/*\\nLine 26: Char 14: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:35:14\\n*/\\n```"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Easy C++ solution \nTime complexity - O(n)\nSpace complexity - O(1)\n\nListNode* reverseList(ListNode* head) {\n        \n        ListNode* prev = NULL ;\n        ListNode* curr = head ;\n        ListNode* forward = NULL ;\n       \n       while( curr != NULL ){\n            forward = curr -> next ;\n            curr -> next = prev ;\n            prev = curr ;\n            curr = forward ;\n        }\n        return prev ;"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n    ListNode*p=head;\\n    ListNode*q=NULL;\\n    ListNode*r=NULL;\\n    while(p!=NULL)\\n    {\\n    r=q;\\n    q=p;\\n  p=p->next;\\n   q->next=r;\\n    }    \\n    head=q;\\n    return head;\\n    }\\n};\\nso this concept involves sliding pointers where r moves to q .q moves to p and p moves to next node and q will be pointing back on the previous address basically previous loop and finally head will be pointed on q making it the first node"
                    }
                ]
            }
        ]
    }
]