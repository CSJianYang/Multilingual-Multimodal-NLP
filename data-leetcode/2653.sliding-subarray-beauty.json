[
    {
        "title": "Sliding Subarray Beauty",
        "question_content": "Given an integer array nums containing n integers, find the beauty of each subarray of size k.\nThe beauty of a subarray is the xth smallest integer in the subarray if it is negative, or 0 if there are fewer than x negative integers.\nReturn an integer array containing n - k + 1 integers, which denote the beauty of the subarrays in order from the first index in the array.\n\n\t\n\tA subarray is a contiguous non-empty sequence of elements within an array.\n\t\n\n&nbsp;\nExample 1:\n\nInput: nums = [1,-1,-3,-2,3], k = 3, x = 2\nOutput: [-1,-2,-2]\nExplanation: There are 3 subarrays with size k = 3. \nThe first subarray is [1, -1, -3] and the 2nd smallest negative integer is -1.&nbsp;\nThe second subarray is [-1, -3, -2] and the 2nd smallest negative integer is -2.&nbsp;\nThe third subarray is [-3, -2, 3]&nbsp;and the 2nd smallest negative integer is -2.\nExample 2:\n\nInput: nums = [-1,-2,-3,-4,-5], k = 2, x = 2\nOutput: [-1,-2,-3,-4]\nExplanation: There are 4 subarrays with size k = 2.\nFor [-1, -2], the 2nd smallest negative integer is -1.\nFor [-2, -3], the 2nd smallest negative integer is -2.\nFor [-3, -4], the 2nd smallest negative integer is -3.\nFor [-4, -5], the 2nd smallest negative integer is -4.&nbsp;\nExample 3:\n\nInput: nums = [-3,1,2,-3,0,-3], k = 2, x = 1\nOutput: [-3,0,-3,-3,-3]\nExplanation: There are 5 subarrays with size k = 2.\nFor [-3, 1], the 1st smallest negative integer is -3.\nFor [1, 2], there is no negative integer so the beauty is 0.\nFor [2, -3], the 1st smallest negative integer is -3.\nFor [-3, 0], the 1st smallest negative integer is -3.\nFor [0, -3], the 1st smallest negative integer is -3.\n&nbsp;\nConstraints:\n\n\tn == nums.length&nbsp;\n\t1 <= n <= 105\n\t1 <= k <= n\n\t1 <= x <= k&nbsp;\n\t-50&nbsp;<= nums[i] <= 50&nbsp;",
        "solutions": [
            {
                "id": 3445659,
                "title": "c-java-python3-simple-counting",
                "content": "\\n# Intuition\\nSince the range of numbers is small `-50 <= nums[i] <= 50`  we can use this to our advantage. Store counts of numbers smaller than 0 in a counter array and use that to find the `xth` smallest number.  \\n\\n# Approach\\nIterate over the counter array and sum the counts of each number. When the sum of counts is greater than or equal to `x` we have found out `xth` smallest number. If sum of counts is never greater than or equal to `x` there aren\\'t enough negative numbers.\\nLine by line explanation:\\n1. `if nums[i] < 0: counter[nums[i] + 50] += 1` For negative numbers increment counter, -50 is mapped to 0, -1 is mapped to 49.\\n2. `if i - k >= 0 and nums[i - k] < 0: counter[nums[i - k] + 50] -= 1` Since we only have to consider a window of size k, we need to remove elements on the front of the sliding window. The front will be at  index `i - k`. Now since we only added negative numbers to the counter we\\'ll remove only if `nums[i - k]` is negative.\\n3. `if i - k + 1 < 0: continue` This checks if the sliding window has atleast k elements\\n4. The rest of the code iterates over the `counter` array to find the `xth` smallest number.\\n\\n# Complexity\\n- Time complexity: `O(n * 50)`\\n\\n- Space complexity: `O(n - k + 1 + 50)`\\n\\n# Code\\n**Python3**:\\n```\\ndef getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n    counter, ans = [0] * 50, [0] * (len(nums) - k + 1)\\n    for i in range(len(nums)):\\n        if nums[i] < 0: counter[nums[i] + 50] += 1\\n        if i - k >= 0 and nums[i - k] < 0: counter[nums[i - k] + 50] -= 1\\n        if i - k + 1 < 0: continue\\n        count = 0\\n        for j in range(50):\\n            count += counter[j]\\n            if count >= x:\\n                ans[i - k + 1] = j - 50\\n                break\\n    return ans\\n```\\n\\n**C++**:\\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    vector<int> ans(nums.size() - k + 1), counter(50);\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        if (i - k + 1 < 0) continue;\\n        for (int j = 0, count = 0; j < 50; j++) {\\n            count += counter[j];\\n            if (count >= x) {\\n                ans[i - k + 1] = j - 50;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\\n\\n**C++ but more concise**:\\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    vector<int> ans(nums.size() - k + 1), counter(50);\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        for (int j = 0, count = 0; j < 50 && count < x && i >= k - 1; j++)\\n            if((count += counter[j]) >= x)\\n                ans[i - k + 1] = j - 50;\\n    }\\n    return ans;\\n}\\n```\\n**Java**:\\n```\\npublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int[] counter = new int[50], ans = new int[nums.length - k + 1];;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        if (i - k + 1 < 0) continue;\\n        for (int j = 0, count = 0; j < 50; j++) {\\n            count += counter[j];\\n            if (count >= x) {\\n                ans[i - k + 1] = j - 50;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\\n\\n**Java but more concise**:\\n```\\npublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int[] counter = new int[50], ans = new int[nums.length - k + 1];;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        for (int j = 0, count = 0; j < 50 && count < x && i >= k - 1; j++)\\n            if ((count += counter[j]) >= x)\\n                ans[i - k + 1] = j - 50;\\n    }\\n    return ans;\\n}\\n```\\n\\n## Bonus:\\nUse `SortedList` in Python:\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        sl, ans = SortedList(), []\\n        for i, y in enumerate(nums):\\n            sl.add(y)\\n            if len(sl) > k: sl.remove(nums[i - k])\\n            if i >= k - 1: ans.append(min(0, sl[x - 1]))\\n        return ans\\n```\\nTime Complexity: `O(nlogk)`",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n    counter, ans = [0] * 50, [0] * (len(nums) - k + 1)\\n    for i in range(len(nums)):\\n        if nums[i] < 0: counter[nums[i] + 50] += 1\\n        if i - k >= 0 and nums[i - k] < 0: counter[nums[i - k] + 50] -= 1\\n        if i - k + 1 < 0: continue\\n        count = 0\\n        for j in range(50):\\n            count += counter[j]\\n            if count >= x:\\n                ans[i - k + 1] = j - 50\\n                break\\n    return ans\\n```\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    vector<int> ans(nums.size() - k + 1), counter(50);\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        if (i - k + 1 < 0) continue;\\n        for (int j = 0, count = 0; j < 50; j++) {\\n            count += counter[j];\\n            if (count >= x) {\\n                ans[i - k + 1] = j - 50;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    vector<int> ans(nums.size() - k + 1), counter(50);\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        for (int j = 0, count = 0; j < 50 && count < x && i >= k - 1; j++)\\n            if((count += counter[j]) >= x)\\n                ans[i - k + 1] = j - 50;\\n    }\\n    return ans;\\n}\\n```\n```\\npublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int[] counter = new int[50], ans = new int[nums.length - k + 1];;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        if (i - k + 1 < 0) continue;\\n        for (int j = 0, count = 0; j < 50; j++) {\\n            count += counter[j];\\n            if (count >= x) {\\n                ans[i - k + 1] = j - 50;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\n```\\npublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int[] counter = new int[50], ans = new int[nums.length - k + 1];;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        for (int j = 0, count = 0; j < 50 && count < x && i >= k - 1; j++)\\n            if ((count += counter[j]) >= x)\\n                ans[i - k + 1] = j - 50;\\n    }\\n    return ans;\\n}\\n```\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        sl, ans = SortedList(), []\\n        for i, y in enumerate(nums):\\n            sl.add(y)\\n            if len(sl) > k: sl.remove(nums[i - k])\\n            if i >= k - 1: ans.append(min(0, sl[x - 1]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445677,
                "title": "cpp-java-python-sliding-window-explanation-with-comments",
                "content": "\\n\\n>##### \\uD83D\\uDD3C IF YOU HELPFUL, PLEASE UPVOTE \\n---\\n\\n#### Approach :\\n* First observation is `-50 <= nums[i] <= 50`, we have only 50 negative numbers so we track of them in freq array\\n* Calculate xth smallest number in freq array\\n\\n---\\n#### Explanation : \\n* In given question, we have `-50 <= nums[i] <= 50` means only ` -50 to -1` negative elements and we need to calculate `xth` smallest negative element. We only deal with negative element in `k` size of sliding window.\\n* But one question like that How to calculate `xth smallest negative element` in current sliding windows bcz each time smallest element change?\\n* We just track of negative number of each sliding window and calculate `xth` smallest element.\\n* But, How to calculate `xth` negative element in current windows?\\n* We have freq of negative numbers in current windows so just calculate from `-50 to -1` xth negative element in `O(50)` constant time.\\n---\\n\\n#### Coplexity :\\n* Time Complexity : `O(N * 50)`\\n* Space Complexity : `O(50)`\\n---\\n\\n\\n###### Special Thanks to `@ManojKumarPatnaik` for `Java` solution\\n---\\n#### Solution :\\n\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> freq(51, 0), ans;\\n        \\n        for(int i = 0, j = 0; i < n; i++) {\\n            // count freq of negative numbers in current sliding windows\\n            if(nums[i] < 0) freq[abs(nums[i])]++;\\n            if(i - j + 1 >= k) {\\n                int cnt = 0;\\n                // calculate xth smallest number in current sliding windows\\n                for(int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if(cnt >= x) { ans.push_back(-L); break;}\\n                }\\n                // No xth smallest number present \\n                if(cnt < x) ans.push_back(0);\\n                if(nums[j] < 0) freq[abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n```java []\\n public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] freq = new int[51];\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        for (int i = 0, j = 0; i < n; i++) {\\n            // count freq of negative numbers in current sliding windows\\n            if (nums[i] < 0) freq[Math.abs(nums[i])]++;\\n            if (i - j + 1 >= k) {\\n                int cnt = 0;\\n                // calculate xth smallest number in current sliding windows\\n                for (int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if (cnt >= x) { \\n                        ans.add(-L);\\n                        break;\\n                    }\\n                }\\n                // No xth smallest number present \\n                if (cnt < x) ans.add(0);\\n                if (nums[j] < 0) freq[Math.abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return ans.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n```\\n\\n```python []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        freq, ans, j = [0] * 51, [], 0\\n\\n        for i in range(len(nums)):\\n            # count freq of negative numbers in current sliding windows\\n            if nums[i] < 0 : freq[abs(nums[i])] += 1\\n            if i - j + 1 >= k :\\n                cnt = 0\\n                # calculate xth smallest number in current sliding windows\\n                for L in reversed(range(51)):\\n                    cnt += freq[L]\\n                    if cnt >= x:\\n                        ans.append(-L)\\n                        break\\n                # No xth smallest number present \\n                if cnt < x : ans.append(0)\\n                if nums[j] < 0 : freq[abs(nums[j])] -= 1\\n                j += 1\\n            \\n        return ans\\n        \\n```\\n\\n>Have a good day. Happy Coding!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> freq(51, 0), ans;\\n        \\n        for(int i = 0, j = 0; i < n; i++) {\\n            // count freq of negative numbers in current sliding windows\\n            if(nums[i] < 0) freq[abs(nums[i])]++;\\n            if(i - j + 1 >= k) {\\n                int cnt = 0;\\n                // calculate xth smallest number in current sliding windows\\n                for(int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if(cnt >= x) { ans.push_back(-L); break;}\\n                }\\n                // No xth smallest number present \\n                if(cnt < x) ans.push_back(0);\\n                if(nums[j] < 0) freq[abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```java []\\n public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] freq = new int[51];\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        for (int i = 0, j = 0; i < n; i++) {\\n            // count freq of negative numbers in current sliding windows\\n            if (nums[i] < 0) freq[Math.abs(nums[i])]++;\\n            if (i - j + 1 >= k) {\\n                int cnt = 0;\\n                // calculate xth smallest number in current sliding windows\\n                for (int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if (cnt >= x) { \\n                        ans.add(-L);\\n                        break;\\n                    }\\n                }\\n                // No xth smallest number present \\n                if (cnt < x) ans.add(0);\\n                if (nums[j] < 0) freq[Math.abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return ans.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n```\n```python []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        freq, ans, j = [0] * 51, [], 0\\n\\n        for i in range(len(nums)):\\n            # count freq of negative numbers in current sliding windows\\n            if nums[i] < 0 : freq[abs(nums[i])] += 1\\n            if i - j + 1 >= k :\\n                cnt = 0\\n                # calculate xth smallest number in current sliding windows\\n                for L in reversed(range(51)):\\n                    cnt += freq[L]\\n                    if cnt >= x:\\n                        ans.append(-L)\\n                        break\\n                # No xth smallest number present \\n                if cnt < x : ans.append(0)\\n                if nums[j] < 0 : freq[abs(nums[j])] -= 1\\n                j += 1\\n            \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445945,
                "title": "using-map-sliding-window-very-simple-easy-to-understand",
                "content": "<b> Up Vote if you like the solution</b>\\n# Approach\\nUsing map we will keep storing the count of -50 to 50 in each window of size k.\\nThen with each window need to search the xth smallest element by counting the number of occurance of each element, in the map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); ++i){\\n            mp[nums[i]]++;\\n            if(i >= k-1){ \\n                if(i >= k) mp[nums[i-k]]--;\\n                int sum = 0, t = 0;\\n                for(auto m: mp){\\n                    sum += m.second;\\n                    if(sum >= x){\\n                        t = (m.first < 0)? m.first: 0;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); ++i){\\n            mp[nums[i]]++;\\n            if(i >= k-1){ \\n                if(i >= k) mp[nums[i-k]]--;\\n                int sum = 0, t = 0;\\n                for(auto m: mp){\\n                    sum += m.second;\\n                    if(sum >= x){\\n                        t = (m.first < 0)? m.first: 0;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445735,
                "title": "c-multiset-using-next-function-explained",
                "content": "**DISCLAIMER: This is not an optimised approach but it is working**\\t\\n\\n\\n**C++ Code:**\\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        int n = nums.size(), j = 0;\\n        \\n        multiset<int> ms;\\n        vector<int> res;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(nums[i] < 0) ms.insert(nums[i]);\\n            \\n            if(i-j+1 == k) {\\n                \\n                if(ms.size() < x)res.push_back(0);\\n                else res.push_back(*next(ms.begin(), x - 1));\\n                \\n                if(nums[j] < 0) ms.erase(ms.find(nums[j]));\\n                \\n                j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        int n = nums.size(), j = 0;\\n        \\n        multiset<int> ms;\\n        vector<int> res;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(nums[i] < 0) ms.insert(nums[i]);\\n            \\n            if(i-j+1 == k) {\\n                \\n                if(ms.size() < x)res.push_back(0);\\n                else res.push_back(*next(ms.begin(), x - 1));\\n                \\n                if(nums[j] < 0) ms.erase(ms.find(nums[j]));\\n                \\n                j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445781,
                "title": "python3-sortedlist",
                "content": "\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        vals = SortedList()\\n        for i, v in enumerate(nums): \\n            vals.add(v)\\n            if i >= k: vals.remove(nums[i-k])\\n            if i >= k-1: ans.append(min(0, vals[x-1]))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        vals = SortedList()\\n        for i, v in enumerate(nums): \\n            vals.add(v)\\n            if i >= k: vals.remove(nums[i-k])\\n            if i >= k-1: ans.append(min(0, vals[x-1]))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446019,
                "title": "policy-based-c",
                "content": "```\\n#include<iostream>\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp> \\n\\nusing namespace __gnu_pbds; \\nusing namespace std;\\n\\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n    int rank = t.order_of_key(v);\\n    ordered_set::iterator it = t.find_by_order(rank);\\n    t.erase(it);\\n}\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_set st;\\n        int i=0,j=0;\\n        vector<int> ans;\\n        while(j<nums.size())\\n        {\\n            if(nums[j]<0)\\n            st.insert(nums[j]);\\n            if(j-i+1==k)\\n            {\\n                if(st.size()<x)\\n                ans.push_back(0);\\n                else\\n                {\\n                    auto temp = st.find_by_order(x-1);\\n                    ans.push_back(*temp);\\n                }\\n                if(nums[i]<0)\\n                myerase(st,nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include<iostream>\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp> \\n\\nusing namespace __gnu_pbds; \\nusing namespace std;\\n\\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n    int rank = t.order_of_key(v);\\n    ordered_set::iterator it = t.find_by_order(rank);\\n    t.erase(it);\\n}\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_set st;\\n        int i=0,j=0;\\n        vector<int> ans;\\n        while(j<nums.size())\\n        {\\n            if(nums[j]<0)\\n            st.insert(nums[j]);\\n            if(j-i+1==k)\\n            {\\n                if(st.size()<x)\\n                ans.push_back(0);\\n                else\\n                {\\n                    auto temp = st.find_by_order(x-1);\\n                    ans.push_back(*temp);\\n                }\\n                if(nums[i]<0)\\n                myerase(st,nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3446035,
                "title": "javascript-2653-sliding-subarray-beauty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar getSubarrayBeauty = function (a, k, x) {\\n    let n = a.length;\\n\\n    let f = {}; // frequency count\\n    for (let i = -50; i <= 50; i++) {\\n        f[i] = 0;\\n    }\\n\\n    let an = [];\\n    let j = 0;\\n    for (let i = 0; i < n; i++) {\\n        f[a[i]]++;\\n        if (i < k - 1) continue; // skip first k-1 elements\\n\\n        let c = 0; // count\\n        for (let i2 = -50; i2 <= 50; i2++)\\n            if (f[i2]) {\\n                c += f[i2]; // add frequency to count\\n                if (c >= x) {\\n                    if (i2 < 0) an.push(i2);\\n                    else an.push(0);\\n                    break;\\n                }\\n            }\\n\\n        f[a[j]]--;\\n        j++;\\n    }\\n\\n    return an;\\n};\\n```\\n\\n---\\n\\n**Contest**\\n- https://leetcode.com/contest/weekly-contest-342/ranking/67/\\n\\n**All Answers**\\n- **Q1** - https://leetcode.com/problems/calculate-delayed-arrival-time/solutions/3446023/javascript-2651-calculate-delayed-arrival-time/?orderBy=most_votes\\n- **Q2** - https://leetcode.com/problems/sum-multiples/solutions/3446027/javascript-2652-sum-multiples/?orderBy=most_votes\\n- **Q3** - https://leetcode.com/problems/sliding-subarray-beauty/solutions/3446035/javascript-2653-sliding-subarray-beauty/?orderBy=most_votes\\n- **Q4** - https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/solutions/3446411/javascript-2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1/?orderBy=most_votes\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/37970e7b-b559-4aa9-834c-e178df5ddaa7_1682232917.7638698.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getSubarrayBeauty = function (a, k, x) {\\n    let n = a.length;\\n\\n    let f = {}; // frequency count\\n    for (let i = -50; i <= 50; i++) {\\n        f[i] = 0;\\n    }\\n\\n    let an = [];\\n    let j = 0;\\n    for (let i = 0; i < n; i++) {\\n        f[a[i]]++;\\n        if (i < k - 1) continue; // skip first k-1 elements\\n\\n        let c = 0; // count\\n        for (let i2 = -50; i2 <= 50; i2++)\\n            if (f[i2]) {\\n                c += f[i2]; // add frequency to count\\n                if (c >= x) {\\n                    if (i2 < 0) an.push(i2);\\n                    else an.push(0);\\n                    break;\\n                }\\n            }\\n\\n        f[a[j]]--;\\n        j++;\\n    }\\n\\n    return an;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445753,
                "title": "cpp-window-sliding-open-addressing-map",
                "content": "### Intuition : \\nAs the numbers are in the range `[-50,50]` we can just increase , decrease count as we move ahead the window.\\nand loop through `[-50,50]` and keep on adding int `cnt` if `cnt >= x` that means that particular number is xth smallest.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        vector<int> ans;\\n        vector<vector<int>> mp(101);\\n        int start = 0,end = 0,n = v.size();\\n        while(end < n) {\\n            mp[v[end] + 50].push_back(v[end++]);\\n            if(end - start > k) {\\n                mp[v[start] + 50].pop_back();\\n                start++;\\n            }\\n            if(end - start == k) {\\n                int cnt = 0, val;\\n                for(int i = 0; i <= 100; i += 1) {\\n                    cnt += mp[i].size();\\n                    if(cnt >= x) {\\n                        val = mp[i][0];\\n                        break;\\n                    }\\n                }\\n                ans.push_back(val > 0 ? 0 : val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n#### Optimisation 1 : \\nWe can just count instead of storing .\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        vector<int> ans;\\n        vector<int> mp(101);\\n        int start = 0,end = 0,n = v.size();\\n        while(end < n) {\\n            mp[v[end] + 50]++;\\n            end++;\\n            if(end - start > k) {\\n                mp[v[start++] + 50]--;\\n            }\\n            if(end - start == k) {\\n                int cnt = 0, val;\\n                for(int i = 0; i <= 100; i += 1) {\\n                    cnt += mp[i];\\n                    if(cnt >= x) {\\n                        val = i - 50;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(val > 0 ? 0 : val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        vector<int> ans;\\n        vector<vector<int>> mp(101);\\n        int start = 0,end = 0,n = v.size();\\n        while(end < n) {\\n            mp[v[end] + 50].push_back(v[end++]);\\n            if(end - start > k) {\\n                mp[v[start] + 50].pop_back();\\n                start++;\\n            }\\n            if(end - start == k) {\\n                int cnt = 0, val;\\n                for(int i = 0; i <= 100; i += 1) {\\n                    cnt += mp[i].size();\\n                    if(cnt >= x) {\\n                        val = mp[i][0];\\n                        break;\\n                    }\\n                }\\n                ans.push_back(val > 0 ? 0 : val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        vector<int> ans;\\n        vector<int> mp(101);\\n        int start = 0,end = 0,n = v.size();\\n        while(end < n) {\\n            mp[v[end] + 50]++;\\n            end++;\\n            if(end - start > k) {\\n                mp[v[start++] + 50]--;\\n            }\\n            if(end - start == k) {\\n                int cnt = 0, val;\\n                for(int i = 0; i <= 100; i += 1) {\\n                    cnt += mp[i];\\n                    if(cnt >= x) {\\n                        val = i - 50;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(val > 0 ? 0 : val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445694,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int a[] = new int[101];\\n        int res[] = new int[n - k + 1];\\n        for (int i=0;i<k;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }\\n        for (int i=0;i<=n-k;i++)\\n        {\\n            int count=0,val=-1;\\n            for(int j=0;j<=49;j++)\\n            {\\n                if(a[j]>0)\\n                {\\n                    count+=a[j];\\n                    if(count>=x)\\n                    {\\n                        val=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            a[nums[i]+50]--;\\n            if(i<n-k)\\n            {\\n                a[nums[i+k]+50]++;\\n            }\\n            res[i] = val == -1 ? 0 : val-50;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int a[] = new int[101];\\n        int res[] = new int[n - k + 1];\\n        for (int i=0;i<k;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }\\n        for (int i=0;i<=n-k;i++)\\n        {\\n            int count=0,val=-1;\\n            for(int j=0;j<=49;j++)\\n            {\\n                if(a[j]>0)\\n                {\\n                    count+=a[j];\\n                    if(count>=x)\\n                    {\\n                        val=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            a[nums[i]+50]--;\\n            if(i<n-k)\\n            {\\n                a[nums[i+k]+50]++;\\n            }\\n            res[i] = val == -1 ? 0 : val-50;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445893,
                "title": "sliding-window-map-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConstraints are low like value of elements of array are between -50 to 50, so we can use map to optimise sliding window here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Push first k element in Map\\n2. Find second smallest element using counting if we find we compare the value with 0 and take minimum of it. (positive element is second smallest take ans[i] as 0).\\n3. push the second smallest element in ans,repeat this process n-k-1 times using sliding window.\\n4. Return the ans\\n\\n# Complexity\\n- Time complexity: O(N*LogN) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n     \\n        int n=nums.size();\\n        map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        vector<int> answer;\\n        int cnt=0;\\n        int res=0;\\n        for(auto y:mp)\\n        {\\n          cnt+=y.second;\\n            if(cnt>=x)\\n            {\\n                res=min(res,y.first);\\n                break;\\n            }\\n        }\\n        answer.push_back(res);\\n        for(int i=k;i<n;i++)\\n        {\\n            mp[nums[i-k]]--;\\n            if(mp[nums[i-k]]==0) mp.erase(nums[i-k]);\\n            mp[nums[i]]++;\\n            int cnt=0;\\n            int res=0;\\n          for(auto y:mp)\\n          {\\n             cnt+=y.second;\\n             if(cnt>=x)\\n             {\\n                res=min(res,y.first);\\n                break;\\n             }\\n       \\n          }\\n         answer.push_back(res);     \\n        }\\n    return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n     \\n        int n=nums.size();\\n        map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        vector<int> answer;\\n        int cnt=0;\\n        int res=0;\\n        for(auto y:mp)\\n        {\\n          cnt+=y.second;\\n            if(cnt>=x)\\n            {\\n                res=min(res,y.first);\\n                break;\\n            }\\n        }\\n        answer.push_back(res);\\n        for(int i=k;i<n;i++)\\n        {\\n            mp[nums[i-k]]--;\\n            if(mp[nums[i-k]]==0) mp.erase(nums[i-k]);\\n            mp[nums[i]]++;\\n            int cnt=0;\\n            int res=0;\\n          for(auto y:mp)\\n          {\\n             cnt+=y.second;\\n             if(cnt>=x)\\n             {\\n                res=min(res,y.first);\\n                break;\\n             }\\n       \\n          }\\n         answer.push_back(res);     \\n        }\\n    return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445704,
                "title": "python-3-sorted-containers",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        win = SortedList()\\n        \\n        for i in range(k):\\n            win.add(nums[i])\\n        \\n        res = []\\n        if win[x - 1] < 0:\\n            res.append(win[x - 1])\\n        else:\\n            res.append(0)\\n        \\n        for i in range(k, len(nums)):\\n            win.add(nums[i])\\n            win.discard(nums[i - k])\\n            \\n            if win[x - 1] < 0:\\n                res.append(win[x - 1])\\n            else:\\n                res.append(0)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        win = SortedList()\\n        \\n        for i in range(k):\\n            win.add(nums[i])\\n        \\n        res = []\\n        if win[x - 1] < 0:\\n            res.append(win[x - 1])\\n        else:\\n            res.append(0)\\n        \\n        for i in range(k, len(nums)):\\n            win.add(nums[i])\\n            win.discard(nums[i - k])\\n            \\n            if win[x - 1] < 0:\\n                res.append(win[x - 1])\\n            else:\\n                res.append(0)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445678,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int func(int x){\\n        int val=0;\\n        for(auto ele:mp){\\n            if(ele.second+val >= x){\\n                if(ele.first > 0)\\n                    return 0;\\n                return ele.first;\\n            }\\n            val += ele.second;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n            if(i>=k)\\n                mp[nums[i-k]]--;\\n            if(i>=k-1)\\n                ans.push_back(func(x));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int func(int x){\\n        int val=0;\\n        for(auto ele:mp){\\n            if(ele.second+val >= x){\\n                if(ele.first > 0)\\n                    return 0;\\n                return ele.first;\\n            }\\n            val += ele.second;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n            if(i>=k)\\n                mp[nums[i-k]]--;\\n            if(i>=k-1)\\n                ans.push_back(func(x));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446469,
                "title": "unordered-map-o-n-50-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size(), i = 0;\\n        unordered_map<int, int> m;\\n        vector<int> ans;\\n        \\n        for(int j=0; j<n; j++) {\\n            m[nums[j]]++;\\n            if(j - i + 1 == k) {\\n                int cnt = x;\\n                for(int val=-50; val<=-1; val++) {\\n                    cnt -= m[val];\\n                    if(cnt <= 0) {\\n                        ans.push_back(val);\\n                        break;\\n                    }\\n                }\\n                if(cnt > 0) ans.push_back(0);\\n                m[nums[i++]]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size(), i = 0;\\n        unordered_map<int, int> m;\\n        vector<int> ans;\\n        \\n        for(int j=0; j<n; j++) {\\n            m[nums[j]]++;\\n            if(j - i + 1 == k) {\\n                int cnt = x;\\n                for(int val=-50; val<=-1; val++) {\\n                    cnt -= m[val];\\n                    if(cnt <= 0) {\\n                        ans.push_back(val);\\n                        break;\\n                    }\\n                }\\n                if(cnt > 0) ans.push_back(0);\\n                m[nums[i++]]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446816,
                "title": "python-easiest-3-three-approach-hash-map-sortedlist-ds-slinding-windows",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition behind question is very simple sliding window but the extra things is added we have to find the xth smallest number so, we are using either sort again again or some data structure like sorted list to find the xth smallest number.\\nI think in this question only we have deal with optimization.\\nFirst i think in the slinding window we make the k size window and find x the minimum element by sorting again again but it giving TLE \\nafter so many TLE i think of the sortedList data structure.\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNote:SortedList Time Complexity is 0(log(n)) that\\'s why we are using SortedList Data structure \\n**Step1:First we are add element of k-1 range  make window of k-1 range in a sortedList\\nSTEP2: Then we are iterate from iterate from the( k+1,len(nums)) and if len(a)>=x and xth smallest is <0 negative number and add in ans list otherwise we are adding 0\\nSTEP3: Slide the window by adding and the remove first element**\\n![WhatsApp Image 2023-04-23 at 2.24.39 PM.jpeg](https://assets.leetcode.com/users/images/ada39c63-3883-4f25-a877-1a46e2c02c9f_1682240267.7857494.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n(log(n)))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**GIVING LEETCODE CONTEST IN MORNING BE LIKE\\uD83D\\uDE05\\uD83D\\uDE05**\\n**US BRO US\\uD83E\\uDD72**\\n![6b6a5f7b23bcfbbea25e680b77369890.jpg](https://assets.leetcode.com/users/images/468495ef-994e-49d1-a69a-e0e12b96137e_1682239704.2012587.jpeg)\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        # Its Time Complexity is 0(log(n)) that\\'s why we are using SortedList Data structure \\n        a=SortedList([])\\n        ans=[]\\n        #STEP1: First we are add element of k-1 range  make window of k-1 range\\n        for ws in range(k):\\n            a.add(nums[ws])\\n        #STEP2: Then we are iterate from iterate from the k+1,len(nums) and if len(a)>=x and xth smallest is <0 \\n        for i in range(k,len(nums)):\\n            if x<=len(a) and a[x-1]<0:\\n                ans.append(a[x-1])\\n            else:\\n                ans.append(0)\\n        #STEP3: Slide the window by adding and the remove first element\\n            a.remove(nums[i-k])\\n            a.add(nums[i])\\n         \\n        # print(ans)\\n    #Remaining last element \\n        if x<=len(a) and a[x-1]<0:\\n                ans.append(a[x-1])\\n        else:\\n            ans.append(0)\\n \\n            # a.remove(nums[i-k])\\n            # a.add(nums[i])\\n        return ans\\n```\\n```python []\\n#TLE GIVING FOR THE 10 TASTE CASES THIS IS BRUTE FORCE\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ws=0\\n        we=k-1\\n        l1=[]\\n        for i in range (we,len(nums)):\\n            arr=sorted(nums[ws:i+1])\\n            min1=arr[x-1]\\n            if min1>0:\\n                l1.append(0)\\n            else:\\n                l1.append(arr[x-1])\\n            ws+=1\\n        return l1\\n\\n\\n\\n```\\n```python []\\n#IN python their is no such ordered map so we make ordered hash map but is is also giving TLE\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n    \\n        dict1={}\\n        c=0\\n        w_start=0\\n        l1=[]\\n        def solve(dict1):\\n            c=0\\n            myKeys = list(dict1.keys())\\n            myKeys.sort()\\n            sorted_dict = {i: dict1[i] for i in myKeys}\\n            for i in sorted_dict  :\\n                c+=dict1[i]\\n                if c>=x:\\n                    return i\\n            return float(\\'inf\\')\\n        for we in range (len(nums)):\\n            if nums[we] not in dict1:\\n                dict1[nums[we]]=1\\n            else:\\n                dict1[nums[we]]+=1\\n            while we-w_start+1>k:\\n                dict1[nums[w_start]]-=1\\n                if dict1[nums[w_start]]==0:\\n                    del dict1[nums[w_start]]\\n                w_start+=1\\n            if we-w_start+1==k:\\n                #search for x smallest\\n                min1=solve(dict1)\\n                if min1>0 or min1==float(\\'inf\\'):\\n                    l1.append(0)\\n                else:\\n                    l1.append(min1)\\n        return l1\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        # Its Time Complexity is 0(log(n)) that\\'s why we are using SortedList Data structure \\n        a=SortedList([])\\n        ans=[]\\n        #STEP1: First we are add element of k-1 range  make window of k-1 range\\n        for ws in range(k):\\n            a.add(nums[ws])\\n        #STEP2: Then we are iterate from iterate from the k+1,len(nums) and if len(a)>=x and xth smallest is <0 \\n        for i in range(k,len(nums)):\\n            if x<=len(a) and a[x-1]<0:\\n                ans.append(a[x-1])\\n            else:\\n                ans.append(0)\\n        #STEP3: Slide the window by adding and the remove first element\\n            a.remove(nums[i-k])\\n            a.add(nums[i])\\n         \\n        # print(ans)\\n    #Remaining last element \\n        if x<=len(a) and a[x-1]<0:\\n                ans.append(a[x-1])\\n        else:\\n            ans.append(0)\\n \\n            # a.remove(nums[i-k])\\n            # a.add(nums[i])\\n        return ans\\n```\n```python []\\n#TLE GIVING FOR THE 10 TASTE CASES THIS IS BRUTE FORCE\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ws=0\\n        we=k-1\\n        l1=[]\\n        for i in range (we,len(nums)):\\n            arr=sorted(nums[ws:i+1])\\n            min1=arr[x-1]\\n            if min1>0:\\n                l1.append(0)\\n            else:\\n                l1.append(arr[x-1])\\n            ws+=1\\n        return l1\\n\\n\\n\\n```\n```python []\\n#IN python their is no such ordered map so we make ordered hash map but is is also giving TLE\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n    \\n        dict1={}\\n        c=0\\n        w_start=0\\n        l1=[]\\n        def solve(dict1):\\n            c=0\\n            myKeys = list(dict1.keys())\\n            myKeys.sort()\\n            sorted_dict = {i: dict1[i] for i in myKeys}\\n            for i in sorted_dict  :\\n                c+=dict1[i]\\n                if c>=x:\\n                    return i\\n            return float(\\'inf\\')\\n        for we in range (len(nums)):\\n            if nums[we] not in dict1:\\n                dict1[nums[we]]=1\\n            else:\\n                dict1[nums[we]]+=1\\n            while we-w_start+1>k:\\n                dict1[nums[w_start]]-=1\\n                if dict1[nums[w_start]]==0:\\n                    del dict1[nums[w_start]]\\n                w_start+=1\\n            if we-w_start+1==k:\\n                #search for x smallest\\n                min1=solve(dict1)\\n                if min1>0 or min1==float(\\'inf\\'):\\n                    l1.append(0)\\n                else:\\n                    l1.append(min1)\\n        return l1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446064,
                "title": "leetcode-the-hard-way-sortedlist",
                "content": "```py\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        res = []\\n        w = SortedList(nums[:k])\\n        res.append(0 if w[x - 1] > 0 else w[x - 1])\\n        for i in range(k, len(nums)) :\\n            w.remove(nums[i - k])\\n            w.add(nums[i])\\n            res.append(0 if w[x - 1] > 0 else w[x - 1])\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```py\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        res = []\\n        w = SortedList(nums[:k])\\n        res.append(0 if w[x - 1] > 0 else w[x - 1])\\n        for i in range(k, len(nums)) :\\n            w.remove(nums[i - k])\\n            w.add(nums[i])\\n            res.append(0 if w[x - 1] > 0 else w[x - 1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445758,
                "title": "ez-c-using-sliding-window",
                "content": "**Time Complexity : O(Nlog N)\\nSpace Complexity : O(N)**\\n\\nInitial Thought Process : \\n* I thought of using a multiset to store the \\'k\\' elements and during each iteration add the \\'x\\' th smallest negative number to our answer.\\n* This resulted in TLE since the find opeartion takes O(log N) and erase also took time.\\n* Since multiset uses bidirectional iterator we won\\'t be directly able to access the xth element by doing `ms.begin()+x` . We need to advance the iterator, which is also very time consuming.\\n* So the next approach I thought was the sliding window approach and after a few trial and error I came upwith the solution.\\n\\n```\\nclass Solution {\\npublic:\\n    int find_element(map<int,int>&m,int x){\\n        int c=0;\\n        for(auto i:m){\\n             c+=i.second;//Incrementing counter to point to the corresponding elment in our key-value pair\\n            if(c>=x) //This means that the \\'x\\' element is present so we return it\\n                return i.first;\\n           \\n        }\\n        return INT_MAX; // \\'x\\' the smallest element not in our window\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        map<int,int>m;\\n        int i=0;\\n       vector<int>res;\\n        \\n        for(int j=0;j<nums.size();j++){\\n            \\n            m[nums[j]]++; // Add element to the window\\n            while((j-i+1)>k){           //Invalid Window Size     \\n                m[nums[i]]--;// Removing element from our window\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n                i++;\\n            }\\n            \\n            if((j-i+1)==k){//Valid Window\\n                int minX=find_element(m,x);//Searching for the \\'x\\' th smallest negative element in our window\\n                if(minX==INT_MAX||minX>0)\\n                    res.push_back(0);\\n                else\\n                    res.push_back(minX);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_element(map<int,int>&m,int x){\\n        int c=0;\\n        for(auto i:m){\\n             c+=i.second;//Incrementing counter to point to the corresponding elment in our key-value pair\\n            if(c>=x) //This means that the \\'x\\' element is present so we return it\\n                return i.first;\\n           \\n        }\\n        return INT_MAX; // \\'x\\' the smallest element not in our window\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        map<int,int>m;\\n        int i=0;\\n       vector<int>res;\\n        \\n        for(int j=0;j<nums.size();j++){\\n            \\n            m[nums[j]]++; // Add element to the window\\n            while((j-i+1)>k){           //Invalid Window Size     \\n                m[nums[i]]--;// Removing element from our window\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n                i++;\\n            }\\n            \\n            if((j-i+1)==k){//Valid Window\\n                int minX=find_element(m,x);//Searching for the \\'x\\' th smallest negative element in our window\\n                if(minX==INT_MAX||minX>0)\\n                    res.push_back(0);\\n                else\\n                    res.push_back(minX);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445737,
                "title": "c-code-using-multi-set-erase-without-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution { \\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    { \\n        multiset<int> negNums = getInitialSet(nums, k);\\n        vector<int> ans = getBeautyArray(negNums, x);\\n        for (int i = k; i < nums.size(); i++) \\n        {\\n            updateSet(negNums, nums[i - k], nums[i]);\\n            ans.push_back(getBeautyElement(negNums, x));\\n        } \\n        return ans;  \\n    } \\nprivate:\\n    multiset<int> getInitialSet(const vector<int>& nums, int k) \\n    {\\n        multiset<int> negNums; \\n        for (int i = 0; i < k; i++) \\n        { \\n            if (nums[i] < 0) \\n            { \\n                negNums.insert(nums[i]); \\n            } \\n        } \\n        return negNums;\\n    }\\n    \\n    vector<int> getBeautyArray(const multiset<int>& negNums, int x) \\n    {\\n        vector<int> ans; \\n        if (negNums.size() >= x) \\n        { \\n            ans.push_back(*next(negNums.begin(), x - 1)); \\n        } \\n        else \\n        { \\n            ans.push_back(0); \\n        } \\n        return ans;\\n    }\\n    void updateSet(multiset<int>& negNums, int oldNum, int newNum) \\n    {\\n        if (oldNum < 0) \\n        { \\n            negNums.erase(negNums.lower_bound(oldNum)); \\n        } \\n        if (newNum < 0) \\n        { \\n            negNums.insert(newNum); \\n        }\\n    }\\n    int getBeautyElement(const multiset<int>& negNums, int x) \\n    {\\n        if (negNums.size() >= x) \\n        { \\n            return *next(negNums.begin(), x - 1); \\n        } \\n        else \\n        { \\n            return 0; \\n        } \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { \\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    { \\n        multiset<int> negNums = getInitialSet(nums, k);\\n        vector<int> ans = getBeautyArray(negNums, x);\\n        for (int i = k; i < nums.size(); i++) \\n        {\\n            updateSet(negNums, nums[i - k], nums[i]);\\n            ans.push_back(getBeautyElement(negNums, x));\\n        } \\n        return ans;  \\n    } \\nprivate:\\n    multiset<int> getInitialSet(const vector<int>& nums, int k) \\n    {\\n        multiset<int> negNums; \\n        for (int i = 0; i < k; i++) \\n        { \\n            if (nums[i] < 0) \\n            { \\n                negNums.insert(nums[i]); \\n            } \\n        } \\n        return negNums;\\n    }\\n    \\n    vector<int> getBeautyArray(const multiset<int>& negNums, int x) \\n    {\\n        vector<int> ans; \\n        if (negNums.size() >= x) \\n        { \\n            ans.push_back(*next(negNums.begin(), x - 1)); \\n        } \\n        else \\n        { \\n            ans.push_back(0); \\n        } \\n        return ans;\\n    }\\n    void updateSet(multiset<int>& negNums, int oldNum, int newNum) \\n    {\\n        if (oldNum < 0) \\n        { \\n            negNums.erase(negNums.lower_bound(oldNum)); \\n        } \\n        if (newNum < 0) \\n        { \\n            negNums.insert(newNum); \\n        }\\n    }\\n    int getBeautyElement(const multiset<int>& negNums, int x) \\n    {\\n        if (negNums.size() >= x) \\n        { \\n            return *next(negNums.begin(), x - 1); \\n        } \\n        else \\n        { \\n            return 0; \\n        } \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446465,
                "title": "c-easiest-solution-using-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int i=0;\\n        int j=0;\\n        int n=nums.size();\\n        vector<int> v(51,0);\\n        vector<int> ans;\\n        while(j<n)\\n        {\\n            if(nums[j]<0)\\n            v[(nums[j]+50)%50]++;\\n            if(j-i+1==k)\\n            {\\n                int p=x;\\n                bool flag=false;\\n                vector<int> v1=v;\\n                for(int i=0;i<=50;i++)\\n                {\\n                    if(v1[i]>0)\\n                    {\\n                        p-=v1[i];\\n                    }\\n                    if(p<=0)\\n                    {\\n                        ans.push_back(i-50);\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                ans.push_back(0);\\n                if(nums[i]<0)\\n                v[(nums[i]+50)%50]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int i=0;\\n        int j=0;\\n        int n=nums.size();\\n        vector<int> v(51,0);\\n        vector<int> ans;\\n        while(j<n)\\n        {\\n            if(nums[j]<0)\\n            v[(nums[j]+50)%50]++;\\n            if(j-i+1==k)\\n            {\\n                int p=x;\\n                bool flag=false;\\n                vector<int> v1=v;\\n                for(int i=0;i<=50;i++)\\n                {\\n                    if(v1[i]>0)\\n                    {\\n                        p-=v1[i];\\n                    }\\n                    if(p<=0)\\n                    {\\n                        ans.push_back(i-50);\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                ans.push_back(0);\\n                if(nums[i]<0)\\n                v[(nums[i]+50)%50]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445799,
                "title": "c-soutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe function takes an input array of integers, the length of the subarray to be considered, and a count x. It then returns an array of integers that contains the maximum negative integer of the subarrays of length k that contain at least x negative integers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a sliding window approach to go through the input array nums. We maintain a counter for negative integers in negative_count initialized with 50 elements (covering the range from -49 to 0). Whenever we add a new integer to the current window, we increment the counter at the corresponding index if it\\'s negative. Similarly, when we move the window to the right, we decrement the counter at the corresponding index if the element falling out of the window is negative.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(nk), where n is the size of the input array nums, and k is the input parameter representing the size of the subarrays.\\n\\nThe function iterates through the array nums once, and for each element it performs three operations: updating the counter for the current element, removing the counter for the element outside the current subarray, and finding the smallest negative element with frequency >= x.\\n\\nEach of these operations takes O(1) time, except for finding the smallest negative element with frequency >= x, which takes O(50) time (since there are at most 50 distinct negative numbers in the input).\\n\\nSince the function iterates through nums once and performs O(1) operations for each element, the overall time complexity is O(nk).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this function is O(1) for the input array nums and the input parameters k and x.\\n\\nThe function uses two additional vectors: ans and counter. The size of ans is nums.size() - k + 1, which is O(n) in the worst case. The size of counter is 50, which is a constant. Therefore, the space complexity of the function is O(n) in the worst case.\\n\\nHowever, we can optimize the space complexity by using a sliding window approach to update the counter vector, and computing the result for each subarray as we go along, instead of storing it in the ans vector. This would reduce the space complexity to O(1), since we would only need to store a constant amount of additional variables to compute the result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans(nums.size() - k + 1, 0), counter(50, 0);\\n        for (int i = 0; i < nums.size(); i++) {\\n            // Update counter for current element\\n            if (nums[i] < 0) counter[nums[i] + 50]++;\\n            // Remove counter for the element outside the current subarray\\n            if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n            // Check if current subarray size is greater than k\\n            if (i - k + 1 < 0) continue;\\n            // Find the smallest negative element with frequency >= x\\n            int count = 0;\\n            for (int j = 0; j < 50; j++) {\\n                count += counter[j];\\n                if (count >= x) {\\n                    ans[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans(nums.size() - k + 1, 0), counter(50, 0);\\n        for (int i = 0; i < nums.size(); i++) {\\n            // Update counter for current element\\n            if (nums[i] < 0) counter[nums[i] + 50]++;\\n            // Remove counter for the element outside the current subarray\\n            if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n            // Check if current subarray size is greater than k\\n            if (i - k + 1 < 0) continue;\\n            // Find the smallest negative element with frequency >= x\\n            int count = 0;\\n            for (int j = 0; j < 50; j++) {\\n                count += counter[j];\\n                if (count >= x) {\\n                    ans[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448390,
                "title": "easy-understable-sliding-window-using-map",
                "content": "# Intuition\\nUSe sliding window and use map to find the Xth smallest negative number.\\n\\n# Approach\\nRun a loop and count the frequency of negative number and check if frequency is equal to the X. If yes then push that element in ans vector and if no then just push 0.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        map<int,int>mp;\\n        for(int i=0;i<k;++i){\\n            mp[nums[i]]++;\\n        } \\n        \\n        vector<int>ans;\\n        int j=0;\\n        for(int i=k;i<=n;++i){\\n            int cnt=0;\\n            for(auto m:mp){\\n                if(m.first<=0){\\n                    if(m.second>0) cnt+=m.second;\\n                    if(cnt>=x){\\n                        ans.push_back(m.first);\\n                        break;\\n                    }\\n                }\\n            }\\n            if(cnt<x) ans.push_back(0);\\n            if(i==n) break;\\n            mp[nums[i]]++;\\n            mp[nums[j]]--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        map<int,int>mp;\\n        for(int i=0;i<k;++i){\\n            mp[nums[i]]++;\\n        } \\n        \\n        vector<int>ans;\\n        int j=0;\\n        for(int i=k;i<=n;++i){\\n            int cnt=0;\\n            for(auto m:mp){\\n                if(m.first<=0){\\n                    if(m.second>0) cnt+=m.second;\\n                    if(cnt>=x){\\n                        ans.push_back(m.first);\\n                        break;\\n                    }\\n                }\\n            }\\n            if(cnt<x) ans.push_back(0);\\n            if(i==n) break;\\n            mp[nums[i]]++;\\n            mp[nums[j]]--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447155,
                "title": "brute-force-200-717-tc-priority-queue-702-717-tc-passed-optimised-queue-map-c",
                "content": "class Solution {\\npublic:\\n    \\n    //APPROACH 2- PRIORITY QUEUE TLE\\n        int priority(vector<int>&nums,int i,int j,int x){\\n            priority_queue<int> pq;\\n            for(int l=i;l<j;l++){\\n                pq.push(nums[l]);\\n                if(pq.size()>x)pq.pop();\\n            }\\n            return pq.top();\\n        }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        //APPROACH-1 BRUTE FORCE\\n        int n=nums.size();\\n       \\n        int i=0,j=0;\\n        bool ok=false;\\n            priority_queue<int,vector<int>,greater<int>> pq;\\n        vector<int> ans;\\n        if(k==1 && x==1) {\\n            ok=true;\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i]<0)ans.push_back(nums[i]);\\n                else ans.push_back(0);\\n            }\\n        }\\n        if(ok==false)\\n        while(j<nums.size()){\\n            pq.push(nums[j]);\\n            if(j-i+1<k)j++;\\n            else if(j-i+1<=k){\\n                int temp=0;\\n                int cnt=0;\\n                bool flag=false;\\n                for(int k=0;k<x;k++){\\n                     if(pq.top()>0){ \\n                            cnt++;\\n                        }\\n                    else break;\\n                }\\n                if(k==cnt){\\n                    temp=0;\\n                    flag=true;\\n                }\\n               if(flag==false) for(int k=0;k<x;k++){\\n                       \\n                        temp=(pq.top());\\n                        //cout<<pq.top()<<\" \";\\n                   if(k==0)pq.pop();\\n                    if(k==x-1) break;\\n                    \\n                }\\n                if(temp>0) temp=0;\\n                //cout<<pq.top()<<\" \";\\n              //  cout<<temp<<\" \";\\n                ans.push_back(temp);\\n               // for(auto it:ans) cout<<it<<\" \";\\n                pq.push(nums[j]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    \\n        //APPROACH 2- PRIORITY QUEUE\\n        int n=nums.size();\\n        int i=0;\\n        vector<int> ans;\\n        int j=k;\\n        while(j-1!=n){\\n            int minElement=priority(nums,i,j,x);\\n            if(minElement>0) ans.push_back(0);\\n            else ans.push_back(minElement);\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n        \\n        //OPTIMISED QUEUE+MAP\\n         int n=nums.size();\\n         map<int,int> mp;\\n        vector<int> ans;\\n        queue<int> q;\\n        for(auto it:nums){\\n            mp[it]++;\\n            q.push(it);\\n        \\n        if(q.size()==k){\\n        int curr=q.front();\\n        q.pop();\\n        int siz=0;\\n        for(auto it:mp){\\n            siz+=it.second;\\n            if(siz>=x){\\n                if(it.first>0) ans.push_back(0);\\n                else ans.push_back(it.first);\\n                break;\\n            }\\n        }\\n            if(mp[curr]>1)mp[curr]--;\\n            else mp.erase(curr);\\n         }\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    //APPROACH 2- PRIORITY QUEUE TLE\\n        int priority(vector<int>&nums,int i,int j,int x){\\n            priority_queue<int> pq;\\n            for(int l=i;l<j;l++){\\n                pq.push(nums[l]);\\n                if(pq.size()>x)pq.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3446993,
                "title": "easy-explanation-multiset-pointer-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we require `xth` smallest element, we should use a container which keeps element sorted for quick queries. Also, note that the values may repeat.\\nSo we can use a `multiset`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to always keep the pointer at the `xth` smallest element after insertion/deletion operations.\\n\\n**But exactly how?**\\nOnce, we insert first `k` set of numbers. We can simply move to the `xth` smallest element in the multiset from the begining to initialize our pointer `ptr`. This would take `x - 1` steps. \\nThen for each insertion/deletion we can follow below steps to maintain our pointer at correct position.\\n\\nAssume that we are at `ith` iteration and value at our `ptr` is `ptr_value`.\\n**Insertion**\\nElement to be inserted is `nums[i]`. First insert this element. Then:\\n* If `nums[i] < ptr_value`: \\nThis value is inserted to the left of `ptr` hence the `ptr` is now pointing to `x+1`th smallest element. Therefore, simply shift `ptr` to one place left(`ptr--`).\\n* Otherwise, the `ptr` remains at correct position.\\n\\n**Deletion**\\nElement to be removed is `nums[i - k]`.\\n* If `nums[i - k] <= ptr_value`: \\nThis value was at left of `ptr`. After it gets removed, our `ptr` points to `x-1th` smallest element. Threfore, shift `ptr` to one position right(`ptr++`).\\n* Otherwise, the `ptr` remains at correct position.\\n\\nNow, remove `nums[i - k]`.\\n\\n**Note**\\nIf a new value is to be inserted which is already present in multiset then it gets inserted after all the same value element.\\nAnd, `st.find(e)` finds the first position of `e`. \\nThese properties helped us in considering edge cases in our if conditions of insertion and deletion.\\n\\n# Complexity\\n- Time complexity:$$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> res;\\n        multiset<int> st;\\n\\n        multiset<int>::iterator ptr;\\n        for(int i = 0; i < n; i++)\\n        {\\n            st.insert(nums[i]);\\n\\n            // initialize ptr\\n            if(i == k - 1)\\n                ptr = next(st.begin(), x - 1);\\n\\n            if(i >= k && nums[i] < *ptr)\\n                ptr--;\\n            \\n            if(i >= k)\\n            {\\n                if(nums[i - k] <= *ptr)  \\n                    ptr++;\\n                st.erase(st.find(nums[i - k]));\\n            }\\n\\n            if(i >= k - 1)\\n                res.push_back(min(0, *ptr));\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\nPlease upvote if it helped\\uD83D\\uDE42.",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> res;\\n        multiset<int> st;\\n\\n        multiset<int>::iterator ptr;\\n        for(int i = 0; i < n; i++)\\n        {\\n            st.insert(nums[i]);\\n\\n            // initialize ptr\\n            if(i == k - 1)\\n                ptr = next(st.begin(), x - 1);\\n\\n            if(i >= k && nums[i] < *ptr)\\n                ptr--;\\n            \\n            if(i >= k)\\n            {\\n                if(nums[i - k] <= *ptr)  \\n                    ptr++;\\n                st.erase(st.find(nums[i - k]));\\n            }\\n\\n            if(i >= k - 1)\\n                res.push_back(min(0, *ptr));\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446927,
                "title": "pbds-c-helpful-data-structure-commented-code",
                "content": "# Intuition\\nWhen the question mentioned find the xth smallest element from the array I quickly thought of PBDS. It is basically a ordered set but the elements can be inedexed. Read more about it [here](https://codeforces.com/blog/entry/11080).\\n\\nTo handle the case of duplicate elements, I have stored the elements along with a index so that every element in the set is unique.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update>\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int> &arr, int k, int x)\\n    {\\n        int i = 0, j = 0;\\n        ordered_set st;\\n        int n = arr.size();\\n        vector<int> temp;\\n        int ind = 0;\\n        while (j < n)\\n        {\\n            // Insert the current element into the ordered set along with its index\\n            st.insert({arr[j], ind});\\n\\n            // If the window size is less than k, increment j to expand the window\\n            if (j - i + 1 < k)\\n            {\\n                j++;\\n            }\\n\\n            // If the window size is equal to k\\n            else if (j - i + 1 == k)\\n            {\\n                // Find the x-th smallest element in the window and get its value\\n                int ans = (st.find_by_order(x - 1))->first;\\n                \\n                // If the value is non-negative, push 0 to the result vector\\n                if (ans >= 0)\\n                {\\n                    temp.push_back(0);\\n                }\\n                // Otherwise, push the value to the result vector\\n                else\\n                {\\n                    temp.push_back(ans);\\n                }\\n\\n                //Now to slide the window, Erase the element pointed by i from the window\\n                st.erase(*st.find_by_order(st.order_of_key({arr[i], -1})));\\n\\n                // sliding the window\\n                i++;\\n                j++;\\n            }\\n            // Increment ind to keep track of the index of the current element\\n            ind++;\\n        }\\n        // Return the result vector\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update>\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int> &arr, int k, int x)\\n    {\\n        int i = 0, j = 0;\\n        ordered_set st;\\n        int n = arr.size();\\n        vector<int> temp;\\n        int ind = 0;\\n        while (j < n)\\n        {\\n            // Insert the current element into the ordered set along with its index\\n            st.insert({arr[j], ind});\\n\\n            // If the window size is less than k, increment j to expand the window\\n            if (j - i + 1 < k)\\n            {\\n                j++;\\n            }\\n\\n            // If the window size is equal to k\\n            else if (j - i + 1 == k)\\n            {\\n                // Find the x-th smallest element in the window and get its value\\n                int ans = (st.find_by_order(x - 1))->first;\\n                \\n                // If the value is non-negative, push 0 to the result vector\\n                if (ans >= 0)\\n                {\\n                    temp.push_back(0);\\n                }\\n                // Otherwise, push the value to the result vector\\n                else\\n                {\\n                    temp.push_back(ans);\\n                }\\n\\n                //Now to slide the window, Erase the element pointed by i from the window\\n                st.erase(*st.find_by_order(st.order_of_key({arr[i], -1})));\\n\\n                // sliding the window\\n                i++;\\n                j++;\\n            }\\n            // Increment ind to keep track of the index of the current element\\n            ind++;\\n        }\\n        // Return the result vector\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3446252,
                "title": "c-easy-to-understand-sliding-window",
                "content": "````\\nclass Solution\\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n    {\\n        int n = nums.size(), i, j, y;\\n        vector<int> count(50, 0), ans(n - k + 1, 0);\\n        for (i = 0; i < n; i++)\\n        {\\n            if (nums[i] < 0)\\n                count[nums[i] + 50]++;\\n            if (i - k >= 0 && nums[i - k] < 0)\\n                count[nums[i - k] + 50]--;\\n            y = 0;\\n            if (i - k + 1 >= 0)\\n            {\\n                for (j = 0; j < 50; j++)\\n                {\\n                    y += count[j];\\n                    if (y >= x)\\n                    {\\n                        ans[i - k + 1] = j - 50;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "````\\nclass Solution\\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n    {\\n        int n = nums.size(), i, j, y;\\n        vector<int> count(50, 0), ans(n - k + 1, 0);\\n        for (i = 0; i < n; i++)\\n        {\\n            if (nums[i] < 0)\\n                count[nums[i] + 50]++;\\n            if (i - k >= 0 && nums[i - k] < 0)\\n                count[nums[i - k] + 50]--;\\n            y = 0;\\n            if (i - k + 1 >= 0)\\n            {\\n                for (j = 0; j < 50; j++)\\n                {\\n                    y += count[j];\\n                    if (y >= x)\\n                    {\\n                        ans[i - k + 1] = j - 50;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446139,
                "title": "sliding-window-mapping-ve-integers-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int>m;\\n        \\n        int negcnt=0;          // Keeping Track Of Count Of Negative Numbers\\n        \\n        for(int i=0;i<k;i++)   //mapping first k elements\\n        {\\n            if(nums[i]<0) {\\n                m[nums[i]]++;\\n                negcnt++;\\n            }\\n        }\\n        \\n        vector<int>res;\\n        int i=0,j=k-1;\\n        while(j<nums.size())     //sliding window\\n        {\\n            if(negcnt>=x)       //if we have sufficient element\\n            {\\n                int pos=x;\\n                for(auto ele:m)  //finding xth element\\n                {\\n                    if(pos-ele.second>0)\\n                    {\\n                        pos=pos-ele.second;\\n                    }\\n                    else\\n                    {\\n                        res.push_back(ele.first);\\n                        break;\\n                    }\\n                }\\n            }\\n            else             //if we do not have suficient elements the push 0\\n            {\\n                res.push_back(0);\\n            }\\n            \\n            if(nums[i]<0)     // removing element at ith position\\n            {\\n                m[nums[i]]--;\\n                negcnt--;\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n            }\\n            \\n            i++;   //incrementing i\\n            if(j+1<nums.size()) j++;  //incrementing j\\n            else break;\\n            \\n            if(nums[j]<0)      //mapping new element in map\\n            {\\n                m[nums[j]]++;\\n                negcnt++;\\n            }\\n        }\\n        \\n        return res;    //return final result\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int>m;\\n        \\n        int negcnt=0;          // Keeping Track Of Count Of Negative Numbers\\n        \\n        for(int i=0;i<k;i++)   //mapping first k elements\\n        {\\n            if(nums[i]<0) {\\n                m[nums[i]]++;\\n                negcnt++;\\n            }\\n        }\\n        \\n        vector<int>res;\\n        int i=0,j=k-1;\\n        while(j<nums.size())     //sliding window\\n        {\\n            if(negcnt>=x)       //if we have sufficient element\\n            {\\n                int pos=x;\\n                for(auto ele:m)  //finding xth element\\n                {\\n                    if(pos-ele.second>0)\\n                    {\\n                        pos=pos-ele.second;\\n                    }\\n                    else\\n                    {\\n                        res.push_back(ele.first);\\n                        break;\\n                    }\\n                }\\n            }\\n            else             //if we do not have suficient elements the push 0\\n            {\\n                res.push_back(0);\\n            }\\n            \\n            if(nums[i]<0)     // removing element at ith position\\n            {\\n                m[nums[i]]--;\\n                negcnt--;\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n            }\\n            \\n            i++;   //incrementing i\\n            if(j+1<nums.size()) j++;  //incrementing j\\n            else break;\\n            \\n            if(nums[j]<0)      //mapping new element in map\\n            {\\n                m[nums[j]]++;\\n                negcnt++;\\n            }\\n        }\\n        \\n        return res;    //return final result\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445867,
                "title": "sliding-window-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs mention in problem statement numbers are with in -50 to 50.\\nWith this we can Maintain a TreeMap with frequency. Once we reached the window size K compute the xth smallest in O(100) in worst case time complexity. This is enough to pass the Time limit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(K log(K)) + O(100 * n)$$ \\n- \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        \\n        int start = 0;\\n        int n = nums.length;\\n        int [] ans = new int[n - k + 1];\\n        int idx = 0;\\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        \\n        for(int end = 0;end < n; end++){\\n            \\n            //System.out.println(\"Size = \" + (end - start + 1) + \" k = \" + k);\\n            if(end - start + 1 <= k){\\n                \\n                tmap.put(nums[end], tmap.getOrDefault(nums[end], 0)+ 1);\\n\\n            }else{\\n                //System.out.println(\"computing ans \" + getSecondSmall(tmap));\\n                ans[idx++] = Kth_smallest(tmap, x);//secmin;\\n                \\n                int val = nums[start];\\n                int tf = tmap.getOrDefault(nums[start], 0);\\n                if(tf <= 1)tmap.remove(nums[start]);\\n                else{\\n                    tmap.put(nums[start], tf-1);\\n                }\\n                start++;\\n\\n                tmap.put(nums[end], tmap.getOrDefault(nums[end], 0)+ 1);\\n            }\\n        }\\n        \\n        ans[idx++] = Kth_smallest(tmap, x);\\n        return ans;\\n    }\\n    \\n    int Kth_smallest(TreeMap<Integer, Integer> mp,int K){\\n        int freq = 0;\\n        for (Map.Entry it : mp.entrySet()) {\\n\\n            freq += (int)it.getValue();\\n\\n            if (freq >= K) {\\n                return Math.min((int)it.getKey(), 0);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        \\n        int start = 0;\\n        int n = nums.length;\\n        int [] ans = new int[n - k + 1];\\n        int idx = 0;\\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        \\n        for(int end = 0;end < n; end++){\\n            \\n            //System.out.println(\"Size = \" + (end - start + 1) + \" k = \" + k);\\n            if(end - start + 1 <= k){\\n                \\n                tmap.put(nums[end], tmap.getOrDefault(nums[end], 0)+ 1);\\n\\n            }else{\\n                //System.out.println(\"computing ans \" + getSecondSmall(tmap));\\n                ans[idx++] = Kth_smallest(tmap, x);//secmin;\\n                \\n                int val = nums[start];\\n                int tf = tmap.getOrDefault(nums[start], 0);\\n                if(tf <= 1)tmap.remove(nums[start]);\\n                else{\\n                    tmap.put(nums[start], tf-1);\\n                }\\n                start++;\\n\\n                tmap.put(nums[end], tmap.getOrDefault(nums[end], 0)+ 1);\\n            }\\n        }\\n        \\n        ans[idx++] = Kth_smallest(tmap, x);\\n        return ans;\\n    }\\n    \\n    int Kth_smallest(TreeMap<Integer, Integer> mp,int K){\\n        int freq = 0;\\n        for (Map.Entry it : mp.entrySet()) {\\n\\n            freq += (int)it.getValue();\\n\\n            if (freq >= K) {\\n                return Math.min((int)it.getKey(), 0);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445738,
                "title": "min-heap-java",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n\\xA0\\xA0\\xA0 public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = nums.length;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int[] result = new int[n - k + 1];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 TreeMap<Integer, Integer> minHeap = new TreeMap<>();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 TreeMap<Integer, Integer> maxHeap = new TreeMap<>(Collections.reverseOrder());\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (int i = 0; i < n; i++) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int num = nums[i];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Add the new element to the minHeap\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.put(num, minHeap.getOrDefault(num, 0) + 1);\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Remove the element that is out of the window\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (i >= k) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int outOfWindow = nums[i - k];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.put(outOfWindow, minHeap.get(outOfWindow) - 1);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (minHeap.get(outOfWindow) == 0) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.remove(outOfWindow);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Get the xth smallest element in the window\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (i >= k - 1) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int count = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int beautifulValue = 0;\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (Map.Entry<Integer, Integer> entry : minHeap.entrySet()) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 count += entry.getValue();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (count >= x) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 beautifulValue = entry.getKey();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 break;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 result[i - k + 1] = beautifulValue < 0 ? beautifulValue : 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return result;\\n\\xA0\\xA0\\xA0 }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n\\xA0\\xA0\\xA0 public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = nums.length;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int[] result = new int[n - k + 1];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 TreeMap<Integer, Integer> minHeap = new TreeMap<>();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 TreeMap<Integer, Integer> maxHeap = new TreeMap<>(Collections.reverseOrder());\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (int i = 0; i < n; i++) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int num = nums[i];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Add the new element to the minHeap\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.put(num, minHeap.getOrDefault(num, 0) + 1);\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Remove the element that is out of the window\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (i >= k) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int outOfWindow = nums[i - k];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.put(outOfWindow, minHeap.get(outOfWindow) - 1);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (minHeap.get(outOfWindow) == 0) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.remove(outOfWindow);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Get the xth smallest element in the window\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (i >= k - 1) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int count = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int beautifulValue = 0;\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (Map.Entry<Integer, Integer> entry : minHeap.entrySet()) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 count += entry.getValue();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (count >= x) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 beautifulValue = entry.getKey();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 break;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 result[i - k + 1] = beautifulValue < 0 ? beautifulValue : 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return result;\\n\\xA0\\xA0\\xA0 }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445727,
                "title": "simple-solution-with-explanation",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven an integer array nums containing n integers, find the beauty of each subarray of size k.\\n\\nThe beauty of a subarray is the xth smallest integer in the subarray if it is negative, or 0 if there are fewer than x negative integers.\\n\\nReturn an integer array containing n - k + 1 integers, which denote the beauty of the subarrays in order from the first index in the array.\\n\\nA subarray is a contiguous non-empty sequence of elements within an array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe problem requires finding the \"beauty\" of all possible subarrays of a given length k in an array nums. The beauty of a subarray is defined as the smallest number that appears at least x times in the subarray. If no number appears at least x times, then the beauty is 0.\\n\\nTo solve this problem, we can use a sliding window approach, where we slide a window of length k over the array nums and calculate the beauty of each subarray. We can keep track of the counts of each number in the current window using a hash map. Then, for each subarray of length k, we can iterate through the hash map to find the smallest number that appears at least x times, and set the beauty of the subarray to that number. If no number appears at least x times, we set the beauty to 0.\\n\\nWe repeat this process for all possible subarrays of length k in the array nums and store the beauties in an output array of length n - k + 1, where n is the length of nums. Finally, we return the output array.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the getSubarrayBeauty method is O(nklogk), where n is the length of the input array nums and k is the length of the subarrays.\\n\\nThe method uses a sliding window approach to iterate through the input array nums, which takes O(n) time. Within each window of size k, the method performs the following operations:\\n\\nAdding an element to the minHeap takes O(logk) time.\\nRemoving an element from the minHeap takes O(logk) time.\\nIterating through the elements of the minHeap takes O(k) time in the worst case, since there can be up to k elements in the minHeap.\\nSince we perform these operations for each window of size k, the overall time complexity is O(nklogk).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity of the getSubarrayBeauty method is O(k), which is the space used by the minHeap and maxHeap data structures. This is because the method only needs to keep track of the counts of the numbers within the current window of size k, which is at most k distinct numbers. The output array of length n - k + 1 also takes O(n - k + 1) = O(n) space, but this is not considered as extra space used by the method.\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] result = new int[n - k + 1];\\n\\n  \\n        TreeMap<Integer, Integer> minHeap = new TreeMap<>();\\n        \\n\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n\\n            \\n            minHeap.put(num, minHeap.getOrDefault(num, 0) + 1);\\n\\n            \\n            if (i >= k) {\\n                int out = nums[i - k];\\n                minHeap.put(out, minHeap.get(out) - 1);\\n                if (minHeap.get(out) == 0) {\\n                    minHeap.remove(out);\\n                }\\n            }\\n\\n            if (i >= k - 1) {\\n                int cnt = 0;\\n                int beauty = 0;\\n                Iterator<Map.Entry<Integer, Integer>> it = minHeap.entrySet().iterator();\\n                while (it.hasNext() && cnt < x) {\\n                    Map.Entry<Integer, Integer> entry = it.next();\\n                    cnt += entry.getValue();\\n                    if (cnt >= x) {\\n                        beauty = entry.getKey();\\n                        break;\\n                    }\\n                }\\n                result[i - k + 1] = beauty < 0 ? beauty : 0;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] result = new int[n - k + 1];\\n\\n  \\n        TreeMap<Integer, Integer> minHeap = new TreeMap<>();\\n        \\n\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n\\n            \\n            minHeap.put(num, minHeap.getOrDefault(num, 0) + 1);\\n\\n            \\n            if (i >= k) {\\n                int out = nums[i - k];\\n                minHeap.put(out, minHeap.get(out) - 1);\\n                if (minHeap.get(out) == 0) {\\n                    minHeap.remove(out);\\n                }\\n            }\\n\\n            if (i >= k - 1) {\\n                int cnt = 0;\\n                int beauty = 0;\\n                Iterator<Map.Entry<Integer, Integer>> it = minHeap.entrySet().iterator();\\n                while (it.hasNext() && cnt < x) {\\n                    Map.Entry<Integer, Integer> entry = it.next();\\n                    cnt += entry.getValue();\\n                    if (cnt >= x) {\\n                        beauty = entry.getKey();\\n                        break;\\n                    }\\n                }\\n                result[i - k + 1] = beauty < 0 ? beauty : 0;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446913,
                "title": "map-and-sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int checker(int x){\\n        for(auto k : mp){\\n            x -= k.second;\\n            if(x <= 0 && k.first < 0){\\n                return k.first;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        for(int i = 0; i < k; i++){\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(checker(x));\\n        int ptr = 0;\\n        for(int i = k; i < nums.size(); i++){\\n            mp[nums[ptr]]--;\\n            mp[nums[i]]++;\\n            if(mp[nums[ptr]] == 0) mp.erase(nums[ptr]);\\n            ans.push_back(checker(x));\\n            ptr++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int checker(int x){\\n        for(auto k : mp){\\n            x -= k.second;\\n            if(x <= 0 && k.first < 0){\\n                return k.first;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        for(int i = 0; i < k; i++){\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(checker(x));\\n        int ptr = 0;\\n        for(int i = k; i < nums.size(); i++){\\n            mp[nums[ptr]]--;\\n            mp[nums[i]]++;\\n            if(mp[nums[ptr]] == 0) mp.erase(nums[ptr]);\\n            ans.push_back(checker(x));\\n            ptr++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446809,
                "title": "python-easy-to-read-solution-hashmap-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question most important hint to get solution is constraints. n <= 10^5 so you should look to solve this with  Time Complexity of O(N).\\n\\nNow how to get count of negative numbers in O(1) time. because if you do any other way you cant solve this problem in O(N). Again if you look at the constraint , -50 <= nums[i] <=50. Can we maintain hashmap of negative numbers ? to get x smallest negative numbers we can simply traverse from -50 to -1 and count frequency of negative numbers. The moment this frequency is more than or equal  to x, we can return negative number for which this is achieved while traversing from -50 to -1. I said \\'more than equal\\'  because same number can occur multiple times . egde case: [-46, -46 , -30]\\n\\n\\nIf this was helpful. Feel free to follow me on \\nhttps://www.youtube.com/@punitvara1924\\nhttps://medium.com/@punitvara\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def find_x_smallest(self, count_map, x):\\n        count = 0\\n        for num in range(-50, 0, 1):\\n            if count_map.get(num, 0) != 0:\\n                count += count_map[num]\\n                if count >= x:\\n                    return num\\n                \\n        return 0\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        start = 0\\n        neg = 0\\n        count_map = {}\\n    \\n        ans = []\\n            \\n        for end in range(len(nums)):\\n            # Remove contribution of start element if its negative.\\n            if start > len(nums)-k+1:\\n                break\\n            if nums[end] < 0:\\n                neg += 1\\n                count_map[nums[end]] = count_map.get(nums[end], 0) + 1\\n            \\n            window_size = end - start + 1\\n            if window_size == k:\\n                temp = 0\\n                if neg >= x: \\n                    temp = self.find_x_smallest(count_map, x)\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    count_map[nums[start]] -= 1\\n                start += 1\\n                ans.append(temp)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def find_x_smallest(self, count_map, x):\\n        count = 0\\n        for num in range(-50, 0, 1):\\n            if count_map.get(num, 0) != 0:\\n                count += count_map[num]\\n                if count >= x:\\n                    return num\\n                \\n        return 0\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        start = 0\\n        neg = 0\\n        count_map = {}\\n    \\n        ans = []\\n            \\n        for end in range(len(nums)):\\n            # Remove contribution of start element if its negative.\\n            if start > len(nums)-k+1:\\n                break\\n            if nums[end] < 0:\\n                neg += 1\\n                count_map[nums[end]] = count_map.get(nums[end], 0) + 1\\n            \\n            window_size = end - start + 1\\n            if window_size == k:\\n                temp = 0\\n                if neg >= x: \\n                    temp = self.find_x_smallest(count_map, x)\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    count_map[nums[start]] -= 1\\n                start += 1\\n                ans.append(temp)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445948,
                "title": "c-counting-sliding-window-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans, mp(101, 0);\\n        int s=0, e=0;\\n        while(e < nums.size())  {\\n            mp[nums[e] + 50]++;\\n            if(e-s+1 == k)    {\\n                int cnt = 0;\\n                for(int i=0; i<101; i++)    {\\n                    cnt += mp[i];\\n                    if(cnt >= x)    {\\n                        if(i > 50) ans.push_back(0);\\n                        else ans.push_back(i - 50);\\n                        break;\\n                    }\\n                }\\n                mp[nums[s] + 50]--;\\n                s++;\\n            }\\n            e++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans, mp(101, 0);\\n        int s=0, e=0;\\n        while(e < nums.size())  {\\n            mp[nums[e] + 50]++;\\n            if(e-s+1 == k)    {\\n                int cnt = 0;\\n                for(int i=0; i<101; i++)    {\\n                    cnt += mp[i];\\n                    if(cnt >= x)    {\\n                        if(i > 50) ans.push_back(0);\\n                        else ans.push_back(i - 50);\\n                        break;\\n                    }\\n                }\\n                mp[nums[s] + 50]--;\\n                s++;\\n            }\\n            e++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445865,
                "title": "c-brute-force-optimized-simplest-solution-faster-than-95",
                "content": "# Code\\n##### Method 1\\nBrute Force ~ TLE - 703/717 \\nTime Complexity: $$O(nklok)$$\\n```\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = nums.size();\\n        vector<int> sub(k),alt(k);\\n        int j = 0;\\n        vector<int> beauty(n - k + 1);\\n\\n        for (int i = 0; i < k; i++) {\\n            alt[i] = nums[i];\\n        }\\n        for (int i = k; i <= n; i++) {\\n            sub=alt;\\n            sort(sub.begin(), sub.end());    \\n            beauty[j++] = (sub[x - 1] < 0) ? sub[x - 1] : 0;\\n\\n            if (i == n) {\\n                break;\\n            }\\n\\n            alt.erase(alt.begin());\\n            alt.push_back(nums[i]);\\n        }\\n\\n        return beauty;\\n    }\\n```\\n\\n##### Method 2\\nFrequency Array \\nTime Complexity: $$O(50n)$$\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans(n - k + 1, 0), freq(50, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0) freq[nums[i] + 50]++;\\n            if (i - k >= 0 && nums[i - k] < 0) freq[nums[i - k] + 50]--;\\n            if (i - k + 1 < 0) continue;\\n            int count = 0;\\n            for (int j = 0; j < 50; j++) {\\n                count += freq[j];\\n                if (count >= x) {\\n                    ans[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = nums.size();\\n        vector<int> sub(k),alt(k);\\n        int j = 0;\\n        vector<int> beauty(n - k + 1);\\n\\n        for (int i = 0; i < k; i++) {\\n            alt[i] = nums[i];\\n        }\\n        for (int i = k; i <= n; i++) {\\n            sub=alt;\\n            sort(sub.begin(), sub.end());    \\n            beauty[j++] = (sub[x - 1] < 0) ? sub[x - 1] : 0;\\n\\n            if (i == n) {\\n                break;\\n            }\\n\\n            alt.erase(alt.begin());\\n            alt.push_back(nums[i]);\\n        }\\n\\n        return beauty;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans(n - k + 1, 0), freq(50, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0) freq[nums[i] + 50]++;\\n            if (i - k >= 0 && nums[i - k] < 0) freq[nums[i - k] + 50]--;\\n            if (i - k + 1 < 0) continue;\\n            int count = 0;\\n            for (int j = 0; j < 50; j++) {\\n                count += freq[j];\\n                if (count >= x) {\\n                    ans[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445830,
                "title": "sliding-window-with-ve-freq-counting-easy-explanation-o-n",
                "content": "# Intuition\\nThe code uses a sliding window technique to create subarrays of length `k`, and then counts the frequency of negative numbers in each subarray. It then finds the `xth` smallest element in the subarray by counting the frequencies of numbers from `50` down to `1` until it reaches the `xth` smallest element. If no `xth` smallest element is present, `0` is added to the answer list.\\n\\n# Complexity\\n- Time complexity:\\n`O(n*50)` = `O(n)`\\n\\n- Space complexity:\\n`O(50)` = `O(1)`\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] freq = new int[51];\\n        int[] res = new int[nums.length - k + 1];\\n        \\n        for(int i = 0, j = 0, idx = 0; i < n; i++) {\\n            if(nums[i] < 0) freq[Math.abs(nums[i])]++;\\n            if(i - j + 1 >= k) {\\n                int cnt = 0;\\n                for(int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if(cnt >= x) { res[idx++] = -L; break;}\\n                }\\n                if(cnt < x) res[idx++] = 0;\\n                if(nums[j] < 0) freq[Math.abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    std::vector<int> getSubarrayBeauty(std::vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        std::vector<int> freq(51);\\n        std::vector<int> res(n - k + 1);\\n\\n        for (int i = 0, j = 0, idx = 0; i < n; i++) {\\n            if (nums[i] < 0) freq[abs(nums[i])]++;\\n            if (i - j + 1 >= k) {\\n                int cnt = 0;\\n                for (int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if (cnt >= x) {\\n                        res[idx++] = -L;\\n                        break;\\n                    }\\n                }\\n                if (cnt < x) res[idx++] = 0;\\n                if (nums[j] < 0) freq[abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n``` python []\\nfrom typing import List\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        freq = [0] * 51\\n        res = [0] * (n - k + 1)\\n\\n        j = 0\\n        idx = 0\\n        for i in range(n):\\n            if nums[i] < 0:\\n                freq[abs(nums[i])] += 1\\n            if i - j + 1 >= k:\\n                cnt = 0\\n                for L in range(50, 0, -1):\\n                    cnt += freq[L]\\n                    if cnt >= x:\\n                        res[idx] = -L\\n                        idx += 1\\n                        break\\n                if cnt < x:\\n                    res[idx] = 0\\n                    idx += 1\\n                if nums[j] < 0:\\n                    freq[abs(nums[j])] -= 1\\n                j += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] freq = new int[51];\\n        int[] res = new int[nums.length - k + 1];\\n        \\n        for(int i = 0, j = 0, idx = 0; i < n; i++) {\\n            if(nums[i] < 0) freq[Math.abs(nums[i])]++;\\n            if(i - j + 1 >= k) {\\n                int cnt = 0;\\n                for(int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if(cnt >= x) { res[idx++] = -L; break;}\\n                }\\n                if(cnt < x) res[idx++] = 0;\\n                if(nums[j] < 0) freq[Math.abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    std::vector<int> getSubarrayBeauty(std::vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        std::vector<int> freq(51);\\n        std::vector<int> res(n - k + 1);\\n\\n        for (int i = 0, j = 0, idx = 0; i < n; i++) {\\n            if (nums[i] < 0) freq[abs(nums[i])]++;\\n            if (i - j + 1 >= k) {\\n                int cnt = 0;\\n                for (int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if (cnt >= x) {\\n                        res[idx++] = -L;\\n                        break;\\n                    }\\n                }\\n                if (cnt < x) res[idx++] = 0;\\n                if (nums[j] < 0) freq[abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n``` python []\\nfrom typing import List\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        freq = [0] * 51\\n        res = [0] * (n - k + 1)\\n\\n        j = 0\\n        idx = 0\\n        for i in range(n):\\n            if nums[i] < 0:\\n                freq[abs(nums[i])] += 1\\n            if i - j + 1 >= k:\\n                cnt = 0\\n                for L in range(50, 0, -1):\\n                    cnt += freq[L]\\n                    if cnt >= x:\\n                        res[idx] = -L\\n                        idx += 1\\n                        break\\n                if cnt < x:\\n                    res[idx] = 0\\n                    idx += 1\\n                if nums[j] < 0:\\n                    freq[abs(nums[j])] -= 1\\n                j += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445749,
                "title": "java-use-bucket-sort-with-sliding-window-given-the-constraints",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought is to observe the constraints since sorting for each subarray would not scale.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce I noticed the -50 < elem < 50 , try to either a map or array.\\nMap - would not keep things sorted. Has to be array, but\\narray cannot handle negative numbers. So, have to shift the \\nelements by 50 and get an index for each element - back and forth.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] rslt = new int[n-k+1];\\n        \\n        int[] bucket = new int[101];\\n        \\n        for(int i = 0; i < k; i++){\\n            int elem = nums[i];\\n            int bktidx = elem + 50;\\n            bucket[bktidx]++;\\n        }\\n        \\n        rslt[0] = getBucket(bucket, x);\\n        for(int i = k; i < n; i++){\\n            int outgoing = nums[i-k];\\n            int outbktidx = outgoing + 50;\\n            bucket[outbktidx]--;\\n            \\n            int incoming = nums[i];\\n            int inxbktidx = incoming + 50;\\n            bucket[inxbktidx]++;\\n            \\n            rslt[i-k+1] = getBucket(bucket, x);\\n        }\\n        return rslt;\\n    }\\n    private int getBucket(int[] bucket, int x){\\n        int cnt = 0;\\n        for(int i = 0; i < bucket.length; i++){\\n            int frqi = bucket[i];\\n            if (cnt + frqi >= x){\\n                return Math.min(0, i-50);\\n            } \\n            cnt += frqi;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] rslt = new int[n-k+1];\\n        \\n        int[] bucket = new int[101];\\n        \\n        for(int i = 0; i < k; i++){\\n            int elem = nums[i];\\n            int bktidx = elem + 50;\\n            bucket[bktidx]++;\\n        }\\n        \\n        rslt[0] = getBucket(bucket, x);\\n        for(int i = k; i < n; i++){\\n            int outgoing = nums[i-k];\\n            int outbktidx = outgoing + 50;\\n            bucket[outbktidx]--;\\n            \\n            int incoming = nums[i];\\n            int inxbktidx = incoming + 50;\\n            bucket[inxbktidx]++;\\n            \\n            rslt[i-k+1] = getBucket(bucket, x);\\n        }\\n        return rslt;\\n    }\\n    private int getBucket(int[] bucket, int x){\\n        int cnt = 0;\\n        for(int i = 0; i < bucket.length; i++){\\n            int frqi = bucket[i];\\n            if (cnt + frqi >= x){\\n                return Math.min(0, i-50);\\n            } \\n            cnt += frqi;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671158,
                "title": "c-easiest-sliding-window-using-array-of-size-50",
                "content": "# Intuition\\nIntuition is to use an array of size 50 to keep track of 2nd -ve smallest element.\\n\\nif ```nums[i]<0``` then we will make ```mp[nums[i] + 50]+=1```, here 0th index is -50 and so on.\\n\\n# Approach\\n\\nif ```nums[i]<0``` we are incresing the count of that element in mp by help of ```mp[nums[i] + 50]+=1```.\\n\\nWhen our window will hit size k. then we will run a loop till 50 and find 2nd smallest number inside array. To find this we will have a temp varibale when it is ```temp>=x``` we will push that element in answer and break. And if ``` temp<x ``` then we will add mp[k1] in temp. Here mp[k1] is total number of negative element having value k1-50.\\n\\nAs we have hitted then window size we need to remove ith element. So if nums[i] < 0 then make mp[nums[i] - 50]--.\\n\\n\\n``` \\nHappy coding and do upvote if it helped :)\\n```\\n# Complexity\\n- Time complexity:\\n$$O(N*50)$$\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        \\n        vector<int> mp(51);\\n\\n        int i=0,j=0;\\n        while(j<n){\\n            if(nums[j]<0){\\n                int ele = nums[j]+50;\\n                mp[ele]+=1;\\n            }\\n\\n            if(j-i+1>=k){\\n                int temp=0;\\n                bool ok=false;\\n                for(int k1=0;k1<50;++k1){\\n                    if(mp[k1]>0){\\n                        if(temp+mp[k1] >= x){\\n                            ans.push_back(k1-50);\\n                            ok= true;\\n                            break;\\n                        }else{\\n                            temp += mp[k1];\\n                        }\\n                    }\\n                }\\n                if(!ok){\\n                    ans.push_back(0);\\n                }\\n\\n                if(nums[i] < 0){\\n                    mp[nums[i]+50] -=1;\\n                }\\n                i+=1;\\n            }\\n            j+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```nums[i]<0```\n```mp[nums[i] + 50]+=1```\n```nums[i]<0```\n```mp[nums[i] + 50]+=1```\n```temp>=x```\n``` temp<x ```\n``` \\nHappy coding and do upvote if it helped :)\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        \\n        vector<int> mp(51);\\n\\n        int i=0,j=0;\\n        while(j<n){\\n            if(nums[j]<0){\\n                int ele = nums[j]+50;\\n                mp[ele]+=1;\\n            }\\n\\n            if(j-i+1>=k){\\n                int temp=0;\\n                bool ok=false;\\n                for(int k1=0;k1<50;++k1){\\n                    if(mp[k1]>0){\\n                        if(temp+mp[k1] >= x){\\n                            ans.push_back(k1-50);\\n                            ok= true;\\n                            break;\\n                        }else{\\n                            temp += mp[k1];\\n                        }\\n                    }\\n                }\\n                if(!ok){\\n                    ans.push_back(0);\\n                }\\n\\n                if(nums[i] < 0){\\n                    mp[nums[i]+50] -=1;\\n                }\\n                i+=1;\\n            }\\n            j+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501383,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int res[]=new int[n-k+1];\\n        int neg[]=new int[51];\\n        int index=0;\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)neg[-nums[i]]++;\\n            if(i+1>=k){\\n                int c=0;\\n                int j=0;\\n                for(j=50;j>0;j--)\\n                {\\n                    c+=neg[j];\\n                    if(x<=c){res[index]=-j;break;}\\n                }\\n                if(j==0)res[index]=0;\\n                if(nums[a]<0)neg[-nums[a]]--;\\n                index++;\\n                a++;\\n            }\\n        }\\n       return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int res[]=new int[n-k+1];\\n        int neg[]=new int[51];\\n        int index=0;\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)neg[-nums[i]]++;\\n            if(i+1>=k){\\n                int c=0;\\n                int j=0;\\n                for(j=50;j>0;j--)\\n                {\\n                    c+=neg[j];\\n                    if(x<=c){res[index]=-j;break;}\\n                }\\n                if(j==0)res[index]=0;\\n                if(nums[a]<0)neg[-nums[a]]--;\\n                index++;\\n                a++;\\n            }\\n        }\\n       return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476254,
                "title": "python3-code",
                "content": "# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        beauts = []\\n        i = 0\\n        j = k\\n        LEN = len(nums)\\n        sortedL = SortedList(nums[i:j])\\n        while j - 1 < LEN:\\n            if x <= j and sortedL[x - 1] < 0:\\n                beauts.append(sortedL[x-1])\\n            else:\\n                beauts.append(0)\\n            if j < LEN:\\n                sortedL.add(nums[j])\\n            sortedL.discard(nums[i])\\n            i += 1\\n            j += 1\\n        return beauts\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        beauts = []\\n        i = 0\\n        j = k\\n        LEN = len(nums)\\n        sortedL = SortedList(nums[i:j])\\n        while j - 1 < LEN:\\n            if x <= j and sortedL[x - 1] < 0:\\n                beauts.append(sortedL[x-1])\\n            else:\\n                beauts.append(0)\\n            if j < LEN:\\n                sortedL.add(nums[j])\\n            sortedL.discard(nums[i])\\n            i += 1\\n            j += 1\\n        return beauts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460286,
                "title": "super-easy-and-intuitive-problem-sliding-window-c",
                "content": "The problem that you will face will be to get the xth minimum element in less time .\\nJust see the constraints and you will notice that negative elements are just -50 to -1 that is only 50 elements.\\nso store it in array based on index and it will ofcourse be sorted.\\n**Note** store negative element on index along with its count.\\nGetting index using arr[50 + nums[i]] and getting the element from index back by i - 50.\\nExample: for -3 we get 50-3=47 as its index and from index 47 we can get 47-50=-3 the orginal elemnt back.\\n```\\nclass Solution\\n{\\n    public:\\n        int gen(int x, int *arr)//getting xth smallest element.\\n        {\\n            int i = 0;\\n            while (i < 50)\\n            {\\n                if (arr[i] < x)\\n                    x -= arr[i];\\n                else\\n                    x = 0;\\n                if (x == 0)\\n                    return i - 50;\\n\\n                i++;\\n            }\\n            return 0;\\n        }\\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n    {\\n        int arr[50] = { 0 };\\n        int start = 0;\\n        vector<int> ans;\\n        for (int end = k - 1; end < nums.size(); end++)\\n        {\\n            if (end == k - 1)//making window\\n            {\\n                for (int j = 0; j < k; j++)\\n                {\\n                    if (nums[j] < 0)\\n                        arr[50 + nums[j]] += 1;\\n                }\\n            }\\n            else\\n            {\\n                if (nums[start] < 0)//sliding the window\\n                    arr[50 + nums[start]] -= 1;\\n                start++;\\n                if (nums[end] < 0)\\n                    arr[50 + nums[end]] += 1;\\n            }\\n            ans.push_back(gen(x, arr));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int gen(int x, int *arr)//getting xth smallest element.\\n        {\\n            int i = 0;\\n            while (i < 50)\\n            {\\n                if (arr[i] < x)\\n                    x -= arr[i];\\n                else\\n                    x = 0;\\n                if (x == 0)\\n                    return i - 50;\\n\\n                i++;\\n            }\\n            return 0;\\n        }\\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n    {\\n        int arr[50] = { 0 };\\n        int start = 0;\\n        vector<int> ans;\\n        for (int end = k - 1; end < nums.size(); end++)\\n        {\\n            if (end == k - 1)//making window\\n            {\\n                for (int j = 0; j < k; j++)\\n                {\\n                    if (nums[j] < 0)\\n                        arr[50 + nums[j]] += 1;\\n                }\\n            }\\n            else\\n            {\\n                if (nums[start] < 0)//sliding the window\\n                    arr[50 + nums[start]] -= 1;\\n                start++;\\n                if (nums[end] < 0)\\n                    arr[50 + nums[end]] += 1;\\n            }\\n            ans.push_back(gen(x, arr));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454006,
                "title": "c-ordered-set-systematic-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*logn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\\n  \\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_set s;\\n        vector<int>ans;\\n        int i=0, j=0;\\n        while(j<nums.size()){\\n            if(nums[j]<0){\\n                s.insert(nums[j]);\\n            }\\n            if(j-i+1==k){\\n                if(s.size()<x){\\n                    ans.push_back(0);\\n                }\\n                else{\\n                    auto it=s.find_by_order(x-1);\\n                    ans.push_back(*it);\\n                }\\n                if(nums[i]<0){\\n                    s.erase(s.find_by_order(s.order_of_key(nums[i])));\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\\n  \\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_set s;\\n        vector<int>ans;\\n        int i=0, j=0;\\n        while(j<nums.size()){\\n            if(nums[j]<0){\\n                s.insert(nums[j]);\\n            }\\n            if(j-i+1==k){\\n                if(s.size()<x){\\n                    ans.push_back(0);\\n                }\\n                else{\\n                    auto it=s.find_by_order(x-1);\\n                    ans.push_back(*it);\\n                }\\n                if(nums[i]<0){\\n                    s.erase(s.find_by_order(s.order_of_key(nums[i])));\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3454001,
                "title": "without-using-stl-c",
                "content": "# ***Complexity-***\\n- **Time complexity:** *O(n * 101)* \\n\\n- **Space complexity:** *O(101)*\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> arr1(101, 0);\\n        vector<int> arr2(nums.size()-k+1);\\n        int index = 0, count = 0, temp = 0;\\n        for(int i = 0; i < k-1; i++)\\n        {\\n            arr1[nums[i] + 50]++;\\n        }\\n        for(int i = k-1; i < nums.size(); i++)\\n        {\\n            arr1[nums[i] + 50]++;\\n            for(int j = 0; j < 101; j++)\\n            {\\n                count += arr1[j];\\n                if(x <= count)\\n                {\\n                    temp = j - 50;\\n                    if(temp > 0)\\n                    {\\n                        arr2[index++] = 0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        arr2[index++] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            count = 0;\\n            arr1[nums[i-k+1] + 50]--;\\n        }\\n        return arr2;\\n    }\\n};\\n```\\n\\n*Do Upvote!* \\uD83D\\uDE03\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> arr1(101, 0);\\n        vector<int> arr2(nums.size()-k+1);\\n        int index = 0, count = 0, temp = 0;\\n        for(int i = 0; i < k-1; i++)\\n        {\\n            arr1[nums[i] + 50]++;\\n        }\\n        for(int i = k-1; i < nums.size(); i++)\\n        {\\n            arr1[nums[i] + 50]++;\\n            for(int j = 0; j < 101; j++)\\n            {\\n                count += arr1[j];\\n                if(x <= count)\\n                {\\n                    temp = j - 50;\\n                    if(temp > 0)\\n                    {\\n                        arr2[index++] = 0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        arr2[index++] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            count = 0;\\n            arr1[nums[i-k+1] + 50]--;\\n        }\\n        return arr2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452363,
                "title": "sliding-subarray-beauty-90-76-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n= nums.size();\\n        vector<int> a(n-k+1);\\n        vector<int>b(50);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            b[nums[i]+50]++;\\n            if(i-k>=0 && nums[i-k]<0)\\n            b[nums[i-k]+50]--;\\n            if(i-k+1<0)\\n            continue;\\n        \\n            int c=0;\\n            for(int j=0;j<50;j++)\\n            {\\n                c+=b[j];\\n                if(c>=x)\\n                {\\n                    a[i-k+1]=j-50;\\n                    break;\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n= nums.size();\\n        vector<int> a(n-k+1);\\n        vector<int>b(50);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            b[nums[i]+50]++;\\n            if(i-k>=0 && nums[i-k]<0)\\n            b[nums[i-k]+50]--;\\n            if(i-k+1<0)\\n            continue;\\n        \\n            int c=0;\\n            for(int j=0;j<50;j++)\\n            {\\n                c+=b[j];\\n                if(c>=x)\\n                {\\n                    a[i-k+1]=j-50;\\n                    break;\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447388,
                "title": "java-solution-most-noob-solution",
                "content": "```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int idx = 0;\\n        int[] map = new int[52];// as all elements lie in between -50 to +50 {i have taken 2 extra elements}\\n        for (int i = 0; i < k; i++) { // for the 1st window of size k\\n            if (nums[i] < 0) {  // i will be only inserting the -ve elements but i will treat them positive \\n\\t\\t\\t// in order  to do that i will add 50 to them \\n                int val = nums[i] + 50; \\n                map[val]++; // increase the number\\'s frequency by 1 \\n            }\\n        }\\n        int cnt = 0;\\n        boolean flag = true;\\n        for (int a = 0; a < 52; a++) { // i will iterate over map    \\n            if (map[a] != 0) {\\n                if (map[a] + cnt >= x) { \\n                    ans[idx++] = a - 50;\\n                    flag = false;\\n                    cnt = 0;\\n                    break;\\n                } else {\\n                    cnt += map[a]; \\n                }\\n            }\\n        }\\n        if (flag) {// there doesn\\'t exist a xth smallest -ve number so i will put zero\\n            ans[idx++] = 0;\\n            cnt = 0;\\n        }\\n        int j = 0;\\n        for (int i = k; i < n; i++) {\\n\\t\\t// release the element outside the window\\n            if (nums[j] < 0) {\\n                int val = nums[j] + 50;\\n                map[val]--;\\n            }\\n            j++;\\n\\n            if (nums[i] < 0) {\\n                int val = nums[i] + 50;\\n                map[val]++;\\n            }\\n\\n            flag = true;\\n            for (int a = 0; a < 52; a++) {\\n                if (map[a] != 0) {\\n                    if (map[a] + cnt >= x) {\\n                        ans[idx++] = a - 50;\\n                        flag = false;\\n                        cnt = 0;\\n                        break;\\n                    } else {\\n                        cnt += map[a];\\n                    }\\n                }\\n            }\\n            if (flag) {\\n                ans[idx++] = 0;\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n# A Bit Optimized Solution\\n```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int idx = 0;\\n        int[] map = new int[50];\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0) {\\n                int val = nums[i] + 50;\\n                map[val]++;\\n            }\\n            if (i - j + 1 == k) {\\n                int cnt = 0;\\n                boolean flag = true;\\n                for (int a = 0; a < 50; a++) {\\n                    if (map[a] != 0) {\\n                        if (map[a] + cnt >= x) {\\n                            ans[idx++] = a - 50;\\n                            flag = false;\\n                            cnt = 0;\\n                            break;\\n                        } else {\\n                            cnt += map[a];\\n                        }\\n                    }\\n                }\\n                if (flag) {\\n                    ans[idx++] = 0;\\n                    cnt = 0;\\n                }\\n                if (nums[j] < 0) {\\n                    int val = nums[j] + 50;\\n                    map[val]--;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int idx = 0;\\n        int[] map = new int[52];// as all elements lie in between -50 to +50 {i have taken 2 extra elements}\\n        for (int i = 0; i < k; i++) { // for the 1st window of size k\\n            if (nums[i] < 0) {  // i will be only inserting the -ve elements but i will treat them positive \\n\\t\\t\\t// in order  to do that i will add 50 to them \\n                int val = nums[i] + 50; \\n                map[val]++; // increase the number\\'s frequency by 1 \\n            }\\n        }\\n        int cnt = 0;\\n        boolean flag = true;\\n        for (int a = 0; a < 52; a++) { // i will iterate over map    \\n            if (map[a] != 0) {\\n                if (map[a] + cnt >= x) { \\n                    ans[idx++] = a - 50;\\n                    flag = false;\\n                    cnt = 0;\\n                    break;\\n                } else {\\n                    cnt += map[a]; \\n                }\\n            }\\n        }\\n        if (flag) {// there doesn\\'t exist a xth smallest -ve number so i will put zero\\n            ans[idx++] = 0;\\n            cnt = 0;\\n        }\\n        int j = 0;\\n        for (int i = k; i < n; i++) {\\n\\t\\t// release the element outside the window\\n            if (nums[j] < 0) {\\n                int val = nums[j] + 50;\\n                map[val]--;\\n            }\\n            j++;\\n\\n            if (nums[i] < 0) {\\n                int val = nums[i] + 50;\\n                map[val]++;\\n            }\\n\\n            flag = true;\\n            for (int a = 0; a < 52; a++) {\\n                if (map[a] != 0) {\\n                    if (map[a] + cnt >= x) {\\n                        ans[idx++] = a - 50;\\n                        flag = false;\\n                        cnt = 0;\\n                        break;\\n                    } else {\\n                        cnt += map[a];\\n                    }\\n                }\\n            }\\n            if (flag) {\\n                ans[idx++] = 0;\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int idx = 0;\\n        int[] map = new int[50];\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0) {\\n                int val = nums[i] + 50;\\n                map[val]++;\\n            }\\n            if (i - j + 1 == k) {\\n                int cnt = 0;\\n                boolean flag = true;\\n                for (int a = 0; a < 50; a++) {\\n                    if (map[a] != 0) {\\n                        if (map[a] + cnt >= x) {\\n                            ans[idx++] = a - 50;\\n                            flag = false;\\n                            cnt = 0;\\n                            break;\\n                        } else {\\n                            cnt += map[a];\\n                        }\\n                    }\\n                }\\n                if (flag) {\\n                    ans[idx++] = 0;\\n                    cnt = 0;\\n                }\\n                if (nums[j] < 0) {\\n                    int val = nums[j] + 50;\\n                    map[val]--;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446917,
                "title": "video-explanation-includes-harder-follow-ups",
                "content": "# Explanation\\n\\nhttps://youtu.be/Atdtf57Cuj8\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/Atdtf57Cuj8)\\n\\n# Code\\n```\\nclass Solution {\\n    unordered_map <int, int> frq;\\n    \\n    void Add (int val) {\\n        frq [val] ++;\\n    }\\n    \\n    void Remove (int val) {\\n        frq [val] --;\\n    }\\n    \\n    int XthLargest (int x) {\\n        int cnt = 0;\\n        \\n        for (int val = -50; val < 0; val ++) {\\n            cnt += frq[val];\\n            if (cnt >= x) return val;\\n        }\\n        return 0;\\n    }\\n    \\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> result;\\n        int n = nums.size();\\n        \\n        for (int j = 0; j < k-1; j ++) Add (nums[j]);\\n        for (int j = k-1; j < n; j ++) {\\n            Add (nums[j]);\\n\\n            result.push_back(XthLargest (x));\\n            \\n            Remove (nums[j-k+1]);\\n        }\\n        \\n        frq.clear();\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map <int, int> frq;\\n    \\n    void Add (int val) {\\n        frq [val] ++;\\n    }\\n    \\n    void Remove (int val) {\\n        frq [val] --;\\n    }\\n    \\n    int XthLargest (int x) {\\n        int cnt = 0;\\n        \\n        for (int val = -50; val < 0; val ++) {\\n            cnt += frq[val];\\n            if (cnt >= x) return val;\\n        }\\n        return 0;\\n    }\\n    \\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> result;\\n        int n = nums.size();\\n        \\n        for (int j = 0; j < k-1; j ++) Add (nums[j]);\\n        for (int j = k-1; j < n; j ++) {\\n            Add (nums[j]);\\n\\n            result.push_back(XthLargest (x));\\n            \\n            Remove (nums[j-k+1]);\\n        }\\n        \\n        frq.clear();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446908,
                "title": "unique-solution-pbds-c",
                "content": "\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\nvector<int> getSubarrayBeauty(vector<int>& arr,int k, int x) {\\n       int i=0,j=0;\\n        ordered_set st;\\n        int n=arr.size();\\n        vector<int>temp;\\n        int y=0;\\n        while(j<n){\\n            st.insert({arr[j],y});          \\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n              int ans = (st.find_by_order(x-1))->first;\\n              if(ans>=0)temp.push_back(0);\\n              else temp.push_back(ans);\\n              st.erase(*st.find_by_order(st.order_of_key({arr[i], -1})));\\n              i++;\\n              j++;\\n            }\\n            y++;\\n        }\\n       return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\nvector<int> getSubarrayBeauty(vector<int>& arr,int k, int x) {\\n       int i=0,j=0;\\n        ordered_set st;\\n        int n=arr.size();\\n        vector<int>temp;\\n        int y=0;\\n        while(j<n){\\n            st.insert({arr[j],y});          \\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n              int ans = (st.find_by_order(x-1))->first;\\n              if(ans>=0)temp.push_back(0);\\n              else temp.push_back(ans);\\n              st.erase(*st.find_by_order(st.order_of_key({arr[i], -1})));\\n              i++;\\n              j++;\\n            }\\n            y++;\\n        }\\n       return temp;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3446649,
                "title": "java-2-solution-easy-to-understand",
                "content": "# 1st :\\n# *** sliding window with frequency counter ***\\n# Complexity\\n- Time complexity: O(N*101)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(101 + (nums.length - k + 1))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] counter = new int[101];\\n        int[] arr = new int[nums.length - k + 1];\\n        int index = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            counter[nums[i] + 50]++;\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i < counter.length; i++) {\\n            count += counter[i];\\n\\n            if(count >= x) {\\n                if(i - 50 < 0) {\\n                    arr[index++] = i - 50;\\n                } else {\\n                    index++;\\n                }   \\n                break;\\n            }\\n        }\\n\\n        if(count < x) {\\n            index++;\\n        }\\n        \\n        for(int i = k; i < nums.length; i++) {\\n            counter[nums[i] + 50]++;\\n            counter[nums[i-k] + 50]--;\\n\\n            int c = 0;\\n            for(int j = 0; j < counter.length; j++) {\\n                c += counter[j];\\n\\n                if(c >= x) {\\n                    if(j - 50 < 0) {\\n                        arr[index++] = j - 50;\\n                    } else {\\n                        index++;\\n                    }      \\n                    break;\\n                }\\n            }\\n\\n            if(c < x) {\\n                index++;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```\\n\\n# 2nd : \\n# ***************** Tree Set *******************\\n# Complexity\\n- Time complexity: O(N*logK)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        int[] arr = new int[nums.length - k + 1];\\n        int index = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        arr[index++] = findXthSmallest(map, x);\\n\\n        for(int i = k; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            map.put(nums[i-k], map.getOrDefault(nums[i-k], 0) - 1);\\n            \\n            if(map.get(nums[i-k]) == 0) {\\n                map.remove(nums[i-k]);\\n            }\\n\\n            arr[index++] = findXthSmallest(map, x);\\n        }\\n\\n        return arr;\\n    }\\n\\n    private int findXthSmallest(TreeMap<Integer, Integer> map, int x) {\\n        int xth = 0;\\n        for(int n : map.keySet()) {\\n            if(n < 0) {\\n                xth += map.get(n);\\n            } else {\\n                break;\\n            }\\n\\n            if(xth >= x) {\\n                return n;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] counter = new int[101];\\n        int[] arr = new int[nums.length - k + 1];\\n        int index = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            counter[nums[i] + 50]++;\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i < counter.length; i++) {\\n            count += counter[i];\\n\\n            if(count >= x) {\\n                if(i - 50 < 0) {\\n                    arr[index++] = i - 50;\\n                } else {\\n                    index++;\\n                }   \\n                break;\\n            }\\n        }\\n\\n        if(count < x) {\\n            index++;\\n        }\\n        \\n        for(int i = k; i < nums.length; i++) {\\n            counter[nums[i] + 50]++;\\n            counter[nums[i-k] + 50]--;\\n\\n            int c = 0;\\n            for(int j = 0; j < counter.length; j++) {\\n                c += counter[j];\\n\\n                if(c >= x) {\\n                    if(j - 50 < 0) {\\n                        arr[index++] = j - 50;\\n                    } else {\\n                        index++;\\n                    }      \\n                    break;\\n                }\\n            }\\n\\n            if(c < x) {\\n                index++;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        int[] arr = new int[nums.length - k + 1];\\n        int index = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        arr[index++] = findXthSmallest(map, x);\\n\\n        for(int i = k; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            map.put(nums[i-k], map.getOrDefault(nums[i-k], 0) - 1);\\n            \\n            if(map.get(nums[i-k]) == 0) {\\n                map.remove(nums[i-k]);\\n            }\\n\\n            arr[index++] = findXthSmallest(map, x);\\n        }\\n\\n        return arr;\\n    }\\n\\n    private int findXthSmallest(TreeMap<Integer, Integer> map, int x) {\\n        int xth = 0;\\n        for(int n : map.keySet()) {\\n            if(n < 0) {\\n                xth += map.get(n);\\n            } else {\\n                break;\\n            }\\n\\n            if(xth >= x) {\\n                return n;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446577,
                "title": "sliding-subarray-beauty-c-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n     int n=nums.size();\\n        vector<int> freq(51,0),ans;\\n        for(int i=0,j=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                freq[abs(nums[i])]++;\\n            }\\n            if(i-j+1>=k)\\n            {\\n                int count=0;\\n                for(int L=50;L>=1;L--)\\n                {\\n                    count+=freq[L];\\n                    if(count>=x)\\n                    {\\n                        ans.push_back(-L);\\n                        break;\\n                    }\\n                }\\n                if(count<x)\\n                {\\n                    ans.push_back(0);\\n                }\\n                if(nums[j]<0)\\n                {\\n                    freq[abs(nums[j])]--;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n     int n=nums.size();\\n        vector<int> freq(51,0),ans;\\n        for(int i=0,j=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                freq[abs(nums[i])]++;\\n            }\\n            if(i-j+1>=k)\\n            {\\n                int count=0;\\n                for(int L=50;L>=1;L--)\\n                {\\n                    count+=freq[L];\\n                    if(count>=x)\\n                    {\\n                        ans.push_back(-L);\\n                        break;\\n                    }\\n                }\\n                if(count<x)\\n                {\\n                    ans.push_back(0);\\n                }\\n                if(nums[j]<0)\\n                {\\n                    freq[abs(nums[j])]--;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446342,
                "title": "c-easiest-code-explanation-with-comments-space-o-1-time-o-n",
                "content": "# Intuition\\nFirstly you need to check the constraints carefully, If you miss out on them than probably you wont be able to come out with viable solution . If you see, the range of numbers is onlyfrom [-50,50].Thus, We can simply Store counts of negative numbers only in a counter array and use it to find the xth smallest number.\\n\\n# Approach\\nNow Just iterate over the counter array and sum the counts of each number. When the sum of counts is greater than or equal to x we have found out xth smallest number and break the iteration . If sum of counts is never greater than or equal to x there aren\\'t enough negative numbers.\\n\\n# Complexity\\n- Time complexity: O(N*50)\\n\\n- Space complexity: O(1), as we have used constant extra space .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n\\n        // Answer Array\\n        vector<int> ans;\\n        int n = nums.size();\\n\\n        // We declare a array of size 51 to store the count \\n        // of each negative element among last k elements .\\n        // and size is 51 because neative elements are in \\n        // range of [-50,-1] only \\n\\n        // Also we dont need to store the count of positive elements \\n        // because there is no need \\n        int mp[51] = {0};\\n\\n        // Step 1 : Stored the count of each negative elemnts among first k elements\\n        for(int i = 0 ; i< k ; i++){\\n            if(nums[i]<0)\\n                mp[-nums[i]]++;\\n        }\\n        \\n        // Now check the xth smallest element \\n        // If there are more than or qual to x elements store the ans \\n        // else store zero \\n        int count = 0;\\n            bool flag = true;\\n            for(int j = 50 ; j>= 1 ; j--){\\n                count += mp[j];\\n                \\n                if(count>= x){\\n                    ans.push_back(-j);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n                ans.push_back(0);\\n        \\n        \\n        // Now simply increase the count of next element and decrease \\n        // the count of last (i-k) element if they are negative respectively.\\n        // And check for Xth smallest element .\\n        for(int i = k ; i<n ; i++)\\n        {\\n            \\n            if(nums[i-k]<0 )\\n                mp[-nums[i-k]]--;\\n            if(nums[i]<0)\\n                mp[-nums[i]]++;\\n            int count = 0;\\n            bool flag = true;\\n            for(int j = 50 ; j>= 1 ; j--){\\n                count += mp[j];\\n                \\n                if(count>= x){\\n                    ans.push_back(-j);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n                ans.push_back(0);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n\\n        // Answer Array\\n        vector<int> ans;\\n        int n = nums.size();\\n\\n        // We declare a array of size 51 to store the count \\n        // of each negative element among last k elements .\\n        // and size is 51 because neative elements are in \\n        // range of [-50,-1] only \\n\\n        // Also we dont need to store the count of positive elements \\n        // because there is no need \\n        int mp[51] = {0};\\n\\n        // Step 1 : Stored the count of each negative elemnts among first k elements\\n        for(int i = 0 ; i< k ; i++){\\n            if(nums[i]<0)\\n                mp[-nums[i]]++;\\n        }\\n        \\n        // Now check the xth smallest element \\n        // If there are more than or qual to x elements store the ans \\n        // else store zero \\n        int count = 0;\\n            bool flag = true;\\n            for(int j = 50 ; j>= 1 ; j--){\\n                count += mp[j];\\n                \\n                if(count>= x){\\n                    ans.push_back(-j);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n                ans.push_back(0);\\n        \\n        \\n        // Now simply increase the count of next element and decrease \\n        // the count of last (i-k) element if they are negative respectively.\\n        // And check for Xth smallest element .\\n        for(int i = k ; i<n ; i++)\\n        {\\n            \\n            if(nums[i-k]<0 )\\n                mp[-nums[i-k]]--;\\n            if(nums[i]<0)\\n                mp[-nums[i]]++;\\n            int count = 0;\\n            bool flag = true;\\n            for(int j = 50 ; j>= 1 ; j--){\\n                count += mp[j];\\n                \\n                if(count>= x){\\n                    ans.push_back(-j);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n                ans.push_back(0);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446275,
                "title": "clean-c-code-tc-o-n-100",
                "content": "# Approach\\n-> take a freq array of size 101 as  -50 <= nums[i] <= 50\\n-> represent -50 -> 0       50 -> 100     nums[i] += 50 sot that all are done 0 based indexing\\n-> then simply for each subarry traverse over the freq array\\n\\n# Complexity\\n- Time complexity:\\nO(n * 100)\\n\\n- Space complexity:\\nO(100)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> freq(101), ans;\\n        for(int i = 0; i < k - 1; i++){\\n            freq[nums[i] + 50]++;\\n        }\\n        for(int i = k - 1; i < n; i++){\\n            freq[nums[i] + 50]++;\\n            int cnt = 0, val;\\n            for(int j = 0; j <= 100; j++){\\n                cnt += freq[j];\\n                if(cnt >= x){\\n                    val = min(0, j - 50);\\n                    ans.push_back(val);\\n                    break;\\n                }\\n            }\\n            freq[nums[i - k + 1] + 50]--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> freq(101), ans;\\n        for(int i = 0; i < k - 1; i++){\\n            freq[nums[i] + 50]++;\\n        }\\n        for(int i = k - 1; i < n; i++){\\n            freq[nums[i] + 50]++;\\n            int cnt = 0, val;\\n            for(int j = 0; j <= 100; j++){\\n                cnt += freq[j];\\n                if(cnt >= x){\\n                    val = min(0, j - 50);\\n                    ans.push_back(val);\\n                    break;\\n                }\\n            }\\n            freq[nums[i - k + 1] + 50]--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446205,
                "title": "easy-sorting-optimisation-c",
                "content": "# Explaination\\n We shall store the count of negative numbers and find Xth smallest number  \\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int it(vector<int>& a, int x){ // to find xth smallest integer in subarray\\n        int ans=0;\\n        for(int i=50;i>=0;i--){\\n           if(a[i]>0){ \\n               x-=a[i];\\n               if(x<=0){\\n                   ans=i;\\n                   break;\\n               }\\n           }\\n        }\\n        return ans;\\n     }\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> m(51,0); // constraints : -50 <= nums[i] <= 50 \\n        int n=nums.size();\\n        vector<int> ans(n-k+1); \\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0){\\n                m[abs(nums[i])]++; //Storing negative integer counts\\n            }\\n        }\\n        ans[0]=-it(m,x); \\n        for(int i=1;i<=n-k;i++){\\n            if(nums[i+k-1]<0){\\n                m[abs(nums[i+k-1])]++;\\n            }\\n            if(nums[i-1]<0){  //If previous index is -ve reduce that count\\n                m[abs(nums[i-1])]--; \\n            }\\n            ans[i]=-it(m,x);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int it(vector<int>& a, int x){ // to find xth smallest integer in subarray\\n        int ans=0;\\n        for(int i=50;i>=0;i--){\\n           if(a[i]>0){ \\n               x-=a[i];\\n               if(x<=0){\\n                   ans=i;\\n                   break;\\n               }\\n           }\\n        }\\n        return ans;\\n     }\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> m(51,0); // constraints : -50 <= nums[i] <= 50 \\n        int n=nums.size();\\n        vector<int> ans(n-k+1); \\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0){\\n                m[abs(nums[i])]++; //Storing negative integer counts\\n            }\\n        }\\n        ans[0]=-it(m,x); \\n        for(int i=1;i<=n-k;i++){\\n            if(nums[i+k-1]<0){\\n                m[abs(nums[i+k-1])]++;\\n            }\\n            if(nums[i-1]<0){  //If previous index is -ve reduce that count\\n                m[abs(nums[i-1])]--; \\n            }\\n            ans[i]=-it(m,x);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446149,
                "title": "java-solution-1005-faster-frequency-array-sliding-window-o-n-x",
                "content": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int ans[]=new int[n-k+1];\\n        int count=0;\\n        int arr[]=new int[50+1];\\n        for(int i=0,j=0;i<n-k+1;i++){\\n            while(j<=i+k-1){\\n                if(nums[j]<0){\\n                    arr[Math.abs(nums[j])]++;\\n                    count++;\\n                }\\n                j++;\\n            }  \\n            if(count>=x){\\n                int pop=0;\\n                int idx=50;\\n                int small=0;\\n                while(pop<x){\\n                    if(arr[idx]!=0){\\n                        pop+=arr[idx];\\n                        small=idx;\\n                    }\\n                    idx--;\\n                }\\n                ans[i]=(-small);\\n            }\\n            \\n            if(nums[i]<0){\\n                count--;\\n                arr[Math.abs(nums[i])]--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int ans[]=new int[n-k+1];\\n        int count=0;\\n        int arr[]=new int[50+1];\\n        for(int i=0,j=0;i<n-k+1;i++){\\n            while(j<=i+k-1){\\n                if(nums[j]<0){\\n                    arr[Math.abs(nums[j])]++;\\n                    count++;\\n                }\\n                j++;\\n            }  \\n            if(count>=x){\\n                int pop=0;\\n                int idx=50;\\n                int small=0;\\n                while(pop<x){\\n                    if(arr[idx]!=0){\\n                        pop+=arr[idx];\\n                        small=idx;\\n                    }\\n                    idx--;\\n                }\\n                ans[i]=(-small);\\n            }\\n            \\n            if(nums[i]<0){\\n                count--;\\n                arr[Math.abs(nums[i])]--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445994,
                "title": "best-solution-using-set-explained-in-detail",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int> s; //we are using multiset because there can be multiple occurences of an element\\n        vector<int> ans;\\n        \\n        for(int i=0; i<k-1; i++)\\n        { \\n            if(nums[i] < 0)  //insert negative elements present in first window\\n            s.insert(nums[i]);\\n        }\\n        \\n        for(int i=k-1; i<nums.size(); i++)\\n        {\\n            if(nums[i] < 0)  //only insert -ve elements in the set\\n             s.insert(nums[i]);\\n\\n            if(s.size() < x)        //if current window does not have at least x -ve elements\\n                ans.push_back(0);   //then insert 0, as given in problem statement\\n            else\\n            {\\n            //otherwise, insert the xth element of the set \\n            //i.e. x-1 elements after the first element\\n              auto it = next(s.begin(), x-1); \\n              ans.push_back(*it);\\n            }\\n\\n        //now, window will shift by one place to the right, so we need to delete the first element of the window\\n        //but our set contains only -ve elements\\n        //so, if i-k+1 th was negative,then it must be in our set also, and we need to remove it\\n        //otherwise, no need to do anything\\n            if(nums[i-k+1] < 0) \\n            s.erase(s.find(nums[i-k+1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int> s; //we are using multiset because there can be multiple occurences of an element\\n        vector<int> ans;\\n        \\n        for(int i=0; i<k-1; i++)\\n        { \\n            if(nums[i] < 0)  //insert negative elements present in first window\\n            s.insert(nums[i]);\\n        }\\n        \\n        for(int i=k-1; i<nums.size(); i++)\\n        {\\n            if(nums[i] < 0)  //only insert -ve elements in the set\\n             s.insert(nums[i]);\\n\\n            if(s.size() < x)        //if current window does not have at least x -ve elements\\n                ans.push_back(0);   //then insert 0, as given in problem statement\\n            else\\n            {\\n            //otherwise, insert the xth element of the set \\n            //i.e. x-1 elements after the first element\\n              auto it = next(s.begin(), x-1); \\n              ans.push_back(*it);\\n            }\\n\\n        //now, window will shift by one place to the right, so we need to delete the first element of the window\\n        //but our set contains only -ve elements\\n        //so, if i-k+1 th was negative,then it must be in our set also, and we need to remove it\\n        //otherwise, no need to do anything\\n            if(nums[i-k+1] < 0) \\n            s.erase(s.find(nums[i-k+1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445973,
                "title": "python3-solution",
                "content": "\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        vals = SortedList()\\n        for i, v in enumerate(nums): \\n            vals.add(v)\\n            if i >= k:\\n                vals.remove(nums[i-k])\\n            if i >= k-1: \\n                ans.append(min(0, vals[x-1]))\\n        return ans \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        vals = SortedList()\\n        for i, v in enumerate(nums): \\n            vals.add(v)\\n            if i >= k:\\n                vals.remove(nums[i-k])\\n            if i >= k-1: \\n                ans.append(min(0, vals[x-1]))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445892,
                "title": "easy-c-sliding-window-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n= nums.size(), neg=0, hav=0;\\n\\t\\t\\n\\t\\t// TAKE HASHMAP OF SIZE 102 ( It take all neg & positive values )\\n        vector<int> hashMap(102,0), res;\\n        \\n        for(int i=0; i<k; i++){ \\n            if(nums[i]<0) { neg++; hashMap[nums[i]+50]++; }\\n        }\\n        \\n        if(neg<x) res.push_back(0);\\n        for(int i=0; i<102; i++){\\n            if(hashMap[i]>0) {\\n                if(hashMap[i]+hav>=x){ res.push_back(i-50); break; } \\n                hav+= hashMap[i];\\n            }\\n        }\\n        \\n        for(int i=k; i<n; i++){\\n            hav=0;\\n            if(nums[i-k]<0){ neg--; hashMap[nums[i-k]+50]--; } \\n            if(nums[i]<0) { neg++;hashMap[nums[i]+50]++; } \\n    \\n            if(neg<x){ res.push_back(0); continue; }\\n            for(int i=0; i<102; i++){\\n                if(hashMap[i]>0) {\\n                    if(hashMap[i]+hav>=x){ res.push_back(i-50); break; } \\n                    hav+= hashMap[i];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n= nums.size(), neg=0, hav=0;\\n\\t\\t\\n\\t\\t// TAKE HASHMAP OF SIZE 102 ( It take all neg & positive values )\\n        vector<int> hashMap(102,0), res;\\n        \\n        for(int i=0; i<k; i++){ \\n            if(nums[i]<0) { neg++; hashMap[nums[i]+50]++; }\\n        }\\n        \\n        if(neg<x) res.push_back(0);\\n        for(int i=0; i<102; i++){\\n            if(hashMap[i]>0) {\\n                if(hashMap[i]+hav>=x){ res.push_back(i-50); break; } \\n                hav+= hashMap[i];\\n            }\\n        }\\n        \\n        for(int i=k; i<n; i++){\\n            hav=0;\\n            if(nums[i-k]<0){ neg--; hashMap[nums[i-k]+50]--; } \\n            if(nums[i]<0) { neg++;hashMap[nums[i]+50]++; } \\n    \\n            if(neg<x){ res.push_back(0); continue; }\\n            for(int i=0; i<102; i++){\\n                if(hashMap[i]>0) {\\n                    if(hashMap[i]+hav>=x){ res.push_back(i-50); break; } \\n                    hav+= hashMap[i];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445866,
                "title": "simple-to-understand-just-count-and-traverse-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRange of an element is between -50 to 50 and we need just negative so at each element i have to find xth smallest that will be in betwenn -1 to -50;\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake a array of size 50 to ->\\nsliding window = just store the frequency of each negative number in window in array and easily find the xth smallest by reversing the array the simple\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n*50)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int arr[],int x){\\n        for(int i=50;i>0;i--){\\n            if(arr[i]>0)x-=arr[i];\\n            if(x<=0)return i;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int arr[52]={0};// to store freq in a window\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0)\\n            arr[abs(nums[i])]+=1;\\n        }\\n        vector<int> ans(nums.size()-k+1,0);\\n        for(int i=k;i<=nums.size();i++){\\n            int l=find(arr,x);// seach xth smallest elementsl\\n            if(l>0)\\n            ans[i-k]=(-l);             \\n            if(i<nums.size()&&nums[i]<0)// to store new element\\n            arr[abs(nums[i])]+=1;\\n            if(nums[i-k]<0)// to remove out of window element\\n            arr[abs(nums[i-k])]-=1;\\n            \\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int arr[],int x){\\n        for(int i=50;i>0;i--){\\n            if(arr[i]>0)x-=arr[i];\\n            if(x<=0)return i;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int arr[52]={0};// to store freq in a window\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0)\\n            arr[abs(nums[i])]+=1;\\n        }\\n        vector<int> ans(nums.size()-k+1,0);\\n        for(int i=k;i<=nums.size();i++){\\n            int l=find(arr,x);// seach xth smallest elementsl\\n            if(l>0)\\n            ans[i-k]=(-l);             \\n            if(i<nums.size()&&nums[i]<0)// to store new element\\n            arr[abs(nums[i])]+=1;\\n            if(nums[i-k]<0)// to remove out of window element\\n            arr[abs(nums[i-k])]-=1;\\n            \\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445858,
                "title": "c-easy-sliding-window-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n     void push_ele(map<int,int>&mp,vector<int>&ans,int x)\\n     { \\n         int num=0;   // if cnt of negative elements is less than x\\n         int cnt=0;\\n         for(auto it:mp)\\n         {\\n             cnt+=it.second;\\n             if(cnt>=x)  // if cnt becomes greater than or equals to x\\n             {\\n                 num=it.first;  // xth element equals it.first\\n                 break;\\n             }\\n         }\\n         ans.push_back(num);\\n\\n     }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x)\\n    {\\n        map<int,int>mp; // to cnt the number of elements \\n        int cnt=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n            mp[nums[i]]++; // if it is negative then insert in map\\n            \\n            }\\n        }\\n        vector<int>ans;\\n        push_ele(mp,ans,x); \\n        for(int i=k;i<nums.size();i++) // sliding the window\\n        {\\n            if(nums[i]<0)\\n            mp[nums[i]]++;\\n            if(nums[i-k]<0)\\n            mp[nums[i-k]]--;\\n            push_ele(mp,ans,x); // function to insert xth negative element if exists\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n     void push_ele(map<int,int>&mp,vector<int>&ans,int x)\\n     { \\n         int num=0;   // if cnt of negative elements is less than x\\n         int cnt=0;\\n         for(auto it:mp)\\n         {\\n             cnt+=it.second;\\n             if(cnt>=x)  // if cnt becomes greater than or equals to x\\n             {\\n                 num=it.first;  // xth element equals it.first\\n                 break;\\n             }\\n         }\\n         ans.push_back(num);\\n\\n     }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x)\\n    {\\n        map<int,int>mp; // to cnt the number of elements \\n        int cnt=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n            mp[nums[i]]++; // if it is negative then insert in map\\n            \\n            }\\n        }\\n        vector<int>ans;\\n        push_ele(mp,ans,x); \\n        for(int i=k;i<nums.size();i++) // sliding the window\\n        {\\n            if(nums[i]<0)\\n            mp[nums[i]]++;\\n            if(nums[i-k]<0)\\n            mp[nums[i-k]]--;\\n            push_ele(mp,ans,x); // function to insert xth negative element if exists\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445851,
                "title": "c-using-multiset",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        1. To handle duplicates, use multiset.\\n        2. Use the next function to find the subarray\\'s xth smallest integer.\\n        3. There is no need to take care of positive integers (according to question).\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    multiset<int>mul;\\n    vector<int>result;\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        int z=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                mul.insert(nums[i]);\\n            }\\n            if(i-z+1==k){\\n                if(mul.size()<x){\\n                    result.push_back(0);\\n                }else{\\n                    result.push_back(*next(mul.begin(),x-1));\\n                }\\n                if(nums[z]<0){\\n                    mul.erase(mul.find(nums[z]));\\n                }\\n                z++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    multiset<int>mul;\\n    vector<int>result;\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        int z=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                mul.insert(nums[i]);\\n            }\\n            if(i-z+1==k){\\n                if(mul.size()<x){\\n                    result.push_back(0);\\n                }else{\\n                    result.push_back(*next(mul.begin(),x-1));\\n                }\\n                if(nums[z]<0){\\n                    mul.erase(mul.find(nums[z]));\\n                }\\n                z++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445847,
                "title": "c-very-simple-explanation-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. take a freq array,f, where index(-50)=0, and index (50)= 100\\nas -50<=nums[i]<=50\\n2. take 2 pointers i,j..i points to start of window, j points to end of window...j is used to stretch the sliding window\\nas you increase j, do f[nums[j]+50]++ \\n3. for the current window find the xth smallest number,and push it to ans vector\\n\\nHow this freq array f helps in finding the xth smallest?\\nsay a window= [-2, -1, 3, -5, -5, -2], x= 5\\n5th smallest number= -1\\nso for the window, freq array will look like this\\nfreq(-5)= 2, freq(-2)= 2, freq(-1)= 1, freq(3)= 1\\nf[-5+50]= 2, f[-2+50]= 2, f[-1+50]= 1, f[3+50]= 1\\n\\nwe move from index 0 to 100 and we have totalCount=0 initially:\\ni=45: f[45]>0: totalCount=totalCount+ f[45]= 2\\ni=48: f[48]>0: totalCount=totalCount+ f[48]= 4\\ni=49: f[49]>0: totalCount=totalCount+ f[49]= 5\\nat i=49, totalCount=5 which is >=x..this means at i=49, we have the xth smallest number...hence i-50 is the xth smallest number ,which is 49-50, ie -1\\n\\n\\n# Complexity\\n- Time complexity: O(n)+ O((n-k+1)*100)= O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(100)= O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findXthSmallest(vector<int>&f, int x){\\n        int totalCount=0;\\n        for(int i=0;i<101;i++){\\n            totalCount+= f[i];\\n            if(totalCount>=x) {\\n                if(i-50<0) return i-50;//index i points to number i-50..if i-50 is negative return it \\n                else return 0;//if i-50 is +ve, return 0\\n            }\\n        }\\n        return 0;//return anything..Whatever is to be returned ,will return from loop only\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> f(105,0), ans;//index of (-50)= 0, index of (50)= 100\\n        int i=0, j=0, n=nums.size();\\n        \\n        while(j<n){\\n            while(j-i<k && j<n){\\n                f[nums[j]+50]++;\\n                j++;\\n            }\\n            //find x th smallest\\n            int xSmallest= findXthSmallest(f, x);\\n            ans.push_back(xSmallest);\\n            f[nums[i]+50]--;//sliding the subarray, so remove ith element\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findXthSmallest(vector<int>&f, int x){\\n        int totalCount=0;\\n        for(int i=0;i<101;i++){\\n            totalCount+= f[i];\\n            if(totalCount>=x) {\\n                if(i-50<0) return i-50;//index i points to number i-50..if i-50 is negative return it \\n                else return 0;//if i-50 is +ve, return 0\\n            }\\n        }\\n        return 0;//return anything..Whatever is to be returned ,will return from loop only\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> f(105,0), ans;//index of (-50)= 0, index of (50)= 100\\n        int i=0, j=0, n=nums.size();\\n        \\n        while(j<n){\\n            while(j-i<k && j<n){\\n                f[nums[j]+50]++;\\n                j++;\\n            }\\n            //find x th smallest\\n            int xSmallest= findXthSmallest(f, x);\\n            ans.push_back(xSmallest);\\n            f[nums[i]+50]--;//sliding the subarray, so remove ith element\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445833,
                "title": "c-java-min-heap-using-maps",
                "content": "## Explanation\\nI tried to solve using priority queues and multisets initially but it gave me TLE as I was iterating over duplicate values every time !! Then I tried this approach where we use Maps as MinHeaps to store the values in the array and their frequencies so that while calculating the x-th smallest integer each time, the code runs fast as we don\\'t need to traverse over all the elements with same values in the subarray !!\\n\\n## Code\\n\\n**Code that gave me TLE using Multisets :**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int findKthSmallest(multiset <int> &pq, int x){\\n        int i = 1;\\n        for(auto it = pq.begin(); it != pq.end(); it++){\\n            if(*it >= 0) return 0;\\n            if(i == x) {\\n                return *it;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset <int> st;\\n        int n = size(nums);\\n        vector<int>res;\\n\\n        for(int i = 0; i < k; i++) st.insert(nums[i]);\\n        res.push_back(findKthSmallest(st,x));\\n\\n        for(int i = 0; i < n-k; i++){\\n            auto it = st.find(nums[i]);\\n            st.erase(it);\\n            st.insert(nums[i+k]);\\n            res.push_back(findKthSmallest(st,x));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n**Working Code using Maps :**\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n\\n        int n = size(nums);\\n        vector<int>res;\\n        map <int, int> minHeap;\\n\\n        for(int i = 0; i < n; i++){\\n            minHeap[nums[i]]++;\\n            if(i >= k){\\n                // erase the element at nums[i-k] ( sliding window moves)\\n                minHeap[nums[i-k]]--;\\n                if(minHeap[nums[i-k]] == 0) minHeap.erase(nums[i-k]);\\n            }\\n            if(i >= k-1){\\n                int cnt = 0, val = 0;\\n                for(auto &[k,v] : minHeap){\\n                    cnt += v;\\n                    if(cnt >= x) {\\n                        val = k;\\n                        break;\\n                    }\\n                }\\n                res.push_back((val > 0)? 0 : val);\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        Map<Integer, Integer> minHeap = new TreeMap<>();\\n\\n        for(int i = 0; i < n; i++) {\\n            minHeap.put(nums[i], minHeap.getOrDefault(nums[i], 0) + 1);\\n            if(i >= k) {\\n                // erase the element at nums[i-k] ( sliding window moves)\\n                minHeap.put(nums[i-k], minHeap.get(nums[i-k]) - 1);\\n                if(minHeap.get(nums[i-k]) == 0) minHeap.remove(nums[i-k]);\\n            }\\n            if(i >= k-1) {\\n                int cnt = 0, val = 0;\\n                for(Map.Entry<Integer, Integer> entry : minHeap.entrySet()) {\\n                    cnt += entry.getValue();\\n                    if(cnt >= x) {\\n                        val = entry.getKey();\\n                        break;\\n                    }\\n                }\\n                res.add((val > 0) ? 0 : val);\\n            }\\n        } \\n        return res;\\n    }\\n}\\n\\n```\\n## Complexity\\n- Time complexity: $$O(n log(k))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findKthSmallest(multiset <int> &pq, int x){\\n        int i = 1;\\n        for(auto it = pq.begin(); it != pq.end(); it++){\\n            if(*it >= 0) return 0;\\n            if(i == x) {\\n                return *it;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset <int> st;\\n        int n = size(nums);\\n        vector<int>res;\\n\\n        for(int i = 0; i < k; i++) st.insert(nums[i]);\\n        res.push_back(findKthSmallest(st,x));\\n\\n        for(int i = 0; i < n-k; i++){\\n            auto it = st.find(nums[i]);\\n            st.erase(it);\\n            st.insert(nums[i+k]);\\n            res.push_back(findKthSmallest(st,x));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n\\n        int n = size(nums);\\n        vector<int>res;\\n        map <int, int> minHeap;\\n\\n        for(int i = 0; i < n; i++){\\n            minHeap[nums[i]]++;\\n            if(i >= k){\\n                // erase the element at nums[i-k] ( sliding window moves)\\n                minHeap[nums[i-k]]--;\\n                if(minHeap[nums[i-k]] == 0) minHeap.erase(nums[i-k]);\\n            }\\n            if(i >= k-1){\\n                int cnt = 0, val = 0;\\n                for(auto &[k,v] : minHeap){\\n                    cnt += v;\\n                    if(cnt >= x) {\\n                        val = k;\\n                        break;\\n                    }\\n                }\\n                res.push_back((val > 0)? 0 : val);\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        Map<Integer, Integer> minHeap = new TreeMap<>();\\n\\n        for(int i = 0; i < n; i++) {\\n            minHeap.put(nums[i], minHeap.getOrDefault(nums[i], 0) + 1);\\n            if(i >= k) {\\n                // erase the element at nums[i-k] ( sliding window moves)\\n                minHeap.put(nums[i-k], minHeap.get(nums[i-k]) - 1);\\n                if(minHeap.get(nums[i-k]) == 0) minHeap.remove(nums[i-k]);\\n            }\\n            if(i >= k-1) {\\n                int cnt = 0, val = 0;\\n                for(Map.Entry<Integer, Integer> entry : minHeap.entrySet()) {\\n                    cnt += entry.getValue();\\n                    if(cnt >= x) {\\n                        val = entry.getKey();\\n                        break;\\n                    }\\n                }\\n                res.add((val > 0) ? 0 : val);\\n            }\\n        } \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445804,
                "title": "ordered-set-map",
                "content": "# Method 1\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<int, null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update>\\n  \\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n        int rank = t.order_of_key(v);\\n        ordered_set::iterator it = t.find_by_order(rank);\\n        t.erase(it);\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        ordered_set st;\\n        int i=0,j=0,n=size(nums);\\n        while(j < n){\\n            st.insert(nums[j]);\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                int e = *(st.find_by_order(x-1));\\n                ans.push_back(e < 0 ? e : 0);\\n                myerase(st,(nums[i]));\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Method 2\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = size(nums), i = 0, j = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        while(j < n){\\n            mp[nums[j]]++;\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                int ct=0;\\n                for(auto&[k,e]: mp){\\n                    if(ct+e>=x){\\n                        ans.push_back(k>0?0:k);\\n                        break;\\n                    }\\n                    ct += e;\\n                }\\n                if(--mp[nums[i]] == 0) mp.erase(nums[i]);\\n                j++,i++;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<int, null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update>\\n  \\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n        int rank = t.order_of_key(v);\\n        ordered_set::iterator it = t.find_by_order(rank);\\n        t.erase(it);\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        ordered_set st;\\n        int i=0,j=0,n=size(nums);\\n        while(j < n){\\n            st.insert(nums[j]);\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                int e = *(st.find_by_order(x-1));\\n                ans.push_back(e < 0 ? e : 0);\\n                myerase(st,(nums[i]));\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = size(nums), i = 0, j = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        while(j < n){\\n            mp[nums[j]]++;\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                int ct=0;\\n                for(auto&[k,e]: mp){\\n                    if(ct+e>=x){\\n                        ans.push_back(k>0?0:k);\\n                        break;\\n                    }\\n                    ct += e;\\n                }\\n                if(--mp[nums[i]] == 0) mp.erase(nums[i]);\\n                j++,i++;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3445751,
                "title": "python3-sorted-list-solution-o-nlogn",
                "content": "**Approach**\\nMaintain an ordered list to store the integers and update it using two pointers.\\n\\n**Complexity**\\nO(NlogN)\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        sl = SortedList()\\n        n = len(nums)\\n        ng = 0\\n        for i in range(k):\\n            sl.add(nums[i])\\n\\n        ans = []\\n        ans.append(min(sl[x - 1], 0))\\n        \\n        i, j = 0, k\\n        \\n        while j < n:\\n            sl.discard(nums[i])\\n            sl.add(nums[j])\\n            i += 1\\n            j += 1\\n            ans.append(min(sl[x - 1], 0))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        sl = SortedList()\\n        n = len(nums)\\n        ng = 0\\n        for i in range(k):\\n            sl.add(nums[i])\\n\\n        ans = []\\n        ans.append(min(sl[x - 1], 0))\\n        \\n        i, j = 0, k\\n        \\n        while j < n:\\n            sl.discard(nums[i])\\n            sl.add(nums[j])\\n            i += 1\\n            j += 1\\n            ans.append(min(sl[x - 1], 0))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445717,
                "title": "map-cpp-two-map-solution-with-detailed-explanation-o-n-log-n",
                "content": "### if you like the solution, please give me a up vote.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to find the xth smallest integer in subarray,\\nwhen we move the subarray, do following operations,\\n1. add new value `nums[i]`\\n2. remove the oldest value `nums[i-k+1]`\\n\\n### Concept\\n<!-- Describe your approach to solving the problem. -->\\nWe can use two map `lower, upper` to maintain the value order,\\nthe count of `lower` is x\\nthe count of `upper` is k - x\\n\\nso the xth smallest integer is at `lower.rbegin()`\\n\\n\\n\\n### Operation : remove the oldest value\\nafter remove the oldest value,\\nwe want to maintain map as below,\\n- the count of `lower` is `x - 1`\\n- the count of `upper` is `k - x`\\n\\nthe oldest value maybe in `lower` or `upper`\\n1. the oldest value in `lower`\\n    directly remove the oldest value from `lower`.\\n\\n2. the oldest value in `upper`\\na. remove the oldest value from `upper`.\\nb. get the largest value from `lower` and insert into `upper`\\n\\n\\n### Operation: add new value\\n1. insert the value into `upper`\\n2. get the smallest value from `upper` and insert into `lower`\\n\\n\\n\\n### Operation: get the xth smallest value\\nthe xth smallest integer is at `lower.rbegin()`\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void remove_val(map<int, int> &m, int val) {\\n        m[val]--;\\n        if(m[val] == 0) {\\n            m.erase(val);\\n        }\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> output(n-k+1, 0);\\n        int upper_cnt = 0;\\n        int val;\\n        map<int, int> lower;\\n        map<int, int> upper;\\n        \\n        for(int i = 0 ; i < (k-1) ; i++) {\\n            upper[nums[i]]++;\\n            upper_cnt++;\\n            if(upper_cnt <= (k - x)) {\\n                continue;\\n            }\\n            \\n            val = upper.begin()->first;\\n            lower[val]++;\\n            \\n            remove_val(upper, val);\\n        }\\n        \\n        for(int i = k-1; i < n; i++) {\\n            int idx = i - k + 1;\\n            val = nums[i];\\n            upper[val]++;\\n            \\n            val = upper.begin()->first;\\n            lower[val]++;\\n            remove_val(upper, val);\\n            \\n            \\n            if(lower.rbegin()->first < 0) {\\n                output[idx] = lower.rbegin()->first;\\n            }\\n            \\n        \\n            //remove val\\n            val = nums[idx];\\n            if(val >= upper.begin()->first) {\\n                remove_val(upper, val);\\n                \\n                //move lower to upper;\\n                val = lower.rbegin()->first;\\n                upper[val]++;\\n                remove_val(lower, val);\\n            }\\n            else {\\n                remove_val(lower, val);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void remove_val(map<int, int> &m, int val) {\\n        m[val]--;\\n        if(m[val] == 0) {\\n            m.erase(val);\\n        }\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> output(n-k+1, 0);\\n        int upper_cnt = 0;\\n        int val;\\n        map<int, int> lower;\\n        map<int, int> upper;\\n        \\n        for(int i = 0 ; i < (k-1) ; i++) {\\n            upper[nums[i]]++;\\n            upper_cnt++;\\n            if(upper_cnt <= (k - x)) {\\n                continue;\\n            }\\n            \\n            val = upper.begin()->first;\\n            lower[val]++;\\n            \\n            remove_val(upper, val);\\n        }\\n        \\n        for(int i = k-1; i < n; i++) {\\n            int idx = i - k + 1;\\n            val = nums[i];\\n            upper[val]++;\\n            \\n            val = upper.begin()->first;\\n            lower[val]++;\\n            remove_val(upper, val);\\n            \\n            \\n            if(lower.rbegin()->first < 0) {\\n                output[idx] = lower.rbegin()->first;\\n            }\\n            \\n        \\n            //remove val\\n            val = nums[idx];\\n            if(val >= upper.begin()->first) {\\n                remove_val(upper, val);\\n                \\n                //move lower to upper;\\n                val = lower.rbegin()->first;\\n                upper[val]++;\\n                remove_val(lower, val);\\n            }\\n            else {\\n                remove_val(lower, val);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445702,
                "title": "sliding-window-ordered-set-c",
                "content": "# Intuition\\nProblem statement gives clear indication. All you need to is to think of a data structure which perofrms insertion and deletion in logn time and finds kth-element in logn. Ordered set is perfect for that\\n\\n# Approach\\nKeep moving the sliding window and find the kth element of each window using Ordered Set.\\n\\n# Complexity\\n- Time complexity:\\nNlogN for Ordered Set\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n//INCLUDE ORDERED SET\\n\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_multiset tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\n//ORDERED SET doesn\\'t contains duplicate so use pair and pass index along with number to avoid duplicates\\n\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_multiset os;\\n        int start=0;\\n        int end=0;\\n        vector <int> ans;\\n        while(end<nums.size()){\\n            os.insert({nums[end],end});\\n            if(end-start+1>k){\\n                //MOVE the sliding window\\n                os.erase({nums[start],start});\\n                ++start;\\n            }\\n            if(end-start+1==k){\\n                //Find xth smallest element\\n                auto it = os.find_by_order(x - 1);\\n                ans.push_back(it->first);\\n            }\\n            ++end;\\n        }\\n        for(auto &it:ans)if(it>0)it=0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\n//INCLUDE ORDERED SET\\n\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_multiset tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\n//ORDERED SET doesn\\'t contains duplicate so use pair and pass index along with number to avoid duplicates\\n\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_multiset os;\\n        int start=0;\\n        int end=0;\\n        vector <int> ans;\\n        while(end<nums.size()){\\n            os.insert({nums[end],end});\\n            if(end-start+1>k){\\n                //MOVE the sliding window\\n                os.erase({nums[start],start});\\n                ++start;\\n            }\\n            if(end-start+1==k){\\n                //Find xth smallest element\\n                auto it = os.find_by_order(x - 1);\\n                ans.push_back(it->first);\\n            }\\n            ++end;\\n        }\\n        for(auto &it:ans)if(it>0)it=0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3445695,
                "title": "pbds-policy-based-data-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\n  \\n// namespace necessary for GNU based \\n// policy based data structures\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        int n= nums.size();\\n        // multiset<int> m;\\n        ordered_set m;\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            m.insert(nums[i]);\\n            if(i-j+1==k)\\n            {\\n                auto it = m.find_by_order(x-1); \\n                if((*it)>=0)\\n                    ans.push_back(0);\\n                else\\n                ans.push_back((*it));\\n                m.erase(--m.lower_bound(nums[j]));\\n                j++;\\n            }\\n            i++;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\n  \\n// namespace necessary for GNU based \\n// policy based data structures\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        int n= nums.size();\\n        // multiset<int> m;\\n        ordered_set m;\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            m.insert(nums[i]);\\n            if(i-j+1==k)\\n            {\\n                auto it = m.find_by_order(x-1); \\n                if((*it)>=0)\\n                    ans.push_back(0);\\n                else\\n                ans.push_back((*it));\\n                m.erase(--m.lower_bound(nums[j]));\\n                j++;\\n            }\\n            i++;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3445666,
                "title": "map-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        map<int, int> freq;\\n        \\n        int l = 0, r = 0;\\n        \\n        while (r < n) {\\n            freq[nums[r]]++;\\n            \\n            if (r >= k-1) {\\n                \\n                int cnt = 0;\\n                for (auto it : freq) {\\n                    cnt += it.second;\\n                    if (cnt >= x) {\\n                        ans.push_back((it.first < 0) ? it.first : 0);\\n                        break;\\n                    }\\n                }\\n                \\n                if (--freq[nums[l]] == 0) \\n                    freq.erase(nums[l]);\\n                \\n                l++;\\n            }\\n            \\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        map<int, int> freq;\\n        \\n        int l = 0, r = 0;\\n        \\n        while (r < n) {\\n            freq[nums[r]]++;\\n            \\n            if (r >= k-1) {\\n                \\n                int cnt = 0;\\n                for (auto it : freq) {\\n                    cnt += it.second;\\n                    if (cnt >= x) {\\n                        ans.push_back((it.first < 0) ? it.first : 0);\\n                        break;\\n                    }\\n                }\\n                \\n                if (--freq[nums[l]] == 0) \\n                    freq.erase(nums[l]);\\n                \\n                l++;\\n            }\\n            \\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101014,
                "title": "simple-c-easy-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(nlogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<k-1;i++)   // to avoid computing for the first time min value\\n            mp[nums[i]]++;\\n        vector<int> ans;\\n        for(int i=k-1;i<nums.size();i++){\\n            mp[nums[i]]++;\\n            int count = 0;\\n            int num = 0;\\n            for(auto s:mp){\\n                count += s.second;\\n                if(count>=x){\\n                    num = min(num,s.first);\\n                    break;\\n                }\\n            }\\n            ans.push_back(num);\\n            mp[nums[i-k+1]]--;\\n            // if(mp[nums[i-k+1]]==0)\\n            //     mp.erase(nums[i-k+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<k-1;i++)   // to avoid computing for the first time min value\\n            mp[nums[i]]++;\\n        vector<int> ans;\\n        for(int i=k-1;i<nums.size();i++){\\n            mp[nums[i]]++;\\n            int count = 0;\\n            int num = 0;\\n            for(auto s:mp){\\n                count += s.second;\\n                if(count>=x){\\n                    num = min(num,s.first);\\n                    break;\\n                }\\n            }\\n            ans.push_back(num);\\n            mp[nums[i-k+1]]--;\\n            // if(mp[nums[i-k+1]]==0)\\n            //     mp.erase(nums[i-k+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062124,
                "title": "segment-tree-solution-o-n-log-64",
                "content": "\\t# we utilize the fact that the range of negative numbers we have to track (-50 -> -1)\\n\\t# is small.  We build a segment tree where each leaf is the cnt of negative values in\\n\\t# the range and each parent is the count of negative numbers in its children.  We \\n\\t# scroll through the nums array, adding negative numbers as we see them and \\n\\t# removing them as they leave our window.  \\n\\t\\n\\tdef removeVal(tree, val):\\n            index = 128 + val\\n            while index != 0:\\n                tree[index] -= 1\\n                index = (index // 2)\\n            \\n            return(tree)\\n        \\n        def addVal(tree, val):\\n            index = 128 + val\\n            while index != 0:\\n                tree[index] += 1\\n                index = (index // 2)\\n            \\n            return(tree)\\n        \\n        def checkX(tree, x):\\n            index = 1\\n            while True:\\n                indexL = 2*index\\n                indexR = 2*index + 1\\n                \\n                if indexL >= len(tree):\\n                    return(index - 2*64)\\n                \\n                if tree[indexL] < x:\\n                    x -= tree[indexL]\\n                    index = indexR\\n                else:\\n                    index = indexL\\n                    \\n        #########\\n        n = len(nums)\\n        \\n        tree = [0]*(2*64)\\n        \\n        ans = []\\n\\t\\t# build the tree for our initial window of size k:\\n        for val in nums[:k]:\\n            if val < 0:\\n                tree = addVal(tree, val)\\n            \\n        if tree[1] < x:\\n            ans.append(0)\\n        else:\\n            ans.append(checkX(tree, x))\\n        \\n\\t\\t# scroll through nums, updating our segment tree and array ans:\\n        for ii in range(k, n):\\n            val = nums[ii]\\n            if val < 0:\\n                tree = addVal(tree, val)\\n            \\n            val2 = nums[ii-k]\\n            if val2 < 0:\\n                tree = removeVal(tree, val2)\\n                \\n            if tree[1] < x:\\n                ans.append(0)\\n            else:\\n                ans.append(checkX(tree, x))\\n        \\n        return(ans)",
                "solutionTags": [],
                "code": "\\t# we utilize the fact that the range of negative numbers we have to track (-50 -> -1)\\n\\t# is small.  We build a segment tree where each leaf is the cnt of negative values in\\n\\t# the range and each parent is the count of negative numbers in its children.  We \\n\\t# scroll through the nums array, adding negative numbers as we see them and \\n\\t# removing them as they leave our window.  \\n\\t\\n\\tdef removeVal(tree, val):\\n            index = 128 + val\\n            while index != 0:\\n                tree[index] -= 1\\n                index = (index // 2)\\n            \\n            return(tree)\\n        \\n        def addVal(tree, val):\\n            index = 128 + val\\n            while index != 0:\\n                tree[index] += 1\\n                index = (index // 2)\\n            \\n            return(tree)\\n        \\n        def checkX(tree, x):\\n            index = 1\\n            while True:\\n                indexL = 2*index\\n                indexR = 2*index + 1\\n                \\n                if indexL >= len(tree):\\n                    return(index - 2*64)\\n                \\n                if tree[indexL] < x:\\n                    x -= tree[indexL]\\n                    index = indexR\\n                else:\\n                    index = indexL\\n                    \\n        #########\\n        n = len(nums)\\n        \\n        tree = [0]*(2*64)\\n        \\n        ans = []\\n\\t\\t# build the tree for our initial window of size k:\\n        for val in nums[:k]:\\n            if val < 0:\\n                tree = addVal(tree, val)\\n            \\n        if tree[1] < x:\\n            ans.append(0)\\n        else:\\n            ans.append(checkX(tree, x))\\n        \\n\\t\\t# scroll through nums, updating our segment tree and array ans:\\n        for ii in range(k, n):\\n            val = nums[ii]\\n            if val < 0:\\n                tree = addVal(tree, val)\\n            \\n            val2 = nums[ii-k]\\n            if val2 < 0:\\n                tree = removeVal(tree, val2)\\n                \\n            if tree[1] < x:\\n                ans.append(0)\\n            else:\\n                ans.append(checkX(tree, x))\\n        \\n        return(ans)",
                "codeTag": "Python3"
            },
            {
                "id": 4032841,
                "title": "simple-java-o-n-50",
                "content": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] arr, int k, int x) {\\n        int[] ans = new int[arr.length - k + 1];\\n        int[] temp = new int[51];\\n        for(int i = 0 ; i < k ; i++){\\n            int ele = arr[i];\\n            if(ele < 0){\\n                temp[-1 * ele]++;\\n            }\\n        }\\n        int ptr = 0;\\n        ans[ptr++] = getValue(temp , x);\\n        for(int i = k ; i < arr.length ; i++){\\n            int prev = i - k;\\n            if(arr[prev] < 0)\\n                temp[arr[prev] * -1]--;\\n            if(arr[i] < 0)\\n                temp[arr[i] * -1]++;\\n            ans[ptr++] = getValue(temp , x);\\n        }\\n        return ans;\\n    }\\n    private int getValue(int[] arr , int x){\\n        int count = 0;\\n        int value = 0;\\n        for(int i = 50 ; i >= 0 ; i--){\\n            if(arr[i] > 0){\\n                count += arr[i];\\n                value = i;\\n            }\\n            if(count >= x) return i * -1;\\n        }\\n        return 0;\\n    }\\n}\\n\\n```\\n***Please UpVote, if found useful :)***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] arr, int k, int x) {\\n        int[] ans = new int[arr.length - k + 1];\\n        int[] temp = new int[51];\\n        for(int i = 0 ; i < k ; i++){\\n            int ele = arr[i];\\n            if(ele < 0){\\n                temp[-1 * ele]++;\\n            }\\n        }\\n        int ptr = 0;\\n        ans[ptr++] = getValue(temp , x);\\n        for(int i = k ; i < arr.length ; i++){\\n            int prev = i - k;\\n            if(arr[prev] < 0)\\n                temp[arr[prev] * -1]--;\\n            if(arr[i] < 0)\\n                temp[arr[i] * -1]++;\\n            ans[ptr++] = getValue(temp , x);\\n        }\\n        return ans;\\n    }\\n    private int getValue(int[] arr , int x){\\n        int count = 0;\\n        int value = 0;\\n        for(int i = 50 ; i >= 0 ; i--){\\n            if(arr[i] > 0){\\n                count += arr[i];\\n                value = i;\\n            }\\n            if(count >= x) return i * -1;\\n        }\\n        return 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013740,
                "title": "c-easy-solution-using-sliding-window-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size(),i = 0,j = 0,sz = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        while(j < n){\\n            if(nums[j] < 0){ \\n                mp[nums[j]]++;\\n                sz++;\\n            }\\n            if(j-i+1 == k){\\n                if(sz >= x){\\n                    int ct = 0;\\n                    for(auto it:mp){\\n                        ct += it.second;\\n                        if(ct >= x){\\n                            ans.push_back(it.first);\\n                            break;\\n                        }\\n                    }\\n                }else{\\n                    ans.push_back(0);\\n                }\\n                if(nums[i] < 0){\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]] == 0) mp.erase(nums[i]);\\n                    sz--;\\n                }\\n                i++;\\n            }\\n\\t\\t\\tj++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size(),i = 0,j = 0,sz = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        while(j < n){\\n            if(nums[j] < 0){ \\n                mp[nums[j]]++;\\n                sz++;\\n            }\\n            if(j-i+1 == k){\\n                if(sz >= x){\\n                    int ct = 0;\\n                    for(auto it:mp){\\n                        ct += it.second;\\n                        if(ct >= x){\\n                            ans.push_back(it.first);\\n                            break;\\n                        }\\n                    }\\n                }else{\\n                    ans.push_back(0);\\n                }\\n                if(nums[i] < 0){\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]] == 0) mp.erase(nums[i]);\\n                    sz--;\\n                }\\n                i++;\\n            }\\n\\t\\t\\tj++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002083,
                "title": "easy-java-o-n-time-and-o-1-memory-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nAfter reading the problem statement there is one thing which is quite apparent. All numbers >= 0 in the array are useless to us. They do not influence the \"beauty\" of any subarray in any way.\\n\\nAnother important thing to notice in the constraints is that nums[i] is between -50 and 50.\\n\\nSince we only care about negative values, this means that there are a total of 50 potential distinct values in this array which we care about [-50, -1]. Let\\'s try and use this!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLet\\'s use our usual left and right pointer technique to create a window of k elements, and then shift it accordingly every iteration.\\n\\nFor every window let\\'s use an array of size 50 representing the count of all negative numbers in our window. We will update the count accordingly as we go left to right.\\n\\nOne task remains, checking for the Xth smallest negative number in each window. We can easily do this using our array of negative number counts. Index 0 represents the count of -50 in a given window, index 1 represents -49, and so on. The last index represents the count of -1. We can just traverse this small array of size 50 from left to right for every window and increase our count of the smallest negative numbers until we hit or surpass x. If we break out of the loop before hitting x that means that there are less than x negative numbers so we return 0.\\n\\n\\n# Complexity\\nTime complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- O(n)\\n- Going through the whole array with left and right pointers takes is a linear time operation. Going through the array of negative number counts is a constant time operation since there are only 50 entries.\\n\\n\\n\\nSpace complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n- O(1)\\n- We are using an auxilary array of size 50, but size 50 is constant.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        \\n        int[] ans = new int[nums.length - k + 1];\\n        int[] negCount = new int[50];\\n        int left = 0;\\n        int ansPtr = 0;\\n\\n        for(int right = 0; right < nums.length; right++){\\n\\n            if(nums[right] < 0){\\n                negCount[nums[right] + 50] += 1;\\n            }\\n\\n            if(right - left >= k){\\n\\n                if(nums[left] < 0){\\n                    negCount[nums[left] + 50] -= 1;\\n                }\\n\\n                left+= 1;\\n\\n            }\\n\\n            if(right - left == k - 1){\\n                int result = findXSmallest(negCount, x);\\n                ans[ansPtr] = result;\\n                ansPtr += 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n    public int findXSmallest(int[] negCount, int x){\\n        int count = 0;\\n\\n        for(int i = 0; i < negCount.length; i++){\\n\\n            count += negCount[i];\\n\\n            if(count >= x){\\n                return i - 50;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Counting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        \\n        int[] ans = new int[nums.length - k + 1];\\n        int[] negCount = new int[50];\\n        int left = 0;\\n        int ansPtr = 0;\\n\\n        for(int right = 0; right < nums.length; right++){\\n\\n            if(nums[right] < 0){\\n                negCount[nums[right] + 50] += 1;\\n            }\\n\\n            if(right - left >= k){\\n\\n                if(nums[left] < 0){\\n                    negCount[nums[left] + 50] -= 1;\\n                }\\n\\n                left+= 1;\\n\\n            }\\n\\n            if(right - left == k - 1){\\n                int result = findXSmallest(negCount, x);\\n                ans[ansPtr] = result;\\n                ansPtr += 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n    public int findXSmallest(int[] negCount, int x){\\n        int count = 0;\\n\\n        for(int i = 0; i < negCount.length; i++){\\n\\n            count += negCount[i];\\n\\n            if(count >= x){\\n                return i - 50;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943657,
                "title": "beats-74-run-time-o-n",
                "content": "# Intuition\\nDefine a hash fuction for all -50 to -1 element and keep a tarck of the count. when window size got hit then start keeping track of count via prefix sum in for loop. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        hm = defaultdict(int)\\n        i = 0 \\n        out = []\\n\\n        for h in range(-50,0):\\n            hm[h] = 0 \\n        \\n        for j in range(len(nums)):\\n            if nums[j] < 0 :\\n                hm[nums[j]] += 1\\n\\n            if j-i+1 == k : \\n                count = 0 \\n                for m in range(-50,0):\\n                    count += hm[m]\\n                    if count >= x :\\n                        out.append(m)\\n                        break \\n                if count < x: \\n                    out.append(0)\\n                hm[nums[i]] -= 1\\n                i += 1\\n        \\n        return out\\n                    \\n\\n                \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        hm = defaultdict(int)\\n        i = 0 \\n        out = []\\n\\n        for h in range(-50,0):\\n            hm[h] = 0 \\n        \\n        for j in range(len(nums)):\\n            if nums[j] < 0 :\\n                hm[nums[j]] += 1\\n\\n            if j-i+1 == k : \\n                count = 0 \\n                for m in range(-50,0):\\n                    count += hm[m]\\n                    if count >= x :\\n                        out.append(m)\\n                        break \\n                if count < x: \\n                    out.append(0)\\n                hm[nums[i]] -= 1\\n                i += 1\\n        \\n        return out\\n                    \\n\\n                \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860893,
                "title": "c-beats-99-3-solution-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n*50)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int z) {\\n   \\n    vector<int>v(101,0);\\n     for(int i=0;i<k-1;i++)\\n     {\\n      \\n      v[nums[i]+50]++;\\n     }\\n     vector<int>ans;\\n     int l=0;\\n    for(int i=k-1;i<nums.size();i++)\\n    {\\n     v[nums[i]+50]++;\\n      int cnt=0;\\n      for(int j=0;j<=50;j++)\\n      { \\n        cnt+=v[j];\\n        if(cnt>=z){ans.push_back(j-50);\\n        break;\\n        }\\n\\n      }\\n      if(cnt<z)ans.push_back(0);\\n   v[nums[l]+50]--;\\n   \\n   \\n   l++;\\n\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int z) {\\n   \\n    vector<int>v(101,0);\\n     for(int i=0;i<k-1;i++)\\n     {\\n      \\n      v[nums[i]+50]++;\\n     }\\n     vector<int>ans;\\n     int l=0;\\n    for(int i=k-1;i<nums.size();i++)\\n    {\\n     v[nums[i]+50]++;\\n      int cnt=0;\\n      for(int j=0;j<=50;j++)\\n      { \\n        cnt+=v[j];\\n        if(cnt>=z){ans.push_back(j-50);\\n        break;\\n        }\\n\\n      }\\n      if(cnt<z)ans.push_back(0);\\n   v[nums[l]+50]--;\\n   \\n   \\n   l++;\\n\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859545,
                "title": "easy-c-solution-using-map",
                "content": "# Complexity\\n- Time complexity:\\n(n*k)\\n\\n- Space complexity:\\n- O(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n// [1,2,3,3,3] k = 2, x = 2;\\n// ans = [0, 0, 0]  devil\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        map<int, int> mp;\\n\\n        for(int i=0 ;i<k ;i++){\\n            if(nums[i]<0)\\n            mp[nums[i]]++;\\n        }\\n        int temp = x, val = 0;\\n        for(auto pa:mp){\\n            temp -= pa.second;\\n            val = pa.first;\\n            if(temp<=0)\\n            break;\\n        }\\n        if(temp<=0)\\n        ans.push_back(val);\\n        else\\n        ans.push_back(0);\\n\\n        int start = 0;\\n        \\n        for(int i=k ;i<nums.size() ;i++){\\n            \\n            if(nums[start]<0){\\n                mp[nums[start]]--;\\n                if(mp[nums[start]] == 0)\\n                mp.erase(nums[start]);\\n            }\\n            start++;\\n\\n            if(nums[i]<0)\\n             mp[nums[i]]++;\\n            \\n            temp = x, val = 0;\\n            for(auto pa:mp){\\n                temp -= pa.second;\\n                val = pa.first;\\n                if(temp<=0)\\n                break;\\n            }\\n            if(temp<=0)\\n            ans.push_back(val);\\n            else\\n            ans.push_back(0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n// [1,2,3,3,3] k = 2, x = 2;\\n// ans = [0, 0, 0]  devil\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        map<int, int> mp;\\n\\n        for(int i=0 ;i<k ;i++){\\n            if(nums[i]<0)\\n            mp[nums[i]]++;\\n        }\\n        int temp = x, val = 0;\\n        for(auto pa:mp){\\n            temp -= pa.second;\\n            val = pa.first;\\n            if(temp<=0)\\n            break;\\n        }\\n        if(temp<=0)\\n        ans.push_back(val);\\n        else\\n        ans.push_back(0);\\n\\n        int start = 0;\\n        \\n        for(int i=k ;i<nums.size() ;i++){\\n            \\n            if(nums[start]<0){\\n                mp[nums[start]]--;\\n                if(mp[nums[start]] == 0)\\n                mp.erase(nums[start]);\\n            }\\n            start++;\\n\\n            if(nums[i]<0)\\n             mp[nums[i]]++;\\n            \\n            temp = x, val = 0;\\n            for(auto pa:mp){\\n                temp -= pa.second;\\n                val = pa.first;\\n                if(temp<=0)\\n                break;\\n            }\\n            if(temp<=0)\\n            ans.push_back(val);\\n            else\\n            ans.push_back(0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837400,
                "title": "python3-2-methods",
                "content": "```\\nfrom sortedcontainers import SortedList \\n\\nclass Solution:\\n    def method1(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * (n - k + 1) # O(n) initialization\\n        nums.append(0)\\n        sliding_window = SortedList(nums[:k]) # O(nlog(n)) initialization\\n        for start in range(len(ans)): # O(n) iterations\\n            ans[start] = min(sliding_window[x - 1], 0)\\n            sliding_window.remove(nums[start]) # O(log(n)) operation\\n            sliding_window.add(nums[start + k]) # O(log(n)) operation\\n        return ans\\n    \\n    def method2(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * (n - k + 1)\\n        \\n        counts = [0] * 101 # O(1) initialization\\n        # init snapshot of counts for first subarray\\n        for val in nums[:k]: # O(n) initialization\\n            counts[val] += 1\\n\\n        # pad nums to avoid index error at end of iteration\\n        nums += [0]\\n        for subarray_start in range(len(ans)): # O(n) iterations\\n            curr_count = 0\\n            for val in range(-50,0): # O(1) iterations\\n                curr_count += counts[val]\\n                if curr_count >= x:\\n                    ans[subarray_start] = val\\n                    break\\n            # update snapshot of counts for next subarray\\n            counts[nums[subarray_start]] -= 1\\n            counts[nums[subarray_start + k]] += 1\\n        return ans\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        return self.method2(nums, k, x)\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList \\n\\nclass Solution:\\n    def method1(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * (n - k + 1) # O(n) initialization\\n        nums.append(0)\\n        sliding_window = SortedList(nums[:k]) # O(nlog(n)) initialization\\n        for start in range(len(ans)): # O(n) iterations\\n            ans[start] = min(sliding_window[x - 1], 0)\\n            sliding_window.remove(nums[start]) # O(log(n)) operation\\n            sliding_window.add(nums[start + k]) # O(log(n)) operation\\n        return ans\\n    \\n    def method2(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * (n - k + 1)\\n        \\n        counts = [0] * 101 # O(1) initialization\\n        # init snapshot of counts for first subarray\\n        for val in nums[:k]: # O(n) initialization\\n            counts[val] += 1\\n\\n        # pad nums to avoid index error at end of iteration\\n        nums += [0]\\n        for subarray_start in range(len(ans)): # O(n) iterations\\n            curr_count = 0\\n            for val in range(-50,0): # O(1) iterations\\n                curr_count += counts[val]\\n                if curr_count >= x:\\n                    ans[subarray_start] = val\\n                    break\\n            # update snapshot of counts for next subarray\\n            counts[nums[subarray_start]] -= 1\\n            counts[nums[subarray_start + k]] += 1\\n        return ans\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        return self.method2(nums, k, x)\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793367,
                "title": "golang-solution-without-sorting",
                "content": "# Code\\n```go\\nfunc getSubarrayBeauty(nums []int, k int, x int) []int {\\n\\tcounter := make(map[int]int, 101)\\n\\tfor i := 0; i < k-1; i++ {\\n\\t\\tcounter[nums[i]]++\\n\\t}\\n\\tbeauty := make([]int, 0, len(nums)-k+1)\\n\\tfor i := k-1; i < len(nums); i++ {\\n\\t\\tcounter[nums[i]]++\\n\\t\\tif i - k >= 0 {\\n\\t\\t\\tcounter[nums[i-k]]--\\n\\t\\t}\\n\\t\\tnegative := 0\\n\\t\\tfor i := -50; i <= 50; i++ {\\n\\t\\t\\tif i >= 0 {\\n\\t\\t\\t\\tbeauty = append(beauty, 0)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tnegative += counter[i]\\n\\t\\t\\tif negative >= x {\\n\\t\\t\\t\\tbeauty = append(beauty, i)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn beauty\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc getSubarrayBeauty(nums []int, k int, x int) []int {\\n\\tcounter := make(map[int]int, 101)\\n\\tfor i := 0; i < k-1; i++ {\\n\\t\\tcounter[nums[i]]++\\n\\t}\\n\\tbeauty := make([]int, 0, len(nums)-k+1)\\n\\tfor i := k-1; i < len(nums); i++ {\\n\\t\\tcounter[nums[i]]++\\n\\t\\tif i - k >= 0 {\\n\\t\\t\\tcounter[nums[i-k]]--\\n\\t\\t}\\n\\t\\tnegative := 0\\n\\t\\tfor i := -50; i <= 50; i++ {\\n\\t\\t\\tif i >= 0 {\\n\\t\\t\\t\\tbeauty = append(beauty, 0)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tnegative += counter[i]\\n\\t\\t\\tif negative >= x {\\n\\t\\t\\t\\tbeauty = append(beauty, i)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn beauty\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781954,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        int i=0,j=0;\\n        multiset<int> st;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] < 0)\\n            {\\n               st.insert(nums[i]);\\n            }\\n            if(i-j+1==k)\\n            {\\n                if(st.size() < x)\\n                { \\n                  ans.push_back(0);\\n                }else\\n                {\\n                    ans.push_back(*next(st.begin(),x-1));\\n                }\\n                auto it=st.find(nums[j]);\\n                if(nums[j] < 0)\\n                {\\n                    st.erase(it);\\n                }\\n                j++;\\n                \\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        int i=0,j=0;\\n        multiset<int> st;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] < 0)\\n            {\\n               st.insert(nums[i]);\\n            }\\n            if(i-j+1==k)\\n            {\\n                if(st.size() < x)\\n                { \\n                  ans.push_back(0);\\n                }else\\n                {\\n                    ans.push_back(*next(st.begin(),x-1));\\n                }\\n                auto it=st.find(nums[j]);\\n                if(nums[j] < 0)\\n                {\\n                    st.erase(it);\\n                }\\n                j++;\\n                \\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771657,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> s;\\n        vector<int> v;\\n        for (int i = 0; i < k; i++) {\\n            s[nums[i]]++;\\n        }\\n        \\n        int i = 0, j = k - 1;\\n        while (j < nums.size()) {\\n            int x2 = x;\\n            for(auto x1:s){\\n                if(x1.first < 0){\\n                    if(x1.second>=x2){\\n                        v.push_back(x1.first);\\n                        break;\\n                    }else{\\n                        x2=x2-x1.second;\\n                    }\\n                }else{\\n                    if(x1.second>=x2){\\n                        v.push_back(0);\\n                        break;\\n                    }else{\\n                        x2=x2-x1.second;\\n                    }\\n                }\\n            }\\n            //if(v.size() <= x)v.push_back(0);\\n            if(s[nums[i]]==1){\\n                s.erase(nums[i]);\\n            }else{\\n                s[nums[i]]--;\\n            }\\n            i++;\\n            j++;\\n            if (j < nums.size()) {\\n                s[nums[j]]++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> s;\\n        vector<int> v;\\n        for (int i = 0; i < k; i++) {\\n            s[nums[i]]++;\\n        }\\n        \\n        int i = 0, j = k - 1;\\n        while (j < nums.size()) {\\n            int x2 = x;\\n            for(auto x1:s){\\n                if(x1.first < 0){\\n                    if(x1.second>=x2){\\n                        v.push_back(x1.first);\\n                        break;\\n                    }else{\\n                        x2=x2-x1.second;\\n                    }\\n                }else{\\n                    if(x1.second>=x2){\\n                        v.push_back(0);\\n                        break;\\n                    }else{\\n                        x2=x2-x1.second;\\n                    }\\n                }\\n            }\\n            //if(v.size() <= x)v.push_back(0);\\n            if(s[nums[i]]==1){\\n                s.erase(nums[i]);\\n            }else{\\n                s[nums[i]]--;\\n            }\\n            i++;\\n            j++;\\n            if (j < nums.size()) {\\n                s[nums[j]]++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770589,
                "title": "easy-solution-using-map-c-not-using-any-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n            int i=0, j=0;\\n        map<int, int> mp; // it store the val key in sorted order\\n            vector<int> ans; // it is use for store ans\\n          while(j<nums.size()){\\n                mp[nums[j]]++;\\n              if(j-i+1<k){  // checking window size if size is less then k\\n                  j++;\\n              }else{  // if window size is equal to k\\n                   int mini=INT_MAX;  // it will store the xth min\\n                  int t=0;  \\n                  for(auto k:mp){\\n                      t+=k.second; // it is storing size\\n                      if(t>=x){ // here t is greter then or equal to x in this time  key is xth val \\n                          mini=k.first;\\n                          break;\\n                      }\\n                  }\\n                  if(mini>0){ // also if xth val is greter then 0 then  we have to made this 0;\\n                      mini=0;\\n                  }\\n                  ans.push_back(mini);\\n                  mp[nums[i]]--; \\n                  if(mp[nums[i]]==0){\\n                      mp.erase(nums[i]);\\n                  }\\n                  i++;\\n                  j++;\\n              }\\n          }\\n          \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n            int i=0, j=0;\\n        map<int, int> mp; // it store the val key in sorted order\\n            vector<int> ans; // it is use for store ans\\n          while(j<nums.size()){\\n                mp[nums[j]]++;\\n              if(j-i+1<k){  // checking window size if size is less then k\\n                  j++;\\n              }else{  // if window size is equal to k\\n                   int mini=INT_MAX;  // it will store the xth min\\n                  int t=0;  \\n                  for(auto k:mp){\\n                      t+=k.second; // it is storing size\\n                      if(t>=x){ // here t is greter then or equal to x in this time  key is xth val \\n                          mini=k.first;\\n                          break;\\n                      }\\n                  }\\n                  if(mini>0){ // also if xth val is greter then 0 then  we have to made this 0;\\n                      mini=0;\\n                  }\\n                  ans.push_back(mini);\\n                  mp[nums[i]]--; \\n                  if(mp[nums[i]]==0){\\n                      mp.erase(nums[i]);\\n                  }\\n                  i++;\\n                  j++;\\n              }\\n          }\\n          \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750844,
                "title": "easy-c-code-sliding-window-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        int n=v.size();\\n        vector<int>count(50,0),ans(n-k+1,0);\\n        for(int i=0;i<k;i++){\\n            if(v[i]<0) count[v[i]+50]++;\\n        }\\n        int u=0;\\n        for(int j=0;j<50;j++){\\n            if(u+count[j]<x) u+=count[j];\\n            else{\\n                ans[0]=j-50;\\n                break;\\n            }\\n        }\\n\\n        for(int i=k;i<n;i++){\\n            if(v[i]<0) count[v[i]+50]++;\\n            if(i-k>=0 and v[i-k]<0) count[v[i-k]+50]--;\\n            int u=0;\\n            for(int j=0;j<50;j++){\\n                if(u+count[j]<x) u+=count[j];\\n                else{\\n                    ans[i-k+1]=j-50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        int n=v.size();\\n        vector<int>count(50,0),ans(n-k+1,0);\\n        for(int i=0;i<k;i++){\\n            if(v[i]<0) count[v[i]+50]++;\\n        }\\n        int u=0;\\n        for(int j=0;j<50;j++){\\n            if(u+count[j]<x) u+=count[j];\\n            else{\\n                ans[0]=j-50;\\n                break;\\n            }\\n        }\\n\\n        for(int i=k;i<n;i++){\\n            if(v[i]<0) count[v[i]+50]++;\\n            if(i-k>=0 and v[i-k]<0) count[v[i-k]+50]--;\\n            int u=0;\\n            for(int j=0;j<50;j++){\\n                if(u+count[j]<x) u+=count[j];\\n                else{\\n                    ans[i-k+1]=j-50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747861,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        negatives = [0]*50\\n        final = []\\n\\n        for i in range(k):\\n            if nums[i]<0:\\n                negatives[nums[i]] += 1\\n\\n        for i in range(k-1, len(nums)):\\n            if i>=k:\\n                if nums[i-k]<0: negatives[nums[i-k]] -= 1\\n                if nums[i]<0: negatives[nums[i]] += 1\\n\\n            remaining = x\\n            for i in range(len(negatives)):\\n                remaining -= negatives[i]\\n                if remaining<=0:\\n                    final.append(-50+i)\\n                    break\\n            \\n            if remaining>0:\\n                final.append(0)\\n        \\n        return final\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        negatives = [0]*50\\n        final = []\\n\\n        for i in range(k):\\n            if nums[i]<0:\\n                negatives[nums[i]] += 1\\n\\n        for i in range(k-1, len(nums)):\\n            if i>=k:\\n                if nums[i-k]<0: negatives[nums[i-k]] -= 1\\n                if nums[i]<0: negatives[nums[i]] += 1\\n\\n            remaining = x\\n            for i in range(len(negatives)):\\n                remaining -= negatives[i]\\n                if remaining<=0:\\n                    final.append(-50+i)\\n                    break\\n            \\n            if remaining>0:\\n                final.append(0)\\n        \\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683403,
                "title": "striver-sliding-window-approach-easy-to-understand-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        //approaches\\n        //1. naive -- O(n^3nlogn)\\n        //2.using sliding window :\\n        // use freq array (-50 to 50)\\n        //update the frequencies for window size \\n\\n        vector<int> freq(101, 0), ans;\\n        int i=0, j=0, n = nums.size();\\n\\n        while(j<n){\\n            // 1. find out the calculations\\n            freq[nums[j]+50]++;\\n            \\n            if(j-i+1 < k) j++;\\n\\n            else if(j-i+1 == k){\\n                //2. ans <- calculations\\n                int cnt = 0, val = 0;\\n                while(cnt!=x){\\n                    for(int i=0; i<101; i++){\\n                        if(freq[i]!=0 && cnt+freq[i] > x){\\n                            cnt = x;\\n                        }\\n                        else if(freq[i]!=0 && cnt+freq[i] <= x){\\n                                cnt = cnt + freq[i];\\n                        }\\n\\n                        if(cnt==x){\\n                            val = i-50;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(val < 0) ans.push_back(val);\\n                else ans.push_back(0);\\n\\n                //3. sliding the window\\n                freq[nums[i]+50]--;\\n                i++, j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        //approaches\\n        //1. naive -- O(n^3nlogn)\\n        //2.using sliding window :\\n        // use freq array (-50 to 50)\\n        //update the frequencies for window size \\n\\n        vector<int> freq(101, 0), ans;\\n        int i=0, j=0, n = nums.size();\\n\\n        while(j<n){\\n            // 1. find out the calculations\\n            freq[nums[j]+50]++;\\n            \\n            if(j-i+1 < k) j++;\\n\\n            else if(j-i+1 == k){\\n                //2. ans <- calculations\\n                int cnt = 0, val = 0;\\n                while(cnt!=x){\\n                    for(int i=0; i<101; i++){\\n                        if(freq[i]!=0 && cnt+freq[i] > x){\\n                            cnt = x;\\n                        }\\n                        else if(freq[i]!=0 && cnt+freq[i] <= x){\\n                                cnt = cnt + freq[i];\\n                        }\\n\\n                        if(cnt==x){\\n                            val = i-50;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(val < 0) ans.push_back(val);\\n                else ans.push_back(0);\\n\\n                //3. sliding the window\\n                freq[nums[i]+50]--;\\n                i++, j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673489,
                "title": "sliding-window-map-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mpp;\\n        vector<int> ans;\\n        int left = 0; int right = k - 1;\\n        for(int i=0;i<k-1;i++) mpp[nums[i]]++;\\n        while( right < nums.size()){\\n            mpp[nums[right]]++;\\n            int xtracker=0;\\n            for(auto it: mpp){\\n               xtracker += it.second;\\n               if(xtracker>=x){\\n                   if(it.first > 0) ans.push_back(0);\\n                   else ans.push_back(it.first);\\n                   break;\\n               }\\n            }\\n            mpp[nums[left]]--;\\n            if(mpp[nums[left]]<=0) mpp.erase(nums[left]);\\n            left++; right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mpp;\\n        vector<int> ans;\\n        int left = 0; int right = k - 1;\\n        for(int i=0;i<k-1;i++) mpp[nums[i]]++;\\n        while( right < nums.size()){\\n            mpp[nums[right]]++;\\n            int xtracker=0;\\n            for(auto it: mpp){\\n               xtracker += it.second;\\n               if(xtracker>=x){\\n                   if(it.first > 0) ans.push_back(0);\\n                   else ans.push_back(it.first);\\n                   break;\\n               }\\n            }\\n            mpp[nums[left]]--;\\n            if(mpp[nums[left]]<=0) mpp.erase(nums[left]);\\n            left++; right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644670,
                "title": "golang-sliding-window-counting-sort",
                "content": "Use sliding window and counting sort to get the xth smallest negative number.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1) since the we only need to store 101 elements\\n\\n# Code\\n```\\nfunc getSubarrayBeauty(nums []int, k int, x int) []int {\\n  // nums[i] is [-50...50] so we can easily do counting sort\\n  // Using an array with an offset so we don\\'t have to use a map\\n  var counts [101]int\\n  left := 0\\n  offset := 50\\n  var res []int\\n  for right := 0; right < len(nums); right++ {\\n    counts[nums[right]+offset]++\\n    if right - left + 1 == k { // subarray with size k is found\\n      // Let\\'s find if ser have xth smallest negative integer\\n      var pos int\\n      var elem int\\n      for i := 0; i < offset; i++ { // only iterate the negative numbers\\n        pos += counts[i]\\n        if pos >= x {\\n          elem = i-offset\\n          break\\n        }\\n      }\\n      // If we can\\'t find a negative element, elem will be 0 which is what we want\\n      res = append(res, elem)\\n      counts[nums[left]+offset]--\\n      left++\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "Sliding Window",
                    "Counting",
                    "Counting Sort"
                ],
                "code": "```\\nfunc getSubarrayBeauty(nums []int, k int, x int) []int {\\n  // nums[i] is [-50...50] so we can easily do counting sort\\n  // Using an array with an offset so we don\\'t have to use a map\\n  var counts [101]int\\n  left := 0\\n  offset := 50\\n  var res []int\\n  for right := 0; right < len(nums); right++ {\\n    counts[nums[right]+offset]++\\n    if right - left + 1 == k { // subarray with size k is found\\n      // Let\\'s find if ser have xth smallest negative integer\\n      var pos int\\n      var elem int\\n      for i := 0; i < offset; i++ { // only iterate the negative numbers\\n        pos += counts[i]\\n        if pos >= x {\\n          elem = i-offset\\n          break\\n        }\\n      }\\n      // If we can\\'t find a negative element, elem will be 0 which is what we want\\n      res = append(res, elem)\\n      counts[nums[left]+offset]--\\n      left++\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3642345,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] arr = new int[101];\\n        int j=0;\\n        int[] ans = new int[nums.length-k+1];\\n        int ind=0;\\n        for(int i=0;i<nums.length;i++){\\n            arr[nums[i]+50]++;\\n            if(i<k-1){\\n                continue;\\n            }\\n\\n// this if is to optimize the code further, code will run without this if also. \\n            if(ind >0 && ans[ind-1]<nums[i] && ans[ind-1] <nums[j-1]){\\n                arr[nums[j++]+50]--;\\n                ans[ind] = ans[ind-1];\\n                ind++;\\n                continue;\\n            }\\n            int count =0;\\n            int si=-1;\\n            while(count<x){\\n                si++;\\n                if(arr[si]!=0){\\n                    count +=arr[si];\\n                }\\n\\n            }\\n            arr[nums[j++]+50]--;\\n            ans[ind++] = (si-50<1)?si-50:0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] arr = new int[101];\\n        int j=0;\\n        int[] ans = new int[nums.length-k+1];\\n        int ind=0;\\n        for(int i=0;i<nums.length;i++){\\n            arr[nums[i]+50]++;\\n            if(i<k-1){\\n                continue;\\n            }\\n\\n// this if is to optimize the code further, code will run without this if also. \\n            if(ind >0 && ans[ind-1]<nums[i] && ans[ind-1] <nums[j-1]){\\n                arr[nums[j++]+50]--;\\n                ans[ind] = ans[ind-1];\\n                ind++;\\n                continue;\\n            }\\n            int count =0;\\n            int si=-1;\\n            while(count<x){\\n                si++;\\n                if(arr[si]!=0){\\n                    count +=arr[si];\\n                }\\n\\n            }\\n            arr[nums[j++]+50]--;\\n            ans[ind++] = (si-50<1)?si-50:0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592646,
                "title": "simple-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] arr= new int[101];\\n        int[] ans=new int[nums.length-k+1];\\n        int l=0;\\n        for(int i=0;i<k;i++){\\n            arr[nums[i]+50]+=1;   \\n        }\\n        int n=x;\\n        for(int i=0;i<101 && n>0;i++){\\n            if(arr[i]==0)\\n             continue;\\n            n-=arr[i];\\n            if(n<=0){\\n                 if(i-50>0)\\n                    ans[l++]=0;\\n                else\\n                    ans[l++]=i-50;\\n            }\\n            \\n        }\\n        int j=k;\\n        int s=0;\\n        while(j<nums.length){\\n            \\n            arr[nums[s++]+50]-=1;\\n            arr[nums[j++]+50]+=1;\\n           \\n            \\n            n=x;\\n            \\n        for(int i=0;i<101 && n>0;i++){\\n            if(arr[i]==0)\\n            continue;\\n            n-=arr[i];\\n            if(n<=0){\\n                if(i-50>0)\\n                    ans[l++]=0;\\n                else\\n                    ans[l++]=i-50;\\n            }\\n            \\n        }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] arr= new int[101];\\n        int[] ans=new int[nums.length-k+1];\\n        int l=0;\\n        for(int i=0;i<k;i++){\\n            arr[nums[i]+50]+=1;   \\n        }\\n        int n=x;\\n        for(int i=0;i<101 && n>0;i++){\\n            if(arr[i]==0)\\n             continue;\\n            n-=arr[i];\\n            if(n<=0){\\n                 if(i-50>0)\\n                    ans[l++]=0;\\n                else\\n                    ans[l++]=i-50;\\n            }\\n            \\n        }\\n        int j=k;\\n        int s=0;\\n        while(j<nums.length){\\n            \\n            arr[nums[s++]+50]-=1;\\n            arr[nums[j++]+50]+=1;\\n           \\n            \\n            n=x;\\n            \\n        for(int i=0;i<101 && n>0;i++){\\n            if(arr[i]==0)\\n            continue;\\n            n-=arr[i];\\n            if(n<=0){\\n                if(i-50>0)\\n                    ans[l++]=0;\\n                else\\n                    ans[l++]=i-50;\\n            }\\n            \\n        }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578713,
                "title": "c-ac-using-maxheap-and-minheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n         vector<int>ans;\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>maxHeap;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>minHeap;\\n        for(int i=0;i<k;i++)\\n        {\\n            \\n                if(maxHeap.size()<x)\\n                maxHeap.push({nums[i],i});\\n                else\\n                {\\n                    if(maxHeap.top().first>nums[i])\\n                    {\\n                        minHeap.push(maxHeap.top());\\n                        maxHeap.pop();\\n                        maxHeap.push({nums[i],i});\\n                    }\\n                    else minHeap.push({nums[i],i});\\n                }\\n\\n        }\\n        if(maxHeap.top().first>=0)\\n        ans.push_back(0);\\n        else\\n        {\\n            ans.push_back(maxHeap.top().first);\\n        }\\n   //     cout<<maxHeap.top().first<<\" \"<<minHeap.top().first<<\\'\\\\n\\';\\n        int i=1,j=k,size=x;\\n        while(j<n)\\n        {\\n            // cout<<\"i=\"<<i<<\" j=\"<<j<<\\'\\\\n\\';\\n            // cout<<maxHeap.top().first<<\" \"<<minHeap.top().first<<\\'\\\\n\\';\\n            if(nums[i-1]<=maxHeap.top().first)\\n            {\\n                 //maxHeap.push({nums[j],j});\\n                 size++;\\n            }\\n                   if(nums[j]<maxHeap.top().first)\\n                {\\n                    maxHeap.push({nums[j],j});\\n                    if(maxHeap.size()>size)\\n                    {\\n                        minHeap.push(maxHeap.top());\\n                        maxHeap.pop();\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    minHeap.push({nums[j],j});\\n                }\\n            while(!maxHeap.empty()&&maxHeap.top().second<i)\\n            {\\n                maxHeap.pop();\\n                size--;\\n            }\\n            while(!minHeap.empty()&&minHeap.top().second<i)\\n            {\\n                minHeap.pop();\\n            }\\n            if(maxHeap.size()<size)\\n            {\\n                maxHeap.push(minHeap.top());\\n                minHeap.pop();\\n            }\\n             if(maxHeap.top().first>=0)\\n             ans.push_back(0);\\n            else\\n            {\\n            ans.push_back(maxHeap.top().first);\\n            }\\n            i++;\\n            j++;\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n         vector<int>ans;\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>maxHeap;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>minHeap;\\n        for(int i=0;i<k;i++)\\n        {\\n            \\n                if(maxHeap.size()<x)\\n                maxHeap.push({nums[i],i});\\n                else\\n                {\\n                    if(maxHeap.top().first>nums[i])\\n                    {\\n                        minHeap.push(maxHeap.top());\\n                        maxHeap.pop();\\n                        maxHeap.push({nums[i],i});\\n                    }\\n                    else minHeap.push({nums[i],i});\\n                }\\n\\n        }\\n        if(maxHeap.top().first>=0)\\n        ans.push_back(0);\\n        else\\n        {\\n            ans.push_back(maxHeap.top().first);\\n        }\\n   //     cout<<maxHeap.top().first<<\" \"<<minHeap.top().first<<\\'\\\\n\\';\\n        int i=1,j=k,size=x;\\n        while(j<n)\\n        {\\n            // cout<<\"i=\"<<i<<\" j=\"<<j<<\\'\\\\n\\';\\n            // cout<<maxHeap.top().first<<\" \"<<minHeap.top().first<<\\'\\\\n\\';\\n            if(nums[i-1]<=maxHeap.top().first)\\n            {\\n                 //maxHeap.push({nums[j],j});\\n                 size++;\\n            }\\n                   if(nums[j]<maxHeap.top().first)\\n                {\\n                    maxHeap.push({nums[j],j});\\n                    if(maxHeap.size()>size)\\n                    {\\n                        minHeap.push(maxHeap.top());\\n                        maxHeap.pop();\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    minHeap.push({nums[j],j});\\n                }\\n            while(!maxHeap.empty()&&maxHeap.top().second<i)\\n            {\\n                maxHeap.pop();\\n                size--;\\n            }\\n            while(!minHeap.empty()&&minHeap.top().second<i)\\n            {\\n                minHeap.pop();\\n            }\\n            if(maxHeap.size()<size)\\n            {\\n                maxHeap.push(minHeap.top());\\n                minHeap.pop();\\n            }\\n             if(maxHeap.top().first>=0)\\n             ans.push_back(0);\\n            else\\n            {\\n            ans.push_back(maxHeap.top().first);\\n            }\\n            i++;\\n            j++;\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3554007,
                "title": "java-frequency-counter-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n\\tpublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n\\t\\tint[] freqCounter = new int[50];\\n\\t\\tint index = 0;\\n\\t\\tint[] results = new int[nums.length - k + 1];\\n\\t\\t\\n\\t\\tfor(int i = 0; i < k; i++) {\\n\\t\\t\\tif(nums[i] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[i] + 50]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tresults[index++] = getXthSmallest(freqCounter, x);\\n\\t\\n\\t\\t\\n\\t\\twhile (index < results.length) {\\n\\t\\t\\tif(nums[index-1] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[index - 1] + 50]--;\\n\\t\\t\\t}\\n\\t\\t\\tif(nums[index + k -1] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[index + k -1] + 50]++;\\n\\t\\t\\t}\\n\\t\\t\\tresults[index++] = getXthSmallest(freqCounter, x);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn results;\\n\\t}\\n\\t\\n\\tprivate int getXthSmallest(int[] freqCounter, int x) {\\n\\t\\tint count = 0;\\n\\t\\tfor(int i = 0; i < 50; i++) {\\n\\t\\t\\tcount += freqCounter[i];\\n\\t\\t\\tif(count >= x) {\\n\\t\\t\\t\\treturn i - 50;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n\\tpublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n\\t\\tint[] freqCounter = new int[50];\\n\\t\\tint index = 0;\\n\\t\\tint[] results = new int[nums.length - k + 1];\\n\\t\\t\\n\\t\\tfor(int i = 0; i < k; i++) {\\n\\t\\t\\tif(nums[i] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[i] + 50]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tresults[index++] = getXthSmallest(freqCounter, x);\\n\\t\\n\\t\\t\\n\\t\\twhile (index < results.length) {\\n\\t\\t\\tif(nums[index-1] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[index - 1] + 50]--;\\n\\t\\t\\t}\\n\\t\\t\\tif(nums[index + k -1] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[index + k -1] + 50]++;\\n\\t\\t\\t}\\n\\t\\t\\tresults[index++] = getXthSmallest(freqCounter, x);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn results;\\n\\t}\\n\\t\\n\\tprivate int getXthSmallest(int[] freqCounter, int x) {\\n\\t\\tint count = 0;\\n\\t\\tfor(int i = 0; i < 50; i++) {\\n\\t\\t\\tcount += freqCounter[i];\\n\\t\\t\\tif(count >= x) {\\n\\t\\t\\t\\treturn i - 50;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539749,
                "title": "slow-python-sliding-window",
                "content": "# Intuition\\nThe numbers are in the range -50, 50.\\nWe can keep track of the frequency of numbers in a sliding window of length k.\\nThen we can loop over values (in increasing order) to see which is the x-th smallest element. Since the possible values are in [-50, 50], we can just loop over the whole range.\\n\\n# Approach\\nCount frequency for the first k elements. Then, for the remaining elements, add one by one and update the frequency. \\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ -- ~100x n, but still O(n). \\n\\n- Space complexity:\\n$$O(1)$$ - we keep frequency for unique elements -- this can be at most 101 values.\\n\\n# Improvements\\nCan replace the `defaultdict` with an `OrderedDict` or use an ordered set to keep track of elements present in the range.\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        from collections import defaultdict\\n        counts = defaultdict(int)\\n        res = []\\n\\n        for i in range(k):\\n            counts[nums[i]] += 1\\n        \\n        crt_cnt = 0\\n        \\n        for j in range(-50, 51):\\n            if counts[j] > 0:\\n                if crt_cnt < x:\\n                    crt_cnt += counts[j]\\n                if crt_cnt >= x:\\n                    res.append(min(0, j))\\n                    break\\n        \\n        for i in range(k, len(nums)):\\n            counts[nums[i - k]] -= 1\\n            counts[nums[i]] += 1\\n            crt_cnt = 0\\n            for j in range(-50, 51):\\n                if counts[j] > 0:\\n                    if crt_cnt < x:\\n                        crt_cnt += counts[j]\\n                    if crt_cnt >= x:\\n                        res.append(min(0, j))\\n                        break\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        from collections import defaultdict\\n        counts = defaultdict(int)\\n        res = []\\n\\n        for i in range(k):\\n            counts[nums[i]] += 1\\n        \\n        crt_cnt = 0\\n        \\n        for j in range(-50, 51):\\n            if counts[j] > 0:\\n                if crt_cnt < x:\\n                    crt_cnt += counts[j]\\n                if crt_cnt >= x:\\n                    res.append(min(0, j))\\n                    break\\n        \\n        for i in range(k, len(nums)):\\n            counts[nums[i - k]] -= 1\\n            counts[nums[i]] += 1\\n            crt_cnt = 0\\n            for j in range(-50, 51):\\n                if counts[j] > 0:\\n                    if crt_cnt < x:\\n                        crt_cnt += counts[j]\\n                    if crt_cnt >= x:\\n                        res.append(min(0, j))\\n                        break\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538695,
                "title": "java-treemap-slow-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < k; i++) {\\n            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);\\n            else map.put(nums[i], 1);\\n        }\\n        int count = 0, c = 0;\\n        int[] res = new int[nums.length - k + 1];\\n        for (int key : map.keySet()) {\\n            count += map.get(key);\\n            if (count >= x) {\\n                res[c] = Math.min(key, 0);\\n                break;\\n            }\\n        }\\n        for (int i = k; i < nums.length; i++) {\\n            int kk = map.get(nums[c]);\\n            if (kk == 0) map.remove(nums[c]);\\n            else map.put(nums[c], kk - 1);\\n            c++;\\n            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);\\n            else map.put(nums[i], 1);\\n            count = 0;\\n            for (int key : map.keySet()) {\\n                count += map.get(key);\\n                if (count >= x) {\\n                    res[c] = Math.min(key, 0);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < k; i++) {\\n            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);\\n            else map.put(nums[i], 1);\\n        }\\n        int count = 0, c = 0;\\n        int[] res = new int[nums.length - k + 1];\\n        for (int key : map.keySet()) {\\n            count += map.get(key);\\n            if (count >= x) {\\n                res[c] = Math.min(key, 0);\\n                break;\\n            }\\n        }\\n        for (int i = k; i < nums.length; i++) {\\n            int kk = map.get(nums[c]);\\n            if (kk == 0) map.remove(nums[c]);\\n            else map.put(nums[c], kk - 1);\\n            c++;\\n            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);\\n            else map.put(nums[i], 1);\\n            count = 0;\\n            for (int key : map.keySet()) {\\n                count += map.get(key);\\n                if (count >= x) {\\n                    res[c] = Math.min(key, 0);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535654,
                "title": "java-c-python-just-a-solution-explained",
                "content": "# TL;DR\\n``` java []\\nclass Solution {\\n    private static final int MAX_VAL = 50;\\n    private static final int MIN_VAL = -50;\\n    private static final int OFFSET = -MIN_VAL;\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        var res = new int[nums.length - k + 1];\\n        var counts = new int[MAX_VAL - MIN_VAL + 2];\\n\\n        int min = MAX_VAL;\\n        int max = MIN_VAL;\\n        for (int i = 0; i < k - 1; i++) {\\n            counts[nums[i] + OFFSET]++;\\n            min = Math.min(min, nums[i]);\\n            max = Math.max(max, nums[i]);\\n        }\\n\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int next = nums[i + k - 1];\\n            counts[next + OFFSET]++;\\n            max = Math.max(max, next);\\n            min = Math.min(min, next);\\n            int xMin = 0;\\n            int count = 0;\\n            for (int j = min - MIN_VAL; j <= max + OFFSET; j++) {\\n                count += counts[j];\\n                if (count >= x) {\\n                    xMin = j - OFFSET;\\n                    break;\\n                }\\n            }\\n            res[i] = Math.min(xMin, 0);\\n            counts[nums[i] + OFFSET]--;\\n            if (counts[nums[i] + OFFSET] == 0) {\\n                if (nums[i] == max) {\\n                    max = MAX_VAL;\\n                }\\n                if (nums[i] == min) {\\n                    min = MIN_VAL;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        const int MAX_VAL = 50;\\n        const int MIN_VAL = -50;\\n        const int OFFSET = -MIN_VAL;\\n        int n = nums.size();\\n        vector<int> res(n - k + 1);\\n        vector<int> counts(MAX_VAL - MIN_VAL + 2, 0);\\n        \\n        int min = MAX_VAL;\\n        int max = MIN_VAL;\\n        for (int i = 0; i < k - 1; i++) {\\n            counts[nums[i] + OFFSET]++;\\n            min = std::min(min, nums[i]);\\n            max = std::max(max, nums[i]);\\n        }\\n        \\n        for (int i = 0; i < n - k + 1; i++) {\\n            int next = nums[i + k - 1];\\n            counts[next + OFFSET]++;\\n            max = std::max(max, next);\\n            min = std::min(min, next);\\n            int xMin = 0;\\n            int count = 0;\\n            for (int j = min - MIN_VAL; j <= max + OFFSET; j++) {\\n                count += counts[j];\\n                if (count >= x) {\\n                    xMin = j - OFFSET;\\n                    break;\\n                }\\n            }\\n            res[i] = std::min(xMin, 0);\\n            counts[nums[i] + OFFSET]--;\\n            if (counts[nums[i] + OFFSET] == 0) {\\n                if (nums[i] == max) {\\n                    max = MAX_VAL;\\n                }\\n                if (nums[i] == min) {\\n                    min = MIN_VAL;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        MAX_VAL = 50\\n        MIN_VAL = -50\\n        OFFSET = -MIN_VAL\\n        n = len(nums)\\n        res = [0] * (n - k + 1)\\n        counts = [0] * (MAX_VAL - MIN_VAL + 2)\\n        \\n        min_val = MAX_VAL\\n        max_val = MIN_VAL\\n        for i in range(k - 1):\\n            counts[nums[i] + OFFSET] += 1\\n            min_val = min(min_val, nums[i])\\n            max_val = max(max_val, nums[i])\\n        \\n        for i in range(n - k + 1):\\n            next_val = nums[i + k - 1]\\n            counts[next_val + OFFSET] += 1\\n            max_val = max(max_val, next_val)\\n            min_val = min(min_val, next_val)\\n            xMin = 0\\n            count = 0\\n            for j in range(min_val - MIN_VAL, max_val + OFFSET + 1):\\n                count += counts[j]\\n                if count >= x:\\n                    xMin = j - OFFSET\\n                    break\\n            res[i] = min(xMin, 0)\\n            counts[nums[i] + OFFSET] -= 1\\n            if counts[nums[i] + OFFSET] == 0:\\n                if nums[i] == max_val:\\n                    max_val = MAX_VAL\\n                if nums[i] == min_val:\\n                    min_val = MIN_VAL\\n        return res\\n```\\n---\\n#### \\u26A0\\uFE0F Please upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n# Intuition\\n\\nThe problem asks us to find the beauty of each subarray of size k in the input array. The beauty of a subarray is defined as the xth smallest negative integer in the subarray if there are at least x negative integers, or 0 otherwise. \\n\\nA straightforward approach to this problem would be to sort each subarray and select the xth smallest negative integer. However, this approach is not efficient due to the repeated sorting operation, which would result in a time complexity of O(n*k*log(k)), where n is the length of the array and k is the size of the subarray.\\n\\nTo optimize this, we can use a sliding window approach and maintain a frequency count of the integers in the current subarray. We also keep track of the minimum and maximum values in the current subarray. \\n\\n# Approach\\n\\nThe optimized approach is to use a sliding window of size `k`. As we slide the window, we keep track of the frequency of numbers in the current window using a frequency array `counts`. For each new window, we add the new number to the frequency array and remove the number that is no longer in the window.\\n\\nWe keep track of the minimum and maximum numbers in the current window. This helps in searching for the xth smallest negative number in the frequency array. \\n\\nAs we slide the window, we keep adding the xth smallest negative number in the window to our result array `res`.\\n\\n# Complexity Analysis\\n\\n- Time complexity: The time complexity of this approach is $$O(n)$$, where $$n$$ is the number of elements in the array. We iterate over the array once, and for each iteration, we perform constant time operations such as updating the frequency array, searching for the xth smallest negative number, and updating the result array.\\n\\n- Space complexity: The space complexity is $$O(n)$$ for the `res` array, and $$O(1)$$ for the `counts` array as it has a fixed size based on the problem constraints (range of the numbers in the array). Therefore, the total space complexity is $$O(n)$$.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "``` java []\\nclass Solution {\\n    private static final int MAX_VAL = 50;\\n    private static final int MIN_VAL = -50;\\n    private static final int OFFSET = -MIN_VAL;\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        var res = new int[nums.length - k + 1];\\n        var counts = new int[MAX_VAL - MIN_VAL + 2];\\n\\n        int min = MAX_VAL;\\n        int max = MIN_VAL;\\n        for (int i = 0; i < k - 1; i++) {\\n            counts[nums[i] + OFFSET]++;\\n            min = Math.min(min, nums[i]);\\n            max = Math.max(max, nums[i]);\\n        }\\n\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int next = nums[i + k - 1];\\n            counts[next + OFFSET]++;\\n            max = Math.max(max, next);\\n            min = Math.min(min, next);\\n            int xMin = 0;\\n            int count = 0;\\n            for (int j = min - MIN_VAL; j <= max + OFFSET; j++) {\\n                count += counts[j];\\n                if (count >= x) {\\n                    xMin = j - OFFSET;\\n                    break;\\n                }\\n            }\\n            res[i] = Math.min(xMin, 0);\\n            counts[nums[i] + OFFSET]--;\\n            if (counts[nums[i] + OFFSET] == 0) {\\n                if (nums[i] == max) {\\n                    max = MAX_VAL;\\n                }\\n                if (nums[i] == min) {\\n                    min = MIN_VAL;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        const int MAX_VAL = 50;\\n        const int MIN_VAL = -50;\\n        const int OFFSET = -MIN_VAL;\\n        int n = nums.size();\\n        vector<int> res(n - k + 1);\\n        vector<int> counts(MAX_VAL - MIN_VAL + 2, 0);\\n        \\n        int min = MAX_VAL;\\n        int max = MIN_VAL;\\n        for (int i = 0; i < k - 1; i++) {\\n            counts[nums[i] + OFFSET]++;\\n            min = std::min(min, nums[i]);\\n            max = std::max(max, nums[i]);\\n        }\\n        \\n        for (int i = 0; i < n - k + 1; i++) {\\n            int next = nums[i + k - 1];\\n            counts[next + OFFSET]++;\\n            max = std::max(max, next);\\n            min = std::min(min, next);\\n            int xMin = 0;\\n            int count = 0;\\n            for (int j = min - MIN_VAL; j <= max + OFFSET; j++) {\\n                count += counts[j];\\n                if (count >= x) {\\n                    xMin = j - OFFSET;\\n                    break;\\n                }\\n            }\\n            res[i] = std::min(xMin, 0);\\n            counts[nums[i] + OFFSET]--;\\n            if (counts[nums[i] + OFFSET] == 0) {\\n                if (nums[i] == max) {\\n                    max = MAX_VAL;\\n                }\\n                if (nums[i] == min) {\\n                    min = MIN_VAL;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        MAX_VAL = 50\\n        MIN_VAL = -50\\n        OFFSET = -MIN_VAL\\n        n = len(nums)\\n        res = [0] * (n - k + 1)\\n        counts = [0] * (MAX_VAL - MIN_VAL + 2)\\n        \\n        min_val = MAX_VAL\\n        max_val = MIN_VAL\\n        for i in range(k - 1):\\n            counts[nums[i] + OFFSET] += 1\\n            min_val = min(min_val, nums[i])\\n            max_val = max(max_val, nums[i])\\n        \\n        for i in range(n - k + 1):\\n            next_val = nums[i + k - 1]\\n            counts[next_val + OFFSET] += 1\\n            max_val = max(max_val, next_val)\\n            min_val = min(min_val, next_val)\\n            xMin = 0\\n            count = 0\\n            for j in range(min_val - MIN_VAL, max_val + OFFSET + 1):\\n                count += counts[j]\\n                if count >= x:\\n                    xMin = j - OFFSET\\n                    break\\n            res[i] = min(xMin, 0)\\n            counts[nums[i] + OFFSET] -= 1\\n            if counts[nums[i] + OFFSET] == 0:\\n                if nums[i] == max_val:\\n                    max_val = MAX_VAL\\n                if nums[i] == min_val:\\n                    min_val = MIN_VAL\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517791,
                "title": "python-counting-sort-o-n-50",
                "content": "As the value range is only `[-50, 50]`, or to be more specific actual range that we work with only `[-50, -1]` we can use instead of `nlogn` sorting `counting sort` with `O(50)`.\\n\\nInstead of counting every time `k-size window` we can use `sliding window of fixed size k`.\\n\\n2641ms ~99.4%\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        res = []\\n        freq = [0] * 51\\n        neg_nums_count = 0\\n        start = 0\\n        for end in range(len(nums)):\\n            if nums[end] < 0:\\n                neg_nums_count += 1\\n                freq[nums[end]] += 1\\n\\n            if end >= k - 1:\\n                pos = 0\\n                current = x\\n                if x > neg_nums_count:\\n                    pos = 51\\n                else:\\n                    while freq[pos] < current:\\n                        current -= freq[pos]\\n                        pos += 1\\n                res.append(pos - 51)\\n\\n                if nums[start] < 0:\\n                    neg_nums_count -= 1\\n                    freq[nums[start]] -= 1\\n                start += 1\\n        \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        res = []\\n        freq = [0] * 51\\n        neg_nums_count = 0\\n        start = 0\\n        for end in range(len(nums)):\\n            if nums[end] < 0:\\n                neg_nums_count += 1\\n                freq[nums[end]] += 1\\n\\n            if end >= k - 1:\\n                pos = 0\\n                current = x\\n                if x > neg_nums_count:\\n                    pos = 51\\n                else:\\n                    while freq[pos] < current:\\n                        current -= freq[pos]\\n                        pos += 1\\n                res.append(pos - 51)\\n\\n                if nums[start] < 0:\\n                    neg_nums_count -= 1\\n                    freq[nums[start]] -= 1\\n                start += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506204,
                "title": "easy-cpp-solution-time-complexity-explained-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->the value for nums are given from -50 to 50 think upon this and write a code for their count\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The function aims to find subarrays of length k in nums that have a \"beauty\" value of at least x. A subarray\\'s beauty is defined as the absolute difference between its maximum and minimum elements.\\n\\nThe implementation uses a sliding window approach to iterate over all subarrays of length k in nums. At each iteration, it maintains a map mp that tracks the frequency of each element in the current subarray.\\n\\nThe while loop iterates from j=0 to j=nums.size()-1. At each iteration, if the subarray length is less than k, the frequency of the element at index j is incremented in the map mp, and j is incremented. If the subarray length is equal to k, the function checks the beauty value of the current subarray by iterating over all elements in the map mp and calculating their contribution to the beauty value. The iteration continues until the sum of the frequencies of the elements encountered so far is greater than or equal to x. If the beauty value of the subarray is greater than or equal to x, the minimum element in the subarray is added to the vector v.\\n\\nAfter checking the beauty value of the subarray, the implementation removes the first element of the current subarray by decrementing its frequency in the map mp. If the frequency of the element becomes zero, it is removed from the map. The indices i and j are incremented to move the sliding window forward.\\n\\nFinally, when the while loop completes, the function returns the vector v containing the minimum elements of all subarrays of length k with a beauty value of at least x.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->The while loop in the implementation iterates over each element in the input vector nums exactly once, so the time complexity of the loop is O(n).\\n\\nInside the while loop, the implementation uses a map to keep track of the frequency of each element in the current subarray. The map operations, such as insertion, deletion, and finding an element, have a time complexity of O(log(n)) on average. In the worst case, when the map is unbalanced, the time complexity of these operations can be O(n). Since the map operations are performed for each element in nums, the overall time complexity of the map operations is O(n*log(n)) on average and O(n^2) in the worst case.\\n\\nTherefore, the overall time complexity of the implementation is dominated by the time complexity of the while loop, which is O(n). Thus, the time complexity of the implementation is O(n*log(n)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The implementation uses a map to keep track of the frequency of each element in the current subarray, so the space complexity of the map is at most O(k). This is because the map will store at most k distinct elements, one for each position in the sliding window.\\n\\nIn addition to the map, the implementation uses a vector to store the minimum elements of the subarrays with beauty value at least x. The length of this vector is at most n/k, since there can be at most n/k subarrays of length k in the input vector nums that the function checks. Therefore, the space complexity of the vector is O(n/k).\\n\\nSince O(k) is less than or equal to O(n/k), the overall space complexity of the implementation is O(n/k).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ios_base::sync_with_stdio(false);\\n        map<int,int>mp;\\n        int i=0; int j=0;\\n        vector<int>v;\\n        while(j<nums.size()){\\n            if(j-i+1<k){\\n                mp[nums[j]]++;\\n                j++;\\n            }\\n            else{\\n                mp[nums[j]]++;\\n                int count=0;\\n               for(auto it:mp){\\n                   count+=it.second;\\n                   if(count>=x){\\n                       if(it.first<=0){\\n                          v.push_back(it.first);  \\n                       }\\n                      else{\\n                          v.push_back(0);\\n                      }\\n                       break;\\n                   }\\n               } \\n               mp[nums[i]]--;\\n               if(mp[nums[i]]==0) {\\n                   mp.erase(nums[i]);\\n               }\\n               i++;\\n               j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ios_base::sync_with_stdio(false);\\n        map<int,int>mp;\\n        int i=0; int j=0;\\n        vector<int>v;\\n        while(j<nums.size()){\\n            if(j-i+1<k){\\n                mp[nums[j]]++;\\n                j++;\\n            }\\n            else{\\n                mp[nums[j]]++;\\n                int count=0;\\n               for(auto it:mp){\\n                   count+=it.second;\\n                   if(count>=x){\\n                       if(it.first<=0){\\n                          v.push_back(it.first);  \\n                       }\\n                      else{\\n                          v.push_back(0);\\n                      }\\n                       break;\\n                   }\\n               } \\n               mp[nums[i]]--;\\n               if(mp[nums[i]]==0) {\\n                   mp.erase(nums[i]);\\n               }\\n               i++;\\n               j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497251,
                "title": "easy-to-understand-sliding-window-ordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nk) \\n-  n-> for iterating over nums array\\n-  k-> for iterating over map\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mp;\\n        int i=0;\\n        for(;i<k-1;i++)\\n          mp[nums[i]]++;\\n\\n            vector<int> ans;\\n          for(;i<nums.size();i++){\\n              mp[nums[i]]++;\\n              int count=0,beauty=0;\\n              for(auto [ele,f]:mp){\\n                  count+=f;\\n                  if(count>=x){ beauty=ele; break;}\\n              }\\n              if(beauty<0)\\n              ans.push_back(beauty);\\n              else \\n              ans.push_back(0);\\n\\n              mp[nums[i-k+1]]--;\\n              if(mp[nums[i-k+1]]==0) mp.erase(nums[i-k+1]);\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mp;\\n        int i=0;\\n        for(;i<k-1;i++)\\n          mp[nums[i]]++;\\n\\n            vector<int> ans;\\n          for(;i<nums.size();i++){\\n              mp[nums[i]]++;\\n              int count=0,beauty=0;\\n              for(auto [ele,f]:mp){\\n                  count+=f;\\n                  if(count>=x){ beauty=ele; break;}\\n              }\\n              if(beauty<0)\\n              ans.push_back(beauty);\\n              else \\n              ans.push_back(0);\\n\\n              mp[nums[i-k+1]]--;\\n              if(mp[nums[i-k+1]]==0) mp.erase(nums[i-k+1]);\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488084,
                "title": "c-easy-solution-frequency-vector",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        vector<int> fre(101);\\n        int i=0,j=0,n = nums.size();\\n        while(j<n)\\n        {\\n            if(nums[j]<0)\\n            {\\n                fre[nums[j]+50]++;\\n            }\\n            if(j-i+1==k)\\n            {\\n                int cnt = 0;\\n                for(int s=0;s<101;s++)\\n                {\\n                    cnt+=fre[s];\\n                    if(cnt>=x)\\n                    {\\n                        ans.push_back(s-50);\\n                        break;\\n                    }\\n                }\\n                if(cnt<x)\\n                ans.push_back(0);\\n                fre[nums[i]+50]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        vector<int> fre(101);\\n        int i=0,j=0,n = nums.size();\\n        while(j<n)\\n        {\\n            if(nums[j]<0)\\n            {\\n                fre[nums[j]+50]++;\\n            }\\n            if(j-i+1==k)\\n            {\\n                int cnt = 0;\\n                for(int s=0;s<101;s++)\\n                {\\n                    cnt+=fre[s];\\n                    if(cnt>=x)\\n                    {\\n                        ans.push_back(s-50);\\n                        break;\\n                    }\\n                }\\n                if(cnt<x)\\n                ans.push_back(0);\\n                fre[nums[i]+50]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486317,
                "title": "99-84-tc-easy-python-solution-using-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        def solve(negative):\\n            if(negative < x):\\n                return 0\\n            temp = x\\n            for i in range(50):\\n                if(temp <= count[i]):\\n                    return i-50\\n                temp -= count[i]\\n                \\n        neg = 0\\n        count = [0] * 50\\n        for i in range(k):\\n            if(nums[i] < 0):\\n                count[nums[i]] += 1\\n                neg += 1\\n        ans = [solve(neg)]\\n        for i in range(k, len(nums)):\\n            if(nums[i] < 0):\\n                count[nums[i]] += 1\\n                neg += 1\\n            if(nums[i-k] < 0):\\n                count[nums[i-k]] -= 1\\n                neg -= 1\\n            ans.append(solve(neg))\\n        return ans\\n            \\n        \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        def solve(negative):\\n            if(negative < x):\\n                return 0\\n            temp = x\\n            for i in range(50):\\n                if(temp <= count[i]):\\n                    return i-50\\n                temp -= count[i]\\n                \\n        neg = 0\\n        count = [0] * 50\\n        for i in range(k):\\n            if(nums[i] < 0):\\n                count[nums[i]] += 1\\n                neg += 1\\n        ans = [solve(neg)]\\n        for i in range(k, len(nums)):\\n            if(nums[i] < 0):\\n                count[nums[i]] += 1\\n                neg += 1\\n            if(nums[i-k] < 0):\\n                count[nums[i-k]] -= 1\\n                neg -= 1\\n            ans.append(solve(neg))\\n        return ans\\n            \\n        \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485287,
                "title": "easy-java-solution-array-sliding-window",
                "content": "```\\nTC = O(N*101)~= O(N)\\nSC = O(101) ~= O(1)\\n\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n          \\n        int freq[] = new int[101];\\n        int N = nums.length;\\n        int len = N - k + 1;\\n        int ans[] = new int[len];\\n        \\n        for(int i=0; i<k; i++) {\\n            freq[nums[i]+50]++;\\n        }\\n        int index =0; \\n\\n        int count = 0;\\n        for(int i=0; i<101; i++) {\\n            count += freq[i];\\n            if(count>=x) {\\n                ans[index++] = i-50 < 0 ? i-50 : 0;\\n                break;\\n            }\\n        }\\n        for(int i=k; i<N; i++) {\\n            freq[nums[i-k]+50]--;\\n            freq[nums[i]+50]++;\\n            count = 0;\\n            for(int j=0; j<101; j++) {\\n                count += freq[j];\\n                if(count>=x) {\\n                    ans[index++] = j-50 < 0 ? j-50 : 0;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nTC = O(N*101)~= O(N)\\nSC = O(101) ~= O(1)\\n\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n          \\n        int freq[] = new int[101];\\n        int N = nums.length;\\n        int len = N - k + 1;\\n        int ans[] = new int[len];\\n        \\n        for(int i=0; i<k; i++) {\\n            freq[nums[i]+50]++;\\n        }\\n        int index =0; \\n\\n        int count = 0;\\n        for(int i=0; i<101; i++) {\\n            count += freq[i];\\n            if(count>=x) {\\n                ans[index++] = i-50 < 0 ? i-50 : 0;\\n                break;\\n            }\\n        }\\n        for(int i=k; i<N; i++) {\\n            freq[nums[i-k]+50]--;\\n            freq[nums[i]+50]++;\\n            count = 0;\\n            for(int j=0; j<101; j++) {\\n                count += freq[j];\\n                if(count>=x) {\\n                    ans[index++] = j-50 < 0 ? j-50 : 0;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480168,
                "title": "java-only-array-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int t[] = new int[101];\\n  int X;\\n\\n  private int findX(){\\n    for(int i = 0, c = 0; i != 50; ++i)\\n      if( (c+=t[i]) >= X) return i - 50;\\n    return 0;\\n  }\\n\\n  public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int ans[] = new int[nums.length - k + 1];\\n    X = x;\\n    \\n    for(int i = 0; i != k; ++i) ++t[nums[i]+50];\\n    ans[0] = findX();\\n\\n    for(int i = k, j = 1; i != nums.length; ++i, ++j){\\n      ++t[nums[i]+50];\\n      --t[nums[j-1]+50];\\n      ans[j] = findX();\\n    }\\n\\n    return ans;  \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  int t[] = new int[101];\\n  int X;\\n\\n  private int findX(){\\n    for(int i = 0, c = 0; i != 50; ++i)\\n      if( (c+=t[i]) >= X) return i - 50;\\n    return 0;\\n  }\\n\\n  public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int ans[] = new int[nums.length - k + 1];\\n    X = x;\\n    \\n    for(int i = 0; i != k; ++i) ++t[nums[i]+50];\\n    ans[0] = findX();\\n\\n    for(int i = k, j = 1; i != nums.length; ++i, ++j){\\n      ++t[nums[i]+50];\\n      --t[nums[j-1]+50];\\n      ans[j] = findX();\\n    }\\n\\n    return ans;  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478045,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_subarray_beauty(nums: Vec<i32>, k: i32, x: i32) -> Vec<i32> {\\n        let mut ans = vec![];\\n        let mut mp = std::collections::BTreeMap::new();\\n        for i in 0..nums.len() {\\n            *mp.entry(nums[i]).or_insert(0) += 1;\\n            if i >= k as usize - 1 {\\n                if i >= k as usize {\\n                    *mp.get_mut(&nums[i - k as usize]).unwrap() -= 1;\\n                }\\n                let mut sum = 0;\\n                let mut t = 0;\\n                for (key, value) in mp.iter() {\\n                    sum += value;\\n                    if sum >= x {\\n                        t = if *key < 0 { *key } else { 0 };\\n                        break;\\n                    }\\n                }\\n                ans.push(t);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_subarray_beauty(nums: Vec<i32>, k: i32, x: i32) -> Vec<i32> {\\n        let mut ans = vec![];\\n        let mut mp = std::collections::BTreeMap::new();\\n        for i in 0..nums.len() {\\n            *mp.entry(nums[i]).or_insert(0) += 1;\\n            if i >= k as usize - 1 {\\n                if i >= k as usize {\\n                    *mp.get_mut(&nums[i - k as usize]).unwrap() -= 1;\\n                }\\n                let mut sum = 0;\\n                let mut t = 0;\\n                for (key, value) in mp.iter() {\\n                    sum += value;\\n                    if sum >= x {\\n                        t = if *key < 0 { *key } else { 0 };\\n                        break;\\n                    }\\n                }\\n                ans.push(t);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477265,
                "title": "c-solution-using-multiset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use multisets to store the elements in sorted order. One multiset(here m1) will store the first x elements and the other(here m2) will store the next k-x elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we slide the window, we will check if the element to be removed is present in the first multiset or the second and remove it from there.\\nThe new element will be added to the other multiset. Suppose we are removing the element from the first multiset then the new element will be added to the second multiset and vice-versa.\\nNow we will adjust the multisets accordingly such that the first multiset contains x elements and the other contains k-x elements.\\nNow, we check if the last element of first multiset is negative or positive and push it to the answer vector accordingly.\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int>m1,m2;\\n        int i=0,j=0;\\n        for(;i<k;i++)\\n            m1.insert(nums[i]);\\n        while(m1.size()>x)\\n        {\\n            m2.insert(*m1.rbegin());\\n            m1.erase(m1.find(*m1.rbegin()));\\n        }\\n        vector<int>res;\\n        if(*m1.rbegin()>=0)\\n            res.push_back(0);\\n        else\\n            res.push_back(*m1.rbegin());\\n        for(;i<nums.size();i++,j++)\\n        {\\n            if(m1.find(nums[j])!=m1.end())\\n            {\\n                m1.erase(m1.find(nums[j]));\\n                m2.insert(nums[i]);\\n                m1.insert(*m2.begin());\\n                m2.erase(m2.begin());\\n            }\\n            else\\n            {\\n                m2.erase(m2.find(nums[j]));\\n                m1.insert(nums[i]);\\n                m2.insert(*m1.rbegin());\\n                m1.erase(m1.find(*m1.rbegin()));\\n            }\\n            if(*m1.rbegin()>=0)\\n                res.push_back(0);\\n            else\\n                res.push_back(*m1.rbegin());\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int>m1,m2;\\n        int i=0,j=0;\\n        for(;i<k;i++)\\n            m1.insert(nums[i]);\\n        while(m1.size()>x)\\n        {\\n            m2.insert(*m1.rbegin());\\n            m1.erase(m1.find(*m1.rbegin()));\\n        }\\n        vector<int>res;\\n        if(*m1.rbegin()>=0)\\n            res.push_back(0);\\n        else\\n            res.push_back(*m1.rbegin());\\n        for(;i<nums.size();i++,j++)\\n        {\\n            if(m1.find(nums[j])!=m1.end())\\n            {\\n                m1.erase(m1.find(nums[j]));\\n                m2.insert(nums[i]);\\n                m1.insert(*m2.begin());\\n                m2.erase(m2.begin());\\n            }\\n            else\\n            {\\n                m2.erase(m2.find(nums[j]));\\n                m1.insert(nums[i]);\\n                m2.insert(*m1.rbegin());\\n                m1.erase(m1.find(*m1.rbegin()));\\n            }\\n            if(*m1.rbegin()>=0)\\n                res.push_back(0);\\n            else\\n                res.push_back(*m1.rbegin());\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471955,
                "title": "c-o-n-log-k-using-ordered-multiset-but-code-is-awful-to-read",
                "content": "I didn\\'t notice the constraint of the range of values, so I didn\\'t think to use counting sort. By the time I noticed the constraint, I had already most of the code for this solution, which is O(n log k) and uses a multiset to store the window. \\n\\nWe insert and delete elements from the window as it slides through the input, and store an iterator to the xth element of the multiset. When processing the next element, we may need to shift the iterator for the xth element left or right based on its relation to the inserted and deleted element. That\\'s why there\\'s so many cases to check. Although this took me a while to do, I learned a lot about the std::multiset which I hadn\\'t known prior.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> res(n-k+1);\\n        multiset<int> s;\\n        for (int i = 0; i < k; i ++){\\n            s.insert(nums[i]);\\n        }\\n        \\n        auto it = s.begin();\\n        for (int i = 1; i < x; i++){  \\n            it++;\\n        }\\n        \\n        int xth = *it;\\n        res[0] = (xth < 0 ) ? xth : 0;\\n\\n        for (int i = k; i < n; i++){\\n            int ins = nums[i];\\n            int del = nums[i-k];\\n\\n            if (ins == del){\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n            }else if (xth > ins && xth > del || xth < ins && xth < del){\\n                s.insert(ins);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth > ins && xth < del){\\n                s.insert(ins);\\n                it = prev(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth < ins && xth > del){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth < ins && xth == del){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }  \\n            }else if (xth > ins && xth == del){\\n                //hardest part\\n                s.insert(ins);\\n                auto itr = s.lower_bound(del);\\n                if (itr == it){\\n                    it = prev(it);\\n                    s.erase(itr);\\n                }else{\\n                    s.erase(itr);\\n                }\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;         \\n            }else if (xth == ins && xth > del ){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth == ins && xth < del){\\n                s.insert(ins);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> res(n-k+1);\\n        multiset<int> s;\\n        for (int i = 0; i < k; i ++){\\n            s.insert(nums[i]);\\n        }\\n        \\n        auto it = s.begin();\\n        for (int i = 1; i < x; i++){  \\n            it++;\\n        }\\n        \\n        int xth = *it;\\n        res[0] = (xth < 0 ) ? xth : 0;\\n\\n        for (int i = k; i < n; i++){\\n            int ins = nums[i];\\n            int del = nums[i-k];\\n\\n            if (ins == del){\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n            }else if (xth > ins && xth > del || xth < ins && xth < del){\\n                s.insert(ins);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth > ins && xth < del){\\n                s.insert(ins);\\n                it = prev(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth < ins && xth > del){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth < ins && xth == del){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }  \\n            }else if (xth > ins && xth == del){\\n                //hardest part\\n                s.insert(ins);\\n                auto itr = s.lower_bound(del);\\n                if (itr == it){\\n                    it = prev(it);\\n                    s.erase(itr);\\n                }else{\\n                    s.erase(itr);\\n                }\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;         \\n            }else if (xth == ins && xth > del ){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth == ins && xth < del){\\n                s.insert(ins);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471317,
                "title": "java",
                "content": "The main trick is to understand that -50 <= nums[i] <= 50, before wasting time on any creative ideas.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int negs=0,n=nums.length;\\n        int [] sol = new int [n-k+1], frqs = new int[101]; //-50 - +50\\n        for (int i=0;i<k;i++){\\n            frqs[nums[i]+50]++;\\n            if (nums[i]<0) negs++;\\n        }\\n        for (int i=0;i<n-k+1;i++){\\n            sol[i] = (negs<x)?0:findXth(frqs,x);\\n            if (i==n-k) break;\\n            frqs[nums[i]+50]--;\\n            if (nums[i]<0) negs--;\\n            frqs[nums[i+k]+50]++;\\n            if (nums[i+k]<0) negs++;\\n        }\\n        return sol;\\n    }\\n\\n    public int findXth(int frqs[],int x){\\n        int counter=0;\\n        for (int i=0;i<51;i++){\\n            counter+=frqs[i];\\n            if (counter>=x) return i-50;\\n        }\\n        return 777;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int negs=0,n=nums.length;\\n        int [] sol = new int [n-k+1], frqs = new int[101]; //-50 - +50\\n        for (int i=0;i<k;i++){\\n            frqs[nums[i]+50]++;\\n            if (nums[i]<0) negs++;\\n        }\\n        for (int i=0;i<n-k+1;i++){\\n            sol[i] = (negs<x)?0:findXth(frqs,x);\\n            if (i==n-k) break;\\n            frqs[nums[i]+50]--;\\n            if (nums[i]<0) negs--;\\n            frqs[nums[i+k]+50]++;\\n            if (nums[i+k]<0) negs++;\\n        }\\n        return sol;\\n    }\\n\\n    public int findXth(int frqs[],int x){\\n        int counter=0;\\n        for (int i=0;i<51;i++){\\n            counter+=frqs[i];\\n            if (counter>=x) return i-50;\\n        }\\n        return 777;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467658,
                "title": "max-heap-min-heap",
                "content": "# Intuition\\nIf we remove the ridiculous -50..50 condition from the task (or just didn\\'t notice it, haha), we would not be able to use the counting-based solutions, so we need something smarter.\\nThe idea is to use max heap for the x smaller numbers, and min heap for the larger numbers and \"transfuse\" numbers between them. When we remove the 1st element from the sliding array, we will either remove it from the maxHeap (and put there the smallest of the larger numbers from the minHeap); or we just remove it from the maxHeap.\\n\\n# Approach\\nI tried to explain everything in details in comments in the code\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {\\n        // we will store x smallest numbers in the maxHeap, so that the element on teh top is the x-th smallest\\n        val maxHeap = PriorityQueue<Int>(reverseOrder())\\n        // we will store the rest of the elements (the bigger ones) in the minHeap\\n        val minHeap = PriorityQueue<Int>()\\n        for (i in 0 until k) {\\n            maxHeap.offer(nums[i])\\n        }\\n        var result  = IntArray(nums.size - k + 1)\\n        for (i in 0 .. nums.size-k) {\\n            // remove the bigger elements from the maxHeap and put them in the minHeap\\n            while (maxHeap.size > x) {\\n                minHeap.offer(maxHeap.poll())\\n            }\\n            // get the x-th smallest element from the top of the maxHeap\\n            result[i] = Math.min(0, maxHeap.peek())\\n            // now we need to remove the 1st element of our sliding array from the heaps\\n            // if this element is less or equal than the top of the maxHeap - it means it participates in the x-size set of minimum elements\\n            // this means we need to remove it from the maxHeap, and put there the smallest number from the remaining elements (which we store in the minHeap)\\n            // otherwise this 1st element is one of the bigger elements, so we just remove it from the minHeap\\n            if (nums[i] <= maxHeap.peek()) {\\n                maxHeap.remove(nums[i])\\n                // if x == k, the minHeap will always be empty\\n                if (minHeap.size > 0) maxHeap.offer(minHeap.poll())\\n            } else minHeap.remove(nums[i])\\n            \\n            // and finally we are adding the next element to the maxHeap\\n            if (k+i < nums.size) maxHeap.offer(nums[k+i])\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {\\n        // we will store x smallest numbers in the maxHeap, so that the element on teh top is the x-th smallest\\n        val maxHeap = PriorityQueue<Int>(reverseOrder())\\n        // we will store the rest of the elements (the bigger ones) in the minHeap\\n        val minHeap = PriorityQueue<Int>()\\n        for (i in 0 until k) {\\n            maxHeap.offer(nums[i])\\n        }\\n        var result  = IntArray(nums.size - k + 1)\\n        for (i in 0 .. nums.size-k) {\\n            // remove the bigger elements from the maxHeap and put them in the minHeap\\n            while (maxHeap.size > x) {\\n                minHeap.offer(maxHeap.poll())\\n            }\\n            // get the x-th smallest element from the top of the maxHeap\\n            result[i] = Math.min(0, maxHeap.peek())\\n            // now we need to remove the 1st element of our sliding array from the heaps\\n            // if this element is less or equal than the top of the maxHeap - it means it participates in the x-size set of minimum elements\\n            // this means we need to remove it from the maxHeap, and put there the smallest number from the remaining elements (which we store in the minHeap)\\n            // otherwise this 1st element is one of the bigger elements, so we just remove it from the minHeap\\n            if (nums[i] <= maxHeap.peek()) {\\n                maxHeap.remove(nums[i])\\n                // if x == k, the minHeap will always be empty\\n                if (minHeap.size > 0) maxHeap.offer(minHeap.poll())\\n            } else minHeap.remove(nums[i])\\n            \\n            // and finally we are adding the next element to the maxHeap\\n            if (k+i < nums.size) maxHeap.offer(nums[k+i])\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466590,
                "title": "java-26ms-96-and-clean-code",
                "content": "# Approach\\n1. Use an int[101] window to mark & count the nums[-50..50]. Just add 50 to the num (-50 + 50) -> 0, (4 +50) -> 54\\n2. Create the initial window with the nums[0..k-1].\\n3. While adding them, keep track of the negative count. If num < 0, increase negative count.\\nWhen quering a given interval, if negativeCount < x, then return 0 immediately.\\n4. Finding the xth negative. \\n    - As mentioned on #3, if negativeCount < x, return 0\\n    - Else loop from 0 to < 50 (representing the nums -50, -1) and do a prefix sum.\\n    - Stop when prefixSum >= x. Return index - 50 (an index 4 will represent the number -46 becuase -46+50 = 4;\\n5. When moving to next element, just remove the left number of the window (nums[i - k]). Also, adjust the negative count. (decrease if the eliminated number is negative). \\n\\n# Complexity\\n- Time complexity:$$O((n-k) * 50)$$ - worst case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(102)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] negativeCount = {0};\\n        int[] window = createWindow(nums, k, negativeCount);\\n        int[] beauty = new int[nums.length - k + 1];\\n        for (int i = k; i < nums.length; i++) {\\n            beauty[i - k] = findXthSmallestInteger(window, x, negativeCount);\\n            removePreviousElement(window, nums, i - k, negativeCount);\\n            addNextElement(window, nums, i, negativeCount);\\n        }\\n        beauty[nums.length - k] = findXthSmallestInteger(window, x, negativeCount);\\n        return beauty;\\n    }\\n\\n    private void removePreviousElement(int[] window, int[] nums, int index, int[] negativeCount) {\\n        if (nums[index] < 0) {\\n            negativeCount[0]--;\\n        }\\n        window[nums[index] + 50]--;\\n    }\\n\\n    private void addNextElement(int[] window, int[] nums, int index, int[] negativeCount) {\\n        if (nums[index] < 0) {\\n            negativeCount[0]++;\\n        }\\n        window[nums[index] + 50]++;\\n    }\\n\\n    private int findXthSmallestInteger(int[] window, int x, int[] negativeCount) {\\n        if (negativeCount[0] < x) {\\n            return 0;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < 50; i++) {\\n            if (window[i] > 0) {\\n                count += window[i];\\n                if (count >= x) {\\n                   return index - 50;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] createWindow(int[] nums, int size, int[] negativeCount) {\\n        int[] window = new int[101];\\n        while(--size >= 0) {\\n            window[nums[size] + 50]++;\\n            if (nums[size] < 0) {\\n                negativeCount[0]++;\\n            }\\n        }\\n        return window;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] negativeCount = {0};\\n        int[] window = createWindow(nums, k, negativeCount);\\n        int[] beauty = new int[nums.length - k + 1];\\n        for (int i = k; i < nums.length; i++) {\\n            beauty[i - k] = findXthSmallestInteger(window, x, negativeCount);\\n            removePreviousElement(window, nums, i - k, negativeCount);\\n            addNextElement(window, nums, i, negativeCount);\\n        }\\n        beauty[nums.length - k] = findXthSmallestInteger(window, x, negativeCount);\\n        return beauty;\\n    }\\n\\n    private void removePreviousElement(int[] window, int[] nums, int index, int[] negativeCount) {\\n        if (nums[index] < 0) {\\n            negativeCount[0]--;\\n        }\\n        window[nums[index] + 50]--;\\n    }\\n\\n    private void addNextElement(int[] window, int[] nums, int index, int[] negativeCount) {\\n        if (nums[index] < 0) {\\n            negativeCount[0]++;\\n        }\\n        window[nums[index] + 50]++;\\n    }\\n\\n    private int findXthSmallestInteger(int[] window, int x, int[] negativeCount) {\\n        if (negativeCount[0] < x) {\\n            return 0;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < 50; i++) {\\n            if (window[i] > 0) {\\n                count += window[i];\\n                if (count >= x) {\\n                   return index - 50;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] createWindow(int[] nums, int size, int[] negativeCount) {\\n        int[] window = new int[101];\\n        while(--size >= 0) {\\n            window[nums[size] + 50]++;\\n            if (nums[size] < 0) {\\n                negativeCount[0]++;\\n            }\\n        }\\n        return window;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466479,
                "title": "java-93-faster-simple-counting-array",
                "content": "**Approach:**\\n* We are provided with a range of `-50 <= nums[i] <= 50 ` , so we can create a count array of size 50 to store only negative number as we only need negative numbers.\\n* Now as we have a fix range of 50, we iterate we iterate over 50 elements to calculate xth negative number with TC: `O(50)` for each operation we do this using frequency by adding frequency to a local variable and checking if it becomes greator or equals to x.\\n* In each iteration we slide over array and increase the frequency of each negative no and remove the element from start if negative.\\n\\n\\n**Tme Complexity:**\\n```\\nTC: O(N)\\nSC: O(1)\\n```\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n          int[] count = new int[50];\\n          int[] sol = new int[nums.length-k+1];\\n          int i=0;\\n          for(;i<k;i++){\\n              if(nums[i]<0)count[nums[i]+50]++;\\n          }\\n          int l=0,val=0;\\n          for(int q=0;q<50;q++){\\n                  l+=count[q];\\n                  if(l>=x){\\n                      val=q-50;\\n                      break;\\n                  }\\n          }\\n          sol[0]=val;\\n          int idx=1;\\n          for(;i<nums.length;i++){\\n              if(nums[idx-1]<0)count[nums[idx-1]+50]--;\\n              if(nums[i]<0)count[nums[i]+50]++;\\n              int loc=0,v=0;\\n              for(int q=0;q<50;q++){\\n                  loc+=count[q];\\n                  if(loc>=x){\\n                      v=q-50;\\n                      break;\\n                  }\\n              }\\n              sol[idx++]=v;\\n          }\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nTC: O(N)\\nSC: O(1)\\n```\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n          int[] count = new int[50];\\n          int[] sol = new int[nums.length-k+1];\\n          int i=0;\\n          for(;i<k;i++){\\n              if(nums[i]<0)count[nums[i]+50]++;\\n          }\\n          int l=0,val=0;\\n          for(int q=0;q<50;q++){\\n                  l+=count[q];\\n                  if(l>=x){\\n                      val=q-50;\\n                      break;\\n                  }\\n          }\\n          sol[0]=val;\\n          int idx=1;\\n          for(;i<nums.length;i++){\\n              if(nums[idx-1]<0)count[nums[idx-1]+50]--;\\n              if(nums[i]<0)count[nums[i]+50]++;\\n              int loc=0,v=0;\\n              for(int q=0;q<50;q++){\\n                  loc+=count[q];\\n                  if(loc>=x){\\n                      v=q-50;\\n                      break;\\n                  }\\n              }\\n              sol[idx++]=v;\\n          }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465886,
                "title": "very-easy-solution-c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nused set and map \\nset is used because in it searching insertion and deletion is done in O(logN) time\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int i=0 , j=0;\\n        int n = nums.size();\\n        map<int , int>mpp;\\n        set<int>st;\\n        vector<int>ans;\\n        \\n        while(j<n)\\n        {\\n            mpp[nums[j]]++;\\n            st.insert(nums[j]);\\n            \\n            if(j-i+1<k)j++;\\n            \\n            else if(j-i+1==k)\\n            {\\n                int cnt=0;\\n\\n                for(auto ele : st)\\n                {\\n                    cnt+=mpp[ele];\\n                    if(cnt>=x)\\n                    {\\n                        if(ele<0)ans.push_back(ele);\\n                        else ans.push_back(0);\\n                        break;\\n                    }\\n                }\\n\\n                if(mpp[nums[i]]==1)\\n                {\\n                    st.erase(nums[i]);\\n                }\\n                mpp[nums[i]]--;\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int i=0 , j=0;\\n        int n = nums.size();\\n        map<int , int>mpp;\\n        set<int>st;\\n        vector<int>ans;\\n        \\n        while(j<n)\\n        {\\n            mpp[nums[j]]++;\\n            st.insert(nums[j]);\\n            \\n            if(j-i+1<k)j++;\\n            \\n            else if(j-i+1==k)\\n            {\\n                int cnt=0;\\n\\n                for(auto ele : st)\\n                {\\n                    cnt+=mpp[ele];\\n                    if(cnt>=x)\\n                    {\\n                        if(ele<0)ans.push_back(ele);\\n                        else ans.push_back(0);\\n                        break;\\n                    }\\n                }\\n\\n                if(mpp[nums[i]]==1)\\n                {\\n                    st.erase(nums[i]);\\n                }\\n                mpp[nums[i]]--;\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463444,
                "title": "python3-hashtable-and-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def find_x_smallest(self, count_map, x):\\n        count = 0\\n        for num in range(-50, 0, 1):\\n            if count_map.get(num, 0) != 0:\\n                count += count_map[num]\\n                if count >= x:\\n                    return num\\n                \\n        return 0\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        start = 0\\n        neg = 0\\n        count_map = {}\\n    \\n        ans = []\\n            \\n        for end in range(len(nums)):\\n            # Remove contribution of start element if its negative.\\n            if start > len(nums)-k+1:\\n                break\\n            if nums[end] < 0:\\n                neg += 1\\n                count_map[nums[end]] = count_map.get(nums[end], 0) + 1\\n            \\n            window_size = end - start + 1\\n            if window_size == k:\\n                temp = 0\\n                if neg > 0 and neg >= x: \\n                    temp = self.find_x_smallest(count_map, x)\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    count_map[nums[start]] -= 1\\n                start += 1\\n                ans.append(temp)\\n            \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def find_x_smallest(self, count_map, x):\\n        count = 0\\n        for num in range(-50, 0, 1):\\n            if count_map.get(num, 0) != 0:\\n                count += count_map[num]\\n                if count >= x:\\n                    return num\\n                \\n        return 0\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        start = 0\\n        neg = 0\\n        count_map = {}\\n    \\n        ans = []\\n            \\n        for end in range(len(nums)):\\n            # Remove contribution of start element if its negative.\\n            if start > len(nums)-k+1:\\n                break\\n            if nums[end] < 0:\\n                neg += 1\\n                count_map[nums[end]] = count_map.get(nums[end], 0) + 1\\n            \\n            window_size = end - start + 1\\n            if window_size == k:\\n                temp = 0\\n                if neg > 0 and neg >= x: \\n                    temp = self.find_x_smallest(count_map, x)\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    count_map[nums[start]] -= 1\\n                start += 1\\n                ans.append(temp)\\n            \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462116,
                "title": "sliding-window-treemap",
                "content": "# Code\\n```\\nclass Solution {\\n    private int getXthSmallest(Map<Integer, Integer> map, int x) {\\n        int count = 0;\\n\\n        for (var entry: map.entrySet()) {\\n            count += entry.getValue();\\n\\n            if (count >= x) {\\n                return entry.getKey();\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n     public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int j = 0;\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        var frequency = new TreeMap<Integer, Integer>();\\n\\n        for (int i = 0; i < k; i++) {\\n            if (nums[i] < 0) {\\n                frequency.merge(nums[i], 1, Integer::sum);\\n            }\\n        }\\n\\n        ans[j++] = getXthSmallest(frequency, x);\\n\\n        for (int i = k; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                frequency.merge(nums[i], 1, Integer::sum);\\n            }\\n\\n            if (nums[i - k] < 0) {\\n                frequency.merge(nums[i - k], -1, Integer::sum);\\n            }\\n\\n            ans[j++] = getXthSmallest(frequency, x);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int getXthSmallest(Map<Integer, Integer> map, int x) {\\n        int count = 0;\\n\\n        for (var entry: map.entrySet()) {\\n            count += entry.getValue();\\n\\n            if (count >= x) {\\n                return entry.getKey();\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n     public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int j = 0;\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        var frequency = new TreeMap<Integer, Integer>();\\n\\n        for (int i = 0; i < k; i++) {\\n            if (nums[i] < 0) {\\n                frequency.merge(nums[i], 1, Integer::sum);\\n            }\\n        }\\n\\n        ans[j++] = getXthSmallest(frequency, x);\\n\\n        for (int i = k; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                frequency.merge(nums[i], 1, Integer::sum);\\n            }\\n\\n            if (nums[i - k] < 0) {\\n                frequency.merge(nums[i - k], -1, Integer::sum);\\n            }\\n\\n            ans[j++] = getXthSmallest(frequency, x);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461681,
                "title": "easy-beginner-friendly-fixed-sized-sliding-window-problem-well-commented-cpp",
                "content": "# Intuition + Approach\\n1. Converted the problem into Fixed Size Sliding Window Problem. \\n2. Used a Map to store the negative numbers, such that we can easily extract the xth smallest element at any point of time.\\n3. At any point the map would only contain the negative numbers present in the window\\n4. Once window size K is reached the challeneging point is to get into the xth position in the map.\\n5. However, while travelling to xth position in map, we need to take into account of the frequency.\\n6. Ran a for loop to take into the number of times we are iterating. \\n\\n# Complexity\\n- Time complexity:\\nO(n*x)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n  {\\n    // to store -ve numbers in order for quick extraction of xth smallest element\\n    map<int, int> umap;\\n    vector<int> ans;\\n    int i = 0, j = 0, flag = 1, c = 0, no = 0;\\n    // sliding window starts\\n    while (j < nums.size())\\n    {\\n      // calculation - insert only negative numbers in map [contains]\\n      if (nums[j] < 0)\\n        umap[nums[j]]++;\\n      // if window size k isn\\'t reached\\n      if (j - i + 1 < k)\\n        j++;\\n      // if window size k is reached\\n      else if (j - i + 1 == k)\\n      {\\n        // this loop is run to get into xth smallest element in map\\n        for (auto it = umap.begin(); it != umap.end(); it++)\\n        {\\n          c += it->second; // to take into account of the number of times it apperared, as if it\\'s present in map means the window has this element of these many occurences\\n          if (c >= x)\\n          { // while adding to it->second, c might exceed x , so if c!=x && c>x doesn\\'t mean xth smallest element isn\\'t present.\\n            no = it->first;\\n            flag = 0;\\n            break;\\n          }\\n        }\\n        c = 0;\\n        if (flag == 0)\\n          ans.push_back(no);\\n        else\\n          ans.push_back(0); // flag!=0 indicates xth smallest element wasn\\'t found so return 0.\\n        flag = 1;\\n        // slide the window\\n        // as k is reached, so delete 1 element from start and update in map accordingly\\n        auto index = umap.find(nums[i]);\\n        if (index != umap.end())\\n        {\\n          if (umap[nums[i]] == 1)\\n            umap.erase(nums[i]);\\n          else\\n            umap[nums[i]]--;\\n        }\\n        i++;\\n        j++;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n  {\\n    // to store -ve numbers in order for quick extraction of xth smallest element\\n    map<int, int> umap;\\n    vector<int> ans;\\n    int i = 0, j = 0, flag = 1, c = 0, no = 0;\\n    // sliding window starts\\n    while (j < nums.size())\\n    {\\n      // calculation - insert only negative numbers in map [contains]\\n      if (nums[j] < 0)\\n        umap[nums[j]]++;\\n      // if window size k isn\\'t reached\\n      if (j - i + 1 < k)\\n        j++;\\n      // if window size k is reached\\n      else if (j - i + 1 == k)\\n      {\\n        // this loop is run to get into xth smallest element in map\\n        for (auto it = umap.begin(); it != umap.end(); it++)\\n        {\\n          c += it->second; // to take into account of the number of times it apperared, as if it\\'s present in map means the window has this element of these many occurences\\n          if (c >= x)\\n          { // while adding to it->second, c might exceed x , so if c!=x && c>x doesn\\'t mean xth smallest element isn\\'t present.\\n            no = it->first;\\n            flag = 0;\\n            break;\\n          }\\n        }\\n        c = 0;\\n        if (flag == 0)\\n          ans.push_back(no);\\n        else\\n          ans.push_back(0); // flag!=0 indicates xth smallest element wasn\\'t found so return 0.\\n        flag = 1;\\n        // slide the window\\n        // as k is reached, so delete 1 element from start and update in map accordingly\\n        auto index = umap.find(nums[i]);\\n        if (index != umap.end())\\n        {\\n          if (umap[nums[i]] == 1)\\n            umap.erase(nums[i]);\\n          else\\n            umap[nums[i]]--;\\n        }\\n        i++;\\n        j++;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460988,
                "title": "a-few-solutions",
                "content": "Let `cnt` be \"buckets\" which store the count of values `1..50` inclusive which represent each corresponding negative value `x` of the input array `A`.\\n\\nUse a sliding window `i..j` inclusive of size `K` along with the function `f()` to perform a linear scan of the \"buckets\" to find and return the target `T`<sup>th</sup> smallest negative value (if it exists).\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun getSubarrayBeauty(A: IntArray, K: Int, T: Int): IntArray {\\n        var ans = mutableListOf<Int>()\\n        var cnt = IntArray(50 + 1) { 0 }\\n        fun f(): Int {\\n            var t = 0\\n            for (x in 50 downTo 1) {\\n                t += cnt[x]\\n                if (T <= t)\\n                    return -x\\n            }\\n            return 0\\n        }\\n        for (j in 0 until A.size) {\\n            if (A[j] < 0) ++cnt[-A[j]]\\n            var i = j - K + 1\\n            if (0 <= i) {\\n                ans.add(f())\\n                if (A[i] < 0) --cnt[-A[i]]\\n            }\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet getSubarrayBeauty = (A, K, T, cnt = Array(50 + 1).fill(0), ans = []) => {\\n    let f = () => {\\n        let t = 0;\\n        for (let x = 50; 0 < x; --x) {\\n            t += cnt[x];\\n            if (T <= t)\\n                return -x;\\n        }\\n        return 0;\\n    };\\n    for (let j = 0; j < A.length; ++j) {\\n        if (A[j] < 0) ++cnt[-A[j]];\\n        let i = j - K + 1;\\n        if (0 <= i) {\\n            ans.push(f());\\n            if (A[i] < 0) --cnt[-A[i]];\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, A: List[int], K: int, T: int) -> List[int]:\\n        ans = []\\n        cnt = [0] * (50 + 1)\\n        def f():\\n            t = 0\\n            for x in range(50, 0, -1):\\n                t += cnt[x]\\n                if T <= t:\\n                    return -x\\n            return 0\\n        for j in range(len(A)):\\n            if A[j] < 0: cnt[-A[j]] += 1\\n            i = j - K + 1\\n            if 0 <= i:\\n                ans.append(f())\\n                if A[i] < 0: cnt[-A[i]] -= 1\\n        return ans\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn get_subarray_beauty(A: VI, K: i32, T: i32) -> VI {\\n        let mut ans = vec![];\\n        let mut cnt = vec![0; 50 + 1];\\n        fn f(A: &VI, T: i32, cnt: &VI) -> i32 {\\n            let mut t = 0;\\n            for x in (1..=50).rev() {\\n                t += cnt[x];\\n                if T <= t {\\n                    return -(x as i32);\\n                }\\n            }\\n            0\\n        }\\n        for j in 0..A.len() {\\n            if A[j] < 0 { cnt[-A[j] as usize] += 1; }\\n            let i = j as i32 - K + 1;\\n            if 0 <= i {\\n                ans.push(f(&A, T, &cnt));\\n                let i = i as usize;\\n                if A[i] < 0 { cnt[-A[i] as usize] -= 1; }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI getSubarrayBeauty(VI& A, int K, int T, VI ans = {}) {\\n        VI cnt(50 + 1);\\n        auto f = [&]() {\\n            auto t = 0;\\n            for (auto x{ 50 }; 0 < x; --x) {\\n                t += cnt[x];\\n                if (T <= t)\\n                    return -x;\\n            }\\n            return 0;\\n        };\\n        for (auto j{ 0 }; j < A.size(); ++j) {\\n            if (A[j] < 0) ++cnt[-A[j]];\\n            auto i = j - K + 1;\\n            if (0 <= i) {\\n                ans.push_back(f());\\n                if (A[i] < 0) --cnt[-A[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun getSubarrayBeauty(A: IntArray, K: Int, T: Int): IntArray {\\n        var ans = mutableListOf<Int>()\\n        var cnt = IntArray(50 + 1) { 0 }\\n        fun f(): Int {\\n            var t = 0\\n            for (x in 50 downTo 1) {\\n                t += cnt[x]\\n                if (T <= t)\\n                    return -x\\n            }\\n            return 0\\n        }\\n        for (j in 0 until A.size) {\\n            if (A[j] < 0) ++cnt[-A[j]]\\n            var i = j - K + 1\\n            if (0 <= i) {\\n                ans.add(f())\\n                if (A[i] < 0) --cnt[-A[i]]\\n            }\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nlet getSubarrayBeauty = (A, K, T, cnt = Array(50 + 1).fill(0), ans = []) => {\\n    let f = () => {\\n        let t = 0;\\n        for (let x = 50; 0 < x; --x) {\\n            t += cnt[x];\\n            if (T <= t)\\n                return -x;\\n        }\\n        return 0;\\n    };\\n    for (let j = 0; j < A.length; ++j) {\\n        if (A[j] < 0) ++cnt[-A[j]];\\n        let i = j - K + 1;\\n        if (0 <= i) {\\n            ans.push(f());\\n            if (A[i] < 0) --cnt[-A[i]];\\n        }\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, A: List[int], K: int, T: int) -> List[int]:\\n        ans = []\\n        cnt = [0] * (50 + 1)\\n        def f():\\n            t = 0\\n            for x in range(50, 0, -1):\\n                t += cnt[x]\\n                if T <= t:\\n                    return -x\\n            return 0\\n        for j in range(len(A)):\\n            if A[j] < 0: cnt[-A[j]] += 1\\n            i = j - K + 1\\n            if 0 <= i:\\n                ans.append(f())\\n                if A[i] < 0: cnt[-A[i]] -= 1\\n        return ans\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn get_subarray_beauty(A: VI, K: i32, T: i32) -> VI {\\n        let mut ans = vec![];\\n        let mut cnt = vec![0; 50 + 1];\\n        fn f(A: &VI, T: i32, cnt: &VI) -> i32 {\\n            let mut t = 0;\\n            for x in (1..=50).rev() {\\n                t += cnt[x];\\n                if T <= t {\\n                    return -(x as i32);\\n                }\\n            }\\n            0\\n        }\\n        for j in 0..A.len() {\\n            if A[j] < 0 { cnt[-A[j] as usize] += 1; }\\n            let i = j as i32 - K + 1;\\n            if 0 <= i {\\n                ans.push(f(&A, T, &cnt));\\n                let i = i as usize;\\n                if A[i] < 0 { cnt[-A[i] as usize] -= 1; }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI getSubarrayBeauty(VI& A, int K, int T, VI ans = {}) {\\n        VI cnt(50 + 1);\\n        auto f = [&]() {\\n            auto t = 0;\\n            for (auto x{ 50 }; 0 < x; --x) {\\n                t += cnt[x];\\n                if (T <= t)\\n                    return -x;\\n            }\\n            return 0;\\n        };\\n        for (auto j{ 0 }; j < A.size(); ++j) {\\n            if (A[j] < 0) ++cnt[-A[j]];\\n            auto i = j - K + 1;\\n            if (0 <= i) {\\n                ans.push_back(f());\\n                if (A[i] < 0) --cnt[-A[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460189,
                "title": "a-short-and-general-multiset-solution",
                "content": "# Intuition\\nMultiset with pointer to xth largest element in the sliding window set maintained\\n\\n# Approach\\nMultiset with pointer to xth largest element in the sliding window set maintained\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(k)) which is independent of nums[i]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        x = x-1;\\n        \\n        vector<int> temp(nums.begin(), nums.begin()+k);\\n        sort(temp.begin(), temp.end());\\n        vector<int> ans = {temp[x]};\\n        int prev = temp[x];\\n        \\n        multiset<int> s;\\n        for(int i = 0; i<k; i++) s.insert(nums[i]);\\n        auto ptr = s.begin();\\n        for(int i = 0; i<x; i++) ptr++;\\n        \\n        \\n        for(int i = k; i<n; i++){\\n            s.insert(nums[i]);\\n            if(nums[i] < prev) ptr--;\\n            prev = *ptr;\\n            if(nums[i-k] <= prev) ptr++;\\n            s.erase(s.find(nums[i-k]));\\n            prev = *ptr;\\n            ans.push_back(prev);\\n        }\\n        for(auto &x : ans) if(x>0) x = 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        x = x-1;\\n        \\n        vector<int> temp(nums.begin(), nums.begin()+k);\\n        sort(temp.begin(), temp.end());\\n        vector<int> ans = {temp[x]};\\n        int prev = temp[x];\\n        \\n        multiset<int> s;\\n        for(int i = 0; i<k; i++) s.insert(nums[i]);\\n        auto ptr = s.begin();\\n        for(int i = 0; i<x; i++) ptr++;\\n        \\n        \\n        for(int i = k; i<n; i++){\\n            s.insert(nums[i]);\\n            if(nums[i] < prev) ptr--;\\n            prev = *ptr;\\n            if(nums[i-k] <= prev) ptr++;\\n            s.erase(s.find(nums[i-k]));\\n            prev = *ptr;\\n            ans.push_back(prev);\\n        }\\n        for(auto &x : ans) if(x>0) x = 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459761,
                "title": "java-simple-solution-greedy-sliding-window-tc-o-n-sc-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int cnt = 0;\\n        int[] freq = new int[60];\\n        for(int i = 0;i < k;i++){\\n            if(nums[i] < 0){\\n                cnt++;\\n                freq[Math.abs(nums[i])]++;\\n            }\\n        }\\n        if(cnt >= x){\\n            int csf = 0;\\n            for(int i = 50;i >= 0;i--){\\n                if(freq[i] + csf >= x){\\n                    ans[0] = -i;\\n                    break;\\n                }\\n                csf += freq[i];\\n            }\\n        }\\n        int start = 0;\\n        int end = k;\\n\\n        while(end < n){\\n            if(nums[end] < 0){\\n                cnt++;\\n                freq[Math.abs(nums[end])]++;\\n            }\\n\\n            if(nums[start] < 0){\\n                cnt--;\\n                freq[Math.abs(nums[start])]--;\\n            }\\n\\n            if(cnt >= x){\\n                int csf = 0;\\n                for(int i = 50;i >= 0;i--){\\n                    if(freq[i] + csf >= x){\\n                        ans[start + 1] = -i;\\n                        break;\\n                    }\\n                    csf += freq[i];\\n                }\\n            }\\n            start++;\\n            end++;\\n        }    \\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int cnt = 0;\\n        int[] freq = new int[60];\\n        for(int i = 0;i < k;i++){\\n            if(nums[i] < 0){\\n                cnt++;\\n                freq[Math.abs(nums[i])]++;\\n            }\\n        }\\n        if(cnt >= x){\\n            int csf = 0;\\n            for(int i = 50;i >= 0;i--){\\n                if(freq[i] + csf >= x){\\n                    ans[0] = -i;\\n                    break;\\n                }\\n                csf += freq[i];\\n            }\\n        }\\n        int start = 0;\\n        int end = k;\\n\\n        while(end < n){\\n            if(nums[end] < 0){\\n                cnt++;\\n                freq[Math.abs(nums[end])]++;\\n            }\\n\\n            if(nums[start] < 0){\\n                cnt--;\\n                freq[Math.abs(nums[start])]--;\\n            }\\n\\n            if(cnt >= x){\\n                int csf = 0;\\n                for(int i = 50;i >= 0;i--){\\n                    if(freq[i] + csf >= x){\\n                        ans[start + 1] = -i;\\n                        break;\\n                    }\\n                    csf += freq[i];\\n                }\\n            }\\n            start++;\\n            end++;\\n        }    \\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459566,
                "title": "sliding-window-concept-done-with-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        \\n        for(int i = 0; i < k; i++)\\n          tmap.put(nums[i], tmap.getOrDefault(nums[i], 0) + 1);\\n        ans[0] = getMin(tmap, x);\\n\\n        for(int i = k; i < n; i++){\\n            tmap.put(nums[i], tmap.getOrDefault(nums[i], 0) + 1);\\n            tmap.put(nums[i - k], tmap.getOrDefault(nums[i - k], 0) - 1);\\n\\n            if(tmap.get(nums[i - k]) == 0)\\n               tmap.remove(nums[i - k]);\\n\\n            ans[i - k + 1] = getMin(tmap, x);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    public int getMin(TreeMap<Integer, Integer> tmap, int x){\\n        int sma = 0;\\n        for(Integer val : tmap.keySet()){\\n            if(val < 0) \\n               sma += tmap.get(val);\\n            else return 0;\\n\\n            if(sma >= x) \\n               return val;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        \\n        for(int i = 0; i < k; i++)\\n          tmap.put(nums[i], tmap.getOrDefault(nums[i], 0) + 1);\\n        ans[0] = getMin(tmap, x);\\n\\n        for(int i = k; i < n; i++){\\n            tmap.put(nums[i], tmap.getOrDefault(nums[i], 0) + 1);\\n            tmap.put(nums[i - k], tmap.getOrDefault(nums[i - k], 0) - 1);\\n\\n            if(tmap.get(nums[i - k]) == 0)\\n               tmap.remove(nums[i - k]);\\n\\n            ans[i - k + 1] = getMin(tmap, x);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    public int getMin(TreeMap<Integer, Integer> tmap, int x){\\n        int sma = 0;\\n        for(Integer val : tmap.keySet()){\\n            if(val < 0) \\n               sma += tmap.get(val);\\n            else return 0;\\n\\n            if(sma >= x) \\n               return val;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458923,
                "title": "java-freq-count-o-n-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolution is based on constraints where we violate the nums[i] >= -50 and <= 50\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse frequency of numbers and traverse the constant 50-100 numbers and find the xth number from the freq array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N*100)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n            \\n            int i = 0;\\n            int n = nums.length;\\n            int[] ans = new int[n-k+1];\\n            int st = 0;\\n\\n\\n            int[] map = new int[200];\\n\\n\\n            while(i<k-1)\\n                map[nums[i++]+50]++;\\n            int j = 0;\\n            while(i<n){\\n                map[nums[i++]+50]++;\\n                ans[j++] = getRes(map, x);\\n                map[nums[st++]+50]--;\\n\\n            }\\n            return ans;\\n    }\\n\\n    public int getRes(int[] m, int x){\\n        int i = 0;\\n        while(x>0 & i < 101){\\n            int j = m[i];\\n            x = Math.max(0, x-j);\\n            if(x > 0)\\n            i++;\\n        }\\n        // System.out.println(i);\\n        return i-50 < 0 ? i-50 : 0; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n            \\n            int i = 0;\\n            int n = nums.length;\\n            int[] ans = new int[n-k+1];\\n            int st = 0;\\n\\n\\n            int[] map = new int[200];\\n\\n\\n            while(i<k-1)\\n                map[nums[i++]+50]++;\\n            int j = 0;\\n            while(i<n){\\n                map[nums[i++]+50]++;\\n                ans[j++] = getRes(map, x);\\n                map[nums[st++]+50]--;\\n\\n            }\\n            return ans;\\n    }\\n\\n    public int getRes(int[] m, int x){\\n        int i = 0;\\n        while(x>0 & i < 101){\\n            int j = m[i];\\n            x = Math.max(0, x-j);\\n            if(x > 0)\\n            i++;\\n        }\\n        // System.out.println(i);\\n        return i-50 < 0 ? i-50 : 0; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458671,
                "title": "easy-to-understand-using-sliding-window-and-map-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each window search the xth min by maintaining a map and running a\\nloop from -50 to 0 as the num value is mentioned in constraints\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = -50; i <= 50; i++)\\n        map.put(i, 0);\\n\\n        int start = 0;\\n        int end = 0;\\n        int [] res = new int[nums.length - k + 1];\\n        int idx = 0;\\n        while(end < nums.length)\\n        {\\n            if(nums[end] < 0)\\n            map.put(nums[end], map.getOrDefault(nums[end], 0) + 1);\\n            end++;\\n            if(end - start == k)\\n            {\\n               res[idx++] = findXMin(map, x);\\n               map.put(nums[start], map.get(nums[start]) - 1);\\n               start++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int findXMin(HashMap<Integer,Integer> map, int x)\\n    {\\n        int xthMin = 0;\\n        for(int i = -50; i <= 0; i++)\\n        {\\n            if(map.get(i) > 0)\\n            xthMin+= map.get(i);\\n\\n            if(xthMin >= x)\\n            return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = -50; i <= 50; i++)\\n        map.put(i, 0);\\n\\n        int start = 0;\\n        int end = 0;\\n        int [] res = new int[nums.length - k + 1];\\n        int idx = 0;\\n        while(end < nums.length)\\n        {\\n            if(nums[end] < 0)\\n            map.put(nums[end], map.getOrDefault(nums[end], 0) + 1);\\n            end++;\\n            if(end - start == k)\\n            {\\n               res[idx++] = findXMin(map, x);\\n               map.put(nums[start], map.get(nums[start]) - 1);\\n               start++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int findXMin(HashMap<Integer,Integer> map, int x)\\n    {\\n        int xthMin = 0;\\n        for(int i = -50; i <= 0; i++)\\n        {\\n            if(map.get(i) > 0)\\n            xthMin+= map.get(i);\\n\\n            if(xthMin >= x)\\n            return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458670,
                "title": "c-solution-simple-counting-simple-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    vector<int>getSubarrayBeauty(vector<int>&nums,int k,int x){\\n        vector<int>dp(101,0);\\n        vector<int>res;\\n        for(int i=0;i<k;i++)\\n            dp[nums[i]+50]+=1;\\n        int cnt=0;\\n        for(int j=0;j<=50;j++){\\n            cnt+=dp[j];\\n            if(cnt>=x){\\n                res.push_back(j-50);\\n                break;\\n            }\\n        }\\n        if(cnt<x)\\n            res.push_back(0);\\n        \\n        for(int i=k;i<nums.size();i++){\\n            cnt=0;\\n            dp[nums[i]+50]+=1;\\n            dp[nums[i-k]+50]-=1;\\n            for(int j=0;j<=50;j++){\\n                cnt+=dp[j];\\n                if(cnt>=x){\\n                    res.push_back(j-50);\\n                    break;\\n                }\\n            }\\n            if(cnt<x)\\n                res.push_back(0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    vector<int>getSubarrayBeauty(vector<int>&nums,int k,int x){\\n        vector<int>dp(101,0);\\n        vector<int>res;\\n        for(int i=0;i<k;i++)\\n            dp[nums[i]+50]+=1;\\n        int cnt=0;\\n        for(int j=0;j<=50;j++){\\n            cnt+=dp[j];\\n            if(cnt>=x){\\n                res.push_back(j-50);\\n                break;\\n            }\\n        }\\n        if(cnt<x)\\n            res.push_back(0);\\n        \\n        for(int i=k;i<nums.size();i++){\\n            cnt=0;\\n            dp[nums[i]+50]+=1;\\n            dp[nums[i-k]+50]-=1;\\n            for(int j=0;j<=50;j++){\\n                cnt+=dp[j];\\n                if(cnt>=x){\\n                    res.push_back(j-50);\\n                    break;\\n                }\\n            }\\n            if(cnt<x)\\n                res.push_back(0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458438,
                "title": "faster-than-99-97-maintain-a-histogram-of-seen-negative-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nKeep `cnt[i]` number of times `-i` is in the window\\n`n` number of negatives in the window\\nfirst init the window, `cnt` and `n` wih the first loop over k elements. Then keep updating the window by removing the leftmost element `nums[i-k]` and adding an element to the ritht: `nums[i]`.\\n\\nThe x^th element is found each time by going over the histogram and accounting for up to `x` first elements found.\\nThis could be improved, by maintaining the x^th element and checking if the new element is lower or higher-or-equel than it, but since my solution is the fastest, no one did so.\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        cnt = [0] * 51\\n        n = 0\\n        for i in range(k):\\n            if nums[i] < 0:\\n                n += 1\\n                cnt[-nums[i]] += 1\\n        if n < x:\\n            ret = [0]\\n        else:\\n            j = x\\n            for i in range(50,0,-1):\\n                j -= cnt[i]\\n                if j <= 0:\\n                    ret = [-i]\\n                    break\\n        for i in range(k, len(nums)):\\n            if nums[i-k] < 0:\\n                cnt[-nums[i-k]] -= 1\\n                n -= 1\\n            if nums[i] < 0:\\n                cnt[-nums[i]] += 1\\n                n += 1\\n            if n < x:\\n                ret.append(0)\\n            else:\\n                j = x\\n                for i in range(50,0,-1):\\n                    j -= cnt[i]\\n                    if j <= 0:\\n                        ret.append(-i)\\n                        break\\n        return ret\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        cnt = [0] * 51\\n        n = 0\\n        for i in range(k):\\n            if nums[i] < 0:\\n                n += 1\\n                cnt[-nums[i]] += 1\\n        if n < x:\\n            ret = [0]\\n        else:\\n            j = x\\n            for i in range(50,0,-1):\\n                j -= cnt[i]\\n                if j <= 0:\\n                    ret = [-i]\\n                    break\\n        for i in range(k, len(nums)):\\n            if nums[i-k] < 0:\\n                cnt[-nums[i-k]] -= 1\\n                n -= 1\\n            if nums[i] < 0:\\n                cnt[-nums[i]] += 1\\n                n += 1\\n            if n < x:\\n                ret.append(0)\\n            else:\\n                j = x\\n                for i in range(50,0,-1):\\n                    j -= cnt[i]\\n                    if j <= 0:\\n                        ret.append(-i)\\n                        break\\n        return ret\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457425,
                "title": "c-ordered-set-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n        int rank = t.order_of_key(v);\\n        ordered_set::iterator it = t.find_by_order(rank);\\n        t.erase(it);\\n        }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        vector<int> v;\\n        ordered_set o_set;\\n        for (int i = 0; i < k; i++)\\n        {\\n            o_set.insert(nums[i]);\\n        }\\n        int tp = *(o_set.find_by_order(x-1));\\n        if(tp<0) v.push_back(tp);\\n        else v.push_back(0);\\n        int ct = 0;\\n        for (int i = k; i < nums.size(); i++)\\n        {\\n            // auto it1 = o_set.find(nums[ct]);\\n            myerase(o_set, nums[ct]);\\n            o_set.insert(nums[i]);\\n            int tp1 = *(o_set.find_by_order(x-1));\\n            if(tp1<0) v.push_back(tp1);\\n            else v.push_back(0);\\n            ct++;\\n\\n        }\\n        \\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n        int rank = t.order_of_key(v);\\n        ordered_set::iterator it = t.find_by_order(rank);\\n        t.erase(it);\\n        }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        vector<int> v;\\n        ordered_set o_set;\\n        for (int i = 0; i < k; i++)\\n        {\\n            o_set.insert(nums[i]);\\n        }\\n        int tp = *(o_set.find_by_order(x-1));\\n        if(tp<0) v.push_back(tp);\\n        else v.push_back(0);\\n        int ct = 0;\\n        for (int i = k; i < nums.size(); i++)\\n        {\\n            // auto it1 = o_set.find(nums[ct]);\\n            myerase(o_set, nums[ct]);\\n            o_set.insert(nums[i]);\\n            int tp1 = *(o_set.find_by_order(x-1));\\n            if(tp1<0) v.push_back(tp1);\\n            else v.push_back(0);\\n            ct++;\\n\\n        }\\n        \\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3457215,
                "title": "easy-c-solution-using-two-array-with-0-n-time-ans-constant-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntwo array for sort using hashing and sliding window\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int neg[51]={0},pos[51]={0};\\n        int i=0,j=0;\\n        while(i<k-1)\\n        {\\n            if(nums[i]<0)\\n            neg[-nums[i]]++;\\n            else\\n            pos[nums[i]]++;\\n            i++;\\n        }\\n          vector<int>  ans;\\n      \\n        while(i<nums.size())\\n        {\\n            if(nums[i]<0)\\n            neg[-nums[i]]++;\\n            else\\n            pos[nums[i]]++;\\n            i++;\\n                int cnt=x;\\n          bool no=true;\\n           for(int l=50;l>0;l--)\\n           {\\n             if(neg[l]>0)\\n             {\\n                 cnt-=neg[l];\\n             }\\n             if(cnt<=0)\\n             {\\n                 ans.push_back(-l);\\n                 no=false;\\n                 break;\\n             }\\n           }\\n           if(no==true)\\n              {\\n                    for(int l=0;l<=50;l++)\\n           {\\n             if(pos[l]>0)\\n             {\\n                 cnt-=pos[l];\\n             }\\n             if(cnt<=0)\\n             {\\n                 ans.push_back(0);\\n                 break;\\n             }\\n           }\\n              }\\n              else\\n              no= false;\\n               if(nums[j]<0)\\n            neg[-nums[j]]--;\\n            else\\n            pos[nums[j]]--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int neg[51]={0},pos[51]={0};\\n        int i=0,j=0;\\n        while(i<k-1)\\n        {\\n            if(nums[i]<0)\\n            neg[-nums[i]]++;\\n            else\\n            pos[nums[i]]++;\\n            i++;\\n        }\\n          vector<int>  ans;\\n      \\n        while(i<nums.size())\\n        {\\n            if(nums[i]<0)\\n            neg[-nums[i]]++;\\n            else\\n            pos[nums[i]]++;\\n            i++;\\n                int cnt=x;\\n          bool no=true;\\n           for(int l=50;l>0;l--)\\n           {\\n             if(neg[l]>0)\\n             {\\n                 cnt-=neg[l];\\n             }\\n             if(cnt<=0)\\n             {\\n                 ans.push_back(-l);\\n                 no=false;\\n                 break;\\n             }\\n           }\\n           if(no==true)\\n              {\\n                    for(int l=0;l<=50;l++)\\n           {\\n             if(pos[l]>0)\\n             {\\n                 cnt-=pos[l];\\n             }\\n             if(cnt<=0)\\n             {\\n                 ans.push_back(0);\\n                 break;\\n             }\\n           }\\n              }\\n              else\\n              no= false;\\n               if(nums[j]<0)\\n            neg[-nums[j]]--;\\n            else\\n            pos[nums[j]]--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457062,
                "title": "brute-force-c-solution-without-using-stl-with-93-memory-beats",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> v1(101,0);\\n        vector<int> v2(nums.size()-k+1);\\n        int idx=0,c=0,t=0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            v1[nums[i]+50]++;\\n        }\\n        for(int i=k-1;i<nums.size();i++)\\n        {\\n            v1[nums[i]+50]++;\\n            for(int j=0;j<=100;j++)\\n            {\\n                c+=v1[j];\\n                if(x<=c)\\n                {\\n                    t=j-50;\\n                    if(t>0)\\n                    {\\n                        v2[idx++]=0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        v2[idx++]=t;\\n                        break;\\n                    }\\n                \\n                }\\n            }\\n            c=0;\\n            v1[nums[i-k+1]+50]--;\\n        }\\n        return v2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> v1(101,0);\\n        vector<int> v2(nums.size()-k+1);\\n        int idx=0,c=0,t=0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            v1[nums[i]+50]++;\\n        }\\n        for(int i=k-1;i<nums.size();i++)\\n        {\\n            v1[nums[i]+50]++;\\n            for(int j=0;j<=100;j++)\\n            {\\n                c+=v1[j];\\n                if(x<=c)\\n                {\\n                    t=j-50;\\n                    if(t>0)\\n                    {\\n                        v2[idx++]=0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        v2[idx++]=t;\\n                        break;\\n                    }\\n                \\n                }\\n            }\\n            c=0;\\n            v1[nums[i-k+1]+50]--;\\n        }\\n        return v2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456713,
                "title": "c-ordered-map-simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findMin(map<int,int> mp,int x){\\n        int smallest=0;\\n        for(auto it : mp){\\n        \\n            if(it.first<0){\\n                smallest+=it.second;\\n            }\\n            else return 0;\\n            \\n            if(smallest>=x){\\n            \\n                return it.first;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        long long int n=nums.size();\\n       \\n        map<int,int> mp;\\n        vector<int> ans;\\n       \\n        for(int i=0;i<k-1;i++) mp[nums[i]]++;\\n        \\n        for(int j=k-1;j<n;j++){\\n             \\n                mp[nums[j]]++;\\n             \\n               ans.push_back(findMin(mp,x));\\n           \\n            \\n               mp[nums[j-k+1]]--;\\n        \\n                \\n            }\\n      return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(map<int,int> mp,int x){\\n        int smallest=0;\\n        for(auto it : mp){\\n        \\n            if(it.first<0){\\n                smallest+=it.second;\\n            }\\n            else return 0;\\n            \\n            if(smallest>=x){\\n            \\n                return it.first;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        long long int n=nums.size();\\n       \\n        map<int,int> mp;\\n        vector<int> ans;\\n       \\n        for(int i=0;i<k-1;i++) mp[nums[i]]++;\\n        \\n        for(int j=k-1;j<n;j++){\\n             \\n                mp[nums[j]]++;\\n             \\n               ans.push_back(findMin(mp,x));\\n           \\n            \\n               mp[nums[j-k+1]]--;\\n        \\n                \\n            }\\n      return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456282,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n  int getXthSmallest(unordered_map<int, int>& freq, int x) {\\n    int tot = 0;\\n    for (int i = -50; i < 0; ++i) {\\n      tot += freq[i];\\n      if (tot >= x) return i;\\n    }\\n    return 0;\\n  }\\n  \\n  vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    int n = nums.size();\\n    vector<int> ans;\\n    unordered_map<int, int> freq;\\n    for (int i = 0; i < k; ++i) {\\n      freq[nums[i]]++;\\n    }\\n    ans.push_back(getXthSmallest(freq, x));\\n    for (int i = 1; i <= (n - k); ++i) {\\n      freq[nums[i - 1]]--;\\n      freq[nums[i + k - 1]]++;\\n      ans.push_back(getXthSmallest(freq, x));\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int getXthSmallest(unordered_map<int, int>& freq, int x) {\\n    int tot = 0;\\n    for (int i = -50; i < 0; ++i) {\\n      tot += freq[i];\\n      if (tot >= x) return i;\\n    }\\n    return 0;\\n  }\\n  \\n  vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    int n = nums.size();\\n    vector<int> ans;\\n    unordered_map<int, int> freq;\\n    for (int i = 0; i < k; ++i) {\\n      freq[nums[i]]++;\\n    }\\n    ans.push_back(getXthSmallest(freq, x));\\n    for (int i = 1; i <= (n - k); ++i) {\\n      freq[nums[i - 1]]--;\\n      freq[nums[i + k - 1]]++;\\n      ans.push_back(getXthSmallest(freq, x));\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456059,
                "title": "short-easy-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> cnt(51, 0), res(n - k + 1);\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] <= 0) cnt[-nums[i]]++;\\n            if(i - k >= 0 && nums[i - k] < 0) cnt[-nums[i - k]]--;\\n            int t = 0;\\n            for(int j = 50; j >= 0 && i >= k - 1; j--) {\\n                t += cnt[j];\\n                if(t >= x) {\\n                    res[i - k + 1] = -j;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> cnt(51, 0), res(n - k + 1);\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] <= 0) cnt[-nums[i]]++;\\n            if(i - k >= 0 && nums[i - k] < 0) cnt[-nums[i - k]]--;\\n            int t = 0;\\n            for(int j = 50; j >= 0 && i >= k - 1; j--) {\\n                t += cnt[j];\\n                if(t >= x) {\\n                    res[i - k + 1] = -j;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455999,
                "title": "c-solution-count-negative-numbers-sliding-window-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        SortedDictionary<int, int> negFreqMap = new();\\n        int[] res = new int[nums.Length - k + 1];\\n\\n        for(int i=-50; i<0; i++){\\n            negFreqMap.Add(i, 0);\\n        }\\n\\n        for(int i=0; i<k; i++){\\n            if(nums[i] < 0){\\n                negFreqMap[nums[i]]++;\\n            }\\n        }\\n\\n        for(int i=k; i<nums.Length; i++){\\n            res[i-k] = GetXthSmallest(negFreqMap, x);\\n\\n            if(nums[i-k] < 0){\\n                negFreqMap[nums[i-k]]--;\\n            }\\n            \\n            if(nums[i] < 0){\\n                negFreqMap[nums[i]]++;\\n            }\\n        }\\n\\n        res[nums.Length - k] = GetXthSmallest(negFreqMap, x);\\n\\n        return res;\\n    }\\n\\n    private int GetXthSmallest(SortedDictionary<int, int> negFreqMap, int x){\\n        foreach(var kvp in negFreqMap){\\n            x -= kvp.Value;\\n\\n            if(x<=0){\\n                return kvp.Key;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        SortedDictionary<int, int> negFreqMap = new();\\n        int[] res = new int[nums.Length - k + 1];\\n\\n        for(int i=-50; i<0; i++){\\n            negFreqMap.Add(i, 0);\\n        }\\n\\n        for(int i=0; i<k; i++){\\n            if(nums[i] < 0){\\n                negFreqMap[nums[i]]++;\\n            }\\n        }\\n\\n        for(int i=k; i<nums.Length; i++){\\n            res[i-k] = GetXthSmallest(negFreqMap, x);\\n\\n            if(nums[i-k] < 0){\\n                negFreqMap[nums[i-k]]--;\\n            }\\n            \\n            if(nums[i] < 0){\\n                negFreqMap[nums[i]]++;\\n            }\\n        }\\n\\n        res[nums.Length - k] = GetXthSmallest(negFreqMap, x);\\n\\n        return res;\\n    }\\n\\n    private int GetXthSmallest(SortedDictionary<int, int> negFreqMap, int x){\\n        foreach(var kvp in negFreqMap){\\n            x -= kvp.Value;\\n\\n            if(x<=0){\\n                return kvp.Key;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455753,
                "title": "sliding-window-map-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        map<int, int> mapp;\\n        vector<int> out;\\n        int ws=0;\\n        for(int we=ws; we<n; we++) {\\n            // we can use the freq of elements in ordered-map to find xth smallest element\\n            mapp[nums[we]]++;\\n            if(we >= k-1) { //if window size(k) hits\\n                int elements=0;\\n                for(auto i: mapp) {\\n                    elements+=i.second;\\n                    if(elements >= x) { // we are at xth smallest\\n                        out.push_back(min(0, i.first)); //if xth element is positive, push 0\\n                        break;\\n                    }\\n                }\\n                mapp[nums[ws]]--;\\n                ws++;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        map<int, int> mapp;\\n        vector<int> out;\\n        int ws=0;\\n        for(int we=ws; we<n; we++) {\\n            // we can use the freq of elements in ordered-map to find xth smallest element\\n            mapp[nums[we]]++;\\n            if(we >= k-1) { //if window size(k) hits\\n                int elements=0;\\n                for(auto i: mapp) {\\n                    elements+=i.second;\\n                    if(elements >= x) { // we are at xth smallest\\n                        out.push_back(min(0, i.first)); //if xth element is positive, push 0\\n                        break;\\n                    }\\n                }\\n                mapp[nums[ws]]--;\\n                ws++;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455665,
                "title": "c-using-sorteddictionary-as-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain sliding windows with **SortedDictionary** data structure. \\nDictionary:\\n* Key = num\\n* Value = count of occurence. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAlso has *GetValueForXth* helper function to identify Xth pos of negative numbers in **SortedDictionary**\\n\\n# Complexity\\n- Time complexity:$$O(nlog(k))$$, where N = nums size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(k)$$, SortedDictionary size\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n- Runtime: 2165 ms\\n- Memory: 65 MB\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        int N = nums.Length;\\n        var res = new int[N - k + 1];\\n        var sorted = new SortedDictionary<int, int>();\\n\\n        for (int i = 0; i < N; i++) {\\n            if (i - k >= 0) {\\n                int prev = nums[i - k];\\n                sorted[prev]--;\\n                if (sorted[prev] == 0) {\\n                    sorted.Remove(prev);\\n                }\\n            }\\n\\n            sorted.TryAdd(nums[i], 0);\\n            sorted[nums[i]]++;\\n\\n            if (i - k + 1 < 0) continue;\\n\\n            res[i - k + 1] = Math.Min(0, GetValueForXth(sorted, x));\\n        }\\n\\n        return res;\\n    }\\n\\n    public int GetValueForXth(SortedDictionary<int, int> sortedMap, int x) {\\n        int count = 0;\\n\\n        foreach (var kv in sortedMap) {\\n            count += kv.Value;\\n            if (count >= x) {\\n\\n                return kv.Key;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n```\\n\\n# Aproach #2 with array counter much faster\\n# Complexity\\n- Time complexity:$$O(n*50))$$, where N = nums size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: additional $$O(50)$$, counter size\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n- Runtime: 487 ms\\n- Memory: 57.6 MB\\n\\n```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        int N = nums.Length;\\n        var res = new int[N - k + 1];\\n        int[] counter = new int[50];\\n\\n        for (int i = 0; i < N; i++) {\\n            if (i - k >= 0 && nums[i - k] < 0) {\\n                counter[nums[i - k] + 50]--;\\n            }\\n\\n            if (nums[i] < 0) {\\n                counter[nums[i] + 50]++;\\n            }\\n\\n            if (i - k + 1 < 0) continue;\\n\\n            for (int j = 0, count = 0; j < 50; j++) {\\n                count += counter[j];\\n                if (count >= x) {\\n                    res[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        int N = nums.Length;\\n        var res = new int[N - k + 1];\\n        var sorted = new SortedDictionary<int, int>();\\n\\n        for (int i = 0; i < N; i++) {\\n            if (i - k >= 0) {\\n                int prev = nums[i - k];\\n                sorted[prev]--;\\n                if (sorted[prev] == 0) {\\n                    sorted.Remove(prev);\\n                }\\n            }\\n\\n            sorted.TryAdd(nums[i], 0);\\n            sorted[nums[i]]++;\\n\\n            if (i - k + 1 < 0) continue;\\n\\n            res[i - k + 1] = Math.Min(0, GetValueForXth(sorted, x));\\n        }\\n\\n        return res;\\n    }\\n\\n    public int GetValueForXth(SortedDictionary<int, int> sortedMap, int x) {\\n        int count = 0;\\n\\n        foreach (var kv in sortedMap) {\\n            count += kv.Value;\\n            if (count >= x) {\\n\\n                return kv.Key;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n```\n```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        int N = nums.Length;\\n        var res = new int[N - k + 1];\\n        int[] counter = new int[50];\\n\\n        for (int i = 0; i < N; i++) {\\n            if (i - k >= 0 && nums[i - k] < 0) {\\n                counter[nums[i - k] + 50]--;\\n            }\\n\\n            if (nums[i] < 0) {\\n                counter[nums[i] + 50]++;\\n            }\\n\\n            if (i - k + 1 < 0) continue;\\n\\n            for (int j = 0, count = 0; j < 50; j++) {\\n                count += counter[j];\\n                if (count >= x) {\\n                    res[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455222,
                "title": "o-n-50",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        c= [0]*51\\n        temp = nums[:k]\\n        l=len(nums)\\n        \\n        for neg in temp:\\n            if neg<0:\\n                c[-neg]+=1\\n        ans=[]\\n        sum_=0\\n        for j in range(50,-1,-1):\\n            sum_+=c[j]\\n            if sum_>=x:\\n                ans.append(-j)\\n                break\\n        if sum_ < x:\\n            ans.append(0)\\n        t=0\\n        for i in range(k,l):\\n            sum_=0\\n            if nums[t]<0:\\n                c[-nums[t]]-=1\\n            t+=1\\n            if nums[i]<0:\\n                c[-nums[i]]+=1\\n            for j in range(50,-1,-1):\\n                sum_+=c[j]\\n                if sum_>=x:\\n                    ans.append(-j)\\n                    break\\n            if sum_<x:\\n                ans.append(0)\\n        return ans\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        c= [0]*51\\n        temp = nums[:k]\\n        l=len(nums)\\n        \\n        for neg in temp:\\n            if neg<0:\\n                c[-neg]+=1\\n        ans=[]\\n        sum_=0\\n        for j in range(50,-1,-1):\\n            sum_+=c[j]\\n            if sum_>=x:\\n                ans.append(-j)\\n                break\\n        if sum_ < x:\\n            ans.append(0)\\n        t=0\\n        for i in range(k,l):\\n            sum_=0\\n            if nums[t]<0:\\n                c[-nums[t]]-=1\\n            t+=1\\n            if nums[i]<0:\\n                c[-nums[i]]+=1\\n            for j in range(50,-1,-1):\\n                sum_+=c[j]\\n                if sum_>=x:\\n                    ans.append(-j)\\n                    break\\n            if sum_<x:\\n                ans.append(0)\\n        return ans\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454911,
                "title": "segment-tree-with-sliding-window",
                "content": "```\\n#define ll long long\\nclass Solution {\\n    ll offset=52;\\n    vector<ll> st;\\npublic:\\n    void update(ll tind,ll tl,ll tr,ll ind,ll val){\\n        if(tl>tr)\\n            return;\\n        if(tl==tr){\\n            st[tind]+=val;\\n            return;\\n        }\\n        ll tm=tl+((tr-tl)>>1),left=tind<<1;\\n        if(tm>=ind)\\n            update(left,tl,tm,ind,val);\\n        else\\n            update(left+1,tm+1,tr,ind,val);\\n        st[tind]=st[left]+st[left|1];\\n    }\\n    \\n    ll findSum(ll tind,ll tl,ll tr,ll ql,ll qr){\\n        if(tl>tr or ql>tr or qr<ql or qr<tl)\\n            return 0;\\n        if(tl>=ql and tr<=qr)\\n            return st[tind];\\n        ll tm=tl+((tr-tl)>>1),left=tind<<1;\\n        return findSum(left,tl,tm,ql,qr)+findSum(left|1,tm+1,tr,ql,qr);\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& a, int k, int x) {\\n        ll n=a.size();\\n        vector<int> f;\\n        st.resize(550,0);\\n        \\n        for(ll i=0;i<n;i++){\\n            update(1,1,110,a[i]+offset,1);\\n            if(i>=k)\\n                update(1,1,110,a[i-k]+offset,-1);\\n            if(i>=(k-1)){\\n                int l=1,r=110,ans=0;\\n                while(l<=r){\\n                    ll m=l+((r-l)>>1);\\n                    ll s=findSum(1,1,110,1,m);\\n                    if(s>=x){\\n                        if(m<offset)\\n                            ans=m-offset;\\n                        r=m-1;\\n                    }\\n                    else\\n                        l=m+1;\\n                }\\n                f.push_back(ans);\\n            }\\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\n    ll offset=52;\\n    vector<ll> st;\\npublic:\\n    void update(ll tind,ll tl,ll tr,ll ind,ll val){\\n        if(tl>tr)\\n            return;\\n        if(tl==tr){\\n            st[tind]+=val;\\n            return;\\n        }\\n        ll tm=tl+((tr-tl)>>1),left=tind<<1;\\n        if(tm>=ind)\\n            update(left,tl,tm,ind,val);\\n        else\\n            update(left+1,tm+1,tr,ind,val);\\n        st[tind]=st[left]+st[left|1];\\n    }\\n    \\n    ll findSum(ll tind,ll tl,ll tr,ll ql,ll qr){\\n        if(tl>tr or ql>tr or qr<ql or qr<tl)\\n            return 0;\\n        if(tl>=ql and tr<=qr)\\n            return st[tind];\\n        ll tm=tl+((tr-tl)>>1),left=tind<<1;\\n        return findSum(left,tl,tm,ql,qr)+findSum(left|1,tm+1,tr,ql,qr);\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& a, int k, int x) {\\n        ll n=a.size();\\n        vector<int> f;\\n        st.resize(550,0);\\n        \\n        for(ll i=0;i<n;i++){\\n            update(1,1,110,a[i]+offset,1);\\n            if(i>=k)\\n                update(1,1,110,a[i-k]+offset,-1);\\n            if(i>=(k-1)){\\n                int l=1,r=110,ans=0;\\n                while(l<=r){\\n                    ll m=l+((r-l)>>1);\\n                    ll s=findSum(1,1,110,1,m);\\n                    if(s>=x){\\n                        if(m<offset)\\n                            ans=m-offset;\\n                        r=m-1;\\n                    }\\n                    else\\n                        l=m+1;\\n                }\\n                f.push_back(ans);\\n            }\\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454308,
                "title": "sliding-window-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& a, int k, int x) \\n    {\\n        int len = a.size()-k+1;\\n        map <int,int> mp;\\n        vector <int> v;\\n        for (int i = 0, j = 0; i < a.size(); i++) \\n        {\\n            mp[a[i]]++;\\n            int sm = 0;\\n            if (i-j+1 == k)\\n            {\\n                for (auto it : mp)\\n                {\\n                    sm += it.second;\\n                    if (sm >= x) \\n                    {\\n                        v.push_back(min(0,it.first));\\n                        break;\\n                    }\\n                }\\n                mp[a[j]]--;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& a, int k, int x) \\n    {\\n        int len = a.size()-k+1;\\n        map <int,int> mp;\\n        vector <int> v;\\n        for (int i = 0, j = 0; i < a.size(); i++) \\n        {\\n            mp[a[i]]++;\\n            int sm = 0;\\n            if (i-j+1 == k)\\n            {\\n                for (auto it : mp)\\n                {\\n                    sm += it.second;\\n                    if (sm >= x) \\n                    {\\n                        v.push_back(min(0,it.first));\\n                        break;\\n                    }\\n                }\\n                mp[a[j]]--;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454152,
                "title": "cpp-code-without-using-stl-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        vector<int>ans(n-k+1,0),counter(51, 0);\\n    \\n\\n        for(int i=0;i<k-1;i++)\\n        {\\n            if(nums[i]<0) \\n            counter[abs(nums[i])]++;\\n        }\\n        int index=0;\\n        for(int i=k-1;i<n;i++)\\n        {\\n            if(nums[i]<0) \\n            counter[abs(nums[i])]++; \\n            int count=0;\\n            for(int j=50;j>0;j--)\\n            {\\n                count+=counter[j];\\n                if(count>=x)\\n                {\\n                    ans[index]=-1*(j); \\n                    break;\\n                }\\n            }\\n            if(nums[i-k+1]<0)\\n            {\\n                counter[abs(nums[i-k+1])]--;\\n            }\\n            index++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        vector<int>ans(n-k+1,0),counter(51, 0);\\n    \\n\\n        for(int i=0;i<k-1;i++)\\n        {\\n            if(nums[i]<0) \\n            counter[abs(nums[i])]++;\\n        }\\n        int index=0;\\n        for(int i=k-1;i<n;i++)\\n        {\\n            if(nums[i]<0) \\n            counter[abs(nums[i])]++; \\n            int count=0;\\n            for(int j=50;j>0;j--)\\n            {\\n                count+=counter[j];\\n                if(count>=x)\\n                {\\n                    ans[index]=-1*(j); \\n                    break;\\n                }\\n            }\\n            if(nums[i-k+1]<0)\\n            {\\n                counter[abs(nums[i-k+1])]--;\\n            }\\n            index++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453989,
                "title": "easy-c-solution-without-stl",
                "content": "\\n# Complexity\\n- Time complexity :O(n*100)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int>a(101,0);\\n        vector<int>res;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }\\n        for(int i=k-1;i<nums.size();i++)\\n        {\\n            a[nums[i]+50]++;\\n            int c=0,mi;\\n            for(int j=0;j<=100;j++)\\n            {\\n                c=c+a[j];\\n                if(c>=x)\\n                {\\n                    mi=min(0,j-50);\\n                    res.push_back(mi);\\n                    break;\\n                }\\n            }\\n            a[nums[i-k+1]+50]--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int>a(101,0);\\n        vector<int>res;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }\\n        for(int i=k-1;i<nums.size();i++)\\n        {\\n            a[nums[i]+50]++;\\n            int c=0,mi;\\n            for(int j=0;j<=100;j++)\\n            {\\n                c=c+a[j];\\n                if(c>=x)\\n                {\\n                    mi=min(0,j-50);\\n                    res.push_back(mi);\\n                    break;\\n                }\\n            }\\n            a[nums[i-k+1]+50]--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453978,
                "title": "using-sortedlist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        final=[0]*(len(nums)-k+1)\\n        j=0\\n        n=len(nums)\\n        ans=SortedList()\\n        print(ans)\\n        for i,a in enumerate(nums):\\n            ans.add(a)\\n            if(i>=k):\\n                ans.remove(nums[i-k])\\n            if(i>=k-1):\\n                if(ans[x-1]<0):\\n                    final[j]=ans[x-1]\\n                j+=1\\n        return final\\n    \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        final=[0]*(len(nums)-k+1)\\n        j=0\\n        n=len(nums)\\n        ans=SortedList()\\n        print(ans)\\n        for i,a in enumerate(nums):\\n            ans.add(a)\\n            if(i>=k):\\n                ans.remove(nums[i-k])\\n            if(i>=k-1):\\n                if(ans[x-1]<0):\\n                    final[j]=ans[x-1]\\n                j+=1\\n        return final\\n    \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453254,
                "title": "c-map-sliding-window-easy-to-understand-clean-code-tc-sc-explained",
                "content": "# Intuition\\nSimple case of sliding window.\\n\\n# Complexity\\n- Time complexity:\\nO(10^5 * 100 * log 100) ~= O(2 * 10^7) at worst case because there can be 100 different numbers in the hashmap\\n\\n- Space complexity:\\nO(100) for the hashmap that we have used in this solution because numbers can range from -50 to 50.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(map<int,int>&mp, int x){\\n        for(auto e: mp){\\n            if(e.second<x){\\n                x-=e.second;\\n            }\\n            else{\\n                if(e.first>0){\\n                    return 0;\\n                }\\n\\n                else{\\n                    return e.first;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int>ans(nums.size()-k+1);\\n        map<int,int>mp;\\n        int i =0, j = 0;\\n\\n        while(j<nums.size()){\\n            mp[nums[j]]++;\\n\\n            if(j-i+1==k){\\n                ans[j-k+1] = func(mp,x);\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0){\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n            }\\n\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(map<int,int>&mp, int x){\\n        for(auto e: mp){\\n            if(e.second<x){\\n                x-=e.second;\\n            }\\n            else{\\n                if(e.first>0){\\n                    return 0;\\n                }\\n\\n                else{\\n                    return e.first;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int>ans(nums.size()-k+1);\\n        map<int,int>mp;\\n        int i =0, j = 0;\\n\\n        while(j<nums.size()){\\n            mp[nums[j]]++;\\n\\n            if(j-i+1==k){\\n                ans[j-k+1] = func(mp,x);\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0){\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n            }\\n\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451879,
                "title": "c-simple-sliding-window-counting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding Window + Counting\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding Window\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n        map<int,int> freq;\\n        vector<int> res; \\n        while(right<n){\\n            freq[nums[right]]++;\\n            if(right>=k-1){\\n                //maintain window\\n                if(right-left+1>k){\\n                    freq[nums[left]]--;\\n                    if(freq[nums[left]]==0){\\n                        freq.erase(nums[left]);\\n                    }\\n                    left++;\\n                }\\n                int ret = helper(freq, x);\\n                res.push_back(ret);\\n            }\\n            right++;\\n        }\\n        return res;\\n    }\\n\\n\\n    int helper(map<int,int>& freq, int x){\\n        int count = 0;\\n\\n        for(auto iter:freq){\\n            if(iter.first>=0){\\n                break;\\n            }\\n            count+=iter.second;\\n            if(count>=x){\\n                return iter.first;\\n            }\\n        }\\n        return 0;\\n\\n\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n        map<int,int> freq;\\n        vector<int> res; \\n        while(right<n){\\n            freq[nums[right]]++;\\n            if(right>=k-1){\\n                //maintain window\\n                if(right-left+1>k){\\n                    freq[nums[left]]--;\\n                    if(freq[nums[left]]==0){\\n                        freq.erase(nums[left]);\\n                    }\\n                    left++;\\n                }\\n                int ret = helper(freq, x);\\n                res.push_back(ret);\\n            }\\n            right++;\\n        }\\n        return res;\\n    }\\n\\n\\n    int helper(map<int,int>& freq, int x){\\n        int count = 0;\\n\\n        for(auto iter:freq){\\n            if(iter.first>=0){\\n                break;\\n            }\\n            count+=iter.second;\\n            if(count>=x){\\n                return iter.first;\\n            }\\n        }\\n        return 0;\\n\\n\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451755,
                "title": "java-treemap-ordered-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans= new int[nums.length-k+1];\\n        TreeMap<Integer, Integer> map= new TreeMap<>();\\n        int count=0;\\n        int ind=0;\\n        int si=0;\\n        int i=0;\\n        for(;i<nums.length;i++)\\n        {\\n             if(count==k)\\n            {\\n                int sum=0;\\n                for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n                {\\n                    sum=sum+entry.getValue();\\n                    if(sum>=x)\\n                    {   ans[ind]=entry.getKey();\\n                        ind++;\\n                        break;\\n                    }\\n                }\\n                if(sum<x) \\n                {\\n                    ans[ind]=0;\\n                    ind++;\\n                }\\n\\n                if(nums[si]<=0)\\n                {\\n                    if(map.get(nums[si])==1) map.remove(nums[si]);\\n                    else map.put(nums[si],map.get(nums[si])-1);\\n                }\\n                si++;\\n                count--;\\n            }\\n            if(count<k)\\n            {\\n                if(nums[i]<=0)\\n                {\\n                if(!map.containsKey(nums[i]))\\n                {\\n                    map.put(nums[i],1);\\n                }\\n                else{\\n                    map.put(nums[i],map.get(nums[i])+1);\\n                }\\n                }\\n                count++;\\n            }\\n           \\n        }\\n        if(count==k)\\n            {\\n                int sum=0;\\n                for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n                {\\n                    sum=sum+entry.getValue();\\n                    if(sum>=x)\\n                    {\\n                        ans[ind]=entry.getKey();\\n                        ind++;\\n                        break;\\n                    }\\n                }\\n                if(sum<x) \\n                {\\n                    ans[ind]=0;\\n                    ind++;\\n                }\\n\\n                if(nums[si]<=0)\\n                {\\n                    if(map.get(nums[si])==1) map.remove(nums[si]);\\n                    else map.put(nums[si],map.get(nums[si])-1);\\n                }\\n                \\n                si++;\\n                count--;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans= new int[nums.length-k+1];\\n        TreeMap<Integer, Integer> map= new TreeMap<>();\\n        int count=0;\\n        int ind=0;\\n        int si=0;\\n        int i=0;\\n        for(;i<nums.length;i++)\\n        {\\n             if(count==k)\\n            {\\n                int sum=0;\\n                for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n                {\\n                    sum=sum+entry.getValue();\\n                    if(sum>=x)\\n                    {   ans[ind]=entry.getKey();\\n                        ind++;\\n                        break;\\n                    }\\n                }\\n                if(sum<x) \\n                {\\n                    ans[ind]=0;\\n                    ind++;\\n                }\\n\\n                if(nums[si]<=0)\\n                {\\n                    if(map.get(nums[si])==1) map.remove(nums[si]);\\n                    else map.put(nums[si],map.get(nums[si])-1);\\n                }\\n                si++;\\n                count--;\\n            }\\n            if(count<k)\\n            {\\n                if(nums[i]<=0)\\n                {\\n                if(!map.containsKey(nums[i]))\\n                {\\n                    map.put(nums[i],1);\\n                }\\n                else{\\n                    map.put(nums[i],map.get(nums[i])+1);\\n                }\\n                }\\n                count++;\\n            }\\n           \\n        }\\n        if(count==k)\\n            {\\n                int sum=0;\\n                for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n                {\\n                    sum=sum+entry.getValue();\\n                    if(sum>=x)\\n                    {\\n                        ans[ind]=entry.getKey();\\n                        ind++;\\n                        break;\\n                    }\\n                }\\n                if(sum<x) \\n                {\\n                    ans[ind]=0;\\n                    ind++;\\n                }\\n\\n                if(nums[si]<=0)\\n                {\\n                    if(map.get(nums[si])==1) map.remove(nums[si]);\\n                    else map.put(nums[si],map.get(nums[si])-1);\\n                }\\n                \\n                si++;\\n                count--;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451678,
                "title": "using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int st = 0;\\n        int n = nums.length;\\n        int []res = new int[n - k + 1];\\n        int freq[] = new int[51];\\n        int itr = 0;\\n        for(int i = 0; i < n ;i++){\\n            int ele = -1 * nums[i];\\n            if(ele > 0){\\n                freq[ele]++;\\n            }\\n            if(i >= k - 1){\\n                int cnt = x;\\n                boolean flag = false;\\n                for(int j = 50; j >= 1; j--){\\n                    if(freq[j] > 0){\\n                        cnt -= freq[j];\\n                        if(cnt <= 0){\\n                            flag = true;\\n                            res[itr++] = -j;\\n                            int stEle = -1 * nums[st];\\n                            if(stEle > 0){\\n                                freq[stEle]--;\\n                            }\\n                            st++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(flag == false){\\n                    res[itr++] = 0;\\n                    int stEle = -1 * nums[st];\\n                    if(stEle > 0){\\n                        freq[stEle]--;\\n                    }\\n                    st++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int st = 0;\\n        int n = nums.length;\\n        int []res = new int[n - k + 1];\\n        int freq[] = new int[51];\\n        int itr = 0;\\n        for(int i = 0; i < n ;i++){\\n            int ele = -1 * nums[i];\\n            if(ele > 0){\\n                freq[ele]++;\\n            }\\n            if(i >= k - 1){\\n                int cnt = x;\\n                boolean flag = false;\\n                for(int j = 50; j >= 1; j--){\\n                    if(freq[j] > 0){\\n                        cnt -= freq[j];\\n                        if(cnt <= 0){\\n                            flag = true;\\n                            res[itr++] = -j;\\n                            int stEle = -1 * nums[st];\\n                            if(stEle > 0){\\n                                freq[stEle]--;\\n                            }\\n                            st++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(flag == false){\\n                    res[itr++] = 0;\\n                    int stEle = -1 * nums[st];\\n                    if(stEle > 0){\\n                        freq[stEle]--;\\n                    }\\n                    st++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451198,
                "title": "intuitive-simulation-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int smallx(const vector<int>& sub, int x) {\\n        int acc = 0;\\n        for (int i = 0; i <= 50; ++i) {\\n            acc += sub[i];\\n            if (acc >= x) return i - 50;\\n        }\\n        return 0;\\n    }\\n\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> sub(101);\\n        for (int i = 0; i < k - 1; ++i) {\\n            sub[nums[i] + 50]++;\\n        }\\n\\n        vector<int> res;\\n        for (int i = k - 1; i < nums.size(); ++i) {\\n            sub[nums[i] + 50]++;\\n            res.push_back(smallx(sub, x));\\n            sub[nums[i - k + 1] + 50]--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    int smallx(const vector<int>& sub, int x) {\\n        int acc = 0;\\n        for (int i = 0; i <= 50; ++i) {\\n            acc += sub[i];\\n            if (acc >= x) return i - 50;\\n        }\\n        return 0;\\n    }\\n\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> sub(101);\\n        for (int i = 0; i < k - 1; ++i) {\\n            sub[nums[i] + 50]++;\\n        }\\n\\n        vector<int> res;\\n        for (int i = k - 1; i < nums.size(); ++i) {\\n            sub[nums[i] + 50]++;\\n            res.push_back(smallx(sub, x));\\n            sub[nums[i - k + 1] + 50]--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451161,
                "title": "100-faster-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[]res = new int[n-k+1];\\n        int[]arr = new int[101];\\n        for(int i = 0;i<n;i++){\\n            arr[nums[i]+50]++;\\n            if(i>=(k-1)){\\n                int t = x;\\n                for(int j = 0;j<=100;j++){ // just created an array of\\n                // 100 numbers and each index storing frq of ith number (offset is 50 because nums\\n                // can be negetive also) . now just iterate and find x largest in each window \\n                    if(t-arr[j] <=0){\\n                        res[i-(k-1)] = j-50;\\n                        if(j>=50) res[i-(k-1)] = 0;\\n                        break;\\n                    }\\n                    t-=arr[j];\\n                }\\n                arr[nums[i-(k-1)]+50]--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[]res = new int[n-k+1];\\n        int[]arr = new int[101];\\n        for(int i = 0;i<n;i++){\\n            arr[nums[i]+50]++;\\n            if(i>=(k-1)){\\n                int t = x;\\n                for(int j = 0;j<=100;j++){ // just created an array of\\n                // 100 numbers and each index storing frq of ith number (offset is 50 because nums\\n                // can be negetive also) . now just iterate and find x largest in each window \\n                    if(t-arr[j] <=0){\\n                        res[i-(k-1)] = j-50;\\n                        if(j>=50) res[i-(k-1)] = 0;\\n                        break;\\n                    }\\n                    t-=arr[j];\\n                }\\n                arr[nums[i-(k-1)]+50]--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451056,
                "title": "c-use-two-multiset-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBorrow the idea from finding the median of the stream, we use the two muliset to store the sliding window, and make sure the begin of the second multiset is the xth smallest value.\\n\\nIn order to handle the multiple value, we use the multiset instead of the set.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key point is that we need to make sure the size of the s1 is equal or less than x - 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int> s1, s2; \\n        int n = nums.size(), j = 0;\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            s1.insert(nums[i]);\\n            if(s1.size() >= x) {\\n                auto tmp = (--s1.end());\\n                s2.insert(*tmp);\\n                s1.erase(tmp);\\n            }\\n            if(s1.size() + s2.size() > k) {\\n                if(s1.find(nums[j]) != s1.end()) {\\n                    s1.erase(s1.find(nums[j++]));\\n                    auto tmp = s2.begin();\\n                    s1.insert(*tmp);\\n                    s2.erase(tmp);\\n                } else \\n                    s2.erase(s2.find(nums[j++]));\\n            }\\n            \\n            if(i >= k - 1) {\\n                int be = *(s2.begin());\\n                ans.push_back(be >= 0 ? 0 : be);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n/*\\n[-3,1,2,-3,0,-3]\\n2\\n1\\n\\ns1 -3\\n\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int> s1, s2; \\n        int n = nums.size(), j = 0;\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            s1.insert(nums[i]);\\n            if(s1.size() >= x) {\\n                auto tmp = (--s1.end());\\n                s2.insert(*tmp);\\n                s1.erase(tmp);\\n            }\\n            if(s1.size() + s2.size() > k) {\\n                if(s1.find(nums[j]) != s1.end()) {\\n                    s1.erase(s1.find(nums[j++]));\\n                    auto tmp = s2.begin();\\n                    s1.insert(*tmp);\\n                    s2.erase(tmp);\\n                } else \\n                    s2.erase(s2.find(nums[j++]));\\n            }\\n            \\n            if(i >= k - 1) {\\n                int be = *(s2.begin());\\n                ans.push_back(be >= 0 ? 0 : be);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n/*\\n[-3,1,2,-3,0,-3]\\n2\\n1\\n\\ns1 -3\\n\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450916,
                "title": "simple-c-counting",
                "content": "# Intuition\\nThe big hint in this problem is in the bounds  ```-50 <= nums[i] <= 50```. Here we know that we can simply hold an array of length 101 that represents the possible numbers seen in the array nums (-50, -49, ... , -1, 0, 1, ... 49, 50). \\n# Approach\\nSimilarly to how some sorting functions can achieve O(n) time given some bounds on the values to be sorted (ie. our ```-50 <= nums[i] <= 50```) we can simply hold the counts of numbers seen and find the x^th smallest number as we go. \\n\\nNote: helper functions were used to keep code concise\\n\\n# getSubarrayBeauty Algorithm:\\n- First initialize an array (in my code arr) that simple holds the values seen so far in nums. Its size is 101 since there are only 101 unique values in nums. This array holds the counts of each unique number seen. \\n\\n- Initialize a vector (in my code list), this is where we will house our solutions. \\n\\n- Loop through nums\\n    - add the number to arr\\n    - if we have seen k numbers then we can find the xth smallest\\n    - add the xth smallest to the list\\n    - remove the number at the back of the sliding window\\n- Make sure to set all positive x^th smallest numbers to 0\\n- Return list\\n\\n# getXthSmallest Algorithm:\\n- Loop through arr\\n    - if there is an element seen at the index i\\n    - Check if x - arr[i] is negative, if so then we have found x^th smallest\\n    - else, update x and continue to the next number in arr\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int arr[101] = {0};\\n        vector<int> list;\\n        for(int i=0; i<nums.size(); i++) {\\n            addNum(nums[i], arr);\\n            if(i + 1 - k >= 0) {\\n                list.push_back(getXthSmallest(x, arr));\\n                removeNum(nums[i - k + 1], arr);\\n            }\\n        }\\n        for(int i=0; i<list.size(); i++) {\\n            if(list[i] > 0) {\\n                list[i] = 0;\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    private:\\n        void addNum(int num, int arr[101]) {\\n            arr[num + 50]++;\\n        }\\n    \\n    private: \\n        void removeNum(int num, int arr[101]) {\\n            arr[num + 50]--;\\n        }\\n    \\n    private: \\n        int getXthSmallest(int x, int arr[101]) {\\n            for(int i=0; i<101; i++) {\\n                if(arr[i] != 0) {\\n                    int temp = x - arr[i];\\n                    if(temp <= 0) {\\n                        return i - 50;\\n                    } else {\\n                        x = x - arr[i];\\n                    }\\n                }\\n            }\\n            return 0;\\n        }  \\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "```-50 <= nums[i] <= 50```\n```-50 <= nums[i] <= 50```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450842,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) \\n    {\\n        int n = nums.length;\\n        int[] count = new int[50];\\n        for(int i = 0; i<k; i++)\\n        {\\n            if(nums[i] < 0)\\n            {\\n                count[nums[i] + 50]++;\\n            }\\n        }\\n        int[] ans = new int[n-k+1];\\n        int j = k;\\n        for(int i = 0; i<n && j<=n; i++, j++)\\n        {\\n            int sum = 0;\\n            boolean flag = false;\\n            for(int m = 0; m < 50; m++)\\n            {\\n                sum += count[m];\\n                if(sum >= x)\\n                {\\n                    ans[i] = m - 50;\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                ans[i] = 0;\\n            }\\n            if(nums[i] < 0)\\n            {\\n                count[nums[i] + 50]--;\\n            }\\n            if(j<n && nums[j] < 0)\\n            {\\n                count[nums[j] + 50]++;\\n            }\\n        }    \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) \\n    {\\n        int n = nums.length;\\n        int[] count = new int[50];\\n        for(int i = 0; i<k; i++)\\n        {\\n            if(nums[i] < 0)\\n            {\\n                count[nums[i] + 50]++;\\n            }\\n        }\\n        int[] ans = new int[n-k+1];\\n        int j = k;\\n        for(int i = 0; i<n && j<=n; i++, j++)\\n        {\\n            int sum = 0;\\n            boolean flag = false;\\n            for(int m = 0; m < 50; m++)\\n            {\\n                sum += count[m];\\n                if(sum >= x)\\n                {\\n                    ans[i] = m - 50;\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                ans[i] = 0;\\n            }\\n            if(nums[i] < 0)\\n            {\\n                count[nums[i] + 50]--;\\n            }\\n            if(j<n && nums[j] < 0)\\n            {\\n                count[nums[j] + 50]++;\\n            }\\n        }    \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450771,
                "title": "easiest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n      var map=new TreeMap<Integer,Integer>();\\n      int n=nums.length,res=0;\\n      var result=new int[n-k+1];\\n      for(int i=0;i<n;i++){\\n          map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n          int out=i-k<0?Integer.MAX_VALUE:nums[i-k];\\n          map.put(out,map.getOrDefault(out,0)-1);\\n          if(i>=k-1){\\n              result[res++]=getsnum(map,x);\\n          }\\n      }return result;\\n    } \\n    private int getsnum(TreeMap<Integer,Integer>map,int x){\\n        int run=0;\\n        for(var entry:map.entrySet()){\\n            int key=entry.getKey();\\n            int val=entry.getValue();\\n            if(key<0){\\n                run+=val;\\n            }\\n            if(run>=x)return key;\\n\\n        }return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n      var map=new TreeMap<Integer,Integer>();\\n      int n=nums.length,res=0;\\n      var result=new int[n-k+1];\\n      for(int i=0;i<n;i++){\\n          map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n          int out=i-k<0?Integer.MAX_VALUE:nums[i-k];\\n          map.put(out,map.getOrDefault(out,0)-1);\\n          if(i>=k-1){\\n              result[res++]=getsnum(map,x);\\n          }\\n      }return result;\\n    } \\n    private int getsnum(TreeMap<Integer,Integer>map,int x){\\n        int run=0;\\n        for(var entry:map.entrySet()){\\n            int key=entry.getKey();\\n            int val=entry.getValue();\\n            if(key<0){\\n                run+=val;\\n            }\\n            if(run>=x)return key;\\n\\n        }return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450680,
                "title": "very-easy-optimized-solution-using-frequency-array",
                "content": "# Complexity\\n- Time complexity: O(n*50)\\n\\n# Code\\n```\\nO(n*50)\\n  int getElement(vector<int>& neg, int x){\\n        int i;\\n        int count=0;\\n        for(int i=50; i>=0; i--){\\n            count+=neg[i];\\n            if(count>=x)\\n                return i*-1;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> neg(51,0);\\n        int i=0, j=0;\\n        int n=nums.size();\\n        vector<int> ans;\\n        while(j<n){\\n            //Calculation\\n            if(nums[j]<0)   neg[abs(nums[j])]++;\\n\\n\\n            //if window size is less than k\\n            if(j-i+1<k){\\n                j++;\\n\\n\\n            //else if window size==k\\n            }else if(j-i+1==k){\\n                int res = getElement(neg, x);\\n                ans.push_back(res);\\n                if(nums[i]<0){\\n                    neg[abs(nums[i])]--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nO(n*50)\\n  int getElement(vector<int>& neg, int x){\\n        int i;\\n        int count=0;\\n        for(int i=50; i>=0; i--){\\n            count+=neg[i];\\n            if(count>=x)\\n                return i*-1;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> neg(51,0);\\n        int i=0, j=0;\\n        int n=nums.size();\\n        vector<int> ans;\\n        while(j<n){\\n            //Calculation\\n            if(nums[j]<0)   neg[abs(nums[j])]++;\\n\\n\\n            //if window size is less than k\\n            if(j-i+1<k){\\n                j++;\\n\\n\\n            //else if window size==k\\n            }else if(j-i+1==k){\\n                int res = getElement(neg, x);\\n                ans.push_back(res);\\n                if(nums[i]<0){\\n                    neg[abs(nums[i])]--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450622,
                "title": "beats-100-runtime-as-of-24mar2023-38ms-sliding-windows-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince normal approach even using the priority queue it was giving TLE, finally tried sliding window. Keep sliding the windows of k array. And find the xth smallest for the current windows of k element. We do not need to keep all elements of k windows instead just keep/manage negative elements. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create windows queueu of all negative element in the first k index.\\n2. begin the loop of sliding windows.\\n3. in the loop first find the xth smallest as in the current window queue.\\n4. as a logical slide check if the left most element which is outgoing is a negative or not. If it is negative then decrease the frequency counter. This basically means that the number is removed from our calculations. Also similarly check the right most incoming number and if this is negative increment its frequency.\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] res = new int[nums.length-k+1];\\n\\t\\tint[] q = new int[50]; \\n        for(int i=0;i<k;i++) // for all the negative values of k windows count up the frequency: first window\\n            if(nums[i]<0)\\n                q[50+nums[i]]++;\\n        \\n       \\t\\t\\n\\t    for(int i=0;i<nums.length - k+1;i++){ // keep sliding the window\\n\\t    \\tres[i] = getXthSmallest(q,x); // in the current windows find the smallest xth value.\\n\\t    \\tif(i+k>nums.length-1) break; // as windows are sliding in next step check the over-run.\\n            //below is logical shift of window to right. \\n            if (nums[i]<0) //if the left most number is negative then it is being removed so update its frequency.\\n                q[50+nums[i]]--;\\n            if(nums[i+k]<0) // the new number coming in and if it is negative update its frequency.\\n                q[50+nums[i+k]]++;\\n        }\\n\\t    \\n        return res;\\n        \\n    }\\n    \\n    // to find the xth smallest by just going through the each index and adding its frequency.\\n    public int getXthSmallest(int[]q, int x){\\n        int count =0; \\n        int res = 0;\\n\\t\\tfor(int j=0;j<50;j++){\\n\\t\\t    count+=q[j];\\n\\t\\t\\tif(count>=x) {\\n                res = j - 50;\\n                break;\\n            }\\n        }\\n        return res;     \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] res = new int[nums.length-k+1];\\n\\t\\tint[] q = new int[50]; \\n        for(int i=0;i<k;i++) // for all the negative values of k windows count up the frequency: first window\\n            if(nums[i]<0)\\n                q[50+nums[i]]++;\\n        \\n       \\t\\t\\n\\t    for(int i=0;i<nums.length - k+1;i++){ // keep sliding the window\\n\\t    \\tres[i] = getXthSmallest(q,x); // in the current windows find the smallest xth value.\\n\\t    \\tif(i+k>nums.length-1) break; // as windows are sliding in next step check the over-run.\\n            //below is logical shift of window to right. \\n            if (nums[i]<0) //if the left most number is negative then it is being removed so update its frequency.\\n                q[50+nums[i]]--;\\n            if(nums[i+k]<0) // the new number coming in and if it is negative update its frequency.\\n                q[50+nums[i+k]]++;\\n        }\\n\\t    \\n        return res;\\n        \\n    }\\n    \\n    // to find the xth smallest by just going through the each index and adding its frequency.\\n    public int getXthSmallest(int[]q, int x){\\n        int count =0; \\n        int res = 0;\\n\\t\\tfor(int j=0;j<50;j++){\\n\\t\\t    count+=q[j];\\n\\t\\t\\tif(count>=x) {\\n                res = j - 50;\\n                break;\\n            }\\n        }\\n        return res;     \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450606,
                "title": "commented-solution-with-time-complexityma",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nstore the ele in map as in sorted form count the freq , calling the fun in order to find the xth smallest val nd now moving the window size by itrating from k\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:NlogN\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint funCall(map<int, int>&mp, int x){\\n    int cnt=0;\\n    for(auto it:mp){\\n        int val = it.first;\\n        if(val<0){\\n            cnt+=it.second;\\n        }\\n        else{\\n            return 0; //map is already sorted slo if not find return 0\\n        }\\n        if(cnt>=x){\\n            return val;\\n        }\\n    }\\n    return 0;\\n}\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int, int>mp;\\n        int n = nums.size();\\n        vector<int>ans(n-k+1);//storing the ans req of size k \\n        for(int i= 0 ; i<k; i++){\\n            mp[nums[i]]++;//storing the freq \\n        }\\n        ans[0]= funCall(mp, x);//findng the x smallest val\\n        for(int i = k ; i <n ; i++){\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;//revoing the first ele from window\\n            if(mp[nums[i-k]]==0){\\n                mp.erase(nums[i-k]);\\n            }\\n            ans[i-k+1]= funCall(mp,x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint funCall(map<int, int>&mp, int x){\\n    int cnt=0;\\n    for(auto it:mp){\\n        int val = it.first;\\n        if(val<0){\\n            cnt+=it.second;\\n        }\\n        else{\\n            return 0; //map is already sorted slo if not find return 0\\n        }\\n        if(cnt>=x){\\n            return val;\\n        }\\n    }\\n    return 0;\\n}\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int, int>mp;\\n        int n = nums.size();\\n        vector<int>ans(n-k+1);//storing the ans req of size k \\n        for(int i= 0 ; i<k; i++){\\n            mp[nums[i]]++;//storing the freq \\n        }\\n        ans[0]= funCall(mp, x);//findng the x smallest val\\n        for(int i = k ; i <n ; i++){\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;//revoing the first ele from window\\n            if(mp[nums[i-k]]==0){\\n                mp.erase(nums[i-k]);\\n            }\\n            ans[i-k+1]= funCall(mp,x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450541,
                "title": "c-tc-0-n-50-frequency-array-fixed-size-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(int a[],int n,int k){\\n        int i;\\n        int count=0;\\n        for(int i=50;i>=0;i--){\\n            count+=a[i];\\n            if(count>=k)\\n                return i*-1;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int a[51];\\n        memset(a,0,sizeof(a));\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0)a[nums[i]*-1]++;\\n        }\\n        ans.push_back(findMin(a,51,x));\\n        int n=nums.size();\\n        int start=0,end=k;\\n        while(end<n){\\n            if(nums[start]<0){\\n                if(a[nums[start]*-1]>0)\\n                    a[nums[start]*-1]--;\\n            }\\n            start++;\\n            if(nums[end]<0)\\n                a[nums[end]*-1]++;\\n            end++;\\n            ans.push_back(findMin(a,51,x));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(int a[],int n,int k){\\n        int i;\\n        int count=0;\\n        for(int i=50;i>=0;i--){\\n            count+=a[i];\\n            if(count>=k)\\n                return i*-1;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int a[51];\\n        memset(a,0,sizeof(a));\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0)a[nums[i]*-1]++;\\n        }\\n        ans.push_back(findMin(a,51,x));\\n        int n=nums.size();\\n        int start=0,end=k;\\n        while(end<n){\\n            if(nums[start]<0){\\n                if(a[nums[start]*-1]>0)\\n                    a[nums[start]*-1]--;\\n            }\\n            start++;\\n            if(nums[end]<0)\\n                a[nums[end]*-1]++;\\n            end++;\\n            ans.push_back(findMin(a,51,x));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450416,
                "title": "kotlin-accepted",
                "content": "# Intuition\\nIt turns out that limits on the size of array elements are important. A completely different approach to subarray analysis.\\n\\n# Approach\\nWindow shift + frequency.\\n\\n# Complexity\\n- Time complexity:\\nO(n(101))\\n\\n- Space complexity:\\nO(n(101))\\n\\n# Code\\n```\\nclass Solution {\\n    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {\\n        val Counts: Array<Int> = Array(101, {0})\\n        var nn_zam = 0\\n        var sum = 0\\n        var len = nums.size\\n        var rez: Array<Int> = Array(len-k+1, {0})\\n\\n        nn_zam = nums[0]\\n        for (j in 0..k-1) {\\n            Counts[nums[j]+50] +=1\\n        }\\n        \\n        sum = 0\\n        // \\u043F\\u043E\\u043A\\u0430 sum < x\\n        for (i in 0..49) {\\n            if (Counts[i] == 0) continue\\n            sum += Counts[i] \\n            if (sum>=x) {\\n                rez[0] = i-50\\n                break\\n            }\\n        }\\n        if (k == len) return rez.toIntArray()\\n        for (j in 1..len-k) {\\n            Counts[nn_zam+50] -=1\\n            Counts[nums[j+k-1]+50] +=1\\n            sum = 0\\n        // \\u043F\\u043E\\u043A\\u0430 sum < x\\n            for (i in 0..49) {\\n                if (Counts[i] == 0) continue\\n                sum += Counts[i] \\n                if (sum>=x) {\\n                    rez[j] = i-50\\n                    break\\n                }\\n            }\\n            nn_zam = nums[j]\\n        }\\n        return rez.toIntArray()\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {\\n        val Counts: Array<Int> = Array(101, {0})\\n        var nn_zam = 0\\n        var sum = 0\\n        var len = nums.size\\n        var rez: Array<Int> = Array(len-k+1, {0})\\n\\n        nn_zam = nums[0]\\n        for (j in 0..k-1) {\\n            Counts[nums[j]+50] +=1\\n        }\\n        \\n        sum = 0\\n        // \\u043F\\u043E\\u043A\\u0430 sum < x\\n        for (i in 0..49) {\\n            if (Counts[i] == 0) continue\\n            sum += Counts[i] \\n            if (sum>=x) {\\n                rez[0] = i-50\\n                break\\n            }\\n        }\\n        if (k == len) return rez.toIntArray()\\n        for (j in 1..len-k) {\\n            Counts[nn_zam+50] -=1\\n            Counts[nums[j+k-1]+50] +=1\\n            sum = 0\\n        // \\u043F\\u043E\\u043A\\u0430 sum < x\\n            for (i in 0..49) {\\n                if (Counts[i] == 0) continue\\n                sum += Counts[i] \\n                if (sum>=x) {\\n                    rez[j] = i-50\\n                    break\\n                }\\n            }\\n            nn_zam = nums[j]\\n        }\\n        return rez.toIntArray()\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450151,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhash negative elements\\n\\n# Complexity\\n- Time complexity:`O(n * 50) = O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        // size of input array\\n        int n = nums.size();\\n\\n        vector<int>freq(51,0); // store frequecies of negative elements\\n        vector<int>result;     // resultant vector\\n\\n        // some variables\\n        int i = 0 , j = 0;\\n        \\n        // traverse input array\\n        while(j < n){\\n            \\n            // hash only negatives\\n            if(nums[j] < 0) freq[nums[j]*(-1)]++; \\n\\n            // subarray size is less than k\\n            if(j - i + 1 < k) j++;\\n            else if(j - i + 1 == k){  // k size subarray is fixed\\n\\n                // for counting negatives & store possible candidate\\n                int cnt = 0 , negative = 0;\\n\\n                // traverse from back to get xth smallest negative\\n                for(int i=50;i>=1;i--){\\n                    \\n                    // if we have x negatives in subarray it will automatically update negative.. otherwise it will remain 0\\n                    if(freq[i] && cnt < x){\\n                        cnt += freq[i];\\n                        if(cnt >= x) negative = i * (-1); \\n                    }\\n\\n                }\\n\\n                // add negative or 0 in result\\n                result.push_back(negative);\\n\\n                // if first element of subarray is negative then remove it from subarray & hash it\\'s value\\n                if(nums[i] < 0) freq[nums[i]*(-1)]--;\\n\\n                // update the subarray\\n                i++; j++;\\n            }\\n        }\\n        // result \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        // size of input array\\n        int n = nums.size();\\n\\n        vector<int>freq(51,0); // store frequecies of negative elements\\n        vector<int>result;     // resultant vector\\n\\n        // some variables\\n        int i = 0 , j = 0;\\n        \\n        // traverse input array\\n        while(j < n){\\n            \\n            // hash only negatives\\n            if(nums[j] < 0) freq[nums[j]*(-1)]++; \\n\\n            // subarray size is less than k\\n            if(j - i + 1 < k) j++;\\n            else if(j - i + 1 == k){  // k size subarray is fixed\\n\\n                // for counting negatives & store possible candidate\\n                int cnt = 0 , negative = 0;\\n\\n                // traverse from back to get xth smallest negative\\n                for(int i=50;i>=1;i--){\\n                    \\n                    // if we have x negatives in subarray it will automatically update negative.. otherwise it will remain 0\\n                    if(freq[i] && cnt < x){\\n                        cnt += freq[i];\\n                        if(cnt >= x) negative = i * (-1); \\n                    }\\n\\n                }\\n\\n                // add negative or 0 in result\\n                result.push_back(negative);\\n\\n                // if first element of subarray is negative then remove it from subarray & hash it\\'s value\\n                if(nums[i] < 0) freq[nums[i]*(-1)]--;\\n\\n                // update the subarray\\n                i++; j++;\\n            }\\n        }\\n        // result \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450069,
                "title": "o-n-solution",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n         int[] res = new int[nums.length - k + 1];\\n        int[] track = new int[150];\\n        for (int i = 0; i < k; i++) {\\n            track[nums[i] + 50]++;\\n        }\\n        int xClone = x;\\n        for (int i = 0; i < 50; i++) {\\n            if (track[i] > 0) {\\n                if (xClone - track[i] <= 0) {\\n                    res[0] = i - 50;\\n                    xClone -= track[i];\\n                    break;\\n                } else {\\n                    xClone -= track[i];\\n                }\\n            }\\n        }\\n        if (xClone > 0)\\n            res[0] = 0;\\n        for (int i = 0; i < nums.length - k; i++) {\\n            track[nums[i] + 50]--;\\n            track[nums[i + k] + 50]++;\\n            int xClone2 = x;\\n            for (int j = 0; j < 50; j++) {\\n                if (track[j] > 0) {\\n                    if (xClone2 - track[j] <= 0) {\\n                        res[i + 1] = j - 50;\\n                        xClone2 -= track[j];\\n                        break;\\n                    } else {\\n                        xClone2 -= track[j];\\n                    }\\n                }\\n            }\\n            if (xClone2 > 0)\\n                res[i + 1] = 0;\\n        }\\n        return res;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n         int[] res = new int[nums.length - k + 1];\\n        int[] track = new int[150];\\n        for (int i = 0; i < k; i++) {\\n            track[nums[i] + 50]++;\\n        }\\n        int xClone = x;\\n        for (int i = 0; i < 50; i++) {\\n            if (track[i] > 0) {\\n                if (xClone - track[i] <= 0) {\\n                    res[0] = i - 50;\\n                    xClone -= track[i];\\n                    break;\\n                } else {\\n                    xClone -= track[i];\\n                }\\n            }\\n        }\\n        if (xClone > 0)\\n            res[0] = 0;\\n        for (int i = 0; i < nums.length - k; i++) {\\n            track[nums[i] + 50]--;\\n            track[nums[i + k] + 50]++;\\n            int xClone2 = x;\\n            for (int j = 0; j < 50; j++) {\\n                if (track[j] > 0) {\\n                    if (xClone2 - track[j] <= 0) {\\n                        res[i + 1] = j - 50;\\n                        xClone2 -= track[j];\\n                        break;\\n                    } else {\\n                        xClone2 -= track[j];\\n                    }\\n                }\\n            }\\n            if (xClone2 > 0)\\n                res[i + 1] = 0;\\n        }\\n        return res;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449950,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x)\\n    {\\n        var n = nums.Length;\\n        var result = new int[n - k + 1];\\n        var negatives = new List<int>();\\n\\n        InitNegatives(negatives, nums, k);\\n\\n        negatives.Sort();\\n        result[0] = negatives.Count >= x ? negatives[x - 1] : 0;\\n\\n        for (var i = k; i < n; i++)\\n        {\\n            if (nums[i - k] < 0)\\n                negatives.Remove(nums[i - k]);\\n\\n            if (nums[i] < 0)\\n            {\\n                var index = negatives.BinarySearch(nums[i]);\\n\\n                if (index < 0)\\n                    index = ~index;\\n\\n                negatives.Insert(index, nums[i]);\\n            }\\n\\n            result[i - k + 1] = negatives.Count >= x ? negatives[x - 1] : 0;\\n        }\\n\\n        return result;\\n    }\\n\\n    private static void InitNegatives(List<int> negatives, int[] nums, int k)\\n    {\\n        for (var i = 0; i < k; i++)\\n            if (nums[i] < 0)\\n                negatives.Add(nums[i]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x)\\n    {\\n        var n = nums.Length;\\n        var result = new int[n - k + 1];\\n        var negatives = new List<int>();\\n\\n        InitNegatives(negatives, nums, k);\\n\\n        negatives.Sort();\\n        result[0] = negatives.Count >= x ? negatives[x - 1] : 0;\\n\\n        for (var i = k; i < n; i++)\\n        {\\n            if (nums[i - k] < 0)\\n                negatives.Remove(nums[i - k]);\\n\\n            if (nums[i] < 0)\\n            {\\n                var index = negatives.BinarySearch(nums[i]);\\n\\n                if (index < 0)\\n                    index = ~index;\\n\\n                negatives.Insert(index, nums[i]);\\n            }\\n\\n            result[i - k + 1] = negatives.Count >= x ? negatives[x - 1] : 0;\\n        }\\n\\n        return result;\\n    }\\n\\n    private static void InitNegatives(List<int> negatives, int[] nums, int k)\\n    {\\n        for (var i = 0; i < k; i++)\\n            if (nums[i] < 0)\\n                negatives.Add(nums[i]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449712,
                "title": "java-javascript-sliding-window-with-counting-table-counting-sort",
                "content": "### Brute Force, O(n^2), TLE\\n#### Javascript\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} x\\n * @return {number[]}\\n */\\nvar getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    const res = [];\\n    for(let i = 0; i <= n - k; i++){\\n        const list = [];\\n        for(let j = i; j - i + 1 <= k; j++){\\n            list.push(nums[j]);\\n        }\\n        list.sort((a, b) => a - b);\\n        res.push(list[x - 1] > 0 ? 0 : list[x - 1]);\\n    }\\n    return res;\\n};\\n\\n// 0 1 2 3 4 5\\n// X X X X X X\\n//   i     j\\n```\\n\\n---\\n\\nIf you have done a similar problem before, you might immediately think of using maxHeap to maintain size == x to find the xth smallest integer.\\nHere is the list of problems that I have done before. \\n\\n(Medium)\\n[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)\\n[378.\\xA0Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\\n[2583.\\xA0Kth Largest Sum in a Binary Tree (Weekly Contest 335)](https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/)\\n\\n(Hard)\\n[295.\\xA0Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)\\n\\nOf course, if you have more question lists about it, down below your question list is welcome.\\n\\n---\\n\\nOK, come back to the problem.\\n\\nIf we use the sliding window method together when we need to remove the left pointer of the window, we cannot efficiently find a specific number in the heap, which need O(n) time to find, we also get TLE result.\\n\\nHow can we solve this? We can discover the constraints and conditions, `-50 <= nums[i] <= 50`, the range of value is too small, then we can try to use the counting table to calculate the frequency of number in the current window.\\n\\n\\n```\\nindex   =      0   1   2 ... 49  50  51  52\\ncnt     =    [ 0,  0,  0,     0,  0,  0,  0 ]  => size == 101\\nnums[i] =>   -50 -49 -48 ... -1   0   1   2\\n```\\n\\nThen, we don\\'t need to consider the positive number. So, just open the 51 sizes.\\n```\\nindex   =      0   1   2 ... 49  50\\ncnt     =    [ 0,  0,  0,     0,  0 ]  => size == 51\\nnums[i] =>   -50 -49 -48 ... -1   0\\n```\\n\\nNow we can add and remove the number really efficiently, we only traverse the counting table to calculate xth smallest integer.\\n\\n---\\n### **Solution**\\n\\n#### Javascript\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} x\\n * @return {number[]}\\n */\\nvar getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    // Build counting table, we don\\'t need to consider the positive number.\\n    // So, just open the 51 sizes.\\n    const cnt = new Array(51).fill(0);  \\n    const res = [];\\n    let j = 0;\\n    for(let i = 0; i <= n - k; i++){\\n        // window size of k\\n        while(j < n && j - i + 1 <= k){\\n            if(nums[j] <= 0){\\n                cnt[nums[j] + 50]++;\\n            }\\n            j++;\\n        }\\n        \\n        // Search and calculate the number of xth smallest in the counting table, \\n        // If we found, add the current index key into the result.\\n        let numberOf = 0;\\n        for(let key = 0; key < 51; key++){\\n            numberOf += cnt[key];\\n            if(numberOf >= x || key === 50){\\n                res.push(key - 50); // Restore to the original number.\\n                break;\\n            }\\n        }\\n        \\n        // remove the left side\\'s number of the window.\\n        if(nums[i] <= 0) cnt[nums[i] + 50]--;\\n    }\\n    return res;\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n#### Java\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] cnt = new int[51];\\n        int[] res = new int[n - k + 1];\\n        int index = 0, j = 0;\\n        \\n        for(int i = 0; i <= n - k; i++){\\n            while(j < n && j - i + 1 <= k){\\n                if(nums[j] <= 0){\\n                    cnt[nums[j] + 50]++;\\n                }\\n                j++;\\n            }\\n            \\n            int numberOf = 0;\\n            for(int key = 0; key < 51; key++){\\n                numberOf += cnt[key];\\n                if(numberOf >= x || key == 50){\\n                    res[index++] = key - 50;\\n                    break;\\n                }\\n            }\\n            \\n            if(nums[i] <= 0) cnt[nums[i] + 50]--;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n* Time : O(51n) --> O(n)\\n* Space : O(51)  --> O(1)",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Counting"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} x\\n * @return {number[]}\\n */\\nvar getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    const res = [];\\n    for(let i = 0; i <= n - k; i++){\\n        const list = [];\\n        for(let j = i; j - i + 1 <= k; j++){\\n            list.push(nums[j]);\\n        }\\n        list.sort((a, b) => a - b);\\n        res.push(list[x - 1] > 0 ? 0 : list[x - 1]);\\n    }\\n    return res;\\n};\\n\\n// 0 1 2 3 4 5\\n// X X X X X X\\n//   i     j\\n```\n```\\nindex   =      0   1   2 ... 49  50  51  52\\ncnt     =    [ 0,  0,  0,     0,  0,  0,  0 ]  => size == 101\\nnums[i] =>   -50 -49 -48 ... -1   0   1   2\\n```\n```\\nindex   =      0   1   2 ... 49  50\\ncnt     =    [ 0,  0,  0,     0,  0 ]  => size == 51\\nnums[i] =>   -50 -49 -48 ... -1   0\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} x\\n * @return {number[]}\\n */\\nvar getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    // Build counting table, we don\\'t need to consider the positive number.\\n    // So, just open the 51 sizes.\\n    const cnt = new Array(51).fill(0);  \\n    const res = [];\\n    let j = 0;\\n    for(let i = 0; i <= n - k; i++){\\n        // window size of k\\n        while(j < n && j - i + 1 <= k){\\n            if(nums[j] <= 0){\\n                cnt[nums[j] + 50]++;\\n            }\\n            j++;\\n        }\\n        \\n        // Search and calculate the number of xth smallest in the counting table, \\n        // If we found, add the current index key into the result.\\n        let numberOf = 0;\\n        for(let key = 0; key < 51; key++){\\n            numberOf += cnt[key];\\n            if(numberOf >= x || key === 50){\\n                res.push(key - 50); // Restore to the original number.\\n                break;\\n            }\\n        }\\n        \\n        // remove the left side\\'s number of the window.\\n        if(nums[i] <= 0) cnt[nums[i] + 50]--;\\n    }\\n    return res;\\n};\\n```\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] cnt = new int[51];\\n        int[] res = new int[n - k + 1];\\n        int index = 0, j = 0;\\n        \\n        for(int i = 0; i <= n - k; i++){\\n            while(j < n && j - i + 1 <= k){\\n                if(nums[j] <= 0){\\n                    cnt[nums[j] + 50]++;\\n                }\\n                j++;\\n            }\\n            \\n            int numberOf = 0;\\n            for(int key = 0; key < 51; key++){\\n                numberOf += cnt[key];\\n                if(numberOf >= x || key == 50){\\n                    res[index++] = key - 50;\\n                    break;\\n                }\\n            }\\n            \\n            if(nums[i] <= 0) cnt[nums[i] + 50]--;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449690,
                "title": "python3-sliding-window-and-sorted-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        from sortedcontainers import SortedList\\n        # created a sorted list , with first k elements from nums\\n        s=SortedList()\\n        for i in range(k):\\n            s.add(nums[i])\\n\\n        # append xth smallest number to ans if it is negative, else append 0\\n        # using x-1 since zero based index\\n        if s[x-1] < 0:\\n            ans.append(s[x-1])\\n        else:\\n            ans.append(0)\\n        \\n        # right shift our sliding window by,\\n        # 1. remove nums[i-k] \\n        # 2. add nums[i]\\n        for i in range(k, len(nums)):\\n            s.remove(nums[i-k])\\n            s.add(nums[i])\\n            # append xth smallest number to ans if it is negative, else append 0\\n            if s[x-1] < 0:\\n                ans.append(s[x-1])\\n            else:\\n                ans.append(0)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        from sortedcontainers import SortedList\\n        # created a sorted list , with first k elements from nums\\n        s=SortedList()\\n        for i in range(k):\\n            s.add(nums[i])\\n\\n        # append xth smallest number to ans if it is negative, else append 0\\n        # using x-1 since zero based index\\n        if s[x-1] < 0:\\n            ans.append(s[x-1])\\n        else:\\n            ans.append(0)\\n        \\n        # right shift our sliding window by,\\n        # 1. remove nums[i-k] \\n        # 2. add nums[i]\\n        for i in range(k, len(nums)):\\n            s.remove(nums[i-k])\\n            s.add(nums[i])\\n            # append xth smallest number to ans if it is negative, else append 0\\n            if s[x-1] < 0:\\n                ans.append(s[x-1])\\n            else:\\n                ans.append(0)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1871468,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872730,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872389,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872061,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872592,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872035,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871801,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871441,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 2018090,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1972216,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871468,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872730,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872389,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872061,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872592,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872035,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871801,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871441,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 2018090,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1972216,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1963849,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1873927,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1872141,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871938,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871711,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871650,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871617,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871587,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871576,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871563,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            }
        ]
    }
]