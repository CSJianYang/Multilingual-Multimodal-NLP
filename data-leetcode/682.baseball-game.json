[
    {
        "title": "Remove Linked List Elements",
        "question_content": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,6,3,4,5,6], val = 6\nOutput: [1,2,3,4,5]\n\nExample 2:\n\nInput: head = [], val = 1\nOutput: []\n\nExample 3:\n\nInput: head = [7,7,7,7], val = 7\nOutput: []\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [0, 104].\n\t1 <= Node.val <= 50\n\t0 <= val <= 50",
        "solutions": [
            {
                "id": 57306,
                "title": "3-line-recursive-solution",
                "content": "    public ListNode removeElements(ListNode head, int val) {\\n            if (head == null) return null;\\n            head.next = removeElements(head.next, val);\\n            return head.val == val ? head.next : head;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public ListNode removeElements(ListNode head, int val) {\\n            if (head == null) return null;\\n            head.next = removeElements(head.next, val);\\n            return head.val == val ? head.next : head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 158651,
                "title": "simple-python-solution-with-explanation-single-pointer-dummy-head",
                "content": "Before writing any code, it\\'s good to make a list of edge cases that we need to consider. This is so that we can be certain that we\\'re not overlooking anything while coming up with our algorithm, and that we\\'re testing all special cases when we\\'re ready to test. These are the edge cases that I came up with.\\n\\n1. The linked list is empty, i.e. the head node is None.\\n2. Multiple nodes with the target value in a row. \\n3. The head node has the target value.\\n4. The head node, and any number of nodes immediately after it have the target value.\\n5. All of the nodes have the target value.\\n6. The last node has the target value.\\n\\nSo with that, this is the algorithm I came up with.\\n\\n```\\nclass Solution:\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        dummy_head = ListNode(-1)\\n        dummy_head.next = head\\n        \\n        current_node = dummy_head\\n        while current_node.next != None:\\n            if current_node.next.val == val:\\n                current_node.next = current_node.next.next\\n            else:\\n                current_node = current_node.next\\n                \\n        return dummy_head.next\\n```\\n\\nIn order to save the need to treat the \"head\" as special, the algorithm uses a \"dummy\" head. This simplifies the code greatly, particularly in the case of needing to remove the head AND some of the nodes immediately after it.\\n\\nThen, we keep track of the current node we\\'re up to, and look ahead to its next node, as long as it exists. If ```current_node.next``` does need removing, then we simply replace it with ```current_node.next.next```. We know this is always \"safe\", because ```current_node.next``` is definitely not None (the loop condition ensures that), so we can safely access its ```next```.\\n\\nOtherwise, we know that ```current_node.next``` should be kept, and so we move ```current_node``` on to be ```current_node.next```.\\n\\nThe loop condition only needs to check that ```current_node.next != None```. The reason it does **not** need to check that ```current_node != None``` is because this is an impossible state to reach. Think about it this way: The ONLY case that we ever do ```current_node = current_node.next``` in is immediately after the loop has already confirmed that ```current_node.next``` is not None. \\n\\nThe algorithm requires ***```O(1)```*** extra space and takes ***```O(n)```*** time.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        dummy_head = ListNode(-1)\\n        dummy_head.next = head\\n        \\n        current_node = dummy_head\\n        while current_node.next != None:\\n            if current_node.next.val == val:\\n                current_node.next = current_node.next.next\\n            else:\\n                current_node = current_node.next\\n                \\n        return dummy_head.next\\n```\n```current_node.next```\n```current_node.next.next```\n```current_node.next```\n```next```\n```current_node.next```\n```current_node```\n```current_node.next```\n```current_node.next != None```\n```current_node != None```\n```current_node = current_node.next```\n```current_node.next```\n```O(1)```\n```O(n)```",
                "codeTag": "Java"
            },
            {
                "id": 1572932,
                "title": "java-three-simple-clean-solutions-w-explanation-iterative-recursive-beats-100",
                "content": "*<ins>Note:</ins> Kindly upvote if you find this article helpful. Thanks for reading!*\\n\\nThis is a fundamental Linked List Traversal question.\\nIn optimized solutions, we will remove the nodes with the value same as the input `val` while traversing the list.\\n\\nThere are three ways we can solve this question:\\n- Iterative Solution without using a Previous Pointer\\n- Iterative Solution using a Previous Pointer\\n- Recursive Solution (This solution requires extra auxiliary space for saving the recursion stack)\\n\\n---\\n\\u2714\\uFE0F **Approach 1: Iterative Solution without using a Previous Pointer**\\n\\nIn this solution, we create a `dummy` node and set `dummy.next = head`. This node helps us keep track of the new head in case the existing `head` has to be removed.\\nSince we are not using a previous pointer, we will set the current (`cur`) node to the `dummy` node.\\nThe list on the left side, including the `cur` node, has been solved. We now need to solve the list on the right side of the `cur` node.\\n\\nWe will check the following two conditions while iterating over the list:\\n- If `cur.next.val == val`, then we will remove the cur.next node by setting `cur.next = cur.next.next`. Please note, we will not move the current pointer in this step as new `cur.next` has not be validated yet.\\n- If `cur.next.val != val`, then we can safely move the `cur` pointer to next node, as next node is a valid node. `cur = cur.next`.\\n\\n**Time Complexity:** `O(N)` --> Each Node in the list is visited once.\\n**Space Complexity:** `O(1)` --> Contant space is used for this solution\\n*Where, N = Length of the input list.*\\n\\n**Example to understand this solution**\\nInput LinkedList: `[2, 3, 1, 2, 2]`\\nIn this input Linked List we are removing the value `2`.\\n\\n![image](https://assets.leetcode.com/users/images/5e44c980-9079-49a8-af15-1a7088b21d02_1636679350.0082548.png)\\n\\n```java\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode cur = dummy;\\n\\n        while (cur.next != null) {\\n            if (cur.next.val == val) {\\n                cur.next = cur.next.next;\\n                // Here cannot move cur to cur.next as we need to validate the next node.\\n            } else {\\n                cur = cur.next;\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n---\\n\\u2714\\uFE0F **Approach 2: Iterative Solution using a Previous Pointer**\\n\\nSame as in the previous solution, we create a `dummy` node and set `dummy.next = head`. This node helps us keep track of the new head in case the existing `head` has to be removed.\\nWe will initialize, `prev` node to `dummy` node and `cur` node to `head` node. \\nThe list on the left side, including the `prev` node, has been solved. We now need to solve the list starting from the `cur` node.\\n\\nWe will check the following two conditions while iterating over the list:\\n- If `cur.val == val`, then we will remove the cur node by setting `prev.next = cur.next`.\\n- If `cur.val != val`, then we can safely move the `prev` pointer to `cur` node, as `cur` node is a valid node. `prev = cur`.\\n\\n**Time Complexity:** `O(N)` --> Each Node in the list is visited once.\\n**Space Complexity:** `O(1)` --> Contant space is used for this solution\\n*Where, N = Length of the input list.*\\n\\n```java\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode cur = head;\\n        ListNode prev = dummy;\\n\\n        while (cur != null) {\\n            if (cur.val == val) {\\n                prev.next = cur.next;\\n            } else {\\n                prev = cur;\\n            }\\n            cur = cur.next;\\n        }\\n\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n---\\n\\n\\u2714\\uFE0F **Approach 3: Recursive Solution**\\n\\nIn this solution, `removeElements` function returns the head of the solved list (nodes with `val` are removed).\\nOnce we get the solved `rightSideHead` from the recursion call, `rightSideHead` node will point to the solved list.\\nNow, we have two choices:\\n- If `head.val == val` --> Current node needs to be removed, so return the `rightSideHead` as it points to the solved rigth side list.\\n- If `head.val != val` --> Update the next pointer of current list, as the next node might have been removed. And then return the current node.\\n\\n**Time Complexity:** `O(N)` --> Each Node in the list is visited once.\\n**Space Complexity:** `O(N)` --> Recursion Stack space\\n*Where, N = Length of the input list.*\\n\\n```java\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        // Once removeElements call is done, right side of the list is solved.\\n        ListNode rightSideHead = removeElements(head.next, val);\\n        if (head.val == val) {\\n            return rightSideHead;\\n        }\\n        head.next = rightSideHead;\\n        return head;\\n    }\\n}\\n```\\n\\n---\\n\\n**<ins>Similar Linked List questions on LeetCode:</ins>**\\n\\n- [27. Remove Element](https://leetcode.com/problems/remove-element/)\\n- [237. Delete Node in a Linked List](https://leetcode.com/problems/delete-node-in-a-linked-list/)\\n- [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)\\n- [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)\\n- [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)\\n- [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)\\n- [445. Add Two Numbers II](https://leetcode.com/problems/add-two-numbers-ii/)\\n- [25. Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)\\n- [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\\n- [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode cur = dummy;\\n\\n        while (cur.next != null) {\\n            if (cur.next.val == val) {\\n                cur.next = cur.next.next;\\n                // Here cannot move cur to cur.next as we need to validate the next node.\\n            } else {\\n                cur = cur.next;\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode cur = head;\\n        ListNode prev = dummy;\\n\\n        while (cur != null) {\\n            if (cur.val == val) {\\n                prev.next = cur.next;\\n            } else {\\n                prev = cur;\\n            }\\n            cur = cur.next;\\n        }\\n\\n        return dummy.next;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        // Once removeElements call is done, right side of the list is solved.\\n        ListNode rightSideHead = removeElements(head.next, val);\\n        if (head.val == val) {\\n            return rightSideHead;\\n        }\\n        head.next = rightSideHead;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57324,
                "title": "ac-java-solution",
                "content": "    public class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            ListNode fakeHead = new ListNode(-1);\\n            fakeHead.next = head;\\n            ListNode curr = head, prev = fakeHead;\\n            while (curr != null) {\\n                if (curr.val == val) {\\n                    prev.next = curr.next;\\n                } else {\\n                    prev = prev.next;\\n                }\\n                curr = curr.next;\\n            }\\n            return fakeHead.next;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            ListNode fakeHead = new ListNode(-1);\\n            fakeHead.next = head;\\n            ListNode curr = head, prev = fakeHead;\\n            while (curr != null) {\\n                if (curr.val == val) {\\n                    prev.next = curr.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 722528,
                "title": "c-2-solutions-with-single-pointer-with-double-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n\\t\\tApproach: 1\\n        Solving the problem using two pointers: previous and current.\\n        Time: 28 ms\\n\\t */\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==nullptr) return head;\\n        while(head!=nullptr && head->val==val){\\n            head = head->next;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        while(curr!=nullptr){\\n            if(curr->val==val){\\n                prev->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;        \\n            }\\n        }\\n        return head;\\n    }\\n    \\n    /*\\n\\t\\tApproach: 2\\n        Solving the problem using a single pointer: current.\\n        Time: 20 ms\\n    */\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==nullptr) return head;\\n\\t\\t// This is for the case when a linked list is like this: \\n\\t\\t// 1->1->2->null , val = 1\\n\\t\\t// 1->1->1->null , val = 1\\n        while(head!=nullptr && head->val==val){\\n            head = head->next;\\n        }\\n        ListNode* curr = head;\\n        while(curr!=nullptr  && curr->next!=nullptr){\\n            if(curr->next->val==val){\\n                curr->next = curr->next->next;\\n\\t\\t\\t\\t// After doing the above step, I am not updating \"curr\" because of these type of test cases:\\n\\t\\t\\t\\t// 1->2->3->6->6->6->5->null  val = 6\\n            }\\n            else\\n                curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n\\n```\\nFeel free to ask any doubts in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n\\t\\tApproach: 1\\n        Solving the problem using two pointers: previous and current.\\n        Time: 28 ms\\n\\t */\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==nullptr) return head;\\n        while(head!=nullptr && head->val==val){\\n            head = head->next;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        while(curr!=nullptr){\\n            if(curr->val==val){\\n                prev->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;        \\n            }\\n        }\\n        return head;\\n    }\\n    \\n    /*\\n\\t\\tApproach: 2\\n        Solving the problem using a single pointer: current.\\n        Time: 20 ms\\n    */\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==nullptr) return head;\\n\\t\\t// This is for the case when a linked list is like this: \\n\\t\\t// 1->1->2->null , val = 1\\n\\t\\t// 1->1->1->null , val = 1\\n        while(head!=nullptr && head->val==val){\\n            head = head->next;\\n        }\\n        ListNode* curr = head;\\n        while(curr!=nullptr  && curr->next!=nullptr){\\n            if(curr->next->val==val){\\n                curr->next = curr->next->next;\\n\\t\\t\\t\\t// After doing the above step, I am not updating \"curr\" because of these type of test cases:\\n\\t\\t\\t\\t// 1->2->3->6->6->6->5->null  val = 6\\n            }\\n            else\\n                curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57323,
                "title": "iterative-short-java-solution",
                "content": "Hi guys!\\n\\nHere's an iterative solution without dummy head. \\nFirst, we shift a head of a list while its' value equals to val. \\nThen, we iterate through the nodes of the list checking if the next node's value equals to val and removing it if needed.  \\n\\n----------\\n\\n    public class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            while (head != null && head.val == val) head = head.next;\\n            ListNode curr = head;\\n            while (curr != null && curr.next != null)\\n                if (curr.next.val == val) curr.next = curr.next.next;\\n                else curr = curr.next;\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            while (head != null && head.val == val) head = head.next;\\n            ListNode curr = head;\\n            while (curr != null && curr.next != null)\\n                if (curr.next.val == val) curr.next = curr.next.next;\\n                else curr = curr.next;\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 57331,
                "title": "accepted-7-line-clean-java-solution",
                "content": "    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        ListNode pointer = head;\\n        while (pointer.next != null) {\\n            if (pointer.next.val == val) pointer.next = pointer.next.next;\\n            else pointer = pointer.next;\\n        }\\n        return head.val == val ? head.next : head;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        ListNode pointer = head;\\n        while (pointer.next != null) {\\n            if (pointer.next.val == val) pointer.next = pointer.next.next;\\n            else pointer = pointer.next;\\n        }\\n        return head.val == val ? head.next : head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1572892,
                "title": "c-python-clean-simple-solution-w-explanation-illustration-iterative-recursive",
                "content": "We are given a Linked List\\'s head pointer `head` and a target value `T`. All the nodes having value as `T` need to be deleted.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Iterative using Dummy node)***\\n\\nA simple solution to delete the nodes having value `T` is to traverse over the linked list and just remove the next pointers to the node having value as `T`. Now, usually in deletion problem of linked list, there can be multiple cases where node to be deleted is either a head node or other node in rest of list. We usually make use of a dummy node at the start or **[sentinel node](https://en.wikipedia.org/wiki/Sentinel_node)** to avoid handling multiple edge cases and write a clean uniform solution.\\n\\nSo, the algorithm we are using can be summarised as -\\n\\n1. Initialize a dummy/sentinel node having its next pointer pointing to the `head` of linked list and another node pointer  `prev` pointing to this dummy node.\\n2. Start iterating over `head` of linked list\\n3. If current node\\'s value is not equal to `T`, we can just move to next node without deleting current node. In this case, \\n\\t* We first update `prev` pointer and point it to current `head`\\n\\t* Then move `head` to next node.\\n4. Otherwise, if **`head -> val == T`**, we know that this **node needs to be deleted**. In this case, \\n\\t* We can just **update the next pointer of previous node to the next pointer of current node**. This will basically remove the current node from list. \\n\\t* Then, we update head to its next node just as in previous case.\\n5. Finally, ignore the dummy node created at start and return its next node.\\n\\n**\\uD83D\\uDCDD Dry Run on Example -**\\n\\n```\\nFor eg. let the list be 1 -> 2 -> 1 -> 4  -> 7  -> 1, and T = 1.\\n                                                                         // dummy and prev initialized pointing to list head\\n 1. -1   \\u2192   1   \\u2192    2   \\u2192   1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null       // head == T, update prev pointer to head\\'s next\\n   ^dummy    ^head                                                       // and move head to next\\n   ^prev\\n => Now traverse till head reaches end\\n \\n     \\u21B1    \\u2192     \\u2192    \\u21B4\\n 2. -1      1   \\u2192    2   \\u2192   1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head != T, just update prev and move head to next\\n\\t^dummy           ^head                                             \\n\\t^prev\\n\\t\\t\\t\\t\\t\\t\\n     \\u21B1    \\u2192     \\u2192    \\u21B4\\n 3. -1      1   \\u2192    2   \\u2192   1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head == T, update prev pointer to head\\'s next\\n\\t^dummy           ^prev   ^head                                       // and move head to next\\n\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4\\n 4. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head != T, just update prev and move head to next\\n\\t^dummy           ^prev           ^head\\n\\t\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4\\n 5. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head != T, just update prev and move head to next\\n\\t^dummy                           ^prev   ^head\\t\\n\\t\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4\\n 6. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head == T, update prev pointer to head\\'s next\\n\\t^dummy                                   ^prev   ^head\\t\\t         // and move head to next\\n\\t\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4       \\u21B1    \\u2192     \\u2192    \\u21B4\\n 7. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7       1   \\u2192   null\\n\\t^dummy                                   ^prev            ^head       // Stop iteration as head = null\\t\\n\\t\\n\\t\\nFinal List = dummy -> next\\n\\t  \\uD83D\\uDC49  2   ->    4   ->   7   ->   null\\n\\n```\\n\\nThe above code will elegantly handle both cases of either head is to be deleted or some other node is to be deleted without needing to do any extra checks in code.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int T) {\\n        ListNode *dummy = new ListNode(-1, head), *prev = dummy;\\n        for(;head; head = head -> next) \\n            if(head -> val != T) \\n                prev = head;                       // just update prev node\\n            else                                   // current node needs to be deleted\\n\\t\\t\\t\\tprev -> next = head -> next;       // just update next of prev to next of current so that current node is removed from list\\n        return dummy -> next;                     \\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def removeElements(self, head, T):\\n        dummy = ListNode(-1, head)\\n        prev = dummy\\n        while head:\\n            if head.val != T:\\n                prev = head\\n            else:\\n                prev.next = head.next\\n            head = head.next\\n        return dummy.next\\n```\\n\\n***Time Complexity :*** **<code>O(N)</code>**, where `N` is the number of nodes in the given linked list. We are just iterating over the linked list once.\\n***Space Complexity :*** **`O(1)`**, only constant extra space is being used.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive)***\\n\\nThe recursive implementation can be shorter but requires `O(N)` space. In this approach, we will use a top-down approach. First, we go down till the end of the list and start deleting from there on our way back to the head node. Each time, we delete the current node if it\\'s value is equal to `T` by returning its next node. Otherwise, we need to keep the current, so we can just return it.\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int T) {\\n        if(!head) return nullptr;\\n        head -> next = removeElements(head -> next, T);\\n        return head -> val == T ? head -> next : head;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def removeElements(self, head, T):\\n        if not head: return None\\n        head.next = self.removeElements(head.next, T);\\n        return head.next if head.val == T else head\\n```\\n\\n***Time Complexity :*** **<code>O(N)</code>** We are just iterating over the linked list once.\\n***Space Complexity :*** **`O(N)`**, required by implicit recursive stack\\n\\n---\\n\\n**Note :** The Problem only asks us to **remove the node from the linked list and not delete it.** A good question to ask in an interview for this problem would be whether we just need to remove the node from linked list or completely delete it from the memory. Since it has not been stated in this problem if the node is required somewhere else later on, its better to just remove the node from linked list as asked.\\n\\nIf we want to delete the node altogether, then we can just free its memory and point it to NULL before returning from the function.\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```\\nFor eg. let the list be 1 -> 2 -> 1 -> 4  -> 7  -> 1, and T = 1.\\n                                                                         // dummy and prev initialized pointing to list head\\n 1. -1   \\u2192   1   \\u2192    2   \\u2192   1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null       // head == T, update prev pointer to head\\'s next\\n   ^dummy    ^head                                                       // and move head to next\\n   ^prev\\n => Now traverse till head reaches end\\n \\n     \\u21B1    \\u2192     \\u2192    \\u21B4\\n 2. -1      1   \\u2192    2   \\u2192   1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head != T, just update prev and move head to next\\n\\t^dummy           ^head                                             \\n\\t^prev\\n\\t\\t\\t\\t\\t\\t\\n     \\u21B1    \\u2192     \\u2192    \\u21B4\\n 3. -1      1   \\u2192    2   \\u2192   1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head == T, update prev pointer to head\\'s next\\n\\t^dummy           ^prev   ^head                                       // and move head to next\\n\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4\\n 4. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head != T, just update prev and move head to next\\n\\t^dummy           ^prev           ^head\\n\\t\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4\\n 5. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head != T, just update prev and move head to next\\n\\t^dummy                           ^prev   ^head\\t\\n\\t\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4\\n 6. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head == T, update prev pointer to head\\'s next\\n\\t^dummy                                   ^prev   ^head\\t\\t         // and move head to next\\n\\t\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4       \\u21B1    \\u2192     \\u2192    \\u21B4\\n 7. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7       1   \\u2192   null\\n\\t^dummy                                   ^prev            ^head       // Stop iteration as head = null\\t\\n\\t\\n\\t\\nFinal List = dummy -> next\\n\\t  \\uD83D\\uDC49  2   ->    4   ->   7   ->   null\\n\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int T) {\\n        ListNode *dummy = new ListNode(-1, head), *prev = dummy;\\n        for(;head; head = head -> next) \\n            if(head -> val != T) \\n                prev = head;                       // just update prev node\\n            else                                   // current node needs to be deleted\\n\\t\\t\\t\\tprev -> next = head -> next;       // just update next of prev to next of current so that current node is removed from list\\n        return dummy -> next;                     \\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def removeElements(self, head, T):\\n        dummy = ListNode(-1, head)\\n        prev = dummy\\n        while head:\\n            if head.val != T:\\n                prev = head\\n            else:\\n                prev.next = head.next\\n            head = head.next\\n        return dummy.next\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int T) {\\n        if(!head) return nullptr;\\n        head -> next = removeElements(head -> next, T);\\n        return head -> val == T ? head -> next : head;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def removeElements(self, head, T):\\n        if not head: return None\\n        head.next = self.removeElements(head.next, T);\\n        return head.next if head.val == T else head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572902,
                "title": "c-java-python-simple-recursive-iterative-solutions-novemberchallenge",
                "content": "This is my first ever post :)\\n\\nThis is an interesting and fairly simple Linked List problem which can be elegantly solved using both recursion and iteration. \\n\\nFirst let us discuss the **iterative approach**.\\nHere, I create a *dummy* node which acts as the predecessor to head itself. This trick is used in many Linked List problems to avoid checking for edge cases when dealing with the first node. Then I initialize a starting node *curr* equal to the *dummy* node. The thing to note here is that in each iteration, I check if the *next* node to *curr* has a value equal to the given *val*. This is done so that if that is the case, we can skip that node all together by setting *curr.next = curr.next.next*. If that isn\\'t the case, then we simply move *curr* forward. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode;\\n        dummy -> next = head;\\n        ListNode* curr = dummy;\\n        \\n        while(curr -> next) {\\n            if(curr -> next -> val == val) {\\n                curr -> next = curr -> next -> next;\\n            } else {\\n                curr = curr -> next;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode curr = dummy;\\n        \\n        while(curr.next != null) {\\n            if(curr.next.val == val) {\\n                curr.next = curr.next.next;\\n            } else {\\n                curr = curr.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        dummy.next = head\\n        curr = dummy\\n        while curr.next:\\n            if curr.next.val == val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return dummy.next\\n```\\n\\n\\nMoving on to the **recursive approach.**\\nRecursion makes the code more self explanatory as it is only required to check the current element. If *head.val* is equal to the given *val*, then we can simply call recursion on *head.next* and return that (this is essentially deleting head). If it isn\\'t, then we set the value of *head.next* equal to the what is returned by recursion when called on *head.next* and return head.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(!head)\\n            return head;\\n        ListNode* newNext = removeElements(head -> next, val);\\n        if(head -> val == val) {\\n            return newNext;\\n        } else {\\n            head -> next = newNext;\\n            return head;\\n        }\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head == null)\\n            return head;\\n        ListNode newNext = removeElements(head.next, val);\\n        if(head.val == val) {\\n            return newNext;\\n        } else {\\n            head.next = newNext;\\n            return head;\\n        }\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head == None:\\n            return head\\n        \\n        newNext = self.removeElements(head.next, val)\\n        if head.val == val:\\n            return newNext\\n        else:\\n            head.next = newNext\\n            return head\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode;\\n        dummy -> next = head;\\n        ListNode* curr = dummy;\\n        \\n        while(curr -> next) {\\n            if(curr -> next -> val == val) {\\n                curr -> next = curr -> next -> next;\\n            } else {\\n                curr = curr -> next;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode curr = dummy;\\n        \\n        while(curr.next != null) {\\n            if(curr.next.val == val) {\\n                curr.next = curr.next.next;\\n            } else {\\n                curr = curr.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        dummy.next = head\\n        curr = dummy\\n        while curr.next:\\n            if curr.next.val == val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return dummy.next\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(!head)\\n            return head;\\n        ListNode* newNext = removeElements(head -> next, val);\\n        if(head -> val == val) {\\n            return newNext;\\n        } else {\\n            head -> next = newNext;\\n            return head;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head == null)\\n            return head;\\n        ListNode newNext = removeElements(head.next, val);\\n        if(head.val == val) {\\n            return newNext;\\n        } else {\\n            head.next = newNext;\\n            return head;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head == None:\\n            return head\\n        \\n        newNext = self.removeElements(head.next, val)\\n        if head.val == val:\\n            return newNext\\n        else:\\n            head.next = newNext\\n            return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57317,
                "title": "simple-and-elegant-solution-in-c",
                "content": "```c++\\nListNode *removeElements(ListNode *head, int val) {\\n\\tListNode **list = &head;\\n\\n\\twhile (*list != nullptr) {\\n\\t\\tif ((*list)->val == val) {\\n\\t\\t    // You can free `*list` here if you know how it is allocated.\\n\\t\\t\\t*list = (*list)->next;\\n\\t\\t} else {\\n\\t\\t\\tlist = &(*list)->next;\\n\\t\\t}\\n\\t}\\n\\n\\treturn head;\\n}\\n```\\n\\nOriginal tail recursive version:\\n\\n```c++\\nvoid removeHelper(ListNode *&list, int val) {\\n\\tif (list != nullptr) {\\n\\t\\tif (list->val == val) {\\n\\t\\t    // You can free `list` here if you know how it is allocated.\\n\\t\\t\\tlist = list->next;\\n\\t\\t\\tremoveHelper(list, val);\\n\\t\\t} else {\\n\\t\\t\\tremoveHelper(list->next, val);\\n\\t\\t}\\n\\t}\\n}\\n\\nListNode *removeElements(ListNode *head, int val) {\\n\\tremoveHelper(head, val);\\n\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```c++\\nListNode *removeElements(ListNode *head, int val) {\\n\\tListNode **list = &head;\\n\\n\\twhile (*list != nullptr) {\\n\\t\\tif ((*list)->val == val) {\\n\\t\\t    // You can free `*list` here if you know how it is allocated.\\n\\t\\t\\t*list = (*list)->next;\\n\\t\\t} else {\\n\\t\\t\\tlist = &(*list)->next;\\n\\t\\t}\\n\\t}\\n\\n\\treturn head;\\n}\\n```\n```c++\\nvoid removeHelper(ListNode *&list, int val) {\\n\\tif (list != nullptr) {\\n\\t\\tif (list->val == val) {\\n\\t\\t    // You can free `list` here if you know how it is allocated.\\n\\t\\t\\tlist = list->next;\\n\\t\\t\\tremoveHelper(list, val);\\n\\t\\t} else {\\n\\t\\t\\tremoveHelper(list->next, val);\\n\\t\\t}\\n\\t}\\n}\\n\\nListNode *removeElements(ListNode *head, int val) {\\n\\tremoveHelper(head, val);\\n\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 57461,
                "title": "simple-clear-python-solution",
                "content": "First we remove all (if any) target nodes from the beginning (we do it because the removing logic is slightly different from when the node is not in the head). After that we just loop over all nodes, if the next one is one that should be removed, just get it out of the list by moving the next pointer to the next-next node. Otherwise just move along the list.\\n\\n    class Solution(object):\\n        def removeElements(self, head, val):\\n            while head is not None and head.val == val:\\n                head = head.next\\n            current = head\\n            while current is not None:\\n                if current.next is not None and current.next.val == val:\\n                    current.next = current.next.next\\n                else:\\n                    current = current.next\\n            return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "First we remove all (if any) target nodes from the beginning (we do it because the removing logic is slightly different from when the node is not in the head). After that we just loop over all nodes, if the next one is one that should be removed, just get it out of the list by moving the next pointer to the next-next node. Otherwise just move along the list.\\n\\n    class Solution(object):\\n        def removeElements(self, head, val):\\n            while head is not None and head.val == val:\\n                head = head.next\\n            current = head\\n            while current is not None:\\n                if current.next is not None and current.next.val == val:\\n                    current.next = current.next.next\\n                else:\\n                    current = current.next\\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 1572935,
                "title": "python-99-one-pass-solution-with-explanation",
                "content": "### Intuition\\n\\nTo delete a node, we need to assign the next node to the previous node. Let\\'s use `curr` to denote the current node, and `prev` to denote the previous node. Then, we have the following 4 cases:\\n\\n1. **Node to remove is at the end of the linked list.**\\n\\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\t\\t\\tprev curr\\n```\\n\\nSimple enough, we just need to assign `prev.next = None`, since `curr.next == None`. No further action is needed since this is the last node to check.\\n\\n2. **Node to remove is in the middle of the linked list.**\\n\\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\tprev curr\\n```\\n\\nTo remove the node `curr`, we can assign `prev.next = curr.next`, which disconnects `curr` from the linked list completely. In the following iteration, we know that `curr = curr.next`, while `prev` should remain pointing at the same node since `curr` has been removed. So, in summary:\\n\\n- `prev.next = curr.next` to remove the node;\\n- `curr = curr.next` to get the next iteration.\\n\\n3. **Node to remove is at the start of the linked list.**\\n\\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t/   \\\\\\n\\t      prev curr\\n```\\n\\nSince `prev == None`, we don\\'t need to assign `prev.next = curr.next`. However, removing nodes from the beginning of the linked list changes the head node of the linked list, so we need to assign `head = curr.next` before proceeding with the next iteration (as per case 2). In summary:\\n\\n- `head = curr.next` to change the head node;\\n- `curr = curr.next` to get the next iteration.\\n\\n4. **Current node is not to be removed.**\\n\\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t    /   \\\\\\n\\t          prev curr\\n```\\n\\nNothing needs to be done, we just need to proceed with the next iteration. This involves:\\n\\n- `curr = curr.next`, as discussed in cases 2 and 3;\\n- `prev = curr`, since the `curr` node is not removed in this case.\\n\\n---\\n\\n### Implementation\\n\\n- Start with `curr = head` and `prev = None`.\\n- Loop through the linked list and determine which of the 4 cases `curr` and `prev` belong to, and perform the action accordingly.\\n\\n```python\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        prev, curr = None, head\\n        while curr:\\n            if curr.val == val:  # cases 1-3\\n                if prev:  # cases 1-2\\n                    prev.next = curr.next\\n                else:  # case 3\\n                    head = curr.next\\n                curr = curr.next  # for all cases\\n            else:  # case 4\\n                prev, curr = curr, curr.next\\n        return head\\n```\\n\\n---\\n\\n### Final Result\\n\\n**TC: O(n)** where `n` is the number of nodes in the linked list.\\n**SC: O(1)**, no additional data structures were used.\\n\\n![image](https://assets.leetcode.com/users/images/236b8bc3-8262-4153-bd6f-1abc83d95594_1636678776.534016.png)\\n\\nPlease upvote of this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\t\\t\\tprev curr\\n```\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\tprev curr\\n```\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t/   \\\\\\n\\t      prev curr\\n```\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t    /   \\\\\\n\\t          prev curr\\n```\n```python\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        prev, curr = None, head\\n        while curr:\\n            if curr.val == val:  # cases 1-3\\n                if prev:  # cases 1-2\\n                    prev.next = curr.next\\n                else:  # case 3\\n                    head = curr.next\\n                curr = curr.next  # for all cases\\n            else:  # case 4\\n                prev, curr = curr, curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57308,
                "title": "concise-c-solution-with-pseudo-listhead",
                "content": "    class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n            ListNode *pseudo_head = new ListNode(0);\\n            pseudo_head->next = head;\\n            ListNode *cur = pseudo_head;\\n            while(cur){\\n                if(cur->next && cur->next->val == val)   cur->next = cur->next->next;\\n                else    cur = cur->next;\\n            }\\n            return pseudo_head->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n            ListNode *pseudo_head = new ListNode(0);\\n            pseudo_head->next = head;\\n            ListNode *cur = pseudo_head;\\n            while(cur){\\n                if(cur->next && cur->next->val == val)   cur->next = cur->next->next;\\n                else    cur = cur->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1572917,
                "title": "c-easy-intuitive-sol-two-approaches-recursive-and-iterative-simple-code",
                "content": "Hello Everyone! hope you all are doing great.\\n\\n**Approach 1 (Recursive):**\\n1. Here we need to think in a recursive way, so for the **base condition** it is simple: that if the current node in a recursive step is null then we can simply return NULL from that (Think of it as we have given an empty list in the input).\\n\\n2. Now, for the **recursive step**, we need to delete all the nodes that are in the right of our current node that have same value as `val` , so we\\'ll call recursive step on `node->next` so that the recursion will take care of the nodes that are ahead of our current node.\\n\\n3. Now, we only need to take care of our current node in our recursive step and here can be two cases:\\n\\t\\ta: **If current node\\'s value is equal to `val`** , then we will simply return the next of current node i.e. `node->next` as to delete current node we will simply omit this node and never return this node, so it will be lost.\\n\\t\\tb: **If current node\\'s value is NOT equal to `val`** then we want to keep this node in our list, so we will simply return this node itself.\\n\\t\\t\\nNow, below is the code for my appraoch: \\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        // Base Condition\\n        if(!head) return NULL;\\n\\t\\t\\n\\t\\t// Delete the nodes that are on the right of our current node\\n        head->next = removeElements(head->next, val);\\n\\t\\t\\n\\t\\t// Omit current node if this has to be deleted or else keep this node \\n        return (head->val==val)? head->next:head;\\n    }\\n};\\n```\\n**Time Complexity:** It would be ***O(N)*** since we are iterating through every node.\\n**Space Complexity:** It\\'s amortized space complexity should be ***O(N)*** because recursion is using a stack space for every node.\\n\\n\\n**Approach 2 (Iterative):** \\n1. First I will handle the case when our list is like `[D D D S S S S]`, where` D` are the nodes that should be deleted and `S` are the safe node. This can be easily done by moving the head pointer of our list to the very first `S` node and omiting the previous `D` nodes.\\n\\n2. Then we will have a current pointer `cur` to iterate through our list and we will make sure that the nodes in the range from `head` to `cur` pointer are all `S` nodes i.e. safe nodes that need not be deleted.\\n\\n3. So, we will alway check the next of `cur` node that whether it has to be deleted or not, and** if needs to be deleted** then we will simply remove its connections (links) form the `cur` node and **if not need to be deleted** then we will simply move the `cur` pointer forward as it will be a `S` node that is a safe node.\\n\\nBelow is the code for my approach:\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        \\n        // Omit the nodes from the start of list by moving head pointer\\n        // if these nodes have to be deleted\\n        // eg [7, 7, 7, 3] val = 7, then we have to delete all 7 and move head to 3\\n        while(head && head->val == val) head = head->next;\\n        \\n        // Now our head is updated\\n        \\n        // Now we will iterate our linked list using cur pointer\\n        // we surely know that cur is not to be deleted because we came to it\\n        // from the previous loop\\n        ListNode* cur = head;\\n        \\n        // loop through list and always check for next of cur node because we\\n        // know that cur has not to be deleted\\n        while(cur){\\n            \\n            // If the next of cur node is to be deleted\\n            // then point the next pointer of cur node to the next pointer\\n            // of the node that has to be deleted i.e. the next of (next of cur)\\n            if(cur->next && cur->next->val == val)\\n                cur->next = cur->next->next;\\n            \\n            // If next of cur is save and should not be deleted then move cur pointer to it\\n            // Because we want that till cur pointer we have the nodes that need not be deleted\\n            else cur = cur->next;\\n            \\n        }\\n        \\n        // then return the head of our updated list\\n        return head;\\n    }\\n};\\n```\\n\\n**Time Complexity:** ***O(N)*** (Iterating through all nodes)\\n**Space Complexity:** ***O(1)***\\n\\n**Please Upvote \\uD83D\\uDD3C if you liked my solution. It keeps me motivated to make such solution posts!**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        // Base Condition\\n        if(!head) return NULL;\\n\\t\\t\\n\\t\\t// Delete the nodes that are on the right of our current node\\n        head->next = removeElements(head->next, val);\\n\\t\\t\\n\\t\\t// Omit current node if this has to be deleted or else keep this node \\n        return (head->val==val)? head->next:head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        \\n        // Omit the nodes from the start of list by moving head pointer\\n        // if these nodes have to be deleted\\n        // eg [7, 7, 7, 3] val = 7, then we have to delete all 7 and move head to 3\\n        while(head && head->val == val) head = head->next;\\n        \\n        // Now our head is updated\\n        \\n        // Now we will iterate our linked list using cur pointer\\n        // we surely know that cur is not to be deleted because we came to it\\n        // from the previous loop\\n        ListNode* cur = head;\\n        \\n        // loop through list and always check for next of cur node because we\\n        // know that cur has not to be deleted\\n        while(cur){\\n            \\n            // If the next of cur node is to be deleted\\n            // then point the next pointer of cur node to the next pointer\\n            // of the node that has to be deleted i.e. the next of (next of cur)\\n            if(cur->next && cur->next->val == val)\\n                cur->next = cur->next->next;\\n            \\n            // If next of cur is save and should not be deleted then move cur pointer to it\\n            // Because we want that till cur pointer we have the nodes that need not be deleted\\n            else cur = cur->next;\\n            \\n        }\\n        \\n        // then return the head of our updated list\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275445,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function(head, val) {\\n    if (!head) return head;\\n\\t\\n\\t// if head is the value were deleting and if there is any repetition lets handle that case first otherwise we\\'ll just break out of the loop\\n    while(head) {\\n        if(head.val === val) {\\n            head = head.next;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n\\t// skip any nodes whos values match the parameters and set it to the node after\\n\\t// if the node is found, set curr.next to the node after it then try again\\n\\t// otherwise iterate forward\\n    let curr = head;\\n    while(curr && curr.next) {\\n        if (curr.next.val === val) curr.next = curr.next.next;\\n        else curr = curr.next;\\n    }\\n    \\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function(head, val) {\\n    if (!head) return head;\\n\\t\\n\\t// if head is the value were deleting and if there is any repetition lets handle that case first otherwise we\\'ll just break out of the loop\\n    while(head) {\\n        if(head.val === val) {\\n            head = head.next;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n\\t// skip any nodes whos values match the parameters and set it to the node after\\n\\t// if the node is found, set curr.next to the node after it then try again\\n\\t// otherwise iterate forward\\n    let curr = head;\\n    while(curr && curr.next) {\\n        if (curr.next.val === val) curr.next = curr.next.next;\\n        else curr = curr.next;\\n    }\\n    \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 57326,
                "title": "32ms-c-ac-solution",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n            if (head==NULL){\\n                return head;\\n            }\\n            ListNode* p=head;\\n            while(p->next!=NULL){\\n                if (p->next->val == val){\\n                    p->next = p->next->next;\\n                }\\n                else{\\n                    p=p->next;\\n                }\\n            }\\n            if (head->val==val)\\n                head=head->next;\\n            return head;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n            if (head==NULL){\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3136351,
                "title": "c-recursive-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLook through every node of the linked list, joining together the nodes, which don\\'t have to be deleted\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n$$O(n)$$. Since we have to look at each node only once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$. Since we are not storing any additional data.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        //base case, recursion ends when NULL is reached\\n        if (head == NULL) return NULL;\\n\\n        //the node has to be removed -> it is skipped during the iteration\\n        if (head->val == val) return removeElements(head->next, val);\\n\\n        //the node doesn\\'t have to be skipped -> the rest of the list has \\n        //to be joined to the node\\n        head->next = removeElements(head->next, val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        //base case, recursion ends when NULL is reached\\n        if (head == NULL) return NULL;\\n\\n        //the node has to be removed -> it is skipped during the iteration\\n        if (head->val == val) return removeElements(head->next, val);\\n\\n        //the node doesn\\'t have to be skipped -> the rest of the list has \\n        //to be joined to the node\\n        head->next = removeElements(head->next, val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57451,
                "title": "c-4-lines-recursive-solution",
                "content": "    ListNode* removeElements(ListNode* head, int val) {\\n        if (head == NULL) return NULL;\\n        if (val == head->val) return removeElements(head->next,val);\\n        head->next = removeElements(head->next,val);\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "    ListNode* removeElements(ListNode* head, int val) {\\n        if (head == NULL) return NULL;\\n        if (val == head->val) return removeElements(head->next,val);\\n        head->next = removeElements(head->next,val);\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3086104,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode;\\n        dummy -> next = head;\\n        ListNode* curr = dummy;\\n        \\n        while(curr -> next) {\\n            if(curr -> next -> val == val) {\\n                curr -> next = curr -> next -> next;\\n            } else {\\n                curr = curr -> next;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode;\\n        dummy -> next = head;\\n        ListNode* curr = dummy;\\n        \\n        while(curr -> next) {\\n            if(curr -> next -> val == val) {\\n                curr -> next = curr -> next -> next;\\n            } else {\\n                curr = curr -> next;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273908,
                "title": "easy-recursive-in-python",
                "content": "```python\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head:\\n            return None\\n        if head.val == val:\\n            head = self.removeElements(head.next,val)\\n        else:\\n            head.next = self.removeElements(head.next,val)\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head:\\n            return None\\n        if head.val == val:\\n            head = self.removeElements(head.next,val)\\n        else:\\n            head.next = self.removeElements(head.next,val)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506318,
                "title": "c-and-python-simple-solutions",
                "content": "**C++ :**\\n\\n```\\nListNode* removeElements(ListNode* head, int val) {\\n\\tif(!head) return head;\\n\\n\\tListNode* node = head;\\n\\twhile(node && node -> next)\\n\\t{\\n\\t\\tif(node -> next -> val == val)\\n\\t\\t\\tnode -> next = node -> next -> next;\\n\\t\\telse\\n\\t\\t\\tnode = node -> next;\\n\\t}\\n\\n\\tif(head -> val == val)\\n\\t\\thead = head -> next;\\n\\n\\treturn head;\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\tnode = head\\n\\twhile node and node.next:\\n\\t\\tif node.next.val == val:\\n\\t\\t\\tnode.next = node.next.next\\n\\n\\t\\telse:\\n\\t\\t\\tnode = node.next\\n\\n\\tif head.val == val:\\n\\t\\thead = head.next\\n\\n\\treturn head\\n```\\n\\n**Like it ? please upvote**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nListNode* removeElements(ListNode* head, int val) {\\n\\tif(!head) return head;\\n\\n\\tListNode* node = head;\\n\\twhile(node && node -> next)\\n\\t{\\n\\t\\tif(node -> next -> val == val)\\n\\t\\t\\tnode -> next = node -> next -> next;\\n\\t\\telse\\n\\t\\t\\tnode = node -> next;\\n\\t}\\n\\n\\tif(head -> val == val)\\n\\t\\thead = head -> next;\\n\\n\\treturn head;\\n}\\n```\n```\\ndef removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\tnode = head\\n\\twhile node and node.next:\\n\\t\\tif node.next.val == val:\\n\\t\\t\\tnode.next = node.next.next\\n\\n\\t\\telse:\\n\\t\\t\\tnode = node.next\\n\\n\\tif head.val == val:\\n\\t\\thead = head.next\\n\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 256356,
                "title": "my-fast-javascript-solution-with-explaination",
                "content": "First we have to check whether or not the linked-list is empty.If it is, we don\\'t even bother going to the next step, and just return null. If it is not empty, we can set two pointers, one points to the forward node, the other points to the previous (pay attention that we have skipped the validation for the first node, we will deal with it at the end : )\\nAfter the setting up, now we can start to run the loop.If the current-node\\'s value equals to the target\\'s value, we take a leap, let the current node equals to its next node, and set the previous node points to the current node.Else, moving two pointers(cur,prev) one step forward...\\nAt last, the target node will all be removed, except for the first one. For example, [1,1,1,1] 1. That is because we have skipped the checking for the first node. Let\\'s fix it by directly checking the value of the head node, if it equals to the target value,  we simply move it one node forward. That\\'s all.\\n```\\nvar removeElements = function(head, val) {\\n    if(!head)return null;\\n    let cur = head.next,\\n        prev = head;\\n    while(cur){\\n        if(cur.val === val){\\n            cur = cur.next;\\n            prev.next = cur;\\n        }else{\\n            prev = cur;\\n            cur = cur.next\\n        }\\n    }\\n    if(head.val === val)return head.next;\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeElements = function(head, val) {\\n    if(!head)return null;\\n    let cur = head.next,\\n        prev = head;\\n    while(cur){\\n        if(cur.val === val){\\n            cur = cur.next;\\n            prev.next = cur;\\n        }else{\\n            prev = cur;\\n            cur = cur.next\\n        }\\n    }\\n    if(head.val === val)return head.next;\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454737,
                "title": "very-easy-0-ms-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Remove Linked List Elements.\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        ListNode curr = fake;\\n        // Loop till curr.next not null...\\n        while(curr.next != null){\\n            // if we find the target val same as the value of curr.next...\\n            if(curr.next.val == val){\\n                // Skip that value and keep updating curr...\\n                curr.next = curr.next.next; \\n            }\\n            // Otherwise, move curr forward...\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return fake.next;       // Return the linked list...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode *prev, *curr;\\n        //deal with leading \\'val\\'s\\n        // If the head node is not null and the value of the head node is same as the target val...\\n        while(head != NULL && head->val == val)\\n            // Skip the value and keep updating head node...\\n            head = head->next;\\n        // Deal with \\'val\\'s not in head of list...\\n        // curr node points to the head node...\\n        curr = head;\\n        // Loop till curr not null...\\n        while(curr != NULL){\\n            // If we find the target val same as the value of curr...\\n            if(curr->val == val){\\n                // Skip that value and keep updating...\\n                prev->next = curr->next;\\n            }\\n            // Move prev when the next node of prev is not \\'val\\'\\n            else{\\n                prev = curr;\\n            }\\n            // Move curr forward...\\n            curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        # create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n        fake = ListNode(None)\\n        fake.next = head\\n        curr = fake\\n        # Loop till curr.next not null...\\n        while curr.next:\\n            # if we find the target val same as the value of curr.next...\\n            if curr.next.val == val:\\n                # Skip that value and keep updating curr...\\n                curr.next = curr.next.next\\n            # Otherwise, move curr forward...\\n            else:\\n                curr = curr.next\\n        # Return the linked list...\\n        return fake.next\\n```\\n        \\n# **JavaScript Solution:**\\n```\\nvar removeElements = function(head, val) {\\n    // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n    var fake = new ListNode(0);\\n    fake.next = head;\\n    var curr = fake;\\n    // Loop till curr.next not null...\\n    while(curr.next != null){\\n        // if we find the target val same as the value of curr.next...\\n        if(curr.next.val == val){\\n            // Skip that value and keep updating curr...\\n            curr.next = curr.next.next; \\n        }\\n        // Otherwise, move curr forward...\\n        else{\\n            curr = curr.next;\\n        }\\n    }\\n    return fake.next;       // Return the linked list...\\n};\\n```\\n\\n# **C Language:**\\n```\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode *prev, *curr;\\n    //deal with leading \\'val\\'s\\n    // If the head node is not null and the value of the head node is same as the target val...\\n    while(head != NULL && head->val == val)\\n        // Skip the value and keep updating head node...\\n        head = head->next;\\n    // Deal with \\'val\\'s not in head of list...\\n    // curr node points to the head node...\\n    curr = head;\\n    // Loop till curr not null...\\n    while(curr != NULL){\\n        // If we find the target val same as the value of curr...\\n        if(curr->val == val){\\n            // Skip that value and keep updating...\\n            prev->next = curr->next;\\n        }\\n        // Move prev when the next node of prev is not \\'val\\'\\n        else{\\n            prev = curr;\\n        }\\n        // Move curr forward...\\n        curr = curr->next;\\n    }\\n    return head;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        # create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n        fake = ListNode(None)\\n        fake.next = head\\n        curr = fake\\n        # Loop till curr.next not null...\\n        while curr.next:\\n            # if we find the target val same as the value of curr.next...\\n            if curr.next.val == val:\\n                # Skip that value and keep updating curr...\\n                curr.next = curr.next.next\\n            # Otherwise, move curr forward...\\n            else:\\n                curr = curr.next\\n        # Return the linked list...\\n        return fake.next\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        ListNode curr = fake;\\n        // Loop till curr.next not null...\\n        while(curr.next != null){\\n            // if we find the target val same as the value of curr.next...\\n            if(curr.next.val == val){\\n                // Skip that value and keep updating curr...\\n                curr.next = curr.next.next; \\n            }\\n            // Otherwise, move curr forward...\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return fake.next;       // Return the linked list...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode *prev, *curr;\\n        //deal with leading \\'val\\'s\\n        // If the head node is not null and the value of the head node is same as the target val...\\n        while(head != NULL && head->val == val)\\n            // Skip the value and keep updating head node...\\n            head = head->next;\\n        // Deal with \\'val\\'s not in head of list...\\n        // curr node points to the head node...\\n        curr = head;\\n        // Loop till curr not null...\\n        while(curr != NULL){\\n            // If we find the target val same as the value of curr...\\n            if(curr->val == val){\\n                // Skip that value and keep updating...\\n                prev->next = curr->next;\\n            }\\n            // Move prev when the next node of prev is not \\'val\\'\\n            else{\\n                prev = curr;\\n            }\\n            // Move curr forward...\\n            curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        # create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n        fake = ListNode(None)\\n        fake.next = head\\n        curr = fake\\n        # Loop till curr.next not null...\\n        while curr.next:\\n            # if we find the target val same as the value of curr.next...\\n            if curr.next.val == val:\\n                # Skip that value and keep updating curr...\\n                curr.next = curr.next.next\\n            # Otherwise, move curr forward...\\n            else:\\n                curr = curr.next\\n        # Return the linked list...\\n        return fake.next\\n```\n```\\nvar removeElements = function(head, val) {\\n    // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n    var fake = new ListNode(0);\\n    fake.next = head;\\n    var curr = fake;\\n    // Loop till curr.next not null...\\n    while(curr.next != null){\\n        // if we find the target val same as the value of curr.next...\\n        if(curr.next.val == val){\\n            // Skip that value and keep updating curr...\\n            curr.next = curr.next.next; \\n        }\\n        // Otherwise, move curr forward...\\n        else{\\n            curr = curr.next;\\n        }\\n    }\\n    return fake.next;       // Return the linked list...\\n};\\n```\n```\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode *prev, *curr;\\n    //deal with leading \\'val\\'s\\n    // If the head node is not null and the value of the head node is same as the target val...\\n    while(head != NULL && head->val == val)\\n        // Skip the value and keep updating head node...\\n        head = head->next;\\n    // Deal with \\'val\\'s not in head of list...\\n    // curr node points to the head node...\\n    curr = head;\\n    // Loop till curr not null...\\n    while(curr != NULL){\\n        // If we find the target val same as the value of curr...\\n        if(curr->val == val){\\n            // Skip that value and keep updating...\\n            prev->next = curr->next;\\n        }\\n        // Move prev when the next node of prev is not \\'val\\'\\n        else{\\n            prev = curr;\\n        }\\n        // Move curr forward...\\n        curr = curr->next;\\n    }\\n    return head;\\n}\\n```\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        # create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n        fake = ListNode(None)\\n        fake.next = head\\n        curr = fake\\n        # Loop till curr.next not null...\\n        while curr.next:\\n            # if we find the target val same as the value of curr.next...\\n            if curr.next.val == val:\\n                # Skip that value and keep updating curr...\\n                curr.next = curr.next.next\\n            # Otherwise, move curr forward...\\n            else:\\n                curr = curr.next\\n        # Return the linked list...\\n        return fake.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492317,
                "title": "python-easy-to-follow-with-comments-no-dummy-node",
                "content": "```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        prev, current = None, head\\n        while current:\\n            if current.val == val:\\n                if prev:\\n                    # Remove the current node in the normal way.\\n                    prev.next = current.next\\n                    current = prev\\n                else:\\n                    # We are at the head, advance the head and keep prev as None.\\n                    head = head.next\\n            else:\\n                # Advance the prev pointer.\\n                prev = current\\n            # Advance the current pointer.\\n            current = current.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        prev, current = None, head\\n        while current:\\n            if current.val == val:\\n                if prev:\\n                    # Remove the current node in the normal way.\\n                    prev.next = current.next\\n                    current = prev\\n                else:\\n                    # We are at the head, advance the head and keep prev as None.\\n                    head = head.next\\n            else:\\n                # Advance the prev pointer.\\n                prev = current\\n            # Advance the current pointer.\\n            current = current.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57515,
                "title": "an-easy-understand-solution-with-pretty-fast-speed",
                "content": "    public class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            while(head != null && head.val == val) {\\n                head = head.next;\\n            }\\n            if(head == null) {\\n                return head;\\n            }\\n            ListNode p = head;\\n            while(p.next != null) {\\n                if(p.next.val == val) {\\n                    p.next = p.next.next;\\n                } else {\\n                    p = p.next;\\n                }\\n            }\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            while(head != null && head.val == val) {\\n                head = head.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 57312,
                "title": "python-solution",
                "content": "    class Solution:\\n    # @param {ListNode} head\\n    # @param {integer} val\\n    # @return {ListNode}\\n    def removeElements(self, head, val):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        next = dummy\\n        \\n        while next != None and next.next != None:\\n            if next.next.val == val:\\n                next.next = next.next.next\\n            else:\\n                next = next.next\\n            \\n        return dummy.next",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {ListNode}",
                "codeTag": "Java"
            },
            {
                "id": 3036500,
                "title": "python-simple-solution-beats-95",
                "content": "\\n## Upvote if it helps! \\uD83D\\uDE00\\n\\n# Approach\\n- The first loop is to detect **if there are nodes to delete at the beginning**.\\n    - In this case we move head until we find the first element which has a different value.\\n- The second loop iterate over the list:\\n    - If we find a node to delete, we also verify if there are a succession of nodes to be deleted with the while.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        # First loop\\n        while head and head.val == val:\\n            head = head.next\\n\\n        current = head\\n\\n        # Second loop\\n        while current:\\n            while current and current.next and current.next.val == val:\\n                current.next = current.next.next\\n            current = current.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        # First loop\\n        while head and head.val == val:\\n            head = head.next\\n\\n        current = head\\n\\n        # Second loop\\n        while current:\\n            while current and current.next and current.next.val == val:\\n                current.next = current.next.next\\n            current = current.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745470,
                "title": "python-one-pass-o-n-time-o-1-memory-explained",
                "content": "Easy linked list traversal problem, without any smart ideas: just traverse list and do what is asked. Two small things which helps to simplify code:\\n1. When traverse, always look at the next element in list, because if we already at element with value equal to `val`, we can not delete it, we need to go back somehow.\\n2. Use dummy head to deal with case when head is equal to `val`.\\n\\nSo, basically our algorithm looks like this: we traverse our list and if value of next element is equal to `val`, we need to delete it, so we do `start.next = start.next.next`. Note, that in this case we do not move our pointers, because there can be more element equal to `val`. If value is not equal to `val`, we move to the next element.\\n\\n**Complexity**: time complexity is `O(n)` with only one pass, space complexity is `O(1)`, because we do not use any additional memory except couple of variable.\\n\\n```\\nclass Solution:\\n    def removeElements(self, head, val):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        start = dummy\\n        while start.next:\\n            if start.next.val == val:\\n                start.next = start.next.next\\n            else:\\n                start = start.next         \\n        return dummy.next   \\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head, val):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        start = dummy\\n        while start.next:\\n            if start.next.val == val:\\n                start.next = start.next.next\\n            else:\\n                start = start.next         \\n        return dummy.next   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 745459,
                "title": "c-simple-iterative-vs-recursive-oneliner-solution-explained-85-time-85-space",
                "content": "So, our first step is to update `head` until its current value matches `val` (and provided we actually have `head` - ie: it is not `NULL`); note that we are not changing any properties here, just updating where `head` is pointing.\\n\\nIf we are done here (either `head` was initially `NULL` or it is now since we traversed the whole list and found only matching values), then we return `head` (or `NULL`, same thing in this case).\\n\\nOnce that is done, we create a support variable `tmp` (because we still have to return `head` later, so we do not want to modify it any further) and progress similarly: we know initially its value cannot be a match, so we proceeed until `tmp->next` is a valid node and if it is a match, then we change its value to point to its following node; otherwise, we just update `tmp`.\\n\\nOnce this is all done, we just return `head`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        // getting rid of potential initial matches\\n        while (head && head->val == val) head = head->next;\\n        if (!head) return head;\\n        // getting rid of other matches\\n        ListNode *tmp = head;\\n        while (tmp->next) {\\n            if (tmp->next->val == val) tmp->next = tmp->next->next;\\n            else tmp = tmp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\nNow, just for fun, I converted it all to a monster onliner (don\\'t do this in interviews!); notice that the possibly only tricky part of converting it all was to use the comma operator to modify `tmp` in the penultimate clause and adding the second condition (` || (tmp && !tmp->next)`) to the very first case in order for it to work on terminal cases.\\n\\nThe unholy oneliner:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val, ListNode* tmp = NULL) {\\n        return !head || (tmp && !tmp->next) ? head : head->val == val ? removeElements(head->next, val) : !tmp ? removeElements(head, val, head) : tmp->next->val == val ? removeElements(head, val, (tmp->next = tmp->next->next, tmp)) :  removeElements(head, val, tmp->next);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        // getting rid of potential initial matches\\n        while (head && head->val == val) head = head->next;\\n        if (!head) return head;\\n        // getting rid of other matches\\n        ListNode *tmp = head;\\n        while (tmp->next) {\\n            if (tmp->next->val == val) tmp->next = tmp->next->next;\\n            else tmp = tmp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val, ListNode* tmp = NULL) {\\n        return !head || (tmp && !tmp->next) ? head : head->val == val ? removeElements(head->next, val) : !tmp ? removeElements(head, val, head) : tmp->next->val == val ? removeElements(head, val, (tmp->next = tmp->next->next, tmp)) :  removeElements(head, val, tmp->next);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655657,
                "title": "simple-recursive-solution",
                "content": "This solution is based on recursion. Here a recursive function \"removenode\" is used. The end of the linked list is reached with the help of the recursive function. \\n![image](https://assets.leetcode.com/users/images/a95d85b9-4549-4960-a10a-5f6614b0dd0a_1664804128.6790764.png)\\n\\nLet us take the above image for illustration. The target value is 6. \\n1. When the end of the linked list is reached by recursive function and NULL is found(The base case) then that instance/stack of the function will return NULL to the previous node\\'s function call.\\n2. Here the value of the node before NULL is 6 which is equal to the target, if this is the case then that function stack will not return the current pointer to the previous node but the pointer to the NULL, Thus losing the pointer of node containing 6.\\n3. When the node 2 is reached then the condition is checked, if its equal to target or not, In this case, it is not thus the current node\\'s next will become the returned node from the previous function stack which was NULL. Thus next of two will become NULL. \\n4. When 6 is reached, the condition evalues as true and and thus returns the pointer of (2) to the previous node.\\n5. When 1 reaches the, condition evaluates as false and thus the next of 1 is the returned pointer which is 2.\\n\\n\\n```\\nListNode *removenode(ListNode *ptr, int target){\\n\\t//base case\\n    if(ptr==NULL){\\n        return NULL;\\n    }\\n\\t//call the recursive function and pass the next node\\n    ListNode *returnnode = removenode(ptr->next,target);\\n\\t///All the below lines will be executed when the recursive function comes back\\n\\t//check if the value of cuurent node is equal to the value of target.\\n    if(ptr->val == target){\\n\\t\\t//if the value of current node is equal to the taget then return the previously returned value.\\n        return returnnode;\\n    }\\n    else{\\n\\t\\t//since the value of current node is not equal to target thus modify the next node.\\n        ptr->next = returnnode;\\n\\t\\t//return the pointer to the current node.\\n        return ptr;\\n    }\\n}\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        return removenode(head,val);\\n    }\\n};\\n```\\n\\nI tried my best to explain the solution. Please upvote or any doubts u can add in comments.",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nListNode *removenode(ListNode *ptr, int target){\\n\\t//base case\\n    if(ptr==NULL){\\n        return NULL;\\n    }\\n\\t//call the recursive function and pass the next node\\n    ListNode *returnnode = removenode(ptr->next,target);\\n\\t///All the below lines will be executed when the recursive function comes back\\n\\t//check if the value of cuurent node is equal to the value of target.\\n    if(ptr->val == target){\\n\\t\\t//if the value of current node is equal to the taget then return the previously returned value.\\n        return returnnode;\\n    }\\n    else{\\n\\t\\t//since the value of current node is not equal to target thus modify the next node.\\n        ptr->next = returnnode;\\n\\t\\t//return the pointer to the current node.\\n        return ptr;\\n    }\\n}\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        return removenode(head,val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746297,
                "title": "rust-no-unwraps",
                "content": "```\\nimpl Solution {\\n    pub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut ptr = &mut head;\\n\\n        loop {\\n            match ptr {\\n                None => break,\\n                Some(node) if node.val == val => {\\n                    *ptr = node.next.take();\\n                }\\n                Some(node) => {\\n                    ptr = &mut node.next;\\n                }\\n            }\\n        }\\n\\n        head\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut ptr = &mut head;\\n\\n        loop {\\n            match ptr {\\n                None => break,\\n                Some(node) if node.val == val => {\\n                    *ptr = node.next.take();\\n                }\\n                Some(node) => {\\n                    ptr = &mut node.next;\\n                }\\n            }\\n        }\\n\\n        head\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 867106,
                "title": "simple-recursive-and-non-recursive-solution-in-c",
                "content": "## **Recursive Solution:**\\n```\\nListNode* removeElements(ListNode* head, int val) {\\n        if (head == 0) return head; //stopping condition.\\n        if (head->val == val)   //if value matches, ignore the element.\\n            return removeElements(head->next, val);\\n        else {                          //if does not match consider it.\\n            head->next = removeElements(head->next, val);\\n            return head;\\n        }\\n    }\\n```\\n\\n## **Non-Recursive Solution:**\\n```\\nListNode* removeElements(ListNode* head, int val) {\\n        if (head == 0) return head;\\n        \\n        ListNode* temp = head;\\n        while (temp != 0 and temp->next != 0) {\\n            if (temp->next->val == val) temp->next = temp->next->next;\\n            else temp = temp->next;\\n        }\\n        if (head->val == val) head = head->next;   \\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nListNode* removeElements(ListNode* head, int val) {\\n        if (head == 0) return head; //stopping condition.\\n        if (head->val == val)   //if value matches, ignore the element.\\n            return removeElements(head->next, val);\\n        else {                          //if does not match consider it.\\n            head->next = removeElements(head->next, val);\\n            return head;\\n        }\\n    }\\n```\n```\\nListNode* removeElements(ListNode* head, int val) {\\n        if (head == 0) return head;\\n        \\n        ListNode* temp = head;\\n        while (temp != 0 and temp->next != 0) {\\n            if (temp->next->val == val) temp->next = temp->next->next;\\n            else temp = temp->next;\\n        }\\n        if (head->val == val) head = head->next;   \\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 57514,
                "title": "java-remove-linked-list-elements-solution",
                "content": "public class Solution {\\n\\n    public ListNode removeElements(ListNode head, int val) {\\n\\n        ListNode dummy = new ListNode(1);\\n        ListNode i = dummy;\\n        ListNode j = head;\\n        dummy.next = head;\\n        \\n        while(j != null){\\n            if(j.val == val){\\n                i.next = i.next.next;\\n                j = j.next;\\n            }else{\\n                i = i.next;\\n                j = j.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public ListNode removeElements(ListNode head, int val) {\\n\\n        ListNode dummy = new ListNode(1);\\n        ListNode i = dummy;\\n        ListNode j = head;\\n        dummy.next = head;\\n        \\n        while(j != null){\\n            if(j.val == val){\\n                i.next = i.next.next;\\n                j = j.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 57523,
                "title": "pointer-of-level-two",
                "content": "It's only intresting when implemented by \"[Two star programming][1]\"!\\n\\n    class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n    \\t\\tListNode **p = &head;\\n    \\t\\twhile(*p != NULL)\\n    \\t\\t{\\n    \\t\\t\\tif((*p)->val == val) \\n    \\t\\t\\t\\t*p = (*p)->next;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tp = &((*p)->next);\\n    \\t\\t}\\n    \\t\\treturn head;\\n        }\\n    };\\n\\n\\n  [1]: http://wordaligned.org/articles/two-star-programming",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n    \\t\\tListNode **p = &head;\\n    \\t\\twhile(*p != NULL)\\n    \\t\\t{\\n    \\t\\t\\tif((*p)->val == val) \\n    \\t\\t\\t\\t*p = (*p)->next;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tp = &((*p)->next);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1572997,
                "title": "javascript-clean-code-detailed-explanation-step-by-step",
                "content": "Problem statement is pretty clear, so let\\'s go straight to the examples where we need to remove all elements with value `0` from a linked list\\n\\n**Scenario 1.** We have some \"bad\" nodes at the beginning of the linked list\\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\n```\\nLet\\'s introduce 2 pointers, `p` - points to a previous element, initially `undefined` as we do not have previous element yet, and `c` - points to the current element, initially points to the head of the linked list\\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\nc\\n```\\nNow, as `c` points to the element with value `0`, point `p` to the same element as `c`\\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\nc\\np\\n```\\nMove `c` to the next element in the linked list\\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\n     c\\np\\n```\\nRemove link to the next element from `p`\\n```\\n_    0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\n     c\\np\\n```\\nAs `c` points to the element with value `0` again, we need to repeat last 3 steps, so we end up at the situation, where all \"bad\" nodes are \"cut off\" and `c` points to the \"good\" element which is now a head of a resulting linked list\\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                    c\\n               p\\n```\\n**Scenario 2.** Now we have \"bad\" nodes in the middle of the linked list, and `c` points to the head of resulting linked list, so let\\'s introduce another variable `h` and point it to the same element `c` is pointing now\\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                    c\\n               p\\n\\t\\t\\t        h\\n```\\nAt this point, `c` points to a \"good\" node, so let\\'s point `p` to the same node\\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                    c\\n                    p\\n\\t\\t\\t        h\\n```\\nNow we can move `c` to the next element\\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                         c\\n                    p\\n\\t\\t\\t        h\\n```\\nRepeat 2 last steps until `c` reaches another \"bad\" node\\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                              c\\n                         p\\n\\t\\t\\t        h\\n```\\nNow, `c` points to the element with value `0`, which we need to remove, so we simply move `c` to the next element\\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                                   c\\n                         p\\n\\t\\t\\t        h\\n```\\nPoint next element of `p` to `c`, thus removing bad element from the list (You may notice here, that \"bad\" node is still poining to the \"good\" node, but we do not really care about it in this particular scenario)\\n```\\n_    _    _    _    2 -> 1 ------> 3 -> \\n                                   c\\n                         p\\n\\t\\t\\t        h\\n```\\nRepeat until `c` reches very end of the linked list and return `h`\\n```\\n_    _    _    _    2 -> 1 ------> 3 -> \\n                                        c\\n                                   p\\n\\t\\t\\t        h\\n```\\n\\n**Finally**, write some code\\n```\\nconst removeElements = function(head, val) {\\n\\t// Introduce p and c, where p is undefined and c points to the first element of a linked list \\n    let previous;\\n    let current = head;\\n\\n\\t// Handle scenario, where \"bad\" nodes are at the beginning of a linked list\\n    while (current && current.val === val) {\\n        previous = current;\\n        current = current.next;\\n        previous.next = null;\\n    }\\n\\n\\t// Introduce h and point it to the c, which is currently a head of the resulting linked list \\n    head = current;\\n    while (current) {\\n        if (current.val === val) {\\n\\t\\t\\t// Handle case when c points to a \"bad\" node, where we link p to the next node of c\\n            previous.next = current.next;\\n            current = current.next;\\n        } else {\\n\\t\\t\\t// Handle case when c points to a \"good\" node, where we simply advance to the next node of c \\n            previous = current;\\n            current = current.next;\\n        }\\n    }\\n    return head;\\n};\\n```\\n\\n**Analysis.** As we pass linked list only once, it gives us `O(n)` time complexity. As we use only fixed number of variables, which does not depend on the number of elements in a linked list, we are at `O(1)` space complexity",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\n```\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\nc\\n```\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\nc\\np\\n```\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\n     c\\np\\n```\n```\\n_    0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\n     c\\np\\n```\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                    c\\n               p\\n```\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                    c\\n               p\\n\\t\\t\\t        h\\n```\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                    c\\n                    p\\n\\t\\t\\t        h\\n```\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                         c\\n                    p\\n\\t\\t\\t        h\\n```\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                              c\\n                         p\\n\\t\\t\\t        h\\n```\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                                   c\\n                         p\\n\\t\\t\\t        h\\n```\n```\\n_    _    _    _    2 -> 1 ------> 3 -> \\n                                   c\\n                         p\\n\\t\\t\\t        h\\n```\n```\\n_    _    _    _    2 -> 1 ------> 3 -> \\n                                        c\\n                                   p\\n\\t\\t\\t        h\\n```\n```\\nconst removeElements = function(head, val) {\\n\\t// Introduce p and c, where p is undefined and c points to the first element of a linked list \\n    let previous;\\n    let current = head;\\n\\n\\t// Handle scenario, where \"bad\" nodes are at the beginning of a linked list\\n    while (current && current.val === val) {\\n        previous = current;\\n        current = current.next;\\n        previous.next = null;\\n    }\\n\\n\\t// Introduce h and point it to the c, which is currently a head of the resulting linked list \\n    head = current;\\n    while (current) {\\n        if (current.val === val) {\\n\\t\\t\\t// Handle case when c points to a \"bad\" node, where we link p to the next node of c\\n            previous.next = current.next;\\n            current = current.next;\\n        } else {\\n\\t\\t\\t// Handle case when c points to a \"good\" node, where we simply advance to the next node of c \\n            previous = current;\\n            current = current.next;\\n        }\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283527,
                "title": "java-100-faster-and-simple",
                "content": "```class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head == null) return head;\\n\\n        ListNode ptr = head;\\n        \\n        while(ptr.next != null) {\\n            if(ptr.next.val == val) ptr.next = ptr.next.next;\\n            else ptr = ptr.next;\\n        }\\n        if(head.val == val) return head.next;\\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head == null) return head;\\n\\n        ListNode ptr = head;\\n        \\n        while(ptr.next != null) {\\n            if(ptr.next.val == val) ptr.next = ptr.next.next;\\n            else ptr = ptr.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 381917,
                "title": "python-solution-using-dummy-head",
                "content": "The idea here is we do not know where `val` will appear, it could very well appear at the beginning of the list. To take care of this case we create a `dummy_head` that point to the current head. To remove a list element we need to wire the node preceding `val` to the node following `val`. We look ahead starting at the dummy node to see if the `next` node contains `val`. If it does we wire the current node `next` to `next.next`, that is the node after `val`. If `val` is not in the next node we just move our current node there.\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        dummy_head = ListNode(0)\\n        dummy_head.next = head\\n        node = dummy_head\\n        while node.next:\\n            if node.next.val == val:\\n                node.next = node.next.next\\n            else:\\n                node = node.next\\n        return dummy_head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        dummy_head = ListNode(0)\\n        dummy_head.next = head\\n        node = dummy_head\\n        while node.next:\\n            if node.next.val == val:\\n                node.next = node.next.next\\n            else:\\n                node = node.next\\n        return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57307,
                "title": "my-easy-c-solution",
                "content": "\\n\\n\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode** tmp = &head;\\n        while(*tmp){\\n            if((*tmp)->val == val) *tmp = (*tmp)->next;\\n            else tmp = &((*tmp)->next);\\n        }\\n        return head;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode** tmp = &head;\\n        while(*tmp){\\n            if((*tmp)->val == val) *tmp = (*tmp)->next;\\n            else tmp = &((*tmp)->next);\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 57571,
                "title": "simple-12ms-c-solution",
                "content": "Just for your reference, welcome any comment.\\n    \\n    struct ListNode* removeElements(struct ListNode* head, int val) \\n    {\\n        struct ListNode **pp, *p;\\n    \\n        pp = &head;\\n        while (*pp) {\\n            p = *pp;\\n            if ((*pp)->val == val) { /* found one */\\n                *pp = p->next;\\n                free(p);\\n            } else\\n                pp = &p->next;\\n        }\\n    \\n        return head;\\n    }",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "Just for your reference, welcome any comment.\\n    \\n    struct ListNode* removeElements(struct ListNode* head, int val) \\n    {\\n        struct ListNode **pp, *p;\\n    \\n        pp = &head;\\n        while (*pp) {\\n            p = *pp;\\n            if ((*pp)->val == val) { /* found one */\\n                *pp = p->next;\\n                free(p);\\n            } else\\n                pp = &p->next;\\n        }\\n    \\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1393993,
                "title": "5-lines-solution-specially-for-beginners-optimal-easiest-easily-understandable",
                "content": "ListNode* removeElements(ListNode* head, int val) {\\n            \\n            ListNode* curr=head;\\n            \\n            \\n            if(head==NULL)return NULL;\\n           while(head!=NULL && head->val==val) head=head->next;\\n             while(curr!=NULL && curr->next!=NULL){\\n            if(curr->next->val==val) curr->next=curr->next->next;\\n                else   curr=curr->next;\\n            }\\n            \\n            return head;\\n        \\n    }\\n\\t\\n\\t// Guys plz plz plz upvote my solution if you like and understand it.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "ListNode* removeElements(ListNode* head, int val) {\\n            \\n            ListNode* curr=head;\\n            \\n            \\n            if(head==NULL)return NULL;\\n           while(head!=NULL && head->val==val) head=head->next;\\n             while(curr!=NULL && curr->next!=NULL){\\n            if(curr->next->val==val) curr->next=curr->next->next;\\n                else   curr=curr->next;\\n            }\\n            \\n            return head;\\n        \\n    }\\n\\t\\n\\t// Guys plz plz plz upvote my solution if you like and understand it.",
                "codeTag": "Unknown"
            },
            {
                "id": 2829118,
                "title": "python-easy-understandable-one-while-loop",
                "content": "## Iterative Approach\\n- Here easy and uderstadable code.\\n\\n__Python :__\\n\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        temp = head\\n        prev = None             # initially prev should points to None\\n        while temp!=None:\\n            if temp.val == val and prev == None :      # when first node is val which has to remove\\n                temp = temp.next\\n                head = temp\\n                prev = None                         # prev must None because still first Node equal to val\\n            elif temp.val == val:               # when in middle node equal to val\\n                prev.next = temp.next               # simple prev point to next node\\n                temp = temp.next\\n            else:                               # Move untill node not equal to val\\n                prev = temp\\n                temp = temp.next\\n        return head\\n```\\n\\n- One last request if you understand it do upvote.",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        temp = head\\n        prev = None             # initially prev should points to None\\n        while temp!=None:\\n            if temp.val == val and prev == None :      # when first node is val which has to remove\\n                temp = temp.next\\n                head = temp\\n                prev = None                         # prev must None because still first Node equal to val\\n            elif temp.val == val:               # when in middle node equal to val\\n                prev.next = temp.next               # simple prev point to next node\\n                temp = temp.next\\n            else:                               # Move untill node not equal to val\\n                prev = temp\\n                temp = temp.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702258,
                "title": "java-98-96-faster-with-comments",
                "content": "```\\npublic ListNode removeElements(ListNode head, int val) {\\n        if(head==null) return null; //list of size 0\\n        if(head.next==null && head.val==val) return null; //list of size 1\\n        // if all elements of list are equal to val given\\n        while(head!=null && head.val==val){  // \\n            head = head.next;\\n        }\\n        ListNode curr = head;\\n        \\n        while(curr!=null && curr.next!=null){\\n            if(curr.next.val==val){\\n                curr.next = curr.next.next;\\n            }else{\\n                curr = curr.next;\\n            }\\n            \\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic ListNode removeElements(ListNode head, int val) {\\n        if(head==null) return null; //list of size 0\\n        if(head.next==null && head.val==val) return null; //list of size 1\\n        // if all elements of list are equal to val given\\n        while(head!=null && head.val==val){  // \\n            head = head.next;\\n        }\\n        ListNode curr = head;\\n        \\n        while(curr!=null && curr.next!=null){\\n            if(curr.next.val==val){\\n                curr.next = curr.next.next;\\n            }else{\\n                curr = curr.next;\\n            }\\n            \\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1708637,
                "title": "c-single-pointer-approach-faster-than-98-consumes-83-less-memory-explained",
                "content": "class Solution {\\npublic:\\n\\n    ListNode* removeElements(ListNode* head, int val) {\\n        \\n        while(head != NULL && head -> val == val)    // eg [7, 7, 7, 5] val = 7, then we have to delete all 7 and move head to 5.\\n        {\\n            head = head -> next;\\n        }\\n        \\n        if(head == NULL)            // eg [7, 7, 7, 7] val = 7, then we have to delete all 7 and return NULL.\\n            return head;\\n        \\n        ListNode* curr = head;\\n        \\n        while(curr -> next != NULL)\\n        {\\n            if(curr -> next -> val == val)\\n            {\\n                curr -> next = curr -> next -> next;\\n            }\\n            else  \\n            {\\n                curr = curr -> next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* removeElements(ListNode* head, int val) {\\n        \\n        while(head != NULL && head -> val == val)    // eg [7, 7, 7, 5] val = 7, then we have to delete all 7 and move head to 5.\\n        {\\n            head = head -> next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 924412,
                "title": "easy-js-solution",
                "content": "```\\nvar removeElements = function(head, val) {\\n    let dummy = new ListNode();\\n    let cur = dummy;\\n    \\n    while (head !== null) {\\n        if (head.val !== val) {\\n            cur.next = head;\\n            cur = cur.next;\\n        }\\n        head = head.next;\\n    }\\n    cur.next = null;\\n    return dummy.next;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeElements = function(head, val) {\\n    let dummy = new ListNode();\\n    let cur = dummy;\\n    \\n    while (head !== null) {\\n        if (head.val !== val) {\\n            cur.next = head;\\n            cur = cur.next;\\n        }\\n        head = head.next;\\n    }\\n    cur.next = null;\\n    return dummy.next;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799736,
                "title": "javascript-solution-203",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nlet removeElements = function(head, val) {\\n    let h=new ListNode(-1);\\n    h.next=head;\\n    head=h;\\n    while(h.next!==null){\\n        if(h.next.val===val){\\n            h.next=h.next.next;\\n        }\\n        else{\\n            h=h.next;\\n        }\\n    }\\n    return head.next;  \\n};\\n```\\n\\n**Runtime: 100 ms, faster than 59.51% of JavaScript online submissions for Remove Linked List Elements.**\\n\\n**Memory Usage: 41.5 MB, less than 21.18% of JavaScript online submissions for Remove Linked List Elements.**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nlet removeElements = function(head, val) {\\n    let h=new ListNode(-1);\\n    h.next=head;\\n    head=h;\\n    while(h.next!==null){\\n        if(h.next.val===val){\\n            h.next=h.next.next;\\n        }\\n        else{\\n            h=h.next;\\n        }\\n    }\\n    return head.next;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208941,
                "title": "python-solution",
                "content": "Time complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        prev = ListNode(0)\\n        prev.next = head\\n        record = prev\\n        trav = head\\n        while trav:\\n            if trav.val == val:\\n                prev.next = trav.next\\n                trav = prev.next\\n            else:\\n                prev = trav\\n                trav = trav.next\\n        return record.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        prev = ListNode(0)\\n        prev.next = head\\n        record = prev\\n        trav = head\\n        while trav:\\n            if trav.val == val:\\n                prev.next = trav.next\\n                trav = prev.next\\n            else:\\n                prev = trav\\n                trav = trav.next\\n        return record.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57337,
                "title": "javascript-solution",
                "content": "````\\nvar removeElements = function(head, val) {\\n    \\n    var prev = null,\\n        actual = head;\\n    \\n    while(actual !== null){\\n        \\n        if(actual.val === val){\\n            if(prev === null){\\n                head = actual.next;\\n            }else{\\n                prev.next = actual.next;\\n            }\\n        }else{\\n            prev = actual;\\n        }\\n        \\n        actual = actual.next;\\n        \\n    }\\n    \\n    return head;\\n};",
                "solutionTags": [],
                "code": "````\\nvar removeElements = function(head, val) {\\n    \\n    var prev = null,\\n        actual = head;\\n    \\n    while(actual !== null){\\n        \\n        if(actual.val === val){\\n            if(prev === null){\\n                head = actual.next;\\n            }else{\\n                prev.next = actual.next;\\n            }\\n        }else{\\n            prev = actual;\\n        }\\n        \\n        actual = actual.next;\\n        \\n    }\\n    \\n    return head;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 57438,
                "title": "my-javascript-solution",
                "content": "    var removeElements = function(head, val) {\\n        var current = head;\\n        var previous = null;\\n        \\n        while(current){\\n            if(current.val === val){\\n                if(previous){\\n                    previous.next = current.next;\\n                }else{\\n                    head = current.next;\\n                }\\n            }else{\\n                previous = current;\\n            }\\n            \\n            current = current.next;\\n        }\\n        \\n        return head;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var removeElements = function(head, val) {\\n        var current = head;\\n        var previous = null;\\n        \\n        while(current){\\n            if(current.val === val){\\n                if(previous){\\n                    previous.next = current.next;\\n                }else{\\n                    head = current.next;\\n                }\\n            }else{\\n                previous = current;\\n            }\\n            \\n            current = current.next;\\n        }\\n        \\n        return head;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3447984,
                "title": "java-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode result = new ListNode(0);\\n        result.next = head;\\n\\n        ListNode current = result;\\n\\n        while (current.next != null) {\\n            if (current.next.val == val) {\\n                current.next = current.next.next;\\n            } else {\\n                current = current.next;\\n            }\\n        }\\n        \\n        return result.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode result = new ListNode(0);\\n        result.next = head;\\n\\n        ListNode current = result;\\n\\n        while (current.next != null) {\\n            if (current.next.val == val) {\\n                current.next = current.next.next;\\n            } else {\\n                current = current.next;\\n            }\\n        }\\n        \\n        return result.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220587,
                "title": "203-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will start by initializing a dummy node and make its next point to head, which will make it easy to handle edge cases.\\n\\nWe will traverse the linked list and remove all the nodes with val equal to given val.\\n\\nAt the end, we will return the next node of dummy node as the new head.\\n\\nAlgorithm:\\n\\n1. Initialize a dummy node and point its next to the head of the linked list.\\n2. Initialize two pointers, prev and curr as dummy and head, respectively.\\n3. Traverse the linked list:\\na. If the value of the current node is equal to the given value, then set the next of the prev node to the next of curr node and move curr to the next node.\\nb. Else, move prev and curr to their next nodes.\\n4. Return the next of the dummy node as the new head of the linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        dummy = ListNode(0)  # initialize dummy node\\n        dummy.next = head  # point its next to head\\n        prev, curr = dummy, head  # initialize prev and curr pointers\\n        \\n        while curr:  # traverse the linked list\\n            if curr.val == val:  # if val found\\n                prev.next = curr.next  # remove the node by skipping it\\n            else:\\n                prev = curr  # move prev to the next node\\n            curr = curr.next  # move curr to the next node\\n        \\n        return dummy.next  # return the new head\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        dummy = ListNode(0)  # initialize dummy node\\n        dummy.next = head  # point its next to head\\n        prev, curr = dummy, head  # initialize prev and curr pointers\\n        \\n        while curr:  # traverse the linked list\\n            if curr.val == val:  # if val found\\n                prev.next = curr.next  # remove the node by skipping it\\n            else:\\n                prev = curr  # move prev to the next node\\n            curr = curr.next  # move curr to the next node\\n        \\n        return dummy.next  # return the new head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198676,
                "title": "solution-intuition-approach-complexity-and-code-removing-linked-list-elements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires removing all nodes that match a specific value from a linked list. The approach involves iterating through the linked list while maintaining a previous node pointer to update the next node pointer of the previous node once a node that matches the specific value is found. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve the problem, we use two pointers, a previous pointer `prev` and a current pointer `curr`, both initially pointing to the head of the linked list. While iterating through the linked list, if the current node has a value equal to the specific value, we skip the current node by updating the next node pointer of the previous node to point to the next node of the current node. Otherwise, we update the previous node pointer to point to the current node.\\n# Complexity\\n- Time complexity:$O(n)$, where n is the number of nodes in the linked list. The algorithm iterates through each node in the linked list at most once to remove the nodes that match the specific value.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$O(1)$. The algorithm uses a constant amount of extra memory to maintain the previous and current node pointers.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        prev = None\\n        curr = head\\n    \\n        while curr:\\n            if curr.val == val:\\n                if prev:\\n                    prev.next = curr.next\\n                else:\\n                    head = curr.next\\n                curr = curr.next\\n            else:\\n                prev = curr\\n                curr = curr.next\\n    \\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        prev = None\\n        curr = head\\n    \\n        while curr:\\n            if curr.val == val:\\n                if prev:\\n                    prev.next = curr.next\\n                else:\\n                    head = curr.next\\n                curr = curr.next\\n            else:\\n                prev = curr\\n                curr = curr.next\\n    \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126711,
                "title": "best-solution-using-data-structure-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val){\\n     ListNode x=head;\\n        ListNode it=x;\\n        while(x!=null && x.val==val){\\n            head=x.next;\\n            x=head;\\n        }\\n        while(x!=null){\\n            if(x.val==val){\\n               \\n                it.next=x.next;\\n                x=it.next;\\n            }\\n            else{\\n                it=x;\\n                x=x.next;\\n            }\\n            \\n        }\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val){\\n     ListNode x=head;\\n        ListNode it=x;\\n        while(x!=null && x.val==val){\\n            head=x.next;\\n            x=head;\\n        }\\n        while(x!=null){\\n            if(x.val==val){\\n               \\n                it.next=x.next;\\n                x=it.next;\\n            }\\n            else{\\n                it=x;\\n                x=x.next;\\n            }\\n            \\n        }\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955214,
                "title": "c-easy-recursive-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int value) {\\n        \\n        \\n        while(head != NULL && head->val == value){\\n            head = head->next;\\n        }\\n        if(head == NULL)\\n            return head;\\n        \\n        head->next = removeElements(head->next,value);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int value) {\\n        \\n        \\n        while(head != NULL && head->val == value){\\n            head = head->next;\\n        }\\n        if(head == NULL)\\n            return head;\\n        \\n        head->next = removeElements(head->next,value);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369093,
                "title": "simple-python-recursion",
                "content": "1. The base case: return None when there is no more head node i.e. the end of the linked list\\n2. The recursive case: we traverse through the rest of the linked list by repatitively calling the function itself, and point head.next to the return result \\n3. On each level of the recrusion, we check if head.val equals val. If it does, we replace the head node with the next node. Otherwise, we simply return the head\\n```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        \\n        if not head:\\n            return head\\n\\n        head.next = self.removeElements(head.next, val)        \\n        if head.val == val:\\n            head = head.next\\n\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        \\n        if not head:\\n            return head\\n\\n        head.next = self.removeElements(head.next, val)        \\n        if head.val == val:\\n            head = head.next\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456137,
                "title": "simple-java-solution-faster-than-98",
                "content": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        else {\\n            if (head.val == val) return removeElements(head.next, val);\\n            else {\\n                head.next = removeElements(head.next, val);\\n                return head;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        else {\\n            if (head.val == val) return removeElements(head.next, val);\\n            else {\\n                head.next = removeElements(head.next, val);\\n                return head;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300871,
                "title": "c-clear-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        var dummy = new ListNode(0);\\n        var cur = dummy;\\n        while (head != null) {\\n            if (head.val != val) {\\n                cur.next = head;\\n                cur = cur.next;\\n            }    \\n            head = head.next;\\n        }\\n        cur.next = null;\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        var dummy = new ListNode(0);\\n        var cur = dummy;\\n        while (head != null) {\\n            if (head.val != val) {\\n                cur.next = head;\\n                cur = cur.next;\\n            }    \\n            head = head.next;\\n        }\\n        cur.next = null;\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57388,
                "title": "simple-python-solution",
                "content": "```\\ndef removeElements(self, head, val):\\n        \\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        pointer = dummy\\n        \\n        while(pointer.next):\\n            \\n            if pointer.next.val == val:\\n                pointer.next = pointer.next.next\\n            else:\\n                pointer = pointer.next\\n                \\n        return dummy.next",
                "solutionTags": [],
                "code": "```\\ndef removeElements(self, head, val):\\n        \\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        pointer = dummy\\n        \\n        while(pointer.next):\\n            \\n            if pointer.next.val == val:\\n                pointer.next = pointer.next.next\\n            else:\\n                pointer = pointer.next\\n                \\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 57422,
                "title": "java-solution-with-brief-explanation",
                "content": "basic idea is to have two pointers, one for previous node and one for current, if current node.val == val \\nwe want to set our previous.next to current.next.\\n\\nbut one problem is what if the head.val == val, I used a while loop to get ride of this situation. So I can be sure that head is always a valid node.\\n\\n\\n\\npublic ListNode removeElements(ListNode head, int val)\\n {\\n\\n        while(head != null && head.val == val){\\n            head = head.next;\\n        }    \\n        if(head == null)\\n            return null;\\n        ListNode pre = head, cur = head.next;\\n        while(cur != null){\\n            if(cur.val == val){\\n                pre.next = cur.next;\\n            }else {\\n                pre = pre.next;\\n            }\\n            cur = cur.next;\\n        }\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "basic idea is to have two pointers, one for previous node and one for current, if current node.val == val \\nwe want to set our previous.next to current.next.\\n\\nbut one problem is what if the head.val == val, I used a while loop to get ride of this situation. So I can be sure that head is always a valid node.\\n\\n\\n\\npublic ListNode removeElements(ListNode head, int val)\\n {\\n\\n        while(head != null && head.val == val){\\n            head = head.next;\\n        }    \\n        if(head == null)\\n            return null;\\n        ListNode pre = head, cur = head.next;\\n        while(cur != null){\\n            if(cur.val == val){\\n                pre.next = cur.next;\\n            }else {\\n                pre = pre.next;\\n            }\\n            cur = cur.next;\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3742478,
                "title": "simple-solution-beats-maximum",
                "content": "# Please upvote if you feel it easy\\uD83D\\uDE0A\\u2764\\n# Code\\n```\\n\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        \\n        if(head == null) return null;\\n        while(head!=null && head.val == val) head = head.next;\\n        ListNode temp = head;\\n        while(temp!=null && temp.next !=null) {\\n            if(temp.next.val == val) {\\n                temp.next = temp.next.next;\\n            }else{\\n                temp = temp.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        \\n        if(head == null) return null;\\n        while(head!=null && head.val == val) head = head.next;\\n        ListNode temp = head;\\n        while(temp!=null && temp.next !=null) {\\n            if(temp.next.val == val) {\\n                temp.next = temp.next.next;\\n            }else{\\n                temp = temp.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272069,
                "title": "python3-73ms-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Two Pointers Methods.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- maintain **two pointers** **prev and current**, meaning is self-described.\\n- now when **removing element is head** then **remove** head **till** it\\'s **not removing element**, till this time our **prev will be None**.\\n- now if removing element is not head then **prev.next = curr.next** and **curr = curr.next**, prev will be same because **if** we do **prev = curr** then **prev will be removed node**.\\n- now when we encounter **node** that is **not removing** then do **prev = curr and curr = curr.next.**\\n- do this all till curr is not None\\n- **return head**.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        prev = None\\n        curr = head\\n        while curr:\\n            if curr.val == val and prev:\\n                prev.next = curr.next\\n                curr = curr.next\\n                continue\\n            elif curr.val == val and not prev:\\n                head = head.next\\n                curr = curr.next\\n                continue\\n            prev = curr\\n            curr = curr.next\\n        return head\\n```\\n# Please like and comment below (\\u0336\\u25C9\\u035B\\u203F\\u25C9\\u0336)",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        prev = None\\n        curr = head\\n        while curr:\\n            if curr.val == val and prev:\\n                prev.next = curr.next\\n                curr = curr.next\\n                continue\\n            elif curr.val == val and not prev:\\n                head = head.next\\n                curr = curr.next\\n                continue\\n            prev = curr\\n            curr = curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735959,
                "title": "c-recursive-easy-3-steps-solution-easy-approach",
                "content": "#### If you understand the approach please please upvote!!!\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        // base case\\n        if(head == NULL) return head;\\n        \\n        // recursive call\\n        head->next = removeElements(head->next, val);\\n        \\n        //small calculation\\n        if(head->val == val) {\\n            return head->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        // base case\\n        if(head == NULL) return head;\\n        \\n        // recursive call\\n        head->next = removeElements(head->next, val);\\n        \\n        //small calculation\\n        if(head->val == val) {\\n            return head->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722158,
                "title": "java-recursion-80-faster",
                "content": "```\\n\\npublic ListNode removeElements(ListNode head, int val) {\\n        if(head==null)\\n            return head;\\n        ListNode ans = removeElements(head.next,val);\\n        if(head.val==val)\\n            return ans;\\n        else{\\n            head.next = ans;\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\npublic ListNode removeElements(ListNode head, int val) {\\n        if(head==null)\\n            return head;\\n        ListNode ans = removeElements(head.next,val);\\n        if(head.val==val)\\n            return ans;\\n        else{\\n            head.next = ans;\\n            return head;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1573492,
                "title": "rust-simple-one-pass-solution",
                "content": "#### If you like my solution, then you should check my [leetcode github repo](https://github.com/SvetlinZarev/coding-challenges/tree/main/leetcode)\\n\\n### Solution with the old compiler version @leetcode (rust 1.48)\\n\\n```rust\\npub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n    let mut dummy = None;\\n    let mut tail = &mut dummy;\\n\\n    while let Some(mut node) = head.take() {\\n        head = node.next.take();\\n\\n        if node.val != val {\\n            *tail = Some(node);\\n            tail = &mut tail.as_mut().unwrap().next;\\n        }\\n    }\\n\\n    dummy\\n}\\n```\\n\\n\\n### Alternative implementation without `.unwrap()` for the old compiler version:\\n\\n```rust\\npub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n    let mut head = head;\\n    let mut ptr = &mut head;\\n\\n    loop {\\n        match ptr {\\n            None => break,\\n            Some(node) if node.val == val => *ptr = node.next.take(),\\n            Some(node) => ptr = &mut node.next,\\n        }\\n    }\\n\\n    head\\n}\\n```\\n\\n### Alternative, cleaner version without `unwrap()` for the new compiler (rust >= 1.53)\\n\\n```rust\\npub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n    let mut list = None;\\n    let mut tail = &mut list;\\n\\n    while let Some(mut node) = head.take() {\\n        head = node.next.take();\\n\\n        if node.val != val {\\n            tail = &mut tail.insert(node).next;\\n        }\\n    }\\n\\n    list\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n    let mut dummy = None;\\n    let mut tail = &mut dummy;\\n\\n    while let Some(mut node) = head.take() {\\n        head = node.next.take();\\n\\n        if node.val != val {\\n            *tail = Some(node);\\n            tail = &mut tail.as_mut().unwrap().next;\\n        }\\n    }\\n\\n    dummy\\n}\\n```\n```rust\\npub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n    let mut head = head;\\n    let mut ptr = &mut head;\\n\\n    loop {\\n        match ptr {\\n            None => break,\\n            Some(node) if node.val == val => *ptr = node.next.take(),\\n            Some(node) => ptr = &mut node.next,\\n        }\\n    }\\n\\n    head\\n}\\n```\n```rust\\npub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n    let mut list = None;\\n    let mut tail = &mut list;\\n\\n    while let Some(mut node) = head.take() {\\n        head = node.next.take();\\n\\n        if node.val != val {\\n            tail = &mut tail.insert(node).next;\\n        }\\n    }\\n\\n    list\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1572963,
                "title": "simple-to-understand-using-basic-loop-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        var ptr = head;\\n        \\n        // Loop through data checking to see if the next node equals the target value\\n        while (ptr != null && ptr.next != null) {            \\n            // If the next node value is the target value, set the next node\\n            // to point to the one after it\\n            if (ptr.next != null && ptr.next.val == val) {\\n                ptr.next = ptr.next.next;\\n            } else {\\n                // Next node doesnt equal target, advance to the next node\\n                ptr = ptr.next;\\n            }\\n        }        \\n        // If the head equals the target value, advance to the next\\n        if (head != null && head.val == val) {\\n            head = head.next;\\n        }          \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        var ptr = head;\\n        \\n        // Loop through data checking to see if the next node equals the target value\\n        while (ptr != null && ptr.next != null) {            \\n            // If the next node value is the target value, set the next node\\n            // to point to the one after it\\n            if (ptr.next != null && ptr.next.val == val) {\\n                ptr.next = ptr.next.next;\\n            } else {\\n                // Next node doesnt equal target, advance to the next node\\n                ptr = ptr.next;\\n            }\\n        }        \\n        // If the head equals the target value, advance to the next\\n        if (head != null && head.val == val) {\\n            head = head.next;\\n        }          \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900341,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        prev, curr = None, head\\n        while curr:\\n            if curr.val == val:\\n                if prev:\\n                    prev.next = curr.next\\n                else:\\n                    head = curr.next\\n            else:\\n                prev = curr\\n            curr = curr.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        prev, curr = None, head\\n        while curr:\\n            if curr.val == val:\\n                if prev:\\n                    prev.next = curr.next\\n                else:\\n                    head = curr.next\\n            else:\\n                prev = curr\\n            curr = curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745439,
                "title": "easy-c-solution-explained",
                "content": "```\\n  ListNode* removeElements(ListNode* head, int val) {\\n        \\n        ListNode* curr = head;\\n        if(head == NULL)\\n        {\\n            return NULL;\\n        }\\n        while(curr->next!= NULL)  //Iterate until linked list is not null\\n        {\\n            if(curr->next->val == val)  // If the next element\\'s value equals  \\'val\\' . Then Shift currents next to the next of current\\'s next node. And repeat same, checking current with currents next.\\n            {\\n                curr->next = curr->next->next;\\n            }\\n            else       // otherwise shift current to currents next.\\n            {\\n                curr = curr->next;\\n            }\\n        }\\n        if(head->val == val)   // Check if the initial Head ( beginning current) was equal to Val. If so, shift it to next.\\n        {\\n            head = head->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  ListNode* removeElements(ListNode* head, int val) {\\n        \\n        ListNode* curr = head;\\n        if(head == NULL)\\n        {\\n            return NULL;\\n        }\\n        while(curr->next!= NULL)  //Iterate until linked list is not null\\n        {\\n            if(curr->next->val == val)  // If the next element\\'s value equals  \\'val\\' . Then Shift currents next to the next of current\\'s next node. And repeat same, checking current with currents next.\\n            {\\n                curr->next = curr->next->next;\\n            }\\n            else       // otherwise shift current to currents next.\\n            {\\n                curr = curr->next;\\n            }\\n        }\\n        if(head->val == val)   // Check if the initial Head ( beginning current) was equal to Val. If so, shift it to next.\\n        {\\n            head = head->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 505560,
                "title": "c-and-js-very-short-three-lines-easy-to-understand-no-really",
                "content": "Javascript\\n```\\nconst removeElements = (h, val) => {\\n    if (!h) return null\\n    h.next = removeElements(h.next, val)\\n    return h.val === val ? h.next : h\\n}\\n```\\n\\nC#\\n```\\npublic ListNode RemoveElements(ListNode h, int v) {\\n\\tif (h == null) return null;\\n\\th.next = RemoveElements(h.next, v);\\n\\treturn h.val == v ? h.next : h;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeElements = (h, val) => {\\n    if (!h) return null\\n    h.next = removeElements(h.next, val)\\n    return h.val === val ? h.next : h\\n}\\n```\n```\\npublic ListNode RemoveElements(ListNode h, int v) {\\n\\tif (h == null) return null;\\n\\th.next = RemoveElements(h.next, v);\\n\\treturn h.val == v ? h.next : h;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 384312,
                "title": "easy-c-solution-20ms-no-extra-prev-pointer",
                "content": "Use a dummy node, for cases when head is to be deleted.\\nRuntime: 20 ms, faster than 99.60% of C++ online submissions for Remove Linked List Elements.\\nMemory Usage: 11 MB, less than 69.81% of C++ online submissions for Remove Linked List Elements.\\n\\n```\\nListNode* removeElements(ListNode* head, int val) {\\n        \\n        ListNode dummy(-1);\\n        dummy.next = head;\\n        ListNode* curr = &dummy;\\n        \\n        while(curr->next)\\n        {\\n            if(curr->next->val == val)\\n            {\\n                ListNode* nextNode = curr->next->next;\\n                curr->next->next = NULL;\\n                curr->next = nextNode;\\n            }\\n            else\\n                curr = curr->next;\\n        }\\n        \\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Use a dummy node, for cases when head is to be deleted.\\nRuntime: 20 ms, faster than 99.60% of C++ online submissions for Remove Linked List Elements.\\nMemory Usage: 11 MB, less than 69.81% of C++ online submissions for Remove Linked List Elements.\\n\\n```\\nListNode* removeElements(ListNode* head, int val) {\\n        \\n        ListNode dummy(-1);\\n        dummy.next = head;\\n        ListNode* curr = &dummy;\\n        \\n        while(curr->next)\\n        {\\n            if(curr->next->val == val)\\n            {\\n                ListNode* nextNode = curr->next->next;\\n                curr->next->next = NULL;\\n                curr->next = nextNode;\\n            }\\n            else\\n                curr = curr->next;\\n        }\\n        \\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3913251,
                "title": "only-3-liner-100-beats",
                "content": "\\n# class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head==null) return null;\\n        head.next = removeElements(head.next, val);\\n        return head.val==val?head.next:head;\\n    }\\n}\\n<!-- if(head==null){\\n            return null;\\n        }\\n        ListNode curr=head;\\n        while(curr.next!=null){\\n            if(curr.next.val==val){\\n                \\n                curr.next=curr.next.next;\\n            }\\n            else\\n            curr=curr.next;\\n        }\\n        if(head.val==val){\\n            return head.next;\\n        }\\n        else{\\n            return head; -->",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head==null) return null;\\n        head.next = removeElements(head.next, val);\\n        return head.val==val?head.next:head;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2966924,
                "title": "c-solution-with-explanation-2-pointers-listnode",
                "content": "# Approach\\n- Create 2 pointers: prev and curr\\n- prev will point to additional dummy node inserted before head, curr will point to head\\n- Iterate curr till end of list: if curr.val == val, move prev pointer to next pointer of curr (meaning it will skip the curr node)\\nOtherwise, assign prev = curr\\n- Return dummy.next as its the prev pointer\\'s path\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode prev = dummy;\\n        ListNode curr = head;\\n        \\n        while(curr != null)\\n        {\\n            if(curr.val == val)\\n                prev.next = curr.next;\\n            else\\n                prev = curr;\\n            curr = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode prev = dummy;\\n        ListNode curr = head;\\n        \\n        while(curr != null)\\n        {\\n            if(curr.val == val)\\n                prev.next = curr.next;\\n            else\\n                prev = curr;\\n            curr = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248711,
                "title": "python-dummy-node-solution-explained-time-o-n-space-o-1",
                "content": "# Explaination:\\nWe are given a linked list and a value, we want to remove all instances of that value from the linked list.\\nA tricky issue you may have with this problem is an input like: 0->0->0->0-> val = 0\\nSince usually to delete nodes we need to take the previous node and change its `.next` pointer to point to the node after the one we want to delete.\\nIn the example 1 -> 2 -> 3, to delete 2, we would need to point 1 to 3.\\n\\nThe problem with our 0->0->0->0 example is we don\\'t have a previous node to use since we need to delete all nodes starting from the first 0.\\n\\nTo handle this issue we will create a `dummyNode` and use that as our `prev` node to help with the deletions.\\n\\n**Solution Breakdown:**\\n1. We create our `dummyNode` and initialize it as an empty `ListNode`. Then we set `dummyNode.next` to `head` to connect it to our linked list.\\n2. Now we create our `prev` and this will point to the `dummyNode`\\n3. Now we create our `current` variable and point it to the `head` of the linked list\\n4. We will iterate through the linked list until `current` becomes `None`.\\n5. If `current.val` is equal to the `val` we were given to delete, we will set our `prev.next` to point to `current.next` since we want to delete the `current` node.\\n6. If `current.val` is not equal to `val`, we just set our `prev` variable to point to `current` since this node was not marked to be deleted.\\n7. On every iteration we move our pointer forward by 1 node by doing `current = current.next`\\n8. After we finish we return `dummyNode.next` because we want to return the modified linked list without the `dummyNode` included.\\n\\n**Time O(N) | Space O(1)**\\nTime is O(N) because at most we are iterating through the entire linked list once\\nSpace is O(1) because we aren\\'t saving anything in memory which would scale with the input, we are only creating some variables and modifying them throughout our iterations.\\n\\n\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummyNode = ListNode()\\n        dummyNode.next = head\\n        \\n        prev = dummyNode\\n        current = head\\n        \\n        while current:\\n            if current.val == val:\\n                prev.next = current.next\\n            else:  \\n                prev = current\\n            current = current.next\\n        \\n        return dummyNode.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummyNode = ListNode()\\n        dummyNode.next = head\\n        \\n        prev = dummyNode\\n        current = head\\n        \\n        while current:\\n            if current.val == val:\\n                prev.next = current.next\\n            else:  \\n                prev = current\\n            current = current.next\\n        \\n        return dummyNode.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650456,
                "title": "java-100-faster-easy",
                "content": "The debugging took me three tries lol\\n## Please upvote if it helps! Thx :D\\n\\n```\\n    public ListNode removeElements(ListNode head, int val) {\\n        while (head!=null && head.val == val) {\\n            head = head.next;\\n        }\\n        ListNode p = head;\\n        while (p != null){\\n            while (p.next!=null && p.next.val == val) p.next = p.next.next;\\n            p = p.next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public ListNode removeElements(ListNode head, int val) {\\n        while (head!=null && head.val == val) {\\n            head = head.next;\\n        }\\n        ListNode p = head;\\n        while (p != null){\\n            while (p.next!=null && p.next.val == val) p.next = p.next.next;\\n            p = p.next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1573799,
                "title": "c-simple-and-clean-solution-explained-with-freeing-memory",
                "content": "**Idea:**\\nWe create a `new_head` which is previous to the regular head. This makes it super easy to remove nodes in the beginning of the list.\\nThen, each time we find a node with value equals `val`, we just make a \"bypass\" and link the previous node to the next one.\\nWe save in `tmp` a pointer to the removed node to be able to free the memory.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* new_head = new ListNode(-1), *tmp;\\n        new_head->next = head;\\n        head = new_head;\\n\\n        while (head->next) {\\n            if (head->next->val == val) {\\n                tmp = head->next;\\n                head->next = head->next->next;\\n                delete tmp;\\n            }\\n            else head = head->next;\\n        }\\n\\n        return new_head->next;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* new_head = new ListNode(-1), *tmp;\\n        new_head->next = head;\\n        head = new_head;\\n\\n        while (head->next) {\\n            if (head->next->val == val) {\\n                tmp = head->next;\\n                head->next = head->next->next;\\n                delete tmp;\\n            }\\n            else head = head->next;\\n        }\\n\\n        return new_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492438,
                "title": "96-javascript-solution-o-n-with-comments-feedback-welcomed",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n\\ninput \\n\\thead of linked list and int\\noutput \\n\\tlinked list\\nconstraints\\n\\tThe number of nodes in the list is in the range [0, 104]. => we can be given an empty linked list/ head\\nedges\\n\\tempty linked list / head\\n\\ntranslate\\n\\treturn a linked list with nodes with input val removed\\nexample1\\n\\t[1,2,3,4,5] val = 6 // [1,2,3,4,5]\\nexample2\\n\\t[1,1,1,1,1] val = 1 // []\\nexample3\\n\\t[1,2,1,2,1,2] val = 2 // [1,1,1]\\nexample4\\n\\t[] val = 1 // []\\n */\\nvar removeElements = function(head, val) {\\n// constraint stated: \"The number of nodes in the list is in the range [0, 104]. \"\\n// so we have to have a conditional to check if we\\'re given an empty head\\n\\n  if (!head) {\\n    return head;\\n  }\\n  \\n  let curr = head;\\n  \\n  // loop through curr up until 2nd to last node since our if statement checks the following node\\n  // we would error out without && curr.next since it will try to do .val on the null node\\n  while (curr && curr.next) {\\n    if (curr.next.val === val) {\\n      curr.next = curr.next.next;\\n    } else {\\n      curr = curr.next;\\n    }\\n  }\\n  \\n  // our loop never checked the head if it was the val to be removed so we use a ternary operator\\n  // to return the head.next if the current head is to be removed \\n  // if not we can return head as is\\n  return head.val === val ? head.next : head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n\\ninput \\n\\thead of linked list and int\\noutput \\n\\tlinked list\\nconstraints\\n\\tThe number of nodes in the list is in the range [0, 104]. => we can be given an empty linked list/ head\\nedges\\n\\tempty linked list / head\\n\\ntranslate\\n\\treturn a linked list with nodes with input val removed\\nexample1\\n\\t[1,2,3,4,5] val = 6 // [1,2,3,4,5]\\nexample2\\n\\t[1,1,1,1,1] val = 1 // []\\nexample3\\n\\t[1,2,1,2,1,2] val = 2 // [1,1,1]\\nexample4\\n\\t[] val = 1 // []\\n */\\nvar removeElements = function(head, val) {\\n// constraint stated: \"The number of nodes in the list is in the range [0, 104]. \"\\n// so we have to have a conditional to check if we\\'re given an empty head\\n\\n  if (!head) {\\n    return head;\\n  }\\n  \\n  let curr = head;\\n  \\n  // loop through curr up until 2nd to last node since our if statement checks the following node\\n  // we would error out without && curr.next since it will try to do .val on the null node\\n  while (curr && curr.next) {\\n    if (curr.next.val === val) {\\n      curr.next = curr.next.next;\\n    } else {\\n      curr = curr.next;\\n    }\\n  }\\n  \\n  // our loop never checked the head if it was the val to be removed so we use a ternary operator\\n  // to return the head.next if the current head is to be removed \\n  // if not we can return head as is\\n  return head.val === val ? head.next : head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1116011,
                "title": "java-0ms-100-faster",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n    if(head==null)\\n        return null;\\n    ListNode temp=head;\\n        while(temp.next!=null){\\n            if(temp.next.val==val)\\n                temp.next=temp.next.next;\\n            else\\n                temp=temp.next;\\n        }\\n        return  head.val == val ? head.next : head;\\n        \\n    }\\n}\\n \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n    if(head==null)\\n        return null;\\n    ListNode temp=head;\\n        while(temp.next!=null){\\n            if(temp.next.val==val)\\n                temp.next=temp.next.next;\\n            else\\n                temp=temp.next;\\n        }\\n        return  head.val == val ? head.next : head;\\n        \\n    }\\n}\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008705,
                "title": "c-iterative-recursive-solution",
                "content": "#### Iterative Appraoch\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* removeElements(ListNode* head, int val) {\\n\\t\\t\\tListNode *preHead = new ListNode(-1);\\n\\t\\t\\tpreHead -> next = head;\\n\\t\\t\\tListNode *curr = preHead;\\n\\n\\t\\t\\twhile(curr != NULL){\\n\\t\\t\\t\\tif(curr -> next != NULL and curr -> next -> val == val){\\n\\t\\t\\t\\t\\tcurr -> next = curr -> next -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tcurr = curr -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn preHead -> next;\\n\\t\\t}\\n\\t};\\n\\t\\n#### Recursive Appraoch\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* removeElements(ListNode* head, int val) {\\n\\t\\t\\tif(head == NULL){\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\t}\\n\\t\\t\\tif(head -> val != val){\\n\\t\\t\\t\\thead -> next = removeElements(head -> next, val);\\n\\t\\t\\t\\treturn head;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tListNode* newHead = head -> next;\\n\\t\\t\\t\\treturn removeElements(newHead, val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* removeElements(ListNode* head, int val) {\\n\\t\\t\\tListNode *preHead = new ListNode(-1);\\n\\t\\t\\tpreHead -> next = head;\\n\\t\\t\\tListNode *curr = preHead;\\n\\n\\t\\t\\twhile(curr != NULL){\\n\\t\\t\\t\\tif(curr -> next != NULL and curr -> next -> val == val){\\n\\t\\t\\t\\t\\tcurr -> next = curr -> next -> next;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 746134,
                "title": "python-3-single-loop-o-n",
                "content": "```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        curr = head\\n        prev = None\\n        \\n        while(curr):\\n            if curr.val == val: \\n                if curr == head:\\n                    head = head.next\\n                    curr = head\\n                else:\\n                    prev.next = curr.next\\n                    curr = prev.next\\n            else:\\n                prev = curr\\n                curr = curr.next\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        curr = head\\n        prev = None\\n        \\n        while(curr):\\n            if curr.val == val: \\n                if curr == head:\\n                    head = head.next\\n                    curr = head\\n                else:\\n                    prev.next = curr.next\\n                    curr = prev.next\\n            else:\\n                prev = curr\\n                curr = curr.next\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565756,
                "title": "c-c-quick-and-short-solutions-using-pointer-to-pointer-o-n-time-o-1-space",
                "content": "Often the hardest thing about using link lists is the corner cases. In this particular problem the obvious corner case is the case where the `head` gets removed.\\n\\nUsing pointer to a pointer approach allows for a solution that removes the corner cases and allows for just a few lines of code to efficently proces.\\n\\n```c []\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n  struct ListNode** nextPtr = &head;\\n  while (*nextPtr) {\\n    if ((**nextPtr).val == val) {\\n      *nextPtr = (**nextPtr).next;\\n    } else {\\n      nextPtr = &(**nextPtr).next;\\n    }\\n  }\\n  return head;\\n}\\n```\\n\\n```cpp []\\nListNode* removeElements(ListNode* head, int val) {\\n  ListNode** nextPtr = &head;\\n  while (*nextPtr) {\\n    if ((**nextPtr).val == val) {\\n      *nextPtr = (**nextPtr).next;\\n    } else {\\n      nextPtr = &(**nextPtr).next;\\n    }\\n  }\\n  return head;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c []\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n  struct ListNode** nextPtr = &head;\\n  while (*nextPtr) {\\n    if ((**nextPtr).val == val) {\\n      *nextPtr = (**nextPtr).next;\\n    } else {\\n      nextPtr = &(**nextPtr).next;\\n    }\\n  }\\n  return head;\\n}\\n```\n```cpp []\\nListNode* removeElements(ListNode* head, int val) {\\n  ListNode** nextPtr = &head;\\n  while (*nextPtr) {\\n    if ((**nextPtr).val == val) {\\n      *nextPtr = (**nextPtr).next;\\n    } else {\\n      nextPtr = &(**nextPtr).next;\\n    }\\n  }\\n  return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355025,
                "title": "rust-two-level-pointer",
                "content": "Remove a node from a linked list is a perfect scene to use two level pointer, aka, pointer to pointer.\\nThe solution is very straight forward, use a pointer(named `walker`) to traverse the list:\\n\\t1. If we meet the deleting node, modify(delete) the node by the `walker`\\n\\t2. if not, modify `walker` to go on traversing.\\nThere is also a c++ version, may be helpful for understanding.\\n```\\nimpl Solution {\\n    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut walker = &mut head;\\n        while walker.is_some() {\\n            if walker.as_ref().unwrap().val == val {\\n                *walker = walker.take().unwrap().next;\\n            } else {\\n                walker = &mut walker.as_mut().unwrap().next;\\n            }\\n        }\\n        head\\n    }\\n}\\n```\\n\\nC++ verison\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        auto walker = &head;\\n        while (nullptr != *walker) {\\n            if (val == (*walker)->val) {\\n                auto to_delete = *walker;\\n                *walker = (*walker)->next;\\n                delete to_delete;\\n            } else {\\n                walker = &(*walker)->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut walker = &mut head;\\n        while walker.is_some() {\\n            if walker.as_ref().unwrap().val == val {\\n                *walker = walker.take().unwrap().next;\\n            } else {\\n                walker = &mut walker.as_mut().unwrap().next;\\n            }\\n        }\\n        head\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        auto walker = &head;\\n        while (nullptr != *walker) {\\n            if (val == (*walker)->val) {\\n                auto to_delete = *walker;\\n                *walker = (*walker)->next;\\n                delete to_delete;\\n            } else {\\n                walker = &(*walker)->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271790,
                "title": "golang",
                "content": "```\\nfunc removeElements(head *ListNode, val int) *ListNode {\\n\\tdummy := &ListNode{Next: head}\\n\\tcur := dummy\\n\\tfor cur.Next != nil {\\n\\t\\tif cur.Next.Val == val {\\n\\t\\t\\tcur.Next = cur.Next.Next\\n\\t\\t} else {\\n\\t\\t\\tcur = cur.Next\\n\\t\\t}\\n\\t}\\n\\n\\treturn dummy.Next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc removeElements(head *ListNode, val int) *ListNode {\\n\\tdummy := &ListNode{Next: head}\\n\\tcur := dummy\\n\\tfor cur.Next != nil {\\n\\t\\tif cur.Next.Val == val {\\n\\t\\t\\tcur.Next = cur.Next.Next\\n\\t\\t} else {\\n\\t\\t\\tcur = cur.Next\\n\\t\\t}\\n\\t}\\n\\n\\treturn dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 57310,
                "title": "python-solution-without-dummy-head",
                "content": "\\n```\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        Remove all elements from a linked list of integers that have value val.\\n        Use the head to eliminite first n hits, and use pointer to eliminite the rest\\n        e.g 1->1->1->2->3->1, 1\\n        Head will be moved to 2, pointer will start from 3\\n        \\n        time complexity: O(n)\\n        space complexity: O(1)\\n      \\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n\\n        # move the head to its next node if its value is equal to the input value\\n        while head is not None and head.val == val:\\n            head = head.next\\n\\n        # handle null value after moving\\n        if head is None:\\n            return None\\n\\n        # create a pointer reference to the head node, and loop to check its next node's value\\n        # if it is equal to the input val, skip that node\\n        cur = head\\n        while cur.next:\\n            if cur.next.val == val:\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        Remove all elements from a linked list of integers that have value val.\\n        Use the head to eliminite first n hits, and use pointer to eliminite the rest\\n        e.g 1->1->1->2->3->1, 1\\n        Head will be moved to 2, pointer will start from 3\\n        \\n        time complexity: O(n)\\n        space complexity: O(1)\\n      \\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n\\n        # move the head to its next node if its value is equal to the input value\\n        while head is not None and head.val == val:\\n            head = head.next\\n\\n        # handle null value after moving\\n        if head is None:\\n            return None\\n\\n        # create a pointer reference to the head node, and loop to check its next node's value\\n        # if it is equal to the input val, skip that node\\n        cur = head\\n        while cur.next:\\n            if cur.next.val == val:\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 57335,
                "title": "python-ac-solution-beat-91-submissions-easy-to-understand",
                "content": "    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        # Remove the heading nodes\\n        while head and head.val == val:\\n            head = head.next\\n        if not head:\\n            return head\\n        prev, cur = head, head.next\\n        while cur:\\n            while cur and cur.val == val:\\n                cur = cur.next\\n            prev.next = cur\\n            if cur:\\n                prev, cur = prev.next, cur.next\\n        return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        # Remove the heading nodes\\n        while head and head.val == val:\\n            head = head.next\\n        if not head:\\n            return head\\n        prev, cur = head, head.next\\n        while cur:\\n            while cur and cur.val == val:\\n                cur = cur.next\\n            prev.next = cur\\n            if cur:\\n                prev, cur = prev.next, cur.next\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 57504,
                "title": "java-solved-recursively",
                "content": "    public class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            ListNode result = head;\\n            if (result == null) {\\n                return null;\\n            } else if (result.val == val) {\\n                return removeElements(result.next, val);\\n            } else {\\n                result.next = removeElements(result.next, val);\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            ListNode result = head;\\n            if (result == null) {\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 57512,
                "title": "the-answer-you-are-wished-to-offer-when-in-an-interview",
                "content": "    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode **pp = &head;\\n        while (*pp)\\n            if ((*pp)->val == val)\\n                *pp = (*pp)->next;\\n            else\\n                pp = &(*pp)->next;\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode **pp = &head;\\n        while (*pp)\\n            if ((*pp)->val == val)\\n                *pp = (*pp)->next;\\n            else\\n                pp = &(*pp)->next;\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3280921,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head == NULL) return head;\\n        ListNode *node = head;\\n        while(node and node->next) {\\n            if(node->next->val == val) node->next = node->next->next;\\n            else node = node->next;\\n        }\\n        if(head->val == val) head = head->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head == NULL) return head;\\n        ListNode *node = head;\\n        while(node and node->next) {\\n            if(node->next->val == val) node->next = node->next->next;\\n            else node = node->next;\\n        }\\n        if(head->val == val) head = head->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136809,
                "title": "python-simple-and-clean-beats-98-69",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea here is to use a dummy node as the starting point of the linked list and traverse through the linked list until the end of the list, updating the links accordingly whenever we encounter a node with value val.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a dummy node dummy and assign head as its next node. This is to simplify the edge case where the linked list starts with a node with value val.\\n- Initialize two pointers prev and curr, both pointing to dummy.\\n- Traverse through the linked list by updating curr to its next node in each iteration and also keep a reference to the next node in nxt.\\n- If curr has value val, update prev.next to nxt to skip curr node.\\n- If curr does not have value val, update prev to curr.\\n- Repeat the process until curr is None.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode(next = head)\\n        curr = head \\n        prev = dummy\\n        \\n        while curr:\\n            nxt = curr.next\\n\\n            if curr.val == val:\\n                prev.next = nxt\\n            else:\\n                prev = curr\\n            curr = nxt\\n            \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode(next = head)\\n        curr = head \\n        prev = dummy\\n        \\n        while curr:\\n            nxt = curr.next\\n\\n            if curr.val == val:\\n                prev.next = nxt\\n            else:\\n                prev = curr\\n            curr = nxt\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066708,
                "title": "using-dummy-node",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode curr = dummy;      //Start of dummy node has a fake node then head node\\n         while(curr.next!=null){    //next node is the head of curr linked list\\n           if(curr.next.val==val){\\n               curr.next=curr.next.next;\\n           }\\n           else{\\n               curr=curr.next;\\n           }\\n        }\\n        return dummy.next;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode curr = dummy;      //Start of dummy node has a fake node then head node\\n         while(curr.next!=null){    //next node is the head of curr linked list\\n           if(curr.next.val==val){\\n               curr.next=curr.next.next;\\n           }\\n           else{\\n               curr=curr.next;\\n           }\\n        }\\n        return dummy.next;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957589,
                "title": "c-90-simple-solution-o-n",
                "content": "```\\nstruct ListNode* removeElements(struct ListNode* head, int val)\\n{\\n    while (head != NULL && head->val == val)\\n        head = head->next;\\n    \\n    for (struct ListNode *cur = head; cur && cur->next;) {\\n        if (cur->next->val == val)\\n            cur->next = cur->next->next;\\n        else\\n            cur = cur->next;\\n    }\\n\\n    return head;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct ListNode* removeElements(struct ListNode* head, int val)\\n{\\n    while (head != NULL && head->val == val)\\n        head = head->next;\\n    \\n    for (struct ListNode *cur = head; cur && cur->next;) {\\n        if (cur->next->val == val)\\n            cur->next = cur->next->next;\\n        else\\n            cur = cur->next;\\n    }\\n\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1473682,
                "title": "simple-java-solution-0ms-100-no-dummy-head",
                "content": "Keep checking if the next node is to be deleted. If yes, set next pointer of current node to next\\'s next. Else, simple move current node pointer to next.\\nWhile returning, check if head\\'s value matches value of node to be deleted. If yes, return head.next else return head.\\n```    \\npublic ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return head;\\n        \\n        ListNode curr = head;\\n        while (curr.next != null) {\\n            if (curr.next.val == val)\\n                curr.next = curr.next.next;\\n            else\\n                curr = curr.next;\\n        }\\n        return head.val == val ? head.next : head;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "Keep checking if the next node is to be deleted. If yes, set next pointer of current node to next\\'s next. Else, simple move current node pointer to next.\\nWhile returning, check if head\\'s value matches value of node to be deleted. If yes, return head.next else return head.\\n```    \\npublic ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return head;\\n        \\n        ListNode curr = head;\\n        while (curr.next != null) {\\n            if (curr.next.val == val)\\n                curr.next = curr.next.next;\\n            else\\n                curr = curr.next;\\n        }\\n        return head.val == val ? head.next : head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1450105,
                "title": "python-supper-clean-code-by-using-dummyhead",
                "content": "```python\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        while head != None:\\n            if head.val != val:\\n                curHead.next = head\\n                curHead = curHead.next\\n            head = head.next\\n        curHead.next = None\\n        return dummyHead.next\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        while head != None:\\n            if head.val != val:\\n                curHead.next = head\\n                curHead = curHead.next\\n            head = head.next\\n        curHead.next = None\\n        return dummyHead.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257519,
                "title": "c-solution-in-simple-steps",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val)\\n    {   \\n        while(head != NULL && head->val == val)\\n        {\\n            head = head->next;\\n        }\\n        if(head == NULL)\\n        return NULL;\\n        \\n        ListNode* pointer;\\n        pointer = head;\\n        while (pointer->next != NULL)\\n        {\\n            if(pointer->next->val == val)\\n            {\\n                pointer->next = pointer->next->next;\\n            }\\n            else\\n            {\\n                pointer = pointer->next;    \\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n**Like the solution? Please upvote.....**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val)\\n    {   \\n        while(head != NULL && head->val == val)\\n        {\\n            head = head->next;\\n        }\\n        if(head == NULL)\\n        return NULL;\\n        \\n        ListNode* pointer;\\n        pointer = head;\\n        while (pointer->next != NULL)\\n        {\\n            if(pointer->next->val == val)\\n            {\\n                pointer->next = pointer->next->next;\\n            }\\n            else\\n            {\\n                pointer = pointer->next;    \\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745765,
                "title": "java-clean-code-o-n-optimal-solution",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic ListNode removeElements (ListNode head, int val) {\\n\\t\\t\\n\\t\\twhile (head != null && head.val == val) {\\n\\t\\t\\thead = head.next;\\n\\t\\t}\\n        \\n        if (head == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\t\\n\\t\\tListNode ptr = head;\\n\\t\\twhile (ptr.next != null) {\\n\\t\\t\\tif (ptr.next.val == val) {\\n\\t\\t\\t\\tptr.next = ptr.next.next;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tptr = ptr.next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn head;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic ListNode removeElements (ListNode head, int val) {\\n\\t\\t\\n\\t\\twhile (head != null && head.val == val) {\\n\\t\\t\\thead = head.next;\\n\\t\\t}\\n        \\n        if (head == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\t\\n\\t\\tListNode ptr = head;\\n\\t\\twhile (ptr.next != null) {\\n\\t\\t\\tif (ptr.next.val == val) {\\n\\t\\t\\t\\tptr.next = ptr.next.next;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tptr = ptr.next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn head;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386446,
                "title": "4ms-c-solution",
                "content": "```\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    if (head == NULL)\\n        return NULL;\\n    if(head->val == val) {\\n        return removeElements(head->next, val);\\n    } else {\\n        head -> next = removeElements(head->next, val);\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    if (head == NULL)\\n        return NULL;\\n    if(head->val == val) {\\n        return removeElements(head->next, val);\\n    } else {\\n        head -> next = removeElements(head->next, val);\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 332814,
                "title": "3-line-swift-solution-recursion",
                "content": "```\\nfunc removeElements(_ head: ListNode?, _ val: Int) -> ListNode? {\\n        guard let head = head else { return nil }\\n        head.next = removeElements(head.next, val)\\n        return head.val != val ? head : head.next\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc removeElements(_ head: ListNode?, _ val: Int) -> ListNode? {\\n        guard let head = head else { return nil }\\n        head.next = removeElements(head.next, val)\\n        return head.val != val ? head : head.next\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308610,
                "title": "4-simple-javascript-lines-68-ms-faster-than-95-57",
                "content": "```Javascript\\nfunction removeElements(H, target){\\n    if(!H) return null;\\n    if(H.val === target) return removeElements(H.next, target);\\n    \\n    H.next = removeElements(H.next, target);\\n    return H;\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```Javascript\\nfunction removeElements(H, target){\\n    if(!H) return null;\\n    if(H.val === target) return removeElements(H.next, target);\\n    \\n    H.next = removeElements(H.next, target);\\n    return H;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 284872,
                "title": "100-golang-solution",
                "content": "```\\nfunc removeElements(head *ListNode, val int) *ListNode {\\n\\tif head == nil {\\n\\t\\treturn head\\n\\t}\\n\\tcurr := head\\n\\n\\tfor ;curr.Next!=nil; {\\n\\t\\tif curr.Next.Val==val {\\n\\t\\t\\tcurr.Next = curr.Next.Next\\n\\t\\t} else {\\n\\t\\t\\tcurr = curr.Next\\n\\t\\t}\\n\\t}\\n\\tif head.Val==val {\\n\\t\\treturn head.Next\\n\\t}\\n\\treturn head\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeElements(head *ListNode, val int) *ListNode {\\n\\tif head == nil {\\n\\t\\treturn head\\n\\t}\\n\\tcurr := head\\n\\n\\tfor ;curr.Next!=nil; {\\n\\t\\tif curr.Next.Val==val {\\n\\t\\t\\tcurr.Next = curr.Next.Next\\n\\t\\t} else {\\n\\t\\t\\tcurr = curr.Next\\n\\t\\t}\\n\\t}\\n\\tif head.Val==val {\\n\\t\\treturn head.Next\\n\\t}\\n\\treturn head\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 57442,
                "title": "my-java-solution-in-1ms",
                "content": "Here is what I did.\\n\\n    public ListNode removeElements(ListNode head, int val) {\\n        while (head != null && head.val == val) {\\n            head = head.next;\\n        }\\n        \\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        ListNode current = head;\\n        while (current.next != null) {\\n            if (current.next.val == val) {\\n                current.next = current.next.next;    \\n            } else {\\n                current = current.next;\\n            }\\n        }\\n        return head;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Here is what I did.\\n\\n    public ListNode removeElements(ListNode head, int val) {\\n        while (head != null && head.val == val) {\\n            head = head.next;\\n        }\\n        \\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        ListNode current = head;\\n        while (current.next != null) {\\n            if (current.next.val == val) {\\n                current.next = current.next.next;    \\n            } else {\\n                current = current.next;\\n            }\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3846781,
                "title": "c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        while(head != NULL && head->val == val){\\n            head = head->next;\\n        }\\n        ListNode* temp = head;\\n        while(temp != NULL && temp->next != NULL){\\n            if(temp->next->val == val){\\n                temp->next = temp->next->next;\\n                continue;\\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        while(head != NULL && head->val == val){\\n            head = head->next;\\n        }\\n        ListNode* temp = head;\\n        while(temp != NULL && temp->next != NULL){\\n            if(temp->next->val == val){\\n                temp->next = temp->next->next;\\n                continue;\\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407428,
                "title": "c-o-n-solution",
                "content": "# Code\\n```\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode* current = head;\\n\\n    while (head && head->val == val)\\n        head = head->next;\\n    \\n    while (current && current->next) {\\n        if (current->next->val == val)\\n            current->next = current->next->next;\\n        else\\n            current = current->next;\\n    }\\n\\n    return head;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode* current = head;\\n\\n    while (head && head->val == val)\\n        head = head->next;\\n    \\n    while (current && current->next) {\\n        if (current->next->val == val)\\n            current->next = current->next->next;\\n        else\\n            current = current->next;\\n    }\\n\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3150934,
                "title": "simple-java-c-easy-100-readable-data-structures",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode x=head;\\n        ListNode it=x;\\n        while(x!=null && x.val==val){\\n            head=x.next;\\n            x=head;\\n        }\\n        while(x!=null){\\n            if(x.val==val){\\n               \\n                it.next=x.next;\\n                x=it.next;\\n            }\\n            else{\\n                it=x;\\n                x=x.next;\\n            }\\n            \\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode x=head;\\n        ListNode it=x;\\n        while(x!=null && x.val==val){\\n            head=x.next;\\n            x=head;\\n        }\\n        while(x!=null){\\n            if(x.val==val){\\n               \\n                it.next=x.next;\\n                x=it.next;\\n            }\\n            else{\\n                it=x;\\n                x=x.next;\\n            }\\n            \\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050006,
                "title": "c-just-traverse-easy-to-understand",
                "content": "\\n### Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode *answer = new ListNode(0);\\n        ListNode *curr = answer;\\n\\n        while(head) {\\n            if(head -> val != val) {\\n                curr -> next = head;\\n                curr = head;\\n            }\\n            head = head -> next;\\n        }\\n        curr -> next = nullptr;\\n        return answer -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode *answer = new ListNode(0);\\n        ListNode *curr = answer;\\n\\n        while(head) {\\n            if(head -> val != val) {\\n                curr -> next = head;\\n                curr = head;\\n            }\\n            head = head -> next;\\n        }\\n        curr -> next = nullptr;\\n        return answer -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967314,
                "title": "easy-to-understand-simple-c-solution",
                "content": "### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteAtEnd(ListNode*& head){\\n        ListNode* prev= head;\\n        if (head==NULL || head->next==NULL)return;\\n        while (prev->next){\\n            if (prev->next->next == NULL){\\n                prev->next = NULL;\\n                return;\\n            }\\n            prev= prev->next;\\n        }\\n    }\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* curr= head;\\n        while (curr){\\n            if (curr->val==val){\\n                //head\\n                if (curr == head){\\n                    head= head->next;\\n                    curr= curr->next;\\n                }\\n                //last node\\n                else if (curr->next == NULL){\\n                    deleteAtEnd(head);\\n                    curr= NULL;\\n                }\\n                // other nodes\\n                else{\\n                    curr->val= curr->next->val;\\n                    curr->next= curr->next->next;\\n                }\\n\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Math"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteAtEnd(ListNode*& head){\\n        ListNode* prev= head;\\n        if (head==NULL || head->next==NULL)return;\\n        while (prev->next){\\n            if (prev->next->next == NULL){\\n                prev->next = NULL;\\n                return;\\n            }\\n            prev= prev->next;\\n        }\\n    }\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* curr= head;\\n        while (curr){\\n            if (curr->val==val){\\n                //head\\n                if (curr == head){\\n                    head= head->next;\\n                    curr= curr->next;\\n                }\\n                //last node\\n                else if (curr->next == NULL){\\n                    deleteAtEnd(head);\\n                    curr= NULL;\\n                }\\n                // other nodes\\n                else{\\n                    curr->val= curr->next->val;\\n                    curr->next= curr->next->next;\\n                }\\n\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907943,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode(-1, head);\\n        ListNode pre = dummy;\\n        while (pre.next != null) {\\n            if (pre.next.val != val)\\n                pre = pre.next;\\n            else\\n                pre.next = pre.next.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode(-1, head);\\n        ListNode pre = dummy;\\n        while (pre.next != null) {\\n            if (pre.next.val != val)\\n                pre = pre.next;\\n            else\\n                pre.next = pre.next.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857650,
                "title": "beats-97-javascript-clean-easy-to-understand-javascript-solution",
                "content": "**Very easy Javascript approach, Beats 90% **\\n\\n```\\nvar removeElements = function(head, val) {\\n    \\n    let tempHead = head,prev\\n    while (tempHead){\\n        if (tempHead.val ===val){\\n            // when head is present at 0th index\\n            if (!prev){\\n                head = head.next\\n                tempHead=tempHead.next\\n            }else{\\n                prev.next =tempHead.next\\n                tempHead=tempHead.next\\n                \\n            }\\n        }else{\\n            prev=tempHead\\n            tempHead= tempHead.next   \\n        }\\n    }\\n    \\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar removeElements = function(head, val) {\\n    \\n    let tempHead = head,prev\\n    while (tempHead){\\n        if (tempHead.val ===val){\\n            // when head is present at 0th index\\n            if (!prev){\\n                head = head.next\\n                tempHead=tempHead.next\\n            }else{\\n                prev.next =tempHead.next\\n                tempHead=tempHead.next\\n                \\n            }\\n        }else{\\n            prev=tempHead\\n            tempHead= tempHead.next   \\n        }\\n    }\\n    \\n    return head\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2837684,
                "title": "java",
                "content": "upvote if you like it\\n```\\n\\n      public ListNode removeElements(ListNode head, int val) {\\n          ListNode temp = new ListNode(-1);\\n          temp.next = head;\\n\\n          ListNode cur = head;\\n          ListNode prev = temp;\\n\\n          while (cur != null) {\\n              if (cur.val == val) {\\n                  prev.next = cur.next;\\n              } else {\\n                  prev = cur;\\n              }\\n              cur = cur.next;\\n          }\\n          return temp.next;\\n      }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n      public ListNode removeElements(ListNode head, int val) {\\n          ListNode temp = new ListNode(-1);\\n          temp.next = head;\\n\\n          ListNode cur = head;\\n          ListNode prev = temp;\\n\\n          while (cur != null) {\\n              if (cur.val == val) {\\n                  prev.next = cur.next;\\n              } else {\\n                  prev = cur;\\n              }\\n              cur = cur.next;\\n          }\\n          return temp.next;\\n      }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828689,
                "title": "python-94-11-faster-iterative-approach-o-n-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head==None: #If head is empty\\n            return head\\n        while head and head.val==val: #If we want to delete the starting nodes\\n            head=head.next\\n        temp=head\\n        while temp:\\n            while temp.next and temp.next.val==val:\\n                temp.next=temp.next.next\\n            temp=temp.next\\n        return head\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head==None: #If head is empty\\n            return head\\n        while head and head.val==val: #If we want to delete the starting nodes\\n            head=head.next\\n        temp=head\\n        while temp:\\n            while temp.next and temp.next.val==val:\\n                temp.next=temp.next.next\\n            temp=temp.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801867,
                "title": "js-beginer-friendly",
                "content": "\\n# Intuition\\nSorry about a lot of code, I\\'m also learning Linked list. This is working and with very direct explaination.\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function (head, val) {\\n// Relocate the head, if the head\\'s value equals to val\\n  while (head) {\\n    if (head.val === val) {\\n      head = head.next;\\n    } else {\\n      break;\\n    }\\n  }\\n// cur represents head for now\\n  let cur = head;\\n// find the nodes should be removed, and jump, jump... \\n// Notice that cur only jumps to the next when found different value.\\n  while (cur && cur.next) {\\n    let nextNode = cur.next;\\n    if (nextNode.val === val) {\\n      cur.next = nextNode.next;\\n      nextNode = nextNode.next;\\n      continue;\\n    }\\n    cur = cur.next;\\n    nextNode = nextNode.next;\\n  }\\n  return head;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function (head, val) {\\n// Relocate the head, if the head\\'s value equals to val\\n  while (head) {\\n    if (head.val === val) {\\n      head = head.next;\\n    } else {\\n      break;\\n    }\\n  }\\n// cur represents head for now\\n  let cur = head;\\n// find the nodes should be removed, and jump, jump... \\n// Notice that cur only jumps to the next when found different value.\\n  while (cur && cur.next) {\\n    let nextNode = cur.next;\\n    if (nextNode.val === val) {\\n      cur.next = nextNode.next;\\n      nextNode = nextNode.next;\\n      continue;\\n    }\\n    cur = cur.next;\\n    nextNode = nextNode.next;\\n  }\\n  return head;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2372618,
                "title": "c-recursive-iterative-easy-logic",
                "content": "Iterative Solution\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {  \\n        ListNode *fast=head, *slow=NULL;       \\n        while(fast!=NULL){\\n            if(fast->val==val){  \\n                if(head==fast)\\n                    head=fast->next;\\n                else\\n                    slow->next=fast->next;\\n            }\\n            else\\n                slow=fast;\\n            fast=fast->next;\\n        }     \\n        return head;        \\n    }\\n};\\n```\\nRecursive Solution\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL)\\n            return head;              \\n        head->next= removeElements(head->next,val);       \\n        if( head->val==val)\\n            return head->next; \\n        return head;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {  \\n        ListNode *fast=head, *slow=NULL;       \\n        while(fast!=NULL){\\n            if(fast->val==val){  \\n                if(head==fast)\\n                    head=fast->next;\\n                else\\n                    slow->next=fast->next;\\n            }\\n            else\\n                slow=fast;\\n            fast=fast->next;\\n        }     \\n        return head;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL)\\n            return head;              \\n        head->next= removeElements(head->next,val);       \\n        if( head->val==val)\\n            return head->next; \\n        return head;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327783,
                "title": "most-intuitive-rust-for-me",
                "content": "This style makes the most sense to me personally. We have to move head into a mutable variable first since we\\'re gonna be modifying. Then we define a mutable refernence to the head which will be our walker.\\n\\nIn our loop, we match the walker. If None, the linked list is over so we break. If Some(node) and the value is val, then we modify what the walker is pointing to (by dereferencing) to be whatever is next. We can\\'t do ``` *walker = node.next``` because node.next is behind a mutable reference (node is a &mut) and we can\\'t move out of something we don\\'t own. So we take it. Then if Some(node) and the value is not val, we modify the walker pointer to point to the next node.\\n\\nAt the end we return our head\\n\\n```\\nimpl Solution {\\n    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut walker = &mut head;\\n        loop {\\n            match walker {\\n                None => break,\\n                Some(node) if node.val == val => {\\n                    *walker = node.next.take();\\n                },\\n                Some(node) => {\\n                    walker = &mut node.next;\\n                },\\n            }\\n        }\\n        head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "``` *walker = node.next```\n```\\nimpl Solution {\\n    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut walker = &mut head;\\n        loop {\\n            match walker {\\n                None => break,\\n                Some(node) if node.val == val => {\\n                    *walker = node.next.take();\\n                },\\n                Some(node) => {\\n                    walker = &mut node.next;\\n                },\\n            }\\n        }\\n        head\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2158854,
                "title": "python3-solution-using-two-pointers-approach",
                "content": "```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1, None)\\n        dummy.next = head\\n        \\n        prev = dummy\\n        curr = dummy.next\\n        \\n        while curr:\\n            if(curr.val == val):\\n                prev.next = curr.next  \\n            else:\\n                prev = curr\\n            curr = curr.next if curr else None\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1, None)\\n        dummy.next = head\\n        \\n        prev = dummy\\n        curr = dummy.next\\n        \\n        while curr:\\n            if(curr.val == val):\\n                prev.next = curr.next  \\n            else:\\n                prev = curr\\n            curr = curr.next if curr else None\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670015,
                "title": "recursive-javascript-solution",
                "content": "```\\nvar removeElements = function(head, val) {\\n    if (!head) {\\n        return head;\\n    }\\n    if (head.val === val) {\\n        return removeElements(head.next, val);\\n    }\\n    head.next = removeElements(head.next, val)\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar removeElements = function(head, val) {\\n    if (!head) {\\n        return head;\\n    }\\n    if (head.val === val) {\\n        return removeElements(head.next, val);\\n    }\\n    head.next = removeElements(head.next, val)\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1573479,
                "title": "c-solution-97-faster-very-easy-to-understand",
                "content": "```\\nListNode* removeElements(ListNode* head, int val) {\\n        ListNode*q=head;\\n       if(head==NULL)\\n       {\\n           return NULL;\\n       }\\n        \\n        while(q!=NULL&&q->val==val)\\n        {\\n            ListNode*p=q;\\n                q=q->next;\\n                delete p;\\n        }\\n        head=q;\\n        while(q&&q->next!=NULL)\\n        {\\n            \\n             if(q->next->val==val)\\n            {\\n              ListNode*temp=q->next;\\n                q->next=temp->next;\\n                delete temp;\\n            }\\n            else\\n            {\\n                q=q->next;\\n            }\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nListNode* removeElements(ListNode* head, int val) {\\n        ListNode*q=head;\\n       if(head==NULL)\\n       {\\n           return NULL;\\n       }\\n        \\n        while(q!=NULL&&q->val==val)\\n        {\\n            ListNode*p=q;\\n                q=q->next;\\n                delete p;\\n        }\\n        head=q;\\n        while(q&&q->next!=NULL)\\n        {\\n            \\n             if(q->next->val==val)\\n            {\\n              ListNode*temp=q->next;\\n                q->next=temp->next;\\n                delete temp;\\n            }\\n            else\\n            {\\n                q=q->next;\\n            }\\n        }\\n        return head;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1513727,
                "title": "easiest-approach-c",
                "content": "```\\n\\t\\tif(head==NULL){\\n            return NULL;\\n        }\\n        \\n        ListNode* temp=head;\\n        \\n        while(temp!=NULL && temp->next!=NULL){\\n            if(temp->next->val==val){\\n                temp->next=temp->next->next;\\n            }else{\\n                temp=temp->next;\\n            }\\n        }\\n        \\n        if(head->val==val){\\n            head=head->next;\\n        }\\n        \\n\\t\\treturn head;\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\t\\tif(head==NULL){\\n            return NULL;\\n        }\\n        \\n        ListNode* temp=head;\\n        \\n        while(temp!=NULL && temp->next!=NULL){\\n            if(temp->next->val==val){\\n                temp->next=temp->next->next;\\n            }else{\\n                temp=temp->next;\\n            }\\n        }\\n        \\n        if(head->val==val){\\n            head=head->next;\\n        }\\n        \\n\\t\\treturn head;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1477630,
                "title": "java-easy-solution-1ms-time-o-n-spaceo-1-1ms",
                "content": "class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n\\t\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode a=head;\\n        while(a!=null){\\n            if(a.next!=null && a.next.val==val){\\n                a.next=a.next.next;\\n                \\n            }\\n            else{\\n            a=a.next;\\n            }\\n            \\n        }\\n        if( head.next==null && head.val==val ){\\n            head=null;\\n        }\\n        else if(head.next!=null && head.val==val ){\\n            head=head.next;\\n        }\\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n\\t\\n        if(head==null){\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1169092,
                "title": "javascript",
                "content": "```\\nvar removeElements = function(head, val) {\\n  if(!head) return head\\n  while(head && head.val == val) head = head.next\\n  let node = head\\n  let prv = null\\n  while(node){\\n    const next = node.next\\n    if(node.val === val){\\n      prv.next = next\\n    }else{\\n      prv = node \\n    }    \\n    node = next\\n  }\\n  return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeElements = function(head, val) {\\n  if(!head) return head\\n  while(head && head.val == val) head = head.next\\n  let node = head\\n  let prv = null\\n  while(node){\\n    const next = node.next\\n    if(node.val === val){\\n      prv.next = next\\n    }else{\\n      prv = node \\n    }    \\n    node = next\\n  }\\n  return head\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1161918,
                "title": "python3-iterative-solution-using-dummy-head-with-explanation",
                "content": "## Implementation\\n```python\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        # dummy_head.next is the first node of list\\n        dummy_head = ListNode(next=head)\\n        \\n        prev, cur = dummy_head, head\\n        while cur:\\n            if cur.val == val:\\n                prev.next = cur.next\\n                cur = cur.next\\n            else:\\n                prev, cur = cur, cur.next\\n            \\n        return dummy_head.next\\n```\\n\\nI use a `dummy_head`, whose next element is the first node of the list. The advantage of applying a `dummy_head` is that we can treat `head` as a normal node of the list, so that we can handle the edge cases easily.\\n\\n\\n## Example\\nLet\\'s say we want to remove all the nodes whose `val` is `6`. \\n\\n- At the beginning\\n![image](https://assets.leetcode.com/users/images/18f838c7-5b91-4982-b862-55ddf92b1514_1618604170.6595209.png)\\n\\n- If `cur` should not be removed, we just move `prev` and `cur` one step forward\\n![image](https://assets.leetcode.com/users/images/813c0bef-0b3c-43bc-b8cc-d18883dbeaf3_1618604394.2694678.png)\\n\\n- If `cur` should be removed\\n\\t- We let `cur.next` be the next node of `prev`\\n\\t- and move `cur` one step forward\\n\\n\\t(I.e., We \"jump over\" the removed node) \\n![image](https://assets.leetcode.com/users/images/c5389a3d-a5c2-45cd-bf7f-d37e2a5b0280_1618604427.412363.png)\\n\\n## Complexity\\n- Time: O(n)\\n- Space: O(1)\\n\\nIf you think this is helpful, please give it a vote.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        # dummy_head.next is the first node of list\\n        dummy_head = ListNode(next=head)\\n        \\n        prev, cur = dummy_head, head\\n        while cur:\\n            if cur.val == val:\\n                prev.next = cur.next\\n                cur = cur.next\\n            else:\\n                prev, cur = cur, cur.next\\n            \\n        return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113125,
                "title": "simple-python-solution",
                "content": "```\\ndef removeElements(self, head: ListNode, val: int) -> ListNode:\\n        \\n        dummy = ListNode() \\n        dummy.next = head \\n        cur = dummy \\n        \\n        while cur and cur.next:\\n            if cur.next.val == val:\\n                cur.next = cur.next.next \\n            else:\\n                cur = cur.next \\n                \\n        return dummy.next \\n```",
                "solutionTags": [],
                "code": "```\\ndef removeElements(self, head: ListNode, val: int) -> ListNode:\\n        \\n        dummy = ListNode() \\n        dummy.next = head \\n        cur = dummy \\n        \\n        while cur and cur.next:\\n            if cur.next.val == val:\\n                cur.next = cur.next.next \\n            else:\\n                cur = cur.next \\n                \\n        return dummy.next \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1008395,
                "title": "rust-onepass",
                "content": "```rust\\nimpl Solution {\\n    pub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut dummy_head = ListNode { val: 0, next: None };\\n        let mut cur = &mut dummy_head;\\n        while let Some(mut node) = head {\\n            head = std::mem::replace(&mut node.next, None);\\n            if node.val != val {\\n                cur.next = Some(node);\\n                cur = cur.next.as_mut().unwrap();\\n            }\\n        }\\n        dummy_head.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut dummy_head = ListNode { val: 0, next: None };\\n        let mut cur = &mut dummy_head;\\n        while let Some(mut node) = head {\\n            head = std::mem::replace(&mut node.next, None);\\n            if node.val != val {\\n                cur.next = Some(node);\\n                cur = cur.next.as_mut().unwrap();\\n            }\\n        }\\n        dummy_head.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 986302,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null || (head.next == null && head.val == val)) {\\n          return null;\\n        }\\n\\n        for (;head != null && head.val == val; head = head.next);\\n\\n        var curr = head;\\n\\n        while (curr != null && curr.next != null) {\\n          if (curr.next.val == val) {\\n            curr.next = curr.next.next;\\n          } else {\\n            curr = curr.next;\\n          }\\n        }\\n\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null || (head.next == null && head.val == val)) {\\n          return null;\\n        }\\n\\n        for (;head != null && head.val == val; head = head.next);\\n\\n        var curr = head;\\n\\n        while (curr != null && curr.next != null) {\\n          if (curr.next.val == val) {\\n            curr.next = curr.next.next;\\n          } else {\\n            curr = curr.next;\\n          }\\n        }\\n\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745764,
                "title": "c-faster-than-97-21",
                "content": "Runtime: 96 ms\\nMemory Usage: 27.9 MB\\n\\n```\\n    public ListNode RemoveElements(ListNode head, int val) \\n    {\\n        ListNode tempHead = new ListNode(0, head);\\n        ListNode prev = tempHead;\\n        ListNode crnt = prev.next;\\n        \\n        while(crnt != null)\\n        {\\n            if (crnt.val == val)\\n            {\\n                prev.next = crnt.next; \\n            }\\n            else\\n            {\\n                prev = crnt;\\n            }\\n            \\n            crnt = prev.next;\\n        }\\n        \\n        return tempHead.next;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 96 ms\\nMemory Usage: 27.9 MB\\n\\n```\\n    public ListNode RemoveElements(ListNode head, int val) \\n    {\\n        ListNode tempHead = new ListNode(0, head);\\n        ListNode prev = tempHead;\\n        ListNode crnt = prev.next;\\n        \\n        while(crnt != null)\\n        {\\n            if (crnt.val == val)\\n            {\\n                prev.next = crnt.next; \\n            }\\n            else\\n            {\\n                prev = crnt;\\n            }\\n            \\n            crnt = prev.next;\\n        }\\n        \\n        return tempHead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 699620,
                "title": "python-99-76-faster",
                "content": "```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        if not head:\\n            return head\\n        while head and head.val == val:\\n            head = head.next\\n        temp = head\\n        while temp and temp.next:\\n            if temp.next.val == val:\\n                temp.next = temp.next.next\\n            else:\\n                temp =  temp.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        if not head:\\n            return head\\n        while head and head.val == val:\\n            head = head.next\\n        temp = head\\n        while temp and temp.next:\\n            if temp.next.val == val:\\n                temp.next = temp.next.next\\n            else:\\n                temp =  temp.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594275,
                "title": "0ms-100-faster-java-simple-iterative-solution",
                "content": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head == null)\\n            return null;\\n        ListNode newhead = new ListNode(-1);\\n        ListNode temp = newhead;\\n        while(head != null){\\n            if(head.val != val){\\n                temp.next = head;\\n                temp = temp.next;\\n            }\\n            head = head.next;\\n        }\\n        temp.next = null;\\n        return newhead.next;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head == null)\\n            return null;\\n        ListNode newhead = new ListNode(-1);\\n        ListNode temp = newhead;\\n        while(head != null){\\n            if(head.val != val){\\n                temp.next = head;\\n                temp = temp.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 318934,
                "title": "java-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        head.next = removeElements(head.next, val);\\n        return head.val == val ? head.next : head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        head.next = removeElements(head.next, val);\\n        return head.val == val ? head.next : head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318794,
                "title": "cpp-uses-dummy-head",
                "content": "```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        for (ListNode* node = dummy; node != nullptr; node = node->next) {\\n            while (node->next != nullptr && node->next->val == val) {\\n                node->next = node->next->next;\\n            }\\n        }\\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        for (ListNode* node = dummy; node != nullptr; node = node->next) {\\n            while (node->next != nullptr && node->next->val == val) {\\n                node->next = node->next->next;\\n            }\\n        }\\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318542,
                "title": "cpp-iterative-recursive-solutions",
                "content": "**Recursive:**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(!head) return nullptr;\\n        head->next = removeElements(head->next, val);\\n        return head->val == val ? head->next : head;\\n    }\\n};\\n```\\nTime: O(N)\\nSpace: O(N) (considering recursion stack)\\n\\n\\n\\n**Iterative:**\\n*a) with previous node:*\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* prev = nullptr, *cur = head;\\n        while(cur) {\\n            if(cur->val == val) {\\n                if(cur == head)\\n                    head = head->next;\\n                else\\n                    prev->next = cur->next;\\n            }else {\\n                prev = cur;\\n            }\\n            cur = cur->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\nTime: O(N)\\nSpace: O(1)\\n\\n*b) use dummy head*\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode(0), *cur = dummy;\\n        dummy->next = head;\\n        while(cur) {\\n            if(cur->next && cur->next->val == val) {\\n                cur->next = cur->next->next;\\n            }else{\\n                cur = cur->next;\\n            }\\n        }\\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```\\nTime: O(N)\\nSpace: O(1)\\n\\n\\n*c) pointer-to-pointer:*\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode** pp = &head;\\n        while(*pp) {\\n            if((*pp)->val == val) {\\n                *pp = (*pp)->next;\\n            }else {\\n                pp = &(*pp)->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\nTime: O(N)\\nSpace: O(1)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(!head) return nullptr;\\n        head->next = removeElements(head->next, val);\\n        return head->val == val ? head->next : head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* prev = nullptr, *cur = head;\\n        while(cur) {\\n            if(cur->val == val) {\\n                if(cur == head)\\n                    head = head->next;\\n                else\\n                    prev->next = cur->next;\\n            }else {\\n                prev = cur;\\n            }\\n            cur = cur->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode(0), *cur = dummy;\\n        dummy->next = head;\\n        while(cur) {\\n            if(cur->next && cur->next->val == val) {\\n                cur->next = cur->next->next;\\n            }else{\\n                cur = cur->next;\\n            }\\n        }\\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode** pp = &head;\\n        while(*pp) {\\n            if((*pp)->val == val) {\\n                *pp = (*pp)->next;\\n            }else {\\n                pp = &(*pp)->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180101,
                "title": "python-4-line-recursive-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        if(head == None): return head;\\n        if(head.val == val): return self.removeElements(head.next, val);\\n        head.next = self.removeElements(head.next, val)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        if(head == None): return head;\\n        if(head.val == val): return self.removeElements(head.next, val);\\n        head.next = self.removeElements(head.next, val)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142417,
                "title": "iterative-go-solution",
                "content": "```\\nfunc removeElements(head *ListNode, val int) *ListNode {\\n    dummy := &ListNode{-1, head}\\n    p := dummy\\n    for p.Next != nil {\\n        if p.Next.Val == val {\\n            p.Next = p.Next.Next\\n            continue\\n        }\\n        p = p.Next\\n    }\\n    return dummy.Next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc removeElements(head *ListNode, val int) *ListNode {\\n    dummy := &ListNode{-1, head}\\n    p := dummy\\n    for p.Next != nil {\\n        if p.Next.Val == val {\\n            p.Next = p.Next.Next\\n            continue\\n        }\\n        p = p.Next\\n    }\\n    return dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 57419,
                "title": "c-28ms-beats-100-00-of-cppsubmissions",
                "content": "    class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n            if(head == NULL)\\n                return NULL;\\n            while(head && head->val == val)\\n                head = head->next;\\n            if(head == NULL) return head;\\n            else {\\n                ListNode *ptr = head;\\n                while(ptr->next) {\\n                    if(ptr->next->val == val)\\n                        ptr->next = ptr->next->next;\\n                    else\\n                        ptr = ptr->next;\\n                }\\n            }\\n            return head;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n            if(head == NULL)\\n                return NULL;\\n            while(head && head->val == val)\\n                head = head->next;\\n            if(head == NULL) return head;\\n            else {\\n                ListNode *ptr = head;\\n                while(ptr->next) {\\n                    if(ptr->next->val == val)\\n                        ptr->next = ptr->next->next;\\n                    else\\n                        ptr = ptr->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 57421,
                "title": "java-2-pointers-solution-2ms",
                "content": "        public ListNode removeElements(ListNode head, int val) {\\n    \\t\\tListNode dummy = new ListNode(0);\\n    \\t\\tdummy.next = head;\\n    \\t\\tListNode first = head;\\n    \\t\\tListNode second = dummy;\\n    \\t\\twhile(first != null) {\\n    \\t\\t\\tif (first.val == val) {\\n    \\t\\t\\t\\tfirst = first.next;\\n    \\t\\t\\t\\tsecond.next = first;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tfirst = first.next;\\n    \\t\\t\\t\\tsecond = second.next;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn dummy.next;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "        public ListNode removeElements(ListNode head, int val) {\\n    \\t\\tListNode dummy = new ListNode(0);\\n    \\t\\tdummy.next = head;\\n    \\t\\tListNode first = head;\\n    \\t\\tListNode second = dummy;\\n    \\t\\twhile(first != null) {\\n    \\t\\t\\tif (first.val == val) {\\n    \\t\\t\\t\\tfirst = first.next;\\n    \\t\\t\\t\\tsecond.next = first;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tfirst = first.next;\\n    \\t\\t\\t\\tsecond = second.next;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn dummy.next;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 57527,
                "title": "easy-c-solution",
                "content": "struct ListNode* removeElements(struct ListNode* head, int val) {\\n    \\n    struct ListNode* dummy=(struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->val=INT_MAX;\\n    dummy->next=head;\\n    struct ListNode* prev=dummy; \\n    struct ListNode* Next=NULL;    \\n    struct ListNode* curr=dummy->next;    \\n    \\n    while(curr){\\n        Next=curr->next;\\n        \\n        if(curr->val==val){\\n            prev->next=curr->next;\\n            free(curr);\\n        }\\n        else\\n            prev=curr;\\n\\n        curr=Next;  \\n    }\\n    \\n    return dummy->next;\\n}",
                "solutionTags": [],
                "code": "struct ListNode* removeElements(struct ListNode* head, int val) {\\n    \\n    struct ListNode* dummy=(struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->val=INT_MAX;\\n    dummy->next=head;\\n    struct ListNode* prev=dummy; \\n    struct ListNode* Next=NULL;    \\n    struct ListNode* curr=dummy->next;    \\n    \\n    while(curr){\\n        Next=curr->next;\\n        \\n        if(curr->val==val){\\n            prev->next=curr->next;\\n            free(curr);\\n        }\\n        else\\n            prev=curr;\\n\\n        curr=Next;  \\n    }\\n    \\n    return dummy->next;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3885563,
                "title": "c-solutation",
                "content": "\\n\\n## \\u4EE3\\u7801\\u968F\\u60F3\\u5F55 \\u7B97\\u6CD5\\u516C\\u5F00\\u8BFE\\nhttps://youtu.be/SsU9ZmFp310\\n```c\\n\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode* temp;\\n\\n    while(head && head->val == val) {\\n        temp = head;\\n        head = head->next;\\n        free(temp);\\n    }\\n\\n    struct ListNode *cur = head;\\n\\n    while(cur && (temp = cur->next)) {\\n        if(temp->val == val) {\\n            cur->next = temp->next;\\n            free(temp);\\n        }\\n        else\\n            cur = cur->next;\\n    }\\n\\n\\n    return head;\\n}\\n\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\n\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode* temp;\\n\\n    while(head && head->val == val) {\\n        temp = head;\\n        head = head->next;\\n        free(temp);\\n    }\\n\\n    struct ListNode *cur = head;\\n\\n    while(cur && (temp = cur->next)) {\\n        if(temp->val == val) {\\n            cur->next = temp->next;\\n            free(temp);\\n        }\\n        else\\n            cur = cur->next;\\n    }\\n\\n\\n    return head;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3839646,
                "title": "simplest-pointer-next-pointer-next-next-method-o-n-beats-97-with-time-64ms-space-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf value matches make the current pointer connects to next.next otherwise it just moves by to next\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHandle edge cases in beginning.\\n\\n![image.png](https://assets.leetcode.com/users/images/c30be6b8-a2cb-47e9-88dc-ba1ad7f67709_1690739091.6531463.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * } 10 :44. - 11: 08\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function(head, val) {\\n    if(!head) return null;\\n    if(head.next === null && head.val === val) return null;\\n\\n    let ref = head;\\n    while(head.next !== null){\\n        if(ref && ref.val === val){\\n            ref = ref.next;\\n        }\\n        else if(head.next.val === val){\\n            head.next = head.next.next;\\n        }\\n        else{\\n            head = head.next;\\n        }\\n    }\\n    return ref;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * } 10 :44. - 11: 08\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function(head, val) {\\n    if(!head) return null;\\n    if(head.next === null && head.val === val) return null;\\n\\n    let ref = head;\\n    while(head.next !== null){\\n        if(ref && ref.val === val){\\n            ref = ref.next;\\n        }\\n        else if(head.next.val === val){\\n            head.next = head.next.next;\\n        }\\n        else{\\n            head = head.next;\\n        }\\n    }\\n    return ref;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3758538,
                "title": "easy-beginner-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode(next=head)\\n        prev ,curr = dummy, head\\n\\n        while curr:\\n            if curr.val == val:\\n                curr = curr.next\\n                prev.next = curr\\n            else:\\n                curr =curr.next\\n                prev = prev.next\\n            \\n\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode(next=head)\\n        prev ,curr = dummy, head\\n\\n        while curr:\\n            if curr.val == val:\\n                curr = curr.next\\n                prev.next = curr\\n            else:\\n                curr =curr.next\\n                prev = prev.next\\n            \\n\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460235,
                "title": "simple-solution-using-one-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        while(head != nullptr && head->val == val ){// 1->1->1->null , val = 1\\n            head = head->next;\\n        }\\n        if(head == nullptr){\\n            return head;\\n        }\\n        \\n        ListNode* temp = head;\\n        while(temp->next != nullptr && temp != nullptr){\\n            if(temp->next->val == val){\\n                temp->next = temp->next->next;\\n                // After doing the above step, I am not updating \"curr\" because of these type of test cases:\\n\\t\\t\\t\\t// 1->2->3->6->6->6->5->null  val = 6\\n            }else{\\n                temp = temp->next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        while(head != nullptr && head->val == val ){// 1->1->1->null , val = 1\\n            head = head->next;\\n        }\\n        if(head == nullptr){\\n            return head;\\n        }\\n        \\n        ListNode* temp = head;\\n        while(temp->next != nullptr && temp != nullptr){\\n            if(temp->next->val == val){\\n                temp->next = temp->next->next;\\n                // After doing the above step, I am not updating \"curr\" because of these type of test cases:\\n\\t\\t\\t\\t// 1->2->3->6->6->6->5->null  val = 6\\n            }else{\\n                temp = temp->next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454910,
                "title": "easy-java-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode temp = head;\\n        while(temp != null) {\\n            if(head.val==val && temp==head) {\\n                head= head.next;\\n                temp = head;\\n                continue;\\n            }\\n            if(temp.next==null) {\\n                break;\\n            }\\n            if(temp.next.val == val) {\\n                temp.next = temp.next.next;\\n                continue;\\n            }\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode temp = head;\\n        while(temp != null) {\\n            if(head.val==val && temp==head) {\\n                head= head.next;\\n                temp = head;\\n                continue;\\n            }\\n            if(temp.next==null) {\\n                break;\\n            }\\n            if(temp.next.val == val) {\\n                temp.next = temp.next.next;\\n                continue;\\n            }\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454734,
                "title": "100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode temp = new ListNode(0);\\n\\n        temp.next = head;\\n        ListNode current = temp;\\n        while(current.next != null){\\n            if(current.next.val == val){\\n                current.next = current.next.next;\\n\\n        }else{\\n           current = current.next; \\n        }\\n        }\\n\\n        return temp.next;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode temp = new ListNode(0);\\n\\n        temp.next = head;\\n        ListNode current = temp;\\n        while(current.next != null){\\n            if(current.next.val == val){\\n                current.next = current.next.next;\\n\\n        }else{\\n           current = current.next; \\n        }\\n        }\\n\\n        return temp.next;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333585,
                "title": "easiest-python-solution-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy=ListNode(next=head)\\n        prev,curr=dummy,head\\n        while curr:\\n            if curr.val==val:\\n                nxt=curr.next\\n                prev.next=nxt\\n                curr=nxt\\n            else:\\n                prev=curr\\n                curr=curr.next\\n        return dummy.next\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy=ListNode(next=head)\\n        prev,curr=dummy,head\\n        while curr:\\n            if curr.val==val:\\n                nxt=curr.next\\n                prev.next=nxt\\n                curr=nxt\\n            else:\\n                prev=curr\\n                curr=curr.next\\n        return dummy.next\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234945,
                "title": "c",
                "content": "# Complexity\\n- Time complexity:```O(n)```\\n- Space complexity:```O(1)```\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        if(head == null) return head;\\n\\n        //if the first element is to be removed or all elements are same as val;\\n        while(head != null && head.val == val) head = head.next;\\n\\n        ListNode current = head;\\n        \\n        while(head != null && head.next != null) {\\n            if(head.next.val == val) {\\n                head.next = head.next.next;\\n            }\\n            else\\n                head = head.next;\\n        }\\n        return current;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        if(head == null) return head;\\n\\n        //if the first element is to be removed or all elements are same as val;\\n        while(head != null && head.val == val) head = head.next;\\n\\n        ListNode current = head;\\n        \\n        while(head != null && head.next != null) {\\n            if(head.next.val == val) {\\n                head.next = head.next.next;\\n            }\\n            else\\n                head = head.next;\\n        }\\n        return current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204124,
                "title": "beats-92-java-code",
                "content": "# Java Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n * int val;\\n * ListNode next;\\n * ListNode() {}\\n * ListNode(int val) { this.val = val; }\\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode ans = new ListNode();\\n        ListNode cur = ans;\\n        ListNode temp = head;\\n\\n        while (temp != null) {\\n            if (temp.val != val) {\\n                cur.next = new ListNode(temp.val);\\n                cur = cur.next;\\n            }\\n\\n            temp = temp.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n * int val;\\n * ListNode next;\\n * ListNode() {}\\n * ListNode(int val) { this.val = val; }\\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode ans = new ListNode();\\n        ListNode cur = ans;\\n        ListNode temp = head;\\n\\n        while (temp != null) {\\n            if (temp.val != val) {\\n                cur.next = new ListNode(temp.val);\\n                cur = cur.next;\\n            }\\n\\n            temp = temp.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106158,
                "title": "runtime-69-ms-beats-81-72-remove-linked-list-elements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        while head!=None and head.val==val:\\n            head=head.next\\n        temp=head\\n        while temp:\\n            while temp.next and temp.next.val==val:\\n                temp.next=temp.next.next\\n            temp=temp.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        while head!=None and head.val==val:\\n            head=head.next\\n        temp=head\\n        while temp:\\n            while temp.next and temp.next.val==val:\\n                temp.next=temp.next.next\\n            temp=temp.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040555,
                "title": "c-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int v) {\\n        if(!head)return NULL;\\n        \\n        ListNode* h= NULL;\\n        ListNode* t= NULL;\\n        \\n        while(head){\\n            if(head->val !=  v){\\n                if(t){\\n                    t->next= head;\\n                    t= t->next;\\n                }\\n                else{\\n                    h= head;\\n                    t= head;\\n                }\\n            }\\n            head= head->next;\\n        }\\n        if(t)t->next= NULL;\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int v) {\\n        if(!head)return NULL;\\n        \\n        ListNode* h= NULL;\\n        ListNode* t= NULL;\\n        \\n        while(head){\\n            if(head->val !=  v){\\n                if(t){\\n                    t->next= head;\\n                    t= t->next;\\n                }\\n                else{\\n                    h= head;\\n                    t= head;\\n                }\\n            }\\n            head= head->next;\\n        }\\n        if(t)t->next= NULL;\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966451,
                "title": "easy-and-understandable-c",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val)\\n    {   \\n        while(head != NULL && head->val == val) // if all the elements are same\\n        {\\n            head = head->next;\\n        }\\n\\n        if(head == NULL)\\n            return NULL;\\n        \\n        ListNode* pointer;\\n        pointer = head;\\n\\n        while (pointer->next != NULL)  // removing ftom middle of the linked list\\n        {\\n            if(pointer->next->val == val)\\n            {\\n                pointer->next = pointer->next->next;\\n            }\\n            else\\n            {\\n                pointer = pointer->next;    \\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val)\\n    {   \\n        while(head != NULL && head->val == val) // if all the elements are same\\n        {\\n            head = head->next;\\n        }\\n\\n        if(head == NULL)\\n            return NULL;\\n        \\n        ListNode* pointer;\\n        pointer = head;\\n\\n        while (pointer->next != NULL)  // removing ftom middle of the linked list\\n        {\\n            if(pointer->next->val == val)\\n            {\\n                pointer->next = pointer->next->next;\\n            }\\n            else\\n            {\\n                pointer = pointer->next;    \\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900595,
                "title": "two-pointers-concept-python3",
                "content": "\\n\\n# Two Pointers Approach--->Time:O(N)\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy=ListNode(next=head)\\n        prev=dummy\\n        cur=head\\n        while cur:\\n            nxt=cur.next\\n            if cur.val==val:\\n                prev.next=nxt\\n            else:\\n                prev=cur\\n            cur=nxt\\n        return dummy.next\\n        \\n```\\n# 2. One Pointer Approach--->Time:O(N)\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        while head and head.val==val:\\n            head=head.next\\n        cur=head\\n        while cur and cur.next:\\n            if cur.next.val==val:\\n                cur.next=cur.next.next\\n            else:\\n                cur=cur.next\\n        return head\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy=ListNode(next=head)\\n        prev=dummy\\n        cur=head\\n        while cur:\\n            nxt=cur.next\\n            if cur.val==val:\\n                prev.next=nxt\\n            else:\\n                prev=cur\\n            cur=nxt\\n        return dummy.next\\n        \\n```\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        while head and head.val==val:\\n            head=head.next\\n        cur=head\\n        while cur and cur.next:\\n            if cur.next.val==val:\\n                cur.next=cur.next.next\\n            else:\\n                cur=cur.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827937,
                "title": "java-easy-to-understand-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        while(head!=null && head.val==val) head=head.next;\\n        if(head==null) return head;\\n        ListNode ptr=head;\\n        while(ptr.next!=null){\\n            if(ptr.next.val==val){\\n                ptr.next=ptr.next.next;\\n                continue;\\n            }\\n            ptr=ptr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        while(head!=null && head.val==val) head=head.next;\\n        if(head==null) return head;\\n        ListNode ptr=head;\\n        while(ptr.next!=null){\\n            if(ptr.next.val==val){\\n                ptr.next=ptr.next.next;\\n                continue;\\n            }\\n            ptr=ptr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719164,
                "title": "java-simple-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head != null) {\\n            // If the starting node is equal to value move the head to the next node until the value is different\\n            while(head != null && head.val == val){\\n                head = head.next;\\n            }\\n            // Take a pointer to the current head node and check if the value of the next node is equal to the value\\n            // If it is equal to the value change the next pointer of the current node to the node ahead\\n            ListNode currentNode = head;\\n            while (currentNode != null && currentNode.next != null) {\\n                if (currentNode.next.val == val) {\\n                    currentNode.next = currentNode.next.next;\\n                } else {\\n                    currentNode = currentNode.next;\\n                }   \\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head != null) {\\n            // If the starting node is equal to value move the head to the next node until the value is different\\n            while(head != null && head.val == val){\\n                head = head.next;\\n            }\\n            // Take a pointer to the current head node and check if the value of the next node is equal to the value\\n            // If it is equal to the value change the next pointer of the current node to the node ahead\\n            ListNode currentNode = head;\\n            while (currentNode != null && currentNode.next != null) {\\n                if (currentNode.next.val == val) {\\n                    currentNode.next = currentNode.next.next;\\n                } else {\\n                    currentNode = currentNode.next;\\n                }   \\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698504,
                "title": "203-remove-linked-list-elements-using-list-linked-list-for-beginners-and-using-linked-list-17ms",
                "content": "```\\n        #Using List +Linked List For Beginners\\n        t=head #assign temp variable because this is single linked list traversed only one time in one direction.\\n        a=[] #create a list for appending value of head\\n        while t:#loop run till temp is not None\\n            a.append(t.val) #t.val give the value from head  and append in a\\n            t=t.next # use for increment the pointer +1\\n        b=[] #now this list create for getting a list according to problem given\\n        for i in a: #iteration of list a\\n            if i!=val:#condition check according to question\\n                b.append(i)\\n        print(b)\\n        if not b:# this condition check if b is empty then return None\\n            return None\\n        i=0# initialize i for compare the len(b)\\n        n=ListNode()#now we create a new object which assign as head \\n        t=n\\n        while i<len(b):\\n            t.val=b[i]#assign value of list b in head n\\n            if i!=len(b)-1: \\n                t.next= ListNode()\\n                t=t.next\\n            i+=1\\n        return n\\n```\\n\\n```\\n        #Using LinkedList Only\\n\\t\\tif head==None:\\n            return head\\n        while head.val==val:\\n                head=head.next\\n                if head==None:\\n                    return head\\n        \\n        t=head\\n        while t and t.next:\\n            \\n            if t.next.val==val:\\n                t.next=t.next.next\\n            else:\\n                t=t.next\\n        return head \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        #Using List +Linked List For Beginners\\n        t=head #assign temp variable because this is single linked list traversed only one time in one direction.\\n        a=[] #create a list for appending value of head\\n        while t:#loop run till temp is not None\\n            a.append(t.val) #t.val give the value from head  and append in a\\n            t=t.next # use for increment the pointer +1\\n        b=[] #now this list create for getting a list according to problem given\\n        for i in a: #iteration of list a\\n            if i!=val:#condition check according to question\\n                b.append(i)\\n        print(b)\\n        if not b:# this condition check if b is empty then return None\\n            return None\\n        i=0# initialize i for compare the len(b)\\n        n=ListNode()#now we create a new object which assign as head \\n        t=n\\n        while i<len(b):\\n            t.val=b[i]#assign value of list b in head n\\n            if i!=len(b)-1: \\n                t.next= ListNode()\\n                t=t.next\\n            i+=1\\n        return n\\n```\n```\\n        #Using LinkedList Only\\n\\t\\tif head==None:\\n            return head\\n        while head.val==val:\\n                head=head.next\\n                if head==None:\\n                    return head\\n        \\n        t=head\\n        while t and t.next:\\n            \\n            if t.next.val==val:\\n                t.next=t.next.next\\n            else:\\n                t=t.next\\n        return head \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2698212,
                "title": "simple-java-solution-beats-100",
                "content": "# Intuition\\nSkip all the node except the val \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSkip all the node except the val  \\nCopy the rest\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode ans= new ListNode();\\n        ListNode cur= ans;\\n        ListNode temp = head;\\n\\n        while(temp != null){\\n            if(temp.val != val){\\n                cur.next = new ListNode(temp.val);\\n                cur = cur.next;\\n            }\\n\\n            temp= temp.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode ans= new ListNode();\\n        ListNode cur= ans;\\n        ListNode temp = head;\\n\\n        while(temp != null){\\n            if(temp.val != val){\\n                cur.next = new ListNode(temp.val);\\n                cur = cur.next;\\n            }\\n\\n            temp= temp.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693938,
                "title": "easy-c-fast",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* remove(ListNode* root, int val){\\n        if(root == NULL)return root;\\n        while(root != NULL and root->val == val){\\n            root = root->next;\\n        }\\n        return root;\\n    }\\n    \\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* root = remove(head, val);\\n        head = root;\\n        while(root != NULL){\\n            if(root->next != NULL and root->next->val == val){\\n                root->next = remove(root->next, val);\\n            }\\n            root = root->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* remove(ListNode* root, int val){\\n        if(root == NULL)return root;\\n        while(root != NULL and root->val == val){\\n            root = root->next;\\n        }\\n        return root;\\n    }\\n    \\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* root = remove(head, val);\\n        head = root;\\n        while(root != NULL){\\n            if(root->next != NULL and root->next->val == val){\\n                root->next = remove(root->next, val);\\n            }\\n            root = root->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686991,
                "title": "easy-java-1-ms-98-94-of-java-submissions",
                "content": "#### Runtime: 1 ms, faster than 98.94% of Java online submissions for Remove Linked List Elements.\\nMemory Usage: 43.1 MB, less than 90.68% of Java online submissions for Remove Linked List Elements.\\n\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode ans = new ListNode();\\n        ListNode curr = ans;\\n        \\n        ListNode ptr = head;\\n        \\n        while(ptr != null) {\\n            if(ptr.val != val) {\\n                curr.next = new ListNode(ptr.val);\\n                curr = curr.next;\\n            }\\n            ptr = ptr.next;\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode ans = new ListNode();\\n        ListNode curr = ans;\\n        \\n        ListNode ptr = head;\\n        \\n        while(ptr != null) {\\n            if(ptr.val != val) {\\n                curr.next = new ListNode(ptr.val);\\n                curr = curr.next;\\n            }\\n            ptr = ptr.next;\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636094,
                "title": "java-short-and-simple-code",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        \\n        if(head==null) return null;\\n        ListNode temp = head;\\n        \\n        while(temp.next!=null){\\n            \\n          if(temp.next.val==val) temp.next = temp.next.next;\\n          else temp = temp.next;\\n        \\n        }\\n        \\n        if(head.val==val) return head.next;\\n        return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        \\n        if(head==null) return null;\\n        ListNode temp = head;\\n        \\n        while(temp.next!=null){\\n            \\n          if(temp.next.val==val) temp.next = temp.next.next;\\n          else temp = temp.next;\\n        \\n        }\\n        \\n        if(head.val==val) return head.next;\\n        return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565052,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1808716,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1731450,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1812433,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1759557,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1786008,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1834914,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1721307,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1686102,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 2058802,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1565052,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1808716,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1731450,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1812433,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1759557,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1786008,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1834914,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1721307,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1686102,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 2058802,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 2038033,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 2017859,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1980602,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1948745,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1921645,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1895985,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1799060,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1777420,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1763555,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1761830,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            }
        ]
    },
    {
        "title": "Baseball Game",
        "question_content": "<p>You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.</p>\n\n<p>You are given a list of strings <code>operations</code>, where <code>operations[i]</code> is the <code>i<sup>th</sup></code> operation you must apply to the record and is one of the following:</p>\n\n<ul>\n\t<li>An integer <code>x</code>.\n\n\t<ul>\n\t\t<li>Record a new score of <code>x</code>.</li>\n\t</ul>\n\t</li>\n\t<li><code>&#39;+&#39;</code>.\n\t<ul>\n\t\t<li>Record a new score that is the sum of the previous two scores.</li>\n\t</ul>\n\t</li>\n\t<li><code>&#39;D&#39;</code>.\n\t<ul>\n\t\t<li>Record a new score that is the double of the previous score.</li>\n\t</ul>\n\t</li>\n\t<li><code>&#39;C&#39;</code>.\n\t<ul>\n\t\t<li>Invalidate the previous score, removing it from the record.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Return <em>the sum of all the scores on the record after applying all the operations</em>.</p>\n\n<p>The test cases are generated such that the answer and all intermediate calculations fit in a <strong>32-bit</strong> integer and that all operations are valid.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> ops = [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]\n<strong>Output:</strong> 30\n<strong>Explanation:</strong>\n&quot;5&quot; - Add 5 to the record, record is now [5].\n&quot;2&quot; - Add 2 to the record, record is now [5, 2].\n&quot;C&quot; - Invalidate and remove the previous score, record is now [5].\n&quot;D&quot; - Add 2 * 5 = 10 to the record, record is now [5, 10].\n&quot;+&quot; - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ops = [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]\n<strong>Output:</strong> 27\n<strong>Explanation:</strong>\n&quot;5&quot; - Add 5 to the record, record is now [5].\n&quot;-2&quot; - Add -2 to the record, record is now [5, -2].\n&quot;4&quot; - Add 4 to the record, record is now [5, -2, 4].\n&quot;C&quot; - Invalidate and remove the previous score, record is now [5, -2].\n&quot;D&quot; - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n&quot;9&quot; - Add 9 to the record, record is now [5, -2, -4, 9].\n&quot;+&quot; - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n&quot;+&quot; - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> ops = [&quot;1&quot;,&quot;C&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>\n&quot;1&quot; - Add 1 to the record, record is now [1].\n&quot;C&quot; - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= operations.length &lt;= 1000</code></li>\n\t<li><code>operations[i]</code> is <code>&quot;C&quot;</code>, <code>&quot;D&quot;</code>, <code>&quot;+&quot;</code>, or a string representing an integer in the range <code>[-3 * 10<sup>4</sup>, 3 * 10<sup>4</sup>]</code>.</li>\n\t<li>For operation <code>&quot;+&quot;</code>, there will always be at least two previous scores on the record.</li>\n\t<li>For operations <code>&quot;C&quot;</code> and <code>&quot;D&quot;</code>, there will always be at least one previous score on the record.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1265313,
                "title": "c-stack-based-solution-easy-to-understand",
                "content": "* **Stack based solution.**\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops)\\n    {\\n        int value1;\\n        int value2;\\n        int ans = 0;\\n        stack<int>stk;\\n        \\n        for(string i:ops)\\n        {\\n            if(i == \"C\")\\n            {\\n                stk.pop();\\n            }\\n            else if(i == \"D\")\\n            {\\n                stk.push(stk.top()*2);\\n            }\\n            else if(i == \"+\")\\n            {\\n                value1 = stk.top();\\n                stk.pop();\\n                value2 = stk.top();\\n                stk.push(value1);\\n                stk.push(value1 + value2);\\n            }\\n            else\\n            {\\n                stk.push(stoi(i)); //stoi() to convert string into integer \\n            }\\n        }\\n        while(stk.size() != 0)\\n        {\\n            ans += stk.top();\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops)\\n    {\\n        int value1;\\n        int value2;\\n        int ans = 0;\\n        stack<int>stk;\\n        \\n        for(string i:ops)\\n        {\\n            if(i == \"C\")\\n            {\\n                stk.pop();\\n            }\\n            else if(i == \"D\")\\n            {\\n                stk.push(stk.top()*2);\\n            }\\n            else if(i == \"+\")\\n            {\\n                value1 = stk.top();\\n                stk.pop();\\n                value2 = stk.top();\\n                stk.push(value1);\\n                stk.push(value1 + value2);\\n            }\\n            else\\n            {\\n                stk.push(stoi(i)); //stoi() to convert string into integer \\n            }\\n        }\\n        while(stk.size() != 0)\\n        {\\n            ans += stk.top();\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107871,
                "title": "straightforward-python",
                "content": "It not stated in the question but you can assume there is not invalid operations, such as `C` when the points history is empty, it still passed.\\n\\n```\\nclass Solution(object):\\n    def calPoints(self, ops):\\n        # Time: O(n)\\n        # Space: O(n)\\n        history = []\\n        for op in ops:\\n            if op == 'C':\\n                history.pop()\\n            elif op == 'D':\\n                history.append(history[-1] * 2)\\n            elif op == '+':\\n                history.append(history[-1] + history[-2])\\n            else:\\n                history.append(int(op))\\n        return sum(history)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def calPoints(self, ops):\\n        # Time: O(n)\\n        # Space: O(n)\\n        history = []\\n        for op in ops:\\n            if op == 'C':\\n                history.pop()\\n            elif op == 'D':\\n                history.append(history[-1] * 2)\\n            elif op == '+':\\n                history.append(history[-1] + history[-2])\\n            else:\\n                history.append(int(op))\\n        return sum(history)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107860,
                "title": "verbose-java-solution-linkedlist",
                "content": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int sum = 0;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        for (String op : ops) {\\n            if (op.equals(\"C\")) {\\n                sum -= list.removeLast();\\n            }\\n            else if (op.equals(\"D\")) {\\n                list.add(list.peekLast() * 2);\\n                sum += list.peekLast();\\n            }\\n            else if (op.equals(\"+\")) {\\n                list.add(list.peekLast() + list.get(list.size() - 2));\\n                sum += list.peekLast();\\n            }\\n            else {\\n                list.add(Integer.parseInt(op));\\n                sum += list.peekLast();\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int sum = 0;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        for (String op : ops) {\\n            if (op.equals(\"C\")) {\\n                sum -= list.removeLast();\\n            }\\n            else if (op.equals(\"D\")) {\\n                list.add(list.peekLast() * 2);\\n                sum += list.peekLast();\\n            }\\n            else if (op.equals(\"+\")) {\\n                list.add(list.peekLast() + list.get(list.size() - 2));\\n                sum += list.peekLast();\\n            }\\n            else {\\n                list.add(Integer.parseInt(op));\\n                sum += list.peekLast();\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930719,
                "title": "c-cycle-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nJust iterate over all characters, check all conditions and build record list. In the end we just return the sum.\\n\\nTime: **O(n)**\\nSpace: **O(n)**\\n\\nRuntime: 3 ms, faster than **86.92%** of C++ online submissions for Baseball Game.\\nMemory Usage: 8.2 MB, less than **99.88%** of C++ online submissions for Baseball Game.\\n\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> record;\\n        for (string ch : ops) {\\n            if (ch == \"C\")\\n                record.pop_back();\\n            else if (ch == \"D\")\\n                record.push_back(record.back() * 2);\\n            else if (ch == \"+\")\\n                record.push_back(record.back() + record[record.size() - 2]);\\n            else\\n                record.push_back(stoi(ch));\\n        }\\n        \\n        return accumulate(record.begin(), record.end(), 0);\\n    }\\n};\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> record;\\n        for (string ch : ops) {\\n            if (ch == \"C\")\\n                record.pop_back();\\n            else if (ch == \"D\")\\n                record.push_back(record.back() * 2);\\n            else if (ch == \"+\")\\n                record.push_back(record.back() + record[record.size() - 2]);\\n            else\\n                record.push_back(stoi(ch));\\n        }\\n        \\n        return accumulate(record.begin(), record.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1762047,
                "title": "c-easy-vector-only-stl-competitive-coding",
                "content": "# 682. Baseball Game\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. STL functions.\\n3. Explanation in comments with code.\\n4. If it helps Please Upvote. \\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n[LeetCode](https://github.com/knockcat/Leetcode)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**Functions Used**\\n\\n```\\n1. v.push_back() -> Push(add) an element at the last of a vector.\\n2. v.pop_back()  -> Pop(remove) an element from last of vector.\\n3. accumulate(v.begin(),v.end(),0) -> sum of all elements(type (int)) in vector.\\n// here v.begin() is an iterator or pointer to the first index.\\n// v.end() is an iterator or pointer to the last index \\n// 0 is passed beacuse at start the sum is 0.\\n4. stoi(x) -> convert x which is of string type to int.\\n```\\n**CODE**\\n```\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> v;\\n        int j = -1;\\n        for(int i = 0; i<ops.size(); ++i)\\n        {\\n            if(ops[i] == \"+\")\\n            {\\n                v.push_back(v[j] + v[j-1]); // if + we have to add the sum of last 2 elements of vector. (v.push_back perform the job for us.)\\n                ++j;\\n            }\\n            else if(ops[i] == \"D\")\\n            {\\n                v.push_back(2*v[j]); // if D we have to push twice of the last element (v.push_back() perform the job for us.)\\n                ++j;\\n            }\\n            else if(ops[i] == \"C\")  // if C we have to delete the last element (v.pop_back() perform the job for us)\\n            {\\n                v.pop_back(); \\n                --j;\\n            }\\n            else // we have to add the add the element ( v.push_back() perform the job for us)\\n            {\\n                v.push_back(stoi(ops[i]));  // stoi(converts an string to int) \\n                ++j;\\n            }\\n               \\n        }\\n\\t\\treturn accumulate(v.begin(),v.end(),0);   // sum of vector elements.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. Easy C++\\n2. STL functions.\\n3. Explanation in comments with code.\\n4. If it helps Please Upvote. \\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\n1. v.push_back() -> Push(add) an element at the last of a vector.\\n2. v.pop_back()  -> Pop(remove) an element from last of vector.\\n3. accumulate(v.begin(),v.end(),0) -> sum of all elements(type (int)) in vector.\\n// here v.begin() is an iterator or pointer to the first index.\\n// v.end() is an iterator or pointer to the last index \\n// 0 is passed beacuse at start the sum is 0.\\n4. stoi(x) -> convert x which is of string type to int.\\n```\n```\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> v;\\n        int j = -1;\\n        for(int i = 0; i<ops.size(); ++i)\\n        {\\n            if(ops[i] == \"+\")\\n            {\\n                v.push_back(v[j] + v[j-1]); // if + we have to add the sum of last 2 elements of vector. (v.push_back perform the job for us.)\\n                ++j;\\n            }\\n            else if(ops[i] == \"D\")\\n            {\\n                v.push_back(2*v[j]); // if D we have to push twice of the last element (v.push_back() perform the job for us.)\\n                ++j;\\n            }\\n            else if(ops[i] == \"C\")  // if C we have to delete the last element (v.pop_back() perform the job for us)\\n            {\\n                v.pop_back(); \\n                --j;\\n            }\\n            else // we have to add the add the element ( v.push_back() perform the job for us)\\n            {\\n                v.push_back(stoi(ops[i]));  // stoi(converts an string to int) \\n                ++j;\\n            }\\n               \\n        }\\n\\t\\treturn accumulate(v.begin(),v.end(),0);   // sum of vector elements.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107929,
                "title": "kt-js-py3-cpp-stack-accumulation",
                "content": "**Synopsis:**\\n\\nUse a stack `s` to store previous rounds\\' points.  Return the accumulated sum of what\\'s leftover on the stack `s` after processing all operations `ops`.\\n\\n---\\n\\n**Note:** there is a typo in this problem description.  The **Example 1 output should be 30**, ```(15 is NOT correct)```\\n\\nExample 1:\\nInput: [\"5\",\"2\",\"C\",\"D\",\"+\"]\\n~~Output: 15~~ \\u274C\\nOutput: 30 \\u2705\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun calPoints(ops: Array<String>): Int {\\n        var s = Stack<Int>()\\n        ops.forEach { op ->\\n            when (op) {\\n                \"+\"  -> s.push(s[s.lastIndex] + s[s.lastIndex - 1])\\n                \"D\"  -> s.push(2 * s.last())\\n                \"C\"  -> s.pop()\\n                else -> s.push(op.toInt())\\n            }\\n        }\\n        return s.sum()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet calPoints = (ops, s = []) => {\\n    for (op of ops) {\\n        let n = s.length;\\n        if (op == \\'+\\')\\n            s.push(s[n - 2] + s[n - 1]);\\n        else if (op == \\'D\\')\\n            s.push(2 * s[n - 1]);\\n        else if (op == \\'C\\')\\n            s.pop();\\n        else\\n            s.push(+op);\\n    }\\n    return _.sum(s)\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        s = []\\n        for op in ops:\\n            if op == \"+\":\\n                s.append(s[-2] + s[-1])\\n            elif op == \"D\":\\n                s.append(2 * s[-1])\\n            elif op == \"C\":\\n                s.pop()\\n            else:\\n                s.append(int(op))\\n        return sum(s)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using VI = vector<int>;\\n    int calPoints(VS& ops, VI s = {}) {\\n        for (auto& op: ops) {\\n            int n = s.size();\\n            if (op == \"+\")\\n                s.push_back(s[n - 2] + s[n - 1]);\\n            else if (op == \"D\")\\n                s.push_back(2 * s[n - 1]);\\n            else if (op == \"C\")\\n                s.pop_back();\\n            else\\n                s.push_back(stoi(op));\\n        }\\n        return accumulate(s.begin(), s.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```(15 is NOT correct)```\n```\\nclass Solution {\\n    fun calPoints(ops: Array<String>): Int {\\n        var s = Stack<Int>()\\n        ops.forEach { op ->\\n            when (op) {\\n                \"+\"  -> s.push(s[s.lastIndex] + s[s.lastIndex - 1])\\n                \"D\"  -> s.push(2 * s.last())\\n                \"C\"  -> s.pop()\\n                else -> s.push(op.toInt())\\n            }\\n        }\\n        return s.sum()\\n    }\\n}\\n```\n```\\nlet calPoints = (ops, s = []) => {\\n    for (op of ops) {\\n        let n = s.length;\\n        if (op == \\'+\\')\\n            s.push(s[n - 2] + s[n - 1]);\\n        else if (op == \\'D\\')\\n            s.push(2 * s[n - 1]);\\n        else if (op == \\'C\\')\\n            s.pop();\\n        else\\n            s.push(+op);\\n    }\\n    return _.sum(s)\\n};\\n```\n```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        s = []\\n        for op in ops:\\n            if op == \"+\":\\n                s.append(s[-2] + s[-1])\\n            elif op == \"D\":\\n                s.append(2 * s[-1])\\n            elif op == \"C\":\\n                s.pop()\\n            else:\\n                s.append(int(op))\\n        return sum(s)\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using VI = vector<int>;\\n    int calPoints(VS& ops, VI s = {}) {\\n        for (auto& op: ops) {\\n            int n = s.size();\\n            if (op == \"+\")\\n                s.push_back(s[n - 2] + s[n - 1]);\\n            else if (op == \"D\")\\n                s.push_back(2 * s[n - 1]);\\n            else if (op == \"C\")\\n                s.pop_back();\\n            else\\n                s.push_back(stoi(op));\\n        }\\n        return accumulate(s.begin(), s.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107859,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        int sum = 0, score = 0;\\n        vector<int> rounds;\\n        for (string op : ops) {\\n            if (op == \"C\") {\\n                sum -= rounds.back();\\n                rounds.pop_back();\\n                continue;\\n            }\\n            if (op == \"D\") {\\n                sum += score = rounds.back() * 2;\\n            }\\n            else if (op == \"+\") {\\n                sum += score = rounds[rounds.size() - 1] + rounds[rounds.size() - 2];\\n            }\\n            else {\\n                sum += score = stoi(op);\\n            }\\n            rounds.push_back(score);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        int sum = 0, score = 0;\\n        vector<int> rounds;\\n        for (string op : ops) {\\n            if (op == \"C\") {\\n                sum -= rounds.back();\\n                rounds.pop_back();\\n                continue;\\n            }\\n            if (op == \"D\") {\\n                sum += score = rounds.back() * 2;\\n            }\\n            else if (op == \"+\") {\\n                sum += score = rounds[rounds.size() - 1] + rounds[rounds.size() - 2];\\n            }\\n            else {\\n                sum += score = stoi(op);\\n            }\\n            rounds.push_back(score);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047526,
                "title": "java-100-faster-list-o-n-single-pass",
                "content": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n       LinkedList<Integer> list = new LinkedList<>();\\n        int sum = 0;\\n        for(var op : ops){\\n            switch (op){\\n                case \"C\":{\\n                    sum -= list.removeLast();\\n                    //list.removeLast();\\n                    break;\\n                }\\n                case \"D\":{\\n                    int item = list.getLast();\\n                    list.addLast(item*2);\\n                    sum+=item*2;\\n                    break;\\n                }\\n                case \"+\":{\\n                    int value = list.get(list.size()-2)+list.getLast();\\n                    list.addLast(value);\\n                    sum+=value;\\n                    break;\\n                }\\n                default:{\\n                    list.addLast(Integer.parseInt(op));\\n                    sum+=Integer.parseInt(op);\\n                    break;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int calPoints(String[] ops) {\\n       LinkedList<Integer> list = new LinkedList<>();\\n        int sum = 0;\\n        for(var op : ops){\\n            switch (op){\\n                case \"C\":{\\n                    sum -= list.removeLast();\\n                    //list.removeLast();\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 607494,
                "title": "easy-to-understand-faster-simple-stack-based-python-solution",
                "content": "```\\n    def calPoints(self, ops: List[str]) -> int:\\n        stack = []\\n        s = 0\\n        for op in ops:\\n            if op == \"C\":\\n                s -= stack.pop()\\n            elif op == \\'D\\':\\n                stack.append(2*stack[-1])\\n                s += stack[-1]\\n            elif op == \"+\":\\n                stack.append(stack[-1] + stack[-2])\\n                s += stack[-1]\\n            else:\\n                stack.append(int(op))\\n                s += stack[-1]\\n        return s\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n    def calPoints(self, ops: List[str]) -> int:\\n        stack = []\\n        s = 0\\n        for op in ops:\\n            if op == \"C\":\\n                s -= stack.pop()\\n            elif op == \\'D\\':\\n                stack.append(2*stack[-1])\\n                s += stack[-1]\\n            elif op == \"+\":\\n                stack.append(stack[-1] + stack[-2])\\n                s += stack[-1]\\n            else:\\n                stack.append(int(op))\\n                s += stack[-1]\\n        return s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 107873,
                "title": "java-very-concise-and-easy-to-understand-using-stack",
                "content": "\\n    public int calPoints(String[] ops) {\\n        int sum = 0;\\n        Stack<Integer> stack = new Stack<Integer>();\\n        for(int i = 0; i < ops.length; i++)\\n        {\\n            if(ops[i].equals(\"+\"))\\n            {\\n                int temp1 = stack.pop();\\n                int temp2 = stack.pop();\\n                int temp_sum = temp1 + temp2;\\n                sum += temp_sum;\\n                stack.push(temp2);\\n                stack.push(temp1);\\n                stack.push(temp_sum);\\n            }\\n            else if(ops[i].equals(\"D\"))\\n            {\\n                int temp = stack.pop();\\n                int temp_d = 2 * temp;\\n                sum += temp_d;\\n                stack.push(temp);\\n                stack.push(temp_d);\\n            }\\n            else if(ops[i].equals(\"C\"))\\n            {\\n                int cancel = stack.pop();\\n                sum -= cancel;\\n            }\\n            else\\n            {\\n                int temp = Integer.parseInt(ops[i]);\\n                sum += temp;\\n                stack.push(temp);   \\n            }\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int calPoints(String[] ops) {\\n        int sum = 0;\\n        Stack<Integer> stack = new Stack<Integer>();\\n        for(int i = 0; i < ops.length; i++)\\n        {\\n            if(ops[i].equals(\"+\"))\\n            {\\n                int temp1 = stack.pop();\\n                int temp2 = stack.pop();\\n                int temp_sum = temp1 + temp2;\\n                sum += temp_sum;\\n                stack.push(temp2);\\n                stack.push(temp1);\\n                stack.push(temp_sum);\\n            }\\n            else if(ops[i].equals(\"D\"))\\n            {\\n                int temp = stack.pop();\\n                int temp_d = 2 * temp;\\n                sum += temp_d;\\n                stack.push(temp);\\n                stack.push(temp_d);\\n            }\\n            else if(ops[i].equals(\"C\"))\\n            {\\n                int cancel = stack.pop();\\n                sum -= cancel;\\n            }\\n            else\\n            {\\n                int temp = Integer.parseInt(ops[i]);\\n                sum += temp;\\n                stack.push(temp);   \\n            }\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1930904,
                "title": "easy-to-understand-code-with-explanation-stack",
                "content": "***Approach Using Stack***\\n\\n```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        Stack<Integer> st = new Stack<>();//creating a stack\\n        for(String s :ops){//filling stack\\n            if(s.equals(\"C\")){ //if we got C in String then remove peek value in stack\\n                st.pop();\\n            }\\n            else if (s.equals(\"D\")){//if we got D in String then multiply the peek value of tack by 2\\n                st.push(st.peek()*2);\\n            }\\n            else if(s.equals(\"+\")){// if we got + in String then add the upermost 2 value of the stack\\n                int temp = st.pop();// removing the peek value while storing it in temperary value\\n                int sum = temp+st.peek();//now add both temp and the peek value\\n                st.push(temp);//pushing back temp and then sum in order\\n                st.push(sum);\\n            }\\n            else{// for all the interger value in string \\n                st.push(Integer.parseInt(s));// converting string to interger\\n            }\\n        }\\n        int res = 0;\\n        for(int i :st){\\n            res+=i;// adding all the value to stack in result \\n        }\\n        return res;\\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***Time Complexity =O(N)\\nSpace Complexity =O(N)***\\n\\n<hr>\\n<hr>\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        Stack<Integer> st = new Stack<>();//creating a stack\\n        for(String s :ops){//filling stack\\n            if(s.equals(\"C\")){ //if we got C in String then remove peek value in stack\\n                st.pop();\\n            }\\n            else if (s.equals(\"D\")){//if we got D in String then multiply the peek value of tack by 2\\n                st.push(st.peek()*2);\\n            }\\n            else if(s.equals(\"+\")){// if we got + in String then add the upermost 2 value of the stack\\n                int temp = st.pop();// removing the peek value while storing it in temperary value\\n                int sum = temp+st.peek();//now add both temp and the peek value\\n                st.push(temp);//pushing back temp and then sum in order\\n                st.push(sum);\\n            }\\n            else{// for all the interger value in string \\n                st.push(Integer.parseInt(s));// converting string to interger\\n            }\\n        }\\n        int res = 0;\\n        for(int i :st){\\n            res+=i;// adding all the value to stack in result \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931513,
                "title": "simplest-easy-solution-without-using-stack",
                "content": "```\\n//Please upvote , if you like my solution :)\\nint calPoints(vector<string>& ops) {\\n        vector<int> nums;\\n        for(auto &it : ops){\\n            if(it == \"+\"){\\n                nums.push_back(nums.back() + nums[nums.size()-2]);\\n            }else if(it == \"C\"){\\n                nums.pop_back();\\n            }else if(it == \"D\"){\\n                nums.push_back(2*nums.back());\\n            }else{\\n                nums.push_back(stoi(it));\\n            }\\n        }\\n        return accumulate(nums.begin(),nums.end(),0);\\n    }\\n//Please upvote , if you like my solution :)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Stack"
                ],
                "code": "```\\n//Please upvote , if you like my solution :)\\nint calPoints(vector<string>& ops) {\\n        vector<int> nums;\\n        for(auto &it : ops){\\n            if(it == \"+\"){\\n                nums.push_back(nums.back() + nums[nums.size()-2]);\\n            }else if(it == \"C\"){\\n                nums.pop_back();\\n            }else if(it == \"D\"){\\n                nums.push_back(2*nums.back());\\n            }else{\\n                nums.push_back(stoi(it));\\n            }\\n        }\\n        return accumulate(nums.begin(),nums.end(),0);\\n    }\\n//Please upvote , if you like my solution :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2821812,
                "title": "java-clean-and-simple",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (String s : operations) {\\n            if (s.equals(\"+\")) {\\n                int a = stack.pop();\\n                int newScore = a + stack.peek();\\n                stack.push(a);\\n                stack.push(newScore);\\n            }\\n            else if (s.equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            }\\n            else if (s.equals(\"C\")) {\\n                stack.pop();\\n            }\\n            else stack.push(Integer.parseInt(s));\\n        }\\n\\n        int totalScore = 0;\\n        while (!stack.isEmpty()) totalScore += stack.pop();\\n\\n        return totalScore;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (String s : operations) {\\n            if (s.equals(\"+\")) {\\n                int a = stack.pop();\\n                int newScore = a + stack.peek();\\n                stack.push(a);\\n                stack.push(newScore);\\n            }\\n            else if (s.equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            }\\n            else if (s.equals(\"C\")) {\\n                stack.pop();\\n            }\\n            else stack.push(Integer.parseInt(s));\\n        }\\n\\n        int totalScore = 0;\\n        while (!stack.isEmpty()) totalScore += stack.pop();\\n\\n        return totalScore;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107900,
                "title": "simple-js-solution",
                "content": "```js\\nvar calPoints = function(ops) {\\n    const arr = []\\n    const actions = {\\n        C: () => arr.pop(),\\n        D: () => arr.push(arr[arr.length - 1] * 2),\\n        '+': () => arr.push(arr[arr.length - 1] + arr[arr.length - 2])\\n    }\\n    for (let a of ops) {\\n        a in actions ? actions[a](): arr.push(+a)\\n    }\\n    return arr.reduce((sum, num) => sum + num)\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar calPoints = function(ops) {\\n    const arr = []\\n    const actions = {\\n        C: () => arr.pop(),\\n        D: () => arr.push(arr[arr.length - 1] * 2),\\n        '+': () => arr.push(arr[arr.length - 1] + arr[arr.length - 2])\\n    }\\n    for (let a of ops) {\\n        a in actions ? actions[a](): arr.push(+a)\\n    }\\n    return arr.reduce((sum, num) => sum + num)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932166,
                "title": "easy-c-solution-using-stack-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we are solving the problem using ***Stack,*** as it follows last in first out ***LIFO.***\\n- There are 4possible cases:\\n    1. `if(ops[i] == \"+\")` we have to store to 2 elements in 2 variables & push them including adding both and push them.\\n    2. `if(ops[i] == \"C\")` we need to pop the last inserted element.\\n    3. `if(ops[i] == \"D\")` next element will be double of last element, push that to stack.\\n    4. Else there will be an integer, so push it directly to our stack \\n- Add all the stack element to ans & return it.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        int ans = 0;\\n        stack<int> st;\\n        \\n        for(int i=0; i<ops.size(); i++){\\n            if(ops[i] == \"+\"){\\n                int x = st.top();\\n                st.pop();\\n                int y = st.top();\\n                st.pop();\\n                \\n                st.push(y);\\n                st.push(x);\\n                st.push(x+y);\\n            }\\n            else if(ops[i] == \"C\"){\\n                st.pop();\\n            }\\n            else if(ops[i] == \"D\"){\\n                st.push(2*st.top());\\n            }\\n            else{\\n                int x = stoi(ops[i]);\\n                st.push(x);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution on Leetcode:**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        int ans = 0;\\n        stack<int> st;\\n        \\n        for(int i=0; i<ops.size(); i++){\\n            if(ops[i] == \"+\"){\\n                int x = st.top();\\n                st.pop();\\n                int y = st.top();\\n                st.pop();\\n                \\n                st.push(y);\\n                st.push(x);\\n                st.push(x+y);\\n            }\\n            else if(ops[i] == \"C\"){\\n                st.pop();\\n            }\\n            else if(ops[i] == \"D\"){\\n                st.push(2*st.top());\\n            }\\n            else{\\n                int x = stoi(ops[i]);\\n                st.push(x);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960391,
                "title": "two-simple-java-solutions-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) \\n    {\\n        int output = 0;\\n\\n        int[] list = new int[operations.length];\\n\\n        for (int i = 0 , j = -1; i < operations.length ; i++)\\n        {\\n            if (operations[i].equals(\"C\"))\\n            {\\n                list[j] = 0;\\n                j--;\\n            }else if (operations[i].equals(\"D\")){\\n                j++;\\n                list[j] = 2 * (list[j-1]) ;\\n            }else if (operations[i].equals(\"+\")){\\n                j++;\\n                list[j] = (list[j-1] + list[j-2] );\\n            }else {\\n                j++;\\n                list[j] = (Integer.parseInt(operations[i]));\\n            }\\n\\n        }\\n\\n        for (int n : list){\\n            output += n;\\n        }\\n\\n\\n        return output;\\n    }\\n}\\n```\\n\\n# code 2 :  By LinkedList \\n\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n          int output = 0;\\n\\n        LinkedList<Integer> list = new LinkedList<>();\\n\\n        for (int i = 0 , j = 0; i < operations.length ; i++)\\n        {\\n            if (operations[i].equals(\"C\"))\\n            {\\n                list.removeLast();\\n                j--;\\n            }else if (operations[i].equals(\"D\")){\\n                list.add( 2 * (list.getLast()) );\\n                j++;\\n            }else if (operations[i].equals(\"+\")){\\n                list.add(list.getLast() + list.get(j-2));\\n                j++;\\n            }else {\\n                list.add(Integer.parseInt(operations[i]));\\n                j++;\\n            }\\n\\n        }\\n\\n        for (int n : list){\\n            output += n;\\n        }\\n\\n\\n        return output;\\n    }\\n}\\n```\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/97ba9f47-f35a-46fe-8890-60103b85cc26_1693003538.1619122.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] operations) \\n    {\\n        int output = 0;\\n\\n        int[] list = new int[operations.length];\\n\\n        for (int i = 0 , j = -1; i < operations.length ; i++)\\n        {\\n            if (operations[i].equals(\"C\"))\\n            {\\n                list[j] = 0;\\n                j--;\\n            }else if (operations[i].equals(\"D\")){\\n                j++;\\n                list[j] = 2 * (list[j-1]) ;\\n            }else if (operations[i].equals(\"+\")){\\n                j++;\\n                list[j] = (list[j-1] + list[j-2] );\\n            }else {\\n                j++;\\n                list[j] = (Integer.parseInt(operations[i]));\\n            }\\n\\n        }\\n\\n        for (int n : list){\\n            output += n;\\n        }\\n\\n\\n        return output;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n          int output = 0;\\n\\n        LinkedList<Integer> list = new LinkedList<>();\\n\\n        for (int i = 0 , j = 0; i < operations.length ; i++)\\n        {\\n            if (operations[i].equals(\"C\"))\\n            {\\n                list.removeLast();\\n                j--;\\n            }else if (operations[i].equals(\"D\")){\\n                list.add( 2 * (list.getLast()) );\\n                j++;\\n            }else if (operations[i].equals(\"+\")){\\n                list.add(list.getLast() + list.get(j-2));\\n                j++;\\n            }else {\\n                list.add(Integer.parseInt(operations[i]));\\n                j++;\\n            }\\n\\n        }\\n\\n        for (int n : list){\\n            output += n;\\n        }\\n\\n\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152555,
                "title": "using-arraylist-in-java-well-explained",
                "content": "\\n\\n# Approach\\nThe approach of the given code is to calculate the total score in a game of baseball, given an array of operations (\\'ops\\'). The code uses an ArrayList \\'list\\' to keep track of the scores at each round.\\n\\n1. Initialization: The code initializes the integer \\'ans\\' to 0 and the ArrayList \\'list\\' to an empty list.\\n\\n2. Iterating through the operations: The code iterates through the \\'ops\\' array using a for loop.\\n- If the current element in the \\'ops\\' array is \"+\", it adds the sum of the last two elements in the \\'list\\' to the \\'list\\'.\\n- If the current element in the \\'ops\\' array is \"D\", it adds double the last element in the \\'list\\' to the \\'list\\'.\\n- If the current element in the \\'ops\\' array is \"C\", it removes the last element from the \\'list\\'.\\n- If the current element in the \\'ops\\' array is a number, it converts it to an integer and adds it to the \\'list\\'.\\n\\n3. Calculating the total score: The code iterates through the \\'list\\' and adds up all the elements in the \\'list\\' to get the total score, which is stored in \\'ans\\'.\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the code is O(n), where n is the number of elements in the \\'ops\\' array. This is because the code only iterates through the \\'ops\\' array once and performs a constant amount of operations for each element in the array.\\n\\n- Space complexity:\\nThe space complexity of the code is O(n), where n is the number of elements in the \\'ops\\' array. This is because the code uses an ArrayList \\'list\\' to store the scores of each round, which has a maximum size of n.\\n\\n# Note -\\nThe difference between \\'==\\' and \\'.equals()\\' in Java is as follows:\\n\\n- \\'==\\' operator: Compares if two references refer to the same object in memory.\\n- \\'.equals()\\' method: Compares the values of two objects.\\n\\nIn the given code, the elements in the \\'ops\\' array are strings. When you compare strings, you need to use the \\'.equals()\\' method, not the \\'==\\' operator, as the latter only checks if two references point to the same object in memory. The \\'.equals()\\' method, on the other hand, compares the actual contents of the strings and returns true if the contents are equal, regardless of whether the strings are stored in separate memory locations or not.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int ans = 0;                                  \\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<ops.length;i++){\\n    \\n            if(ops[i].equals(\"+\")){\\n                int sum = list.get(list.size()-1)+list.get(list.size()-2);\\n                list.add(sum);\\n            }\\n            else if(ops[i].equals(\"D\")){\\n                int prod = 2*list.get(list.size()-1);\\n                list.add(prod);\\n            }\\n            else if(ops[i].equals(\"C\")){\\n                list.remove(list.size()-1);\\n            }\\n            else{\\n                int t = Integer.parseInt(ops[i]);\\n                list.add(t);\\n            }\\n        }\\n        for(int i=0;i<list.size();i++){\\n            ans +=list.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/88b84055-0606-4da3-be81-af34aec51353_1675707585.5151799.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int ans = 0;                                  \\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<ops.length;i++){\\n    \\n            if(ops[i].equals(\"+\")){\\n                int sum = list.get(list.size()-1)+list.get(list.size()-2);\\n                list.add(sum);\\n            }\\n            else if(ops[i].equals(\"D\")){\\n                int prod = 2*list.get(list.size()-1);\\n                list.add(prod);\\n            }\\n            else if(ops[i].equals(\"C\")){\\n                list.remove(list.size()-1);\\n            }\\n            else{\\n                int t = Integer.parseInt(ops[i]);\\n                list.add(t);\\n            }\\n        }\\n        for(int i=0;i<list.size();i++){\\n            ans +=list.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932457,
                "title": "easy-java-solution-using-stack-with-explanation-clean-code",
                "content": "\\n```\\nclass Solution {\\n    \\n    public int calPoints(String[] ops) {\\n        \\n        Stack<Integer> s= new Stack<>();\\n        for(int i=0;i<ops.length;i++){\\n            // ATQ--> \"C\" is encountered simple pop the element.\\n            if(ops[i].equals(\"C\")){\\n                s.pop();\\n            }\\n            // ATQ-->\"D\" is encountered while traversing the string we push into stack 2*s.peek() element .\\n            else if(ops[i].equals(\"D\")){\\n                s.push(2*s.peek());\\n            }\\n            //ATQ-->  \"+\" is encountered in the ops array we pop two element then add their sum and again push the popped items with their sum.\\n            else if(ops[i].equals(\"+\")){\\n                int sum=0;\\n                int s1=s.pop();\\n                int s2=s.pop();\\n                sum=s1+s2;\\n                s.push(s2);\\n                s.push(s1);\\n                s.push(sum);\\n            }\\n            // ATQ--> if the element is digit simply push the element in stack\\n            else{\\n                s.push(Integer.parseInt(ops[i]));\\n            }\\n        }\\n        \\n        // finally pop all the element from stack & return their sum\\n        int sumofStack=0;\\n        while(!s.isEmpty()){\\n            sumofStack=sumofStack+s.pop();\\n        }\\n        \\n        // return their sum\\n        return sumofStack;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int calPoints(String[] ops) {\\n        \\n        Stack<Integer> s= new Stack<>();\\n        for(int i=0;i<ops.length;i++){\\n            // ATQ--> \"C\" is encountered simple pop the element.\\n            if(ops[i].equals(\"C\")){\\n                s.pop();\\n            }\\n            // ATQ-->\"D\" is encountered while traversing the string we push into stack 2*s.peek() element .\\n            else if(ops[i].equals(\"D\")){\\n                s.push(2*s.peek());\\n            }\\n            //ATQ-->  \"+\" is encountered in the ops array we pop two element then add their sum and again push the popped items with their sum.\\n            else if(ops[i].equals(\"+\")){\\n                int sum=0;\\n                int s1=s.pop();\\n                int s2=s.pop();\\n                sum=s1+s2;\\n                s.push(s2);\\n                s.push(s1);\\n                s.push(sum);\\n            }\\n            // ATQ--> if the element is digit simply push the element in stack\\n            else{\\n                s.push(Integer.parseInt(ops[i]));\\n            }\\n        }\\n        \\n        // finally pop all the element from stack & return their sum\\n        int sumofStack=0;\\n        while(!s.isEmpty()){\\n            sumofStack=sumofStack+s.pop();\\n        }\\n        \\n        // return their sum\\n        return sumofStack;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411637,
                "title": "javascript-solution-faster-than-90",
                "content": "```/**\\n * @param {string[]} ops\\n * @return {number}\\n */\\nvar calPoints = function(ops) {\\n    let stack = [];\\n    ops.forEach((op)=>{\\n        if(parseInt(op)){\\n            stack.push(parseInt(op))\\n        }\\n        else if(op === \\'+\\'){\\n            stack.push((stack[stack.length-1] || 0 ) + (stack[stack.length-2] || 0 ))\\n        }\\n        else if(op === \\'D\\'){\\n            stack.push((stack[stack.length-1] || 0 ) *2)\\n        }\\n        else if(op === \\'C\\'){\\n            stack.pop();\\n        }\\n    })\\n    console.log(stack)\\n    return stack.reduce((a,v)=>a+v,0)\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * @param {string[]} ops\\n * @return {number}\\n */\\nvar calPoints = function(ops) {\\n    let stack = [];\\n    ops.forEach((op)=>{\\n        if(parseInt(op)){\\n            stack.push(parseInt(op))\\n        }\\n        else if(op === \\'+\\'){\\n            stack.push((stack[stack.length-1] || 0 ) + (stack[stack.length-2] || 0 ))\\n        }\\n        else if(op === \\'D\\'){\\n            stack.push((stack[stack.length-1] || 0 ) *2)\\n        }\\n        else if(op === \\'C\\'){\\n            stack.pop();\\n        }\\n    })\\n    console.log(stack)\\n    return stack.reduce((a,v)=>a+v,0)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 380544,
                "title": "two-solutions-in-python-3-beats-99",
                "content": "_With Stack:_\\n```\\nclass Solution:\\n    def calPoints(self, s: List[str]) -> int:\\n    \\tp = []\\n    \\tfor i in s:\\n    \\t\\tif i == \\'C\\': p.pop()\\n    \\t\\telif i == \\'D\\': p.append(2*p[-1])\\n    \\t\\telif i == \\'+\\': p.append(p[-1]+p[-2])\\n    \\t\\telse: p.append(int(i))\\n    \\treturn sum(p)\\n\\t\\t\\n\\n\\n```\\n_Without Stack:_\\n```\\nclass Solution:\\n    def calPoints(self, s: List[str]) -> int:\\n    \\ts, i = [int(s[i]) if s[i] not in \\'CD+\\' else s[i] for i in range(len(s))]+[\\'\\'], 1\\n    \\twhile s[i] != \\'\\':\\n    \\t\\tif s[i] == \\'C\\':\\n    \\t\\t\\tdel s[i-1], s[i-1]\\n    \\t\\t\\ti -= 1\\n    \\t\\t\\tcontinue\\n    \\t\\ti += 1\\n    \\tfor i in range(len(s)-1):\\n    \\t\\tif s[i] == \\'D\\': s[i] = 2*s[i-1]\\n    \\t\\tif s[i] == \\'+\\': s[i] = s[i-2] + s[i-1]\\n    \\treturn sum(s[:len(s)-1])\\n\\t\\t\\n\\n\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, s: List[str]) -> int:\\n    \\tp = []\\n    \\tfor i in s:\\n    \\t\\tif i == \\'C\\': p.pop()\\n    \\t\\telif i == \\'D\\': p.append(2*p[-1])\\n    \\t\\telif i == \\'+\\': p.append(p[-1]+p[-2])\\n    \\t\\telse: p.append(int(i))\\n    \\treturn sum(p)\\n\\t\\t\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534032,
                "title": "java-stack-baseball-game",
                "content": "\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(String step : operations)\\n        {\\n            switch (step)\\n            {\\n                case \"+\":\\n                {\\n                    int second = stack.pop();\\n                    int first = stack.peek();\\n                    stack.push(second);\\n                    stack.push(second + first);\\n                    break;\\n                }\\n                case \"D\": {\\n                    stack.push(stack.peek() * 2);\\n                    break;\\n                }\\n                case \"C\":\\n                {\\n                    stack.pop();\\n                    break;\\n                }\\n                default:\\n                    stack.push(Integer.parseInt(step));\\n            }\\n        }\\n        int sum = 0;\\n        while (stack.size() > 0)\\n            sum += stack.pop();\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(String step : operations)\\n        {\\n            switch (step)\\n            {\\n                case \"+\":\\n                {\\n                    int second = stack.pop();\\n                    int first = stack.peek();\\n                    stack.push(second);\\n                    stack.push(second + first);\\n                    break;\\n                }\\n                case \"D\": {\\n                    stack.push(stack.peek() * 2);\\n                    break;\\n                }\\n                case \"C\":\\n                {\\n                    stack.pop();\\n                    break;\\n                }\\n                default:\\n                    stack.push(Integer.parseInt(step));\\n            }\\n        }\\n        int sum = 0;\\n        while (stack.size() > 0)\\n            sum += stack.pop();\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934341,
                "title": "javascript-100-stack-reduce",
                "content": "![image](https://assets.leetcode.com/users/images/2426d8ee-2338-4056-837b-b7e4a2b61c82_1649625964.7165606.png)\\n\\n\\n```\\nconst calPoints = ops => {\\n  return ops.reduce((score, op, idx) => {\\n    if (op === \\'C\\') score.pop()\\n    else if (op === \\'D\\') score.push(score[score.length - 1] * 2)\\n    else if (op === \\'+\\') score.push(score[score.length - 1] + score[score.length - 2])\\n    else score.push(+op)\\n    return score\\n  }, []).reduce((sum, num) => sum += num, 0)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nconst calPoints = ops => {\\n  return ops.reduce((score, op, idx) => {\\n    if (op === \\'C\\') score.pop()\\n    else if (op === \\'D\\') score.push(score[score.length - 1] * 2)\\n    else if (op === \\'+\\') score.push(score[score.length - 1] + score[score.length - 2])\\n    else score.push(+op)\\n    return score\\n  }, []).reduce((sum, num) => sum += num, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3301191,
                "title": "java-stack-explained",
                "content": "# Intuition\\nFor **D** -> **stack.peek() x 2** ... So then we will have twice the value of Last\\nFor **C** -> **stack.pop()** ... Invalidate last Score\\nFor **+** -> **x=stack.pop() , y=stack.pop() , z=x+y ,then push y,x,z resp..**\\nFor **x** -> **stack.push(Integer.parseInt(x)))**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack=new Stack<>();\\n        \\n        for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n                stack.pop();\\n            }\\n\\n        else if(operations[i].equals(\"D\")){\\n            stack.push(stack.peek()*2);\\n        }\\n        else if(operations[i].equals(\"+\")){\\n            int x=stack.pop();\\n            int y=stack.pop();\\n            int z=x+y;\\n            stack.push(y);\\n            stack.push(x);\\n            stack.push(z);\\n        }\\n        else{\\n            stack.push(Integer.parseInt(operations[i]));\\n        }\\n        }\\n        int sum=0;\\n        while(!stack.isEmpty()){\\n            sum+=stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack=new Stack<>();\\n        \\n        for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n                stack.pop();\\n            }\\n\\n        else if(operations[i].equals(\"D\")){\\n            stack.push(stack.peek()*2);\\n        }\\n        else if(operations[i].equals(\"+\")){\\n            int x=stack.pop();\\n            int y=stack.pop();\\n            int z=x+y;\\n            stack.push(y);\\n            stack.push(x);\\n            stack.push(z);\\n        }\\n        else{\\n            stack.push(Integer.parseInt(operations[i]));\\n        }\\n        }\\n        int sum=0;\\n        while(!stack.isEmpty()){\\n            sum+=stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932976,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {string[]} ops\\n * @return {number}\\n */\\nvar calPoints = function(ops) {\\n    const stack = [];\\n    \\n    for(let i=0; i<ops.length; i++){\\n        \\n        switch(ops[i]){\\n            case \\'D\\': {\\n                // Record a new score that is double the previous score. \\n                // It is guaranteed there will always be a previous score.\\n                const last = stack[stack.length - 1];\\n                stack.push(last * 2);\\n                break;\\n            }\\n                \\n            case \\'C\\':{\\n                // Invalidate the previous score, removing it from the record. \\n                // It is guaranteed there will always be a previous score.\\n                stack.pop();\\n                break;\\n            }\\n                \\n            case \\'+\\': {\\n                // Record a new score that is the sum of the previous two scores. \\n                // It is guaranteed there will always be two previous scores.\\n                const one = stack[stack.length - 2];\\n                const two = stack[stack.length - 1];\\n                stack.push(one + two);\\n                break;\\n            }\\n                \\n            default: {\\n                stack.push(Number(ops[i]))\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return stack.reduce((prev, cur) => prev + cur, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string[]} ops\\n * @return {number}\\n */\\nvar calPoints = function(ops) {\\n    const stack = [];\\n    \\n    for(let i=0; i<ops.length; i++){\\n        \\n        switch(ops[i]){\\n            case \\'D\\': {\\n                // Record a new score that is double the previous score. \\n                // It is guaranteed there will always be a previous score.\\n                const last = stack[stack.length - 1];\\n                stack.push(last * 2);\\n                break;\\n            }\\n                \\n            case \\'C\\':{\\n                // Invalidate the previous score, removing it from the record. \\n                // It is guaranteed there will always be a previous score.\\n                stack.pop();\\n                break;\\n            }\\n                \\n            case \\'+\\': {\\n                // Record a new score that is the sum of the previous two scores. \\n                // It is guaranteed there will always be two previous scores.\\n                const one = stack[stack.length - 2];\\n                const two = stack[stack.length - 1];\\n                stack.push(one + two);\\n                break;\\n            }\\n                \\n            default: {\\n                stack.push(Number(ops[i]))\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return stack.reduce((prev, cur) => prev + cur, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1930948,
                "title": "c-vector-without-using-stack-easy-approach",
                "content": "function which we used\\n1. **vector.push_back( n )** : insert an element n at the last in the vector.\\n2. **vector.pop_back()** : delete an element from the last of the vector.\\n3. **stoi( ops[i] )** : convert the string value in to the integer.\\n\\n\\t**CODE :**\\n\\n```\\n\\t\\t\\t\\t/* If you find this helpful upvote please */\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        int n = ops.size() , sum = 0 ;\\n\\t\\tint k = 1; // we use this variable for the indexing of ans vector.\\n        vector<int> ans;\\n        ans.push_back(stoi(ops[0])); //it is certain that first element should be inserted for any other operation.\\n        for(int i = 1 ; i < n ;i ++) //we run a loop from index 1 to last.\\n        {\\n            if(ops[i] == \"D\")\\n            {\\n                ans.push_back(ans[k - 1] * 2);\\n                k ++;\\n            }\\n            else if(ops[i] == \"C\")\\n            {\\n                ans.pop_back();\\n                k --; //we decrement an index because we remove an element.\\n            }\\n            else if(ops[i] == \"+\")\\n            {\\n                ans.push_back(ans[k - 1] + ans[k - 2]);\\n                k ++;\\n            }\\n            else\\n            {\\n                ans.push_back(stoi(ops[i]));\\n                k ++;\\n            }\\n        }\\n        for(int j = 0 ; j < ans.size() ; j ++)\\n        {\\n            sum = sum + ans[j];\\n        }\\n        return sum;\\n    }\\n};\\n\\t\\t\\t\\t\\t\\t\\t\\t// Thank You\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\t\\t\\t\\t/* If you find this helpful upvote please */\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        int n = ops.size() , sum = 0 ;\\n\\t\\tint k = 1; // we use this variable for the indexing of ans vector.\\n        vector<int> ans;\\n        ans.push_back(stoi(ops[0])); //it is certain that first element should be inserted for any other operation.\\n        for(int i = 1 ; i < n ;i ++) //we run a loop from index 1 to last.\\n        {\\n            if(ops[i] == \"D\")\\n            {\\n                ans.push_back(ans[k - 1] * 2);\\n                k ++;\\n            }\\n            else if(ops[i] == \"C\")\\n            {\\n                ans.pop_back();\\n                k --; //we decrement an index because we remove an element.\\n            }\\n            else if(ops[i] == \"+\")\\n            {\\n                ans.push_back(ans[k - 1] + ans[k - 2]);\\n                k ++;\\n            }\\n            else\\n            {\\n                ans.push_back(stoi(ops[i]));\\n                k ++;\\n            }\\n        }\\n        for(int j = 0 ; j < ans.size() ; j ++)\\n        {\\n            sum = sum + ans[j];\\n        }\\n        return sum;\\n    }\\n};\\n\\t\\t\\t\\t\\t\\t\\t\\t// Thank You\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930901,
                "title": "simple-java-solution-using-stack",
                "content": "since we want to look always last element (atmost last 2) everytime. hence stack is best suitable for it.\\n```\\npublic int calPoints(String[] ops) {\\n        Deque<Integer> stack = new LinkedList<>();\\n        for(String val:ops) {\\n            if(\"+\".equals(val)) {\\n                int op1 = stack.pop();\\n                int op2 = op1 + stack.peek();\\n                stack.push(op1);\\n                stack.push(op2);\\n            } else if(\"C\".equals(val)) {\\n                stack.pop();\\n            } else if(\"D\".equals(val)) {\\n                stack.push(2*stack.peek());\\n            } else {\\n                stack.push(Integer.parseInt(val));\\n            }\\n        }\\n        int res=0;\\n        while(!stack.isEmpty()) {\\n            res+=stack.pop();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int calPoints(String[] ops) {\\n        Deque<Integer> stack = new LinkedList<>();\\n        for(String val:ops) {\\n            if(\"+\".equals(val)) {\\n                int op1 = stack.pop();\\n                int op2 = op1 + stack.peek();\\n                stack.push(op1);\\n                stack.push(op2);\\n            } else if(\"C\".equals(val)) {\\n                stack.pop();\\n            } else if(\"D\".equals(val)) {\\n                stack.push(2*stack.peek());\\n            } else {\\n                stack.push(Integer.parseInt(val));\\n            }\\n        }\\n        int res=0;\\n        while(!stack.isEmpty()) {\\n            res+=stack.pop();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3193851,
                "title": "easy-python-solution-got-98-run-time-using-stacks",
                "content": "# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        lst=[]\\n        for i in operations:\\n            if i==\"C\":\\n                lst.pop()\\n            elif i==\"D\":\\n                lst.append(lst[-1]*2)\\n            elif i==\"+\":\\n                sm=lst[-2]+lst[-1]\\n                lst.append(sm)\\n            else:\\n                lst.append(int(i))\\n        print(lst)\\n        return sum(lst)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        lst=[]\\n        for i in operations:\\n            if i==\"C\":\\n                lst.pop()\\n            elif i==\"D\":\\n                lst.append(lst[-1]*2)\\n            elif i==\"+\":\\n                sm=lst[-2]+lst[-1]\\n                lst.append(sm)\\n            else:\\n                lst.append(int(i))\\n        print(lst)\\n        return sum(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771301,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n    public int calPoints(String[] ops) {\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (int i = 0; i < ops.length; i++) {\\n            if (ops[i].equals(\"C\")) {\\n                stack.pop();\\n            } else if (ops[i].equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            } else if (ops[i].equals(\"+\")) {\\n                int a = stack.pop();\\n                int res = a + stack.peek();\\n                stack.push(a);\\n                stack.push(res);\\n            } else stack.push(Integer.valueOf(ops[i]));\\n        }\\n\\n        int res = 0;\\n\\n        while (!stack.isEmpty()) {\\n            res += stack.pop();\\n        }\\n\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\n    public int calPoints(String[] ops) {\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (int i = 0; i < ops.length; i++) {\\n            if (ops[i].equals(\"C\")) {\\n                stack.pop();\\n            } else if (ops[i].equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            } else if (ops[i].equals(\"+\")) {\\n                int a = stack.pop();\\n                int res = a + stack.peek();\\n                stack.push(a);\\n                stack.push(res);\\n            } else stack.push(Integer.valueOf(ops[i]));\\n        }\\n\\n        int res = 0;\\n\\n        while (!stack.isEmpty()) {\\n            res += stack.pop();\\n        }\\n\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982933,
                "title": "python-easy-and-straightforward-solution-w-explanation-18ms-beats-99-12",
                "content": "**Explanation**:\\nWe first have a list for the record (empty list)\\nWe iterate through `ops` and each time we check if the current element is:\\n\\t- The letter \"C\": delete last element in the record\\n\\t- The letter \"D\": add the double of the last element into the record\\n\\t- The symbol \"+\": add the sum of the last 2 elements into the record\\n\\t- Anything else (has to be an integer x, as said in the constraints)\\n\\nLastly, we take the sum of all the numbers in the record.\\n\\n\\n\\n```\\nclass Solution(object):\\n    def calPoints(self, ops):\\n        \"\"\"\\n        :type ops: List[str]\\n        :rtype: int\\n        \"\"\"\\n        record = []\\n        for i in range(len(ops)):\\n            if ops[i] == \\'C\\':\\n                record.pop()\\n            elif ops[i] == \\'D\\':\\n                record.append(record[-1] * 2)\\n            elif ops[i] == \\'+\\':\\n                record.append(record[-1] + record[-2])\\n            else:\\n                record.append(int(ops[i]))\\n        return sum(record)\\n```\\n\\n**If you liked this, please upvote to support me!**\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def calPoints(self, ops):\\n        \"\"\"\\n        :type ops: List[str]\\n        :rtype: int\\n        \"\"\"\\n        record = []\\n        for i in range(len(ops)):\\n            if ops[i] == \\'C\\':\\n                record.pop()\\n            elif ops[i] == \\'D\\':\\n                record.append(record[-1] * 2)\\n            elif ops[i] == \\'+\\':\\n                record.append(record[-1] + record[-2])\\n            else:\\n                record.append(int(ops[i]))\\n        return sum(record)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933515,
                "title": "stack-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> nums;\\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i]==\"+\"){\\n                int ans=0;\\n                ans+=nums.top();\\n                int store=nums.top();\\n                nums.pop();\\n                ans+=nums.top();\\n                int store2=nums.top();\\n                nums.push(store);\\n                nums.push(ans);\\n            }\\n            else if(ops[i]==\"C\"){\\n                nums.pop();\\n            }\\n            else if(ops[i]==\"D\"){\\n                int ans=0;\\n                int val=nums.top();\\n                ans=2*val;\\n                nums.push(ans);\\n            }\\n            else{\\n                nums.push(stoi(ops[i]));\\n            }\\n        }\\n        int ans=0;\\n        while(!nums.empty()){\\n            ans+=nums.top();\\n            nums.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> nums;\\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i]==\"+\"){\\n                int ans=0;\\n                ans+=nums.top();\\n                int store=nums.top();\\n                nums.pop();\\n                ans+=nums.top();\\n                int store2=nums.top();\\n                nums.push(store);\\n                nums.push(ans);\\n            }\\n            else if(ops[i]==\"C\"){\\n                nums.pop();\\n            }\\n            else if(ops[i]==\"D\"){\\n                int ans=0;\\n                int val=nums.top();\\n                ans=2*val;\\n                nums.push(ans);\\n            }\\n            else{\\n                nums.push(stoi(ops[i]));\\n            }\\n        }\\n        int ans=0;\\n        while(!nums.empty()){\\n            ans+=nums.top();\\n            nums.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933200,
                "title": "c-stack-easy-o-n-solution-100-faster",
                "content": "**Please upvote if you find this solution helpful :)**\\n**Code:**\\n**TC: O(N), SC: O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) \\n    {\\n        stack<int> st;\\n        int helper1, helper2;\\n        \\n        for(auto it:ops)\\n        {\\n            if(it==\"C\")\\n            {\\n                st.pop();\\n            }\\n            \\n            else if(it==\"D\")\\n            {\\n                st.push(2*st.top());\\n            }\\n            \\n            else if(it==\"+\")\\n            {\\n                helper1=st.top();\\n                st.pop();\\n                helper2=st.top();\\n                st.push(helper1);\\n                st.push(helper1+helper2);\\n            }\\n            else\\n            {\\n                st.push(stoi(it));\\n            }\\n        }\\n        \\n        int ans=0;\\n        while(!st.empty())\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please upvote if you find this solution helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) \\n    {\\n        stack<int> st;\\n        int helper1, helper2;\\n        \\n        for(auto it:ops)\\n        {\\n            if(it==\"C\")\\n            {\\n                st.pop();\\n            }\\n            \\n            else if(it==\"D\")\\n            {\\n                st.push(2*st.top());\\n            }\\n            \\n            else if(it==\"+\")\\n            {\\n                helper1=st.top();\\n                st.pop();\\n                helper2=st.top();\\n                st.push(helper1);\\n                st.push(helper1+helper2);\\n            }\\n            else\\n            {\\n                st.push(stoi(it));\\n            }\\n        }\\n        \\n        int ans=0;\\n        while(!st.empty())\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930604,
                "title": "c-vector-and-stuff-check-it-out-live-on-stream",
                "content": "Link to stream in my profile\\n\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        int ans = 0;\\n        vector<int> scores;\\n        int n = ops.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            int size = scores.size();\\n            if(ops[i] == \"+\") {\\n                scores.push_back(scores[size-1] + scores[size-2]);\\n            } else if (ops[i] == \"C\") { \\n                scores.pop_back();\\n            } else if (ops[i] == \"D\") {\\n                scores.push_back(scores[size-1]*2);\\n            } else {\\n                scores.push_back(stoi(ops[i]));\\n            }\\n        }\\n        \\n        ans = accumulate(scores.begin(), scores.end(), 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        int ans = 0;\\n        vector<int> scores;\\n        int n = ops.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            int size = scores.size();\\n            if(ops[i] == \"+\") {\\n                scores.push_back(scores[size-1] + scores[size-2]);\\n            } else if (ops[i] == \"C\") { \\n                scores.pop_back();\\n            } else if (ops[i] == \"D\") {\\n                scores.push_back(scores[size-1]*2);\\n            } else {\\n                scores.push_back(stoi(ops[i]));\\n            }\\n        }\\n        \\n        ans = accumulate(scores.begin(), scores.end(), 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736576,
                "title": "c-100-faster-0ms-using-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack <int> st;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < ops.size(); i++){\\n                \\n                if(ops[i] == \"+\"){\\n                        \\n                        int val1,val2;\\n                        val1 = st.top();\\n                        st.pop();\\n                        val2 = st.top();\\n                        st.pop();\\n                        sum += (val1 + val2);\\n                        st.push(val2);\\n                        st.push(val1);\\n                        st.push(val2 + val1);\\n                }\\n                        else if(ops[i] == \"D\"){    \\n                        int val = st.top();\\n                        st.push( val*2 );\\n                        sum += 2*val;\\n                        }\\n                        else if(ops[i] == \"C\"){                \\n                        sum -= st.top();\\n                        st.pop();\\n                }\\n                else \\n                    st.push(stoi(ops[i])),sum += stoi(ops[i]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack <int> st;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < ops.size(); i++){\\n                \\n                if(ops[i] == \"+\"){\\n                        \\n                        int val1,val2;\\n                        val1 = st.top();\\n                        st.pop();\\n                        val2 = st.top();\\n                        st.pop();\\n                        sum += (val1 + val2);\\n                        st.push(val2);\\n                        st.push(val1);\\n                        st.push(val2 + val1);\\n                }\\n                        else if(ops[i] == \"D\"){    \\n                        int val = st.top();\\n                        st.push( val*2 );\\n                        sum += 2*val;\\n                        }\\n                        else if(ops[i] == \"C\"){                \\n                        sum -= st.top();\\n                        st.pop();\\n                }\\n                else \\n                    st.push(stoi(ops[i])),sum += stoi(ops[i]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674378,
                "title": "easiest-python-solution-with-stack-implemenation",
                "content": "```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        stack=[]\\n        for i,el in enumerate(ops):\\n            if el==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            elif el==\\'D\\':\\n                stack.append(stack[-1]*2)\\n            elif el==\\'C\\':\\n                stack.pop()\\n            else:\\n                stack.append(int(el))\\n        return sum(stack)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        stack=[]\\n        for i,el in enumerate(ops):\\n            if el==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            elif el==\\'D\\':\\n                stack.append(stack[-1]*2)\\n            elif el==\\'C\\':\\n                stack.pop()\\n            else:\\n                stack.append(int(el))\\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153120,
                "title": "java-using-stack-with-comments",
                "content": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        if(ops.length ==0 || ops ==null)         // returning 0 if ops is null or empty\\n            return 0;\\n        Stack<Integer> stack = new Stack();        \\n        for(int i = 0; i<ops.length; i++) {            \\n            if(ops[i].equals(\"D\")) {                     //if \"D\" is encountered while traversing the string we push into stack 2*stack.peek() element.\\n                stack.push(2*stack.peek());\\n            }\\n            else if(ops[i].equals(\"C\")) {  //If \"C\" is encountered simply pop the element. No need to check for empty stack(its already handled as stated in the question).\\n                stack.pop();\\n            }\\n            else if(ops[i].equals(\"+\")) {       //The tricky part in my solution. if \"+\" is encountered in the ops array we pop out two elements add their sum and then again push the popped items one by one with thier sum.(Again no need to handle the empty case of stack already stated in the question).\\n                int sum = 0;\\n                int s1 = stack.pop();\\n                int s2 = stack.pop();\\n                sum = s1+s2;\\n                stack.push(s2);\\n                stack.push(s1);\\n                stack.push(sum);\\n            }\\n            else {\\n                stack.push(Integer.parseInt(ops[i]));                 // if the ith element is digit simply push it in the stack.\\n            }\\n        }\\n        int sumOfStack = 0;\\n        while(!stack.isEmpty()) {\\n            sumOfStack+=stack.pop();                                //Finally pop all the items and return their sum\\n        }\\n        return sumOfStack;\\n    }\\n}\\n```\\n# 2 ms, faster than 81.46% of Java online submissions for Baseball Game.\\n\\n## Do upvote if you find the solution helpful.",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        if(ops.length ==0 || ops ==null)         // returning 0 if ops is null or empty\\n            return 0;\\n        Stack<Integer> stack = new Stack();        \\n        for(int i = 0; i<ops.length; i++) {            \\n            if(ops[i].equals(\"D\")) {                     //if \"D\" is encountered while traversing the string we push into stack 2*stack.peek() element.\\n                stack.push(2*stack.peek());\\n            }\\n            else if(ops[i].equals(\"C\")) {  //If \"C\" is encountered simply pop the element. No need to check for empty stack(its already handled as stated in the question).\\n                stack.pop();\\n            }\\n            else if(ops[i].equals(\"+\")) {       //The tricky part in my solution. if \"+\" is encountered in the ops array we pop out two elements add their sum and then again push the popped items one by one with thier sum.(Again no need to handle the empty case of stack already stated in the question).\\n                int sum = 0;\\n                int s1 = stack.pop();\\n                int s2 = stack.pop();\\n                sum = s1+s2;\\n                stack.push(s2);\\n                stack.push(s1);\\n                stack.push(sum);\\n            }\\n            else {\\n                stack.push(Integer.parseInt(ops[i]));                 // if the ith element is digit simply push it in the stack.\\n            }\\n        }\\n        int sumOfStack = 0;\\n        while(!stack.isEmpty()) {\\n            sumOfStack+=stack.pop();                                //Finally pop all the items and return their sum\\n        }\\n        return sumOfStack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710195,
                "title": "rust-cheapest-best",
                "content": "```\\nimpl Solution {\\n    pub fn cal_points(ops: Vec<String>) -> i32 {\\n        ops.iter()\\n            .fold(vec![], |mut acc, cur| {\\n                match cur.as_str() {\\n                    \"+\" => acc.push(acc[acc.len() - 1] + acc[acc.len() - 2]),\\n                    \"D\" => acc.push(acc[acc.len() - 1] * 2),\\n                    \"C\" => {\\n                        acc.pop();\\n                    }\\n                    x => acc.push(str::parse::<i32>(x).unwrap()),\\n                }\\n                acc\\n            })\\n            .iter()\\n            .sum()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn cal_points(ops: Vec<String>) -> i32 {\\n        ops.iter()\\n            .fold(vec![], |mut acc, cur| {\\n                match cur.as_str() {\\n                    \"+\" => acc.push(acc[acc.len() - 1] + acc[acc.len() - 2]),\\n                    \"D\" => acc.push(acc[acc.len() - 1] * 2),\\n                    \"C\" => {\\n                        acc.pop();\\n                    }\\n                    x => acc.push(str::parse::<i32>(x).unwrap()),\\n                }\\n                acc\\n            })\\n            .iter()\\n            .sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683537,
                "title": "java-stack-one-pass-o-n-simple-and-fast",
                "content": "Java stack solution with only one pass. I have simply maintained a variable (**total**) to prevent second pass.\\n```\\npublic int calPoints(String[] ops) {\\n\\tStack<Integer> s = new Stack<>();\\n\\tint total = 0, temp;\\n\\tfor(String op : ops) {           //  for each loop for string array\\n\\t\\tif(op.equals(\"C\")) {\\n\\t\\t\\ttotal -= s.pop();\\n\\t\\t}\\n\\t\\telse if(op.equals(\"D\")) {\\n\\t\\t\\ttemp = 2*s.peek();\\n\\t\\t\\ts.push(temp);\\n\\t\\t\\ttotal += temp;\\n\\t\\t}\\n\\t\\telse if(op.equals(\"+\")) {\\n\\t\\t\\ttemp = s.pop();\\n\\t\\t\\tint sum = temp + s.peek();\\n\\t\\t\\ts.push(temp);\\n\\t\\t\\ts.push(sum);\\n\\t\\t\\ttotal += sum;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\ttemp = Integer.parseInt(op);\\n\\t\\t\\ts.push(temp);\\n\\t\\t\\ttotal += temp;\\n\\t\\t}\\n\\t}\\n\\treturn total;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int calPoints(String[] ops) {\\n\\tStack<Integer> s = new Stack<>();\\n\\tint total = 0, temp;\\n\\tfor(String op : ops) {           //  for each loop for string array\\n\\t\\tif(op.equals(\"C\")) {\\n\\t\\t\\ttotal -= s.pop();\\n\\t\\t}\\n\\t\\telse if(op.equals(\"D\")) {\\n\\t\\t\\ttemp = 2*s.peek();\\n\\t\\t\\ts.push(temp);\\n\\t\\t\\ttotal += temp;\\n\\t\\t}\\n\\t\\telse if(op.equals(\"+\")) {\\n\\t\\t\\ttemp = s.pop();\\n\\t\\t\\tint sum = temp + s.peek();\\n\\t\\t\\ts.push(temp);\\n\\t\\t\\ts.push(sum);\\n\\t\\t\\ttotal += sum;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\ttemp = Integer.parseInt(op);\\n\\t\\t\\ts.push(temp);\\n\\t\\t\\ttotal += temp;\\n\\t\\t}\\n\\t}\\n\\treturn total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831002,
                "title": "simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& o) {\\n        stack<int> s;\\n        for(int i = 0; i < o.size();i++){\\n            if(s.empty()) s.push(stoi(o[i]));\\n            else{\\n                if(o[i] == \"+\"){\\n                    int x = s.top();\\n                    s.pop();\\n                    int y = s.top();\\n                    s.push(x);\\n                    s.push(x+y);\\n                }\\n                else if(o[i] == \"C\"){\\n                    s.pop();\\n                }\\n                else if(o[i] == \"D\"){\\n                    s.push(2*s.top());\\n                }\\n                else{\\n                    s.push(stoi(o[i]));\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        while(!s.empty()){\\n            sum += s.top();\\n            s.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& o) {\\n        stack<int> s;\\n        for(int i = 0; i < o.size();i++){\\n            if(s.empty()) s.push(stoi(o[i]));\\n            else{\\n                if(o[i] == \"+\"){\\n                    int x = s.top();\\n                    s.pop();\\n                    int y = s.top();\\n                    s.push(x);\\n                    s.push(x+y);\\n                }\\n                else if(o[i] == \"C\"){\\n                    s.pop();\\n                }\\n                else if(o[i] == \"D\"){\\n                    s.push(2*s.top());\\n                }\\n                else{\\n                    s.push(stoi(o[i]));\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        while(!s.empty()){\\n            sum += s.top();\\n            s.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776235,
                "title": "easy-java-solution-with-stack",
                "content": "# Approach1: Use Stack\\n# Approach2: Use Dequeue\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            if(operations[i].equals(\"C\")){\\n                stack.pop();\\n            }else if(operations[i].equals(\"D\")){\\n                stack.push(stack.peek() * 2);\\n            }else if(operations[i].equals(\"+\") && stack.size()>=2){\\n                int value1 = stack.pop();\\n                int value2 = stack.pop();\\n                int value = value1+ value2;\\n                //push value2 back to the stack frist\\n                stack.push(value2);\\n                stack.push(value1);\\n                stack.push(value);\\n            }else {\\n                stack.push(Integer.parseInt(operations[i]));\\n            }\\n        }\\n        \\n        System.out.println(\"Stack\" + stack);\\n\\n        int sum =0;\\n        while (!stack.isEmpty()){\\n            sum += stack.pop();\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            if(operations[i].equals(\"C\")){\\n                stack.pop();\\n            }else if(operations[i].equals(\"D\")){\\n                stack.push(stack.peek() * 2);\\n            }else if(operations[i].equals(\"+\") && stack.size()>=2){\\n                int value1 = stack.pop();\\n                int value2 = stack.pop();\\n                int value = value1+ value2;\\n                //push value2 back to the stack frist\\n                stack.push(value2);\\n                stack.push(value1);\\n                stack.push(value);\\n            }else {\\n                stack.push(Integer.parseInt(operations[i]));\\n            }\\n        }\\n        \\n        System.out.println(\"Stack\" + stack);\\n\\n        int sum =0;\\n        while (!stack.isEmpty()){\\n            sum += stack.pop();\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599589,
                "title": "easy-solution-1ms-100-beats-fully-explained-java",
                "content": "# Approach\\n1. Initialize variables: `sum` to store the sum of scores, `k` as a pointer/index for the record array, and create an array `record` to store the scores.\\n\\n2. Iterate through each operation in the `operations` array using an enhanced for loop.\\n\\n3. For each operation:\\n   - If the operation is \"+\", calculate the current score as the sum of the previous two scores in the record. Store the value in the `record` array at index `k` and increment `k` by 1.\\n   - If the operation is \"D\", calculate the current score as double the previous score in the record. Store the value in the `record` array at index `k` and increment `k` by 1.\\n   - If the operation is \"C\", invalidate the previous score by setting it to 0 in the `record` array. Decrement `k` by 1 to move the pointer/index back to the previous score.\\n   - If the operation is a number, parse it as an integer and store it in the `record` array at index `k`. Increment `k` by 1.\\n\\n4. After processing all the operations, calculate the sum of scores by iterating through the `record` array using a regular for loop and adding each score to the `sum` variable.\\n\\n5. Return the final sum as the result.\\n\\nThe solution uses a switch-case statement to handle different types of operations efficiently. It updates the `record` array and maintains the pointer/index `k` to keep track of the latest position in the array. By the end of the loop, the `record` array contains the scores, and the sum is calculated, which is then returned as the final result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        int sum = 0, k = 0;\\n        int[] record = new int[operations.length];\\n        for(String s : operations)\\n            switch(s){\\n                case \"+\" -> {\\n                    record[k] = record[k - 1] + record[k-2];\\n                    k++;\\n                } \\n                case \"D\" -> {\\n                    record[k] = record[k - 1] * 2;\\n                    k++;\\n                }\\n                case \"C\" -> record[--k] = 0;\\n                default -> {\\n                    record[k] = Integer.parseInt(s);\\n                    k++;\\n                }\\n            }\\n\\n        for(int num : record)\\n            sum += num;\\n\\n        return sum;      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        int sum = 0, k = 0;\\n        int[] record = new int[operations.length];\\n        for(String s : operations)\\n            switch(s){\\n                case \"+\" -> {\\n                    record[k] = record[k - 1] + record[k-2];\\n                    k++;\\n                } \\n                case \"D\" -> {\\n                    record[k] = record[k - 1] * 2;\\n                    k++;\\n                }\\n                case \"C\" -> record[--k] = 0;\\n                default -> {\\n                    record[k] = Integer.parseInt(s);\\n                    k++;\\n                }\\n            }\\n\\n        for(int num : record)\\n            sum += num;\\n\\n        return sum;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430962,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>&o)\\n    {\\n        stack<int>s;\\n        for(int i=0;i<o.size();i++)\\n        {\\n            if(o[i]==\"C\")\\n            s.pop();\\n            else if(o[i]==\"D\")\\n            s.push(s.top()*2);\\n            else if(o[i]==\"+\")\\n            {\\n                int e1=s.top();\\n                s.pop();\\n                int e2=s.top();\\n                s.push(e1);\\n                s.push(e1+e2);\\n            }\\n            else\\n            s.push(stoi(o[i]));\\n        }\\n        int sum=0;\\n        while(!s.empty())\\n        {\\n        sum+=s.top();\\n        s.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack = []\\n\\n        for c in operations:\\n            if c == \"C\":\\n                stack.pop()\\n            elif c == \"D\":\\n                stack.append(stack[-1] * 2)\\n            elif c == \"+\":\\n                stack.append(stack[-1] + stack[-2])\\n            else:\\n                stack.append(int(c))\\n        return sum(stack)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n    int sum=0;\\n    int[] arr = new int[operations.length];\\n    int count=0;\\n\\n    for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n            arr[--count]=0;\\n        }\\n        else if(operations[i].equals(\"D\")){\\n            arr[count] = 2 * arr[count-1];\\n            count++;\\n        }\\n        else if(operations[i].equals(\"+\")){\\n            arr[count]= arr[count-1] + arr[count-2];\\n            count++;\\n        } else {\\n            arr[count] = Integer.parseInt(operations[i]);\\n            count++;\\n        }   \\n    }\\n    for(int j=0;j<arr.length;j++){\\n        sum += arr[j];\\n    }\\n    return sum;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>&o)\\n    {\\n        stack<int>s;\\n        for(int i=0;i<o.size();i++)\\n        {\\n            if(o[i]==\"C\")\\n            s.pop();\\n            else if(o[i]==\"D\")\\n            s.push(s.top()*2);\\n            else if(o[i]==\"+\")\\n            {\\n                int e1=s.top();\\n                s.pop();\\n                int e2=s.top();\\n                s.push(e1);\\n                s.push(e1+e2);\\n            }\\n            else\\n            s.push(stoi(o[i]));\\n        }\\n        int sum=0;\\n        while(!s.empty())\\n        {\\n        sum+=s.top();\\n        s.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack = []\\n\\n        for c in operations:\\n            if c == \"C\":\\n                stack.pop()\\n            elif c == \"D\":\\n                stack.append(stack[-1] * 2)\\n            elif c == \"+\":\\n                stack.append(stack[-1] + stack[-2])\\n            else:\\n                stack.append(int(c))\\n        return sum(stack)\\n```\n```Java []\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n    int sum=0;\\n    int[] arr = new int[operations.length];\\n    int count=0;\\n\\n    for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n            arr[--count]=0;\\n        }\\n        else if(operations[i].equals(\"D\")){\\n            arr[count] = 2 * arr[count-1];\\n            count++;\\n        }\\n        else if(operations[i].equals(\"+\")){\\n            arr[count]= arr[count-1] + arr[count-2];\\n            count++;\\n        } else {\\n            arr[count] = Integer.parseInt(operations[i]);\\n            count++;\\n        }   \\n    }\\n    for(int j=0;j<arr.length;j++){\\n        sum += arr[j];\\n    }\\n    return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385527,
                "title": "easy-to-understand-solution-swift",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func calPoints(_ operations: [String]) -> Int {\\n        var total = [Int]()\\n    \\n        for operation in operations {\\n            switch operation {\\n            case \"+\":\\n                total.append(total.suffix(2).reduce(0, +))\\n            case \"D\":\\n                total.append((total.last ?? 0) * 2)\\n            case \"C\":\\n                total = total.dropLast()\\n            default:\\n                total.append(Int(operation) ?? 0)\\n            }\\n        }\\n        return total.reduce(0, +)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func calPoints(_ operations: [String]) -> Int {\\n        var total = [Int]()\\n    \\n        for operation in operations {\\n            switch operation {\\n            case \"+\":\\n                total.append(total.suffix(2).reduce(0, +))\\n            case \"D\":\\n                total.append((total.last ?? 0) * 2)\\n            case \"C\":\\n                total = total.dropLast()\\n            default:\\n                total.append(Int(operation) ?? 0)\\n            }\\n        }\\n        return total.reduce(0, +)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318893,
                "title": "682-time-95-68-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe initialize an empty stack to keep track of the scores.\\n\\nWe iterate through each operation in the input list.\\n\\nIf the operation is \"C\", we remove the last score from the stack using stack.pop().\\n\\nIf the operation is \"D\", we double the last score and append it to the stack using stack.append(stack[-1] * 2).\\n\\nIf the operation is \"+\", we add the last two scores and append the sum to the stack using stack.append(stack[-1] + stack[-2]).\\n\\nIf the operation is an integer, we convert it to an integer using int(op) and append it to the stack using stack.append(int(op)).\\n\\nFinally, we return the sum of all the scores in the stack using sum(stack).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        stack = []\\n        for op in ops:\\n            if op == \"C\":\\n                stack.pop()\\n            elif op == \"D\":\\n                stack.append(stack[-1] * 2)\\n            elif op == \"+\":\\n                stack.append(stack[-1] + stack[-2])\\n            else:\\n                stack.append(int(op))\\n        return sum(stack)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Stack",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        stack = []\\n        for op in ops:\\n            if op == \"C\":\\n                stack.pop()\\n            elif op == \"D\":\\n                stack.append(stack[-1] * 2)\\n            elif op == \"+\":\\n                stack.append(stack[-1] + stack[-2])\\n            else:\\n                stack.append(int(op))\\n        return sum(stack)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244894,
                "title": "baseball-game-cpp-simple-approach",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& op) {\\n        vector<int> v;\\n        for(int i=0;i<op.size();i++){\\n            int n=v.size();\\n            if(op[i] == \"+\") v.push_back(v[n-1]+v[n-2]);\\n            else if(op[i] == \"C\") v.pop_back();\\n            else if(op[i] == \"D\") v.push_back(2*v[n-1]);\\n            else v.push_back(stoi(op[i]));\\n        }\\n        int sum=0;\\n        for(auto s:v) sum+=s;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& op) {\\n        vector<int> v;\\n        for(int i=0;i<op.size();i++){\\n            int n=v.size();\\n            if(op[i] == \"+\") v.push_back(v[n-1]+v[n-2]);\\n            else if(op[i] == \"C\") v.pop_back();\\n            else if(op[i] == \"D\") v.push_back(2*v[n-1]);\\n            else v.push_back(stoi(op[i]));\\n        }\\n        int sum=0;\\n        for(auto s:v) sum+=s;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181934,
                "title": "easy-python-solution-using-stack",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        lst=[]\\n        for i in operations:\\n            if i==\"C\":\\n                lst.pop()\\n            elif i==\"D\":\\n                lst.append(lst[-1]*2)\\n            elif i==\"+\":\\n                sm=lst[-2]+lst[-1]\\n                lst.append(sm)\\n            else:\\n                lst.append(int(i))\\n        print(lst)\\n        return sum(lst)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        lst=[]\\n        for i in operations:\\n            if i==\"C\":\\n                lst.pop()\\n            elif i==\"D\":\\n                lst.append(lst[-1]*2)\\n            elif i==\"+\":\\n                sm=lst[-2]+lst[-1]\\n                lst.append(sm)\\n            else:\\n                lst.append(int(i))\\n        print(lst)\\n        return sum(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171519,
                "title": "c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n\\n    vector<int> score;\\n    for (int i = 0; i < operations.size(); i++)\\n    {\\n\\n        if (operations[i] == \"C\")\\n        {\\n            score.pop_back();\\n        }\\n        else if (operations[i] == \"D\")\\n        {\\n            score.push_back(2 * (score[score.size() - 1]));\\n        }\\n        else if (operations[i] == \"+\")\\n        {\\n            score.push_back(score[score.size() - 1] + score[score.size() - 2]);\\n        }\\n        else\\n        {\\n            score.push_back(stoi(operations[i]));\\n        }\\n    }\\n\\n    int ans = 0;\\n    for (int i = 0; i < score.size(); i++)\\n    {\\n        ans += score[i];\\n    }\\n    return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n\\n    vector<int> score;\\n    for (int i = 0; i < operations.size(); i++)\\n    {\\n\\n        if (operations[i] == \"C\")\\n        {\\n            score.pop_back();\\n        }\\n        else if (operations[i] == \"D\")\\n        {\\n            score.push_back(2 * (score[score.size() - 1]));\\n        }\\n        else if (operations[i] == \"+\")\\n        {\\n            score.push_back(score[score.size() - 1] + score[score.size() - 2]);\\n        }\\n        else\\n        {\\n            score.push_back(stoi(operations[i]));\\n        }\\n    }\\n\\n    int ans = 0;\\n    for (int i = 0; i < score.size(); i++)\\n    {\\n        ans += score[i];\\n    }\\n    return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792878,
                "title": "c-stack-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n    stack<int> s;\\n    int score=0;\\n    for(int i=0;i<operations.size();i++)\\n    {\\n        \\n        if(operations[i]==\"C\")\\n        {\\n            s.pop();\\n        }\\n        else if(operations[i]==\"D\")\\n        {\\n            int num=s.top()*2;\\n            s.push(num);\\n        }\\n        else if(operations[i]==\"+\")\\n        {\\n            int xzxczxczxcsc   =s.top();\\n            s.pop();\\n            int slast=s.top();\\n            s.push(last);\\n            s.push(last+slast);\\n        }\\n        else\\n        {\\n            int value=stoi(operations[i]);\\n            s.push(value);\\n        }\\n    }\\n    while(!s.empty())\\n    {\\n        score+= s.top();\\n        s.pop();\\n    }\\n    return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n    stack<int> s;\\n    int score=0;\\n    for(int i=0;i<operations.size();i++)\\n    {\\n        \\n        if(operations[i]==\"C\")\\n        {\\n            s.pop();\\n        }\\n        else if(operations[i]==\"D\")\\n        {\\n            int num=s.top()*2;\\n            s.push(num);\\n        }\\n        else if(operations[i]==\"+\")\\n        {\\n            int xzxczxczxcsc   =s.top();\\n            s.pop();\\n            int slast=s.top();\\n            s.push(last);\\n            s.push(last+slast);\\n        }\\n        else\\n        {\\n            int value=stoi(operations[i]);\\n            s.push(value);\\n        }\\n    }\\n    while(!s.empty())\\n    {\\n        score+= s.top();\\n        s.pop();\\n    }\\n    return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602678,
                "title": "python-o-n-stack",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n  def calPoints(self, operations):\\n    stack= deque() \\n    for op in operations:\\n      if op==\"C\":\\n        stack.pop()\\n      elif op==\"D\":\\n         stack.append(2*stack[-1])\\n      elif op==\"+\":\\n         stack.append(stack[-1]+stack[-2])\\n      else:\\n        stack.append(int(op))\\n    return sum(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n  def calPoints(self, operations):\\n    stack= deque() \\n    for op in operations:\\n      if op==\"C\":\\n        stack.pop()\\n      elif op==\"D\":\\n         stack.append(2*stack[-1])\\n      elif op==\"+\":\\n         stack.append(stack[-1]+stack[-2])\\n      else:\\n        stack.append(int(op))\\n    return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583570,
                "title": "c-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        \\n        vector<int> ans;\\n        int n = operations.size();\\n        \\n        for(int i=0;i<operations.size();i++){\\n            if(operations[i] == \"C\"){\\n                ans.pop_back();\\n            }else if(operations[i] == \"D\"){\\n                ans.emplace_back(2*ans[ans.size()-1]);\\n            }else if(operations[i] == \"+\"){\\n                ans.emplace_back(ans[ans.size()-1] + ans[ans.size()-2]);\\n            }else{\\n                int n = stoi(operations[i]);\\n                ans.emplace_back(n);\\n            }\\n        }\\n        \\n        int sum = 0;\\n        \\n        for(auto it : ans){\\n            sum+=it;\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        \\n        vector<int> ans;\\n        int n = operations.size();\\n        \\n        for(int i=0;i<operations.size();i++){\\n            if(operations[i] == \"C\"){\\n                ans.pop_back();\\n            }else if(operations[i] == \"D\"){\\n                ans.emplace_back(2*ans[ans.size()-1]);\\n            }else if(operations[i] == \"+\"){\\n                ans.emplace_back(ans[ans.size()-1] + ans[ans.size()-2]);\\n            }else{\\n                int n = stoi(operations[i]);\\n                ans.emplace_back(n);\\n            }\\n        }\\n        \\n        int sum = 0;\\n        \\n        for(auto it : ans){\\n            sum+=it;\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934121,
                "title": "javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst calPoints = ops => {\\n    let record = [];\\n    let sum = 0;\\n\\n    for (let i = 0; i < ops.length; i++) {\\n        let current = ops[i]\\n\\n\\n        if (Number.isInteger(parseInt(current))) {\\n            record.push(parseInt(current))\\n        } else if (current === \\'+\\') {\\n            record.push(record[record.length - 2] + record[record.length - 1])\\n        } else if (current === \\'D\\') {\\n            record.push(2 * record[record.length - 1])\\n        } else {\\n            record.pop()\\n        }\\n    }\\n\\n    record.forEach(x => sum += x)\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst calPoints = ops => {\\n    let record = [];\\n    let sum = 0;\\n\\n    for (let i = 0; i < ops.length; i++) {\\n        let current = ops[i]\\n\\n\\n        if (Number.isInteger(parseInt(current))) {\\n            record.push(parseInt(current))\\n        } else if (current === \\'+\\') {\\n            record.push(record[record.length - 2] + record[record.length - 1])\\n        } else if (current === \\'D\\') {\\n            record.push(2 * record[record.length - 1])\\n        } else {\\n            record.pop()\\n        }\\n    }\\n\\n    record.forEach(x => sum += x)\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933684,
                "title": "java-o-n-brute-force-approach",
                "content": "```\\nclass Solution {\\n    public static int calPoints(String[] ops) {\\n        int i = 0;\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        for (int j = 0; j < ops.length; j++) {\\n            char ch= ops[j].charAt(0);\\n            if(ops[j].charAt(0)!=\\'C\\' && ops[j].charAt(0)!=\\'D\\' && ops[j].charAt(0)!=\\'+\\') arr.add(Integer.parseInt(ops[j]));\\n            if(ops[j].charAt(0)==\\'C\\') arr.remove(arr.size()-1);\\n            else if(ops[j].charAt(0)==\\'D\\') arr.add(2*arr.get(arr.size()-1));\\n            else if(ops[j].charAt(0)==\\'+\\') arr.add((arr.get((arr.size()-1))+arr.get((arr.size()-2))));\\n        }\\n        int sum=0;\\n        for(int i1:arr) sum+=i1;\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int calPoints(String[] ops) {\\n        int i = 0;\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        for (int j = 0; j < ops.length; j++) {\\n            char ch= ops[j].charAt(0);\\n            if(ops[j].charAt(0)!=\\'C\\' && ops[j].charAt(0)!=\\'D\\' && ops[j].charAt(0)!=\\'+\\') arr.add(Integer.parseInt(ops[j]));\\n            if(ops[j].charAt(0)==\\'C\\') arr.remove(arr.size()-1);\\n            else if(ops[j].charAt(0)==\\'D\\') arr.add(2*arr.get(arr.size()-1));\\n            else if(ops[j].charAt(0)==\\'+\\') arr.add((arr.get((arr.size()-1))+arr.get((arr.size()-2))));\\n        }\\n        int sum=0;\\n        for(int i1:arr) sum+=i1;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933466,
                "title": "nice-code-written-in-c-must-view-once-and-upvote-if-you-like-it",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> res;\\n        for(auto x:ops){\\n            if(x==\"C\"){\\n                res.pop_back();\\n            }else if(x==\"+\"){\\n                res.push_back(res.rbegin()[0]+res.rbegin()[1]);\\n            }else if(x==\"D\"){\\n                res.push_back(res.back()*2);\\n            }else{\\n                res.push_back(stoi(x));\\n            }\\n        }\\n        int ans=accumulate(res.begin(),res.end(),0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> res;\\n        for(auto x:ops){\\n            if(x==\"C\"){\\n                res.pop_back();\\n            }else if(x==\"+\"){\\n                res.push_back(res.rbegin()[0]+res.rbegin()[1]);\\n            }else if(x==\"D\"){\\n                res.push_back(res.back()*2);\\n            }else{\\n                res.push_back(stoi(x));\\n            }\\n        }\\n        int ans=accumulate(res.begin(),res.end(),0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932354,
                "title": "simple-python-solution-o-1-space-complexity-and-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        i = j = 0\\n        while j < len(ops):\\n            if ops[j] == \"C\":\\n                i -= 2\\n            elif ops[j] == \"D\":\\n                ops[i] = int(ops[i-1])*2\\n            elif ops[j] == \"+\":\\n                ops[i] = int(ops[i-1]) + int(ops[i-2])\\n            else:\\n                ops[i] = int(ops[j])\\n            i += 1\\n            j += 1\\n        return sum(ops[:i])\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        i = j = 0\\n        while j < len(ops):\\n            if ops[j] == \"C\":\\n                i -= 2\\n            elif ops[j] == \"D\":\\n                ops[i] = int(ops[i-1])*2\\n            elif ops[j] == \"+\":\\n                ops[i] = int(ops[i-1]) + int(ops[i-2])\\n            else:\\n                ops[i] = int(ops[j])\\n            i += 1\\n            j += 1\\n        return sum(ops[:i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931876,
                "title": "simple-if-else-solution-c",
                "content": "```\\n    int calPoints(vector<string>& ops) {\\n        string ch=\"\";\\n        vector<int> rec;\\n        for(int i=0;i < ops.size();i++)\\n        {\\n            ch = ops[i];\\n            int n = rec.size();\\n            if(ch==\"C\")\\n            {\\n                rec.pop_back();\\n            }\\n            else if(ch==\"D\")\\n            {\\n                int ele = rec[n-1]*2;\\n                rec.push_back(ele);\\n            }\\n            else if(ch==\"+\")\\n            {\\n                int ele = rec[n-1] + rec[n-2];\\n                rec.push_back(ele);\\n            }\\n            else\\n            {\\n                int num = stoi(ch);\\n                rec.push_back(num);\\n            }\\n        }\\n        int sum=0;\\n        for(auto i : rec)\\n        {\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n    int calPoints(vector<string>& ops) {\\n        string ch=\"\";\\n        vector<int> rec;\\n        for(int i=0;i < ops.size();i++)\\n        {\\n            ch = ops[i];\\n            int n = rec.size();\\n            if(ch==\"C\")\\n            {\\n                rec.pop_back();\\n            }\\n            else if(ch==\"D\")\\n            {\\n                int ele = rec[n-1]*2;\\n                rec.push_back(ele);\\n            }\\n            else if(ch==\"+\")\\n            {\\n                int ele = rec[n-1] + rec[n-2];\\n                rec.push_back(ele);\\n            }\\n            else\\n            {\\n                int num = stoi(ch);\\n                rec.push_back(num);\\n            }\\n        }\\n        int sum=0;\\n        for(auto i : rec)\\n        {\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931818,
                "title": "baseball-game-c-correct-the-solution",
                "content": "help me finding bug in this solution\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int>scores;\\n        int idx = 0;\\n        for (string op : ops){\\n            if (op==\"+\") {\\n                scores[idx] = scores[idx - 1] + scores[idx - 2];\\n                idx++;\\n            } else if (op==\"D\") {\\n                scores[idx] = 2 * scores[idx - 1];\\n                idx++;\\n            } else if (op==\"C\") {\\n                idx--;\\n                scores[idx] = 0;\\n            } else {\\n                scores.push_back(stoi(op));\\n                idx++;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int score : scores) {\\n            ans += score;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int>scores;\\n        int idx = 0;\\n        for (string op : ops){\\n            if (op==\"+\") {\\n                scores[idx] = scores[idx - 1] + scores[idx - 2];\\n                idx++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1931681,
                "title": "python-90-faster",
                "content": "```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        res = []\\n        for i in ops:\\n            if i == \\'C\\':\\n                res.pop()\\n            elif i == \\'D\\':\\n                res.append(res[-1] * 2)\\n            elif i == \"+\":\\n                res.append(res[len(res)-2] + res[-1])             \\n            else:\\n                res.append(int(i))\\n        return sum(res)\\n\\t\\t\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        res = []\\n        for i in ops:\\n            if i == \\'C\\':\\n                res.pop()\\n            elif i == \\'D\\':\\n                res.append(res[-1] * 2)\\n            elif i == \"+\":\\n                res.append(res[len(res)-2] + res[-1])             \\n            else:\\n                res.append(int(i))\\n        return sum(res)\\n\\t\\t\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1930814,
                "title": "python-stack-clean-solution",
                "content": "```\\nfrom collections import deque\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        stk = deque()\\n\\n        push, pop = stk.append, stk.pop\\n\\n        for e in ops:\\n            if e == \\'+\\':\\n                push(stk[-1] + stk[-2])\\n            elif e == \\'D\\':\\n                push(2 * stk[-1])\\n            elif e == \\'C\\':\\n                pop()\\n            else:\\n                push(int(e))\\n\\n        return sum(stk)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nfrom collections import deque\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        stk = deque()\\n\\n        push, pop = stk.append, stk.pop\\n\\n        for e in ops:\\n            if e == \\'+\\':\\n                push(stk[-1] + stk[-2])\\n            elif e == \\'D\\':\\n                push(2 * stk[-1])\\n            elif e == \\'C\\':\\n                pop()\\n            else:\\n                push(int(e))\\n\\n        return sum(stk)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676251,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn cal_points(ops: Vec<String>) -> i32 {\\n        let mut res = Vec::new();\\n        for s in ops.iter() {\\n            match s.as_str() {\\n                \"C\" => res.truncate(res.len() - 1),\\n                \"D\" => res.push(*res.last().unwrap() * 2),\\n                \"+\" => res.push(res.iter().rev().take(2).sum()),\\n                d => res.push(d.parse::<i32>().unwrap()),\\n            }\\n        }\\n        res.iter().sum::<i32>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn cal_points(ops: Vec<String>) -> i32 {\\n        let mut res = Vec::new();\\n        for s in ops.iter() {\\n            match s.as_str() {\\n                \"C\" => res.truncate(res.len() - 1),\\n                \"D\" => res.push(*res.last().unwrap() * 2),\\n                \"+\" => res.push(res.iter().rev().take(2).sum()),\\n                d => res.push(d.parse::<i32>().unwrap()),\\n            }\\n        }\\n        res.iter().sum::<i32>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1518868,
                "title": "javascript",
                "content": "Runtime: 76 ms, faster than 77.67% of JavaScript online submissions for Baseball Game.\\nMemory Usage: 39.6 MB, less than 58.60% of JavaScript online submissions for Baseball Game.\\n\\n```\\nvar calPoints = function(ops) {\\n  let arr = [];\\n  let total = 0;\\n\\n  for (let i = 0; i < ops.length; i++) {\\n    if (ops[i] === \\'C\\') arr.pop();\\n    else if (ops[i] === \\'D\\') arr.push(Number(2 * arr[arr.length - 1]));\\n    else if (ops[i] === \\'+\\') arr.push(Number(arr[arr.length - 1] + arr[arr.length - 2]));\\n    else arr.push(Number(ops[i]));\\n  }\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    total += arr[i];\\n  }\\n\\n  return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar calPoints = function(ops) {\\n  let arr = [];\\n  let total = 0;\\n\\n  for (let i = 0; i < ops.length; i++) {\\n    if (ops[i] === \\'C\\') arr.pop();\\n    else if (ops[i] === \\'D\\') arr.push(Number(2 * arr[arr.length - 1]));\\n    else if (ops[i] === \\'+\\') arr.push(Number(arr[arr.length - 1] + arr[arr.length - 2]));\\n    else arr.push(Number(ops[i]));\\n  }\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    total += arr[i];\\n  }\\n\\n  return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261515,
                "title": "easy-javascript-solution",
                "content": "```\\nvar calPoints = function(ops) {\\n    let stack = [];\\n    for(let i=0; i<ops.length; i++){\\n    if(ops[i] == \\'D\\'){\\n        stack.push(2 * stack.slice(-1)[0]);\\n    }else if(ops[i] === \\'C\\'){\\n         stack.pop();\\n    }else if(ops[i] === \\'+\\'){\\n        stack.push(stack.slice(-1)[0] + stack.slice(-2)[0])\\n     }else{\\n         stack.push(parseInt(ops[i]));\\n     }\\n        \\n    }\\n    return stack.reduce((a,b)=>a+b);\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar calPoints = function(ops) {\\n    let stack = [];\\n    for(let i=0; i<ops.length; i++){\\n    if(ops[i] == \\'D\\'){\\n        stack.push(2 * stack.slice(-1)[0]);\\n    }else if(ops[i] === \\'C\\'){\\n         stack.pop();\\n    }else if(ops[i] === \\'+\\'){\\n        stack.push(stack.slice(-1)[0] + stack.slice(-2)[0])\\n     }else{\\n         stack.push(parseInt(ops[i]));\\n     }\\n        \\n    }\\n    return stack.reduce((a,b)=>a+b);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1051268,
                "title": "python-3-stack-implementation-easy",
                "content": "Approach:\\n\\nWhen you encounter an integer, typecast it to ```int()``` and append to stack. Otherwise,  use ```if-else``` conditions to compute value and append the result to stack. Return ```sum(stack)```.\\n```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        stack = []\\n        for i in ops:\\n            if i not in \"+DC\":\\n                stack.append(int(i))\\n            else:\\n                if i == \"C\":\\n                    stack.pop()\\n                elif i == \"D\":\\n                    stack.append(2*stack[-1])\\n                elif i == \"+\":\\n                    stack.append((stack[-1]) + stack[-2])\\n        return sum(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```int()```\n```if-else```\n```sum(stack)```\n```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        stack = []\\n        for i in ops:\\n            if i not in \"+DC\":\\n                stack.append(int(i))\\n            else:\\n                if i == \"C\":\\n                    stack.pop()\\n                elif i == \"D\":\\n                    stack.append(2*stack[-1])\\n                elif i == \"+\":\\n                    stack.append((stack[-1]) + stack[-2])\\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044613,
                "title": "beats-90-c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n            \\n        stack <int> st;\\n            \\n        for(int i = 0; i < ops.size(); i++){\\n                \\n                if(ops[i] == \"+\"){\\n                        \\n                        int val1,val2;\\n                        \\n                        val1 = st.top();\\n                        st.pop();\\n                        val2 = st.top();\\n                        st.pop();\\n                        \\n                        st.push(val2);\\n                        st.push(val1);\\n                        st.push(val2 + val1);\\n                        \\n                }else if(ops[i] == \"D\"){\\n                        \\n                        int val = st.top();\\n                        st.push( val*2 );\\n                        \\n                }else if(ops[i] == \"C\")                        \\n                        st.pop();\\n                else \\n                        st.push(stoi(ops[i]));\\n                                        \\n        }\\n            \\n        int output = 0;  \\n            \\n        while(!st.empty()){\\n                \\n            output += st.top();\\n            st.pop();\\n                \\n        }\\n            \\n            return output;\\n    }\\n};\\n```\\n**Please upvote my solution If you like it..**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n            \\n        stack <int> st;\\n            \\n        for(int i = 0; i < ops.size(); i++){\\n                \\n                if(ops[i] == \"+\"){\\n                        \\n                        int val1,val2;\\n                        \\n                        val1 = st.top();\\n                        st.pop();\\n                        val2 = st.top();\\n                        st.pop();\\n                        \\n                        st.push(val2);\\n                        st.push(val1);\\n                        st.push(val2 + val1);\\n                        \\n                }else if(ops[i] == \"D\"){\\n                        \\n                        int val = st.top();\\n                        st.push( val*2 );\\n                        \\n                }else if(ops[i] == \"C\")                        \\n                        st.pop();\\n                else \\n                        st.push(stoi(ops[i]));\\n                                        \\n        }\\n            \\n        int output = 0;  \\n            \\n        while(!st.empty()){\\n                \\n            output += st.top();\\n            st.pop();\\n                \\n        }\\n            \\n            return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856085,
                "title": "c-basic-list-solution",
                "content": "```\\n    public int CalPoints(string[] ops) {\\n        var innings = new List<int>();\\n        foreach(var i in ops){\\n            switch (i){\\n                case \"+\":\\n                    innings.Add(innings[^1] + innings[^2]);\\n                    break;\\n                case \"D\":\\n                    innings.Add(2 * innings[^1]);\\n                    break;\\n                case \"C\":\\n                    innings.RemoveAt(innings.Count-1);\\n                    break;\\n                default:\\n                    innings.Add(int.Parse(i));\\n                    break;\\n            }\\n        }\\n        return innings.Sum();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int CalPoints(string[] ops) {\\n        var innings = new List<int>();\\n        foreach(var i in ops){\\n            switch (i){\\n                case \"+\":\\n                    innings.Add(innings[^1] + innings[^2]);\\n                    break;\\n                case \"D\":\\n                    innings.Add(2 * innings[^1]);\\n                    break;\\n                case \"C\":\\n                    innings.RemoveAt(innings.Count-1);\\n                    break;\\n                default:\\n                    innings.Add(int.Parse(i));\\n                    break;\\n            }\\n        }\\n        return innings.Sum();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 272941,
                "title": "java-1-ms-faster-than-100-00",
                "content": "Straight forward solution using arrays. \\n\\n    public int calPoints(String[] ops) {\\n        int[] score = new int[ops.length];\\n        int ind = -1, sum = 0;\\n        \\n        for(String s : ops){\\n            if(s.equals(\"C\")){\\n                sum -= score[ind];\\n                score[ind] = 0;\\n                ind--;\\n            }else if(s.equals(\"D\")){\\n                sum += score[ind]*2;\\n                ind++;\\n                score[ind] = score[ind-1]*2;                \\n            }else if(s.equals(\"+\")){\\n                ind++;\\n                score[ind] = score[ind-1] + score[ind-2];\\n                sum += score[ind];\\n            }else{\\n                ind++;\\n                score[ind] = Integer.parseInt(s);\\n                sum += score[ind];\\n            }\\n            \\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "Straight forward solution using arrays. \\n\\n    public int calPoints(String[] ops) {\\n        int[] score = new int[ops.length];\\n        int ind = -1, sum = 0;\\n        \\n        for(String s : ops){\\n            if(s.equals(\"C\")){\\n                sum -= score[ind];\\n                score[ind] = 0;\\n                ind--;\\n            }else if(s.equals(\"D\")){\\n                sum += score[ind]*2;\\n                ind++;\\n                score[ind] = score[ind-1]*2;                \\n            }else if(s.equals(\"+\")){\\n                ind++;\\n                score[ind] = score[ind-1] + score[ind-2];\\n                sum += score[ind];\\n            }else{\\n                ind++;\\n                score[ind] = Integer.parseInt(s);\\n                sum += score[ind];\\n            }\\n            \\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 254553,
                "title": "c-8ms-beats-100-of-others-uses-vector-easy-to-understand-not-smart-code",
                "content": "```\\n    int calPoints(vector<string>& ops) {\\n        vector<int> rounds;\\n        int lastIndex=0;\\n        \\n        for(string str : ops){\\n            if(isdigit(str[0]) || str[0] == \\'-\\'){\\n                rounds.push_back(std::stoi(str));\\n            }\\n            else if(str[0] == \\'+\\'){\\n                rounds.push_back(rounds[lastIndex]+rounds[lastIndex-1]);\\n            }\\n            else if(str[0] == \\'D\\'){\\n                rounds.push_back(2*rounds[lastIndex]);\\n            }\\n            else if(str[0] == \\'C\\'){\\n                rounds.pop_back();\\n            }\\n            \\n            lastIndex = rounds.size()-1;\\n        }\\n        \\n        return accumulate(rounds.begin(), rounds.end(),0); // calculates sum of vector\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int calPoints(vector<string>& ops) {\\n        vector<int> rounds;\\n        int lastIndex=0;\\n        \\n        for(string str : ops){\\n            if(isdigit(str[0]) || str[0] == \\'-\\'){\\n                rounds.push_back(std::stoi(str));\\n            }\\n            else if(str[0] == \\'+\\'){\\n                rounds.push_back(rounds[lastIndex]+rounds[lastIndex-1]);\\n            }\\n            else if(str[0] == \\'D\\'){\\n                rounds.push_back(2*rounds[lastIndex]);\\n            }\\n            else if(str[0] == \\'C\\'){\\n                rounds.pop_back();\\n            }\\n            \\n            lastIndex = rounds.size()-1;\\n        }\\n        \\n        return accumulate(rounds.begin(), rounds.end(),0); // calculates sum of vector\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 107892,
                "title": "c-solution-with-one-stack",
                "content": "Straightforward C++ solution using one stack. O(n) time and O(n) space.\\n\\n```\\n    int calPoints(vector<string>& ops) {\\n        if (ops.empty()) return 0;\\n        \\n        stack<int> pts;\\n        int ans = 0;\\n        \\n        for (int i=0; i<ops.size(); i++) {\\n            if (ops[i] == \"C\") {\\n                ans -= pts.top();\\n                pts.pop();\\n            } else if (ops[i] == \"D\") {\\n                pts.push(pts.top()*2);\\n                ans += pts.top();\\n            } else if (ops[i] == \"+\") {\\n                int a = pts.top();\\n                pts.pop();\\n                int b = pts.top();\\n                pts.push(a);\\n                \\n                ans += (a+b);\\n                pts.push(a+b);\\n            } else {\\n                int n = stoi(ops[i]);\\n                ans += n;\\n                pts.push(n);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n    int calPoints(vector<string>& ops) {\\n        if (ops.empty()) return 0;\\n        \\n        stack<int> pts;\\n        int ans = 0;\\n        \\n        for (int i=0; i<ops.size(); i++) {\\n            if (ops[i] == \"C\") {\\n                ans -= pts.top();\\n                pts.pop();\\n            } else if (ops[i] == \"D\") {\\n                pts.push(pts.top()*2);\\n                ans += pts.top();\\n            } else if (ops[i] == \"+\") {\\n                int a = pts.top();\\n                pts.pop();\\n                int b = pts.top();\\n                pts.push(a);\\n                \\n                ans += (a+b);\\n                pts.push(a+b);\\n            } else {\\n                int n = stoi(ops[i]);\\n                ans += n;\\n                pts.push(n);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107926,
                "title": "my-accepted-code-in-java-7ms",
                "content": "My idea is that just keeping track of the current valid round's point in an array and use it to have a next valid round's point.\\n\\n```\\n  public int calPoints(String[] ops) {\\n    int sum = 0;\\n    int valid[] = new int[ops.length];\\n    int v = -1;\\n    for (int i = 0; i < ops.length; i++) {\\n      if (ops[i].equals(\"C\")) {\\n        sum -= valid[v];\\n        v--;\\n      } else if (ops[i].equals(\"D\")) {\\n        int d = (valid[v] + valid[v]);\\n        v++;\\n        valid[v] = d;\\n        sum += d;\\n      } else if (ops[i].equals(\"+\")) {\\n        int p = (valid[v] + valid[v - 1]);\\n        v++;\\n        valid[v] = p;\\n        sum += p;\\n      } else {\\n        int val = Integer.parseInt(ops[i]);\\n        v++;\\n        valid[v] = val;\\n        sum += val;\\n      }\\n    }\\n\\n    return sum;\\n  }\\n````",
                "solutionTags": [],
                "code": "```\\n  public int calPoints(String[] ops) {\\n    int sum = 0;\\n    int valid[] = new int[ops.length];\\n    int v = -1;\\n    for (int i = 0; i < ops.length; i++) {\\n      if (ops[i].equals(\"C\")) {\\n        sum -= valid[v];\\n        v--;\\n      } else if (ops[i].equals(\"D\")) {\\n        int d = (valid[v] + valid[v]);\\n        v++;\\n        valid[v] = d;\\n        sum += d;\\n      } else if (ops[i].equals(\"+\")) {\\n        int p = (valid[v] + valid[v - 1]);\\n        v++;\\n        valid[v] = p;\\n        sum += p;\\n      } else {\\n        int val = Integer.parseInt(ops[i]);\\n        v++;\\n        valid[v] = val;\\n        sum += val;\\n      }\\n    }\\n\\n    return sum;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064345,
                "title": "c-beginner-friendly-solution-using-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    int calPoints(vector<string>& operations) {\\n      vector<int>arr(1001,0);\\n        int top=-1;\\n        int i=0;\\n        while(i<operations.size()){\\n\\n            if(operations[i]==\"+\"){\\n                        int a=arr[top];\\n                        top--;\\n                        int result=a+arr[top];\\n                        top++;\\n                        arr[top]=a;\\n                        top++;\\n                        arr[top]=result;\\n                        i++;\\n                    }\\n                    else if(operations[i]==\"D\"){\\n                        int d=2*arr[top];\\n                        top++;\\n                        arr[top]=d;\\n                        i++;\\n                    }\\n                    else if(operations[i]==\"C\"){\\n                        arr[top]=0;\\n                        top--;\\n                        i++;\\n                    }\\n                    else{\\n                        top++;\\n                        arr[top]=stoi(operations[i]);\\n                        i++;\\n                    }\\n        }\\n\\n        int sum=0;\\n        int j=0;\\n        while(j<arr.size()){\\n            sum=sum+arr[j];\\n            j++;\\n        }\\n     \\n     return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    int calPoints(vector<string>& operations) {\\n      vector<int>arr(1001,0);\\n        int top=-1;\\n        int i=0;\\n        while(i<operations.size()){\\n\\n            if(operations[i]==\"+\"){\\n                        int a=arr[top];\\n                        top--;\\n                        int result=a+arr[top];\\n                        top++;\\n                        arr[top]=a;\\n                        top++;\\n                        arr[top]=result;\\n                        i++;\\n                    }\\n                    else if(operations[i]==\"D\"){\\n                        int d=2*arr[top];\\n                        top++;\\n                        arr[top]=d;\\n                        i++;\\n                    }\\n                    else if(operations[i]==\"C\"){\\n                        arr[top]=0;\\n                        top--;\\n                        i++;\\n                    }\\n                    else{\\n                        top++;\\n                        arr[top]=stoi(operations[i]);\\n                        i++;\\n                    }\\n        }\\n\\n        int sum=0;\\n        int j=0;\\n        while(j<arr.size()){\\n            sum=sum+arr[j];\\n            j++;\\n        }\\n     \\n     return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005693,
                "title": "easy-c-solution-using-stack-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& op) {\\n        stack<int>s;//create a stack\\n        int sum1=0;\\n\\n        for(int i=0; i<op.size(); i++)\\n        {\\n            int temp=0,sum=0;\\n            if(op[i]==\"+\" && !s.empty())\\n            {\\n                // we need to make a temporary variable in order to access the value before top\\n                // store the value of top in temp and then pop the top value so that we can get the new top value and perform sum\\n                  \\n                temp=s.top();\\n                s.pop();\\n                sum = temp + s.top();\\n                s.push(temp);// again push the temp variable in the stack\\n                s.push(sum);// push the sum we got\\n            }\\n            else if(op[i]==\"C\" && !s.empty())// it is important to check if the stack value is not empty\\n            {\\n                // if the value is C then we simply need to pop from stack\\n                s.pop();\\n            }\\n            else if(op[i]==\"D\" && !s.empty())\\n            {\\n                s.push(2*s.top());// push the value 2 times the top value\\n            }\\n            else\\n            {\\n                s.push(stoi(op[i]));// convert string value into integer using stoi function and push into stack\\n            }\\n        }\\n\\n        while (!s.empty()) // iterate through stack till its empty and do the sum\\n        {\\n            sum1 += s.top();\\n            s.pop();\\n        }\\n    \\n\\n        return sum1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& op) {\\n        stack<int>s;//create a stack\\n        int sum1=0;\\n\\n        for(int i=0; i<op.size(); i++)\\n        {\\n            int temp=0,sum=0;\\n            if(op[i]==\"+\" && !s.empty())\\n            {\\n                // we need to make a temporary variable in order to access the value before top\\n                // store the value of top in temp and then pop the top value so that we can get the new top value and perform sum\\n                  \\n                temp=s.top();\\n                s.pop();\\n                sum = temp + s.top();\\n                s.push(temp);// again push the temp variable in the stack\\n                s.push(sum);// push the sum we got\\n            }\\n            else if(op[i]==\"C\" && !s.empty())// it is important to check if the stack value is not empty\\n            {\\n                // if the value is C then we simply need to pop from stack\\n                s.pop();\\n            }\\n            else if(op[i]==\"D\" && !s.empty())\\n            {\\n                s.push(2*s.top());// push the value 2 times the top value\\n            }\\n            else\\n            {\\n                s.push(stoi(op[i]));// convert string value into integer using stoi function and push into stack\\n            }\\n        }\\n\\n        while (!s.empty()) // iterate through stack till its empty and do the sum\\n        {\\n            sum1 += s.top();\\n            s.pop();\\n        }\\n    \\n\\n        return sum1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826227,
                "title": "easy-solution-that-doesn-t-use-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition here is to use a stack. But we can actually use a vector because it supports pop_back and push_back operations. Most importantly, a vector can enable us to calculate the case \"+\" easily: we don\\'t need to pop twice. Instead, we can simply index the last and second elements in the vector and sum them up. \\n\\nAlso, to optimize time complexity, we can keep a running sum instead of writing a for loop to summing up all elements in vector/stack eventually.\\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n    vector<int> record;\\n    int sum = 0;\\n    for (auto o : operations) {\\n        if (o == \"+\") {\\n            int add1 = record.back();\\n            int add2 = record[record.size() - 2];\\n            int sumOfTwo = add1 + add2;\\n            record.push_back(sumOfTwo);\\n            sum += sumOfTwo;\\n        } else if (o == \"D\") {\\n            int doublePrev = 2 * record.back();\\n            record.push_back(doublePrev);\\n            sum += doublePrev;\\n        } else if (o == \"C\") { \\n            int subtract = record.back();\\n            record.pop_back();\\n            sum -= subtract;\\n        } else {\\n            int toadd = stoi(o);\\n            record.push_back(toadd);\\n            sum += toadd;\\n        }\\n    }\\n    return sum;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n    vector<int> record;\\n    int sum = 0;\\n    for (auto o : operations) {\\n        if (o == \"+\") {\\n            int add1 = record.back();\\n            int add2 = record[record.size() - 2];\\n            int sumOfTwo = add1 + add2;\\n            record.push_back(sumOfTwo);\\n            sum += sumOfTwo;\\n        } else if (o == \"D\") {\\n            int doublePrev = 2 * record.back();\\n            record.push_back(doublePrev);\\n            sum += doublePrev;\\n        } else if (o == \"C\") { \\n            int subtract = record.back();\\n            record.pop_back();\\n            sum -= subtract;\\n        } else {\\n            int toadd = stoi(o);\\n            record.push_back(toadd);\\n            sum += toadd;\\n        }\\n    }\\n    return sum;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794318,
                "title": "java-solution-stacks",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0; i<operations.length; i++){\\n            if(operations[i].equals(\"C\")){\\n                stack.pop();\\n            }\\n            else if(operations[i].equals(\"D\")){\\n                stack.push(2* stack.peek());\\n            }\\n            else if(operations[i].equals(\"+\") && stack.size()>=2){\\n                int x = stack.pop();\\n                int y = stack.pop();\\n                int z = x+y;\\n\\n                stack.push(y);\\n                stack.push(x);\\n                stack.push(z);\\n            }\\n            else{\\n                stack.push(Integer.parseInt(operations[i]));\\n            }\\n        }\\n        int sum =0;\\n        while(!stack.isEmpty()){\\n            sum+=stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0; i<operations.length; i++){\\n            if(operations[i].equals(\"C\")){\\n                stack.pop();\\n            }\\n            else if(operations[i].equals(\"D\")){\\n                stack.push(2* stack.peek());\\n            }\\n            else if(operations[i].equals(\"+\") && stack.size()>=2){\\n                int x = stack.pop();\\n                int y = stack.pop();\\n                int z = x+y;\\n\\n                stack.push(y);\\n                stack.push(x);\\n                stack.push(z);\\n            }\\n            else{\\n                stack.push(Integer.parseInt(operations[i]));\\n            }\\n        }\\n        int sum =0;\\n        while(!stack.isEmpty()){\\n            sum+=stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693883,
                "title": "c-easy-solution-using-stack",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& op) {\\n        stack<int> st;\\n        for(int i=0; i<op.size();i++){\\n            \\n            if(st.empty()){\\n                st.push(stoi(op[i]));\\n            }\\n            if(op[i] == \"C\" ){\\n                st.pop();\\n            }\\n            else if(op[i] == \"D\" ){\\n                st.push(2*st.top());\\n            }\\n            else if(op[i] == \"+\"){\\n                int temp = st.top();\\n                st.pop();\\n                int a = temp+st.top();\\n                st.push(temp);\\n                st.push(a);\\n            }\\n            else{\\n                st.push(stoi(op[i]));\\n            }\\n        }\\n\\n        vector<int> v;\\n        \\n        int sum =0;\\n        while(!st.empty()){\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n\\n        for(int i=0; i<v.size()-1;i++){\\n            //cout<<v[i]<<\" \";\\n            sum+=v[i];\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& op) {\\n        stack<int> st;\\n        for(int i=0; i<op.size();i++){\\n            \\n            if(st.empty()){\\n                st.push(stoi(op[i]));\\n            }\\n            if(op[i] == \"C\" ){\\n                st.pop();\\n            }\\n            else if(op[i] == \"D\" ){\\n                st.push(2*st.top());\\n            }\\n            else if(op[i] == \"+\"){\\n                int temp = st.top();\\n                st.pop();\\n                int a = temp+st.top();\\n                st.push(temp);\\n                st.push(a);\\n            }\\n            else{\\n                st.push(stoi(op[i]));\\n            }\\n        }\\n\\n        vector<int> v;\\n        \\n        int sum =0;\\n        while(!st.empty()){\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n\\n        for(int i=0; i<v.size()-1;i++){\\n            //cout<<v[i]<<\" \";\\n            sum+=v[i];\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3609855,
                "title": "easiest-c-solution-absolute-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& opr) {\\n        vector<int>v;\\n        for(int i=0;i<opr.size();i++){\\n            int sz=v.size();\\n            if(opr[i]!=\"D\" && opr[i]!=\"C\" && opr[i]!=\"+\"){\\n                v.emplace_back(stoi(opr[i]));\\n            }\\n            if(opr[i]==\"+\"){\\n                v.emplace_back(v[sz-1]+v[sz-2]);\\n            }\\n            if(opr[i]==\"D\"){\\n                v.emplace_back(2*v[sz-1]);\\n            }\\n            if(opr[i]==\"C\"){\\n                v.pop_back();\\n            }\\n        }\\n        long long ans=accumulate(v.begin(),v.end(),0);\\n        return ans;\\n        \\n    }\\n};\\nDO UPVOTE\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& opr) {\\n        vector<int>v;\\n        for(int i=0;i<opr.size();i++){\\n            int sz=v.size();\\n            if(opr[i]!=\"D\" && opr[i]!=\"C\" && opr[i]!=\"+\"){\\n                v.emplace_back(stoi(opr[i]));\\n            }\\n            if(opr[i]==\"+\"){\\n                v.emplace_back(v[sz-1]+v[sz-2]);\\n            }\\n            if(opr[i]==\"D\"){\\n                v.emplace_back(2*v[sz-1]);\\n            }\\n            if(opr[i]==\"C\"){\\n                v.pop_back();\\n            }\\n        }\\n        long long ans=accumulate(v.begin(),v.end(),0);\\n        return ans;\\n        \\n    }\\n};\\nDO UPVOTE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536955,
                "title": "javascript-easiest-way-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a stack to keep track of valid scores and perform operations based on the given rules. Calculate the total score by summing up the scores in the stack.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize an empty stack.\\nIterate through operations.\\nFor each operation:\\nIf integer, push onto stack.\\nIf \"+\", push sum of last two scores onto stack.\\nIf \"D\", push double of last score onto stack.\\nIf \"C\", pop last score from stack.\\nReturn sum of scores in stack.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n), where n is the number of operations.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(n), where n is the number of operations. The stack stores the valid scores, which can be at most the same size as the number of operations.\\n# Code\\n```\\n/**\\n * @param {string[]} operations\\n * @return {number}\\n */\\nvar calPoints = function(operations) {\\n    let stack = [];\\n    for(let i =0; i< operations.length; i++){\\n        let len = stack.length;\\n        switch(operations[i]){\\n            case \"+\" : \\n                    stack.push( stack[len-1]+stack[len-2] );\\n                    break;\\n            case \"D\" : \\n                    stack.push(stack[len-1]*2);\\n                    break;\\n            case \"C\" : \\n                    stack.pop()\\n                    break;\\n            default : \\n                    stack.push(parseInt(operations[i]))\\n        }\\n    }\\n    \\n    return stack.length ? stack.reduce((now,prev)=>{\\n        return now+prev\\n    }) : 0;\\n};\\n```\\n# EXPLANATION\\nLet\\'s go through an example to understand how the code works:\\n```\\nInput: operations = [\"5\", \"2\", \"C\", \"D\", \"+\"]\\nOutput: 30\\n\\n```\\n\\nInitially, the stack is empty. We iterate through the operations:\\n\\nFor \"5\", we convert it to a number and push it onto the stack. The stack becomes [5].\\nFor \"2\", we convert it to a number and push it onto the stack. The stack becomes [5, 2].\\nFor \"C\", we pop the last score from the stack. The stack becomes [5].\\nFor \"D\", we duplicate the last score in the stack (5) and push the doubled value (10) onto the stack. The stack becomes [5, 10].\\nFor \"+\", we pop the last two scores from the stack (5 and 10), calculate their sum (15), and push it onto the stack. The stack becomes [5, 10, 15].\\nWe have processed all the operations. We calculate the\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string[]} operations\\n * @return {number}\\n */\\nvar calPoints = function(operations) {\\n    let stack = [];\\n    for(let i =0; i< operations.length; i++){\\n        let len = stack.length;\\n        switch(operations[i]){\\n            case \"+\" : \\n                    stack.push( stack[len-1]+stack[len-2] );\\n                    break;\\n            case \"D\" : \\n                    stack.push(stack[len-1]*2);\\n                    break;\\n            case \"C\" : \\n                    stack.pop()\\n                    break;\\n            default : \\n                    stack.push(parseInt(operations[i]))\\n        }\\n    }\\n    \\n    return stack.length ? stack.reduce((now,prev)=>{\\n        return now+prev\\n    }) : 0;\\n};\\n```\n```\\nInput: operations = [\"5\", \"2\", \"C\", \"D\", \"+\"]\\nOutput: 30\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486520,
                "title": "brute-force-beginner",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        int n = operations.size();\\n        vector<int> scores(n);\\n\\n        int j = 0;\\n        for (auto ch: operations) {\\n            if (ch == \"+\") scores[j++] = scores[j-1]+scores[j-2];\\n            else if (ch == \"D\") scores[j++] = scores[j-1]*2;\\n            else if (ch == \"C\") scores[--j] = 0;\\n            else scores[j++] = stoi(ch);\\n        }\\n\\n        return accumulate(begin(scores), end(scores), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        int n = operations.size();\\n        vector<int> scores(n);\\n\\n        int j = 0;\\n        for (auto ch: operations) {\\n            if (ch == \"+\") scores[j++] = scores[j-1]+scores[j-2];\\n            else if (ch == \"D\") scores[j++] = scores[j-1]*2;\\n            else if (ch == \"C\") scores[--j] = 0;\\n            else scores[j++] = stoi(ch);\\n        }\\n\\n        return accumulate(begin(scores), end(scores), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450802,
                "title": "very-easy-c-solution-using-stack-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N) (stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& op) \\n    {\\n        stack<string>s;\\n        for(int i=0;i<op.size();i++)\\n        {\\n            if(op[i]==\"+\")\\n            {\\n                string a = s.top();\\n                s.pop();\\n                string b = s.top();\\n                s.pop();\\n                int c = stoi(a);\\n                int d = stoi(b);\\n                int e = c+d;\\n                string f = to_string(e);\\n                s.push(b);\\n                s.push(a);\\n                s.push(f);\\n            }\\n            else if(op[i]==\"C\")\\n            {\\n                s.pop();\\n            }\\n            else if(op[i]==\"D\")\\n            {\\n                string a = s.top();\\n                int b = stoi(a);\\n                b=b*2;\\n                string c = to_string(b);\\n                s.push(c);\\n            }\\n            else\\n            {\\n                s.push(op[i]);\\n            }\\n        } \\n        int ans=0; \\n        while(s.size())\\n        {\\n            string a = s.top();\\n            int b = stoi(a);\\n            ans+=b;\\n            s.pop();\\n        } \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& op) \\n    {\\n        stack<string>s;\\n        for(int i=0;i<op.size();i++)\\n        {\\n            if(op[i]==\"+\")\\n            {\\n                string a = s.top();\\n                s.pop();\\n                string b = s.top();\\n                s.pop();\\n                int c = stoi(a);\\n                int d = stoi(b);\\n                int e = c+d;\\n                string f = to_string(e);\\n                s.push(b);\\n                s.push(a);\\n                s.push(f);\\n            }\\n            else if(op[i]==\"C\")\\n            {\\n                s.pop();\\n            }\\n            else if(op[i]==\"D\")\\n            {\\n                string a = s.top();\\n                int b = stoi(a);\\n                b=b*2;\\n                string c = to_string(b);\\n                s.push(c);\\n            }\\n            else\\n            {\\n                s.push(op[i]);\\n            }\\n        } \\n        int ans=0; \\n        while(s.size())\\n        {\\n            string a = s.top();\\n            int b = stoi(a);\\n            ans+=b;\\n            s.pop();\\n        } \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415852,
                "title": "simple-java-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) \\n    {\\n      Stack<Integer> stack=new Stack<>();\\n      for(int i=0;i<operations.length;i++)\\n      {\\n          if(operations[i].equals(\"C\"))\\n          {\\n              stack.pop();\\n          }\\n          else if(operations[i].equals(\"D\"))\\n          {\\n              stack.push(stack.peek()*2);\\n          }\\n          else if(operations[i].equals(\"+\"))\\n          {\\n              int a=stack.pop();\\n              int b=stack.pop();\\n              int c=a+b;\\n              stack.push(b);\\n              stack.push(a);\\n              stack.push(c);\\n          }\\n          else{\\n               stack.push(Integer.parseInt(operations[i]));\\n          }\\n      }\\n      int sum=0;\\n      while(!stack.isEmpty())\\n      {\\n          sum+=stack.pop();\\n      }\\n      return sum;\\n                \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] operations) \\n    {\\n      Stack<Integer> stack=new Stack<>();\\n      for(int i=0;i<operations.length;i++)\\n      {\\n          if(operations[i].equals(\"C\"))\\n          {\\n              stack.pop();\\n          }\\n          else if(operations[i].equals(\"D\"))\\n          {\\n              stack.push(stack.peek()*2);\\n          }\\n          else if(operations[i].equals(\"+\"))\\n          {\\n              int a=stack.pop();\\n              int b=stack.pop();\\n              int c=a+b;\\n              stack.push(b);\\n              stack.push(a);\\n              stack.push(c);\\n          }\\n          else{\\n               stack.push(Integer.parseInt(operations[i]));\\n          }\\n      }\\n      int sum=0;\\n      while(!stack.isEmpty())\\n      {\\n          sum+=stack.pop();\\n      }\\n      return sum;\\n                \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325217,
                "title": "baseball-game",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![baseball.PNG](https://assets.leetcode.com/users/images/eb3fa421-d250-423a-8a6c-fccc083c3ec8_1679414081.752513.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        res=[]\\n        for i in operations:\\n            if i==\\'C\\':\\n                res.pop()\\n            elif i==\\'D\\':\\n                res.append(int(res[-1])*2)\\n            elif i==\\'+\\':\\n                res.append(int(res[-1])+int(res[-2]))\\n            else:\\n                res.append(i)\\n        ans=0\\n        for i in res:\\n            ans+=int(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        res=[]\\n        for i in operations:\\n            if i==\\'C\\':\\n                res.pop()\\n            elif i==\\'D\\':\\n                res.append(int(res[-1])*2)\\n            elif i==\\'+\\':\\n                res.append(int(res[-1])+int(res[-2]))\\n            else:\\n                res.append(i)\\n        ans=0\\n        for i in res:\\n            ans+=int(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211341,
                "title": "java-using-array-solution-1ms-code",
                "content": "\\n# Approach\\nUsing Array as a stack and take a variable which store TOS(Top of Stack).\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        int a[]=new int[operations.length];\\n        int ans=0,c=0;\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i].equals(\"+\")) a[c++]=a[c-2]+a[c-3];\\n            else if(operations[i].equals(\"D\")) a[c++]=2*a[c-2];\\n            else if(operations[i].equals(\"C\")) c--;\\n            else a[c++]=Integer.parseInt(operations[i]);\\n        }\\n        for(int i=0;i<c;i++)\\n        ans+=a[i];\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        int a[]=new int[operations.length];\\n        int ans=0,c=0;\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i].equals(\"+\")) a[c++]=a[c-2]+a[c-3];\\n            else if(operations[i].equals(\"D\")) a[c++]=2*a[c-2];\\n            else if(operations[i].equals(\"C\")) c--;\\n            else a[c++]=Integer.parseInt(operations[i]);\\n        }\\n        for(int i=0;i<c;i++)\\n        ans+=a[i];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156195,
                "title": "simple-c-code-easy-beats-100",
                "content": "Runtime : Beats 94%+\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        vector<int> res;\\n        for(int i=0; i< operations.size();i++){\\n            int x;\\n            if(operations[i]==\"+\"){\\n                x=res[res.size()-1]+res[res.size()-2];\\n                res.push_back(x);\\n            }else if(operations[i]==\"D\"){\\n                x=res[res.size()-1]*2;\\n                res.push_back(x);\\n            }else if(operations[i]==\"C\"){\\n                res.pop_back();\\n            }else{\\n                res.push_back(stoi(operations[i]));\\n            }\\n        }\\n        int c=0;\\n        for(auto a: res){\\n            c=c+a;\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\nHope you liked the implementation of the code, if you like it feel free to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        vector<int> res;\\n        for(int i=0; i< operations.size();i++){\\n            int x;\\n            if(operations[i]==\"+\"){\\n                x=res[res.size()-1]+res[res.size()-2];\\n                res.push_back(x);\\n            }else if(operations[i]==\"D\"){\\n                x=res[res.size()-1]*2;\\n                res.push_back(x);\\n            }else if(operations[i]==\"C\"){\\n                res.pop_back();\\n            }else{\\n                res.push_back(stoi(operations[i]));\\n            }\\n        }\\n        int c=0;\\n        for(auto a: res){\\n            c=c+a;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152920,
                "title": "beats-100-easy-sol-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n    int sum=0;\\n    int[] arr = new int[operations.length];\\n    int count=0;\\n\\n    for(int i=0;i<operations.length;i++){\\n        // System.out.println(count + \" \" + operations[i]);\\n        if(operations[i].equals(\"C\")){\\n            arr[--count]=0;\\n        }\\n        else if(operations[i].equals(\"D\")){\\n            arr[count] = 2 * arr[count-1];\\n            count++;\\n        }\\n        else if(operations[i].equals(\"+\")){\\n            arr[count]= arr[count-1] + arr[count-2];\\n            count++;\\n        }\\n        else{\\n            // System.out.println(operations[i]);\\n            arr[count] = Integer.parseInt(operations[i]);\\n            count++;\\n        }   \\n    }\\n    for(int j=0;j<arr.length;j++){\\n        //System.out.println(arr[j]);\\n        sum += arr[j];\\n    }\\n    return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n    int sum=0;\\n    int[] arr = new int[operations.length];\\n    int count=0;\\n\\n    for(int i=0;i<operations.length;i++){\\n        // System.out.println(count + \" \" + operations[i]);\\n        if(operations[i].equals(\"C\")){\\n            arr[--count]=0;\\n        }\\n        else if(operations[i].equals(\"D\")){\\n            arr[count] = 2 * arr[count-1];\\n            count++;\\n        }\\n        else if(operations[i].equals(\"+\")){\\n            arr[count]= arr[count-1] + arr[count-2];\\n            count++;\\n        }\\n        else{\\n            // System.out.println(operations[i]);\\n            arr[count] = Integer.parseInt(operations[i]);\\n            count++;\\n        }   \\n    }\\n    for(int j=0;j<arr.length;j++){\\n        //System.out.println(arr[j]);\\n        sum += arr[j];\\n    }\\n    return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141349,
                "title": "easy-to-understand-c-solution-with-0ms-run-time",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        vector<int>record;\\n        for(auto i:operations)\\n        {\\n            if(i == \"+\")\\n            {\\n                int n = record.size();\\n                record.push_back(record[n-1] + record[n-2]);\\n            }\\n            else if(i == \"D\")\\n            {\\n                int n = record.size();\\n                record.push_back(record[n-1] * 2);\\n            }\\n            else if(i == \"C\")\\n                record.pop_back();\\n            \\n            else\\n                record.push_back(stoi(i));\\n            \\n        }\\n\\n        return accumulate(record.begin(), record.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        vector<int>record;\\n        for(auto i:operations)\\n        {\\n            if(i == \"+\")\\n            {\\n                int n = record.size();\\n                record.push_back(record[n-1] + record[n-2]);\\n            }\\n            else if(i == \"D\")\\n            {\\n                int n = record.size();\\n                record.push_back(record[n-1] * 2);\\n            }\\n            else if(i == \"C\")\\n                record.pop_back();\\n            \\n            else\\n                record.push_back(stoi(i));\\n            \\n        }\\n\\n        return accumulate(record.begin(), record.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081420,
                "title": "simple-solution-beats-9-3-9-9",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} operations\\n * @return {number}\\n */\\nconst calPoints = function (operations) {\\n  const records = [];\\n  while (operations.length != 0) {\\n    const op = operations.shift();\\n    switch (op) {\\n      case \\'C\\': records.pop();\\n        break;\\n      case \\'D\\': records.push(2 * records.at(-1));\\n        break;\\n      case \\'+\\': records.push(+records.at(-1) + +records.at(-2));\\n        break;\\n      default: records.push(+op);\\n        break;\\n    }\\n  }\\n  return records.reduce((a, b) => a + b, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string[]} operations\\n * @return {number}\\n */\\nconst calPoints = function (operations) {\\n  const records = [];\\n  while (operations.length != 0) {\\n    const op = operations.shift();\\n    switch (op) {\\n      case \\'C\\': records.pop();\\n        break;\\n      case \\'D\\': records.push(2 * records.at(-1));\\n        break;\\n      case \\'+\\': records.push(+records.at(-1) + +records.at(-2));\\n        break;\\n      default: records.push(+op);\\n        break;\\n    }\\n  }\\n  return records.reduce((a, b) => a + b, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2633114,
                "title": "very-simple-python-solution",
                "content": "Time and Space Complexcity O(n)\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        ans=[]\\n        a=0\\n        for i in operations:\\n            if i==\"C\":\\n                a=ans.pop()\\n            elif i==\"D\":\\n                ans.append(2*ans[-1])\\n            elif i==\"+\":\\n                ans.append(ans[-1]+ans[-2])\\n            else:\\n                ans.append(int(i))\\n        return sum(ans)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        ans=[]\\n        a=0\\n        for i in operations:\\n            if i==\"C\":\\n                a=ans.pop()\\n            elif i==\"D\":\\n                ans.append(2*ans[-1])\\n            elif i==\"+\":\\n                ans.append(ans[-1]+ans[-2])\\n            else:\\n                ans.append(int(i))\\n        return sum(ans)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596627,
                "title": "stack-fast-with-explanation",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/682-baseball-game-stack.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n/**\\n * @param {string[]} ops\\n * @return {number}\\n */\\nvar calPoints = function(ops) {\\n    let stack = [];\\n    let sum = 0;\\n    for(let i=0;i<ops.length;i++){\\n        if(ops[i] == \\'C\\'){\\n            stack.pop(); \\n        }else if(ops[i] == \\'+\\'){\\n            stack.push(Number(stack[stack.length-1] || 0) + Number(stack[stack.length-2] || 0)); \\n        }else if(ops[i] == \\'D\\'){\\n            stack.push(stack[stack.length-1] * 2); \\n        }else if((!isNaN(ops[i])) && typeof(Number(ops[i])) == \\'number\\'){\\n            stack.push(ops[i]);\\n        }\\n    }\\n    return  stack.reduce(\\n              (previousValue, currentValue) => Number(previousValue) + Number(currentValue),\\n              0\\n            );\\n};\\n```\\n\\n```\\nRuntime: 70 ms, faster than 87.59% of JavaScript online submissions for Baseball Game.\\nMemory Usage: 42.6 MB, less than 49.49% of JavaScript online submissions for Baseball Game.\\n```\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string[]} ops\\n * @return {number}\\n */\\nvar calPoints = function(ops) {\\n    let stack = [];\\n    let sum = 0;\\n    for(let i=0;i<ops.length;i++){\\n        if(ops[i] == \\'C\\'){\\n            stack.pop(); \\n        }else if(ops[i] == \\'+\\'){\\n            stack.push(Number(stack[stack.length-1] || 0) + Number(stack[stack.length-2] || 0)); \\n        }else if(ops[i] == \\'D\\'){\\n            stack.push(stack[stack.length-1] * 2); \\n        }else if((!isNaN(ops[i])) && typeof(Number(ops[i])) == \\'number\\'){\\n            stack.push(ops[i]);\\n        }\\n    }\\n    return  stack.reduce(\\n              (previousValue, currentValue) => Number(previousValue) + Number(currentValue),\\n              0\\n            );\\n};\\n```\n```\\nRuntime: 70 ms, faster than 87.59% of JavaScript online submissions for Baseball Game.\\nMemory Usage: 42.6 MB, less than 49.49% of JavaScript online submissions for Baseball Game.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2553779,
                "title": "js-with-explanation-easy-to-understand-70ms",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/682-baseball-game-stack.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n/**\\n * @param {string[]} ops\\n * @return {number}\\n */\\nvar calPoints = function(ops) {\\n    let stack = [];\\n    let sum = 0;\\n    for(let i=0;i<ops.length;i++){\\n        if(ops[i] == \\'C\\'){\\n            stack.pop(); \\n        }else if(ops[i] == \\'+\\'){\\n            stack.push(Number(stack[stack.length-1] || 0) + Number(stack[stack.length-2] || 0)); \\n        }else if(ops[i] == \\'D\\'){\\n            stack.push(stack[stack.length-1] * 2); \\n        }else if((!isNaN(ops[i])) && typeof(Number(ops[i])) == \\'number\\'){\\n            stack.push(ops[i]);\\n        }\\n    }\\n    return  stack.reduce(\\n              (previousValue, currentValue) => Number(previousValue) + Number(currentValue),\\n              0\\n            );\\n};\\n```\\n\\n```\\nRuntime: 70 ms, faster than 87.59% of JavaScript online submissions for Baseball Game.\\nMemory Usage: 42.6 MB, less than 49.49% of JavaScript online submissions for Baseball Game.\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string[]} ops\\n * @return {number}\\n */\\nvar calPoints = function(ops) {\\n    let stack = [];\\n    let sum = 0;\\n    for(let i=0;i<ops.length;i++){\\n        if(ops[i] == \\'C\\'){\\n            stack.pop(); \\n        }else if(ops[i] == \\'+\\'){\\n            stack.push(Number(stack[stack.length-1] || 0) + Number(stack[stack.length-2] || 0)); \\n        }else if(ops[i] == \\'D\\'){\\n            stack.push(stack[stack.length-1] * 2); \\n        }else if((!isNaN(ops[i])) && typeof(Number(ops[i])) == \\'number\\'){\\n            stack.push(ops[i]);\\n        }\\n    }\\n    return  stack.reduce(\\n              (previousValue, currentValue) => Number(previousValue) + Number(currentValue),\\n              0\\n            );\\n};\\n```\n```\\nRuntime: 70 ms, faster than 87.59% of JavaScript online submissions for Baseball Game.\\nMemory Usage: 42.6 MB, less than 49.49% of JavaScript online submissions for Baseball Game.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2488476,
                "title": "js-very-easy-solution-100",
                "content": "```\\nconst APPLY = {\\n    \"+\": \"+\",\\n    \"D\": \"D\",\\n    \"C\": \"C\",\\n}\\n\\nvar calPoints = function(ops) {\\n    let output = [];\\n    let totalScore = 0;\\n    \\n    for (let i = 0; i < ops.length; i++) {\\n        const op = ops[i];\\n\\n        if (!APPLY[op]) {\\n            output.push(op);\\n            totalScore += Number(op);\\n        } else if (op === \"+\") {\\n            const newScore = Number(output[output.length - 1]) + Number(output[output.length - 2]);\\n            output.push(newScore);\\n            totalScore += newScore;\\n        } else if (op === \"D\") {\\n            const newScore = Number(output[output.length - 1]) * 2\\n            output.push(newScore);\\n            totalScore += newScore;\\n        } else {\\n            totalScore -= output.pop();\\n        }\\n    }\\n\\n    return totalScore;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst APPLY = {\\n    \"+\": \"+\",\\n    \"D\": \"D\",\\n    \"C\": \"C\",\\n}\\n\\nvar calPoints = function(ops) {\\n    let output = [];\\n    let totalScore = 0;\\n    \\n    for (let i = 0; i < ops.length; i++) {\\n        const op = ops[i];\\n\\n        if (!APPLY[op]) {\\n            output.push(op);\\n            totalScore += Number(op);\\n        } else if (op === \"+\") {\\n            const newScore = Number(output[output.length - 1]) + Number(output[output.length - 2]);\\n            output.push(newScore);\\n            totalScore += newScore;\\n        } else if (op === \"D\") {\\n            const newScore = Number(output[output.length - 1]) * 2\\n            output.push(newScore);\\n            totalScore += newScore;\\n        } else {\\n            totalScore -= output.pop();\\n        }\\n    }\\n\\n    return totalScore;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420246,
                "title": "c-easy-solution",
                "content": "```\\n//Please upvote\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        \\n        stack<int> s;\\n        int sum=0;\\n        for(int i=0;i<ops.size();i++)\\n        {\\n           if(ops[i]==\"C\")\\n               s.pop();\\n            \\n            else if(ops[i]==\"D\")\\n                s.push(2 * s.top());\\n            \\n            else if(ops[i]==\"+\")\\n            {\\n                int temp=s.top();\\n            s.pop();\\n                int temp2=s.top();\\n                s.push(temp);\\n                s.push(temp+temp2);\\n            }\\n            else\\n            {\\n                //converting string to int and then inserting it into stack\\n                s.push(stoi(ops[i]));\\n            }\\n            \\n        }\\n        \\n        int result=0;\\n        // calculating the total sum of the integers present in stack \\n        while(!s.empty())\\n        {\\n            result+=s.top();\\n            s.pop();\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        \\n        stack<int> s;\\n        int sum=0;\\n        for(int i=0;i<ops.size();i++)\\n        {\\n           if(ops[i]==\"C\")\\n               s.pop();\\n            \\n            else if(ops[i]==\"D\")\\n                s.push(2 * s.top());\\n            \\n            else if(ops[i]==\"+\")\\n            {\\n                int temp=s.top();\\n            s.pop();\\n                int temp2=s.top();\\n                s.push(temp);\\n                s.push(temp+temp2);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2294609,
                "title": "java-1ms-faster-than-100-o-n-memory-less-than-99-66",
                "content": "* 1ms, faster than 100%\\n[https://leetcode.com/submissions/detail/749297803/](https://leetcode.com/submissions/detail/749297803/)\\n\\n```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int[] a =  new int[1000];\\n        int index = 0;\\n        int sum = 0;\\n        for(String op : ops){\\n            switch (op){\\n                case \"C\":\\n                    sum -= a[index-1];\\n                    index--;\\n                    break;\\n                case \"D\":\\n                    a[index] = 2*a[index-1];\\n                    sum+=a[index];\\n                    index++;\\n                    break;\\n                case \"+\":\\n                    a[index] = a[index-1] + a[index-2];\\n                    sum+=a[index];\\n                    index++;\\n                    break;\\n                default:\\n                    a[index] = Integer.parseInt(op);\\n                    sum+=a[index];\\n                    index++;\\n                    break;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n* Using LinkedList\\n\\n[https://leetcode.com/submissions/detail/749294339/](https://leetcode.com/submissions/detail/749294339/)\\n\\n```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n       LinkedList<Integer> list = new LinkedList<>();\\n        int sum = 0;\\n        for(var op : ops){\\n            switch (op){\\n                case \"C\":{\\n                    sum -= list.removeLast();\\n                    break;\\n                }\\n                case \"D\":{\\n                    int item = list.getLast();\\n                    list.addLast(item*2);\\n                    sum+=item*2;\\n                    break;\\n                }\\n                case \"+\":{\\n                    int value = list.get(list.size()-2)+list.getLast();\\n                    list.addLast(value);\\n                    sum+=value;\\n                    break;\\n                }\\n                default:{\\n                    list.addLast(Integer.parseInt(op));\\n                    sum+=Integer.parseInt(op);\\n                    break;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int[] a =  new int[1000];\\n        int index = 0;\\n        int sum = 0;\\n        for(String op : ops){\\n            switch (op){\\n                case \"C\":\\n                    sum -= a[index-1];\\n                    index--;\\n                    break;\\n                case \"D\":\\n                    a[index] = 2*a[index-1];\\n                    sum+=a[index];\\n                    index++;\\n                    break;\\n                case \"+\":\\n                    a[index] = a[index-1] + a[index-2];\\n                    sum+=a[index];\\n                    index++;\\n                    break;\\n                default:\\n                    a[index] = Integer.parseInt(op);\\n                    sum+=a[index];\\n                    index++;\\n                    break;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n       LinkedList<Integer> list = new LinkedList<>();\\n        int sum = 0;\\n        for(var op : ops){\\n            switch (op){\\n                case \"C\":{\\n                    sum -= list.removeLast();\\n                    break;\\n                }\\n                case \"D\":{\\n                    int item = list.getLast();\\n                    list.addLast(item*2);\\n                    sum+=item*2;\\n                    break;\\n                }\\n                case \"+\":{\\n                    int value = list.get(list.size()-2)+list.getLast();\\n                    list.addLast(value);\\n                    sum+=value;\\n                    break;\\n                }\\n                default:{\\n                    list.addLast(Integer.parseInt(op));\\n                    sum+=Integer.parseInt(op);\\n                    break;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270380,
                "title": "python-3-simple-easy-to-understand-low-memory",
                "content": "Runtime: `51 ms, faster than 76.32%` of Python3 online submissions for Baseball Game.\\nMemory Usage: `13.9 MB, less than 99.68%` of Python3 online submissions for Baseball Game.\\n\\n```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        d = []\\n        for i in ops:\\n            if i == \"C\":\\n                d.remove(d[-1])\\n            elif i == \"D\":\\n                d.append(2*d[-1])\\n            elif i == \"+\":\\n                d.append(d[-1]+d[-2])\\n            else:\\n                d.append(int(i))\\n        return sum(d)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Runtime: `51 ms, faster than 76.32%` of Python3 online submissions for Baseball Game.\\nMemory Usage: `13.9 MB, less than 99.68%` of Python3 online submissions for Baseball Game.\\n\\n```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        d = []\\n        for i in ops:\\n            if i == \"C\":\\n                d.remove(d[-1])\\n            elif i == \"D\":\\n                d.append(2*d[-1])\\n            elif i == \"+\":\\n                d.append(d[-1]+d[-2])\\n            else:\\n                d.append(int(i))\\n        return sum(d)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1939402,
                "title": "c-easy-solution-with-0ms-runtime",
                "content": "vector<int> arr;\\n         \\n        for (string ch : ops) {\\n            if(ch ==\"+\") \\n                arr.push_back(arr[arr.size()-1]+ arr[arr.size()-2]);\\n            else if(ch ==\"D\")\\n                arr.push_back(arr.back()*2);\\n            else if(ch ==\"C\")\\n                arr.pop_back();\\n            else \\n                arr.push_back(stoi(ch));\\n        }\\n            \\n        \\n        return accumulate(arr.begin(),arr.end(),0);",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "vector<int> arr;\\n         \\n        for (string ch : ops) {\\n            if(ch ==\"+\") \\n                arr.push_back(arr[arr.size()-1]+ arr[arr.size()-2]);\\n            else if(ch ==\"D\")\\n                arr.push_back(arr.back()*2);\\n            else if(ch ==\"C\")\\n                arr.pop_back();\\n            else \\n                arr.push_back(stoi(ch));\\n        }\\n            \\n        \\n        return accumulate(arr.begin(),arr.end(),0);",
                "codeTag": "Unknown"
            },
            {
                "id": 1933627,
                "title": "java-solution-easiest-to-understand-using-switch-case-statement",
                "content": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int[] record= new int[1000];\\n        int j=0;\\n        int sum=0;\\n        for(int i=0; i<ops.length; i++)\\n        {\\n            switch(ops[i])\\n            {\\n                case \"+\":\\n                    j++;\\n                    record[j]=record[j-1]+record[j-2];  \\n                    break;\\n                \\n                case \"C\":\\n                    record[j]=0;\\n                    j--;\\n                    break;\\n                    \\n                case \"D\":\\n                    j++;\\n                    record[j]=record[j-1]*2;\\n                    break;\\n                \\n                default:\\n                    j++;\\n                    record[j]=Integer.valueOf(ops[i]);\\n                    break;\\n            }\\n        }\\n        for(int k=0; k<record.length;k++)\\n        {\\n            sum+=record[k];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int[] record= new int[1000];\\n        int j=0;\\n        int sum=0;\\n        for(int i=0; i<ops.length; i++)\\n        {\\n            switch(ops[i])\\n            {\\n                case \"+\":\\n                    j++;\\n                    record[j]=record[j-1]+record[j-2];  \\n                    break;\\n                \\n                case \"C\":\\n                    record[j]=0;\\n                    j--;\\n                    break;\\n                    \\n                case \"D\":\\n                    j++;\\n                    record[j]=record[j-1]*2;\\n                    break;\\n                \\n                default:\\n                    j++;\\n                    record[j]=Integer.valueOf(ops[i]);\\n                    break;\\n            }\\n        }\\n        for(int k=0; k<record.length;k++)\\n        {\\n            sum+=record[k];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933587,
                "title": "c-easy-solution-using-vector",
                "content": "**Easy C++ solution using Vector**\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n    int sum=0;\\n        vector<int>v;\\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i]==\"+\"){\\n                v.push_back(v[v.size()-1]+v[v.size()-2]);\\n            }\\n            \\n            else if(ops[i]==\"D\"){\\n                 v.push_back(v[v.size()-1]* 2);\\n            }\\n            else if(ops[i]==\"C\"){\\n                 v.pop_back();\\n            }\\n            else{\\n                v.push_back(stoi(ops[i]));\\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            sum+=v[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n    int sum=0;\\n        vector<int>v;\\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i]==\"+\"){\\n                v.push_back(v[v.size()-1]+v[v.size()-2]);\\n            }\\n            \\n            else if(ops[i]==\"D\"){\\n                 v.push_back(v[v.size()-1]* 2);\\n            }\\n            else if(ops[i]==\"C\"){\\n                 v.pop_back();\\n            }\\n            else{\\n                v.push_back(stoi(ops[i]));\\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            sum+=v[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933350,
                "title": "easy-self-explained-code-o-n-arraylist-java",
                "content": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(String str : ops){\\n            if(str.equals(\"C\")){\\n                list.remove(list.size() - 1);\\n            }\\n            else if(str.equals(\"D\")){\\n                list.add(list.get(list.size() - 1) * 2);\\n            }\\n            else if(str.equals(\"+\")){\\n                list.add(list.get(list.size() - 1) + list.get(list.size() - 2));\\n            }\\n            else{\\n                list.add(Integer.parseInt(str));\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int val : list) ans += val;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(String str : ops){\\n            if(str.equals(\"C\")){\\n                list.remove(list.size() - 1);\\n            }\\n            else if(str.equals(\"D\")){\\n                list.add(list.get(list.size() - 1) * 2);\\n            }\\n            else if(str.equals(\"+\")){\\n                list.add(list.get(list.size() - 1) + list.get(list.size() - 2));\\n            }\\n            else{\\n                list.add(Integer.parseInt(str));\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int val : list) ans += val;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932624,
                "title": "c-stack-based-simple-solution",
                "content": "```\\n#include<ctype.h>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> st;\\n        for(int i = 0;i<ops.size();i++)\\n        {\\n             if(ops[i] == \"C\")\\n                st.pop();\\n            else if(ops[i] == \"D\"){\\n                st.push(st.top() * 2);\\n            }\\n            else if(ops[i] == \"+\"){\\n                int t1 = st.top();\\n                int c1 = st.top();\\n                st.pop();\\n                int t2 = st.top();\\n                st.push(c1);\\n                st.push(t1+t2);\\n            }\\n            else{\\n                st.push(stoi(ops[i]));\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> st;\\n        for(int i = 0;i<ops.size();i++)\\n        {\\n             if(ops[i] == \"C\")\\n                st.pop();\\n            else if(ops[i] == \"D\"){\\n                st.push(st.top() * 2);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1932582,
                "title": "c-simple-code",
                "content": "```\\nint calPoints(vector<string>& ops) {\\n        vector<int> v;\\n        \\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i]==\"C\"){\\n                v.pop_back();\\n            }\\n            else if(ops[i]==\"D\"){\\n                auto a=v.back();\\n                //v.push_back(a);\\n                a*=2;\\n                v.push_back(a);\\n            }\\n            else if(ops[i]==\"+\"){\\n                auto a=v.back();\\n                v.pop_back();\\n                auto b=v.back();\\n                //v.push_back(b);\\n                v.push_back(a);\\n                v.push_back(a+b);\\n            }\\n            else{\\n                stringstream geek(ops[i]);\\n                int x = 0;\\n                geek >> x;\\n                v.push_back(x);\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<v.size();i++){\\n            cout<<v[i]<<\" \";\\n            res+=v[i];\\n        }\\n        cout<<endl;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint calPoints(vector<string>& ops) {\\n        vector<int> v;\\n        \\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i]==\"C\"){\\n                v.pop_back();\\n            }\\n            else if(ops[i]==\"D\"){\\n                auto a=v.back();\\n                //v.push_back(a);\\n                a*=2;\\n                v.push_back(a);\\n            }\\n            else if(ops[i]==\"+\"){\\n                auto a=v.back();\\n                v.pop_back();\\n                auto b=v.back();\\n                //v.push_back(b);\\n                v.push_back(a);\\n                v.push_back(a+b);\\n            }\\n            else{\\n                stringstream geek(ops[i]);\\n                int x = 0;\\n                geek >> x;\\n                v.push_back(x);\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<v.size();i++){\\n            cout<<v[i]<<\" \";\\n            res+=v[i];\\n        }\\n        cout<<endl;\\n        return res;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1932549,
                "title": "c-easy-approach-stack-array-o-n",
                "content": "```\\n\\uD83D\\uDCA1 Please upvote if you like the solution \\uD83D\\uDC4B\\uD83C\\uDFFB\\n```\\n\\n```\\n// Array Approach:\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> result;\\n        \\n        \\n        for(int i=0;i<ops.size();i++)\\n        {\\n            if(ops[i] == \"+\")\\n            {\\n                int sum = result[result.size()-1] + result[result.size()-2];\\n                result.push_back(sum);\\n            }\\n            else if(ops[i] == \"D\")\\n            {\\n                int res = 2*result.back();\\n                result.push_back(res);\\n            }\\n            else if(ops[i] == \"C\")\\n                result.pop_back();\\n            else\\n            {\\n                stringstream ss;\\n                ss<<ops[i];\\n                int res = 0;\\n                ss>>res;\\n                result.push_back(res);\\n            }\\n        }\\n        \\n        int newSum = 0;\\n        for(int i=0;i<result.size();i++)\\n            newSum += result[i];\\n        \\n        return newSum;\\n    }\\n};\\n```\\n\\n---\\n---\\n\\n```\\n// Stack approach:\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> s;\\n        \\n        for(int i=0;i<ops.size();i++)\\n        {\\n            if(ops[i] == \"D\")\\n            {\\n                int res = 2 * s.top();\\n                s.push(res);\\n            }\\n            else if(ops[i] == \"C\")\\n            {\\n                s.pop();\\n            }\\n            else if(ops[i] == \"+\")\\n            {\\n                int res = 0;\\n                \\n                int a = s.top();\\n                s.pop();\\n                \\n                int b = s.top();\\n                s.push(a);\\n                \\n                res = a+b;\\n                s.push(res);\\n            }\\n            else\\n            {\\n                stringstream ss;\\n                \\n                ss<<ops[i];\\n                int res = 0;\\n                ss>>res;\\n                \\n                s.push(res);\\n            }\\n        }\\n        \\n        int newSum = 0;\\n        \\n        while(s.empty() == false)\\n        {\\n            newSum += s.top();\\n            s.pop();\\n        }\\n        \\n        return newSum;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\uD83D\\uDCA1 Please upvote if you like the solution \\uD83D\\uDC4B\\uD83C\\uDFFB\\n```\n```\\n// Array Approach:\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> result;\\n        \\n        \\n        for(int i=0;i<ops.size();i++)\\n        {\\n            if(ops[i] == \"+\")\\n            {\\n                int sum = result[result.size()-1] + result[result.size()-2];\\n                result.push_back(sum);\\n            }\\n            else if(ops[i] == \"D\")\\n            {\\n                int res = 2*result.back();\\n                result.push_back(res);\\n            }\\n            else if(ops[i] == \"C\")\\n                result.pop_back();\\n            else\\n            {\\n                stringstream ss;\\n                ss<<ops[i];\\n                int res = 0;\\n                ss>>res;\\n                result.push_back(res);\\n            }\\n        }\\n        \\n        int newSum = 0;\\n        for(int i=0;i<result.size();i++)\\n            newSum += result[i];\\n        \\n        return newSum;\\n    }\\n};\\n```\n```\\n// Stack approach:\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> s;\\n        \\n        for(int i=0;i<ops.size();i++)\\n        {\\n            if(ops[i] == \"D\")\\n            {\\n                int res = 2 * s.top();\\n                s.push(res);\\n            }\\n            else if(ops[i] == \"C\")\\n            {\\n                s.pop();\\n            }\\n            else if(ops[i] == \"+\")\\n            {\\n                int res = 0;\\n                \\n                int a = s.top();\\n                s.pop();\\n                \\n                int b = s.top();\\n                s.push(a);\\n                \\n                res = a+b;\\n                s.push(res);\\n            }\\n            else\\n            {\\n                stringstream ss;\\n                \\n                ss<<ops[i];\\n                int res = 0;\\n                ss>>res;\\n                \\n                s.push(res);\\n            }\\n        }\\n        \\n        int newSum = 0;\\n        \\n        while(s.empty() == false)\\n        {\\n            newSum += s.top();\\n            s.pop();\\n        }\\n        \\n        return newSum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932424,
                "title": "cc-100-faster-easy-to-understand-using-stack",
                "content": "```\\n/*\\nSo carefully observe what\\'s given in question \\nwhile reading you can observe that we need to pop and get last element from array\\nso we can either use stack or vector \\n*/\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int>st;\\n            \\n        for(int i=0;i<ops.size();i++)\\n        {\\n            if(ops[i]==\"+\")\\n            {\\n                int fir=0,sec=0;\\n                fir=st.top();\\n                st.pop();\\n                if(st.size()>0) sec=st.top();\\n                st.push(fir);\\n                st.push(fir+sec);\\n            }\\n            else if(ops[i]==\"C\")\\n            {\\n                if(st.size()>0) st.pop();\\n            }\\n            else if(ops[i]==\"D\")\\n            {\\n                int get=st.top();\\n                get=get*2;\\n                st.push(get);\\n            }\\n            else\\n            {\\n                int num=stoi(ops[i]); // to convert string to integer stoi is used\\n                st.push(num);\\n            }\\n        }\\n        int su=0;\\n        // at last to get sum we will sum all numbers present in stack\\n\\t\\twhile(st.size()>0)\\n        {\\n            su+=st.top();\\n            st.pop();\\n        }\\n        return su;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\n/*\\nSo carefully observe what\\'s given in question \\nwhile reading you can observe that we need to pop and get last element from array\\nso we can either use stack or vector \\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int>st;\\n            \\n        for(int i=0;i<ops.size();i++)\\n        {\\n            if(ops[i]==\"+\")\\n            {\\n                int fir=0,sec=0;\\n                fir=st.top();\\n                st.pop();\\n                if(st.size()>0) sec=st.top();\\n                st.push(fir);\\n                st.push(fir+sec);\\n            }\\n            else if(ops[i]==\"C\")\\n            {\\n                if(st.size()>0) st.pop();\\n            }\\n            else if(ops[i]==\"D\")\\n            {\\n                int get=st.top();\\n                get=get*2;\\n                st.push(get);\\n            }\\n            else\\n            {\\n                int num=stoi(ops[i]); // to convert string to integer stoi is used\\n                st.push(num);\\n            }\\n        }\\n        int su=0;\\n        // at last to get sum we will sum all numbers present in stack\\n\\t\\twhile(st.size()>0)\\n        {\\n            su+=st.top();\\n            st.pop();\\n        }\\n        return su;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932351,
                "title": "simple-c-solution-with-explanation-vector",
                "content": "You can also use a **stack** instead of a **vector**( both work in the same way ).\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int calPoints(vector<string> &ops)\\n    {\\n        // a vector to store all integers\\n        vector<int> ans;\\n        int n = ops.size();\\n\\n        // iterating through all operations\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (ops[i] == \"D\")\\n                ans.push_back(2 * ans.back());\\n            else if (ops[i] == \"C\")\\n                ans.pop_back();\\n            else if (ops[i] == \"+\")\\n                ans.push_back(ans[ans.size() - 1] + ans[ans.size() - 2]);\\n            else\\n                ans.push_back(stoi(ops[i]));\\n        }\\n        // adding the remaining integers in vector\\n        //  after performing all the operations\\n        int sum = 0;\\n        for (int i : ans)\\n            sum += i;\\n\\n        // returning answer as sum\\n        return sum;\\n    }\\n};\\n```\\n\\n**Time Complexity: O(N)**\\n**Space Complexity: O(N)**\\n\\nI hope this helps \\uD83D\\uDE42",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int calPoints(vector<string> &ops)\\n    {\\n        // a vector to store all integers\\n        vector<int> ans;\\n        int n = ops.size();\\n\\n        // iterating through all operations\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (ops[i] == \"D\")\\n                ans.push_back(2 * ans.back());\\n            else if (ops[i] == \"C\")\\n                ans.pop_back();\\n            else if (ops[i] == \"+\")\\n                ans.push_back(ans[ans.size() - 1] + ans[ans.size() - 2]);\\n            else\\n                ans.push_back(stoi(ops[i]));\\n        }\\n        // adding the remaining integers in vector\\n        //  after performing all the operations\\n        int sum = 0;\\n        for (int i : ans)\\n            sum += i;\\n\\n        // returning answer as sum\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932261,
                "title": "python-stack-if-else-statement-easy-solution",
                "content": "Approach\\n-\\n-> Given conditions\\n-\\n\\t->\"+\" append sum of last two elements\\n\\t->\"D\" append twice of last element to the stack\\n\\t->\"C\" remove last element\\n\\t-> any integer is appended to the stack\\n\\n\\n->Use if else conditions to perform above operations as per the input\\n-> Return the sum of remaining elements in stack.\\n\\n\\n```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        stack=[]\\n        for n in ops:\\n            if n==\"+\":\\n                stack.append(stack[-1]+stack[-2])\\n            elif n==\"D\":\\n                stack.append(stack[-1]*2)\\n            elif n==\"C\":\\n                stack.pop()\\n            else:\\n                num=int(n)\\n                stack.append(num)\\n        return sum(stack)  \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        stack=[]\\n        for n in ops:\\n            if n==\"+\":\\n                stack.append(stack[-1]+stack[-2])\\n            elif n==\"D\":\\n                stack.append(stack[-1]*2)\\n            elif n==\"C\":\\n                stack.pop()\\n            else:\\n                num=int(n)\\n                stack.append(num)\\n        return sum(stack)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932110,
                "title": "c-easy-to-understand-with-explanation",
                "content": "```\\n\\n// Explanation:\\n// We pass through the vector ops, whenever we encounter \"+\",\"C\",\"D\", we perform it\\'s corresponding operation and\\n// push the result into a vector named record, if we encounter number while passing we convert it into an integer using stoi()\\n// function in C++ and push it into the vector.\\n// At last we calculate sum of the vector and return it.\\n\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> record;\\n        \\n        for(string s: ops) {\\n            if(s== \"+\") {\\n                int new_score = (*(record.end() - 1) + *(record.end() - 2));\\n                record.push_back(new_score);\\n            }\\n            else if(s == \"D\") {\\n                int new_score = 2*(*(record.end() - 1));\\n                record.push_back(new_score);\\n            }\\n            else if(s == \"C\") {\\n                record.pop_back();\\n            }\\n            else {\\n                int score = stoi(s);\\n                record.push_back(score);\\n            }\\n        }\\n        \\n        int scores_sum = accumulate(record.begin(), record.end(), 0);\\n        \\n        return scores_sum;\\n    }\\n};\\n\\n``",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> record;\\n        \\n        for(string s: ops) {\\n            if(s== \"+\") {\\n                int new_score = (*(record.end() - 1) + *(record.end() - 2));\\n                record.push_back(new_score);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1932099,
                "title": "simple-c-solution-100-faster-and-95-memory-efficient",
                "content": "```\\n    int calPoints(vector<string>& ops) {\\n        vector<int> arr;\\n        int n = ops.size();\\n        int prev = stoi(ops[0]);\\n        arr.push_back(prev);\\n        for(int i=1; i<n; i++){\\n            if(ops[i]==\"C\"){\\n                arr.pop_back();\\n                continue;\\n            } else if (ops[i]==\"D\"){\\n                int last = arr.back();\\n                arr.push_back(last*2);\\n            } else if (ops[i]==\"+\"){\\n                int last = arr[arr.size()-1]+arr[arr.size()-2];\\n                arr.push_back(last);\\n            } else {\\n                arr.push_back(stoi(ops[i]));\\n            }\\n        }\\n        int sum = 0;\\n        for(auto e: arr){\\n            sum+=e;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "```\\n    int calPoints(vector<string>& ops) {\\n        vector<int> arr;\\n        int n = ops.size();\\n        int prev = stoi(ops[0]);\\n        arr.push_back(prev);\\n        for(int i=1; i<n; i++){\\n            if(ops[i]==\"C\"){\\n                arr.pop_back();\\n                continue;\\n            } else if (ops[i]==\"D\"){\\n                int last = arr.back();\\n                arr.push_back(last*2);\\n            } else if (ops[i]==\"+\"){\\n                int last = arr[arr.size()-1]+arr[arr.size()-2];\\n                arr.push_back(last);\\n            } else {\\n                arr.push_back(stoi(ops[i]));\\n            }\\n        }\\n        int sum = 0;\\n        for(auto e: arr){\\n            sum+=e;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1931956,
                "title": "with-diagram-c-o-n-using-stack-simple-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        if(ops.size()==1){\\n            return stoi(ops[0]) ;           \\n        }\\n        \\n        stack<int> hello;\\n        int three,two,one;\\n        int sum=0;\\n        \\n        for(int i=0;i<ops.size();i++){\\n        \\n            if(ops[i]!=\"C\" && ops[i]!=\"D\" && ops[i]!=\"+\")\\n            {\\n                hello.push(stoi(ops[i]));\\n                sum+=stoi(ops[i]);\\n            \\n            }else if(ops[i]==\"C\")\\n            {\\n                cout<<hello.top();\\n                sum-=hello.top();\\n                hello.pop();\\n            \\n            }else if(ops[i]==\"D\")\\n            {\\n                sum+=2*hello.top();\\n                hello.push(2*hello.top());\\n            \\n            }else if(ops[i]==\"+\")\\n            {\\n                two=hello.top();hello.pop();\\n                one=hello.top();\\n                three=two+one;\\n                sum+=three;\\n                hello.push(two);\\n                hello.push(three);\\n            }\\n        }\\n        \\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/08f064c0-ad2f-4916-950a-745dc476a9f3_1649572460.4348326.png)\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        if(ops.size()==1){\\n            return stoi(ops[0]) ;           \\n        }\\n        \\n        stack<int> hello;\\n        int three,two,one;\\n        int sum=0;\\n        \\n        for(int i=0;i<ops.size();i++){\\n        \\n            if(ops[i]!=\"C\" && ops[i]!=\"D\" && ops[i]!=\"+\")\\n            {\\n                hello.push(stoi(ops[i]));\\n                sum+=stoi(ops[i]);\\n            \\n            }else if(ops[i]==\"C\")\\n            {\\n                cout<<hello.top();\\n                sum-=hello.top();\\n                hello.pop();\\n            \\n            }else if(ops[i]==\"D\")\\n            {\\n                sum+=2*hello.top();\\n                hello.push(2*hello.top());\\n            \\n            }else if(ops[i]==\"+\")\\n            {\\n                two=hello.top();hello.pop();\\n                one=hello.top();\\n                three=two+one;\\n                sum+=three;\\n                hello.push(two);\\n                hello.push(three);\\n            }\\n        }\\n        \\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1931819,
                "title": "c-easy-explanation-using-stack-daily-leetcoding-challenge-april-day-10",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) \\n    {\\n        stack<int> st;                  // it will store the values in integer format\\n        \\n        // storing all the values \\n        for(int i=0;i<ops.size();i++)\\n        {\\n            if(ops[i]==\"D\")               // if it is \"D\" then store double as a new record\\n            {\\n                st.push(st.top()*2);\\n            }\\n            \\n            else if(ops[i]==\"C\")          // if it is \"C\" then delete previous record\\n            {\\n                st.pop();\\n            }\\n            \\n            else if(ops[i]==\"+\")          // if it is \"+\" then store sum of pervious two as a new record\\n            {\\n                int first = st.top();     // take out the first previous\\n                st.pop();\\n                \\n                int second = st.top();    // take out the second previous\\n                st.pop();\\n                \\n                st.push(second);          // again push values for making stack as it is\\n                st.push(first);\\n                st.push(first+second);    // store the sum as a new record\\n            }\\n            \\n            else                          // else store the value in integer form\\n            {\\n                st.push(stoi(ops[i]));\\n            }\\n        }\\n        \\n        int res = 0;\\n        while(!st.empty())                           // store all the sum in res\\n        {\\n            res = res + st.top();\\n            st.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) \\n    {\\n        stack<int> st;                  // it will store the values in integer format\\n        \\n        // storing all the values \\n        for(int i=0;i<ops.size();i++)\\n        {\\n            if(ops[i]==\"D\")               // if it is \"D\" then store double as a new record\\n            {\\n                st.push(st.top()*2);\\n            }\\n            \\n            else if(ops[i]==\"C\")          // if it is \"C\" then delete previous record\\n            {\\n                st.pop();\\n            }\\n            \\n            else if(ops[i]==\"+\")          // if it is \"+\" then store sum of pervious two as a new record\\n            {\\n                int first = st.top();     // take out the first previous\\n                st.pop();\\n                \\n                int second = st.top();    // take out the second previous\\n                st.pop();\\n                \\n                st.push(second);          // again push values for making stack as it is\\n                st.push(first);\\n                st.push(first+second);    // store the sum as a new record\\n            }\\n            \\n            else                          // else store the value in integer form\\n            {\\n                st.push(stoi(ops[i]));\\n            }\\n        }\\n        \\n        int res = 0;\\n        while(!st.empty())                           // store all the sum in res\\n        {\\n            res = res + st.top();\\n            st.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931706,
                "title": "c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> st;\\n        int ans=0;\\n        for(auto x : ops){\\n            if(x==\"+\"){\\n                // CASE 1 \\n                // STORE TOP VALUE OF STACK IN TEMP1 THEN POP IT\\n                // THEN STORE THE TOP VALUE AGAIN IN TEMP2 \\n                //PUSH TEMP1 THAN PUSH TEMP1+TEMP2\\n                int temp1 = st.top();\\n                st.pop();\\n                int temp2 = st.top();\\n                st.push(temp1);\\n                st.push(temp1+temp2);\\n            }\\n            else\\n                if(x==\"C\"){\\n                    // CASE 2\\n                    // JUST POP FROM THE GIVEN STACK\\n                    st.pop();\\n                }\\n            else\\n                if(x==\"D\"){\\n                    // CASE 3\\n                    // PUSH TWICE THE VALUE OF TOP INTO THE STACK\\n                    st.push(st.top()*2);\\n                }\\n            else{\\n                st.push(stoi(x));\\n            }\\n        }\\n        // FIND SUM OF THE GIVEN STACK\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> st;\\n        int ans=0;\\n        for(auto x : ops){\\n            if(x==\"+\"){\\n                // CASE 1 \\n                // STORE TOP VALUE OF STACK IN TEMP1 THEN POP IT\\n                // THEN STORE THE TOP VALUE AGAIN IN TEMP2 \\n                //PUSH TEMP1 THAN PUSH TEMP1+TEMP2\\n                int temp1 = st.top();\\n                st.pop();\\n                int temp2 = st.top();\\n                st.push(temp1);\\n                st.push(temp1+temp2);\\n            }\\n            else\\n                if(x==\"C\"){\\n                    // CASE 2\\n                    // JUST POP FROM THE GIVEN STACK\\n                    st.pop();\\n                }\\n            else\\n                if(x==\"D\"){\\n                    // CASE 3\\n                    // PUSH TWICE THE VALUE OF TOP INTO THE STACK\\n                    st.push(st.top()*2);\\n                }\\n            else{\\n                st.push(stoi(x));\\n            }\\n        }\\n        // FIND SUM OF THE GIVEN STACK\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931494,
                "title": "stack-solution-c-robot-game",
                "content": "```\\n/*\\nAmazon online assessment has this question named with\\ndifferent headline - \\'Robot Game\\' .   But the question was same.\\n*/\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> st;\\n        for(string s:ops) {\\n            if(s != \"C\" && s != \"D\" && s != \"+\") {\\n                st.push(stoi(s));\\n            } else if(s == \"+\") {\\n                int temp1  = st.top();\\n                st.pop();\\n                int temp2 = st.top();\\n                st.push(temp1);\\n                st.push(temp1+temp2);\\n            } else if(s == \"D\") {\\n                int temp = st.top();\\n                st.push(2*temp);\\n            } else {\\n                st.pop();\\n            }\\n        }\\n        int sum = 0;\\n        while(!st.empty()) {\\n            sum += st.top();\\n            st.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nAmazon online assessment has this question named with\\ndifferent headline - \\'Robot Game\\' .   But the question was same.\\n*/\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> st;\\n        for(string s:ops) {\\n            if(s != \"C\" && s != \"D\" && s != \"+\") {\\n                st.push(stoi(s));\\n            } else if(s == \"+\") {\\n                int temp1  = st.top();\\n                st.pop();\\n                int temp2 = st.top();\\n                st.push(temp1);\\n                st.push(temp1+temp2);\\n            } else if(s == \"D\") {\\n                int temp = st.top();\\n                st.push(2*temp);\\n            } else {\\n                st.pop();\\n            }\\n        }\\n        int sum = 0;\\n        while(!st.empty()) {\\n            sum += st.top();\\n            st.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931376,
                "title": "c-use-stack-to-get-previous-elements-dlc-april10",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> st;\\n        for(auto it: ops){\\n            if(it == \"+\"){\\n                int num1 = st.top(); st.pop();\\n                int num2 = st.top();\\n                st.push(num1);\\n                st.push(num1+num2);\\n            }\\n            \\n            else if(it == \"D\")\\n                st.push(st.top()*2);\\n            \\n            else if(it== \"C\")\\n                st.pop();\\n            \\n            else\\n                st.push(stoi(it));       \\n        }\\n        \\n        //sum up the result\\n        int res = 0;\\n        while(!st.empty()){\\n            res += st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> st;\\n        for(auto it: ops){\\n            if(it == \"+\"){\\n                int num1 = st.top(); st.pop();\\n                int num2 = st.top();\\n                st.push(num1);\\n                st.push(num1+num2);\\n            }\\n            \\n            else if(it == \"D\")\\n                st.push(st.top()*2);\\n            \\n            else if(it== \"C\")\\n                st.pop();\\n            \\n            else\\n                st.push(stoi(it));       \\n        }\\n        \\n        //sum up the result\\n        int res = 0;\\n        while(!st.empty()){\\n            res += st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930818,
                "title": "java-solution-with-a-pointer",
                "content": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int[] scores = new int[ops.length];\\n        int idx = 0;\\n        for (String op : ops) {\\n            if (op.equals(\"+\")) {\\n                scores[idx] = scores[idx - 1] + scores[idx - 2];\\n                idx++;\\n            } else if (op.equals(\"D\")) {\\n                scores[idx] = 2 * scores[idx - 1];\\n                idx++;\\n            } else if (op.equals(\"C\")) {\\n                idx--;\\n                scores[idx] = 0;\\n            } else {\\n                scores[idx] = Integer.parseInt(op);\\n                idx++;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int score : scores) {\\n            ans += score;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int[] scores = new int[ops.length];\\n        int idx = 0;\\n        for (String op : ops) {\\n            if (op.equals(\"+\")) {\\n                scores[idx] = scores[idx - 1] + scores[idx - 2];\\n                idx++;\\n            } else if (op.equals(\"D\")) {\\n                scores[idx] = 2 * scores[idx - 1];\\n                idx++;\\n            } else if (op.equals(\"C\")) {\\n                idx--;\\n                scores[idx] = 0;\\n            } else {\\n                scores[idx] = Integer.parseInt(op);\\n                idx++;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int score : scores) {\\n            ans += score;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930807,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> scores;\\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i]==\"C\"){\\n                scores.pop_back();\\n            }else if(ops[i]==\"+\"){\\n                scores.push_back(scores[scores.size()-1]+scores[scores.size()-2]);\\n            }else if(ops[i]==\"D\"){\\n                scores.push_back(scores[scores.size()-1]*2);\\n            }else{\\n                scores.push_back(stoi(ops[i]));\\n            }\\n        }\\n        return accumulate(scores.begin(),scores.end(),0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> scores;\\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i]==\"C\"){\\n                scores.pop_back();\\n            }else if(ops[i]==\"+\"){\\n                scores.push_back(scores[scores.size()-1]+scores[scores.size()-2]);\\n            }else if(ops[i]==\"D\"){\\n                scores.push_back(scores[scores.size()-1]*2);\\n            }else{\\n                scores.push_back(stoi(ops[i]));\\n            }\\n        }\\n        return accumulate(scores.begin(),scores.end(),0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930609,
                "title": "java-int-array-stack-1ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int[] stack = new int[ops.length];\\n        int i = -1;\\n        int total = 0;\\n        for(String s : ops) {\\n            char first = s.charAt(0);\\n            switch(first) {\\n                case \\'D\\':\\n                    stack[i + 1] = stack[i] << 1;\\n                    i++;\\n                    total += stack[i];\\n                    break;\\n                case \\'+\\':\\n                    stack[i + 1] = stack[i] + stack[i - 1];\\n                    i++;\\n                    total += stack[i];\\n                    break;\\n                case \\'C\\':\\n                    total -= stack[i];\\n                    i--;\\n                    break;\\n                default:                    \\n                    stack[++i] = Integer.parseInt(s);\\n                    total += stack[i];\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int[] stack = new int[ops.length];\\n        int i = -1;\\n        int total = 0;\\n        for(String s : ops) {\\n            char first = s.charAt(0);\\n            switch(first) {\\n                case \\'D\\':\\n                    stack[i + 1] = stack[i] << 1;\\n                    i++;\\n                    total += stack[i];\\n                    break;\\n                case \\'+\\':\\n                    stack[i + 1] = stack[i] + stack[i - 1];\\n                    i++;\\n                    total += stack[i];\\n                    break;\\n                case \\'C\\':\\n                    total -= stack[i];\\n                    i--;\\n                    break;\\n                default:                    \\n                    stack[++i] = Integer.parseInt(s);\\n                    total += stack[i];\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834863,
                "title": "java-simulation-with-help-of-arraylist",
                "content": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n\\n        int Result=0;\\n        List<Integer> list=new ArrayList<>();\\n        list.add(Integer.parseInt(ops[0]));\\n        for(int i=1;i<ops.length;i++)\\n        {\\n            String currOps=ops[i];//get the current operation \\n            if(currOps.equals(\"+\"))//add the two prev values \\n            {\\n                int a=list.get(list.size()-1);\\n                int b=list.get(list.size()-2);\\n                int sum=a+b;\\n                list.add(sum);\\n            }//\\n            \\n            else if(currOps.equals(\"D\"))//double the prev \\n            {\\n                int new_num=list.get(list.size()-1)*2;\\n                list.add(new_num);\\n            }\\n            else if(currOps.equals(\"C\"))//delete the previous if \"C\"\\n            {\\n                list.remove(list.size()-1);\\n            }\\n            \\n            else \\n            {\\n                //definately a number ..\\n                int num=Integer.parseInt(currOps);\\n                list.add(num);\\n            }\\n                }//loop \\n        \\n         for(int val:list)\\n         {\\n             Result+=val;\\n         }\\n        \\n        return Result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n\\n        int Result=0;\\n        List<Integer> list=new ArrayList<>();\\n        list.add(Integer.parseInt(ops[0]));\\n        for(int i=1;i<ops.length;i++)\\n        {\\n            String currOps=ops[i];//get the current operation \\n            if(currOps.equals(\"+\"))//add the two prev values \\n            {\\n                int a=list.get(list.size()-1);\\n                int b=list.get(list.size()-2);\\n                int sum=a+b;\\n                list.add(sum);\\n            }//\\n            \\n            else if(currOps.equals(\"D\"))//double the prev \\n            {\\n                int new_num=list.get(list.size()-1)*2;\\n                list.add(new_num);\\n            }\\n            else if(currOps.equals(\"C\"))//delete the previous if \"C\"\\n            {\\n                list.remove(list.size()-1);\\n            }\\n            \\n            else \\n            {\\n                //definately a number ..\\n                int num=Integer.parseInt(currOps);\\n                list.add(num);\\n            }\\n                }//loop \\n        \\n         for(int val:list)\\n         {\\n             Result+=val;\\n         }\\n        \\n        return Result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726365,
                "title": "c-100-faster-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint calPoints(vector<string>& ops) {\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tfor(auto it: ops){\\n\\t\\t\\t\\tif(it[0]==\\'-\\' || isdigit(it[0])){\\n\\t\\t\\t\\t\\tst.push(stoi(it));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(it==\"+\"){\\n\\t\\t\\t\\t\\tint b=st.top();\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tint a=st.top();\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tst.push(a);\\n\\t\\t\\t\\t\\tst.push(b);\\n\\t\\t\\t\\t\\tst.push(a+b);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(it==\"D\"){\\n\\t\\t\\t\\t\\tint n=st.top();\\n\\t\\t\\t\\t\\tst.push(2*n);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(it==\"C\"){\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint ans=0;\\n\\t\\t\\twhile(!st.empty()){\\n\\t\\t\\t\\t// cout<<st.top()<<\" \";\\n\\t\\t\\t\\tans+=st.top();\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n**\\tIf it was helpful and you like this DO UPVOTE **",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint calPoints(vector<string>& ops) {\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tfor(auto it: ops){\\n\\t\\t\\t\\tif(it[0]==\\'-\\' || isdigit(it[0])){\\n\\t\\t\\t\\t\\tst.push(stoi(it));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1651850,
                "title": "solution-with-vectors-and-stack-c",
                "content": "***With Vectors***\\n\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        int n=ops.size();\\n        vector<int> v;\\n        for(int i=0; i<n; i++){\\n            if(ops[i]==\"+\"){\\n                v.push_back((v[v.size()-2])+(v[v.size()-1])); \\n            }else if(ops[i]==\"C\"){\\n                v.pop_back();\\n            }else if(ops[i]==\"D\"){\\n                v.push_back(v[v.size()-1]*2);\\n            }else{\\n                v.push_back(stoi(ops[i]));\\n            }   \\n        }    \\n        int ans=accumulate(v.begin(),v.end(),0);\\n        return ans;\\n    }\\n};\\n```\\n****With Stack***\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        int val1;\\n        int val2;\\n        int n=ops.size();\\n        stack<int> stk;\\n        for(int i=0; i<n; i++){\\n            if(ops[i]==\"+\"){\\n                val1=stk.top();\\n                stk.pop();\\n                val2=stk.top();\\n                stk.push(val1);\\n                stk.push(val1+val2);\\n            }\\n            else if(ops[i]==\"D\"){\\n                stk.push(stk.top()*2);\\n            }\\n            else if(ops[i]==\"C\"){\\n                stk.pop();\\n            }\\n            else{\\n                stk.push(stoi(ops[i]));\\n            }\\n        }int sum=0;\\n        while(stk.size()!=0){\\n            int val3=stk.top();\\n            stk.pop();\\n            sum +=val3;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n*if found useful upvote*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        int n=ops.size();\\n        vector<int> v;\\n        for(int i=0; i<n; i++){\\n            if(ops[i]==\"+\"){\\n                v.push_back((v[v.size()-2])+(v[v.size()-1])); \\n            }else if(ops[i]==\"C\"){\\n                v.pop_back();\\n            }else if(ops[i]==\"D\"){\\n                v.push_back(v[v.size()-1]*2);\\n            }else{\\n                v.push_back(stoi(ops[i]));\\n            }   \\n        }    \\n        int ans=accumulate(v.begin(),v.end(),0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        int val1;\\n        int val2;\\n        int n=ops.size();\\n        stack<int> stk;\\n        for(int i=0; i<n; i++){\\n            if(ops[i]==\"+\"){\\n                val1=stk.top();\\n                stk.pop();\\n                val2=stk.top();\\n                stk.push(val1);\\n                stk.push(val1+val2);\\n            }\\n            else if(ops[i]==\"D\"){\\n                stk.push(stk.top()*2);\\n            }\\n            else if(ops[i]==\"C\"){\\n                stk.pop();\\n            }\\n            else{\\n                stk.push(stoi(ops[i]));\\n            }\\n        }int sum=0;\\n        while(stk.size()!=0){\\n            int val3=stk.top();\\n            stk.pop();\\n            sum +=val3;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596357,
                "title": "c-vector-based-solution-easy-to-understand",
                "content": "**Complete Code**\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> scores;\\n        for(int i = 0; i < ops.size(); i++){\\n            if(ops[i] != \"C\" && ops[i] != \"D\" && ops[i] != \"+\")\\n                scores.push_back(stoi(ops[i]));\\n            else if(ops[i] == \"C\")\\n                scores.pop_back();\\n            else if(ops[i] == \"D\")\\n                scores.push_back(2 * scores[scores.size() - 1]);\\n            else if(ops[i] == \"+\")\\n                scores.push_back(scores[scores.size() - 2] + scores[scores.size() - 1]);\\n        }\\n        \\n        return accumulate(scores.begin(),scores.end(),0);\\n    }\\n};\\n```\\n**TIME COMPLEXITY\\nO(n)**\\n\\n**SPACE COMPLEXITY\\nO(n)**\\n![image](https://assets.leetcode.com/users/images/4841f4c9-8619-4e9b-9417-1b58217e8f1a_1637880031.128262.png)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        vector<int> scores;\\n        for(int i = 0; i < ops.size(); i++){\\n            if(ops[i] != \"C\" && ops[i] != \"D\" && ops[i] != \"+\")\\n                scores.push_back(stoi(ops[i]));\\n            else if(ops[i] == \"C\")\\n                scores.pop_back();\\n            else if(ops[i] == \"D\")\\n                scores.push_back(2 * scores[scores.size() - 1]);\\n            else if(ops[i] == \"+\")\\n                scores.push_back(scores[scores.size() - 2] + scores[scores.size() - 1]);\\n        }\\n        \\n        return accumulate(scores.begin(),scores.end(),0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580833,
                "title": "easy-python-solution-pretty-straightforward",
                "content": "```\\ndef calPoints(self, ops: List[str]) -> int:\\n        l=[]\\n        for i in range(len(ops)):\\n            if ops[i].lstrip(\"-\").isdigit():\\n                l.append(int(ops[i]))\\n            elif ops[i] == \"C\":\\n                l.pop(len(l)-1)\\n            elif ops[i] == \"D\":\\n                l.append(l[-1]*2)\\n            elif ops[i] == \"+\":\\n                l.append(l[-1]+l[-2])\\n        return sum(l)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef calPoints(self, ops: List[str]) -> int:\\n        l=[]\\n        for i in range(len(ops)):\\n            if ops[i].lstrip(\"-\").isdigit():\\n                l.append(int(ops[i]))\\n            elif ops[i] == \"C\":\\n                l.pop(len(l)-1)\\n            elif ops[i] == \"D\":\\n                l.append(l[-1]*2)\\n            elif ops[i] == \"+\":\\n                l.append(l[-1]+l[-2])\\n        return sum(l)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1259535,
                "title": "c-solution-easy-to-understand-baseball-game",
                "content": "class Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int>st;\\n        for(string s:ops){\\n            if(s==\"+\"){\\n                int top=st.top();\\n                st.pop();\\n                int next_top=top+st.top();\\n                st.push(top);\\n                st.push(next_top);\\n            }\\n            else if(s==\"C\")\\n                st.pop();\\n            else if(s==\"D\"){\\n                st.push(2*st.top());\\n            }\\n            else \\n                st.push(stoi(s));\\n        }\\n        int sum=0;\\n        while(st.size()!=0){\\n            sum+=st.top();\\n            st.pop();\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int>st;\\n        for(string s:ops){\\n            if(s==\"+\"){\\n                int top=st.top();\\n                st.pop();\\n                int next_top=top+st.top();\\n                st.push(top);\\n                st.push(next_top);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 998869,
                "title": "python-o-1-space-solution",
                "content": "So far I haven\\'t seen a constant space solution posted. Most seem to use some extra data structure. This solution is O(1) space assuming the input array doesn\\'t count as extra space. \\n\\nThe idea here is to create a ledger by embedding the additions/deletions in the existing input ops array. For \"D\" and \"+\", simply override the value with the calculated number. For \"C\", override the previous number with an \"X\". Use 2 variables (prev, prev2) to keep track of the previous 2 numbers\\' indices. While looping through the list, make additions/subtractions as needed while updating the previous 2 numbers\\' indices. \\n\\n**Note: this is my raw solution without any optimizations. Feel free to chime in with feedback or optimize further. \\n\\n```\\nclass Solution:\\n    def calPoints(self, ops: List[str]): \\n        ans = prev = prev2 = 0\\n        for i, op in enumerate(ops):\\n            if op == \"C\":\\n                d = -int(ops[prev])\\n                ops[prev] = \"X\"\\n                prev = prev2\\n                while prev2 > 0:\\n                    prev2 -= 1\\n                    if ops[prev2] not in [\"C\", \"X\"]:\\n                        break                \\n            elif op == \"D\":\\n                d = 2 * int(ops[prev])\\n                ops[i] = str(d)\\n            elif op == \"+\":\\n                d = int(ops[prev]) + int(ops[prev2])\\n                ops[i] = str(d)\\n            else:\\n                d = int(ops[i])\\n            ans += d\\n            if op != \"C\":\\n                prev2, prev = prev, i\\n        return ans \\n\\t",
                "solutionTags": [],
                "code": "So far I haven\\'t seen a constant space solution posted. Most seem to use some extra data structure. This solution is O(1) space assuming the input array doesn\\'t count as extra space. \\n\\nThe idea here is to create a ledger by embedding the additions/deletions in the existing input ops array. For \"D\" and \"+\", simply override the value with the calculated number. For \"C\", override the previous number with an \"X\". Use 2 variables (prev, prev2) to keep track of the previous 2 numbers\\' indices. While looping through the list, make additions/subtractions as needed while updating the previous 2 numbers\\' indices. \\n\\n**Note: this is my raw solution without any optimizations. Feel free to chime in with feedback or optimize further. \\n\\n```\\nclass Solution:\\n    def calPoints(self, ops: List[str]): \\n        ans = prev = prev2 = 0\\n        for i, op in enumerate(ops):\\n            if op == \"C\":\\n                d = -int(ops[prev])\\n                ops[prev] = \"X\"\\n                prev = prev2\\n                while prev2 > 0:\\n                    prev2 -= 1\\n                    if ops[prev2] not in [\"C\", \"X\"]:\\n                        break                \\n            elif op == \"D\":\\n                d = 2 * int(ops[prev])\\n                ops[i] = str(d)\\n            elif op == \"+\":\\n                d = int(ops[prev]) + int(ops[prev2])\\n                ops[i] = str(d)\\n            else:\\n                d = int(ops[i])\\n            ans += d\\n            if op != \"C\":\\n                prev2, prev = prev, i\\n        return ans \\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 972468,
                "title": "java-3ms-clean-solution-switch-case-o-n-time-space",
                "content": "Iam using a List of Integers to remove sometimes the last score. Removing last value in List is in O(1).\\n   Approch to iterate over all Strings from ops and check which rule should be executed.\\n   \\n ```\\n  public int calPoints(String[] ops) {\\n        List<Integer> scores = new ArrayList<>();\\n        int totalScore = 0;\\n        int lastElement = 0;\\n        for(String str : ops)\\n        {\\n            switch(str)\\n            {\\n                case \"C\":\\n                    scores.remove(scores.size() -1); \\n                    break;\\n                case \"D\":\\n                    lastElement = scores.get(scores.size() -1);\\n                    scores.add(2 * lastElement); \\n                    break;\\n                case \"+\":\\n                    int secondLast = scores.get(scores.size() -2);\\n                    lastElement = scores.get(scores.size() -1);\\n                    scores.add(secondLast + lastElement);\\n                    break;\\n                default: // Integer value\\n                    scores.add(Integer.parseInt(str));\\n                    break;\\n            }\\n        }\\n        \\n        for(int value : scores) // sum all elements from list together\\n        { \\n            totalScore += value;\\n        }\\n        \\n       return totalScore;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public int calPoints(String[] ops) {\\n        List<Integer> scores = new ArrayList<>();\\n        int totalScore = 0;\\n        int lastElement = 0;\\n        for(String str : ops)\\n        {\\n            switch(str)\\n            {\\n                case \"C\":\\n                    scores.remove(scores.size() -1); \\n                    break;\\n                case \"D\":\\n                    lastElement = scores.get(scores.size() -1);\\n                    scores.add(2 * lastElement); \\n                    break;\\n                case \"+\":\\n                    int secondLast = scores.get(scores.size() -2);\\n                    lastElement = scores.get(scores.size() -1);\\n                    scores.add(secondLast + lastElement);\\n                    break;\\n                default: // Integer value\\n                    scores.add(Integer.parseInt(str));\\n                    break;\\n            }\\n        }\\n        \\n        for(int value : scores) // sum all elements from list together\\n        { \\n            totalScore += value;\\n        }\\n        \\n       return totalScore;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 801816,
                "title": "c-stack-runtime-8-ms-faster-than-84-90-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> ValueStep;\\n        stack<int> Step;\\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i]!=\"C\" && ops[i]!=\"D\" && ops[i]!=\"+\"){\\n                int point=stoi(ops[i]);\\n                if(ValueStep.empty()){\\n                    ValueStep.push(point); \\n                    \\n                    Step.push(point);\\n                }\\n                else{\\n                    int sum=ValueStep.top()+point;\\n                    ValueStep.push(sum);\\n                    \\n                    Step.push(point);\\n                }\\n            }\\n            else if(ops[i]==\"C\"){\\n                int minus=ValueStep.top()-Step.top();\\n                ValueStep.push(minus);\\n                Step.pop();\\n            }\\n            else if(ops[i]==\"D\"){\\n                int Double=Step.top()*2;\\n                ValueStep.push(Double+ValueStep.top());\\n                Step.push(Double);\\n            }\\n            else{\\n                int ValueSteptop=Step.top();\\n                Step.pop();\\n                int sum2step=ValueSteptop+Step.top();\\n                ValueStep.push(sum2step+ValueStep.top());\\n                Step.push(ValueSteptop);\\n                Step.push(sum2step);\\n            }\\n        }\\n        return ValueStep.top();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> ValueStep;\\n        stack<int> Step;\\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i]!=\"C\" && ops[i]!=\"D\" && ops[i]!=\"+\"){\\n                int point=stoi(ops[i]);\\n                if(ValueStep.empty()){\\n                    ValueStep.push(point); \\n                    \\n                    Step.push(point);\\n                }\\n                else{\\n                    int sum=ValueStep.top()+point;\\n                    ValueStep.push(sum);\\n                    \\n                    Step.push(point);\\n                }\\n            }\\n            else if(ops[i]==\"C\"){\\n                int minus=ValueStep.top()-Step.top();\\n                ValueStep.push(minus);\\n                Step.pop();\\n            }\\n            else if(ops[i]==\"D\"){\\n                int Double=Step.top()*2;\\n                ValueStep.push(Double+ValueStep.top());\\n                Step.push(Double);\\n            }\\n            else{\\n                int ValueSteptop=Step.top();\\n                Step.pop();\\n                int sum2step=ValueSteptop+Step.top();\\n                ValueStep.push(sum2step+ValueStep.top());\\n                Step.push(ValueSteptop);\\n                Step.push(sum2step);\\n            }\\n        }\\n        return ValueStep.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747667,
                "title": "simple-c-solution",
                "content": "```\\nint calPoints(vector<string>& ops) {\\n\\tstack<int> stk;\\n\\tint ans = 0;\\n\\tfor(string &s: ops){\\n\\t\\tif(s == \"C\"){\\n\\t\\t\\tans -= stk.top();\\n\\t\\t\\tstk.pop();\\n\\t\\t}else if(s == \"D\"){\\n\\t\\t\\tans += 2 * stk.top();\\n\\t\\t\\tstk.push(2*stk.top());\\n\\t\\t}else if(s == \"+\"){\\n\\t\\t\\tint x = stk.top();stk.pop();\\n\\t\\t\\tint y = stk.top();\\n\\t\\t\\tstk.push(x);\\n\\t\\t\\tstk.push(x+y);\\n\\t\\t\\tans += x+y;\\n\\t\\t}else{\\n\\t\\t\\tint x = stoi(s);\\n\\t\\t\\tstk.push(x);\\n\\t\\t\\tans += x;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint calPoints(vector<string>& ops) {\\n\\tstack<int> stk;\\n\\tint ans = 0;\\n\\tfor(string &s: ops){\\n\\t\\tif(s == \"C\"){\\n\\t\\t\\tans -= stk.top();\\n\\t\\t\\tstk.pop();\\n\\t\\t}else if(s == \"D\"){\\n\\t\\t\\tans += 2 * stk.top();\\n\\t\\t\\tstk.push(2*stk.top());\\n\\t\\t}else if(s == \"+\"){\\n\\t\\t\\tint x = stk.top();stk.pop();\\n\\t\\t\\tint y = stk.top();\\n\\t\\t\\tstk.push(x);\\n\\t\\t\\tstk.push(x+y);\\n\\t\\t\\tans += x+y;\\n\\t\\t}else{\\n\\t\\t\\tint x = stoi(s);\\n\\t\\t\\tstk.push(x);\\n\\t\\t\\tans += x;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 667432,
                "title": "python-simple-fast",
                "content": "```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        a=[]\\n        for i in ops:\\n            if i==\\'C\\':\\n                a.pop()\\n            elif i==\\'D\\':\\n                a.append(a[-1]*2)\\n            elif i==\\'+\\':\\n                a.append(a[-1]+a[-2])\\n            else:\\n                a.append(int(i))\\n        return sum(a)``\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, ops: List[str]) -> int:\\n        a=[]\\n        for i in ops:\\n            if i==\\'C\\':\\n                a.pop()\\n            elif i==\\'D\\':\\n                a.append(a[-1]*2)\\n            elif i==\\'+\\':\\n                a.append(a[-1]+a[-2])\\n            else:\\n                a.append(int(i))\\n        return sum(a)``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617848,
                "title": "java-0-ms-beats-100",
                "content": "I know it\\'s not the best coding style, but I couldn\\'t help myself to beat the 1 ms record for this problem. I changed the stack to an array with a pointer, used a switch statement, and considered only the first character of each string. Also, I eliminated some temporary variables during the D and + operations. The operation for adding a number requires a temp variable since parsing string to int is an O(num digits) operation.\\n```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int sum = 0;\\n        int[] arr = new int[ops.length];\\n        int index = -1;\\n        for (String s : ops) {\\n            switch (s.charAt(0)) {\\n                case \\'C\\': sum -= arr[index--]; break;\\n                case \\'D\\': sum += arr[index] * 2; arr[++index] = arr[index - 1] * 2; break;\\n                case \\'+\\': sum += arr[index] + arr[index - 1]; arr[++index] = arr[index - 1] + arr[index - 2]; break;\\n                default: int n = Integer.parseInt(s); sum += n; arr[++index] = n;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int sum = 0;\\n        int[] arr = new int[ops.length];\\n        int index = -1;\\n        for (String s : ops) {\\n            switch (s.charAt(0)) {\\n                case \\'C\\': sum -= arr[index--]; break;\\n                case \\'D\\': sum += arr[index] * 2; arr[++index] = arr[index - 1] * 2; break;\\n                case \\'+\\': sum += arr[index] + arr[index - 1]; arr[++index] = arr[index - 1] + arr[index - 2]; break;\\n                default: int n = Integer.parseInt(s); sum += n; arr[++index] = n;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584311,
                "title": "c-solution-beats-100-time-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int>s;\\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i]==\"+\"){\\n                int first = s.top();\\n                s.pop();\\n                int second = s.top();\\n                int res = first + second;\\n                s.push(first);\\n                s.push(res);\\n                continue;\\n            }\\n            if(ops[i]==\"D\"){\\n                s.push(2*s.top());\\n                continue;\\n            }\\n            if(ops[i]==\"C\"){\\n                s.pop();\\n                continue;\\n            }\\n            else s.push(stoi(ops[i]));\\n        }\\n       int ans = 0;\\n        while(!s.empty()){\\n            ans += s.top();\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int>s;\\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i]==\"+\"){\\n                int first = s.top();\\n                s.pop();\\n                int second = s.top();\\n                int res = first + second;\\n                s.push(first);\\n                s.push(res);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 538668,
                "title": "java-linkedlist",
                "content": "```\\npublic int calPoints(String[] ops) {\\n        LinkedList<Integer> l = new LinkedList<>();\\n        for (String s : ops) {\\n            if (s.equals(\"C\")) {\\n                l.removeLast();\\n            } else if (s.equals(\"D\") ){\\n                l.add(l.getLast() * 2);\\n            } else if (s.equals(\"+\")) {\\n                l.add(l.get(l.size() - 1) + l.get(l.size() - 2));\\n            } else {\\n                l.add(Integer.parseInt(s));\\n            }\\n        }\\n        int res = 0;\\n        for (int i : l) res += i;\\n        return res;\\n    }\\n```\\nRef: https://leetcode.com/problems/baseball-game/discuss/107860/Verbose-Java-solution-LinkedList\\n",
                "solutionTags": [],
                "code": "```\\npublic int calPoints(String[] ops) {\\n        LinkedList<Integer> l = new LinkedList<>();\\n        for (String s : ops) {\\n            if (s.equals(\"C\")) {\\n                l.removeLast();\\n            } else if (s.equals(\"D\") ){\\n                l.add(l.getLast() * 2);\\n            } else if (s.equals(\"+\")) {\\n                l.add(l.get(l.size() - 1) + l.get(l.size() - 2));\\n            } else {\\n                l.add(Integer.parseInt(s));\\n            }\\n        }\\n        int res = 0;\\n        for (int i : l) res += i;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376293,
                "title": "100-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int[] scores = new int[ops.length];\\n        \\n        int sum = 0;\\n        int index = 0;\\n        for (int i = 0; i < ops.length; i++) {\\n            if (ops[i].equals(\"+\")) {\\n                scores[index] = scores[index - 1] + scores[index - 2];\\n                sum += scores[index];\\n                index++;\\n            } else if (ops[i].equals(\"D\")) {\\n                scores[index] = 2 * scores[index - 1];\\n                sum += scores[index];\\n                index++;\\n            } else if (ops[i].equals(\"C\")) {\\n                sum -= scores[index - 1];\\n                index--;\\n            } else {\\n                scores[index] = Integer.parseInt(ops[i]);\\n                sum += scores[index];\\n                index++;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int[] scores = new int[ops.length];\\n        \\n        int sum = 0;\\n        int index = 0;\\n        for (int i = 0; i < ops.length; i++) {\\n            if (ops[i].equals(\"+\")) {\\n                scores[index] = scores[index - 1] + scores[index - 2];\\n                sum += scores[index];\\n                index++;\\n            } else if (ops[i].equals(\"D\")) {\\n                scores[index] = 2 * scores[index - 1];\\n                sum += scores[index];\\n                index++;\\n            } else if (ops[i].equals(\"C\")) {\\n                sum -= scores[index - 1];\\n                index--;\\n            } else {\\n                scores[index] = Integer.parseInt(ops[i]);\\n                sum += scores[index];\\n                index++;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350921,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> scores;\\n        int sum = 0;\\n        for(auto s: ops){\\n            if(s == \"+\"){\\n                int x = scores.top();\\n                scores.pop();\\n                int y = scores.top();\\n                sum += x + y;\\n                scores.push(x);\\n                scores.push(x + y);\\n            } else if(s == \"D\"){\\n                int x = scores.top();\\n                sum += x * 2;\\n                scores.push(x * 2);\\n            } else if(s == \"C\"){\\n                sum -= scores.top();\\n                scores.pop();\\n            } else {\\n                int x = stoi(s);\\n                scores.push(x);\\n                sum += x;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& ops) {\\n        stack<int> scores;\\n        int sum = 0;\\n        for(auto s: ops){\\n            if(s == \"+\"){\\n                int x = scores.top();\\n                scores.pop();\\n                int y = scores.top();\\n                sum += x + y;\\n                scores.push(x);\\n                scores.push(x + y);\\n            } else if(s == \"D\"){\\n                int x = scores.top();\\n                sum += x * 2;\\n                scores.push(x * 2);\\n            } else if(s == \"C\"){\\n                sum -= scores.top();\\n                scores.pop();\\n            } else {\\n                int x = stoi(s);\\n                scores.push(x);\\n                sum += x;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201097,
                "title": "java-simple-solution-beats-98-91-using-linkedlist",
                "content": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int sumPoints = 0;\\n        int len = ops.length;\\n        LinkedList<Integer> result = new LinkedList<>();\\n        for(int i=0;i<len;i++){\\n            String t = ops[i];\\n            switch(t){\\n                case \"C\":{\\n                    sumPoints-=result.removeLast();\\n                    break;\\n                }\\n                case \"D\":{\\n                    sumPoints+=result.getLast()*2;\\n                    result.addLast(result.getLast()*2);\\n                    break;\\n                }\\n                case \"+\":{\\n                    int x1 = result.removeLast();\\n                    int x2 = result.getLast();\\n                    result.addLast(x1);\\n                    sumPoints+=x1;\\n                    sumPoints+=x2;\\n                    result.addLast(x1+x2);\\n                    break;\\n                }\\n                default:{\\n                    int currentPoints = Integer.parseInt(t);\\n                    sumPoints+=currentPoints;\\n                    result.addLast(currentPoints);\\n                    break;\\n                }\\n            }\\n        }\\n        return sumPoints;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int sumPoints = 0;\\n        int len = ops.length;\\n        LinkedList<Integer> result = new LinkedList<>();\\n        for(int i=0;i<len;i++){\\n            String t = ops[i];\\n            switch(t){\\n                case \"C\":{\\n                    sumPoints-=result.removeLast();\\n                    break;\\n                }\\n                case \"D\":{\\n                    sumPoints+=result.getLast()*2;\\n                    result.addLast(result.getLast()*2);\\n                    break;\\n                }\\n                case \"+\":{\\n                    int x1 = result.removeLast();\\n                    int x2 = result.getLast();\\n                    result.addLast(x1);\\n                    sumPoints+=x1;\\n                    sumPoints+=x2;\\n                    result.addLast(x1+x2);\\n                    break;\\n                }\\n                default:{\\n                    int currentPoints = Integer.parseInt(t);\\n                    sumPoints+=currentPoints;\\n                    result.addLast(currentPoints);\\n                    break;\\n                }\\n            }\\n        }\\n        return sumPoints;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193802,
                "title": "java-concise-solution-beats-93-using-inbuit-stack",
                "content": "public int calPoints(String[] ops) {\\n        Stack<Integer> stack = new Stack<>();\\n        int sum =0;\\n        for(String s:ops){\\n           \\n            if(s.charAt(0)==\\'C\\') {\\n                int x = stack.pop();\\n                sum -= x;\\n            }\\n            else if(s.charAt(0)==\\'D\\'){\\n                int p = stack.peek();\\n                stack.push(2*p);\\n                sum += 2*p;\\n                \\n            }\\n            else if(s.charAt(0)==\\'+\\' ){\\n                int a = stack.pop(), b= stack.peek();\\n                sum += a+b;\\n                stack.push(a);\\n                stack.push(a+b);\\n            }\\n            else{\\n                int x= Integer.parseInt(s);\\n                \\n                stack.push(x);\\n                sum += x;\\n            }\\n             //System.out.println(sum);\\n            \\n        }  \\n\\t\\t\\n\\treturn sum;\\n        \\n    }\\n\\t",
                "solutionTags": [],
                "code": "public int calPoints(String[] ops) {\\n        Stack<Integer> stack = new Stack<>();\\n        int sum =0;\\n        for(String s:ops){\\n           \\n            if(s.charAt(0)==\\'C\\') {\\n                int x = stack.pop();\\n                sum -= x;\\n            }\\n            else if(s.charAt(0)==\\'D\\'){\\n                int p = stack.peek();\\n                stack.push(2*p);\\n                sum += 2*p;\\n                \\n            }\\n            else if(s.charAt(0)==\\'+\\' ){\\n                int a = stack.pop(), b= stack.peek();\\n                sum += a+b;\\n                stack.push(a);\\n                stack.push(a+b);\\n            }\\n            else{\\n                int x= Integer.parseInt(s);\\n                \\n                stack.push(x);\\n                sum += x;\\n            }\\n             //System.out.println(sum);\\n            \\n        }  \\n\\t\\t\\n\\treturn sum;\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 137022,
                "title": "c-solution-using-list",
                "content": "```\\n public int CalPoints(string[] ops)\\n        {\\n            int sum = 0;\\n            List<int> valids = new List<int>();\\n\\n            foreach (var op in ops)\\n            {\\n                int move;\\n\\n                switch (op)\\n                {\\n                    case \"C\": move = -valids[valids.Count - 1];    break;\\n                    case \"D\": move = 2 * valids[valids.Count - 1]; break;\\n                    case \"+\": move = valids[valids.Count - 1] + valids[valids.Count - 2]; break;\\n                    default : move = int.Parse(op); break;\\n                }\\n\\n                sum += move;\\n\\n                if (op == \"C\") valids.RemoveAt(valids.Count - 1);\\n                else valids.Add(move);                                \\n            }\\n\\n            return sum;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n public int CalPoints(string[] ops)\\n        {\\n            int sum = 0;\\n            List<int> valids = new List<int>();\\n\\n            foreach (var op in ops)\\n            {\\n                int move;\\n\\n                switch (op)\\n                {\\n                    case \"C\": move = -valids[valids.Count - 1];    break;\\n                    case \"D\": move = 2 * valids[valids.Count - 1]; break;\\n                    case \"+\": move = valids[valids.Count - 1] + valids[valids.Count - 2]; break;\\n                    default : move = int.Parse(op); break;\\n                }\\n\\n                sum += move;\\n\\n                if (op == \"C\") valids.RemoveAt(valids.Count - 1);\\n                else valids.Add(move);                                \\n            }\\n\\n            return sum;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107886,
                "title": "golang-solution-in-3ms",
                "content": "```\\nimport (\\n    \"strconv\"\\n)\\n\\nfunc calPoints(ops []string) int {\\n    stack := make([]int, len(ops))\\n    top := 0\\n\\n    for i := 0; i < len(ops); i++ {\\n        op := ops[i]\\n        switch op {\\n        case \"+\":\\n            last1 := stack[top-1]\\n            last2 := stack[top-2]\\n            stack[top] = last1 + last2\\n            top += 1\\n        case \"D\":\\n            last1 := stack[top-1]\\n            stack[top] = last1 * 2\\n            top += 1\\n        case \"C\":\\n            top -= 1\\n        default:\\n            stack[top], _ = strconv.Atoi(op)\\n            top += 1\\n        }\\n    }\\n\\n    points := 0\\n    for i := 0; i < top; i++ {\\n        points += stack[i]\\n    }\\n    return points\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport (\\n    \"strconv\"\\n)\\n\\nfunc calPoints(ops []string) int {\\n    stack := make([]int, len(ops))\\n    top := 0\\n\\n    for i := 0; i < len(ops); i++ {\\n        op := ops[i]\\n        switch op {\\n        case \"+\":\\n            last1 := stack[top-1]\\n            last2 := stack[top-2]\\n            stack[top] = last1 + last2\\n            top += 1\\n        case \"D\":\\n            last1 := stack[top-1]\\n            stack[top] = last1 * 2\\n            top += 1\\n        case \"C\":\\n            top -= 1\\n        default:\\n            stack[top], _ = strconv.Atoi(op)\\n            top += 1\\n        }\\n    }\\n\\n    points := 0\\n    for i := 0; i < top; i++ {\\n        points += stack[i]\\n    }\\n    return points\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 107855,
                "title": "very-easy-to-understand-solution-using-stack",
                "content": "basic idea is to store a number into stack so that you can use it in future reference since stack has LIFO properties.\\ntwo cases to consider:\\n1. if you get a number from ops[i], implement a function called (isdigit) by using try catch to check if a string element is digit. Since string array doesn't have the isDigit method like Cha. However, there is no point to put it as char array since if a user passed in a negative value or not a single digit its time consuming to check and add it to sum.\\n2. before u perform each of the \"C\", \"D\", \"+\" make sure u check if a stack is empty or not if the stack is empty you don't need to do anything;  but for the \"+\" method you need to check twice since it requires last two score. if the second time u checked is empty simply use the first time score and add to the sum and ofcourse added it back after you pop it\\n\\n      \\n     public int calPoints(String[] ops) {\\n        if(ops == null || ops.length == 0){\\n            return  0;}\\n\\n        Deque<Integer> stack = new LinkedList<>();\\n        int sum = 0;\\n        //has to use .equals not ==\\n        for(String ccc: ops){\\n            if(isdigit(ccc)){\\n                int temp = Integer.parseInt(ccc);\\n                stack.offerFirst(temp);\\n                sum += temp;\\n            }else if(ccc.equals(\"D\")){\\n                if(!stack.isEmpty()){\\n                    int c = stack.peekFirst()*2;\\n                    sum += c;\\n                    stack.offerFirst(c);\\n                }\\n            }else if(ccc.equals(\"C\")){\\n                if(!stack.isEmpty()){\\n                    int remove = stack.removeFirst();\\n                    sum -= remove;\\n                }\\n            }else if(ccc.equals(\"+\")){\\n                if(!stack.isEmpty()){  \\n                    int addmid = stack.removeFirst();\\n                    if(!stack.isEmpty()){\\n                        int addfirst = stack.removeFirst();\\n                        int curr = addfirst + addmid;\\n                        sum += curr;\\n                        stack.offerFirst(addfirst);\\n                        stack.offerFirst(addmid);\\n                        stack.offerFirst(curr);\\n                        continue;\\n                    }\\n                    sum += addmid;\\n                    stack.offerFirst(addmid);\\n                    stack.offerFirst(addmid);\\n                }\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n    \\n  \\n    private boolean isdigit(String ops){\\n        try{\\n            Integer.parseInt(ops);\\n            return true;\\n        }catch(Exception ex){\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Stack",
                    "Queue"
                ],
                "code": "basic idea is to store a number into stack so that you can use it in future reference since stack has LIFO properties.\\ntwo cases to consider:\\n1. if you get a number from ops[i], implement a function called (isdigit) by using try catch to check if a string element is digit. Since string array doesn't have the isDigit method like Cha. However, there is no point to put it as char array since if a user passed in a negative value or not a single digit its time consuming to check and add it to sum.\\n2. before u perform each of the \"C\", \"D\", \"+\" make sure u check if a stack is empty or not if the stack is empty you don't need to do anything;  but for the \"+\" method you need to check twice since it requires last two score. if the second time u checked is empty simply use the first time score and add to the sum and ofcourse added it back after you pop it\\n\\n      \\n     public int calPoints(String[] ops) {\\n        if(ops == null || ops.length == 0){\\n            return  0;}\\n\\n        Deque<Integer> stack = new LinkedList<>();\\n        int sum = 0;\\n        //has to use .equals not ==\\n        for(String ccc: ops){\\n            if(isdigit(ccc)){\\n                int temp = Integer.parseInt(ccc);\\n                stack.offerFirst(temp);\\n                sum += temp;\\n            }else if(ccc.equals(\"D\")){\\n                if(!stack.isEmpty()){\\n                    int c = stack.peekFirst()*2;\\n                    sum += c;\\n                    stack.offerFirst(c);\\n                }\\n            }else if(ccc.equals(\"C\")){\\n                if(!stack.isEmpty()){\\n                    int remove = stack.removeFirst();\\n                    sum -= remove;\\n                }\\n            }else if(ccc.equals(\"+\")){\\n                if(!stack.isEmpty()){  \\n                    int addmid = stack.removeFirst();\\n                    if(!stack.isEmpty()){\\n                        int addfirst = stack.removeFirst();\\n                        int curr = addfirst + addmid;\\n                        sum += curr;\\n                        stack.offerFirst(addfirst);\\n                        stack.offerFirst(addmid);\\n                        stack.offerFirst(curr);\\n                        continue;\\n                    }\\n                    sum += addmid;\\n                    stack.offerFirst(addmid);\\n                    stack.offerFirst(addmid);\\n                }\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n    \\n  \\n    private boolean isdigit(String ops){\\n        try{\\n            Integer.parseInt(ops);\\n            return true;\\n        }catch(Exception ex){\\n            return false;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 107858,
                "title": "straightforward-java-with-list",
                "content": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int score = 0;\\n        List<Integer> ls = new ArrayList<Integer>();\\n        for (int i = 0; i < ops.length; i++) {\\n            String s = ops[i];\\n            if (s.equals(\"+\")) {\\n            \\tint num = 0;\\n            \\tfor (int ii = 0, il = ls.size() - 1; ii < 2 && il >= 0; ii++, il--)\\n            \\t\\tnum += ls.get(il);\\n            \\tscore += num;\\n            \\tls.add(num);\\n            } else if (s.equals(\"C\")) {\\n            \\tint num = ls.get(ls.size() - 1);\\n            \\tscore -= num;\\n            \\tls.remove(ls.size() - 1);\\n            } else if (s.equals(\"D\")) {\\n            \\tint num = ls.get(ls.size() - 1) * 2;\\n            \\tscore += num;\\n            \\tls.add(num);\\n            } else {\\n            \\tint num = Integer.valueOf(s);\\n            \\tscore += num;\\n            \\tls.add(num);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        int score = 0;\\n        List<Integer> ls = new ArrayList<Integer>();\\n        for (int i = 0; i < ops.length; i++) {\\n            String s = ops[i];\\n            if (s.equals(\"+\")) {\\n            \\tint num = 0;\\n            \\tfor (int ii = 0, il = ls.size() - 1; ii < 2 && il >= 0; ii++, il--)\\n            \\t\\tnum += ls.get(il);\\n            \\tscore += num;\\n            \\tls.add(num);\\n            } else if (s.equals(\"C\")) {\\n            \\tint num = ls.get(ls.size() - 1);\\n            \\tscore -= num;\\n            \\tls.remove(ls.size() - 1);\\n            } else if (s.equals(\"D\")) {\\n            \\tint num = ls.get(ls.size() - 1) * 2;\\n            \\tscore += num;\\n            \\tls.add(num);\\n            } else {\\n            \\tint num = Integer.valueOf(s);\\n            \\tscore += num;\\n            \\tls.add(num);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092964,
                "title": "baseball-game-using-java-99-space-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int calPoints(String[] op) {\\n        ArrayList<Integer> a=new ArrayList<>();\\n        int sum=0;\\n        for(int i=0;i<op.length;i++)\\n        {\\n            if(Character.isDigit(op[i].charAt(0)))\\n            {\\n                a.add(Integer.parseInt(op[i]));\\n            }\\n            else if(op[i].charAt(0)==\\'-\\')\\n            {\\n                a.add(Integer.parseInt(op[i]));\\n            }\\n            else if(op[i].equals(\"D\"))\\n            {\\n                a.add(a.get(a.size()-1)*2);                \\n            }\\n            else if(op[i].equals(\"C\"))\\n            {\\n                a.remove(a.size()-1);\\n            }\\n            else if(op[i].equals(\"+\"))\\n            {\\n                a.add(a.get(a.size()-1)+a.get(a.size()-2));\\n            }        \\n        }\\n        for(int i:a)\\n        {\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] op) {\\n        ArrayList<Integer> a=new ArrayList<>();\\n        int sum=0;\\n        for(int i=0;i<op.length;i++)\\n        {\\n            if(Character.isDigit(op[i].charAt(0)))\\n            {\\n                a.add(Integer.parseInt(op[i]));\\n            }\\n            else if(op[i].charAt(0)==\\'-\\')\\n            {\\n                a.add(Integer.parseInt(op[i]));\\n            }\\n            else if(op[i].equals(\"D\"))\\n            {\\n                a.add(a.get(a.size()-1)*2);                \\n            }\\n            else if(op[i].equals(\"C\"))\\n            {\\n                a.remove(a.size()-1);\\n            }\\n            else if(op[i].equals(\"+\"))\\n            {\\n                a.add(a.get(a.size()-1)+a.get(a.size()-2));\\n            }        \\n        }\\n        for(int i:a)\\n        {\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957572,
                "title": "one-traversal-stack-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        stack<int>st;\\n        int sum=0;\\n        for(int i=0;i<operations.size();i++){\\n            if(operations[i]==\"D\"){\\n                int x=st.top()*2;\\n                st.push(x);\\n                sum=sum+st.top();\\n            }\\n            else if(operations[i]==\"C\"){\\n             sum=sum-st.top();\\n             st.pop();\\n            }\\n            else if(operations[i]==\"+\"){\\n                int temp=st.top();\\n                st.pop();\\n                int y=st.top()+temp;\\n                st.push(temp);\\n                st.push(y);\\n                sum=sum+st.top();\\n\\n            }\\n            else{\\n                st.push(stoi(operations[i]));\\n                sum=sum+st.top();\\n            }\\n        }\\n     return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        stack<int>st;\\n        int sum=0;\\n        for(int i=0;i<operations.size();i++){\\n            if(operations[i]==\"D\"){\\n                int x=st.top()*2;\\n                st.push(x);\\n                sum=sum+st.top();\\n            }\\n            else if(operations[i]==\"C\"){\\n             sum=sum-st.top();\\n             st.pop();\\n            }\\n            else if(operations[i]==\"+\"){\\n                int temp=st.top();\\n                st.pop();\\n                int y=st.top()+temp;\\n                st.push(temp);\\n                st.push(y);\\n                sum=sum+st.top();\\n\\n            }\\n            else{\\n                st.push(stoi(operations[i]));\\n                sum=sum+st.top();\\n            }\\n        }\\n     return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831473,
                "title": "simple-java-solution",
                "content": "Approach\\n\\n\\nThis Java code defines a class called Solution with a method calPoints that calculates the sum of valid points based on a list of operations. The operations are represented as an array of strings op. The operations can be of four types:\\n\\n* Integer: Represents a valid point, and it is pushed onto the stack.\\n* \"C\": Represents an invalid operation and removes the last valid point from the stack.\\n* \"D\": Represents a double operation, where the last valid point is doubled and pushed onto the stack.\\n* \"+\": Represents an addition operation, where the last two valid points are summed, and the result is pushed onto the stack.\\n\\nLet\\'s go through the code step by step:\\n\\n1.The method calPoints takes the op array as input and initializes an empty stack st to hold the valid points.\\n\\n2.The code then iterates through each element of the op array using a for-loop.\\n3. For each element, it checks the type of operation:\\n\\n * If the operation is \"C\" (char at index 0), and the stack is not empty, it means we need to remove the last valid point. Thus, the last element is popped from the stack using st.pop().\\n * If the operation is \"D\", it means we need to double the last valid point and push it onto the stack. This is done by popping the last element from the stack (st.peek()) and pushing its doubled value (2 * st.peek()).\\n * If the operation is \"+\", it means we need to add the last two valid points and push the result onto the stack. To achieve this, the last two elements are popped from the stack, their sum is calculated, and the three elements (last two popped and the sum) are pushed back onto the stack in the same order.\\n * If the operation is none of the above (\"C\", \"D\", or \"+\"), it means the operation represents a valid point (integer). In this case, the integer value is parsed from the string (Integer.parseInt(op[i])) and pushed onto the stack.\\n \\n 4.After processing all the operations, the code proceeds to calculate the final sum of all valid points stored in the stack. It pops elements from the stack one by one and adds them to the ans variable.\\n\\n5.Finally, the method returns the sum (ans) as the result.\\n\\nThis code efficiently processes the list of operations and calculates the sum of valid points using a stack, which is a suitable data structure for this problem since it involves the concept of \"last valid point\" and its potential removal or duplication.\\n\\nComplexity\\n\\nTime Complexity:\\n\\nThe code iterates through each element in the op array once using a for-loop. The loop runs op.length times.\\nFor each operation, the time complexity of processing it is constant, as the operations on the stack (push, pop, peek) are all O(1) operations.\\nTherefore, the overall time complexity of the code is O(N), where N is the length of the op array.\\n\\nSpace Complexity:\\n\\nThe space complexity is determined by the space used by the stack st, which holds the valid points during the processing of the operations.\\nIn the worst case, the stack could store all the valid points present in the op array (when there are no \"C\" operations). In this case, the space complexity would be O(N).\\nHowever, note that the stack would not store more than N elements at any point in time since each \"C\" operation removes one valid point. Therefore, the space complexity in the average case would be less than O(N).\\nThus, the space complexity of the code is O(N) on average and in the worst case.\\n\\n```\\nclass Solution {\\n    public int calPoints(String[] op) {\\n        Stack<Integer> st = new Stack<>();\\n        for(int i = 0;i<op.length;i++){\\n            if(op[i].charAt(0) == \\'C\\' && st.empty()!=true){st.pop();}\\n            else if(op[i].charAt(0) == \\'D\\' ){st.push(2*st.peek());}\\n            else if(op[i].charAt(0) ==\\'+\\'){\\n                int v2 = st.pop();\\n                int v1 = st.pop();\\n                int v3 = v1+v2;\\n                st.push(v1);\\n                st.push(v2);\\n                st.push(v3);\\n            }\\n            else if(op[i].charAt(0) != \\'C\\'){\\n                st.push(Integer.parseInt(op[i]));\\n            }\\n        }\\n        int ans = 0;\\n        while(st.empty()!=true){\\n            ans = ans + st.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] op) {\\n        Stack<Integer> st = new Stack<>();\\n        for(int i = 0;i<op.length;i++){\\n            if(op[i].charAt(0) == \\'C\\' && st.empty()!=true){st.pop();}\\n            else if(op[i].charAt(0) == \\'D\\' ){st.push(2*st.peek());}\\n            else if(op[i].charAt(0) ==\\'+\\'){\\n                int v2 = st.pop();\\n                int v1 = st.pop();\\n                int v3 = v1+v2;\\n                st.push(v1);\\n                st.push(v2);\\n                st.push(v3);\\n            }\\n            else if(op[i].charAt(0) != \\'C\\'){\\n                st.push(Integer.parseInt(op[i]));\\n            }\\n        }\\n        int ans = 0;\\n        while(st.empty()!=true){\\n            ans = ans + st.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808682,
                "title": "easy-brute-force-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConsider the input vector:\\n\\n```\\nvector<string> op = {\"5\", \"2\", \"C\", \"D\", \"+\"};\\n```\\n\\nLet\\'s trace the code with this example:\\n\\n1. Initialize an empty vector \"ans\" to store the points/scores.\\n\\n2. Loop through the \"op\" vector:\\n\\n   - For \"op[0] = \\'5\\'\":\\n     - Convert the string to an integer and push it into the \"ans\" vector: `ans = {5}`.\\n\\n   - For \"op[1] = \\'2\\'\":\\n     - Convert the string to an integer and push it into the \"ans\" vector: `ans = {5, 2}`.\\n\\n   - For \"op[2] = \\'C\\'\":\\n     - Remove the last element from the \"ans\" vector (remove \"2\"): `ans = {5}`.\\n\\n   - For \"op[3] = \\'D\\'\":\\n     - Get the last element from the \"ans\" vector (5), double it (2*5 = 10), and push it into the \"ans\" vector: `ans = {5, 10}`.\\n\\n   - For \"op[4] = \\'+\\'\":\\n     - Get the last two elements from the \"ans\" vector (10 and 5), add them (10 + 5 = 15), and push the sum into the \"ans\" vector: `ans = {5, 10, 15}`.\\n\\n3. Calculate the final result by summing up all the elements in the \"ans\" vector: `result = 5 + 10 + 15 = 30`.\\n\\n4. Return the result (30).\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& op) {\\n        vector<int> ans;\\n\\n        for(int i = 0; i < op.size(); i++){\\n            if(op[i] == \"C\"){\\n                ans.pop_back();\\n            }\\n            else if(op[i] == \"D\"){\\n                int val = ans.back();\\n                ans.push_back(2*val);\\n            }\\n            else if(op[i] == \"+\"){\\n                int val1 = ans.back();\\n                ans.pop_back();\\n                int val2 = ans.back();\\n                ans.push_back(val1);\\n                ans.push_back(val1 + val2);\\n            }\\n            else{\\n                int j  = 0;\\n                int tempVal = 0;\\n                bool flag = false;\\n                if(op[i][j] == \\'-\\'){\\n                    flag = true;\\n                    j++;\\n                }\\n                while(j < op[i].size()){\\n                    int res = op[i][j] - 48;\\n                    tempVal = tempVal * 10 + res;\\n                    j++;\\n                }\\n                if(flag == true)\\n                    tempVal = (-1) * tempVal;\\n                ans.push_back(tempVal);\\n            }\\n        }\\n        int result = 0;\\n        for(auto it : ans){\\n            result += it;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nvector<string> op = {\"5\", \"2\", \"C\", \"D\", \"+\"};\\n```\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& op) {\\n        vector<int> ans;\\n\\n        for(int i = 0; i < op.size(); i++){\\n            if(op[i] == \"C\"){\\n                ans.pop_back();\\n            }\\n            else if(op[i] == \"D\"){\\n                int val = ans.back();\\n                ans.push_back(2*val);\\n            }\\n            else if(op[i] == \"+\"){\\n                int val1 = ans.back();\\n                ans.pop_back();\\n                int val2 = ans.back();\\n                ans.push_back(val1);\\n                ans.push_back(val1 + val2);\\n            }\\n            else{\\n                int j  = 0;\\n                int tempVal = 0;\\n                bool flag = false;\\n                if(op[i][j] == \\'-\\'){\\n                    flag = true;\\n                    j++;\\n                }\\n                while(j < op[i].size()){\\n                    int res = op[i][j] - 48;\\n                    tempVal = tempVal * 10 + res;\\n                    j++;\\n                }\\n                if(flag == true)\\n                    tempVal = (-1) * tempVal;\\n                ans.push_back(tempVal);\\n            }\\n        }\\n        int result = 0;\\n        for(auto it : ans){\\n            result += it;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774602,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        res=[]\\n        for i in operations:\\n            if i==\"C\":\\n                res.pop()\\n            elif i==\"D\":\\n                res.append(2*(res[len(res)-1]))\\n            elif i==\"+\":\\n                res.append(res[len(res)-1]+res[len(res)-2])\\n            else:\\n                res.append(int(i))\\n        return sum(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        res=[]\\n        for i in operations:\\n            if i==\"C\":\\n                res.pop()\\n            elif i==\"D\":\\n                res.append(2*(res[len(res)-1]))\\n            elif i==\"+\":\\n                res.append(res[len(res)-1]+res[len(res)-2])\\n            else:\\n                res.append(int(i))\\n        return sum(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684921,
                "title": "stack-solution-beats-98",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack = []\\n        for operation in operations:\\n            if operation == \\'+\\':\\n                stack.append(stack[-1] + stack[-2])\\n            elif operation == \\'D\\':\\n                stack.append(stack[-1]*2)\\n            elif operation == \\'C\\':\\n                stack.pop(-1)\\n            else:\\n                stack.append(int(operation))\\n        return sum(stack)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack = []\\n        for operation in operations:\\n            if operation == \\'+\\':\\n                stack.append(stack[-1] + stack[-2])\\n            elif operation == \\'D\\':\\n                stack.append(stack[-1]*2)\\n            elif operation == \\'C\\':\\n                stack.pop(-1)\\n            else:\\n                stack.append(int(operation))\\n        return sum(stack)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570661,
                "title": "javascritp-basic-knowledge-solution",
                "content": "# Intuition\\n    How to do with less complexity\\n\\n# Approach\\n    1.Create a new Array for inserting the values\\n    2.Inside a loop change the strings value of numbers to Integers\\n    3.Write conditions for the the operations.\\n    4.Find the sum\\n\\n# Complexity\\n- Time complexity:\\n    The time complexity of the program is O(n)\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\n/**\\n * @param {string[]} operations\\n * @return {number}\\n */\\nvar calPoints = function(operations) {\\n   let newArr = []\\n    for (let i = 0; i < operations.length; i++) {\\n        if (operations[i] != \\'C\\' && operations[i] != \\'D\\' && operations[i] != \\'+\\') {\\n            let value = parseInt(operations[i])\\n            newArr.push(value)\\n        }\\n        if (operations[i] == \"C\") {\\n            newArr.pop()\\n        } else if (operations[i] === \"D\") {\\n            let value = newArr[newArr.length - 1] * 2\\n            newArr.push(value)\\n        } else if (operations[i] === \"+\") {\\n            let newValue = newArr[newArr.length - 1] + newArr[newArr.length - 2]\\n            newArr.push(newValue)\\n        }\\n    }\\n    let total = newArr.reduce((acc, curr) => {\\n        return acc += curr\\n    }, 0)\\n    return total\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} operations\\n * @return {number}\\n */\\nvar calPoints = function(operations) {\\n   let newArr = []\\n    for (let i = 0; i < operations.length; i++) {\\n        if (operations[i] != \\'C\\' && operations[i] != \\'D\\' && operations[i] != \\'+\\') {\\n            let value = parseInt(operations[i])\\n            newArr.push(value)\\n        }\\n        if (operations[i] == \"C\") {\\n            newArr.pop()\\n        } else if (operations[i] === \"D\") {\\n            let value = newArr[newArr.length - 1] * 2\\n            newArr.push(value)\\n        } else if (operations[i] === \"+\") {\\n            let newValue = newArr[newArr.length - 1] + newArr[newArr.length - 2]\\n            newArr.push(newValue)\\n        }\\n    }\\n    let total = newArr.reduce((acc, curr) => {\\n        return acc += curr\\n    }, 0)\\n    return total\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531347,
                "title": "a-very-simple-c-solution-with-stack",
                "content": "# Intuition\\n<!-- Stack approach -->\\n\\n# Approach\\n<!-- In this solution the main idea is the use of stack -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- 85ms -->\\n\\n- Space complexity: O(n)\\n<!-- 39.2MB -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CalPoints(string[] operations) {\\n        int length = operations.Length;\\n        int[] res = new int[length];\\n        Stack<int> myStack = new Stack<int>(res);\\n        int ans=0;\\n        int i=0;\\n        while(i<length){\\n            if(operations[i]==\"+\"){\\n                if (myStack.Count >= 2){\\n                    int firstElement = myStack.Pop();\\n                    int secondElement = myStack.Pop();\\n                    int sum = firstElement + secondElement;\\n                    myStack.Push(secondElement);\\n                    myStack.Push(firstElement);\\n                    myStack.Push(sum);\\n                }\\n            }\\n            else if(operations[i]==\"C\"){\\n                if (myStack.Count >= 1){\\n                    myStack.Pop();\\n                }\\n            }\\n            else if(operations[i]==\"D\"){\\n                 int top = myStack.Pop();\\n                 int result = top * 2;\\n                 myStack.Push(top);\\n                 myStack.Push(result);\\n            }else{\\n                myStack.Push(Int32.Parse(operations[i]));\\n            }\\n            i++;\\n        }\\n        while (myStack.Count > 0){\\n            ans+=myStack.Pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CalPoints(string[] operations) {\\n        int length = operations.Length;\\n        int[] res = new int[length];\\n        Stack<int> myStack = new Stack<int>(res);\\n        int ans=0;\\n        int i=0;\\n        while(i<length){\\n            if(operations[i]==\"+\"){\\n                if (myStack.Count >= 2){\\n                    int firstElement = myStack.Pop();\\n                    int secondElement = myStack.Pop();\\n                    int sum = firstElement + secondElement;\\n                    myStack.Push(secondElement);\\n                    myStack.Push(firstElement);\\n                    myStack.Push(sum);\\n                }\\n            }\\n            else if(operations[i]==\"C\"){\\n                if (myStack.Count >= 1){\\n                    myStack.Pop();\\n                }\\n            }\\n            else if(operations[i]==\"D\"){\\n                 int top = myStack.Pop();\\n                 int result = top * 2;\\n                 myStack.Push(top);\\n                 myStack.Push(result);\\n            }else{\\n                myStack.Push(Int32.Parse(operations[i]));\\n            }\\n            i++;\\n        }\\n        while (myStack.Count > 0){\\n            ans+=myStack.Pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519803,
                "title": "easy-and-simple-solution-in-javascript-wow-0",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string[]} operations\\n * @return {number}\\n */\\nvar calPoints = function(operations) {\\n    let arr = []\\n    operations.reverse()\\n    while(operations.length) {\\n        let curr = operations.pop()\\n        if(curr == \\'C\\') arr.pop()\\n        if(curr == \\'D\\') {\\n            let num = 2 * arr[arr.length - 1]\\n            arr.push(num * 1)\\n        }\\n        if(curr == \\'+\\') {\\n            let num = arr[arr.length - 2] + arr[arr.length - 1]\\n            arr.push(num * 1)\\n        }\\n        if(curr !== \\'+\\' && curr !== \\'D\\' && curr !== \\'C\\') {\\n            arr.push(curr * 1)\\n        }\\n    }\\n    let sum = 0\\n    console.log(arr)\\n    arr.forEach((el) => {\\n        sum += el\\n    })\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} operations\\n * @return {number}\\n */\\nvar calPoints = function(operations) {\\n    let arr = []\\n    operations.reverse()\\n    while(operations.length) {\\n        let curr = operations.pop()\\n        if(curr == \\'C\\') arr.pop()\\n        if(curr == \\'D\\') {\\n            let num = 2 * arr[arr.length - 1]\\n            arr.push(num * 1)\\n        }\\n        if(curr == \\'+\\') {\\n            let num = arr[arr.length - 2] + arr[arr.length - 1]\\n            arr.push(num * 1)\\n        }\\n        if(curr !== \\'+\\' && curr !== \\'D\\' && curr !== \\'C\\') {\\n            arr.push(curr * 1)\\n        }\\n    }\\n    let sum = 0\\n    console.log(arr)\\n    arr.forEach((el) => {\\n        sum += el\\n    })\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430966,
                "title": "c-solution-100-time-72-6-space-vector-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations);\\n\\n    bool isNumber(string line, int &n);\\n};\\n/*************************************************************/\\nint Solution::calPoints(vector<string>& operations) {\\n    int i, size = operations.size(), n;\\n    char *p;\\n    vector<int> v;\\n    for (i = 0; i < size; ++i) {\\n    \\n        if (isNumber(operations[i], n) == true) {\\n           v.push_back(n);\\n       } else if (operations[i] == \"+\") {\\n           v.push_back( v[v.size()-1] + v[v.size()-2] );\\n       } else if (operations[i] == \"D\") {\\n           v.push_back( 2*v[v.size()-1]);\\n       } else {\\n           v.pop_back();\\n       }\\n    }\\n    size = v.size();\\n    for (i = 0, n = 0; i < size; ++i) {\\n        n+=v[i];\\n    }\\n    return n;\\n}\\n/*************************************************************/\\nbool Solution::isNumber(string line, int &n) {\\n    char* p;\\n    int i, size = line.size();\\n    for (i = 0; i < size; ++i) {\\n        if (i == 0 && line[i] == \\'-\\') {\\n            continue;\\n        } else if (line[i] < \\'0\\' || line[i] > \\'9\\') {\\n            return false;\\n        }\\n    }\\n    n = strtol(line.c_str(), &p, 10);\\n    return true;\\n}\\n/*************************************************************/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations);\\n\\n    bool isNumber(string line, int &n);\\n};\\n/*************************************************************/\\nint Solution::calPoints(vector<string>& operations) {\\n    int i, size = operations.size(), n;\\n    char *p;\\n    vector<int> v;\\n    for (i = 0; i < size; ++i) {\\n    \\n        if (isNumber(operations[i], n) == true) {\\n           v.push_back(n);\\n       } else if (operations[i] == \"+\") {\\n           v.push_back( v[v.size()-1] + v[v.size()-2] );\\n       } else if (operations[i] == \"D\") {\\n           v.push_back( 2*v[v.size()-1]);\\n       } else {\\n           v.pop_back();\\n       }\\n    }\\n    size = v.size();\\n    for (i = 0, n = 0; i < size; ++i) {\\n        n+=v[i];\\n    }\\n    return n;\\n}\\n/*************************************************************/\\nbool Solution::isNumber(string line, int &n) {\\n    char* p;\\n    int i, size = line.size();\\n    for (i = 0; i < size; ++i) {\\n        if (i == 0 && line[i] == \\'-\\') {\\n            continue;\\n        } else if (line[i] < \\'0\\' || line[i] > \\'9\\') {\\n            return false;\\n        }\\n    }\\n    n = strtol(line.c_str(), &p, 10);\\n    return true;\\n}\\n/*************************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404819,
                "title": "js-59ms",
                "content": "\\n```\\nvar calPoints = function(ops) {\\n    let arr = [];\\n\\n    for (let i = 0; i < ops.length; i++) {\\n        if (ops[i] == \\'C\\') {\\n            arr.pop();\\n            continue;\\n        }\\n        if (ops[i] == \\'D\\') {\\n            arr.push(arr[arr.length - 1] * 2);\\n            continue;\\n        }\\n        if (ops[i] == \\'+\\') {\\n            arr.push((arr[arr.length - 2]) + arr[arr.length - 1]);\\n            continue;\\n        }\\n        ops[i] = +ops[i];\\n        if (Number.isInteger(ops[i])) {\\n            arr.push(ops[i]);\\n        }\\n    }\\n    return arr.reduce((a, b) => a + b, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar calPoints = function(ops) {\\n    let arr = [];\\n\\n    for (let i = 0; i < ops.length; i++) {\\n        if (ops[i] == \\'C\\') {\\n            arr.pop();\\n            continue;\\n        }\\n        if (ops[i] == \\'D\\') {\\n            arr.push(arr[arr.length - 1] * 2);\\n            continue;\\n        }\\n        if (ops[i] == \\'+\\') {\\n            arr.push((arr[arr.length - 2]) + arr[arr.length - 1]);\\n            continue;\\n        }\\n        ops[i] = +ops[i];\\n        if (Number.isInteger(ops[i])) {\\n            arr.push(ops[i]);\\n        }\\n    }\\n    return arr.reduce((a, b) => a + b, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3402859,
                "title": "using-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339883,
                "title": "c-stack-single-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        stack<int> S;\\n        int sum = 0;\\n\\n        for (string op: operations) {\\n            int num;\\n            switch (op[0]) {\\n                case \\'C\\': {\\n                    sum -= S.top();\\n                    S.pop();\\n                    break;\\n                }\\n                case \\'D\\': {\\n                    num = S.top()*2;\\n                    sum += num;\\n                    S.push(num);\\n                    break;\\n                }\\n                case \\'+\\': {\\n                    num = S.top(); S.pop();\\n                    int num2 = S.top();\\n                    S.push(num);\\n                    S.push(num+num2);\\n                    sum += num + num2;\\n                    break;\\n                }\\n                default: {\\n                    num = stoi(op);\\n                    S.push(num);\\n                    sum += num;\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        stack<int> S;\\n        int sum = 0;\\n\\n        for (string op: operations) {\\n            int num;\\n            switch (op[0]) {\\n                case \\'C\\': {\\n                    sum -= S.top();\\n                    S.pop();\\n                    break;\\n                }\\n                case \\'D\\': {\\n                    num = S.top()*2;\\n                    sum += num;\\n                    S.push(num);\\n                    break;\\n                }\\n                case \\'+\\': {\\n                    num = S.top(); S.pop();\\n                    int num2 = S.top();\\n                    S.push(num);\\n                    S.push(num+num2);\\n                    sum += num + num2;\\n                    break;\\n                }\\n                default: {\\n                    num = stoi(op);\\n                    S.push(num);\\n                    sum += num;\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323318,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        \\n        stack<int>s;\\n        for(int i=0;i<operations.size();i++)\\n        {\\n            string str=operations[i];\\n            if(str==\"+\")\\n            {\\n                int n1=s.top();\\n                s.pop();\\n                int n2=s.top();\\n                s.push(n1);\\n                s.push(n1+n2);\\n            }\\n            else if(str==\"D\")\\n            {\\n                int n=s.top();\\n                s.push(2*n);\\n            }\\n            else if(str==\"C\")\\n            {\\n                s.pop();\\n            }\\n            else\\n            {\\n                int n=stoi(str);\\n                s.push(n);\\n            }\\n        }\\n        int sum=0;\\n        while(!s.empty())\\n        {\\n\\t\\t\\tsum+=s.top();\\n            s.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        \\n        stack<int>s;\\n        for(int i=0;i<operations.size();i++)\\n        {\\n            string str=operations[i];\\n            if(str==\"+\")\\n            {\\n                int n1=s.top();\\n                s.pop();\\n                int n2=s.top();\\n                s.push(n1);\\n                s.push(n1+n2);\\n            }\\n            else if(str==\"D\")\\n            {\\n                int n=s.top();\\n                s.push(2*n);\\n            }\\n            else if(str==\"C\")\\n            {\\n                s.pop();\\n            }\\n            else\\n            {\\n                int n=stoi(str);\\n                s.push(n);\\n            }\\n        }\\n        int sum=0;\\n        while(!s.empty())\\n        {\\n\\t\\t\\tsum+=s.top();\\n            s.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283003,
                "title": "baseball-game-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        vector<int> arr;\\n        int i;\\n        for(i=0 ; i<operations.size() ; i++)\\n        {\\n            if(operations[i]==\"D\")\\n            {\\n                arr.push_back(arr[arr.size()-1]*2);\\n            }\\n            else if(operations[i]==\"C\")\\n            {\\n                arr.pop_back();\\n            }\\n            else if(operations[i]==\"+\")\\n            {\\n                arr.push_back(arr[arr.size()-1] + arr[arr.size()-2]);\\n            }\\n            else\\n            {\\n                arr.push_back(stoi(operations[i]));\\n            }\\n        }\\n        return accumulate(arr.begin(), arr.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& operations) {\\n        vector<int> arr;\\n        int i;\\n        for(i=0 ; i<operations.size() ; i++)\\n        {\\n            if(operations[i]==\"D\")\\n            {\\n                arr.push_back(arr[arr.size()-1]*2);\\n            }\\n            else if(operations[i]==\"C\")\\n            {\\n                arr.pop_back();\\n            }\\n            else if(operations[i]==\"+\")\\n            {\\n                arr.push_back(arr[arr.size()-1] + arr[arr.size()-2]);\\n            }\\n            else\\n            {\\n                arr.push_back(stoi(operations[i]));\\n            }\\n        }\\n        return accumulate(arr.begin(), arr.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233030,
                "title": "easy-solution-using-stack",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        Stack<Integer> stack = new Stack<>();\\n          \\n        for(String s : ops){\\n            \\n              if( s.equals(\"C\")){\\n                 stack.pop();\\n             }\\n             else if(s.equals(\"D\")){\\n                 stack.push(2* stack.peek());\\n             }\\n              else if(s.equals(\"+\")){\\n                 \\n                  if(stack.size() >=2){\\n                     int res1= stack.pop();\\n                     int res2= stack.pop();\\n                     int res= res1+res2;\\n                     stack.push(res2);\\n                     stack.push(res1);\\n                     stack.push(res); \\n                  }\\n             }\\n             else{\\n                 stack.push(Integer.parseInt(s));\\n             }\\n        }\\n        int ans =0;\\n         while(!stack.isEmpty()){\\n            ans += stack.pop();\\n         }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calPoints(String[] ops) {\\n        Stack<Integer> stack = new Stack<>();\\n          \\n        for(String s : ops){\\n            \\n              if( s.equals(\"C\")){\\n                 stack.pop();\\n             }\\n             else if(s.equals(\"D\")){\\n                 stack.push(2* stack.peek());\\n             }\\n              else if(s.equals(\"+\")){\\n                 \\n                  if(stack.size() >=2){\\n                     int res1= stack.pop();\\n                     int res2= stack.pop();\\n                     int res= res1+res2;\\n                     stack.push(res2);\\n                     stack.push(res1);\\n                     stack.push(res); \\n                  }\\n             }\\n             else{\\n                 stack.push(Integer.parseInt(s));\\n             }\\n        }\\n        int ans =0;\\n         while(!stack.isEmpty()){\\n            ans += stack.pop();\\n         }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177533,
                "title": "golang-100-fastest",
                "content": "\\n```\\ntype score struct {\\n\\tthis []int\\n}\\n\\nfunc (s *score) add(n int) { s.this = append(s.this, n) }\\nfunc (s *score) del()      { s.this = s.this[:len(s.this)-1] }\\nfunc (s *score) plus()     { s.this = append(s.this, s.this[len(s.this)-1]+s.this[len(s.this)-2]) }\\nfunc (s *score) double()   { s.this = append(s.this, 2*s.this[len(s.this)-1]) }\\nfunc (s *score) sum() (res int) {\\n\\tfor _, v := range s.this {\\n\\t\\tres += v\\n\\t}\\n\\treturn\\n}\\n\\nfunc calPoints(operations []string) int {\\n\\tvar s score\\n\\tfor _, v := range operations {\\n\\t\\tswitch v {\\n\\t\\tcase \"+\":\\n\\t\\t\\ts.plus()\\n\\t\\tcase \"D\":\\n\\t\\t\\ts.double()\\n\\t\\tcase \"C\":\\n\\t\\t\\ts.del()\\n\\t\\tdefault:\\n\\t\\t\\tr, _ := strconv.Atoi(v)\\n\\t\\t\\ts.add(r)\\n\\t\\t}\\n\\t}\\n\\treturn s.sum()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype score struct {\\n\\tthis []int\\n}\\n\\nfunc (s *score) add(n int) { s.this = append(s.this, n) }\\nfunc (s *score) del()      { s.this = s.this[:len(s.this)-1] }\\nfunc (s *score) plus()     { s.this = append(s.this, s.this[len(s.this)-1]+s.this[len(s.this)-2]) }\\nfunc (s *score) double()   { s.this = append(s.this, 2*s.this[len(s.this)-1]) }\\nfunc (s *score) sum() (res int) {\\n\\tfor _, v := range s.this {\\n\\t\\tres += v\\n\\t}\\n\\treturn\\n}\\n\\nfunc calPoints(operations []string) int {\\n\\tvar s score\\n\\tfor _, v := range operations {\\n\\t\\tswitch v {\\n\\t\\tcase \"+\":\\n\\t\\t\\ts.plus()\\n\\t\\tcase \"D\":\\n\\t\\t\\ts.double()\\n\\t\\tcase \"C\":\\n\\t\\t\\ts.del()\\n\\t\\tdefault:\\n\\t\\t\\tr, _ := strconv.Atoi(v)\\n\\t\\t\\ts.add(r)\\n\\t\\t}\\n\\t}\\n\\treturn s.sum()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3168796,
                "title": "easy-python-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack = []\\n        for i in range(len(operations)):\\n            if operations[i]==\"D\":\\n                stack.append(stack[-1]*2)\\n            elif operations[i]==\"C\":\\n                stack.pop(-1)\\n            elif operations[i]==\"+\":\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(operations[i]))\\n        print(stack)\\n        return sum(stack)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack = []\\n        for i in range(len(operations)):\\n            if operations[i]==\"D\":\\n                stack.append(stack[-1]*2)\\n            elif operations[i]==\"C\":\\n                stack.pop(-1)\\n            elif operations[i]==\"+\":\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(operations[i]))\\n        print(stack)\\n        return sum(stack)\\n\\n\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564883,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1565444,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1567117,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1565955,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1566801,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1765476,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1575069,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1799849,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 2057657,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 2054771,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1564883,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1565444,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1567117,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1565955,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1566801,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1765476,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1575069,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1799849,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 2057657,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 2054771,
                "content": [
                    {
                        "username": "david120",
                        "content": "I guess the \"rounds\" supposed to be innings?  None of the operations mentioned in this question have anything to do with baseball with maybe the exception of putting a positive integer in a round as a proxy for runs scored."
                    },
                    {
                        "username": "QueenZoe",
                        "content": "Can not understand after each remove operation, in the example one, why after remove the 2d round, the sum is 30?? Also in the second example. After remove the 3rd round score, why in the next step with double score it is -4?  and the sum is -1? How???"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/baseball-game/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Stack [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This challenge sucks Leetcode!!!"
                    },
                    {
                        "username": "linzihan",
                        "content": "![0_1506234177757_QQ\\u56fe\\u724720170924142202.png](/assets/uploads/files/1506234179530-qq\\u56fe\\u724720170924142202-resized.png) \\n\\nI am confused!!!"
                    },
                    {
                        "username": "sgmmsxz",
                        "content": "![0_1506226624320_Screen Shot 2017-09-23 at 11.11.13 PM.png](/assets/uploads/files/1506226627418-screen-shot-2017-09-23-at-11.11.13-pm-resized.png)"
                    },
                    {
                        "username": "District_12",
                        "content": "Maybe it\\'s time to fix testcases?"
                    },
                    {
                        "username": "190030887",
                        "content": "tanks guys........"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "public int calPoints(String[] operations) {\\n       int count=0;\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<operations.length;i++){\\n            if(operations[i]==\"C\"){\\n                list.remove(list.get(count-1));\\n                count--;\\n            }\\n            else if(operations[i]==\"D\"){\\n                int num=list.get(count-1)*2;\\n                list.add(num);\\n                count++;\\n            }\\n            else if(operations[i]==\"+\"){\\n                int num= list.get(count-1)+list.get(count-2);\\n                list.add(num);\\n                count++;\\n            }\\n            else {\\n                int num=Integer.valueOf(operations[i]);\\n                list.add(num);\\n                count++;\\n            }\\n        }\\n        int sum=0;\\n        for (int i = 0; i < list.size(); i++) {\\n            sum=sum+list.get(i);\\n        }\\n        return sum;\\n    }\\n \\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 999, java.base/java.lang.Integer.valueOf\\n  at line 21, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\nwhy it is giving runtime error whereas it is giving output on other ."
                    },
                    {
                        "username": "Aniket_Kumar_Mishra",
                        "content": "try to use operations[i].equals(\"C\") instead of opearations[i] == \"C\""
                    },
                    {
                        "username": "Parampreet_Singh23",
                        "content": "#include<string.h>\\n#include<stack>\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& str) {\\n      stack<int> st;\\n      int i=0;\\n      int sum=0;\\n      int len= str.size();\\n      for(i=0;i<len;i++){\\n        if(str[i]==\"+\"){\\n        int temp1=st.top();\\n        st.pop();\\n        int temp2=st.top();\\n        st.pop();\\n        int a=temp1+temp2;\\n        st.push(temp2);\\n        st.push(temp1);\\n        st.push(a);\\n        }\\n      \\n      else if(str[i]==\"C\"){\\n        st.pop();\\n      }\\n      else if(str[i]==\"D\"){\\n        int temp=st.top();\\n        temp=temp*2;\\n        st.push(temp);\\n      }\\n      else{\\n        st.push(stoi(str[i]));\\n      }\\n      }\\n        while(not st.empty()){\\n          int temp=st.top();\\n          st.pop();\\n          sum=sum+temp;\\n\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "My solution is giving right answer on IntelliJ but wrong on leetcode. Please help!!\\n\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            String ch = operations[i];\\n            if(ch == \"+\"){\\n                int top = st.peek();\\n                st.pop();\\n                int sec = st.peek();\\n                st.push(top);\\n                int sum = top + sec;\\n                st.push(sum);\\n            }\\n            else if(ch == \"D\"){ \\n                    int n = st.peek();\\n                    int n2 = n*2;\\n                    st.push(n2);\\n                    }\\n            else if(ch == \"C\"){ st.pop(); }\\n            else{\\n                try {\\n                  int d = Integer.parseInt(ch);\\n                  st.push(d);\\n                  } catch (NumberFormatException nfe) {\\n                  continue;\\n               }\\n            }\\n            }\\n            int sum=0;\\n            while(!st.isEmpty()){\\n                 sum += st.peek();\\n                st.pop();\\n            }    \\n            return sum;\\n        }\\n    }\\n"
                    }
                ]
            },
            {
                "id": 2053051,
                "content": [
                    {
                        "username": "abhay_mnit22",
                        "content": "use .equals instead of == (java )"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "Thank you"
                    },
                    {
                        "username": "shoaibhossain24",
                        "content": "I first tried on Intellij and then posted the solution here, the results tell me the output is 7 expected 30, in my IDE the output is 30.\\nAny Idea why?"
                    },
                    {
                        "username": "aritrakunda3",
                        "content": "I did not get why my solution takes more memory , I did not used any additional data structure."
                    },
                    {
                        "username": "user4657aM",
                        "content": "In leetcode I\\'m getting the following error:\\n\\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 786, java.base/java.lang.Integer.parseInt\\n  at line 12, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nBut the same code gets compiled in online gdb and gives correct ans..\\nPlease give any suggestion"
                    },
                    {
                        "username": "SV_Shriyansh",
                        "content": "I am getting NumberFormatException for   `int temp = Integer.parseInt(operations[i])` Can any one help me out how to resolve it.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "A `NumberFormatException` is thrown by Java methods that attempt to convert a `String` into a number, like `Integer.parseInt()`, when the `String` cannot be properly parsed into a number. In this case, the `NumberFormatException` is thrown because the code attempts to parse non-numeric strings (\"C\", \"D\", \"+\") into integers.\\n\\nTo avoid the `NumberFormatException`, you can add checks for non-numeric strings in your code. Here\\'s a Java solution for your problem that handles the different types of operations correctly:\\n\\n```java\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (String op : operations) {\\n            if (op.equals(\"C\")) {\\n                stack.pop();\\n            } else if (op.equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            } else if (op.equals(\"+\")) {\\n                int top = stack.pop();\\n                int newtop = top + stack.peek();\\n                stack.push(top);\\n                stack.push(newtop);\\n            } else {\\n                stack.push(Integer.parseInt(op));\\n            }\\n        }\\n        int sum = 0;\\n        for(int score : stack) {\\n            sum += score;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nIn this code:\\n\\n1. We use a `Stack` to keep track of the scores.\\n2. We iterate over each operation:\\n   - If the operation is \\'C\\', we remove the last score by calling `pop()`.\\n   - If the operation is \\'D\\', we double the last score and push it onto the `Stack`.\\n   - If the operation is \\'+\\', we add the last two scores and push the sum onto the `Stack`.\\n   - Otherwise, the operation is a `String` representing an integer. We parse it to an integer and push it onto the `Stack`.\\n3. Finally, we return the sum of all scores in the `Stack`."
                    },
                    {
                        "username": "oleg-mng",
                        "content": "you can try to use List<String> \nconvert from String to int and back"
                    },
                    {
                        "username": "Xswefv87526492",
                        "content": "please help\\n\\nfor case 20 :  [\"-60\",\"D\",\"-36\",\"30\",\"13\",\"C\",\"C\",\"-33\",\"53\",\"79\"]\\nmy output is -87 \\nexpected is:-117 \\nbut when i do the ansewer on paper my answer comes to be \\n\\n\\n\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n      int count=0;\\n      for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n          operations[i]=null;\\n          operations[i-1]=null;\\n          count+=1;\\n        }\\n      }\\n        String[] op=new String[operations.length-count];\\n        int r=0;\\n        for(int k=0;k<operations.length;k++){\\n          if(operations[k]==null){\\n            continue;\\n          }else{\\n            op[r]=operations[k];\\n             r++;\\n          }\\n        }\\n        int[] arr=new int[operations.length-count];\\n        int pos=0;\\n        for(int j=0;j<op.length;j++){\\n          if(op[j]==null){\\n            continue;\\n          }\\n          \\n         if(op[j].equals(\"D\")){\\n            int vald=(arr[j-1]);\\n            arr[pos]=vald*2;\\n            pos++;\\n\\n          }else if(op[j].equals(\"+\")){\\n            int val1a=(arr[j-2]);\\n            int val2a=(arr[j-1]);\\n            arr[pos]=val1a+val2a;\\n            pos++;\\n          }else{\\n            int okval=Integer.parseInt(op[j]);\\n            arr[pos]=okval;\\n            pos++;\\n          }\\n        }\\n\\n          int sumof=0;\\n          for(int o=0;o<arr.length;o++){\\n            sumof+=arr[o];\\n          }\\n         \\n          return sumof;\\n}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem in your code is that when you encounter \"C\", you just nullify the current operation and the previous operation, which does not correctly represent the described behavior. Instead, you should think about \"C\" as removing the last valid score from the record.\\n\\nAlso, when \"D\" and \"+\" occur, you\\'re accessing the array at index \"j-1\" and \"j-2\", but you should access the array at index \"pos-1\" and \"pos-2\" because \"pos\" tracks the number of valid scores.\\n\\nHere is the corrected version of your code:\\n\\n```java\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n        int[] arr = new int[operations.length];\\n        int pos = 0;\\n        \\n        for(int j=0;j<operations.length;j++){\\n            if(operations[j].equals(\"D\")){\\n                arr[pos] = 2 * arr[pos-1];\\n                pos++;\\n            } else if(operations[j].equals(\"+\")){\\n                arr[pos] = arr[pos-1] + arr[pos-2];\\n                pos++;\\n            } else if(operations[j].equals(\"C\")){\\n                arr[pos-1] = 0; // Invalidate the last score\\n                pos = pos > 0 ? pos-1 : 0; // Make sure not to go negative\\n            } else {\\n                arr[pos] = Integer.parseInt(operations[j]);\\n                pos++;\\n            }\\n        }\\n      \\n        int sumof = 0;\\n        for(int o = 0; o < arr.length; o++){\\n            sumof += arr[o];\\n        }\\n     \\n        return sumof;\\n    }\\n}\\n```\\n\\nIn this corrected version, we keep track of the valid scores in the `arr` array and use the `pos` variable to keep track of the position of the last valid score. We then handle each operation according to the problem\\'s description."
                    },
                    {
                        "username": "mirshod_py",
                        "content": "        stack = []\\n        for p in operations:\\n            if (not stack and p.isnumeric()) or (stack and p.isnumeric()):\\n                stack.append(int(p))\\n            elif p == \"+\" and len(stack) >= 2:\\n                stack.append(stack[-2] + stack[-1])\\n            elif p == \"D\" and stack:\\n                stack.append(2 * stack[-1])\\n            elif p == \"C\" and stack:\\n                stack.pop()\\n        return sum(stack)\\n            where is the problem in this solution? it is not passing this test case \"[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\\n\""
                    },
                    {
                        "username": "Harp1207",
                        "content": "\"-2\".isnumeric()  --> False\\u3002btw, you do not need to check check stack\\'s empty or length since the test data make sure valid"
                    },
                    {
                        "username": "itsV_768",
                        "content": "in my approach I was not resetting the char and int .\\nBut happy , solved it by my self"
                    },
                    {
                        "username": "sudhirpatra",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& o) {\\n        vector<int>res;\\n        for(int i=0;i<o.size();i++){\\n            if(o[i]==\"+\") {\\n                res.push_back(res[res.size()-1]+res[res.size()-2]);            \\n            }\\n            else if(o[i]==\"D\") {\\n                res.push_back(res[res.size()-1]*2);\\n            }\\n            else if(o[i]==\"C\") {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(stoi(o[i]));\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<res.size();i++){\\n            sum=sum+res[i];\\n        }\\n        return sum;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2045801,
                "content": [
                    {
                        "username": "abhay_mnit22",
                        "content": "use .equals instead of == (java )"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "Thank you"
                    },
                    {
                        "username": "shoaibhossain24",
                        "content": "I first tried on Intellij and then posted the solution here, the results tell me the output is 7 expected 30, in my IDE the output is 30.\\nAny Idea why?"
                    },
                    {
                        "username": "aritrakunda3",
                        "content": "I did not get why my solution takes more memory , I did not used any additional data structure."
                    },
                    {
                        "username": "user4657aM",
                        "content": "In leetcode I\\'m getting the following error:\\n\\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 786, java.base/java.lang.Integer.parseInt\\n  at line 12, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nBut the same code gets compiled in online gdb and gives correct ans..\\nPlease give any suggestion"
                    },
                    {
                        "username": "SV_Shriyansh",
                        "content": "I am getting NumberFormatException for   `int temp = Integer.parseInt(operations[i])` Can any one help me out how to resolve it.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "A `NumberFormatException` is thrown by Java methods that attempt to convert a `String` into a number, like `Integer.parseInt()`, when the `String` cannot be properly parsed into a number. In this case, the `NumberFormatException` is thrown because the code attempts to parse non-numeric strings (\"C\", \"D\", \"+\") into integers.\\n\\nTo avoid the `NumberFormatException`, you can add checks for non-numeric strings in your code. Here\\'s a Java solution for your problem that handles the different types of operations correctly:\\n\\n```java\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (String op : operations) {\\n            if (op.equals(\"C\")) {\\n                stack.pop();\\n            } else if (op.equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            } else if (op.equals(\"+\")) {\\n                int top = stack.pop();\\n                int newtop = top + stack.peek();\\n                stack.push(top);\\n                stack.push(newtop);\\n            } else {\\n                stack.push(Integer.parseInt(op));\\n            }\\n        }\\n        int sum = 0;\\n        for(int score : stack) {\\n            sum += score;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nIn this code:\\n\\n1. We use a `Stack` to keep track of the scores.\\n2. We iterate over each operation:\\n   - If the operation is \\'C\\', we remove the last score by calling `pop()`.\\n   - If the operation is \\'D\\', we double the last score and push it onto the `Stack`.\\n   - If the operation is \\'+\\', we add the last two scores and push the sum onto the `Stack`.\\n   - Otherwise, the operation is a `String` representing an integer. We parse it to an integer and push it onto the `Stack`.\\n3. Finally, we return the sum of all scores in the `Stack`."
                    },
                    {
                        "username": "oleg-mng",
                        "content": "you can try to use List<String> \nconvert from String to int and back"
                    },
                    {
                        "username": "Xswefv87526492",
                        "content": "please help\\n\\nfor case 20 :  [\"-60\",\"D\",\"-36\",\"30\",\"13\",\"C\",\"C\",\"-33\",\"53\",\"79\"]\\nmy output is -87 \\nexpected is:-117 \\nbut when i do the ansewer on paper my answer comes to be \\n\\n\\n\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n      int count=0;\\n      for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n          operations[i]=null;\\n          operations[i-1]=null;\\n          count+=1;\\n        }\\n      }\\n        String[] op=new String[operations.length-count];\\n        int r=0;\\n        for(int k=0;k<operations.length;k++){\\n          if(operations[k]==null){\\n            continue;\\n          }else{\\n            op[r]=operations[k];\\n             r++;\\n          }\\n        }\\n        int[] arr=new int[operations.length-count];\\n        int pos=0;\\n        for(int j=0;j<op.length;j++){\\n          if(op[j]==null){\\n            continue;\\n          }\\n          \\n         if(op[j].equals(\"D\")){\\n            int vald=(arr[j-1]);\\n            arr[pos]=vald*2;\\n            pos++;\\n\\n          }else if(op[j].equals(\"+\")){\\n            int val1a=(arr[j-2]);\\n            int val2a=(arr[j-1]);\\n            arr[pos]=val1a+val2a;\\n            pos++;\\n          }else{\\n            int okval=Integer.parseInt(op[j]);\\n            arr[pos]=okval;\\n            pos++;\\n          }\\n        }\\n\\n          int sumof=0;\\n          for(int o=0;o<arr.length;o++){\\n            sumof+=arr[o];\\n          }\\n         \\n          return sumof;\\n}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem in your code is that when you encounter \"C\", you just nullify the current operation and the previous operation, which does not correctly represent the described behavior. Instead, you should think about \"C\" as removing the last valid score from the record.\\n\\nAlso, when \"D\" and \"+\" occur, you\\'re accessing the array at index \"j-1\" and \"j-2\", but you should access the array at index \"pos-1\" and \"pos-2\" because \"pos\" tracks the number of valid scores.\\n\\nHere is the corrected version of your code:\\n\\n```java\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n        int[] arr = new int[operations.length];\\n        int pos = 0;\\n        \\n        for(int j=0;j<operations.length;j++){\\n            if(operations[j].equals(\"D\")){\\n                arr[pos] = 2 * arr[pos-1];\\n                pos++;\\n            } else if(operations[j].equals(\"+\")){\\n                arr[pos] = arr[pos-1] + arr[pos-2];\\n                pos++;\\n            } else if(operations[j].equals(\"C\")){\\n                arr[pos-1] = 0; // Invalidate the last score\\n                pos = pos > 0 ? pos-1 : 0; // Make sure not to go negative\\n            } else {\\n                arr[pos] = Integer.parseInt(operations[j]);\\n                pos++;\\n            }\\n        }\\n      \\n        int sumof = 0;\\n        for(int o = 0; o < arr.length; o++){\\n            sumof += arr[o];\\n        }\\n     \\n        return sumof;\\n    }\\n}\\n```\\n\\nIn this corrected version, we keep track of the valid scores in the `arr` array and use the `pos` variable to keep track of the position of the last valid score. We then handle each operation according to the problem\\'s description."
                    },
                    {
                        "username": "mirshod_py",
                        "content": "        stack = []\\n        for p in operations:\\n            if (not stack and p.isnumeric()) or (stack and p.isnumeric()):\\n                stack.append(int(p))\\n            elif p == \"+\" and len(stack) >= 2:\\n                stack.append(stack[-2] + stack[-1])\\n            elif p == \"D\" and stack:\\n                stack.append(2 * stack[-1])\\n            elif p == \"C\" and stack:\\n                stack.pop()\\n        return sum(stack)\\n            where is the problem in this solution? it is not passing this test case \"[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\\n\""
                    },
                    {
                        "username": "Harp1207",
                        "content": "\"-2\".isnumeric()  --> False\\u3002btw, you do not need to check check stack\\'s empty or length since the test data make sure valid"
                    },
                    {
                        "username": "itsV_768",
                        "content": "in my approach I was not resetting the char and int .\\nBut happy , solved it by my self"
                    },
                    {
                        "username": "sudhirpatra",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& o) {\\n        vector<int>res;\\n        for(int i=0;i<o.size();i++){\\n            if(o[i]==\"+\") {\\n                res.push_back(res[res.size()-1]+res[res.size()-2]);            \\n            }\\n            else if(o[i]==\"D\") {\\n                res.push_back(res[res.size()-1]*2);\\n            }\\n            else if(o[i]==\"C\") {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(stoi(o[i]));\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<res.size();i++){\\n            sum=sum+res[i];\\n        }\\n        return sum;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2038975,
                "content": [
                    {
                        "username": "abhay_mnit22",
                        "content": "use .equals instead of == (java )"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "Thank you"
                    },
                    {
                        "username": "shoaibhossain24",
                        "content": "I first tried on Intellij and then posted the solution here, the results tell me the output is 7 expected 30, in my IDE the output is 30.\\nAny Idea why?"
                    },
                    {
                        "username": "aritrakunda3",
                        "content": "I did not get why my solution takes more memory , I did not used any additional data structure."
                    },
                    {
                        "username": "user4657aM",
                        "content": "In leetcode I\\'m getting the following error:\\n\\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 786, java.base/java.lang.Integer.parseInt\\n  at line 12, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nBut the same code gets compiled in online gdb and gives correct ans..\\nPlease give any suggestion"
                    },
                    {
                        "username": "SV_Shriyansh",
                        "content": "I am getting NumberFormatException for   `int temp = Integer.parseInt(operations[i])` Can any one help me out how to resolve it.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "A `NumberFormatException` is thrown by Java methods that attempt to convert a `String` into a number, like `Integer.parseInt()`, when the `String` cannot be properly parsed into a number. In this case, the `NumberFormatException` is thrown because the code attempts to parse non-numeric strings (\"C\", \"D\", \"+\") into integers.\\n\\nTo avoid the `NumberFormatException`, you can add checks for non-numeric strings in your code. Here\\'s a Java solution for your problem that handles the different types of operations correctly:\\n\\n```java\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (String op : operations) {\\n            if (op.equals(\"C\")) {\\n                stack.pop();\\n            } else if (op.equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            } else if (op.equals(\"+\")) {\\n                int top = stack.pop();\\n                int newtop = top + stack.peek();\\n                stack.push(top);\\n                stack.push(newtop);\\n            } else {\\n                stack.push(Integer.parseInt(op));\\n            }\\n        }\\n        int sum = 0;\\n        for(int score : stack) {\\n            sum += score;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nIn this code:\\n\\n1. We use a `Stack` to keep track of the scores.\\n2. We iterate over each operation:\\n   - If the operation is \\'C\\', we remove the last score by calling `pop()`.\\n   - If the operation is \\'D\\', we double the last score and push it onto the `Stack`.\\n   - If the operation is \\'+\\', we add the last two scores and push the sum onto the `Stack`.\\n   - Otherwise, the operation is a `String` representing an integer. We parse it to an integer and push it onto the `Stack`.\\n3. Finally, we return the sum of all scores in the `Stack`."
                    },
                    {
                        "username": "oleg-mng",
                        "content": "you can try to use List<String> \nconvert from String to int and back"
                    },
                    {
                        "username": "Xswefv87526492",
                        "content": "please help\\n\\nfor case 20 :  [\"-60\",\"D\",\"-36\",\"30\",\"13\",\"C\",\"C\",\"-33\",\"53\",\"79\"]\\nmy output is -87 \\nexpected is:-117 \\nbut when i do the ansewer on paper my answer comes to be \\n\\n\\n\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n      int count=0;\\n      for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n          operations[i]=null;\\n          operations[i-1]=null;\\n          count+=1;\\n        }\\n      }\\n        String[] op=new String[operations.length-count];\\n        int r=0;\\n        for(int k=0;k<operations.length;k++){\\n          if(operations[k]==null){\\n            continue;\\n          }else{\\n            op[r]=operations[k];\\n             r++;\\n          }\\n        }\\n        int[] arr=new int[operations.length-count];\\n        int pos=0;\\n        for(int j=0;j<op.length;j++){\\n          if(op[j]==null){\\n            continue;\\n          }\\n          \\n         if(op[j].equals(\"D\")){\\n            int vald=(arr[j-1]);\\n            arr[pos]=vald*2;\\n            pos++;\\n\\n          }else if(op[j].equals(\"+\")){\\n            int val1a=(arr[j-2]);\\n            int val2a=(arr[j-1]);\\n            arr[pos]=val1a+val2a;\\n            pos++;\\n          }else{\\n            int okval=Integer.parseInt(op[j]);\\n            arr[pos]=okval;\\n            pos++;\\n          }\\n        }\\n\\n          int sumof=0;\\n          for(int o=0;o<arr.length;o++){\\n            sumof+=arr[o];\\n          }\\n         \\n          return sumof;\\n}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem in your code is that when you encounter \"C\", you just nullify the current operation and the previous operation, which does not correctly represent the described behavior. Instead, you should think about \"C\" as removing the last valid score from the record.\\n\\nAlso, when \"D\" and \"+\" occur, you\\'re accessing the array at index \"j-1\" and \"j-2\", but you should access the array at index \"pos-1\" and \"pos-2\" because \"pos\" tracks the number of valid scores.\\n\\nHere is the corrected version of your code:\\n\\n```java\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n        int[] arr = new int[operations.length];\\n        int pos = 0;\\n        \\n        for(int j=0;j<operations.length;j++){\\n            if(operations[j].equals(\"D\")){\\n                arr[pos] = 2 * arr[pos-1];\\n                pos++;\\n            } else if(operations[j].equals(\"+\")){\\n                arr[pos] = arr[pos-1] + arr[pos-2];\\n                pos++;\\n            } else if(operations[j].equals(\"C\")){\\n                arr[pos-1] = 0; // Invalidate the last score\\n                pos = pos > 0 ? pos-1 : 0; // Make sure not to go negative\\n            } else {\\n                arr[pos] = Integer.parseInt(operations[j]);\\n                pos++;\\n            }\\n        }\\n      \\n        int sumof = 0;\\n        for(int o = 0; o < arr.length; o++){\\n            sumof += arr[o];\\n        }\\n     \\n        return sumof;\\n    }\\n}\\n```\\n\\nIn this corrected version, we keep track of the valid scores in the `arr` array and use the `pos` variable to keep track of the position of the last valid score. We then handle each operation according to the problem\\'s description."
                    },
                    {
                        "username": "mirshod_py",
                        "content": "        stack = []\\n        for p in operations:\\n            if (not stack and p.isnumeric()) or (stack and p.isnumeric()):\\n                stack.append(int(p))\\n            elif p == \"+\" and len(stack) >= 2:\\n                stack.append(stack[-2] + stack[-1])\\n            elif p == \"D\" and stack:\\n                stack.append(2 * stack[-1])\\n            elif p == \"C\" and stack:\\n                stack.pop()\\n        return sum(stack)\\n            where is the problem in this solution? it is not passing this test case \"[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\\n\""
                    },
                    {
                        "username": "Harp1207",
                        "content": "\"-2\".isnumeric()  --> False\\u3002btw, you do not need to check check stack\\'s empty or length since the test data make sure valid"
                    },
                    {
                        "username": "itsV_768",
                        "content": "in my approach I was not resetting the char and int .\\nBut happy , solved it by my self"
                    },
                    {
                        "username": "sudhirpatra",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& o) {\\n        vector<int>res;\\n        for(int i=0;i<o.size();i++){\\n            if(o[i]==\"+\") {\\n                res.push_back(res[res.size()-1]+res[res.size()-2]);            \\n            }\\n            else if(o[i]==\"D\") {\\n                res.push_back(res[res.size()-1]*2);\\n            }\\n            else if(o[i]==\"C\") {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(stoi(o[i]));\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<res.size();i++){\\n            sum=sum+res[i];\\n        }\\n        return sum;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1980843,
                "content": [
                    {
                        "username": "abhay_mnit22",
                        "content": "use .equals instead of == (java )"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "Thank you"
                    },
                    {
                        "username": "shoaibhossain24",
                        "content": "I first tried on Intellij and then posted the solution here, the results tell me the output is 7 expected 30, in my IDE the output is 30.\\nAny Idea why?"
                    },
                    {
                        "username": "aritrakunda3",
                        "content": "I did not get why my solution takes more memory , I did not used any additional data structure."
                    },
                    {
                        "username": "user4657aM",
                        "content": "In leetcode I\\'m getting the following error:\\n\\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 786, java.base/java.lang.Integer.parseInt\\n  at line 12, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nBut the same code gets compiled in online gdb and gives correct ans..\\nPlease give any suggestion"
                    },
                    {
                        "username": "SV_Shriyansh",
                        "content": "I am getting NumberFormatException for   `int temp = Integer.parseInt(operations[i])` Can any one help me out how to resolve it.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "A `NumberFormatException` is thrown by Java methods that attempt to convert a `String` into a number, like `Integer.parseInt()`, when the `String` cannot be properly parsed into a number. In this case, the `NumberFormatException` is thrown because the code attempts to parse non-numeric strings (\"C\", \"D\", \"+\") into integers.\\n\\nTo avoid the `NumberFormatException`, you can add checks for non-numeric strings in your code. Here\\'s a Java solution for your problem that handles the different types of operations correctly:\\n\\n```java\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (String op : operations) {\\n            if (op.equals(\"C\")) {\\n                stack.pop();\\n            } else if (op.equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            } else if (op.equals(\"+\")) {\\n                int top = stack.pop();\\n                int newtop = top + stack.peek();\\n                stack.push(top);\\n                stack.push(newtop);\\n            } else {\\n                stack.push(Integer.parseInt(op));\\n            }\\n        }\\n        int sum = 0;\\n        for(int score : stack) {\\n            sum += score;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nIn this code:\\n\\n1. We use a `Stack` to keep track of the scores.\\n2. We iterate over each operation:\\n   - If the operation is \\'C\\', we remove the last score by calling `pop()`.\\n   - If the operation is \\'D\\', we double the last score and push it onto the `Stack`.\\n   - If the operation is \\'+\\', we add the last two scores and push the sum onto the `Stack`.\\n   - Otherwise, the operation is a `String` representing an integer. We parse it to an integer and push it onto the `Stack`.\\n3. Finally, we return the sum of all scores in the `Stack`."
                    },
                    {
                        "username": "oleg-mng",
                        "content": "you can try to use List<String> \nconvert from String to int and back"
                    },
                    {
                        "username": "Xswefv87526492",
                        "content": "please help\\n\\nfor case 20 :  [\"-60\",\"D\",\"-36\",\"30\",\"13\",\"C\",\"C\",\"-33\",\"53\",\"79\"]\\nmy output is -87 \\nexpected is:-117 \\nbut when i do the ansewer on paper my answer comes to be \\n\\n\\n\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n      int count=0;\\n      for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n          operations[i]=null;\\n          operations[i-1]=null;\\n          count+=1;\\n        }\\n      }\\n        String[] op=new String[operations.length-count];\\n        int r=0;\\n        for(int k=0;k<operations.length;k++){\\n          if(operations[k]==null){\\n            continue;\\n          }else{\\n            op[r]=operations[k];\\n             r++;\\n          }\\n        }\\n        int[] arr=new int[operations.length-count];\\n        int pos=0;\\n        for(int j=0;j<op.length;j++){\\n          if(op[j]==null){\\n            continue;\\n          }\\n          \\n         if(op[j].equals(\"D\")){\\n            int vald=(arr[j-1]);\\n            arr[pos]=vald*2;\\n            pos++;\\n\\n          }else if(op[j].equals(\"+\")){\\n            int val1a=(arr[j-2]);\\n            int val2a=(arr[j-1]);\\n            arr[pos]=val1a+val2a;\\n            pos++;\\n          }else{\\n            int okval=Integer.parseInt(op[j]);\\n            arr[pos]=okval;\\n            pos++;\\n          }\\n        }\\n\\n          int sumof=0;\\n          for(int o=0;o<arr.length;o++){\\n            sumof+=arr[o];\\n          }\\n         \\n          return sumof;\\n}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem in your code is that when you encounter \"C\", you just nullify the current operation and the previous operation, which does not correctly represent the described behavior. Instead, you should think about \"C\" as removing the last valid score from the record.\\n\\nAlso, when \"D\" and \"+\" occur, you\\'re accessing the array at index \"j-1\" and \"j-2\", but you should access the array at index \"pos-1\" and \"pos-2\" because \"pos\" tracks the number of valid scores.\\n\\nHere is the corrected version of your code:\\n\\n```java\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n        int[] arr = new int[operations.length];\\n        int pos = 0;\\n        \\n        for(int j=0;j<operations.length;j++){\\n            if(operations[j].equals(\"D\")){\\n                arr[pos] = 2 * arr[pos-1];\\n                pos++;\\n            } else if(operations[j].equals(\"+\")){\\n                arr[pos] = arr[pos-1] + arr[pos-2];\\n                pos++;\\n            } else if(operations[j].equals(\"C\")){\\n                arr[pos-1] = 0; // Invalidate the last score\\n                pos = pos > 0 ? pos-1 : 0; // Make sure not to go negative\\n            } else {\\n                arr[pos] = Integer.parseInt(operations[j]);\\n                pos++;\\n            }\\n        }\\n      \\n        int sumof = 0;\\n        for(int o = 0; o < arr.length; o++){\\n            sumof += arr[o];\\n        }\\n     \\n        return sumof;\\n    }\\n}\\n```\\n\\nIn this corrected version, we keep track of the valid scores in the `arr` array and use the `pos` variable to keep track of the position of the last valid score. We then handle each operation according to the problem\\'s description."
                    },
                    {
                        "username": "mirshod_py",
                        "content": "        stack = []\\n        for p in operations:\\n            if (not stack and p.isnumeric()) or (stack and p.isnumeric()):\\n                stack.append(int(p))\\n            elif p == \"+\" and len(stack) >= 2:\\n                stack.append(stack[-2] + stack[-1])\\n            elif p == \"D\" and stack:\\n                stack.append(2 * stack[-1])\\n            elif p == \"C\" and stack:\\n                stack.pop()\\n        return sum(stack)\\n            where is the problem in this solution? it is not passing this test case \"[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\\n\""
                    },
                    {
                        "username": "Harp1207",
                        "content": "\"-2\".isnumeric()  --> False\\u3002btw, you do not need to check check stack\\'s empty or length since the test data make sure valid"
                    },
                    {
                        "username": "itsV_768",
                        "content": "in my approach I was not resetting the char and int .\\nBut happy , solved it by my self"
                    },
                    {
                        "username": "sudhirpatra",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& o) {\\n        vector<int>res;\\n        for(int i=0;i<o.size();i++){\\n            if(o[i]==\"+\") {\\n                res.push_back(res[res.size()-1]+res[res.size()-2]);            \\n            }\\n            else if(o[i]==\"D\") {\\n                res.push_back(res[res.size()-1]*2);\\n            }\\n            else if(o[i]==\"C\") {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(stoi(o[i]));\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<res.size();i++){\\n            sum=sum+res[i];\\n        }\\n        return sum;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1972611,
                "content": [
                    {
                        "username": "abhay_mnit22",
                        "content": "use .equals instead of == (java )"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "Thank you"
                    },
                    {
                        "username": "shoaibhossain24",
                        "content": "I first tried on Intellij and then posted the solution here, the results tell me the output is 7 expected 30, in my IDE the output is 30.\\nAny Idea why?"
                    },
                    {
                        "username": "aritrakunda3",
                        "content": "I did not get why my solution takes more memory , I did not used any additional data structure."
                    },
                    {
                        "username": "user4657aM",
                        "content": "In leetcode I\\'m getting the following error:\\n\\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 786, java.base/java.lang.Integer.parseInt\\n  at line 12, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nBut the same code gets compiled in online gdb and gives correct ans..\\nPlease give any suggestion"
                    },
                    {
                        "username": "SV_Shriyansh",
                        "content": "I am getting NumberFormatException for   `int temp = Integer.parseInt(operations[i])` Can any one help me out how to resolve it.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "A `NumberFormatException` is thrown by Java methods that attempt to convert a `String` into a number, like `Integer.parseInt()`, when the `String` cannot be properly parsed into a number. In this case, the `NumberFormatException` is thrown because the code attempts to parse non-numeric strings (\"C\", \"D\", \"+\") into integers.\\n\\nTo avoid the `NumberFormatException`, you can add checks for non-numeric strings in your code. Here\\'s a Java solution for your problem that handles the different types of operations correctly:\\n\\n```java\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (String op : operations) {\\n            if (op.equals(\"C\")) {\\n                stack.pop();\\n            } else if (op.equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            } else if (op.equals(\"+\")) {\\n                int top = stack.pop();\\n                int newtop = top + stack.peek();\\n                stack.push(top);\\n                stack.push(newtop);\\n            } else {\\n                stack.push(Integer.parseInt(op));\\n            }\\n        }\\n        int sum = 0;\\n        for(int score : stack) {\\n            sum += score;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nIn this code:\\n\\n1. We use a `Stack` to keep track of the scores.\\n2. We iterate over each operation:\\n   - If the operation is \\'C\\', we remove the last score by calling `pop()`.\\n   - If the operation is \\'D\\', we double the last score and push it onto the `Stack`.\\n   - If the operation is \\'+\\', we add the last two scores and push the sum onto the `Stack`.\\n   - Otherwise, the operation is a `String` representing an integer. We parse it to an integer and push it onto the `Stack`.\\n3. Finally, we return the sum of all scores in the `Stack`."
                    },
                    {
                        "username": "oleg-mng",
                        "content": "you can try to use List<String> \nconvert from String to int and back"
                    },
                    {
                        "username": "Xswefv87526492",
                        "content": "please help\\n\\nfor case 20 :  [\"-60\",\"D\",\"-36\",\"30\",\"13\",\"C\",\"C\",\"-33\",\"53\",\"79\"]\\nmy output is -87 \\nexpected is:-117 \\nbut when i do the ansewer on paper my answer comes to be \\n\\n\\n\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n      int count=0;\\n      for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n          operations[i]=null;\\n          operations[i-1]=null;\\n          count+=1;\\n        }\\n      }\\n        String[] op=new String[operations.length-count];\\n        int r=0;\\n        for(int k=0;k<operations.length;k++){\\n          if(operations[k]==null){\\n            continue;\\n          }else{\\n            op[r]=operations[k];\\n             r++;\\n          }\\n        }\\n        int[] arr=new int[operations.length-count];\\n        int pos=0;\\n        for(int j=0;j<op.length;j++){\\n          if(op[j]==null){\\n            continue;\\n          }\\n          \\n         if(op[j].equals(\"D\")){\\n            int vald=(arr[j-1]);\\n            arr[pos]=vald*2;\\n            pos++;\\n\\n          }else if(op[j].equals(\"+\")){\\n            int val1a=(arr[j-2]);\\n            int val2a=(arr[j-1]);\\n            arr[pos]=val1a+val2a;\\n            pos++;\\n          }else{\\n            int okval=Integer.parseInt(op[j]);\\n            arr[pos]=okval;\\n            pos++;\\n          }\\n        }\\n\\n          int sumof=0;\\n          for(int o=0;o<arr.length;o++){\\n            sumof+=arr[o];\\n          }\\n         \\n          return sumof;\\n}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem in your code is that when you encounter \"C\", you just nullify the current operation and the previous operation, which does not correctly represent the described behavior. Instead, you should think about \"C\" as removing the last valid score from the record.\\n\\nAlso, when \"D\" and \"+\" occur, you\\'re accessing the array at index \"j-1\" and \"j-2\", but you should access the array at index \"pos-1\" and \"pos-2\" because \"pos\" tracks the number of valid scores.\\n\\nHere is the corrected version of your code:\\n\\n```java\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n        int[] arr = new int[operations.length];\\n        int pos = 0;\\n        \\n        for(int j=0;j<operations.length;j++){\\n            if(operations[j].equals(\"D\")){\\n                arr[pos] = 2 * arr[pos-1];\\n                pos++;\\n            } else if(operations[j].equals(\"+\")){\\n                arr[pos] = arr[pos-1] + arr[pos-2];\\n                pos++;\\n            } else if(operations[j].equals(\"C\")){\\n                arr[pos-1] = 0; // Invalidate the last score\\n                pos = pos > 0 ? pos-1 : 0; // Make sure not to go negative\\n            } else {\\n                arr[pos] = Integer.parseInt(operations[j]);\\n                pos++;\\n            }\\n        }\\n      \\n        int sumof = 0;\\n        for(int o = 0; o < arr.length; o++){\\n            sumof += arr[o];\\n        }\\n     \\n        return sumof;\\n    }\\n}\\n```\\n\\nIn this corrected version, we keep track of the valid scores in the `arr` array and use the `pos` variable to keep track of the position of the last valid score. We then handle each operation according to the problem\\'s description."
                    },
                    {
                        "username": "mirshod_py",
                        "content": "        stack = []\\n        for p in operations:\\n            if (not stack and p.isnumeric()) or (stack and p.isnumeric()):\\n                stack.append(int(p))\\n            elif p == \"+\" and len(stack) >= 2:\\n                stack.append(stack[-2] + stack[-1])\\n            elif p == \"D\" and stack:\\n                stack.append(2 * stack[-1])\\n            elif p == \"C\" and stack:\\n                stack.pop()\\n        return sum(stack)\\n            where is the problem in this solution? it is not passing this test case \"[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\\n\""
                    },
                    {
                        "username": "Harp1207",
                        "content": "\"-2\".isnumeric()  --> False\\u3002btw, you do not need to check check stack\\'s empty or length since the test data make sure valid"
                    },
                    {
                        "username": "itsV_768",
                        "content": "in my approach I was not resetting the char and int .\\nBut happy , solved it by my self"
                    },
                    {
                        "username": "sudhirpatra",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& o) {\\n        vector<int>res;\\n        for(int i=0;i<o.size();i++){\\n            if(o[i]==\"+\") {\\n                res.push_back(res[res.size()-1]+res[res.size()-2]);            \\n            }\\n            else if(o[i]==\"D\") {\\n                res.push_back(res[res.size()-1]*2);\\n            }\\n            else if(o[i]==\"C\") {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(stoi(o[i]));\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<res.size();i++){\\n            sum=sum+res[i];\\n        }\\n        return sum;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1939492,
                "content": [
                    {
                        "username": "abhay_mnit22",
                        "content": "use .equals instead of == (java )"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "Thank you"
                    },
                    {
                        "username": "shoaibhossain24",
                        "content": "I first tried on Intellij and then posted the solution here, the results tell me the output is 7 expected 30, in my IDE the output is 30.\\nAny Idea why?"
                    },
                    {
                        "username": "aritrakunda3",
                        "content": "I did not get why my solution takes more memory , I did not used any additional data structure."
                    },
                    {
                        "username": "user4657aM",
                        "content": "In leetcode I\\'m getting the following error:\\n\\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 786, java.base/java.lang.Integer.parseInt\\n  at line 12, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nBut the same code gets compiled in online gdb and gives correct ans..\\nPlease give any suggestion"
                    },
                    {
                        "username": "SV_Shriyansh",
                        "content": "I am getting NumberFormatException for   `int temp = Integer.parseInt(operations[i])` Can any one help me out how to resolve it.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "A `NumberFormatException` is thrown by Java methods that attempt to convert a `String` into a number, like `Integer.parseInt()`, when the `String` cannot be properly parsed into a number. In this case, the `NumberFormatException` is thrown because the code attempts to parse non-numeric strings (\"C\", \"D\", \"+\") into integers.\\n\\nTo avoid the `NumberFormatException`, you can add checks for non-numeric strings in your code. Here\\'s a Java solution for your problem that handles the different types of operations correctly:\\n\\n```java\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (String op : operations) {\\n            if (op.equals(\"C\")) {\\n                stack.pop();\\n            } else if (op.equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            } else if (op.equals(\"+\")) {\\n                int top = stack.pop();\\n                int newtop = top + stack.peek();\\n                stack.push(top);\\n                stack.push(newtop);\\n            } else {\\n                stack.push(Integer.parseInt(op));\\n            }\\n        }\\n        int sum = 0;\\n        for(int score : stack) {\\n            sum += score;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nIn this code:\\n\\n1. We use a `Stack` to keep track of the scores.\\n2. We iterate over each operation:\\n   - If the operation is \\'C\\', we remove the last score by calling `pop()`.\\n   - If the operation is \\'D\\', we double the last score and push it onto the `Stack`.\\n   - If the operation is \\'+\\', we add the last two scores and push the sum onto the `Stack`.\\n   - Otherwise, the operation is a `String` representing an integer. We parse it to an integer and push it onto the `Stack`.\\n3. Finally, we return the sum of all scores in the `Stack`."
                    },
                    {
                        "username": "oleg-mng",
                        "content": "you can try to use List<String> \nconvert from String to int and back"
                    },
                    {
                        "username": "Xswefv87526492",
                        "content": "please help\\n\\nfor case 20 :  [\"-60\",\"D\",\"-36\",\"30\",\"13\",\"C\",\"C\",\"-33\",\"53\",\"79\"]\\nmy output is -87 \\nexpected is:-117 \\nbut when i do the ansewer on paper my answer comes to be \\n\\n\\n\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n      int count=0;\\n      for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n          operations[i]=null;\\n          operations[i-1]=null;\\n          count+=1;\\n        }\\n      }\\n        String[] op=new String[operations.length-count];\\n        int r=0;\\n        for(int k=0;k<operations.length;k++){\\n          if(operations[k]==null){\\n            continue;\\n          }else{\\n            op[r]=operations[k];\\n             r++;\\n          }\\n        }\\n        int[] arr=new int[operations.length-count];\\n        int pos=0;\\n        for(int j=0;j<op.length;j++){\\n          if(op[j]==null){\\n            continue;\\n          }\\n          \\n         if(op[j].equals(\"D\")){\\n            int vald=(arr[j-1]);\\n            arr[pos]=vald*2;\\n            pos++;\\n\\n          }else if(op[j].equals(\"+\")){\\n            int val1a=(arr[j-2]);\\n            int val2a=(arr[j-1]);\\n            arr[pos]=val1a+val2a;\\n            pos++;\\n          }else{\\n            int okval=Integer.parseInt(op[j]);\\n            arr[pos]=okval;\\n            pos++;\\n          }\\n        }\\n\\n          int sumof=0;\\n          for(int o=0;o<arr.length;o++){\\n            sumof+=arr[o];\\n          }\\n         \\n          return sumof;\\n}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem in your code is that when you encounter \"C\", you just nullify the current operation and the previous operation, which does not correctly represent the described behavior. Instead, you should think about \"C\" as removing the last valid score from the record.\\n\\nAlso, when \"D\" and \"+\" occur, you\\'re accessing the array at index \"j-1\" and \"j-2\", but you should access the array at index \"pos-1\" and \"pos-2\" because \"pos\" tracks the number of valid scores.\\n\\nHere is the corrected version of your code:\\n\\n```java\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n        int[] arr = new int[operations.length];\\n        int pos = 0;\\n        \\n        for(int j=0;j<operations.length;j++){\\n            if(operations[j].equals(\"D\")){\\n                arr[pos] = 2 * arr[pos-1];\\n                pos++;\\n            } else if(operations[j].equals(\"+\")){\\n                arr[pos] = arr[pos-1] + arr[pos-2];\\n                pos++;\\n            } else if(operations[j].equals(\"C\")){\\n                arr[pos-1] = 0; // Invalidate the last score\\n                pos = pos > 0 ? pos-1 : 0; // Make sure not to go negative\\n            } else {\\n                arr[pos] = Integer.parseInt(operations[j]);\\n                pos++;\\n            }\\n        }\\n      \\n        int sumof = 0;\\n        for(int o = 0; o < arr.length; o++){\\n            sumof += arr[o];\\n        }\\n     \\n        return sumof;\\n    }\\n}\\n```\\n\\nIn this corrected version, we keep track of the valid scores in the `arr` array and use the `pos` variable to keep track of the position of the last valid score. We then handle each operation according to the problem\\'s description."
                    },
                    {
                        "username": "mirshod_py",
                        "content": "        stack = []\\n        for p in operations:\\n            if (not stack and p.isnumeric()) or (stack and p.isnumeric()):\\n                stack.append(int(p))\\n            elif p == \"+\" and len(stack) >= 2:\\n                stack.append(stack[-2] + stack[-1])\\n            elif p == \"D\" and stack:\\n                stack.append(2 * stack[-1])\\n            elif p == \"C\" and stack:\\n                stack.pop()\\n        return sum(stack)\\n            where is the problem in this solution? it is not passing this test case \"[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\\n\""
                    },
                    {
                        "username": "Harp1207",
                        "content": "\"-2\".isnumeric()  --> False\\u3002btw, you do not need to check check stack\\'s empty or length since the test data make sure valid"
                    },
                    {
                        "username": "itsV_768",
                        "content": "in my approach I was not resetting the char and int .\\nBut happy , solved it by my self"
                    },
                    {
                        "username": "sudhirpatra",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& o) {\\n        vector<int>res;\\n        for(int i=0;i<o.size();i++){\\n            if(o[i]==\"+\") {\\n                res.push_back(res[res.size()-1]+res[res.size()-2]);            \\n            }\\n            else if(o[i]==\"D\") {\\n                res.push_back(res[res.size()-1]*2);\\n            }\\n            else if(o[i]==\"C\") {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(stoi(o[i]));\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<res.size();i++){\\n            sum=sum+res[i];\\n        }\\n        return sum;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1896821,
                "content": [
                    {
                        "username": "abhay_mnit22",
                        "content": "use .equals instead of == (java )"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "Thank you"
                    },
                    {
                        "username": "shoaibhossain24",
                        "content": "I first tried on Intellij and then posted the solution here, the results tell me the output is 7 expected 30, in my IDE the output is 30.\\nAny Idea why?"
                    },
                    {
                        "username": "aritrakunda3",
                        "content": "I did not get why my solution takes more memory , I did not used any additional data structure."
                    },
                    {
                        "username": "user4657aM",
                        "content": "In leetcode I\\'m getting the following error:\\n\\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 786, java.base/java.lang.Integer.parseInt\\n  at line 12, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nBut the same code gets compiled in online gdb and gives correct ans..\\nPlease give any suggestion"
                    },
                    {
                        "username": "SV_Shriyansh",
                        "content": "I am getting NumberFormatException for   `int temp = Integer.parseInt(operations[i])` Can any one help me out how to resolve it.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "A `NumberFormatException` is thrown by Java methods that attempt to convert a `String` into a number, like `Integer.parseInt()`, when the `String` cannot be properly parsed into a number. In this case, the `NumberFormatException` is thrown because the code attempts to parse non-numeric strings (\"C\", \"D\", \"+\") into integers.\\n\\nTo avoid the `NumberFormatException`, you can add checks for non-numeric strings in your code. Here\\'s a Java solution for your problem that handles the different types of operations correctly:\\n\\n```java\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (String op : operations) {\\n            if (op.equals(\"C\")) {\\n                stack.pop();\\n            } else if (op.equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            } else if (op.equals(\"+\")) {\\n                int top = stack.pop();\\n                int newtop = top + stack.peek();\\n                stack.push(top);\\n                stack.push(newtop);\\n            } else {\\n                stack.push(Integer.parseInt(op));\\n            }\\n        }\\n        int sum = 0;\\n        for(int score : stack) {\\n            sum += score;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nIn this code:\\n\\n1. We use a `Stack` to keep track of the scores.\\n2. We iterate over each operation:\\n   - If the operation is \\'C\\', we remove the last score by calling `pop()`.\\n   - If the operation is \\'D\\', we double the last score and push it onto the `Stack`.\\n   - If the operation is \\'+\\', we add the last two scores and push the sum onto the `Stack`.\\n   - Otherwise, the operation is a `String` representing an integer. We parse it to an integer and push it onto the `Stack`.\\n3. Finally, we return the sum of all scores in the `Stack`."
                    },
                    {
                        "username": "oleg-mng",
                        "content": "you can try to use List<String> \nconvert from String to int and back"
                    },
                    {
                        "username": "Xswefv87526492",
                        "content": "please help\\n\\nfor case 20 :  [\"-60\",\"D\",\"-36\",\"30\",\"13\",\"C\",\"C\",\"-33\",\"53\",\"79\"]\\nmy output is -87 \\nexpected is:-117 \\nbut when i do the ansewer on paper my answer comes to be \\n\\n\\n\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n      int count=0;\\n      for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n          operations[i]=null;\\n          operations[i-1]=null;\\n          count+=1;\\n        }\\n      }\\n        String[] op=new String[operations.length-count];\\n        int r=0;\\n        for(int k=0;k<operations.length;k++){\\n          if(operations[k]==null){\\n            continue;\\n          }else{\\n            op[r]=operations[k];\\n             r++;\\n          }\\n        }\\n        int[] arr=new int[operations.length-count];\\n        int pos=0;\\n        for(int j=0;j<op.length;j++){\\n          if(op[j]==null){\\n            continue;\\n          }\\n          \\n         if(op[j].equals(\"D\")){\\n            int vald=(arr[j-1]);\\n            arr[pos]=vald*2;\\n            pos++;\\n\\n          }else if(op[j].equals(\"+\")){\\n            int val1a=(arr[j-2]);\\n            int val2a=(arr[j-1]);\\n            arr[pos]=val1a+val2a;\\n            pos++;\\n          }else{\\n            int okval=Integer.parseInt(op[j]);\\n            arr[pos]=okval;\\n            pos++;\\n          }\\n        }\\n\\n          int sumof=0;\\n          for(int o=0;o<arr.length;o++){\\n            sumof+=arr[o];\\n          }\\n         \\n          return sumof;\\n}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem in your code is that when you encounter \"C\", you just nullify the current operation and the previous operation, which does not correctly represent the described behavior. Instead, you should think about \"C\" as removing the last valid score from the record.\\n\\nAlso, when \"D\" and \"+\" occur, you\\'re accessing the array at index \"j-1\" and \"j-2\", but you should access the array at index \"pos-1\" and \"pos-2\" because \"pos\" tracks the number of valid scores.\\n\\nHere is the corrected version of your code:\\n\\n```java\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n        int[] arr = new int[operations.length];\\n        int pos = 0;\\n        \\n        for(int j=0;j<operations.length;j++){\\n            if(operations[j].equals(\"D\")){\\n                arr[pos] = 2 * arr[pos-1];\\n                pos++;\\n            } else if(operations[j].equals(\"+\")){\\n                arr[pos] = arr[pos-1] + arr[pos-2];\\n                pos++;\\n            } else if(operations[j].equals(\"C\")){\\n                arr[pos-1] = 0; // Invalidate the last score\\n                pos = pos > 0 ? pos-1 : 0; // Make sure not to go negative\\n            } else {\\n                arr[pos] = Integer.parseInt(operations[j]);\\n                pos++;\\n            }\\n        }\\n      \\n        int sumof = 0;\\n        for(int o = 0; o < arr.length; o++){\\n            sumof += arr[o];\\n        }\\n     \\n        return sumof;\\n    }\\n}\\n```\\n\\nIn this corrected version, we keep track of the valid scores in the `arr` array and use the `pos` variable to keep track of the position of the last valid score. We then handle each operation according to the problem\\'s description."
                    },
                    {
                        "username": "mirshod_py",
                        "content": "        stack = []\\n        for p in operations:\\n            if (not stack and p.isnumeric()) or (stack and p.isnumeric()):\\n                stack.append(int(p))\\n            elif p == \"+\" and len(stack) >= 2:\\n                stack.append(stack[-2] + stack[-1])\\n            elif p == \"D\" and stack:\\n                stack.append(2 * stack[-1])\\n            elif p == \"C\" and stack:\\n                stack.pop()\\n        return sum(stack)\\n            where is the problem in this solution? it is not passing this test case \"[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\\n\""
                    },
                    {
                        "username": "Harp1207",
                        "content": "\"-2\".isnumeric()  --> False\\u3002btw, you do not need to check check stack\\'s empty or length since the test data make sure valid"
                    },
                    {
                        "username": "itsV_768",
                        "content": "in my approach I was not resetting the char and int .\\nBut happy , solved it by my self"
                    },
                    {
                        "username": "sudhirpatra",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& o) {\\n        vector<int>res;\\n        for(int i=0;i<o.size();i++){\\n            if(o[i]==\"+\") {\\n                res.push_back(res[res.size()-1]+res[res.size()-2]);            \\n            }\\n            else if(o[i]==\"D\") {\\n                res.push_back(res[res.size()-1]*2);\\n            }\\n            else if(o[i]==\"C\") {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(stoi(o[i]));\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<res.size();i++){\\n            sum=sum+res[i];\\n        }\\n        return sum;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1891628,
                "content": [
                    {
                        "username": "abhay_mnit22",
                        "content": "use .equals instead of == (java )"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "Thank you"
                    },
                    {
                        "username": "shoaibhossain24",
                        "content": "I first tried on Intellij and then posted the solution here, the results tell me the output is 7 expected 30, in my IDE the output is 30.\\nAny Idea why?"
                    },
                    {
                        "username": "aritrakunda3",
                        "content": "I did not get why my solution takes more memory , I did not used any additional data structure."
                    },
                    {
                        "username": "user4657aM",
                        "content": "In leetcode I\\'m getting the following error:\\n\\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 786, java.base/java.lang.Integer.parseInt\\n  at line 12, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nBut the same code gets compiled in online gdb and gives correct ans..\\nPlease give any suggestion"
                    },
                    {
                        "username": "SV_Shriyansh",
                        "content": "I am getting NumberFormatException for   `int temp = Integer.parseInt(operations[i])` Can any one help me out how to resolve it.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "A `NumberFormatException` is thrown by Java methods that attempt to convert a `String` into a number, like `Integer.parseInt()`, when the `String` cannot be properly parsed into a number. In this case, the `NumberFormatException` is thrown because the code attempts to parse non-numeric strings (\"C\", \"D\", \"+\") into integers.\\n\\nTo avoid the `NumberFormatException`, you can add checks for non-numeric strings in your code. Here\\'s a Java solution for your problem that handles the different types of operations correctly:\\n\\n```java\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (String op : operations) {\\n            if (op.equals(\"C\")) {\\n                stack.pop();\\n            } else if (op.equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            } else if (op.equals(\"+\")) {\\n                int top = stack.pop();\\n                int newtop = top + stack.peek();\\n                stack.push(top);\\n                stack.push(newtop);\\n            } else {\\n                stack.push(Integer.parseInt(op));\\n            }\\n        }\\n        int sum = 0;\\n        for(int score : stack) {\\n            sum += score;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nIn this code:\\n\\n1. We use a `Stack` to keep track of the scores.\\n2. We iterate over each operation:\\n   - If the operation is \\'C\\', we remove the last score by calling `pop()`.\\n   - If the operation is \\'D\\', we double the last score and push it onto the `Stack`.\\n   - If the operation is \\'+\\', we add the last two scores and push the sum onto the `Stack`.\\n   - Otherwise, the operation is a `String` representing an integer. We parse it to an integer and push it onto the `Stack`.\\n3. Finally, we return the sum of all scores in the `Stack`."
                    },
                    {
                        "username": "oleg-mng",
                        "content": "you can try to use List<String> \nconvert from String to int and back"
                    },
                    {
                        "username": "Xswefv87526492",
                        "content": "please help\\n\\nfor case 20 :  [\"-60\",\"D\",\"-36\",\"30\",\"13\",\"C\",\"C\",\"-33\",\"53\",\"79\"]\\nmy output is -87 \\nexpected is:-117 \\nbut when i do the ansewer on paper my answer comes to be \\n\\n\\n\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n      int count=0;\\n      for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n          operations[i]=null;\\n          operations[i-1]=null;\\n          count+=1;\\n        }\\n      }\\n        String[] op=new String[operations.length-count];\\n        int r=0;\\n        for(int k=0;k<operations.length;k++){\\n          if(operations[k]==null){\\n            continue;\\n          }else{\\n            op[r]=operations[k];\\n             r++;\\n          }\\n        }\\n        int[] arr=new int[operations.length-count];\\n        int pos=0;\\n        for(int j=0;j<op.length;j++){\\n          if(op[j]==null){\\n            continue;\\n          }\\n          \\n         if(op[j].equals(\"D\")){\\n            int vald=(arr[j-1]);\\n            arr[pos]=vald*2;\\n            pos++;\\n\\n          }else if(op[j].equals(\"+\")){\\n            int val1a=(arr[j-2]);\\n            int val2a=(arr[j-1]);\\n            arr[pos]=val1a+val2a;\\n            pos++;\\n          }else{\\n            int okval=Integer.parseInt(op[j]);\\n            arr[pos]=okval;\\n            pos++;\\n          }\\n        }\\n\\n          int sumof=0;\\n          for(int o=0;o<arr.length;o++){\\n            sumof+=arr[o];\\n          }\\n         \\n          return sumof;\\n}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem in your code is that when you encounter \"C\", you just nullify the current operation and the previous operation, which does not correctly represent the described behavior. Instead, you should think about \"C\" as removing the last valid score from the record.\\n\\nAlso, when \"D\" and \"+\" occur, you\\'re accessing the array at index \"j-1\" and \"j-2\", but you should access the array at index \"pos-1\" and \"pos-2\" because \"pos\" tracks the number of valid scores.\\n\\nHere is the corrected version of your code:\\n\\n```java\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n        int[] arr = new int[operations.length];\\n        int pos = 0;\\n        \\n        for(int j=0;j<operations.length;j++){\\n            if(operations[j].equals(\"D\")){\\n                arr[pos] = 2 * arr[pos-1];\\n                pos++;\\n            } else if(operations[j].equals(\"+\")){\\n                arr[pos] = arr[pos-1] + arr[pos-2];\\n                pos++;\\n            } else if(operations[j].equals(\"C\")){\\n                arr[pos-1] = 0; // Invalidate the last score\\n                pos = pos > 0 ? pos-1 : 0; // Make sure not to go negative\\n            } else {\\n                arr[pos] = Integer.parseInt(operations[j]);\\n                pos++;\\n            }\\n        }\\n      \\n        int sumof = 0;\\n        for(int o = 0; o < arr.length; o++){\\n            sumof += arr[o];\\n        }\\n     \\n        return sumof;\\n    }\\n}\\n```\\n\\nIn this corrected version, we keep track of the valid scores in the `arr` array and use the `pos` variable to keep track of the position of the last valid score. We then handle each operation according to the problem\\'s description."
                    },
                    {
                        "username": "mirshod_py",
                        "content": "        stack = []\\n        for p in operations:\\n            if (not stack and p.isnumeric()) or (stack and p.isnumeric()):\\n                stack.append(int(p))\\n            elif p == \"+\" and len(stack) >= 2:\\n                stack.append(stack[-2] + stack[-1])\\n            elif p == \"D\" and stack:\\n                stack.append(2 * stack[-1])\\n            elif p == \"C\" and stack:\\n                stack.pop()\\n        return sum(stack)\\n            where is the problem in this solution? it is not passing this test case \"[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\\n\""
                    },
                    {
                        "username": "Harp1207",
                        "content": "\"-2\".isnumeric()  --> False\\u3002btw, you do not need to check check stack\\'s empty or length since the test data make sure valid"
                    },
                    {
                        "username": "itsV_768",
                        "content": "in my approach I was not resetting the char and int .\\nBut happy , solved it by my self"
                    },
                    {
                        "username": "sudhirpatra",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& o) {\\n        vector<int>res;\\n        for(int i=0;i<o.size();i++){\\n            if(o[i]==\"+\") {\\n                res.push_back(res[res.size()-1]+res[res.size()-2]);            \\n            }\\n            else if(o[i]==\"D\") {\\n                res.push_back(res[res.size()-1]*2);\\n            }\\n            else if(o[i]==\"C\") {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(stoi(o[i]));\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<res.size();i++){\\n            sum=sum+res[i];\\n        }\\n        return sum;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1804382,
                "content": [
                    {
                        "username": "abhay_mnit22",
                        "content": "use .equals instead of == (java )"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "Thank you"
                    },
                    {
                        "username": "shoaibhossain24",
                        "content": "I first tried on Intellij and then posted the solution here, the results tell me the output is 7 expected 30, in my IDE the output is 30.\\nAny Idea why?"
                    },
                    {
                        "username": "aritrakunda3",
                        "content": "I did not get why my solution takes more memory , I did not used any additional data structure."
                    },
                    {
                        "username": "user4657aM",
                        "content": "In leetcode I\\'m getting the following error:\\n\\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 786, java.base/java.lang.Integer.parseInt\\n  at line 12, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nBut the same code gets compiled in online gdb and gives correct ans..\\nPlease give any suggestion"
                    },
                    {
                        "username": "SV_Shriyansh",
                        "content": "I am getting NumberFormatException for   `int temp = Integer.parseInt(operations[i])` Can any one help me out how to resolve it.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "A `NumberFormatException` is thrown by Java methods that attempt to convert a `String` into a number, like `Integer.parseInt()`, when the `String` cannot be properly parsed into a number. In this case, the `NumberFormatException` is thrown because the code attempts to parse non-numeric strings (\"C\", \"D\", \"+\") into integers.\\n\\nTo avoid the `NumberFormatException`, you can add checks for non-numeric strings in your code. Here\\'s a Java solution for your problem that handles the different types of operations correctly:\\n\\n```java\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (String op : operations) {\\n            if (op.equals(\"C\")) {\\n                stack.pop();\\n            } else if (op.equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            } else if (op.equals(\"+\")) {\\n                int top = stack.pop();\\n                int newtop = top + stack.peek();\\n                stack.push(top);\\n                stack.push(newtop);\\n            } else {\\n                stack.push(Integer.parseInt(op));\\n            }\\n        }\\n        int sum = 0;\\n        for(int score : stack) {\\n            sum += score;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nIn this code:\\n\\n1. We use a `Stack` to keep track of the scores.\\n2. We iterate over each operation:\\n   - If the operation is \\'C\\', we remove the last score by calling `pop()`.\\n   - If the operation is \\'D\\', we double the last score and push it onto the `Stack`.\\n   - If the operation is \\'+\\', we add the last two scores and push the sum onto the `Stack`.\\n   - Otherwise, the operation is a `String` representing an integer. We parse it to an integer and push it onto the `Stack`.\\n3. Finally, we return the sum of all scores in the `Stack`."
                    },
                    {
                        "username": "oleg-mng",
                        "content": "you can try to use List<String> \nconvert from String to int and back"
                    },
                    {
                        "username": "Xswefv87526492",
                        "content": "please help\\n\\nfor case 20 :  [\"-60\",\"D\",\"-36\",\"30\",\"13\",\"C\",\"C\",\"-33\",\"53\",\"79\"]\\nmy output is -87 \\nexpected is:-117 \\nbut when i do the ansewer on paper my answer comes to be \\n\\n\\n\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n      int count=0;\\n      for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n          operations[i]=null;\\n          operations[i-1]=null;\\n          count+=1;\\n        }\\n      }\\n        String[] op=new String[operations.length-count];\\n        int r=0;\\n        for(int k=0;k<operations.length;k++){\\n          if(operations[k]==null){\\n            continue;\\n          }else{\\n            op[r]=operations[k];\\n             r++;\\n          }\\n        }\\n        int[] arr=new int[operations.length-count];\\n        int pos=0;\\n        for(int j=0;j<op.length;j++){\\n          if(op[j]==null){\\n            continue;\\n          }\\n          \\n         if(op[j].equals(\"D\")){\\n            int vald=(arr[j-1]);\\n            arr[pos]=vald*2;\\n            pos++;\\n\\n          }else if(op[j].equals(\"+\")){\\n            int val1a=(arr[j-2]);\\n            int val2a=(arr[j-1]);\\n            arr[pos]=val1a+val2a;\\n            pos++;\\n          }else{\\n            int okval=Integer.parseInt(op[j]);\\n            arr[pos]=okval;\\n            pos++;\\n          }\\n        }\\n\\n          int sumof=0;\\n          for(int o=0;o<arr.length;o++){\\n            sumof+=arr[o];\\n          }\\n         \\n          return sumof;\\n}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem in your code is that when you encounter \"C\", you just nullify the current operation and the previous operation, which does not correctly represent the described behavior. Instead, you should think about \"C\" as removing the last valid score from the record.\\n\\nAlso, when \"D\" and \"+\" occur, you\\'re accessing the array at index \"j-1\" and \"j-2\", but you should access the array at index \"pos-1\" and \"pos-2\" because \"pos\" tracks the number of valid scores.\\n\\nHere is the corrected version of your code:\\n\\n```java\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n        int[] arr = new int[operations.length];\\n        int pos = 0;\\n        \\n        for(int j=0;j<operations.length;j++){\\n            if(operations[j].equals(\"D\")){\\n                arr[pos] = 2 * arr[pos-1];\\n                pos++;\\n            } else if(operations[j].equals(\"+\")){\\n                arr[pos] = arr[pos-1] + arr[pos-2];\\n                pos++;\\n            } else if(operations[j].equals(\"C\")){\\n                arr[pos-1] = 0; // Invalidate the last score\\n                pos = pos > 0 ? pos-1 : 0; // Make sure not to go negative\\n            } else {\\n                arr[pos] = Integer.parseInt(operations[j]);\\n                pos++;\\n            }\\n        }\\n      \\n        int sumof = 0;\\n        for(int o = 0; o < arr.length; o++){\\n            sumof += arr[o];\\n        }\\n     \\n        return sumof;\\n    }\\n}\\n```\\n\\nIn this corrected version, we keep track of the valid scores in the `arr` array and use the `pos` variable to keep track of the position of the last valid score. We then handle each operation according to the problem\\'s description."
                    },
                    {
                        "username": "mirshod_py",
                        "content": "        stack = []\\n        for p in operations:\\n            if (not stack and p.isnumeric()) or (stack and p.isnumeric()):\\n                stack.append(int(p))\\n            elif p == \"+\" and len(stack) >= 2:\\n                stack.append(stack[-2] + stack[-1])\\n            elif p == \"D\" and stack:\\n                stack.append(2 * stack[-1])\\n            elif p == \"C\" and stack:\\n                stack.pop()\\n        return sum(stack)\\n            where is the problem in this solution? it is not passing this test case \"[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\\n\""
                    },
                    {
                        "username": "Harp1207",
                        "content": "\"-2\".isnumeric()  --> False\\u3002btw, you do not need to check check stack\\'s empty or length since the test data make sure valid"
                    },
                    {
                        "username": "itsV_768",
                        "content": "in my approach I was not resetting the char and int .\\nBut happy , solved it by my self"
                    },
                    {
                        "username": "sudhirpatra",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& o) {\\n        vector<int>res;\\n        for(int i=0;i<o.size();i++){\\n            if(o[i]==\"+\") {\\n                res.push_back(res[res.size()-1]+res[res.size()-2]);            \\n            }\\n            else if(o[i]==\"D\") {\\n                res.push_back(res[res.size()-1]*2);\\n            }\\n            else if(o[i]==\"C\") {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(stoi(o[i]));\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<res.size();i++){\\n            sum=sum+res[i];\\n        }\\n        return sum;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1768379,
                "content": [
                    {
                        "username": "abhay_mnit22",
                        "content": "use .equals instead of == (java )"
                    },
                    {
                        "username": "Kritik18Wankhede",
                        "content": "Thank you"
                    },
                    {
                        "username": "shoaibhossain24",
                        "content": "I first tried on Intellij and then posted the solution here, the results tell me the output is 7 expected 30, in my IDE the output is 30.\\nAny Idea why?"
                    },
                    {
                        "username": "aritrakunda3",
                        "content": "I did not get why my solution takes more memory , I did not used any additional data structure."
                    },
                    {
                        "username": "user4657aM",
                        "content": "In leetcode I\\'m getting the following error:\\n\\njava.lang.NumberFormatException: For input string: \"C\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 786, java.base/java.lang.Integer.parseInt\\n  at line 12, Solution.calPoints\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nBut the same code gets compiled in online gdb and gives correct ans..\\nPlease give any suggestion"
                    },
                    {
                        "username": "SV_Shriyansh",
                        "content": "I am getting NumberFormatException for   `int temp = Integer.parseInt(operations[i])` Can any one help me out how to resolve it.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "A `NumberFormatException` is thrown by Java methods that attempt to convert a `String` into a number, like `Integer.parseInt()`, when the `String` cannot be properly parsed into a number. In this case, the `NumberFormatException` is thrown because the code attempts to parse non-numeric strings (\"C\", \"D\", \"+\") into integers.\\n\\nTo avoid the `NumberFormatException`, you can add checks for non-numeric strings in your code. Here\\'s a Java solution for your problem that handles the different types of operations correctly:\\n\\n```java\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (String op : operations) {\\n            if (op.equals(\"C\")) {\\n                stack.pop();\\n            } else if (op.equals(\"D\")) {\\n                stack.push(2 * stack.peek());\\n            } else if (op.equals(\"+\")) {\\n                int top = stack.pop();\\n                int newtop = top + stack.peek();\\n                stack.push(top);\\n                stack.push(newtop);\\n            } else {\\n                stack.push(Integer.parseInt(op));\\n            }\\n        }\\n        int sum = 0;\\n        for(int score : stack) {\\n            sum += score;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\nIn this code:\\n\\n1. We use a `Stack` to keep track of the scores.\\n2. We iterate over each operation:\\n   - If the operation is \\'C\\', we remove the last score by calling `pop()`.\\n   - If the operation is \\'D\\', we double the last score and push it onto the `Stack`.\\n   - If the operation is \\'+\\', we add the last two scores and push the sum onto the `Stack`.\\n   - Otherwise, the operation is a `String` representing an integer. We parse it to an integer and push it onto the `Stack`.\\n3. Finally, we return the sum of all scores in the `Stack`."
                    },
                    {
                        "username": "oleg-mng",
                        "content": "you can try to use List<String> \nconvert from String to int and back"
                    },
                    {
                        "username": "Xswefv87526492",
                        "content": "please help\\n\\nfor case 20 :  [\"-60\",\"D\",\"-36\",\"30\",\"13\",\"C\",\"C\",\"-33\",\"53\",\"79\"]\\nmy output is -87 \\nexpected is:-117 \\nbut when i do the ansewer on paper my answer comes to be \\n\\n\\n\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n      int count=0;\\n      for(int i=0;i<operations.length;i++){\\n        if(operations[i].equals(\"C\")){\\n          operations[i]=null;\\n          operations[i-1]=null;\\n          count+=1;\\n        }\\n      }\\n        String[] op=new String[operations.length-count];\\n        int r=0;\\n        for(int k=0;k<operations.length;k++){\\n          if(operations[k]==null){\\n            continue;\\n          }else{\\n            op[r]=operations[k];\\n             r++;\\n          }\\n        }\\n        int[] arr=new int[operations.length-count];\\n        int pos=0;\\n        for(int j=0;j<op.length;j++){\\n          if(op[j]==null){\\n            continue;\\n          }\\n          \\n         if(op[j].equals(\"D\")){\\n            int vald=(arr[j-1]);\\n            arr[pos]=vald*2;\\n            pos++;\\n\\n          }else if(op[j].equals(\"+\")){\\n            int val1a=(arr[j-2]);\\n            int val2a=(arr[j-1]);\\n            arr[pos]=val1a+val2a;\\n            pos++;\\n          }else{\\n            int okval=Integer.parseInt(op[j]);\\n            arr[pos]=okval;\\n            pos++;\\n          }\\n        }\\n\\n          int sumof=0;\\n          for(int o=0;o<arr.length;o++){\\n            sumof+=arr[o];\\n          }\\n         \\n          return sumof;\\n}\\n}\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem in your code is that when you encounter \"C\", you just nullify the current operation and the previous operation, which does not correctly represent the described behavior. Instead, you should think about \"C\" as removing the last valid score from the record.\\n\\nAlso, when \"D\" and \"+\" occur, you\\'re accessing the array at index \"j-1\" and \"j-2\", but you should access the array at index \"pos-1\" and \"pos-2\" because \"pos\" tracks the number of valid scores.\\n\\nHere is the corrected version of your code:\\n\\n```java\\nimport java.util.*;\\npublic class Solution {\\n    public static int calPoints(String[] operations) {\\n        int[] arr = new int[operations.length];\\n        int pos = 0;\\n        \\n        for(int j=0;j<operations.length;j++){\\n            if(operations[j].equals(\"D\")){\\n                arr[pos] = 2 * arr[pos-1];\\n                pos++;\\n            } else if(operations[j].equals(\"+\")){\\n                arr[pos] = arr[pos-1] + arr[pos-2];\\n                pos++;\\n            } else if(operations[j].equals(\"C\")){\\n                arr[pos-1] = 0; // Invalidate the last score\\n                pos = pos > 0 ? pos-1 : 0; // Make sure not to go negative\\n            } else {\\n                arr[pos] = Integer.parseInt(operations[j]);\\n                pos++;\\n            }\\n        }\\n      \\n        int sumof = 0;\\n        for(int o = 0; o < arr.length; o++){\\n            sumof += arr[o];\\n        }\\n     \\n        return sumof;\\n    }\\n}\\n```\\n\\nIn this corrected version, we keep track of the valid scores in the `arr` array and use the `pos` variable to keep track of the position of the last valid score. We then handle each operation according to the problem\\'s description."
                    },
                    {
                        "username": "mirshod_py",
                        "content": "        stack = []\\n        for p in operations:\\n            if (not stack and p.isnumeric()) or (stack and p.isnumeric()):\\n                stack.append(int(p))\\n            elif p == \"+\" and len(stack) >= 2:\\n                stack.append(stack[-2] + stack[-1])\\n            elif p == \"D\" and stack:\\n                stack.append(2 * stack[-1])\\n            elif p == \"C\" and stack:\\n                stack.pop()\\n        return sum(stack)\\n            where is the problem in this solution? it is not passing this test case \"[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\\n\""
                    },
                    {
                        "username": "Harp1207",
                        "content": "\"-2\".isnumeric()  --> False\\u3002btw, you do not need to check check stack\\'s empty or length since the test data make sure valid"
                    },
                    {
                        "username": "itsV_768",
                        "content": "in my approach I was not resetting the char and int .\\nBut happy , solved it by my self"
                    },
                    {
                        "username": "sudhirpatra",
                        "content": "C++ Solution\\n\\nclass Solution {\\npublic:\\n    int calPoints(vector<string>& o) {\\n        vector<int>res;\\n        for(int i=0;i<o.size();i++){\\n            if(o[i]==\"+\") {\\n                res.push_back(res[res.size()-1]+res[res.size()-2]);            \\n            }\\n            else if(o[i]==\"D\") {\\n                res.push_back(res[res.size()-1]*2);\\n            }\\n            else if(o[i]==\"C\") {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(stoi(o[i]));\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<res.size();i++){\\n            sum=sum+res[i];\\n        }\\n        return sum;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]