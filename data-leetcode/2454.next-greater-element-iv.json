[
    {
        "title": "Next Greater Element IV",
        "question_content": "You are given a 0-indexed array of non-negative integers nums. For each integer in nums, you must find its respective second greater integer.\nThe second greater integer of nums[i] is nums[j] such that:\n\n\tj > i\n\tnums[j] > nums[i]\n\tThere exists exactly one index k such that nums[k] > nums[i] and i < k < j.\n\nIf there is no such nums[j], the second greater integer is considered to be -1.\n\n\tFor example, in the array [1, 2, 4, 3], the second greater integer of 1 is 4, 2 is 3,&nbsp;and that of 3 and 4 is -1.\n\nReturn an integer array answer, where answer[i] is the second greater integer of nums[i].\n&nbsp;\nExample 1:\n\nInput: nums = [2,4,0,9,6]\nOutput: [9,6,6,-1,-1]\nExplanation:\n0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.\n1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.\n2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.\n3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.\n4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.\nThus, we return [9,6,6,-1,-1].\n\nExample 2:\n\nInput: nums = [3,3]\nOutput: [-1,-1]\nExplanation:\nWe return [-1,-1] since neither integer has any integer greater than it.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t0 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 2756668,
                "title": "java-c-python-one-pass-stack-solution-o-n",
                "content": "# **Intuition**\\nNext Greater Element canb resolved with one mono stack.\\nCould we resolve this problem with mono stack?\\n<br>\\n\\n# **Explanation**\\nUse two stack `s1` and `s2`.\\nSimilar to \"Next Greater Element\"\\n`s1` stores the index of elements\\nthat have not found their first greater element.\\n\\n`s2` stores the index of elements\\nthat have found their first greater element,\\nhave not found their second greater element.\\n\\nFor each `a = A[i]` in A\\nWe first compare the `a` with the tail elements in `s2`,\\npop all element smaller than `a`,\\nbecause `a` is their second greater element.\\n\\nThen we compare the `a` with the tail elements in `s1`,\\nmove all elements smaller than `a` to the tail of `s2`,\\nbecause `a` is their first greater element.\\n\\nWe repeatly do this for all `A[i]` and finally return the result.\\n<br>\\n\\n# **Complexity**\\nAll `A[i]` is pushed in `s1` and `s2` at most once.\\nAll `A[i]` is pushed in `s1` and `s2` at most once.\\n\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int[] secondGreaterElement(int[] A) {\\n        int n = A.length,  res[] = new int[n];\\n        Arrays.fill(res, -1);\\n        Stack<Integer> s1 = new Stack<>(), s2 = new Stack<>(), tmp = new Stack<>();\\n        for (int i=0; i < n; i++) {\\n            while (!s2.empty() && A[s2.peek()] < A[i])\\n                res[s2.pop()] = A[i];\\n            while (!s1.empty() && A[s1.peek()] < A[i])\\n                tmp.push(s1.pop());\\n            while (!tmp.empty())\\n                s2.push(tmp.pop());\\n            s1.push(i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    vector<int> secondGreaterElement(vector<int>& A) {\\n        int n = A.size();\\n        vector<int> res(n, -1), s1, s2, tmp;\\n        for (int i = 0 ;i < n; ++i) {\\n            while (!s2.empty() && A[s2.back()] < A[i])\\n                res[s2.back()] = A[i], s2.pop_back();\\n            while (!s1.empty() && A[s1.back()] < A[i])\\n                tmp.push_back(s1.back()), s1.pop_back();\\n            while (!tmp.empty())\\n                s2.push_back(tmp.back()), tmp.pop_back();\\n            s1.push_back(i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def secondGreaterElement(self, A: List[int]) -> List[int]:\\n        res, s1, s2 = [-1] * len(A), [], []\\n        for i,a in enumerate(A):\\n            while s2 and A[s2[-1]] < a:\\n                res[s2.pop()] = a;\\n            tmp = []\\n            while s1 and A[s1[-1]] < a:\\n                tmp.append(s1.pop())\\n            s2 += tmp[::-1]\\n            s1.append(i)\\n        return res\\n```\\n\\n# More Good Stack Problems\\nHere are some problems that impressed me.\\nGood luck and have fun.\\n\\n- 2454. [Next Greater Element IV](https://leetcode.com/problems/next-greater-element-iv/discuss/2756668/JavaC%2B%2BPython-One-Pass-Stack-Solution)\\n- 2398. [Maximum Number of Robots Within Budget](https://leetcode.com/problems/maximum-number-of-robots-within-budget/discuss/2524838/Python-Sliding-Window-O(n))\\n- 2289. [Steps to Make Array Non-decreasing](https://leetcode.com/problems/steps-to-make-array-non-decreasing/discuss/2085864/)\\n- 2281. [Sum of Total Strength of Wizards](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/python-solution-on/1405190)\\n- 1776. [Car Fleet II](https://leetcode.com/problems/car-fleet-ii/discuss/1085987/javacpython-on-stack-solution/)\\n- 1673. [Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/952786/javacpython-one-pass-stack-solution/776191 )\\n- 1671. [Minimum Number of Removals to Make Mountain Array](https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/discuss/952136/Python-LIS-O(nlogn))\\n- 1475. [Final Prices With a Special Discount in a Shop](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/discuss/685390/javacpython-stack-one-pass/809992)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1130. [Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n- 907. [Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n- 901. [Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n- 856. [Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n- 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n- 496. Next Greater Element I\\n- 84. Largest Rectangle in Histogram\\n- 42. Trapping Rain Water\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int[] secondGreaterElement(int[] A) {\\n        int n = A.length,  res[] = new int[n];\\n        Arrays.fill(res, -1);\\n        Stack<Integer> s1 = new Stack<>(), s2 = new Stack<>(), tmp = new Stack<>();\\n        for (int i=0; i < n; i++) {\\n            while (!s2.empty() && A[s2.peek()] < A[i])\\n                res[s2.pop()] = A[i];\\n            while (!s1.empty() && A[s1.peek()] < A[i])\\n                tmp.push(s1.pop());\\n            while (!tmp.empty())\\n                s2.push(tmp.pop());\\n            s1.push(i);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> secondGreaterElement(vector<int>& A) {\\n        int n = A.size();\\n        vector<int> res(n, -1), s1, s2, tmp;\\n        for (int i = 0 ;i < n; ++i) {\\n            while (!s2.empty() && A[s2.back()] < A[i])\\n                res[s2.back()] = A[i], s2.pop_back();\\n            while (!s1.empty() && A[s1.back()] < A[i])\\n                tmp.push_back(s1.back()), s1.pop_back();\\n            while (!tmp.empty())\\n                s2.push_back(tmp.back()), tmp.pop_back();\\n            s1.push_back(i);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def secondGreaterElement(self, A: List[int]) -> List[int]:\\n        res, s1, s2 = [-1] * len(A), [], []\\n        for i,a in enumerate(A):\\n            while s2 and A[s2[-1]] < a:\\n                res[s2.pop()] = a;\\n            tmp = []\\n            while s1 and A[s1[-1]] < a:\\n                tmp.append(s1.pop())\\n            s2 += tmp[::-1]\\n            s1.append(i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2756341,
                "title": "c-java-python3-monotonic-stack-priority-queue",
                "content": "**Explanation**\\n* Monotonic stack is used to find the next greater element\\n* In `mid[i]` we store all the indexes for who `A[i]` is next greater element\\nFor the input `[2,4,0,9,6]`, `mid` looks like: `[[], [0], [], [2, 1], []] `. \\n\\t* `A[1]` is the next greater element for `A[0]`\\n\\t* `A[3]` is the next greater element for `A[1]` and `A[2]`\\n* Iterate over `A` and for each element `A[i]` if there are smaller elements in min heap, poll the elements in the min heap and set `A[i]` as second greater element for them\\n* Then push all the elements for who `A[i]` was next greater(elements in `mid[i]`) in to the min heap\\n\\t* We can now push the elements in `mid[i]` into the min heap because we know one greater element for these elements has already been found. Now we just need to find one more and that will be the second greater element\\n\\n\\n<iframe src=\"https://leetcode.com/playground/ehacvCUT/shared\" frameBorder=\"0\" width=\"730\" height=\"450\"></iframe>\\n\\n*Time complexity: nlogn*",
                "solutionTags": [],
                "code": "**Explanation**\\n* Monotonic stack is used to find the next greater element\\n* In `mid[i]` we store all the indexes for who `A[i]` is next greater element\\nFor the input `[2,4,0,9,6]`, `mid` looks like: `[[], [0], [], [2, 1], []] `. \\n\\t* `A[1]` is the next greater element for `A[0]`\\n\\t* `A[3]` is the next greater element for `A[1]` and `A[2]`\\n* Iterate over `A` and for each element `A[i]` if there are smaller elements in min heap, poll the elements in the min heap and set `A[i]` as second greater element for them\\n* Then push all the elements for who `A[i]` was next greater(elements in `mid[i]`) in to the min heap\\n\\t* We can now push the elements in `mid[i]` into the min heap because we know one greater element for these elements has already been found. Now we just need to find one more and that will be the second greater element\\n\\n\\n<iframe src=\"https://leetcode.com/playground/ehacvCUT/shared\" frameBorder=\"0\" width=\"730\" height=\"450\"></iframe>\\n\\n*Time complexity: nlogn*",
                "codeTag": "Unknown"
            },
            {
                "id": 2757279,
                "title": "k-th-greater-element",
                "content": "We will take a look at a generic solution that can find `k`-th greater element.\\n\\nWe will reuse the next greater element algorithm almost \"as-is\".\\n> As a quick refresher, that algorithm goes right-to-left maintaining a mono-stack, and binary-searches the monostack to find the next greater element.\\n\\nSay, `nums[i]` is the next greater element for previous elements `nums[j0], nums[j1], ...`. During the first pass, we will track indexes of those elements in `prev[j]`.\\n\\nDuring the second pass, when we reach `nums[i]`, we will search the monostrack for the next greater element for `nums[j0], nums[j1], ...`. Again, we will link that greater elements to indexes of previous elements.\\n\\nTherefore, after the second pass, for each index `j` in `prev[i]`, `nums[i]` is the second greater element for `nums[j]`.\\n\\n![image](https://assets.leetcode.com/users/images/27bfcc2d-5bfc-4fec-b749-170d554998fa_1667072187.056245.png)\\n\\nWe can do one more pass to figure out the third greater element, and so on.\\n\\n**C++**\\n```cpp\\nvector<vector<int>> greaterElement(vector<int>& nums, const vector<vector<int>> &prev) {\\n    vector<int> ms;\\n    vector<vector<int>> pprev(nums.size());\\n    for (int i = nums.size() - 1; i >= 0; --i) {\\n        for (int j : prev.empty() ? vector<int>{i} : prev[i]) {\\n            auto it = upper_bound(rbegin(ms), rend(ms), j, [&](int i, int j){ return nums[i] < nums[j]; });\\n            if (it != rend(ms))\\n                pprev[*it].push_back(j);\\n        }\\n        while(!ms.empty() && nums[ms.back()] < nums[i])\\n            ms.pop_back();\\n        ms.push_back(i);\\n    }\\n    return pprev;\\n}\\nvector<int> secondGreaterElement(vector<int>& nums, int k = 2) {\\n    vector<int> res(nums.size(), -1);\\n    vector<vector<int>> prev;\\n    while (--k >= 0)\\n        prev = greaterElement(nums, prev);\\n    for (int i = nums.size() - 1; i >= 0; --i)\\n        for (int j : prev[i])\\n            res[j] = nums[i];\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> greaterElement(vector<int>& nums, const vector<vector<int>> &prev) {\\n    vector<int> ms;\\n    vector<vector<int>> pprev(nums.size());\\n    for (int i = nums.size() - 1; i >= 0; --i) {\\n        for (int j : prev.empty() ? vector<int>{i} : prev[i]) {\\n            auto it = upper_bound(rbegin(ms), rend(ms), j, [&](int i, int j){ return nums[i] < nums[j]; });\\n            if (it != rend(ms))\\n                pprev[*it].push_back(j);\\n        }\\n        while(!ms.empty() && nums[ms.back()] < nums[i])\\n            ms.pop_back();\\n        ms.push_back(i);\\n    }\\n    return pprev;\\n}\\nvector<int> secondGreaterElement(vector<int>& nums, int k = 2) {\\n    vector<int> res(nums.size(), -1);\\n    vector<vector<int>> prev;\\n    while (--k >= 0)\\n        prev = greaterElement(nums, prev);\\n    for (int i = nums.size() - 1; i >= 0; --i)\\n        for (int j : prev[i])\\n            res[j] = nums[i];\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756336,
                "title": "segment-tree-cpp-o-n-log-n",
                "content": "How to find a index **j** such that **j > i** and **nums[j] > nums[i]** and if there are many possible indices **j** find the smallest one.\\n\\nWe can use a stack for this problem but it is also possible to do it with a segment tree lets see how, suppose we build our segment tree of **max** operation.\\n\\nNow suppose you are in a range of your segment tree represented by **[l, r]** now first check the maximum value in the left tree i.e **[l, mid]** if the maximum in the left tree is greater than **nums[i]** then answer lies in the left tree otherwise answer lies in the right tree i.e **[mid + 1, r]**, so keep going down in the tree until the point **l == r** and the index **j** such that **nums[i] < nums[j]** is **l**.\\n\\nSo first find the first index such that **k** such that **nums[i] < nums[k]** in the range **[i + 1, n]** using segment tree then find the second index **j** such that **nums[i] < nums[j]** in the range **[k + 1, n]**.\\nAnd if either **k** or **j** is not present the answer for index **i** is **-1**.\\n\\n**Time complexity: O(n * log(n))**\\n**Space complexity: O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n    void build(int l, int r, int x, vector<int> &nums) {\\n        if(l == r) {\\n            if(l < nums.size()) {\\n                seg[x] = nums[l];\\n            }\\n            return;\\n        }\\n\\n        int mid = (l + r) / 2;\\n        build(l, mid, 2 * x + 1, nums);\\n        build(mid + 1, r, 2 * x + 2, nums);\\n\\n        seg[x] = max(seg[2 * x + 1], seg[2 * x + 2]); //Segment tree for max operation\\n    }\\n    int query(int k, int l, int x, int lx, int rx) {\\n        if(seg[x] <= k or rx < l) return -1; \\n\\t\\t// if the maximum in the range is less than or equal to nums[i] or the range less than i return -1\\n\\t\\t\\n        if(lx == rx) return lx;\\n\\n        int mid = (lx + rx) / 2;\\n\\n        int res = query(k, l, 2 * x + 1, lx, mid);\\n\\t\\t//first search in the left subtree\\n\\t\\t\\n        if(res == -1) // if not present search in the right subtree\\n            res = query(k, l, 2 * x + 2, mid + 1, rx);\\n\\t\\t\\t\\n        return res;\\n    }\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        int x = 1;\\n        \\n        while(x <= n) x *= 2;\\n        seg.resize(2 * x, 0);\\n        build(0, x - 1, 0, nums);\\n        \\n        vector<int> res(n, -1);\\n        \\n        for(int i = 0; i < n; ++i) {\\n            int first = query(nums[i], i + 1, 0, 0, x - 1); //first index k such that nums[i] < nums[k]\\n            if(first != -1) {\\n                int second = query(nums[i], first + 1, 0, 0, x - 1); //second index j such that nums[i] < nums[j]\\n                if(second != -1) res[i] = nums[second];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n    void build(int l, int r, int x, vector<int> &nums) {\\n        if(l == r) {\\n            if(l < nums.size()) {\\n                seg[x] = nums[l];\\n            }\\n            return;\\n        }\\n\\n        int mid = (l + r) / 2;\\n        build(l, mid, 2 * x + 1, nums);\\n        build(mid + 1, r, 2 * x + 2, nums);\\n\\n        seg[x] = max(seg[2 * x + 1], seg[2 * x + 2]); //Segment tree for max operation\\n    }\\n    int query(int k, int l, int x, int lx, int rx) {\\n        if(seg[x] <= k or rx < l) return -1; \\n\\t\\t// if the maximum in the range is less than or equal to nums[i] or the range less than i return -1\\n\\t\\t\\n        if(lx == rx) return lx;\\n\\n        int mid = (lx + rx) / 2;\\n\\n        int res = query(k, l, 2 * x + 1, lx, mid);\\n\\t\\t//first search in the left subtree\\n\\t\\t\\n        if(res == -1) // if not present search in the right subtree\\n            res = query(k, l, 2 * x + 2, mid + 1, rx);\\n\\t\\t\\t\\n        return res;\\n    }\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        int x = 1;\\n        \\n        while(x <= n) x *= 2;\\n        seg.resize(2 * x, 0);\\n        build(0, x - 1, 0, nums);\\n        \\n        vector<int> res(n, -1);\\n        \\n        for(int i = 0; i < n; ++i) {\\n            int first = query(nums[i], i + 1, 0, 0, x - 1); //first index k such that nums[i] < nums[k]\\n            if(first != -1) {\\n                int second = query(nums[i], first + 1, 0, 0, x - 1); //second index j such that nums[i] < nums[j]\\n                if(second != -1) res[i] = nums[second];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756557,
                "title": "easy-peasy-solution-c-like-next-greater-element-faster-than-87-50",
                "content": "1. First find next greater element for each element in the array\\n2. Store them into an array , here I used nextBig[ ]\\n3. Now just find second next greater element\\n\\nPlease upvote if you find it useful.. :)\\n\\nHappy Coding :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int nextBig[n+4];\\n        nextBig[n-1]=n;\\n        nextBig[n]=n;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            int pos;\\n            pos = i+1;\\n            while(pos<n && nums[pos]<= nums[i]  ){\\n                pos = nextBig[pos];\\n            }\\n            nextBig[i]=pos;\\n        }\\n        vector<int>ans(n);\\n        int pos;\\n        for(int i=0; i<n; i++)\\n        {\\n            pos = nextBig[i];\\n            pos++;\\n           \\n            while(pos<n && nums[pos]<=nums[i]){\\n                pos = nextBig[pos];\\n            }\\n           \\n                \\n            if(pos<n) ans[i]=nums[pos];\\n            else ans[i]=-1;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int nextBig[n+4];\\n        nextBig[n-1]=n;\\n        nextBig[n]=n;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            int pos;\\n            pos = i+1;\\n            while(pos<n && nums[pos]<= nums[i]  ){\\n                pos = nextBig[pos];\\n            }\\n            nextBig[i]=pos;\\n        }\\n        vector<int>ans(n);\\n        int pos;\\n        for(int i=0; i<n; i++)\\n        {\\n            pos = nextBig[i];\\n            pos++;\\n           \\n            while(pos<n && nums[pos]<=nums[i]){\\n                pos = nextBig[pos];\\n            }\\n           \\n                \\n            if(pos<n) ans[i]=nums[pos];\\n            else ans[i]=-1;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756340,
                "title": "c-easy-o-nlogn-monotonic-stack-multiset-similar-to-next-greater-element",
                "content": "# Approach\\nwe have to find every element\\'s next to next greater element, we can use a stack for finding an element\\'s next greater element.\\n\\nso in the example [2,4,0,9,6] next greater element for 2 is 4.\\n\\nas soon as next greater element of a number arrives, we can push that number in a multiset, and just lookout for one more greater element than that number which will be our answer.\\n\\nso in the example, as soon as 4 arrives (next greater of 2) we push 2 in a multiset, when 9 arrives, we check multiset whether the elements in the multiset are smaller than 9, all the elements smaller than 9 will have answer = 9.\\n\\n# Complexity\\n- Time complexity:\\nO(Nlog(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        stack<int> s;\\n        multiset<vector<int>> m;\\n        vector<int> ans(nums.size(),-1);\\n        s.push(0);\\n        for(int i=1;i<nums.size();i++){\\n\\n            // check if current element is greater than any element present in multiset\\n            while(!m.empty() && nums[i] > (*m.begin())[0]){\\n                ans[(*m.begin())[1]] = nums[i];\\n                m.erase(m.begin());\\n            }\\n\\n            // all the elements whose next greater element exist will be pushed in multiset, we keep this track with the help of stack\\n            while(!s.empty() && nums[i]>nums[s.top()]){\\n                m.insert({nums[s.top()],s.top()});\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        stack<int> s;\\n        multiset<vector<int>> m;\\n        vector<int> ans(nums.size(),-1);\\n        s.push(0);\\n        for(int i=1;i<nums.size();i++){\\n\\n            // check if current element is greater than any element present in multiset\\n            while(!m.empty() && nums[i] > (*m.begin())[0]){\\n                ans[(*m.begin())[1]] = nums[i];\\n                m.erase(m.begin());\\n            }\\n\\n            // all the elements whose next greater element exist will be pushed in multiset, we keep this track with the help of stack\\n            while(!s.empty() && nums[i]>nums[s.top()]){\\n                m.insert({nums[s.top()],s.top()});\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756410,
                "title": "simple-intuitive-solution-sets-explained",
                "content": "We will keep two sets to indicate the states of the elements-\\n\\t<ol><li>Set 1 will contain the elements whose next greater element is not found yet.</li>\\n\\t<li>Set 2 will contain the elements whose next greater element has been found but second greater element is not found yet.</li></ol>\\n\\tNow we iterate from the beginning. For each element \\'x\\' we do the following-\\n\\t<ul><li>At first we will check Set 2. Every element \\'y\\'  that  is less than \\'x\\' its second greater element will be \\'x\\' as we already found its first greater element. Then we erase \\'y\\' from the set.</li>\\n\\t<li>Then we traverse Set1. Every element \\'y\\' that is less than \\'x\\', its first greater element will be \\'x\\'. So we discovered the first greater element of \\'y\\'. Hence, we remove \\'y\\' from Set 1 and insert it in Set2.\\n\\t</ol>\\n\\tAny element that was not erased from Set 2 or  Set 1 will have -1 as its second greater element.\\n\\t\\n\\tSample Code:\\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> secondGreaterElement(vector<int>& arr) {\\n\\t\\t\\tset<pair<int,int>>Set1,Set2;// Set contains value and index.\\n\\t\\t\\tvector<int>ans(arr.size(),-1);\\n\\t\\t\\tfor(int i=0;i<arr.size();i++){\\n\\t\\t\\t\\t//Check Set2\\n\\t\\t\\t\\twhile(Set2.size()){\\n\\t\\t\\t\\t\\t auto u = *Set2.begin();\\n\\t\\t\\t\\t\\tint val = u.first;\\n\\t\\t\\t\\t\\tif(val<arr[i]){\\n\\t\\t\\t\\t\\t\\tSet2.erase(u);\\n\\t\\t\\t\\t\\t\\tans[u.second] = arr[i];\\n\\t\\t\\t\\t\\t}else break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//Check Set1\\n\\t\\t\\t\\twhile(Set1.size()){\\n\\t\\t\\t\\t\\tauto u = *Set1.begin();\\n\\t\\t\\t\\t\\tint val = u.first;\\n\\t\\t\\t\\t\\tif(val<arr[i]){\\n\\t\\t\\t\\t\\t\\tSet2.insert(u);\\n\\t\\t\\t\\t\\t\\tSet1.erase(u);\\n\\t\\t\\t\\t\\t}else break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tSet1.insert({arr[i],i});\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n```\\nAny Suggestions/Feedback will be helpful. Do upvote if you find the solution interesting.",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> secondGreaterElement(vector<int>& arr) {\\n\\t\\t\\tset<pair<int,int>>Set1,Set2;// Set contains value and index.\\n\\t\\t\\tvector<int>ans(arr.size(),-1);\\n\\t\\t\\tfor(int i=0;i<arr.size();i++){\\n\\t\\t\\t\\t//Check Set2\\n\\t\\t\\t\\twhile(Set2.size()){\\n\\t\\t\\t\\t\\t auto u = *Set2.begin();\\n\\t\\t\\t\\t\\tint val = u.first;\\n\\t\\t\\t\\t\\tif(val<arr[i]){\\n\\t\\t\\t\\t\\t\\tSet2.erase(u);\\n\\t\\t\\t\\t\\t\\tans[u.second] = arr[i];\\n\\t\\t\\t\\t\\t}else break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//Check Set1\\n\\t\\t\\t\\twhile(Set1.size()){\\n\\t\\t\\t\\t\\tauto u = *Set1.begin();\\n\\t\\t\\t\\t\\tint val = u.first;\\n\\t\\t\\t\\t\\tif(val<arr[i]){\\n\\t\\t\\t\\t\\t\\tSet2.insert(u);\\n\\t\\t\\t\\t\\t\\tSet1.erase(u);\\n\\t\\t\\t\\t\\t}else break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tSet1.insert({arr[i],i});\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756412,
                "title": "python3-monotonic-stack-o-n",
                "content": "We use two stacks ```stack``` and ```second``` to store the indices ```i```  such that ```stack[i]``` and ```second[i]``` are non-increasing sequences. ```second``` stores the indices that already meet the first greater element. We need a ```temp``` in the loop of ```stack``` so that the indices in ```second``` are increasing. \\n```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        output = [-1] * n\\n        stack = []\\n        second = []\\n        for i in range(n):\\n            while second and nums[i] > nums[second[-1]]:\\n                curr = second.pop()\\n                if output[curr] == -1:\\n                    output[curr] = nums[i]\\n            temp = []\\n            while stack and nums[i] > nums[stack[-1]]:\\n                curr = stack.pop()\\n                if output[curr] == -1:\\n                    temp.append(curr)\\n            stack.append(i)\\n            second += temp[::-1]\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```stack```\n```second```\n```i```\n```stack[i]```\n```second[i]```\n```second```\n```temp```\n```stack```\n```second```\n```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        output = [-1] * n\\n        stack = []\\n        second = []\\n        for i in range(n):\\n            while second and nums[i] > nums[second[-1]]:\\n                curr = second.pop()\\n                if output[curr] == -1:\\n                    output[curr] = nums[i]\\n            temp = []\\n            while stack and nums[i] > nums[stack[-1]]:\\n                curr = stack.pop()\\n                if output[curr] == -1:\\n                    temp.append(curr)\\n            stack.append(i)\\n            second += temp[::-1]\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756610,
                "title": "c-stack-to-find-nge-then-using-segment-tree-with-binary-search",
                "content": "It is inututive to do a next greater element logic , then to find out the number that is second NGE we are using a segment tree with binary search.\\n\\nNew to segment tree learn it from [here](https://www.youtube.com/watch?v=NEG-SoyigGE&t=61s)\\n#striverOP\\n\\n\\n```\\n// CPP code for range maximum query and updates\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n\\nint getMid(int s, int e)\\n{\\n\\treturn s + (e - s) / 2;\\n}\\n\\n\\nint MaxUtil(int* st, int ss, int se, int l,\\n\\t\\t\\tint r, int node)\\n{\\n\\t\\n\\tif (l <= ss && r >= se)\\n\\t\\treturn st[node];\\n\\n\\tif (se < l || ss > r)\\n\\t\\treturn -1;\\n\\n\\tint mid = getMid(ss, se);\\n\\t\\n\\treturn max(MaxUtil(st, ss, mid, l, r,\\n\\t\\t\\t\\t\\t2 * node + 1),\\n\\t\\t\\tMaxUtil(st, mid + 1, se, l,\\n\\t\\t\\t\\t\\tr, 2 * node + 2));\\n}\\n\\n\\nint getMax(int* st, int n, int l, int r)\\n{\\n\\t\\n\\tif (l < 0 || r > n - 1 || l > r)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\treturn MaxUtil(st, 0, n - 1, l, r, 0);\\n}\\n\\n\\nint constructSTUtil(int arr[], int ss, int se,\\n\\t\\t\\t\\t\\tint* st, int si)\\n{\\n\\t\\n\\tif (ss == se)\\n\\t{\\n\\t\\tst[si] = arr[ss];\\n\\t\\treturn arr[ss];\\n\\t}\\n\\n\\tint mid = getMid(ss, se);\\n\\t\\n\\tst[si] = max(constructSTUtil(arr, ss, mid, st,\\n\\t\\t\\t\\t\\t\\t\\t\\tsi * 2 + 1),\\n\\t\\t\\t\\tconstructSTUtil(arr, mid + 1, se,\\n\\t\\t\\t\\t\\t\\t\\t\\tst, si * 2 + 2));\\n\\t\\n\\treturn st[si];\\n}\\n\\nint* constructST(int arr[], int n)\\n{\\n\\n\\tint x = (int)(ceil(log2(n)));\\n\\n\\tint max_size = 2 * (int)pow(2, x) - 1;\\n\\n\\tint* st = new int[max_size];\\n\\n\\tconstructSTUtil(arr, 0, n - 1, st, 0);\\n\\n\\treturn st;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        \\n        vector<int> first;\\n        stack<int> st;\\n        \\n        // Using the next greater element logic to find the index of next greater element \\n        \\n        for(int i=nums.size()-1;i>=0;i--){\\n            while(st.size()>0 && nums[i]>=nums[st.top()])\\n                st.pop();\\n            if(st.size()==0){\\n                first.push_back(-1);\\n            }\\n            else{\\n                first.push_back(st.top());\\n            }\\n            st.push(i);\\n        }\\n        \\n        reverse(first.begin(),first.end());\\n        vector<int> ans;\\n        \\n        int n=nums.size();\\n        int arr[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=nums[i];\\n        }\\n        \\n        \\n        int* st1 = constructST(arr, n); // contsruction of segment tree that suppourt\\'s range max queries\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(first[i]==-1){\\n                //Thre is no NGE then it is obvious that second NGE dont exist\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            long long start=first[i]+1;\\n            long long end=n-1;\\n            int res=-1;\\n            \\n            //Binary searching the value which is > nums[i] in the part of array that extends from the position of first NGE index +1 to end\\n            while(start<=end){\\n                long long mid=(start+end)/2;\\n                \\n                int got=getMax(st1, n, start, mid);\\n                if(got>nums[i]){\\n                    //We found the value in left part then we try to reduce search space \\n                    res=got;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n// CPP code for range maximum query and updates\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n\\nint getMid(int s, int e)\\n{\\n\\treturn s + (e - s) / 2;\\n}\\n\\n\\nint MaxUtil(int* st, int ss, int se, int l,\\n\\t\\t\\tint r, int node)\\n{\\n\\t\\n\\tif (l <= ss && r >= se)\\n\\t\\treturn st[node];\\n\\n\\tif (se < l || ss > r)\\n\\t\\treturn -1;\\n\\n\\tint mid = getMid(ss, se);\\n\\t\\n\\treturn max(MaxUtil(st, ss, mid, l, r,\\n\\t\\t\\t\\t\\t2 * node + 1),\\n\\t\\t\\tMaxUtil(st, mid + 1, se, l,\\n\\t\\t\\t\\t\\tr, 2 * node + 2));\\n}\\n\\n\\nint getMax(int* st, int n, int l, int r)\\n{\\n\\t\\n\\tif (l < 0 || r > n - 1 || l > r)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\treturn MaxUtil(st, 0, n - 1, l, r, 0);\\n}\\n\\n\\nint constructSTUtil(int arr[], int ss, int se,\\n\\t\\t\\t\\t\\tint* st, int si)\\n{\\n\\t\\n\\tif (ss == se)\\n\\t{\\n\\t\\tst[si] = arr[ss];\\n\\t\\treturn arr[ss];\\n\\t}\\n\\n\\tint mid = getMid(ss, se);\\n\\t\\n\\tst[si] = max(constructSTUtil(arr, ss, mid, st,\\n\\t\\t\\t\\t\\t\\t\\t\\tsi * 2 + 1),\\n\\t\\t\\t\\tconstructSTUtil(arr, mid + 1, se,\\n\\t\\t\\t\\t\\t\\t\\t\\tst, si * 2 + 2));\\n\\t\\n\\treturn st[si];\\n}\\n\\nint* constructST(int arr[], int n)\\n{\\n\\n\\tint x = (int)(ceil(log2(n)));\\n\\n\\tint max_size = 2 * (int)pow(2, x) - 1;\\n\\n\\tint* st = new int[max_size];\\n\\n\\tconstructSTUtil(arr, 0, n - 1, st, 0);\\n\\n\\treturn st;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        \\n        vector<int> first;\\n        stack<int> st;\\n        \\n        // Using the next greater element logic to find the index of next greater element \\n        \\n        for(int i=nums.size()-1;i>=0;i--){\\n            while(st.size()>0 && nums[i]>=nums[st.top()])\\n                st.pop();\\n            if(st.size()==0){\\n                first.push_back(-1);\\n            }\\n            else{\\n                first.push_back(st.top());\\n            }\\n            st.push(i);\\n        }\\n        \\n        reverse(first.begin(),first.end());\\n        vector<int> ans;\\n        \\n        int n=nums.size();\\n        int arr[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=nums[i];\\n        }\\n        \\n        \\n        int* st1 = constructST(arr, n); // contsruction of segment tree that suppourt\\'s range max queries\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(first[i]==-1){\\n                //Thre is no NGE then it is obvious that second NGE dont exist\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            long long start=first[i]+1;\\n            long long end=n-1;\\n            int res=-1;\\n            \\n            //Binary searching the value which is > nums[i] in the part of array that extends from the position of first NGE index +1 to end\\n            while(start<=end){\\n                long long mid=(start+end)/2;\\n                \\n                int got=getMax(st1, n, start, mid);\\n                if(got>nums[i]){\\n                    //We found the value in left part then we try to reduce search space \\n                    res=got;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2759849,
                "title": "c-two-solution-same-as-next-greater-element-segment-tree",
                "content": "```\\n# Solution 1\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // next greater\\n        vector<int> ng(n, -1);\\n        stack<int> stk;\\n        for(int i = n-1; i >= 0; i--) {\\n            while(!stk.empty() && nums[stk.top()] <= nums[i])\\n                stk.pop();\\n            if(!stk.empty())\\n                ng[i] = stk.top();\\n            stk.push(i);\\n        }\\n        \\n        // next second greater\\n        vector<int> sg(n, -1);\\n        for(int i = 0; i < n; i++) {\\n            if(ng[i] == -1)\\n                continue;\\n            int tmp = ng[i]+1;\\n            while(tmp != -1 && tmp < n && nums[tmp] <= nums[i])\\n                tmp = ng[tmp];\\n            if(tmp != -1 && tmp < n)\\n                sg[i] = nums[tmp];\\n        }\\n        \\n        return sg;\\n    }\\n};\\n\\n#Solution 2\\nclass Solution {\\n    vector<int> tree;\\n\\n    // range max tree\\n    int buildTree(int i, int l, int r, vector<int> &nums) {\\n        if (l == r) \\n            return tree[i] = nums[l];\\n        int mid = (l + r) / 2;\\n        return tree[i] = max(buildTree(2*i+1, l, mid, nums), buildTree(2*i+2, mid+1, r, nums));\\n    }\\n\\n    int query(int num, int pos, int i, int l, int r, vector<int> &nums) {\\n        if(tree[i] <= num || r < pos)\\n            return INT_MAX;\\n        else if(l == r)\\n            return l;\\n\\n        int mid = (l + r) / 2;\\n        int res = query(num, pos, 2*i+1, l, mid, nums);\\n        if (res == INT_MAX)\\n            res = query(num, pos, 2*i+2, mid+1, r, nums);\\n\\n        return res;\\n    }\\n\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, -1);\\n\\n        tree.resize(4*n);\\n        buildTree(0, 0, n-1, nums);\\n\\n        for (int i = 0; i < n; i++) {\\n            int ng = query(nums[i], i+1, 0, 0, n-1, nums);\\n            if(ng != INT_MAX) {\\n                int sng = query(nums[i], ng+1, 0, 0, n-1, nums);\\n                cout << sng << \" \";\\n                if(sng != INT_MAX)\\n                    ans[i] = nums[sng];\\n            } \\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Segment Tree",
                    "Monotonic Stack"
                ],
                "code": "```\\n# Solution 1\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // next greater\\n        vector<int> ng(n, -1);\\n        stack<int> stk;\\n        for(int i = n-1; i >= 0; i--) {\\n            while(!stk.empty() && nums[stk.top()] <= nums[i])\\n                stk.pop();\\n            if(!stk.empty())\\n                ng[i] = stk.top();\\n            stk.push(i);\\n        }\\n        \\n        // next second greater\\n        vector<int> sg(n, -1);\\n        for(int i = 0; i < n; i++) {\\n            if(ng[i] == -1)\\n                continue;\\n            int tmp = ng[i]+1;\\n            while(tmp != -1 && tmp < n && nums[tmp] <= nums[i])\\n                tmp = ng[tmp];\\n            if(tmp != -1 && tmp < n)\\n                sg[i] = nums[tmp];\\n        }\\n        \\n        return sg;\\n    }\\n};\\n\\n#Solution 2\\nclass Solution {\\n    vector<int> tree;\\n\\n    // range max tree\\n    int buildTree(int i, int l, int r, vector<int> &nums) {\\n        if (l == r) \\n            return tree[i] = nums[l];\\n        int mid = (l + r) / 2;\\n        return tree[i] = max(buildTree(2*i+1, l, mid, nums), buildTree(2*i+2, mid+1, r, nums));\\n    }\\n\\n    int query(int num, int pos, int i, int l, int r, vector<int> &nums) {\\n        if(tree[i] <= num || r < pos)\\n            return INT_MAX;\\n        else if(l == r)\\n            return l;\\n\\n        int mid = (l + r) / 2;\\n        int res = query(num, pos, 2*i+1, l, mid, nums);\\n        if (res == INT_MAX)\\n            res = query(num, pos, 2*i+2, mid+1, r, nums);\\n\\n        return res;\\n    }\\n\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, -1);\\n\\n        tree.resize(4*n);\\n        buildTree(0, 0, n-1, nums);\\n\\n        for (int i = 0; i < n; i++) {\\n            int ng = query(nums[i], i+1, 0, 0, n-1, nums);\\n            if(ng != INT_MAX) {\\n                int sng = query(nums[i], ng+1, 0, 0, n-1, nums);\\n                cout << sng << \" \";\\n                if(sng != INT_MAX)\\n                    ans[i] = nums[sng];\\n            } \\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2756608,
                "title": "sort-indices-sortedlist",
                "content": "For the purpose of this question elements in the array smaller than the one in question are invisible. So, sort the indices by the reverse order of their values. As we go through the indices one by one, keep them in a `SortedList`. If there are >=2 indices greater than the current one, use the second one. Otherwise, -1.\\n\\n(`sorted` in python is stable so indices whose values are the same go in order and indices to the right won\\'t be in `sl`)\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        indices = sorted(range(n), key=lambda i: nums[i], reverse=True)\\n        sl = SortedList()\\n        ans = [None] * n\\n        for i in indices:\\n            index = sl.bisect_right(i)\\n            if index + 1 < len(sl):\\n                ans[i] = nums[sl[index + 1]]\\n            else:\\n                ans[i] = -1\\n            sl.add(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        indices = sorted(range(n), key=lambda i: nums[i], reverse=True)\\n        sl = SortedList()\\n        ans = [None] * n\\n        for i in indices:\\n            index = sl.bisect_right(i)\\n            if index + 1 < len(sl):\\n                ans[i] = nums[sl[index + 1]]\\n            else:\\n                ans[i] = -1\\n            sl.add(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799346,
                "title": "monotonic-stack-min-heap",
                "content": "# Intuition\\nTo find the second greatest element. we need to distingush elements whose who have got one greater and whose who havent got any greater.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo find the fist greater element we use monotonic stack `st` as in First Greatest Element. but after poping it we add it to a min heap `pq` which contains elements that have got a greater element once.\\n\\nBefore adding elements and even before poping elements to the `pq` we check for all elements that are less that the element and hece we get the second greatest element.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(nlogn)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> gE(n, -1);\\n        stack<int> st;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        for(int i = 0; i < n; i++) {\\n            while(!pq.empty() && pq.top().first < nums[i]) {\\n                gE[pq.top().second] = nums[i];\\n                pq.pop();\\n            }\\n            while(!st.empty() && nums[st.top()] < nums[i]) {\\n                pq.push(make_pair(nums[st.top()], st.top()));\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        \\n        return gE;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> gE(n, -1);\\n        stack<int> st;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        for(int i = 0; i < n; i++) {\\n            while(!pq.empty() && pq.top().first < nums[i]) {\\n                gE[pq.top().second] = nums[i];\\n                pq.pop();\\n            }\\n            while(!st.empty() && nums[st.top()] < nums[i]) {\\n                pq.push(make_pair(nums[st.top()], st.top()));\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n        \\n        return gE;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757269,
                "title": "java-python3-the-kth-greater-element-solution-linked-list",
                "content": "## Intuition\\n\\nFirst, try to solve it with monotonic stack.\\nBut for this time, we can\\'t directly pop the top element from the stack while encountering a greater element. Instead, we need to keep a state: **how many greater elements does the top element in the stack encounter?**\\n\\nThere are two cases:\\n1. ``nums[i] <= the top element in the stack``: Push ``[i(index), nums[i](value), 0(count)]`` to the stack.\\n2. ``nums[i] > the top element in the stack``:\\n\\t(1) Increment ``count`` of the element by 1.\\n\\t(2) If there are 2 next greater elements(``count==2``), then pop it from the stack and set the second greater element(``nums[i]``) for it.\\n\\tOtherwise, continue to check the next element in the stack until we encounter an element greater than or equal to ``nums[i]``(case 1).\\n\\t\\nYou may ask where to push ``[i(index), nums[i](value), 0(count)]`` for the case 2.\\nBecause we want the stack to be a **non-increasing** array, add the item ``[i(index), nums[i](value), 0(count)]`` to the right position in the stack. The time complexity of inserting an item into an array is ``O(n)`` and that\\'s inefficient. So, we can try a **linked list** instead.\\n\\n## Implementation\\n\\n**Java**\\n```\\npublic class ListNode {\\n    int idx;\\n    int val;\\n    int count;\\n    ListNode next;\\n    ListNode() {}\\n    ListNode(int idx, int val, int count, ListNode next) {\\n        this.idx = idx;\\n        this.val = val;\\n        this.count = count;\\n        this.next = next;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] result = new int[nums.length];\\n        Arrays.fill(result, -1);\\n        ListNode head = new ListNode();\\n        ListNode prev, cur;\\n        for (int i = 0; i < nums.length; ++i) {\\n            prev = head;\\n            cur = head.next;\\n            while (cur != null && nums[i] > cur.val) {\\n                ++cur.count;\\n                if (cur.count == 2) {\\n                    result[cur.idx] = nums[i]; // set second greater element nums[i] for cur.idx\\n                    prev.next = cur.next; // remove cur from the linked list\\n                } else {\\n                    prev = cur;\\n                }\\n                cur = cur.next;\\n            }\\n            prev.next = new ListNode(i, nums[i], 0, cur); // insert cur to the linked list\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Python3**\\n```\\nclass ListNode:\\n    def __init__(self, idx=-1, val=-1, count=0, next=None):\\n        self.idx = idx\\n        self.val = val\\n        self.count = count\\n        self.next = next\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        result = [-1] * len(nums)\\n        head = ListNode()\\n        for i, num in enumerate(nums):\\n            prev, cur = head, head.next\\n            while cur and num > cur.val:\\n                cur.count += 1\\n                if cur.count == 2:\\n                    result[cur.idx] = num # set second greater element nums[i] for cur.idx\\n                    prev.next = cur.next # remove cur from the linked list\\n                else:\\n                    prev = cur\\n                cur = cur.next\\n            prev.next = ListNode(i, num, 0, cur) # insert cur to the linked list\\n        return result\\n```\\n\\n**Complexity Analysis**\\nNote: ``n`` is the length of the input array ``nums``.\\n\\n* Time complexity: ``O(n)``. **Each node is processed at most twice** because when ``count == 2``, that node will be removed from the linked list. So, the overall complexity is ``O(2n)``. That is, ``O(n)``.\\n* Space complexity: ``O(n)``. If ``nums`` is a decreasing array, then the linked list will contain ``n`` nodes.\\n\\n---\\n\\n## Bonus\\n\\nWe can do a little modification to make a generalized solution: **the Kth Greater Element Solution** from the above implementation.\\n\\n**The Kth Greater Element Solution**\\n```\\nclass ListNode:\\n    def __init__(self, idx=-1, val=-1, count=0, next=None):\\n        self.idx = idx\\n        self.val = val\\n        self.count = count\\n        self.next = next\\n\\nclass Solution:\\n    def kthGreaterElement(self, nums: List[int], k: int) -> List[int]:\\n        result = [-1] * len(nums)\\n        head = ListNode()\\n        for i, num in enumerate(nums):\\n            prev, cur = head, head.next\\n            while cur and num > cur.val:\\n                cur.count += 1\\n                if cur.count == k:\\n                    result[cur.idx] = num # set the kth greater element nums[i] for cur.idx\\n                    prev.next = cur.next # remove cur from the linked list\\n                else:\\n                    prev = cur\\n                cur = cur.next\\n            prev.next = ListNode(i, num, 0, cur) # insert cur to the linked list\\n        return result\\n```\\n\\n**Complexity Analysis**\\nNote: ``n`` is the length of the input array ``nums``.\\n\\n* Time complexity: ``O(kn)``. **Each node is processed at most k times** because when ``count == k``, that node will be removed from the linked list. So, the overall complexity is ``O(kn)``.\\n* Space complexity: ``O(n)``.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Linked List"
                ],
                "code": "```\\npublic class ListNode {\\n    int idx;\\n    int val;\\n    int count;\\n    ListNode next;\\n    ListNode() {}\\n    ListNode(int idx, int val, int count, ListNode next) {\\n        this.idx = idx;\\n        this.val = val;\\n        this.count = count;\\n        this.next = next;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] result = new int[nums.length];\\n        Arrays.fill(result, -1);\\n        ListNode head = new ListNode();\\n        ListNode prev, cur;\\n        for (int i = 0; i < nums.length; ++i) {\\n            prev = head;\\n            cur = head.next;\\n            while (cur != null && nums[i] > cur.val) {\\n                ++cur.count;\\n                if (cur.count == 2) {\\n                    result[cur.idx] = nums[i]; // set second greater element nums[i] for cur.idx\\n                    prev.next = cur.next; // remove cur from the linked list\\n                } else {\\n                    prev = cur;\\n                }\\n                cur = cur.next;\\n            }\\n            prev.next = new ListNode(i, nums[i], 0, cur); // insert cur to the linked list\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass ListNode:\\n    def __init__(self, idx=-1, val=-1, count=0, next=None):\\n        self.idx = idx\\n        self.val = val\\n        self.count = count\\n        self.next = next\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        result = [-1] * len(nums)\\n        head = ListNode()\\n        for i, num in enumerate(nums):\\n            prev, cur = head, head.next\\n            while cur and num > cur.val:\\n                cur.count += 1\\n                if cur.count == 2:\\n                    result[cur.idx] = num # set second greater element nums[i] for cur.idx\\n                    prev.next = cur.next # remove cur from the linked list\\n                else:\\n                    prev = cur\\n                cur = cur.next\\n            prev.next = ListNode(i, num, 0, cur) # insert cur to the linked list\\n        return result\\n```\n```\\nclass ListNode:\\n    def __init__(self, idx=-1, val=-1, count=0, next=None):\\n        self.idx = idx\\n        self.val = val\\n        self.count = count\\n        self.next = next\\n\\nclass Solution:\\n    def kthGreaterElement(self, nums: List[int], k: int) -> List[int]:\\n        result = [-1] * len(nums)\\n        head = ListNode()\\n        for i, num in enumerate(nums):\\n            prev, cur = head, head.next\\n            while cur and num > cur.val:\\n                cur.count += 1\\n                if cur.count == k:\\n                    result[cur.idx] = num # set the kth greater element nums[i] for cur.idx\\n                    prev.next = cur.next # remove cur from the linked list\\n                else:\\n                    prev = cur\\n                cur = cur.next\\n            prev.next = ListNode(i, num, 0, cur) # insert cur to the linked list\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756379,
                "title": "java-2-queues-o-n",
                "content": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        Arrays.fill(ans, -1);\\n        LinkedList<Integer> s1 = new LinkedList<>();\\n        LinkedList<Integer> s2 = new LinkedList<>();\\n        for (int i=0; i < nums.length; i++) {\\n            while(!s2.isEmpty() && nums[i] > nums[s2.getLast()]) {\\n                ans[s2.removeLast()] = nums[i];\\n            }\\n            LinkedList temp = new LinkedList<>();\\n            while(!s1.isEmpty() && nums[i] > nums[s1.getLast()]) {\\n                temp.addFirst(s1.removeLast());\\n            }\\n            s2.addAll(temp);\\n            s1.addLast(i);\\n            // System.out.println(s1);\\n            // System.out.println(s2);\\n         // System.out.println();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        Arrays.fill(ans, -1);\\n        LinkedList<Integer> s1 = new LinkedList<>();\\n        LinkedList<Integer> s2 = new LinkedList<>();\\n        for (int i=0; i < nums.length; i++) {\\n            while(!s2.isEmpty() && nums[i] > nums[s2.getLast()]) {\\n                ans[s2.removeLast()] = nums[i];\\n            }\\n            LinkedList temp = new LinkedList<>();\\n            while(!s1.isEmpty() && nums[i] > nums[s1.getLast()]) {\\n                temp.addFirst(s1.removeLast());\\n            }\\n            s2.addAll(temp);\\n            s1.addLast(i);\\n            // System.out.println(s1);\\n            // System.out.println(s2);\\n         // System.out.println();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764415,
                "title": "best-solution-in-c-similar-to-next-greater-element-stack",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int size=nums.size();\\n        vector<int> vec(size),ans(size,-1);\\n        stack<int> sta;\\n        for(int i=size-1;i>=0;i--){\\n            if(sta.size()==0){\\n                vec[i]=-1;\\n                sta.push(i);\\n                continue;\\n            }\\n            while(sta.size()>0 && nums[i]>=nums[sta.top()])\\n                sta.pop();\\n            if(sta.size())\\n                vec[i]=sta.top();\\n            else\\n                vec[i]=-1;\\n            sta.push(i);\\n        }\\n        for(int i=0;i<size;i++){\\n            if(vec[i]==-1)\\n                continue;\\n            int ind_start=vec[i]+1; \\n            while(ind_start!=-1 && ind_start<size && nums[ind_start]<=nums[i])\\n                ind_start=vec[ind_start];\\n            if(ind_start==-1 || ind_start==size)\\n                ans[i]=-1;\\n            else\\n                ans[i]=nums[ind_start];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int size=nums.size();\\n        vector<int> vec(size),ans(size,-1);\\n        stack<int> sta;\\n        for(int i=size-1;i>=0;i--){\\n            if(sta.size()==0){\\n                vec[i]=-1;\\n                sta.push(i);\\n                continue;\\n            }\\n            while(sta.size()>0 && nums[i]>=nums[sta.top()])\\n                sta.pop();\\n            if(sta.size())\\n                vec[i]=sta.top();\\n            else\\n                vec[i]=-1;\\n            sta.push(i);\\n        }\\n        for(int i=0;i<size;i++){\\n            if(vec[i]==-1)\\n                continue;\\n            int ind_start=vec[i]+1; \\n            while(ind_start!=-1 && ind_start<size && nums[ind_start]<=nums[i])\\n                ind_start=vec[ind_start];\\n            if(ind_start==-1 || ind_start==size)\\n                ans[i]=-1;\\n            else\\n                ans[i]=nums[ind_start];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766520,
                "title": "two-methods-c-o-nlogn-o-n",
                "content": "```\\nO(nlogn) method\\nSort our array and make pair of index in a separate array.\\nNow take a set and push the indices in that set from the end.\\nNow we know the indices in set are of elements which are >= current element.\\nTake up second index after taking lower_bound of current index in set.\\nExample -> 3 2 1 4 5\\nSort -> 1  2  3  4  5\\n        2  1  0  3  4\\nPush in set from end, first two elements are pushed as they do not have\\ntwo greater element to their right.\\nset -> 3  4\\nNow next elment is 3,0 we can say there are two indices greater than 0 \\nand next greater II will be 5\\nset -> 0 3 4\\nFor 2,1 we have 3 and 4 to the right of 1\\nset -> 0 1 3 4\\nFor 1,2 we have 3 and 4 to right of 2\\n``` \\n**Take care of duplicates by not pushing the indices unless number changes.**\\n```\\nclass Solution {\\npublic:\\n\\tstatic bool cmp(const pair<int,int>& a, const pair<int,int>& b){\\n        if(a.first == b.first) return a.second > b.second;\\n        return a.first < b.first;\\n    }\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n    // One way to do is by using set\\n        vector<pair<int,int>> vec;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            vec.push_back({nums[i],i});\\n        }\\n        sort(vec.begin(), vec.end(), cmp);\\n        vector<int> ans(n,-1);\\n        set<int> s;\\n        for(int i=n-1; i>=0; i--){\\n            int index = vec[i].second;\\n            if(!s.empty()){\\n                auto it = s.lower_bound(index);\\n                if(it != s.end()) it++;\\n                if(it != s.end()) ans[index] = nums[*it];\\n            }\\n            s.insert(index);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nUsing three monotonic stacks\\nUse two stacks 1. to store the indices of elements which have not got first greater\\n               2. to store the indices of elements which have got first greater\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n    // Using stacks\\n        int n = nums.size();\\n        stack<int> s1,s2,tmp;\\n        vector<int> ans(n,-1);\\n        for(int i=0; i<n; i++){\\n            int curr = nums[i];\\n\\t\\t\\t// if current is greater than previous number\\n\\t\\t\\t// we have got first greater to that prev number\\n            while(!s1.empty() && curr > nums[s1.top()]){\\n                tmp.push(s1.top());\\n                s1.pop();\\n            }\\n\\t\\t\\t// if current number is greater than prev\\n\\t\\t\\t// we have got second greater to that prev number\\n            while(!s2.empty() && curr > nums[s2.top()]){\\n                ans[s2.top()] = curr;\\n                s2.pop();\\n            }\\n\\t\\t\\t// we wanted the stack monotonic so we used temp \\n\\t\\t\\t// now when we push in temp our order is greater at top\\n\\t\\t\\t// but we want smaller at top so we push now to s2\\n            while(!tmp.empty()){\\n                s2.push(tmp.top());\\n                tmp.pop();\\n            }\\n            s1.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nO(nlogn) method\\nSort our array and make pair of index in a separate array.\\nNow take a set and push the indices in that set from the end.\\nNow we know the indices in set are of elements which are >= current element.\\nTake up second index after taking lower_bound of current index in set.\\nExample -> 3 2 1 4 5\\nSort -> 1  2  3  4  5\\n        2  1  0  3  4\\nPush in set from end, first two elements are pushed as they do not have\\ntwo greater element to their right.\\nset -> 3  4\\nNow next elment is 3,0 we can say there are two indices greater than 0 \\nand next greater II will be 5\\nset -> 0 3 4\\nFor 2,1 we have 3 and 4 to the right of 1\\nset -> 0 1 3 4\\nFor 1,2 we have 3 and 4 to right of 2\\n```\n```\\nclass Solution {\\npublic:\\n\\tstatic bool cmp(const pair<int,int>& a, const pair<int,int>& b){\\n        if(a.first == b.first) return a.second > b.second;\\n        return a.first < b.first;\\n    }\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n    // One way to do is by using set\\n        vector<pair<int,int>> vec;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            vec.push_back({nums[i],i});\\n        }\\n        sort(vec.begin(), vec.end(), cmp);\\n        vector<int> ans(n,-1);\\n        set<int> s;\\n        for(int i=n-1; i>=0; i--){\\n            int index = vec[i].second;\\n            if(!s.empty()){\\n                auto it = s.lower_bound(index);\\n                if(it != s.end()) it++;\\n                if(it != s.end()) ans[index] = nums[*it];\\n            }\\n            s.insert(index);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nUsing three monotonic stacks\\nUse two stacks 1. to store the indices of elements which have not got first greater\\n               2. to store the indices of elements which have got first greater\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n    // Using stacks\\n        int n = nums.size();\\n        stack<int> s1,s2,tmp;\\n        vector<int> ans(n,-1);\\n        for(int i=0; i<n; i++){\\n            int curr = nums[i];\\n\\t\\t\\t// if current is greater than previous number\\n\\t\\t\\t// we have got first greater to that prev number\\n            while(!s1.empty() && curr > nums[s1.top()]){\\n                tmp.push(s1.top());\\n                s1.pop();\\n            }\\n\\t\\t\\t// if current number is greater than prev\\n\\t\\t\\t// we have got second greater to that prev number\\n            while(!s2.empty() && curr > nums[s2.top()]){\\n                ans[s2.top()] = curr;\\n                s2.pop();\\n            }\\n\\t\\t\\t// we wanted the stack monotonic so we used temp \\n\\t\\t\\t// now when we push in temp our order is greater at top\\n\\t\\t\\t// but we want smaller at top so we push now to s2\\n            while(!tmp.empty()){\\n                s2.push(tmp.top());\\n                tmp.pop();\\n            }\\n            s1.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758471,
                "title": "monotonic-stack-priority-queue-super-easy-solution",
                "content": "Priority queue contains elements which have found their first greater element and are looking for second greater element and stack contains elements which have not found their first greater element . \\nOnly difference between this problem and standard next greater element problems is priority queue.\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        stack<int>st;\\n        vector<int>b(n,-1);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n             while(!pq.empty()&&nums[i]>pq.top().first)\\n            {\\n                b[pq.top().second]=nums[i];\\n                pq.pop();\\n            }\\n            \\n            while(!st.empty()&&nums[i]>nums[st.top()])\\n            {\\n                pq.push({nums[st.top()],st.top()});\\n                st.pop();\\n            }\\n            \\n           \\n            st.push(i);\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            b[st.top()]=-1;\\n            st.pop();\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            b[pq.top().second]=-1;\\n            pq.pop();\\n        }\\n        \\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        stack<int>st;\\n        vector<int>b(n,-1);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n             while(!pq.empty()&&nums[i]>pq.top().first)\\n            {\\n                b[pq.top().second]=nums[i];\\n                pq.pop();\\n            }\\n            \\n            while(!st.empty()&&nums[i]>nums[st.top()])\\n            {\\n                pq.push({nums[st.top()],st.top()});\\n                st.pop();\\n            }\\n            \\n           \\n            st.push(i);\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            b[st.top()]=-1;\\n            st.pop();\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            b[pq.top().second]=-1;\\n            pq.pop();\\n        }\\n        \\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756416,
                "title": "java-nlogn-same-as-next-greater-element",
                "content": "```\\nclass Solution {\\n    Stack<Integer> st = new Stack<>();\\n    public int[] secondGreaterElement(int[] nums) {\\n        st = new Stack<>();\\n        int arr[] = getNG(nums); \\n        PriorityQueue<int[]> pq[] = new PriorityQueue[nums.length];\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            pq[i] = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        }\\n        int[] res = new int[arr.length];\\n\\n        for(int i = 0;i<nums.length;i++){            \\n            if(arr[i]==-1){\\n                res[i] = -1;\\n                continue;  \\n            } \\n            pq[arr[i]].add(new int[]{nums[i],i});\\n        }\\n        \\n        st.clear();\\n        \\n        \\n        for(int i = arr.length-1;i>=0;i--){\\n            \\n            if(st.isEmpty()){\\n               while(!pq[i].isEmpty()){\\n                   res[pq[i].remove()[1]] = -1;\\n               } \\n            }\\n            else{\\n                \\n                while(!pq[i].isEmpty()){\\n                    int[] x = pq[i].remove();\\n                    \\n                    while(!st.isEmpty() && x[0]>=st.peek()){\\n                        st.pop();\\n                    }\\n                    \\n                    if(st.isEmpty()){\\n                        res[x[1]] = -1;\\n                    }\\n                    else{\\n                        res[x[1]] = st.peek();\\n                    }\\n                }\\n            }\\n            st.push(nums[i]);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int[] getNG(int[] arr){\\n        st.clear();\\n        int[] res = new int[arr.length];\\n        \\n        for(int i = arr.length-1;i>=0;i--){\\n            \\n            if(st.isEmpty()){\\n                res[i] = -1;\\n            }\\n            else{\\n                while(!st.isEmpty() && arr[st.peek()]<=arr[i]){\\n                    st.pop();\\n                }\\n                \\n                if(st.isEmpty()){\\n                    res[i] = -1;\\n                }\\n                else{\\n                    res[i] = st.peek();\\n                }\\n            }\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    Stack<Integer> st = new Stack<>();\\n    public int[] secondGreaterElement(int[] nums) {\\n        st = new Stack<>();\\n        int arr[] = getNG(nums); \\n        PriorityQueue<int[]> pq[] = new PriorityQueue[nums.length];\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            pq[i] = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        }\\n        int[] res = new int[arr.length];\\n\\n        for(int i = 0;i<nums.length;i++){            \\n            if(arr[i]==-1){\\n                res[i] = -1;\\n                continue;  \\n            } \\n            pq[arr[i]].add(new int[]{nums[i],i});\\n        }\\n        \\n        st.clear();\\n        \\n        \\n        for(int i = arr.length-1;i>=0;i--){\\n            \\n            if(st.isEmpty()){\\n               while(!pq[i].isEmpty()){\\n                   res[pq[i].remove()[1]] = -1;\\n               } \\n            }\\n            else{\\n                \\n                while(!pq[i].isEmpty()){\\n                    int[] x = pq[i].remove();\\n                    \\n                    while(!st.isEmpty() && x[0]>=st.peek()){\\n                        st.pop();\\n                    }\\n                    \\n                    if(st.isEmpty()){\\n                        res[x[1]] = -1;\\n                    }\\n                    else{\\n                        res[x[1]] = st.peek();\\n                    }\\n                }\\n            }\\n            st.push(nums[i]);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int[] getNG(int[] arr){\\n        st.clear();\\n        int[] res = new int[arr.length];\\n        \\n        for(int i = arr.length-1;i>=0;i--){\\n            \\n            if(st.isEmpty()){\\n                res[i] = -1;\\n            }\\n            else{\\n                while(!st.isEmpty() && arr[st.peek()]<=arr[i]){\\n                    st.pop();\\n                }\\n                \\n                if(st.isEmpty()){\\n                    res[i] = -1;\\n                }\\n                else{\\n                    res[i] = st.peek();\\n                }\\n            }\\n            st.push(i);\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824976,
                "title": "c-set-monotonic-stack-easy-to-understand",
                "content": "1. In order to solve this problem, we need to have basic idea on how to calculate the next greater element using monotonic stack. \\n2. Monotonic stack is basically a stack in decreasing order such that all elements are in descending order. Whenever we encounter a new number such that it\\'s value is greater than the element on the top, we keep on popping all the numbers from the stack out till the stack\\'s topmost value is greater than the current value. Using this, we can easily find the next greater element.\\n3. Idea behind this problem is that whenever we encounter a next greater element, we will add all the elements whose next greater element is the current element to a different set called `processed`. This is for keeping track that first greater element of these numbers have been found already.\\n4. Whenever I encounter next number, I will first go through the processed set. If I encounter a number which is less than current element, the current element will be the second greater number for the processed one. We can then update our answer and delete this value from our set.\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        stack<pair<int, int> > monoStack;\\n        set<pair<int, int> > processed;\\n        vector<int> ans(nums.size(), -1);\\n        for(int i = 0; i < nums.size(); i++) {\\n            vector<pair<int, int> > toDelete;\\n            for(auto it = processed.begin(); it != processed.end(); it++) {\\n                if(it->first < nums[i]) {\\n                    ans[it->second] = nums[i];\\n                    toDelete.push_back(*it);\\n                }\\n                else break;\\n            }\\n            for(int j = 0; j < toDelete.size(); j++) {\\n                processed.erase(toDelete[j]);\\n            }\\n            if(monoStack.empty()) monoStack.push({ nums[i], i });\\n            else {\\n                while(!monoStack.empty() && monoStack.top().first < nums[i]) {\\n                    processed.insert(monoStack.top());\\n                    monoStack.pop();\\n                }\\n                monoStack.push({ nums[i], i });\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        stack<pair<int, int> > monoStack;\\n        set<pair<int, int> > processed;\\n        vector<int> ans(nums.size(), -1);\\n        for(int i = 0; i < nums.size(); i++) {\\n            vector<pair<int, int> > toDelete;\\n            for(auto it = processed.begin(); it != processed.end(); it++) {\\n                if(it->first < nums[i]) {\\n                    ans[it->second] = nums[i];\\n                    toDelete.push_back(*it);\\n                }\\n                else break;\\n            }\\n            for(int j = 0; j < toDelete.size(); j++) {\\n                processed.erase(toDelete[j]);\\n            }\\n            if(monoStack.empty()) monoStack.push({ nums[i], i });\\n            else {\\n                while(!monoStack.empty() && monoStack.top().first < nums[i]) {\\n                    processed.insert(monoStack.top());\\n                    monoStack.pop();\\n                }\\n                monoStack.push({ nums[i], i });\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759063,
                "title": "c-no-segment-tree-no-stack-solution-using-sorting-and-lower-bound-o-nlogn-time-o-n-space",
                "content": "We only care about elements which are appearing after and which are greater than current element. So we iterate over the elements in decreasing order\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(pair<int,int> &a, pair<int,int> &b){\\n        if(a.first==b.first)return a.second<b.second;\\n        return a.first>b.first;\\n    }\\n    \\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\tvector<pair<int,int>> a;\\n\\t\\tfor(int i=0; i<n; i++) a.push_back({nums[i],i});\\n\\t\\tsort(a.begin(), a.end(), cmp);\\n        \\n        vector<int> ans(n);\\n        set<int> s;\\n\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\tint index = a[i].second;\\n\\t\\t\\tauto it=s.lower_bound(index);\\n\\t\\t\\tif(it!=s.end()) it++;\\n\\t\\t\\tif(it!=s.end()) {\\n\\t\\t\\t\\tans[index]=nums[*it];\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans[index]=-1;\\n\\t\\t\\t}\\n\\t\\t\\ts.insert(index);\\n\\t\\t}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(pair<int,int> &a, pair<int,int> &b){\\n        if(a.first==b.first)return a.second<b.second;\\n        return a.first>b.first;\\n    }\\n    \\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\tvector<pair<int,int>> a;\\n\\t\\tfor(int i=0; i<n; i++) a.push_back({nums[i],i});\\n\\t\\tsort(a.begin(), a.end(), cmp);\\n        \\n        vector<int> ans(n);\\n        set<int> s;\\n\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\tint index = a[i].second;\\n\\t\\t\\tauto it=s.lower_bound(index);\\n\\t\\t\\tif(it!=s.end()) it++;\\n\\t\\t\\tif(it!=s.end()) {\\n\\t\\t\\t\\tans[index]=nums[*it];\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tans[index]=-1;\\n\\t\\t\\t}\\n\\t\\t\\ts.insert(index);\\n\\t\\t}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757184,
                "title": "sorting-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) \\n    {\\n        int n =  nums.size();\\n        vector<vector<int>> vt;\\n        for(int i = 0;i<n;i++)\\n        {\\n            vt.push_back({nums[i] , i});\\n        }\\n        \\n        multiset<int> st;\\n        vector<int> ans(n , -1);\\n        sort(vt.begin() , vt.end());\\n        \\n        for(int i = n-1;i>=0;)\\n        {\\n            vector<int> tp;\\n            int val = vt[i][0];\\n            while(i >= 0 && val == vt[i][0])\\n            {\\n                auto itr = st.upper_bound(vt[i][1]);\\n                if(itr != st.end())\\n                {\\n                    if(itr != st.end()) itr++;\\n                    if(itr != st.end()) ans[vt[i][1]] = nums[*itr];\\n                }\\n                tp.push_back(vt[i][1]);\\n                i-=1;\\n            }\\n            \\n            for(auto &idx :tp)\\n                st.insert(idx);\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) \\n    {\\n        int n =  nums.size();\\n        vector<vector<int>> vt;\\n        for(int i = 0;i<n;i++)\\n        {\\n            vt.push_back({nums[i] , i});\\n        }\\n        \\n        multiset<int> st;\\n        vector<int> ans(n , -1);\\n        sort(vt.begin() , vt.end());\\n        \\n        for(int i = n-1;i>=0;)\\n        {\\n            vector<int> tp;\\n            int val = vt[i][0];\\n            while(i >= 0 && val == vt[i][0])\\n            {\\n                auto itr = st.upper_bound(vt[i][1]);\\n                if(itr != st.end())\\n                {\\n                    if(itr != st.end()) itr++;\\n                    if(itr != st.end()) ans[vt[i][1]] = nums[*itr];\\n                }\\n                tp.push_back(vt[i][1]);\\n                i-=1;\\n            }\\n            \\n            for(auto &idx :tp)\\n                st.insert(idx);\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757058,
                "title": "c-shortest-code-ever-with-explanation-stack-priority-queue",
                "content": "**Approach** : \\n* First find the *next greater element **(nge)*** using monotonic stack and put the element for which we found n.g.e. let **curr** to **priority_queue( min heap )** and the *next greater element **(nge)*** of **curr** to **stack**.\\n* These values in pq can be used to further find it\\'s ***second next greater element*** from the nums array that we are traversing. \\n\\n\\teg :      Suppose our `pq.top().first = 2` and since it is in pq that means we already have it\\'s *next greater element in stack*. Now in the nums if we found a number` nums[i]` which is greater than 2 that means nums[i] is the ***2nd next greater element*** for 2; \\n.\\nSo, store ` res[pq.top().second] = nums[i];`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> res(n,-1);\\n        stack<pair<int,int>> st;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<n;i++){\\n            \\n            while(!pq.empty() and nums[i] > pq.top().first){\\n                res[pq.top().second] = nums[i];\\n                pq.pop();\\n            }\\n            \\n            while(!st.empty() and nums[i] > st.top().first){\\n                pq.push(st.top());\\n                st.pop();\\n            } \\n            st.push({nums[i],i});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> res(n,-1);\\n        stack<pair<int,int>> st;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<n;i++){\\n            \\n            while(!pq.empty() and nums[i] > pq.top().first){\\n                res[pq.top().second] = nums[i];\\n                pq.pop();\\n            }\\n            \\n            while(!st.empty() and nums[i] > st.top().first){\\n                pq.push(st.top());\\n                st.pop();\\n            } \\n            st.push({nums[i],i});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756605,
                "title": "c-easy-to-understand-code-monotonic-stack-and-priority-queue-o-nlogn-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res(n, -1);\\n        stack<int> first;\\n        auto comp = [&nums](int i, int j) { return nums[i] > nums[j]; };\\n        priority_queue<int, vector<int>, decltype(comp)> second(comp);\\n        for (int i = 0; i < n; i++) {\\n            while (!second.empty()) {\\n                if (nums[i] <= nums[second.top()]) break;\\n                // find second greater\\n                res[second.top()] = nums[i];\\n                second.pop();\\n            }\\n            while (!first.empty()) {\\n                if (nums[i] <= nums[first.top()]) break;\\n                // find first greater, push it into the second container(priority_queue)\\n                second.push(first.top());\\n                first.pop();\\n            }\\n            first.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res(n, -1);\\n        stack<int> first;\\n        auto comp = [&nums](int i, int j) { return nums[i] > nums[j]; };\\n        priority_queue<int, vector<int>, decltype(comp)> second(comp);\\n        for (int i = 0; i < n; i++) {\\n            while (!second.empty()) {\\n                if (nums[i] <= nums[second.top()]) break;\\n                // find second greater\\n                res[second.top()] = nums[i];\\n                second.pop();\\n            }\\n            while (!first.empty()) {\\n                if (nums[i] <= nums[first.top()]) break;\\n                // find first greater, push it into the second container(priority_queue)\\n                second.push(first.top());\\n                first.pop();\\n            }\\n            first.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756518,
                "title": "c-2-layers-stack-pq-o-n-logn",
                "content": "When the first greater is found for some elements in the monotonic stack, transfer them into the priority queue\\nin order to wait for the second greater:\\n\\n* use a <b>monotonic stack</b> to keep the decreasing sequences (and detect the <b>first greater</b> element for those\\nelements in stack that are smaller than the current <b>nums[i]</b>)\\n* priority queue to find the <b>second greater</b> for the elements that are transferred from the monotonic stack in the pq, after finding the first greater\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        vector<int> ans(nums.size(), -1);\\n        \\n        // q1 -> keep track of the first greater\\n        deque<int> q1;\\n\\t\\t\\n\\t\\t// q2 -> keep track of the second greater\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q2;\\n        \\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            while (!q2.empty() && q2.top().first < nums[i]) {\\n                ans[q2.top().second] = nums[i];\\n                q2.pop();\\n            }\\n    \\n            while (!q1.empty() && nums[q1.back()] < nums[i]) {\\n                q2.push({nums[q1.back()], q1.back()});\\n                q1.pop_back();\\n            }\\n            \\n            q1.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        vector<int> ans(nums.size(), -1);\\n        \\n        // q1 -> keep track of the first greater\\n        deque<int> q1;\\n\\t\\t\\n\\t\\t// q2 -> keep track of the second greater\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q2;\\n        \\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            while (!q2.empty() && q2.top().first < nums[i]) {\\n                ans[q2.top().second] = nums[i];\\n                q2.pop();\\n            }\\n    \\n            while (!q1.empty() && nums[q1.back()] < nums[i]) {\\n                q2.push({nums[q1.back()], q1.back()});\\n                q1.pop_back();\\n            }\\n            \\n            q1.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756505,
                "title": "use-a-map",
                "content": "1. traverse through the array, maintain a set of seen elements.\\n2. for current element, we mark elements smaller than current. \\n - if some element is already marked, then current is the second greater of it, we can remove it from the seen set.\\n\\ncannot tell the time complexity, maybe O(nlogn), but accepted\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        vector<int> ans(nums.size(), -1);\\n        multimap<int, pair<int, int>> m;// key(element from nums), (the mark), (index of this element)\\n        for (int i = 0; i < nums.size(); i++) {\\n            int x = nums[i];\\n            for (auto it = m.begin(); it != m.end();) { // \\n                if (it->first >= x) break; // only mark element smaller than x (according to the problem description)\\n                if (it->second.first == 1) { // already marked, this is the second time (means current element is the second greater of it, means job is done for it, we can remove it freely)\\n                    ans[it->second.second] = x;\\n                    it=m.erase(it);\\n                } else { // first time mark\\n                    it->second.first++;\\n                    it++;\\n                }\\n            }\\n            m.insert({ x,{0,i} });\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        vector<int> ans(nums.size(), -1);\\n        multimap<int, pair<int, int>> m;// key(element from nums), (the mark), (index of this element)\\n        for (int i = 0; i < nums.size(); i++) {\\n            int x = nums[i];\\n            for (auto it = m.begin(); it != m.end();) { // \\n                if (it->first >= x) break; // only mark element smaller than x (according to the problem description)\\n                if (it->second.first == 1) { // already marked, this is the second time (means current element is the second greater of it, means job is done for it, we can remove it freely)\\n                    ans[it->second.second] = x;\\n                    it=m.erase(it);\\n                } else { // first time mark\\n                    it->second.first++;\\n                    it++;\\n                }\\n            }\\n            m.insert({ x,{0,i} });\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756478,
                "title": "java-similar-solution-like-next-greatest-element",
                "content": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] a) {\\n        Stack<Integer> s = new Stack<>();\\n        PriorityQueue<int[]> t = new PriorityQueue<>((i,j) -> (i[0] - j[0]));\\n        int n = a.length;\\n        int[] ans = new int[n];\\n        Arrays.fill(ans,-1);\\n        for(int i=0;i<n;i++){\\n            while(!t.isEmpty() && t.peek()[0] < a[i]){\\n                int[] b = t.poll();\\n                ans[b[1]] = a[i];  \\n            }\\n            while(!s.isEmpty() && a[s.peek()] < a[i]){\\n                int in = s.pop();\\n                t.add(new int[]{a[in],in});\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] a) {\\n        Stack<Integer> s = new Stack<>();\\n        PriorityQueue<int[]> t = new PriorityQueue<>((i,j) -> (i[0] - j[0]));\\n        int n = a.length;\\n        int[] ans = new int[n];\\n        Arrays.fill(ans,-1);\\n        for(int i=0;i<n;i++){\\n            while(!t.isEmpty() && t.peek()[0] < a[i]){\\n                int[] b = t.poll();\\n                ans[b[1]] = a[i];  \\n            }\\n            while(!s.isEmpty() && a[s.peek()] < a[i]){\\n                int in = s.pop();\\n                t.add(new int[]{a[in],in});\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835358,
                "title": "python3-first-helper-and-second-stacks-o-n-100-faster",
                "content": "\\n```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        st1 = [] # monotonic decreasing first stack.\\n        st2 = [] # Monotonic decreasing second stack.(having only that elements which have first greater)\\n        helper = [] # monotonic increasing helper stack(help in moving elements from st1 to st2 with maintaining monotonicity of st2) \\n        n = len(nums)\\n        ans =[-1]*n\\n        for i in range(n):\\n            while st2 and nums[i]>nums[st2[-1]]: # if element can be second largest for st2 elements\\n                ans[st2.pop()] = nums[i]\\n            while st1 and nums[i]>nums[st1[-1]]: # if element can be second largest for st2 elements\\n                helper.append(st1.pop())\\n            while helper:\\n                st2.append(helper.pop())    # for maintain monotonicity of st2\\n            st1.append(i)\\n        return ans   \\n```\\n**If like , Upvote :)**\\n\\n![image](https://assets.leetcode.com/users/images/3795acd7-665a-4f86-924a-6ac8cae9d0d7_1690658756.045314.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        st1 = [] # monotonic decreasing first stack.\\n        st2 = [] # Monotonic decreasing second stack.(having only that elements which have first greater)\\n        helper = [] # monotonic increasing helper stack(help in moving elements from st1 to st2 with maintaining monotonicity of st2) \\n        n = len(nums)\\n        ans =[-1]*n\\n        for i in range(n):\\n            while st2 and nums[i]>nums[st2[-1]]: # if element can be second largest for st2 elements\\n                ans[st2.pop()] = nums[i]\\n            while st1 and nums[i]>nums[st1[-1]]: # if element can be second largest for st2 elements\\n                helper.append(st1.pop())\\n            while helper:\\n                st2.append(helper.pop())    # for maintain monotonicity of st2\\n            st1.append(i)\\n        return ans   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577175,
                "title": "javascript-commented-in-detail",
                "content": "- Time complexity: $$O(n)$$  \\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar secondGreaterElement = function(nums) {\\n    const n = nums.length;\\n    // Create an array to store the results.\\n    const ans = new Array(n).fill(-1);\\n    // Create a decreasing stack to store the indices that met the first greater num.\\n    const pre = [];\\n    // Create a decreasing stack to store the indices.\\n    const cur = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        const num = nums[i];\\n        // While there are indices in the previous stack that meet the second greater num.\\n        while (pre.length > 0 && nums[pre[pre.length - 1]] < num) {\\n            // Update the results.\\n            ans[pre.pop()] = num;\\n        }\\n        // Push indices that meet the first greater num from `cur` to `pre`.\\n        // Create a temp array to make indices in `pre` increasing.\\n        const tmp = [];\\n        while (cur.length > 0 && nums[cur[cur.length - 1]] < num) {\\n            tmp.push(cur.pop());\\n        }\\n        // While there are indices in `tmp`, push them to `pre`.\\n        while (tmp.length > 0) {\\n            pre.push(tmp.pop());\\n        }\\n        // Push the current index to `cur`.\\n        cur.push(i);\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Binary Search",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar secondGreaterElement = function(nums) {\\n    const n = nums.length;\\n    // Create an array to store the results.\\n    const ans = new Array(n).fill(-1);\\n    // Create a decreasing stack to store the indices that met the first greater num.\\n    const pre = [];\\n    // Create a decreasing stack to store the indices.\\n    const cur = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        const num = nums[i];\\n        // While there are indices in the previous stack that meet the second greater num.\\n        while (pre.length > 0 && nums[pre[pre.length - 1]] < num) {\\n            // Update the results.\\n            ans[pre.pop()] = num;\\n        }\\n        // Push indices that meet the first greater num from `cur` to `pre`.\\n        // Create a temp array to make indices in `pre` increasing.\\n        const tmp = [];\\n        while (cur.length > 0 && nums[cur[cur.length - 1]] < num) {\\n            tmp.push(cur.pop());\\n        }\\n        // While there are indices in `tmp`, push them to `pre`.\\n        while (tmp.length > 0) {\\n            pre.push(tmp.pop());\\n        }\\n        // Push the current index to `cur`.\\n        cur.push(i);\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3532311,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Two Stacks\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) \\n    {\\n        int i,n;\\n        n=nums.size(); \\n\\n        vector<int> s1,s2,temp,ans(n,-1);\\n\\n        for(i=0;i<n;i++)\\n        {\\n            while(!s2.empty() && nums[s2.back()]<nums[i])\\n            {\\n                ans[s2.back()]=nums[i];\\n                s2.pop_back();\\n            }\\n\\n            while(!s1.empty() && nums[s1.back()]<nums[i])\\n            {\\n                temp.push_back(s1.back());\\n                s1.pop_back();\\n            }\\n            \\n            while(!temp.empty())\\n            {\\n                s2.push_back(temp.back());\\n                temp.pop_back();\\n            }\\n\\n            s1.push_back(i);\\n        }\\n\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) \\n    {\\n        int i,n;\\n        n=nums.size(); \\n\\n        vector<int> s1,s2,temp,ans(n,-1);\\n\\n        for(i=0;i<n;i++)\\n        {\\n            while(!s2.empty() && nums[s2.back()]<nums[i])\\n            {\\n                ans[s2.back()]=nums[i];\\n                s2.pop_back();\\n            }\\n\\n            while(!s1.empty() && nums[s1.back()]<nums[i])\\n            {\\n                temp.push_back(s1.back());\\n                s1.pop_back();\\n            }\\n            \\n            while(!temp.empty())\\n            {\\n                s2.push_back(temp.back());\\n                temp.pop_back();\\n            }\\n\\n            s1.push_back(i);\\n        }\\n\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477669,
                "title": "using-map-c-but-pretty-slow-approach",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        map<int,bool>num;\\n        set<int>st;\\n        unordered_map<int,vector<int>>ind;\\n        for(int i = 0;i<n;i++){\\n            int e = nums[i];\\n            num[e] = true;\\n            ind[e].push_back(i);\\n            st.insert(i);\\n        }\\n\\n        vector<int>ans(n,-1);\\n        unordered_map<int,set<int>>fnal;\\n        for(auto e:num){\\n            for(auto in:ind[e.first]){\\n                st.erase(in);\\n            }\\n            for(auto in:ind[e.first]){\\n                 auto it1 = st.upper_bound(in);\\n                if(it1 == st.end())continue;\\n                auto it2 = st.upper_bound(*it1);\\n                if(it2 == st.end())continue;\\n                ans[in] = nums[*it2];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        map<int,bool>num;\\n        set<int>st;\\n        unordered_map<int,vector<int>>ind;\\n        for(int i = 0;i<n;i++){\\n            int e = nums[i];\\n            num[e] = true;\\n            ind[e].push_back(i);\\n            st.insert(i);\\n        }\\n\\n        vector<int>ans(n,-1);\\n        unordered_map<int,set<int>>fnal;\\n        for(auto e:num){\\n            for(auto in:ind[e.first]){\\n                st.erase(in);\\n            }\\n            for(auto in:ind[e.first]){\\n                 auto it1 = st.upper_bound(in);\\n                if(it1 == st.end())continue;\\n                auto it2 = st.upper_bound(*it1);\\n                if(it2 == st.end())continue;\\n                ans[in] = nums[*it2];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137413,
                "title": "very-simple-using-2-stack-l",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& arr) {\\n        stack<int>st1,st2,temp;\\n        int n =arr.size();\\n        vector<int>ans(n,-1);\\n        for(int i=0;i<n;i++){\\n          while(!st2.empty()&& arr[st2.top()]<arr[i]){\\n              ans[st2.top()] = arr[i];\\n              st2.pop();\\n          }\\n          while(!st1.empty()&&arr[st1.top()]<arr[i]){\\n              temp.push(st1.top());\\n              st1.pop();\\n          }\\n          while(!temp.empty()) {\\n              st2.push(temp.top());\\n              temp.pop();\\n          }\\n          st1.push(i);\\n        }\\n    return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& arr) {\\n        stack<int>st1,st2,temp;\\n        int n =arr.size();\\n        vector<int>ans(n,-1);\\n        for(int i=0;i<n;i++){\\n          while(!st2.empty()&& arr[st2.top()]<arr[i]){\\n              ans[st2.top()] = arr[i];\\n              st2.pop();\\n          }\\n          while(!st1.empty()&&arr[st1.top()]<arr[i]){\\n              temp.push(st1.top());\\n              st1.pop();\\n          }\\n          while(!temp.empty()) {\\n              st2.push(temp.top());\\n              temp.pop();\\n          }\\n          st1.push(i);\\n        }\\n    return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987777,
                "title": "c-2nd-layer-nge-minheap-priority-queue-for-filtration",
                "content": "\\n# Complexity\\n- TC -> O(NlogN) :  SC -> O(3N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        vector<vector<int>> vec1(nums.size());  \\n        stack<int> st;  \\n\\n        // for the 1st Layer of NGE(Next greater elem) ->\\n        // storing the indices of elems having NGE as nums[i] into vec1[i] \\n        for(int i=0;i<nums.size();i++){\\n            int ele = nums[i];\\n            while(!st.empty() && nums[st.top()]<ele){\\n                vec1[i].push_back(st.top());\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n\\n        vector<vector<int>> vec2(nums.size()); \\n\\n        //using Min Heap to take the indices of elems which are less than the 2nd NGE(nums[i]) into vec2[i]\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq; // num -> index\\n\\n        // for the 2nd Layer of NGE(Next greater elem) ->\\n        // storing the indices of elems having 2nd NGE as nums[i] into vec2[i]  (sing minheap to take elems < nums[i])\\n        for(int i=0;i<nums.size();i++){\\n            int ele = nums[i];\\n            while(!pq.empty() && ele>pq.top().first){\\n                vec2[i].push_back(pq.top().second);\\n                pq.pop();\\n            }\\n            for(auto j:vec1[i]){\\n                pq.push({nums[j],j});\\n            }\\n        }\\n\\n        vector<int> ans(nums.size(),-1);\\n\\n        // putting 2nd NGE into its respective 2nd PSE(previous smaller elem) using the vec2\\n        for(int i=nums.size()-1;i>=0;i--){\\n            int elem = nums[i];\\n            for(auto j:vec2[i]){\\n                ans[j]=elem;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        vector<vector<int>> vec1(nums.size());  \\n        stack<int> st;  \\n\\n        // for the 1st Layer of NGE(Next greater elem) ->\\n        // storing the indices of elems having NGE as nums[i] into vec1[i] \\n        for(int i=0;i<nums.size();i++){\\n            int ele = nums[i];\\n            while(!st.empty() && nums[st.top()]<ele){\\n                vec1[i].push_back(st.top());\\n                st.pop();\\n            }\\n            st.push(i);\\n        }\\n\\n        vector<vector<int>> vec2(nums.size()); \\n\\n        //using Min Heap to take the indices of elems which are less than the 2nd NGE(nums[i]) into vec2[i]\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq; // num -> index\\n\\n        // for the 2nd Layer of NGE(Next greater elem) ->\\n        // storing the indices of elems having 2nd NGE as nums[i] into vec2[i]  (sing minheap to take elems < nums[i])\\n        for(int i=0;i<nums.size();i++){\\n            int ele = nums[i];\\n            while(!pq.empty() && ele>pq.top().first){\\n                vec2[i].push_back(pq.top().second);\\n                pq.pop();\\n            }\\n            for(auto j:vec1[i]){\\n                pq.push({nums[j],j});\\n            }\\n        }\\n\\n        vector<int> ans(nums.size(),-1);\\n\\n        // putting 2nd NGE into its respective 2nd PSE(previous smaller elem) using the vec2\\n        for(int i=nums.size()-1;i>=0;i--){\\n            int elem = nums[i];\\n            for(auto j:vec2[i]){\\n                ans[j]=elem;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828225,
                "title": "stack-binarysearch-heap-solutions-python",
                "content": "**Stack Approach**\\n**Time: O(n)\\nSpace: O(n)**\\n```\\ndef secondGreaterElement(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    ans = [-1]*n\\n\\n    stack = []\\n    next_stack = []\\n    for i in range(n):\\n\\n        while next_stack and nums[next_stack[-1]] < nums[i]:\\n            ans[next_stack.pop()] = nums[i]\\n\\n        indices = []\\n        while stack and nums[stack[-1]] < nums[i]:\\n            indices += [stack.pop()]\\n        next_stack += indices[::-1]\\n        stack.append(i)\\n    \\n    return ans\\n```\\n\\n**Binary Search Approach**\\n**Time: O(nlogn)\\nSpace: O(n)**\\n```\\ndef secondGreaterElement(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    ans = [-1]*n\\n\\n    def BS(i):\\n        L = 0; R = len(stack)\\n        while L < R:\\n            M = (L+R)//2\\n            if nums[stack[M]] >= nums[i]:\\n                L = M+1\\n            else:\\n                R = M\\n        return L\\n\\n    stack = []\\n    next_stack = []\\n    for i in range(n):\\n\\n        while next_stack and nums[next_stack[-1]] < nums[i]:\\n            ans[next_stack.pop()] = nums[i]\\n\\n        idx = BS(i)\\n        if idx < len(stack):\\n            next_stack += stack[idx:]\\n            stack[idx:] = []\\n        stack.append(i)\\n    \\n    return ans\\n```\\n\\n**Heap Approach**\\n**Time: O(nlogn)\\nSpace: O(n)**\\n```\\ndef secondGreaterElement(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    ans = [-1]*n\\n\\n    stack = []\\n    min_heap = []\\n    for i in range(n):\\n\\n        while min_heap and min_heap[0][0] < nums[i]:\\n            _, idx = heappop(min_heap)\\n            ans[idx] = nums[i]\\n\\n        while stack and nums[stack[-1]] < nums[i]:\\n            j = stack.pop()\\n            heappush(min_heap, [nums[j], j])\\n\\n        stack.append(i)\\n    \\n    return ans\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef secondGreaterElement(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    ans = [-1]*n\\n\\n    stack = []\\n    next_stack = []\\n    for i in range(n):\\n\\n        while next_stack and nums[next_stack[-1]] < nums[i]:\\n            ans[next_stack.pop()] = nums[i]\\n\\n        indices = []\\n        while stack and nums[stack[-1]] < nums[i]:\\n            indices += [stack.pop()]\\n        next_stack += indices[::-1]\\n        stack.append(i)\\n    \\n    return ans\\n```\n```\\ndef secondGreaterElement(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    ans = [-1]*n\\n\\n    def BS(i):\\n        L = 0; R = len(stack)\\n        while L < R:\\n            M = (L+R)//2\\n            if nums[stack[M]] >= nums[i]:\\n                L = M+1\\n            else:\\n                R = M\\n        return L\\n\\n    stack = []\\n    next_stack = []\\n    for i in range(n):\\n\\n        while next_stack and nums[next_stack[-1]] < nums[i]:\\n            ans[next_stack.pop()] = nums[i]\\n\\n        idx = BS(i)\\n        if idx < len(stack):\\n            next_stack += stack[idx:]\\n            stack[idx:] = []\\n        stack.append(i)\\n    \\n    return ans\\n```\n```\\ndef secondGreaterElement(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    ans = [-1]*n\\n\\n    stack = []\\n    min_heap = []\\n    for i in range(n):\\n\\n        while min_heap and min_heap[0][0] < nums[i]:\\n            _, idx = heappop(min_heap)\\n            ans[idx] = nums[i]\\n\\n        while stack and nums[stack[-1]] < nums[i]:\\n            j = stack.pop()\\n            heappush(min_heap, [nums[j], j])\\n\\n        stack.append(i)\\n    \\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2791303,
                "title": "c-using-two-priority-queues",
                "content": "# Intuition\\n - grouping by counting for a greater number\\n\\n# Approach\\n - Using two Priority queues. pq0, pq1\\n - pq0 : It doesn\\'t have a greater number\\n - pq1 : It doesn\\'t have second greater number yet\\n\\n# Complexity\\n- Time complexity: O( N log N )\\n\\n- Space complexity: O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct node {\\n        int val, idx;  \\n    };\\n    \\n    struct compare {\\n        bool operator()(const node &a, const node &b) {\\n            return a.val > b.val;\\n        }  \\n    };\\n    \\n    priority_queue<node, vector<node>, compare> pq0, pq1;    \\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> ans(n, -1);\\n        \\n        for (int i=0; i<n; ++i) {\\n            while(!pq1.empty() && pq1.top().val < nums[i]) {\\n                ans[pq1.top().idx] = nums[i];\\n                pq1.pop();\\n            }\\n            \\n            while(!pq0.empty() && pq0.top().val < nums[i]) {                \\n                pq1.push(pq0.top());\\n                pq0.pop();\\n            }\\n            \\n            pq0.push({nums[i], i});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct node {\\n        int val, idx;  \\n    };\\n    \\n    struct compare {\\n        bool operator()(const node &a, const node &b) {\\n            return a.val > b.val;\\n        }  \\n    };\\n    \\n    priority_queue<node, vector<node>, compare> pq0, pq1;    \\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> ans(n, -1);\\n        \\n        for (int i=0; i<n; ++i) {\\n            while(!pq1.empty() && pq1.top().val < nums[i]) {\\n                ans[pq1.top().idx] = nums[i];\\n                pq1.pop();\\n            }\\n            \\n            while(!pq0.empty() && pq0.top().val < nums[i]) {                \\n                pq1.push(pq0.top());\\n                pq0.pop();\\n            }\\n            \\n            pq0.push({nums[i], i});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763296,
                "title": "c-easy-solution-using-stack-and-binary-search-o-nlogn-time-o-n-space-complexity",
                "content": "# Intuition\\nWe can get inspiration to use Stack from [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/). Then we have to find a way to now instead obtain the second greater element instead of first.\\n\\n# Approach\\nRead the solution for [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/) before reading this if you haven\\'t as the approach is heavily based on that. While popping elements before pushing the new element, we will also store them in an vector. As the elements were always sorted in the stack, the vector will be sorted to, thus we use can binary search. Now to find the second greater element, we first find the first greater element. Then to find the second greater element:\\n\\n- If there is any number greater than the required number in the vector of numbers removed while pushing the first greater element, then the lowest such number is the answer\\n- Otherwise just pick the next number from stack\\n\\nAlso remember to handle the edge case when answer is -1.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        vector<vector<int>> del(n, vector<int> ());\\n        stack<pair<int, int>> data;\\n        for(int i = n - 1; i >= 0; i--){\\n            if(data.empty()){\\n                ans[i] = -1;\\n                data.push({nums[i], i});\\n                continue;\\n            }\\n            while(data.top().first <= nums[i]){\\n                del[i].push_back(data.top().first);\\n                data.pop();\\n                if(data.empty()){\\n                    break;\\n                }\\n            }\\n            if(data.empty()){\\n                ans[i] = -1;\\n                data.push({nums[i], i});\\n                continue;\\n            }\\n            auto itr = upper_bound(del[data.top().second].begin(), del[data.top().second].end(), nums[i]);\\n            if(itr == del[data.top().second].end()){\\n                pair<int, int> temp = data.top();\\n                data.pop();\\n                if(data.empty()) ans[i] = -1;\\n                else ans[i] = data.top().first;\\n                data.push(temp);\\n            }else ans[i] = *itr;\\n            data.push({nums[i], i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        vector<vector<int>> del(n, vector<int> ());\\n        stack<pair<int, int>> data;\\n        for(int i = n - 1; i >= 0; i--){\\n            if(data.empty()){\\n                ans[i] = -1;\\n                data.push({nums[i], i});\\n                continue;\\n            }\\n            while(data.top().first <= nums[i]){\\n                del[i].push_back(data.top().first);\\n                data.pop();\\n                if(data.empty()){\\n                    break;\\n                }\\n            }\\n            if(data.empty()){\\n                ans[i] = -1;\\n                data.push({nums[i], i});\\n                continue;\\n            }\\n            auto itr = upper_bound(del[data.top().second].begin(), del[data.top().second].end(), nums[i]);\\n            if(itr == del[data.top().second].end()){\\n                pair<int, int> temp = data.top();\\n                data.pop();\\n                if(data.empty()) ans[i] = -1;\\n                else ans[i] = data.top().first;\\n                data.push(temp);\\n            }else ans[i] = *itr;\\n            data.push({nums[i], i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761676,
                "title": "next-greater-element-iv-two-stack-easy-way-c",
                "content": "```\\nSet s1 will contain the elements whose next greater element is not found yet.\\n\\nSet s2 will contain the elements whose next greater element has been found but second greater element is not found yet.\\n\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        set<pair<int,int> >s1,s2;\\n        int n=nums.size();\\n        vector<int>ans(n,-1);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s2.empty())\\n            {\\n                auto to=s2.begin();\\n                int val=to->first;\\n                if(nums[i]>val)\\n                {\\n                    ans[to->second]=nums[i];\\n                    s2.erase(to);\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            \\n            while(!s1.empty())\\n            {\\n                auto to=s1.begin();\\n                int val=to->first;\\n                if(nums[i]>val)\\n                {\\n                    s2.insert(*to);\\n                    s1.erase(*to);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            s1.insert({nums[i],i});\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        set<pair<int,int> >s1,s2;\\n        int n=nums.size();\\n        vector<int>ans(n,-1);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s2.empty())\\n            {\\n                auto to=s2.begin();\\n                int val=to->first;\\n                if(nums[i]>val)\\n                {\\n                    ans[to->second]=nums[i];\\n                    s2.erase(to);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2757825,
                "title": "java-two-min-heaps-priority-queue",
                "content": "Just like finding next greatest element with a single priority queue we can use one more to track the elements which are going t be needing second greatest element.\\n\\nTime: `O(NlogN)`, Space: `O(N)`\\n\\nsolution is explained through comments\\n\\n```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        for(int i = 0;i<n;i++) ans[i] = -1;\\n\\t\\t// Min heap to track the elements to be treated for the first time\\n        PriorityQueue<Pair<Integer, Integer>> firstGreater = new PriorityQueue<>((a, b) -> {\\n            return compare(a.getKey(), b.getKey());\\n        });\\n\\t\\t\\n\\t\\t// Min heap to track the elements needing the second greater element\\n        PriorityQueue<Pair<Integer, Integer>> secondGreater = new PriorityQueue<>((a, b) -> {\\n            return compare(a.getKey(), b.getKey());\\n        });\\n        \\n        firstGreater.add(new Pair(nums[0], 0));\\n        \\n        for(int i = 1;i<n;i++) {\\n            // pop lesser elements than nums[i] and put answer for them as nums[i]\\n            while(!secondGreater.isEmpty() && secondGreater.peek().getKey() < nums[i]) {\\n                Pair<Integer, Integer> top = secondGreater.poll();\\n                ans[top.getValue()] = nums[i];\\n            }\\n            \\n            // pop lesser elements from firstGreater and push to secondGreater\\n            while(!firstGreater.isEmpty() && firstGreater.peek().getKey() < nums[i]) {\\n                secondGreater.add(firstGreater.poll());\\n            }\\n            \\n            firstGreater.add(new Pair(nums[i], i));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int compare(int a, int b) {\\n        return (Integer.valueOf(a)).compareTo(Integer.valueOf(b));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        for(int i = 0;i<n;i++) ans[i] = -1;\\n\\t\\t// Min heap to track the elements to be treated for the first time\\n        PriorityQueue<Pair<Integer, Integer>> firstGreater = new PriorityQueue<>((a, b) -> {\\n            return compare(a.getKey(), b.getKey());\\n        });\\n\\t\\t\\n\\t\\t// Min heap to track the elements needing the second greater element\\n        PriorityQueue<Pair<Integer, Integer>> secondGreater = new PriorityQueue<>((a, b) -> {\\n            return compare(a.getKey(), b.getKey());\\n        });\\n        \\n        firstGreater.add(new Pair(nums[0], 0));\\n        \\n        for(int i = 1;i<n;i++) {\\n            // pop lesser elements than nums[i] and put answer for them as nums[i]\\n            while(!secondGreater.isEmpty() && secondGreater.peek().getKey() < nums[i]) {\\n                Pair<Integer, Integer> top = secondGreater.poll();\\n                ans[top.getValue()] = nums[i];\\n            }\\n            \\n            // pop lesser elements from firstGreater and push to secondGreater\\n            while(!firstGreater.isEmpty() && firstGreater.peek().getKey() < nums[i]) {\\n                secondGreater.add(firstGreater.poll());\\n            }\\n            \\n            firstGreater.add(new Pair(nums[i], i));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int compare(int a, int b) {\\n        return (Integer.valueOf(a)).compareTo(Integer.valueOf(b));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757746,
                "title": "monotonic-stack-heap-video-solution",
                "content": "You can watch the video solution [here](https://youtu.be/YZrQrQehM64) \\n\\nFirst we are finding the `Next Greater Element` for all numbers.\\n\\nWe are considering it as the middle number.\\nThen we are adding all the numbers to the left of it in a minheap.\\nAll the numbers to the right are then compared with the top element in the heap.\\n\\nIf it is greater, then that number is the `2nd Greater Element`.\\n\\n```\\nclass Solution:\\n    def secondGreaterElement(self, A: List[int]) -> List[int]:\\n        n = len(A)\\n        \\n        middle, st = [[] for _ in range(n)], []\\n        \\n        for i in range(n):\\n            while st and A[st[-1]]<A[i]:\\n                middle[i].append(st.pop())\\n            st.append(i)\\n            \\n        ans = [-1] * n\\n        h = []\\n        \\n        for i in range(n):\\n            while h and A[h[0][1]]<A[i]:\\n                ans[heapq.heappop(h)[1]] = A[i]\\n                \\n            for j in middle[i]:\\n                heapq.heappush(h, (A[j], j))\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "You can watch the video solution [here](https://youtu.be/YZrQrQehM64) \\n\\nFirst we are finding the `Next Greater Element` for all numbers.\\n\\nWe are considering it as the middle number.\\nThen we are adding all the numbers to the left of it in a minheap.\\nAll the numbers to the right are then compared with the top element in the heap.\\n\\nIf it is greater, then that number is the `2nd Greater Element`.\\n\\n```\\nclass Solution:\\n    def secondGreaterElement(self, A: List[int]) -> List[int]:\\n        n = len(A)\\n        \\n        middle, st = [[] for _ in range(n)], []\\n        \\n        for i in range(n):\\n            while st and A[st[-1]]<A[i]:\\n                middle[i].append(st.pop())\\n            st.append(i)\\n            \\n        ans = [-1] * n\\n        h = []\\n        \\n        for i in range(n):\\n            while h and A[h[0][1]]<A[i]:\\n                ans[heapq.heappop(h)[1]] = A[i]\\n                \\n            for j in middle[i]:\\n                heapq.heappush(h, (A[j], j))\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2757625,
                "title": "rust-segment-tree-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, we map all n distinct sorted values of nums into their ordering index (0-based). \\nWe then use a segment tree to maintain two list of indexes, with the first being the indexes of those numbers in nums that are bigger and the second list contains similar indexes that have not been propogated yet.     \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSegment Tree\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N LogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::BinaryHeap;\\nuse std::collections::BTreeSet;\\nuse std::collections::HashMap;\\n\\nstruct Tree {\\n    tree: Vec<((usize, usize), (usize, usize))>,\\n    sz: usize\\n}\\n\\nimpl Tree {\\n    fn new(m: usize, n: usize) -> Self {\\n        Self { tree: vec![((m, m), (m, m)); 4 * n], sz: m }\\n    }\\n\\n    fn add(&mut self, u: usize, left: usize, right: usize, i: usize, val: usize) {\\n        if i < left { return } \\n        if i >= right {\\n            let mut pq = BinaryHeap::from([val, self.tree[u].1.0, self.tree[u].1.1]);\\n            if pq.len() > 2 { pq.pop(); } \\n            if pq.len() == 2 { self.tree[u].1.1 = pq.pop().unwrap(); }\\n            self.tree[u].1.0 = pq.pop().unwrap();\\n            return;\\n        }\\n        if left == right { return }\\n\\n        let mid = left + (right - left) / 2;\\n        self.add(2 * u, left, mid, i, val);\\n        self.add(2 * u + 1, mid + 1, right, i, val);\\n    }\\n\\n    fn query(&mut self, u: usize, left: usize, right: usize, i: usize) ->usize {\\n        if self.tree[u].1.0 < self.sz {\\n            let mut pq = BinaryHeap::from([self.tree[u].0.0, self.tree[u].0.1, \\n                                           self.tree[u].1.0, self.tree[u].1.1]);\\n            while pq.len() > 2 { pq.pop(); }\\n            self.tree[u].0.1 = pq.pop().unwrap();\\n            self.tree[u].0.0 = pq.pop().unwrap();\\n        \\n            if left < right {\\n                let mut pq = BinaryHeap::from([self.tree[u].1.0, self.tree[u].1.1, \\n                                               self.tree[2 * u].1.0, self.tree[2 * u].1.1]);\\n                while pq.len() > 2 { pq.pop(); }\\n                self.tree[2 * u].1.1 = pq.pop().unwrap();\\n                self.tree[2 * u].1.0 = pq.pop().unwrap();\\n\\n                let mut pq = BinaryHeap::from([self.tree[u].1.0, self.tree[u].1.1, \\n                                               self.tree[2 * u + 1].1.0, self.tree[2 * u + 1].1.1]);\\n                while pq.len() > 2 { pq.pop(); }\\n                self.tree[2 * u + 1].1.1 = pq.pop().unwrap();\\n                self.tree[2 * u + 1].1.0 = pq.pop().unwrap();\\n            }\\n\\n            self.tree[u].1.0 = self.sz;\\n            self.tree[u].1.1 = self.sz;\\n        }\\n\\n        if left == right { return self.tree[u].0.1 }\\n\\n        let mid = left + (right - left) / 2;\\n\\n        if i <= mid { return self.query(2 * u, left, mid, i) }\\n        self.query(2 * u + 1, mid + 1, right, i)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn second_greater_element(nums: Vec<i32>) -> Vec<i32> {\\n        let mut temp = BTreeSet::new();\\n        for a in &nums { temp.insert(*a); }\\n\\n        let mut mp = HashMap::<i32, usize>::new();\\n        for a in temp.iter() {\\n            let sz = mp.len();\\n            mp.insert(*a, sz);\\n        }\\n\\n        let n = mp.len() + 1;\\n        let m = nums.len();\\n        let mut tree = Tree::new(m, n);\\n        let mut ret = vec![];\\n\\n        for i in (0 .. m).rev() {\\n            let j = *mp.get(&nums[i]).unwrap();\\n            tree.add(1, 0, n - 1, j, i);\\n            let k = tree.query(1, 0, n - 1, j + 1);\\n            let temp = if k == m { -1 } else { nums[k] };\\n            ret.push(temp);\\n        }\\n        ret.reverse();\\n\\n        ret\\n    } \\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\nuse std::collections::BTreeSet;\\nuse std::collections::HashMap;\\n\\nstruct Tree {\\n    tree: Vec<((usize, usize), (usize, usize))>,\\n    sz: usize\\n}\\n\\nimpl Tree {\\n    fn new(m: usize, n: usize) -> Self {\\n        Self { tree: vec![((m, m), (m, m)); 4 * n], sz: m }\\n    }\\n\\n    fn add(&mut self, u: usize, left: usize, right: usize, i: usize, val: usize) {\\n        if i < left { return } \\n        if i >= right {\\n            let mut pq = BinaryHeap::from([val, self.tree[u].1.0, self.tree[u].1.1]);\\n            if pq.len() > 2 { pq.pop(); } \\n            if pq.len() == 2 { self.tree[u].1.1 = pq.pop().unwrap(); }\\n            self.tree[u].1.0 = pq.pop().unwrap();\\n            return;\\n        }\\n        if left == right { return }\\n\\n        let mid = left + (right - left) / 2;\\n        self.add(2 * u, left, mid, i, val);\\n        self.add(2 * u + 1, mid + 1, right, i, val);\\n    }\\n\\n    fn query(&mut self, u: usize, left: usize, right: usize, i: usize) ->usize {\\n        if self.tree[u].1.0 < self.sz {\\n            let mut pq = BinaryHeap::from([self.tree[u].0.0, self.tree[u].0.1, \\n                                           self.tree[u].1.0, self.tree[u].1.1]);\\n            while pq.len() > 2 { pq.pop(); }\\n            self.tree[u].0.1 = pq.pop().unwrap();\\n            self.tree[u].0.0 = pq.pop().unwrap();\\n        \\n            if left < right {\\n                let mut pq = BinaryHeap::from([self.tree[u].1.0, self.tree[u].1.1, \\n                                               self.tree[2 * u].1.0, self.tree[2 * u].1.1]);\\n                while pq.len() > 2 { pq.pop(); }\\n                self.tree[2 * u].1.1 = pq.pop().unwrap();\\n                self.tree[2 * u].1.0 = pq.pop().unwrap();\\n\\n                let mut pq = BinaryHeap::from([self.tree[u].1.0, self.tree[u].1.1, \\n                                               self.tree[2 * u + 1].1.0, self.tree[2 * u + 1].1.1]);\\n                while pq.len() > 2 { pq.pop(); }\\n                self.tree[2 * u + 1].1.1 = pq.pop().unwrap();\\n                self.tree[2 * u + 1].1.0 = pq.pop().unwrap();\\n            }\\n\\n            self.tree[u].1.0 = self.sz;\\n            self.tree[u].1.1 = self.sz;\\n        }\\n\\n        if left == right { return self.tree[u].0.1 }\\n\\n        let mid = left + (right - left) / 2;\\n\\n        if i <= mid { return self.query(2 * u, left, mid, i) }\\n        self.query(2 * u + 1, mid + 1, right, i)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn second_greater_element(nums: Vec<i32>) -> Vec<i32> {\\n        let mut temp = BTreeSet::new();\\n        for a in &nums { temp.insert(*a); }\\n\\n        let mut mp = HashMap::<i32, usize>::new();\\n        for a in temp.iter() {\\n            let sz = mp.len();\\n            mp.insert(*a, sz);\\n        }\\n\\n        let n = mp.len() + 1;\\n        let m = nums.len();\\n        let mut tree = Tree::new(m, n);\\n        let mut ret = vec![];\\n\\n        for i in (0 .. m).rev() {\\n            let j = *mp.get(&nums[i]).unwrap();\\n            tree.add(1, 0, n - 1, j, i);\\n            let k = tree.query(1, 0, n - 1, j + 1);\\n            let temp = if k == m { -1 } else { nums[k] };\\n            ret.push(temp);\\n        }\\n        ret.reverse();\\n\\n        ret\\n    } \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2757493,
                "title": "java-solution-using-stack-and-max-heap-tc-o-n-sc-o-n",
                "content": "```\\nclass Solution {\\n\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        Arrays.fill(ans, -1);\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tPriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\twhile (!maxHeap.isEmpty()) {\\n\\t\\t\\t\\tif (nums[i] <= nums[maxHeap.peek()]) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// find second greater\\n\\t\\t\\t\\tans[maxHeap.peek()] = nums[i];\\n\\t\\t\\t\\tmaxHeap.poll();\\n\\t\\t\\t}\\n\\t\\t\\twhile (!stack.empty()) {\\n\\t\\t\\t\\tif (nums[i] <= nums[stack.peek()]) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// find first greater, add it PriorityQueue\\n\\t\\t\\t\\tmaxHeap.add(stack.peek());\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(i);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        Arrays.fill(ans, -1);\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tPriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\twhile (!maxHeap.isEmpty()) {\\n\\t\\t\\t\\tif (nums[i] <= nums[maxHeap.peek()]) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// find second greater\\n\\t\\t\\t\\tans[maxHeap.peek()] = nums[i];\\n\\t\\t\\t\\tmaxHeap.poll();\\n\\t\\t\\t}\\n\\t\\t\\twhile (!stack.empty()) {\\n\\t\\t\\t\\tif (nums[i] <= nums[stack.peek()]) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// find first greater, add it PriorityQueue\\n\\t\\t\\t\\tmaxHeap.add(stack.peek());\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(i);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757259,
                "title": "python3-intermediate-stack",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/a90ca3f9de0f99297262514c111f27700c24c04a) for solutions of biweekly 90. \\n\\n```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        ans = [-1] * len(nums)\\n        s, ss = [], []\\n        for i, x in enumerate(nums): \\n            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x\\n            buff = []\\n            while s and nums[s[-1]] < x: buff.append(s.pop())\\n            while buff: ss.append(buff.pop())\\n            s.append(i)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        ans = [-1] * len(nums)\\n        s, ss = [], []\\n        for i, x in enumerate(nums): \\n            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x\\n            buff = []\\n            while s and nums[s[-1]] < x: buff.append(s.pop())\\n            while buff: ss.append(buff.pop())\\n            s.append(i)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757176,
                "title": "weirdest-solution-you-can-find-stack-linear-search-in-order",
                "content": "x[i] is the list of indices for which arr[i] is the next greater element\\nx[i] is sorted in increasing order of arr[index], where index is an element of x[i]\\nfor every i, we calculate the next greater element of each x[i][index] after i, as x[i] is sorted, ans[x[i][index]] <= ans[x[i][index+1]] next greater element for a greater element can be the same as the answer for a smaller value or more\\n```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] arr) {\\n        List<Integer>[] x = nexGreater(arr.length, arr);\\n        int[] ans = new int[arr.length];\\n        Arrays.fill(ans, -1);\\n        for(int i = 0; i < x.length; i++) {\\n            if(x[i] == null) continue;\\n            int idx = 0, j = i+1;\\n            while(idx < x[i].size() && j < arr.length) {\\n                if(arr[j] > arr[x[i].get(idx)]) ans[x[i].get(idx++)] = arr[j];\\n                else j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    List<Integer>[] nexGreater(int n, int arr[]) {\\n        List<Integer>[] x = new List[n];\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            if (stack.isEmpty()) {\\n                stack.push(i);\\n                continue;\\n            }\\n            while (!stack.isEmpty() && arr[i] > arr[stack.peek()]) {\\n                if(x[i] == null) x[i] = new ArrayList<>();\\n                x[i].add(stack.pop());\\n            }\\n            stack.push(i);\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] arr) {\\n        List<Integer>[] x = nexGreater(arr.length, arr);\\n        int[] ans = new int[arr.length];\\n        Arrays.fill(ans, -1);\\n        for(int i = 0; i < x.length; i++) {\\n            if(x[i] == null) continue;\\n            int idx = 0, j = i+1;\\n            while(idx < x[i].size() && j < arr.length) {\\n                if(arr[j] > arr[x[i].get(idx)]) ans[x[i].get(idx++)] = arr[j];\\n                else j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    List<Integer>[] nexGreater(int n, int arr[]) {\\n        List<Integer>[] x = new List[n];\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            if (stack.isEmpty()) {\\n                stack.push(i);\\n                continue;\\n            }\\n            while (!stack.isEmpty() && arr[i] > arr[stack.peek()]) {\\n                if(x[i] == null) x[i] = new ArrayList<>();\\n                x[i].add(stack.pop());\\n            }\\n            stack.push(i);\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756794,
                "title": "video-explanation-with-first-principles",
                "content": "https://www.youtube.com/watch?v=eQ5GrfZch3Q",
                "solutionTags": [
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "https://www.youtube.com/watch?v=eQ5GrfZch3Q",
                "codeTag": "Unknown"
            },
            {
                "id": 2756683,
                "title": "python-heap",
                "content": "I created a min heap, to which tuples containing (nums[i], i) would be added. Also, use a dictionary to record the number of prior greater values we have found for each tuple. We need to iterate through the values in nums, each time checking whether the value is greater than the first element of the tuple at the top of the min heap. As long as the value is greater, we then update the dictionary value, and if this is the second time we have found a greater value, we put the value in the result list, res. If it is not the second time, we do need to pop the item from the heap, and then put it back on the heap after having checked the remaining qualifying values in the heap.\\n\\n```\\ndef secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        res = [-1 for i in range(len(nums))]\\n        d = {}\\n        for i in range(len(nums)):\\n            d[(nums[i], i)] = 0\\n        from heapq import heappush, heappop\\n        h = [] # add the number, plus its index, as tuple\\n        for i in range(len(nums)):\\n            addback = []\\n            while h:\\n                if nums[i] > h[0][0]:\\n                    if d[(h[0][0], h[0][1])] == 0:\\n                        d[(h[0][0], h[0][1])] += 1\\n                        addback.append([h[0][0], h[0][1]])\\n                        heappop(h)\\n                    elif d[(h[0][0], h[0][1])] == 1:\\n                        res[h[0][1]] = nums[i]\\n                        heappop(h)\\n                else:\\n                    break\\n            heappush(h, [nums[i], i])\\n            for k,l in addback:\\n                heappush(h, [k,l])\\n        return res\\n                ```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        res = [-1 for i in range(len(nums))]\\n        d = {}\\n        for i in range(len(nums)):\\n            d[(nums[i], i)] = 0\\n        from heapq import heappush, heappop\\n        h = [] # add the number, plus its index, as tuple\\n        for i in range(len(nums)):\\n            addback = []\\n            while h:\\n                if nums[i] > h[0][0]:\\n                    if d[(h[0][0], h[0][1])] == 0:\\n                        d[(h[0][0], h[0][1])] += 1\\n                        addback.append([h[0][0], h[0][1]])\\n                        heappop(h)\\n                    elif d[(h[0][0], h[0][1])] == 1:\\n                        res[h[0][1]] = nums[i]\\n                        heappop(h)\\n                else:\\n                    break\\n            heappush(h, [nums[i], i])\\n            for k,l in addback:\\n                heappush(h, [k,l])\\n        return res\\n                ```",
                "codeTag": "Python3"
            },
            {
                "id": 2756657,
                "title": "python-3-o-n-clean-two-stacks-with-comments",
                "content": "```\\nclass Solution:\\n  def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n    ans = [-1] * len(nums)\\n    # Decreasing stack that stores indices that already met the first greater num.\\n    prevStack = []\\n    # Decreasing stack that stores indices.\\n    currStack = []\\n\\n    for i, num in enumerate(nums):\\n      # Indices in prevStack meet second greater num.\\n      while prevStack and nums[prevStack[-1]] < num:\\n        ans[prevStack.pop()] = num\\n      # Push indices that meet the first greater num from currStack to prevStack.\\n      # We need a temp array to make indices in prevStack increasing.\\n      decreasingIndices = []\\n      while currStack and nums[currStack[-1]] < num:\\n        decreasingIndices.append(currStack.pop())\\n      for index in reversed(decreasingIndices):\\n        prevStack.append(index)\\n      currStack.append(i)\\n\\n    return ans\\n```\\n\\nSince each num is pushed/popped from `prevStack`, `currStack`, and `decreasingIndices` at most once, the time complexity is O(n).\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n  def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n    ans = [-1] * len(nums)\\n    # Decreasing stack that stores indices that already met the first greater num.\\n    prevStack = []\\n    # Decreasing stack that stores indices.\\n    currStack = []\\n\\n    for i, num in enumerate(nums):\\n      # Indices in prevStack meet second greater num.\\n      while prevStack and nums[prevStack[-1]] < num:\\n        ans[prevStack.pop()] = num\\n      # Push indices that meet the first greater num from currStack to prevStack.\\n      # We need a temp array to make indices in prevStack increasing.\\n      decreasingIndices = []\\n      while currStack and nums[currStack[-1]] < num:\\n        decreasingIndices.append(currStack.pop())\\n      for index in reversed(decreasingIndices):\\n        prevStack.append(index)\\n      currStack.append(i)\\n\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756626,
                "title": "c-simple-solution-using-stack-and-min-heap",
                "content": "The idea is to maintain a stack to get the first greater element. Once we get the first greater element for a number, we push it to the min-heap waiting to get the second greater element. For each number, we check if it is greater than the elements in the heap; if yes then the current number is the second greater element for that number.\\n\\n\\n```\\n vector<int> secondGreaterElement(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        vector<int> ans(n,-1);\\n        \\n        stack<pair<int,int>> st;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        \\n        for(int i=0;i<n;i++){\\n            int curr=nums[i];\\n            while(pq.size() && pq.top().first<curr){\\n                ans[pq.top().second]=curr;\\n                pq.pop();\\n            }\\n            \\n            while(st.size() && st.top().first<curr){\\n                pq.push(st.top());\\n                st.pop();\\n            }\\n            \\n            st.push({curr,i});\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\n vector<int> secondGreaterElement(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        vector<int> ans(n,-1);\\n        \\n        stack<pair<int,int>> st;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        \\n        for(int i=0;i<n;i++){\\n            int curr=nums[i];\\n            while(pq.size() && pq.top().first<curr){\\n                ans[pq.top().second]=curr;\\n                pq.pop();\\n            }\\n            \\n            while(st.size() && st.top().first<curr){\\n                pq.push(st.top());\\n                st.pop();\\n            }\\n            \\n            st.push({curr,i});\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756587,
                "title": "python-3-sortedlist-o-n-log-n",
                "content": "The idea is to process numbers in increasing order. For example: [3,2,2,4,0,9,6,6]\\nWe process from 0 -> 2 -> 3 -> 4 -> 6 -> 9:\\n* 0: remove its index set [4] -> SortedList([0, 1, 2, 3, 5, 6, 7]) -> binary search to find 2nd index greater than 4 -> 6\\n* 2: remove its index set [1, 2] -> SortedList([0, 3, 5, 6, 7]) -> binary search to find 2nd index greater than 1 -> 5, 2 -> 5 \\n* 3: remove its index set [0] -> SortedList([3, 5, 6, 7]) -> binary search to find 2nd index greater than 0 -> 5\\n* 4: remove its index set [3] -> SortedList([5, 6, 7]) -> binary search to find 2nd index greater than 3 -> 6\\n* 6: remove its index set [6, 7] -> SortedList([5]) -> binary search to find 2nd index greater than 6 -> -1, 7 -> -1\\n* 9: remove its index set [5] -> SortedList([]) -> binary search to find 2nd index greater than 5 -> -1\\n* So we get thet mapping {4: 6, 1: 9, 2: 9, 0: 9, 3: 6, 6: -1, 7: -1, 5: -1}, which means {nums[4]: 6, nums[1]: 9, ...}. We just need to return the mapping in order, i.e. {0: 9, 1: 9, 2: 9, 3: 6, 4: 6, 5:-1, 6:-1, 7:-1} -> [9, 9, 9, 6, 6, -1, -1, -1]\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        \\n        idx = defaultdict(list)\\n        for i, x in enumerate(nums):\\n            idx[x].append(i)\\n        \\n        r = SortedList(range(len(nums)))\\n        \\n        ans = {}\\n        for k in sorted(idx.keys()):\\n            for i in idx[k]:\\n                r.remove(i)\\n            for i in idx[k]:\\n                j = r.bisect_left(i) + 1\\n                if j < len(r):\\n                    ans[i] = nums[r[j]]\\n                else:\\n                    ans[i] = -1\\n        \\n        return [ans[i] for i in range(len(nums))]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        \\n        idx = defaultdict(list)\\n        for i, x in enumerate(nums):\\n            idx[x].append(i)\\n        \\n        r = SortedList(range(len(nums)))\\n        \\n        ans = {}\\n        for k in sorted(idx.keys()):\\n            for i in idx[k]:\\n                r.remove(i)\\n            for i in idx[k]:\\n                j = r.bisect_left(i) + 1\\n                if j < len(r):\\n                    ans[i] = nums[r[j]]\\n                else:\\n                    ans[i] = -1\\n        \\n        return [ans[i] for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756569,
                "title": "std-set-sorting-in-o-nlogn-c",
                "content": "**[Solution]**\\nLet\\'s simplify the statement first.\\n\\nThis problem can be reduced to finding the second greater index from subset of index S of which index-th element of nums is strictly greater than nums[i], for each i in range of [0, N), \\n\\nIf we iterate over an array based on preference of pair<int, int>{-nums[i], i},\\n\\nthis can be reduced to finding the second greater index from subset of index S of which index is previously iterated, for each pair<int, int>{-nums[i], i}.\\n\\n\\nThe problem get much simpler, and it can be easily implemented by using std::set and its module, upper_bound() twice!\\n\\nIf you use other languages which does not support the same kind of the std:: map data structure, it may be more difficult, though.\\n\\nAnyway, here\\'s my implementation in C++.\\n\\nTime : O(NlogN)\\nSpace: O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<pair<int, int>> arr(n);\\n        for (int i = 0; i < n; i++){\\n            arr[i] = {-nums[i], i};\\n        }\\n        sort(arr.begin(), arr.end());\\n        set<int> S;\\n        vector<int> ans(n, -1);\\n        for (auto & [_, idx] : arr){\\n            auto itr = S.upper_bound(idx);\\n            if (itr != S.end()){\\n                auto itr1 = S.upper_bound(*itr);\\n                if (itr1 != S.end()){\\n                    ans[idx] = nums[*itr1];\\n                }\\n            }\\n            S.insert(idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<pair<int, int>> arr(n);\\n        for (int i = 0; i < n; i++){\\n            arr[i] = {-nums[i], i};\\n        }\\n        sort(arr.begin(), arr.end());\\n        set<int> S;\\n        vector<int> ans(n, -1);\\n        for (auto & [_, idx] : arr){\\n            auto itr = S.upper_bound(idx);\\n            if (itr != S.end()){\\n                auto itr1 = S.upper_bound(*itr);\\n                if (itr1 != S.end()){\\n                    ans[idx] = nums[*itr1];\\n                }\\n            }\\n            S.insert(idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756529,
                "title": "c-modified-monotonic-stack-sorting-o-n-long-n",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> nextHighest(n, -1);\\n        \\n        vector<int> high;\\n        for(int i=n-1; i>=0; i--){\\n            int cur = nums[i];\\n            while(high.size() && nums[high.back()]<=nums[i]){\\n                high.pop_back();\\n            }\\n            if(high.size()){\\n                nextHighest[i] = high.back();\\n            }\\n            high.push_back(i);\\n        }\\n        \\n        vector<vector<int>> midVal(n, vector<int>());\\n        for(int i=0; i<n; i++){\\n            if(nextHighest[i]!=-1){\\n                midVal[nextHighest[i]].push_back(i);\\n            }\\n        }\\n        \\n        vector<int> ans(n, -1);\\n        vector<int> st;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            int cur = nums[i];\\n            vector<vector<int>> prev;\\n            for(int j=0; j<midVal[i].size(); j++){\\n                prev.push_back({nums[midVal[i][j]], midVal[i][j]});\\n            }\\n            \\n            sort(prev.begin(), prev.end());\\n            \\n            for(auto item:prev){\\n                while(st.size() && item[0]>=st.back()){\\n                    st.pop_back();\\n                }\\n                if(st.size()){\\n                    ans[item[1]] = st.back();\\n                }\\n            }\\n            while(st.size() && cur>=st.back()){\\n                st.pop_back();\\n            }\\n            \\n            st.push_back(nums[i]);\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> nextHighest(n, -1);\\n        \\n        vector<int> high;\\n        for(int i=n-1; i>=0; i--){\\n            int cur = nums[i];\\n            while(high.size() && nums[high.back()]<=nums[i]){\\n                high.pop_back();\\n            }\\n            if(high.size()){\\n                nextHighest[i] = high.back();\\n            }\\n            high.push_back(i);\\n        }\\n        \\n        vector<vector<int>> midVal(n, vector<int>());\\n        for(int i=0; i<n; i++){\\n            if(nextHighest[i]!=-1){\\n                midVal[nextHighest[i]].push_back(i);\\n            }\\n        }\\n        \\n        vector<int> ans(n, -1);\\n        vector<int> st;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            int cur = nums[i];\\n            vector<vector<int>> prev;\\n            for(int j=0; j<midVal[i].size(); j++){\\n                prev.push_back({nums[midVal[i][j]], midVal[i][j]});\\n            }\\n            \\n            sort(prev.begin(), prev.end());\\n            \\n            for(auto item:prev){\\n                while(st.size() && item[0]>=st.back()){\\n                    st.pop_back();\\n                }\\n                if(st.size()){\\n                    ans[item[1]] = st.back();\\n                }\\n            }\\n            while(st.size() && cur>=st.back()){\\n                st.pop_back();\\n            }\\n            \\n            st.push_back(nums[i]);\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756479,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        unordered_map<int,int>Parent;\\n        stack<int>s;\\n        vector<int>ans(nums.size(),-1);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(s.empty()||nums[s.top()]>=nums[i])\\n            {\\n                s.push(i);\\n            }\\n            else\\n            {\\n               while(!s.empty() and nums[s.top()]<nums[i])\\n               {\\n                   ans[s.top()] = i;\\n                   s.pop();\\n               }\\n                s.push(i);\\n            }\\n        }\\n        vector<int>store(nums.size(),-1);\\n        priority_queue<pair<pair<int,int>,int>,vector<pair<pair<int,int>,int>>,greater<pair<pair<int,int>,int>>>pq,pq1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            while(!pq.empty() and nums[pq.top().first.second]<nums[i])\\n            {\\n                if(pq.top().second==i)\\n                {\\n                    pq1.push(pq.top());\\n                    pq.pop();\\n                }\\n                else\\n                {\\n                    store[pq.top().first.second] = nums[i];\\n                    pq.pop();\\n                }\\n            }\\n            if(ans[i]!=-1)\\n            pq.push({{nums[i],i},ans[i]});\\n            while(!pq1.empty())\\n            {\\n                pq.push(pq1.top());\\n                pq1.pop();\\n            }\\n        }\\n        \\n        return store;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        unordered_map<int,int>Parent;\\n        stack<int>s;\\n        vector<int>ans(nums.size(),-1);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(s.empty()||nums[s.top()]>=nums[i])\\n            {\\n                s.push(i);\\n            }\\n            else\\n            {\\n               while(!s.empty() and nums[s.top()]<nums[i])\\n               {\\n                   ans[s.top()] = i;\\n                   s.pop();\\n               }\\n                s.push(i);\\n            }\\n        }\\n        vector<int>store(nums.size(),-1);\\n        priority_queue<pair<pair<int,int>,int>,vector<pair<pair<int,int>,int>>,greater<pair<pair<int,int>,int>>>pq,pq1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            while(!pq.empty() and nums[pq.top().first.second]<nums[i])\\n            {\\n                if(pq.top().second==i)\\n                {\\n                    pq1.push(pq.top());\\n                    pq.pop();\\n                }\\n                else\\n                {\\n                    store[pq.top().first.second] = nums[i];\\n                    pq.pop();\\n                }\\n            }\\n            if(ans[i]!=-1)\\n            pq.push({{nums[i],i},ans[i]});\\n            while(!pq1.empty())\\n            {\\n                pq.push(pq1.top());\\n                pq1.pop();\\n            }\\n        }\\n        \\n        return store;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756477,
                "title": "java-monostack-priorityqueue",
                "content": "\\tpublic static int[] secondGreaterElement(int[] nums) {\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tPriorityQueue<Integer> candidates = new PriorityQueue<>(Comparator.comparingInt(i -> nums[i]));\\n\\t\\tint n = nums.length;\\n\\t\\tint[] res = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint num = nums[i];\\n\\t\\t\\t// a candidate found a greater element again\\n\\t\\t\\twhile (!candidates.isEmpty() && num > nums[candidates.peek()]) {\\n\\t\\t\\t\\tres[candidates.poll()] = num;\\n\\t\\t\\t}\\n\\t\\t\\t// found first greater element, select it as a candidate\\n\\t\\t\\twhile (!stack.isEmpty() && num > nums[stack.peek()]) {\\n\\t\\t\\t\\tcandidates.offer(stack.pop());\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(i);\\n\\t\\t}\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tres[stack.pop()] = -1;\\n\\t\\t}\\n\\t\\twhile (!candidates.isEmpty()) {\\n\\t\\t\\tres[candidates.poll()] = -1;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "\\tpublic static int[] secondGreaterElement(int[] nums) {\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tPriorityQueue<Integer> candidates = new PriorityQueue<>(Comparator.comparingInt(i -> nums[i]));\\n\\t\\tint n = nums.length;\\n\\t\\tint[] res = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint num = nums[i];\\n\\t\\t\\t// a candidate found a greater element again\\n\\t\\t\\twhile (!candidates.isEmpty() && num > nums[candidates.peek()]) {\\n\\t\\t\\t\\tres[candidates.poll()] = num;\\n\\t\\t\\t}\\n\\t\\t\\t// found first greater element, select it as a candidate\\n\\t\\t\\twhile (!stack.isEmpty() && num > nums[stack.peek()]) {\\n\\t\\t\\t\\tcandidates.offer(stack.pop());\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(i);\\n\\t\\t}\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tres[stack.pop()] = -1;\\n\\t\\t}\\n\\t\\twhile (!candidates.isEmpty()) {\\n\\t\\t\\tres[candidates.poll()] = -1;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2756377,
                "title": "java-treemap",
                "content": "* Maintain sorted map with all numbers that do not have two greater elements yet\\n* Iterate through all number\\n\\t* For current element: get subMap with all the numbers with lower value that we have already seen and have not found two greater elements\\n\\t* Remove numbers from the map with two greater elements\\n\\t* Put current number into the map\\n\\n```\\npublic int[] secondGreaterElement(int[] nums) {\\n\\tvar res = new int[nums.length];\\n\\tArrays.fill(res, -1);\\n\\n\\t// < val, { index, count } >\\n\\tvar m = new TreeMap<Integer, List<int[]>>();\\n\\tfor (int i = 0; i < res.length; i++) {\\n\\t\\t// get all numbers with lower value that we have already seen and have not found two greater elements \\n\\t\\tvar sub = new TreeMap<>(m.subMap(0, nums[i]));\\n\\n\\t\\tfor (var e : sub.entrySet()) {\\n\\t\\t\\tvar newList = new ArrayList<int[]>();\\n\\t\\t\\tfor (var v : e.getValue()) {\\n\\t\\t\\t\\tif (v[1] == 1) {\\n\\t\\t\\t\\t\\tres[v[0]] = nums[i];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tv[1] = 1;\\n\\t\\t\\t\\t\\tnewList.add(v);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (newList.size() == 0) {\\n\\t\\t\\t\\t// clean up to reduce time complexity\\n\\t\\t\\t\\tm.remove(e.getKey());\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// put back list of numbers with one greater element \\n\\t\\t\\t\\tm.put(e.getKey(), newList);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// put current number\\n\\t\\tm.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(new int[] { i, 0 });\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] secondGreaterElement(int[] nums) {\\n\\tvar res = new int[nums.length];\\n\\tArrays.fill(res, -1);\\n\\n\\t// < val, { index, count } >\\n\\tvar m = new TreeMap<Integer, List<int[]>>();\\n\\tfor (int i = 0; i < res.length; i++) {\\n\\t\\t// get all numbers with lower value that we have already seen and have not found two greater elements \\n\\t\\tvar sub = new TreeMap<>(m.subMap(0, nums[i]));\\n\\n\\t\\tfor (var e : sub.entrySet()) {\\n\\t\\t\\tvar newList = new ArrayList<int[]>();\\n\\t\\t\\tfor (var v : e.getValue()) {\\n\\t\\t\\t\\tif (v[1] == 1) {\\n\\t\\t\\t\\t\\tres[v[0]] = nums[i];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tv[1] = 1;\\n\\t\\t\\t\\t\\tnewList.add(v);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (newList.size() == 0) {\\n\\t\\t\\t\\t// clean up to reduce time complexity\\n\\t\\t\\t\\tm.remove(e.getKey());\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// put back list of numbers with one greater element \\n\\t\\t\\t\\tm.put(e.getKey(), newList);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// put current number\\n\\t\\tm.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(new int[] { i, 0 });\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756362,
                "title": "c-clean-and-simple-solution-o-nlogn",
                "content": "Here, we use 2 priority queues-pq and pq1.\\npq contains all the element for which there are no greater element yet.\\npq1 contains all the elements for which one greater element has been found.\\nWe iterate the nums array and update both pq and pq1 accordingly,code is easy to understand.\\nTime complexity - O(nlogn)\\nSpace complexity -O(n).\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans(n,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq,pq1;\\n        for(int i=0;i<n;i++) ans[i]=-1;\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            while(!pq1.empty()){\\n                auto p=pq1.top();\\n                if(p.first>=x) break;\\n                pq1.pop();\\n                ans[p.second]=x;\\n            }\\n            while(!pq.empty()){\\n                auto p=pq.top();\\n                if(p.first>=x) break;\\n                pq.pop(); pq1.push(p);\\n            }\\n            pq.push({x,i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans(n,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq,pq1;\\n        for(int i=0;i<n;i++) ans[i]=-1;\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            while(!pq1.empty()){\\n                auto p=pq1.top();\\n                if(p.first>=x) break;\\n                pq1.pop();\\n                ans[p.second]=x;\\n            }\\n            while(!pq.empty()){\\n                auto p=pq.top();\\n                if(p.first>=x) break;\\n                pq.pop(); pq1.push(p);\\n            }\\n            pq.push({x,i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091487,
                "title": "using-2-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int>s1;\\n        stack<int>s2;\\n        stack<int>temp;\\n        vector<int>ans(n,-1);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s2.empty() && nums[s2.top()]< nums[i])\\n            {\\n                ans[s2.top()] = nums[i];\\n                s2.pop();\\n            }\\n\\n            while(!s1.empty() && nums[s1.top()]< nums[i])\\n            {\\n                temp.push(s1.top());\\n                s1.pop();\\n            }\\n\\n            while(!temp.empty())\\n            {\\n                s2.push(temp.top());\\n                temp.pop();\\n\\n            }\\n            s1.push(i);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int>s1;\\n        stack<int>s2;\\n        stack<int>temp;\\n        vector<int>ans(n,-1);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!s2.empty() && nums[s2.top()]< nums[i])\\n            {\\n                ans[s2.top()] = nums[i];\\n                s2.pop();\\n            }\\n\\n            while(!s1.empty() && nums[s1.top()]< nums[i])\\n            {\\n                temp.push(s1.top());\\n                s1.pop();\\n            }\\n\\n            while(!temp.empty())\\n            {\\n                s2.push(temp.top());\\n                temp.pop();\\n\\n            }\\n            s1.push(i);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956523,
                "title": "using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        //two stack liye ,ek me traverse karte un elements ko store kiye jo bara  hai ,baad me -1 \\n        ///dusre me un sabko jo kisi ek se chote hai ,check karenge agar 2 gua toh ans wale stack me add ,varna ye bi -1.\\n        //Elements in stack 1 s1: elements that we have iterated over previously.\\n/*Elements in stack 2 s2: elements that we have iterated over previosuly and there is one element greater than them.\\n\\nIf curr element is greater than the top of the second stack, we found a solution for the element on the top of the stack.\\n\\nIf curr element is greater than the top of the first stack, we remove that element and push it into the second stack.*/\\n     Stack<Integer> s1 = new Stack<>(), s2 = new Stack<>();\\n        int[] ans = new int[nums.length];\\n        for (int i = 0; i < nums.length; i += 1) {\\n            while (!s2.isEmpty() && nums[i] > nums[s2.peek()]) {\\n                int idx = s2.pop();\\n                ans[idx] = nums[i];\\n            }\\n            \\n            Stack<Integer> s = new Stack<>();\\n            while (!s1.isEmpty() && nums[i] > nums[s1.peek()]) {\\n                s.push(s1.pop());\\n            }\\n            \\n            while (!s.isEmpty()) {\\n                s2.push(s.pop());\\n            }\\n            \\n            s1.push(i);\\n        }\\n        \\n        while (!s1.isEmpty()) {\\n            ans[s1.pop()] = -1;\\n        }\\n        \\n        while (!s2.isEmpty()) {\\n            ans[s2.pop()] = -1;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        //two stack liye ,ek me traverse karte un elements ko store kiye jo bara  hai ,baad me -1 \\n        ///dusre me un sabko jo kisi ek se chote hai ,check karenge agar 2 gua toh ans wale stack me add ,varna ye bi -1.\\n        //Elements in stack 1 s1: elements that we have iterated over previously.\\n/*Elements in stack 2 s2: elements that we have iterated over previosuly and there is one element greater than them.\\n\\nIf curr element is greater than the top of the second stack, we found a solution for the element on the top of the stack.\\n\\nIf curr element is greater than the top of the first stack, we remove that element and push it into the second stack.*/\\n     Stack<Integer> s1 = new Stack<>(), s2 = new Stack<>();\\n        int[] ans = new int[nums.length];\\n        for (int i = 0; i < nums.length; i += 1) {\\n            while (!s2.isEmpty() && nums[i] > nums[s2.peek()]) {\\n                int idx = s2.pop();\\n                ans[idx] = nums[i];\\n            }\\n            \\n            Stack<Integer> s = new Stack<>();\\n            while (!s1.isEmpty() && nums[i] > nums[s1.peek()]) {\\n                s.push(s1.pop());\\n            }\\n            \\n            while (!s.isEmpty()) {\\n                s2.push(s.pop());\\n            }\\n            \\n            s1.push(i);\\n        }\\n        \\n        while (!s1.isEmpty()) {\\n            ans[s1.pop()] = -1;\\n        }\\n        \\n        while (!s2.isEmpty()) {\\n            ans[s2.pop()] = -1;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932632,
                "title": "c-stack-segment-tree-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n*log^2n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> a;\\n    vector<int> seg;\\n\\n    void build(int node,int lo,int hi){\\n        if(lo == hi){\\n            seg[node] = a[lo];\\n            return ;\\n        }\\n        int mid = lo + (hi-lo)/2;\\n        build(2*node+1,lo,mid);\\n        build(2*node+2,mid+1,hi);\\n        seg[node] = max(seg[2*node+1],seg[2*node+2]);\\n    }\\n\\n    int query(int node,int lo,int hi,int l,int r){\\n        if(lo>=l && hi<=r){\\n            return seg[node];\\n        }\\n        if(hi<l || lo>r){\\n            return 0;\\n        }\\n        int mid = lo + (hi-lo)/2;\\n        int left = query(2*node+1,lo,mid,l,r);\\n        int right = query(2*node+2,mid+1,hi,l,r);\\n        return max(left,right);\\n    }\\n\\n    // l,r tumhare inputs hain;\\n\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        a.clear();\\n        a.resize(n);\\n        seg.clear();\\n        seg.resize(4 * n);\\n        int nextG[n];\\n        stack<int> stk;\\n        nextG[n - 1] = n;\\n        stk.push(n - 1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            while(stk.size() && nums[i] >= nums[stk.top()])\\n            {\\n                stk.pop();\\n            }\\n            if(stk.size())nextG[i] = stk.top();\\n            else nextG[i] = n;\\n            stk.push(i);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i] = nums[i];\\n        }\\n        build(0,0,n - 1);\\n        vector<int> answer(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int lo = nextG[i] + 1, hi = n - 1;\\n            int ans = -1;\\n            while(lo <= hi)\\n            {\\n                int mid = (lo + hi) >> 1;\\n                int q = query(0,0,n - 1,nextG[i] + 1,mid);\\n                if(q > nums[i])\\n                {\\n                    ans = mid;\\n                    hi = mid - 1;\\n                }\\n                else\\n                {\\n                    lo = mid + 1;\\n                }\\n            }\\n            if(ans == -1)\\n            answer[i] = -1;\\n            else\\n            answer[i] = nums[ans];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> a;\\n    vector<int> seg;\\n\\n    void build(int node,int lo,int hi){\\n        if(lo == hi){\\n            seg[node] = a[lo];\\n            return ;\\n        }\\n        int mid = lo + (hi-lo)/2;\\n        build(2*node+1,lo,mid);\\n        build(2*node+2,mid+1,hi);\\n        seg[node] = max(seg[2*node+1],seg[2*node+2]);\\n    }\\n\\n    int query(int node,int lo,int hi,int l,int r){\\n        if(lo>=l && hi<=r){\\n            return seg[node];\\n        }\\n        if(hi<l || lo>r){\\n            return 0;\\n        }\\n        int mid = lo + (hi-lo)/2;\\n        int left = query(2*node+1,lo,mid,l,r);\\n        int right = query(2*node+2,mid+1,hi,l,r);\\n        return max(left,right);\\n    }\\n\\n    // l,r tumhare inputs hain;\\n\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        a.clear();\\n        a.resize(n);\\n        seg.clear();\\n        seg.resize(4 * n);\\n        int nextG[n];\\n        stack<int> stk;\\n        nextG[n - 1] = n;\\n        stk.push(n - 1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            while(stk.size() && nums[i] >= nums[stk.top()])\\n            {\\n                stk.pop();\\n            }\\n            if(stk.size())nextG[i] = stk.top();\\n            else nextG[i] = n;\\n            stk.push(i);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            a[i] = nums[i];\\n        }\\n        build(0,0,n - 1);\\n        vector<int> answer(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int lo = nextG[i] + 1, hi = n - 1;\\n            int ans = -1;\\n            while(lo <= hi)\\n            {\\n                int mid = (lo + hi) >> 1;\\n                int q = query(0,0,n - 1,nextG[i] + 1,mid);\\n                if(q > nums[i])\\n                {\\n                    ans = mid;\\n                    hi = mid - 1;\\n                }\\n                else\\n                {\\n                    lo = mid + 1;\\n                }\\n            }\\n            if(ans == -1)\\n            answer[i] = -1;\\n            else\\n            answer[i] = nums[ans];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892840,
                "title": "python-solution-using-o-n-and-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        stack=[]\\n        ans=[-1 for _ in range(len(nums))]\\n        for i in range(len(nums)):\\n            res=[]\\n            while(len(stack)!=0 and nums[stack[-1][0]]<nums[i]):\\n                t=stack.pop()\\n                if(t[1]==1):\\n                    ans[t[0]]=nums[i]\\n                else:\\n                    t[1]+=1\\n                    res.append(t)\\n            stack.append([i,0])\\n            stack+=res[::-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        stack=[]\\n        ans=[-1 for _ in range(len(nums))]\\n        for i in range(len(nums)):\\n            res=[]\\n            while(len(stack)!=0 and nums[stack[-1][0]]<nums[i]):\\n                t=stack.pop()\\n                if(t[1]==1):\\n                    ans[t[0]]=nums[i]\\n                else:\\n                    t[1]+=1\\n                    res.append(t)\\n            stack.append([i,0])\\n            stack+=res[::-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861836,
                "title": "one-pass-solution-with-using-2-main-and-1-temporary-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n time O(N) as each no will be process max 2 time so push and pop in stack will not change time complexity of O(N), \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace -> O(3N) = O(N)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar secondGreaterElement = function(nums) {\\n    let stack1 = [], stack2 = [];\\n    let peek = (no) => {\\n        if(no == 1)\\n            return nums[stack1[stack1.length - 1]];\\n        return nums[stack2[stack2.length - 1]];\\n    }  \\n    let result = new Array(nums.length).fill(-1);\\n    for(let i = 0; i < nums.length; i++){\\n        while(stack2.length && peek(2) < nums[i]){\\n            result[stack2.pop()] = nums[i];\\n        }\\n        // this is require to store the value in increasing order so that the min value get processs. Otherwise min value will be blocked by a greater value in stack2. \\n        let tempStack = [];\\n        while(stack1.length && peek(1) < nums[i]){\\n            tempStack.push(stack1.pop());\\n        }\\n        while(tempStack.length) stack2.push(tempStack.pop());\\n        stack1.push(i);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar secondGreaterElement = function(nums) {\\n    let stack1 = [], stack2 = [];\\n    let peek = (no) => {\\n        if(no == 1)\\n            return nums[stack1[stack1.length - 1]];\\n        return nums[stack2[stack2.length - 1]];\\n    }  \\n    let result = new Array(nums.length).fill(-1);\\n    for(let i = 0; i < nums.length; i++){\\n        while(stack2.length && peek(2) < nums[i]){\\n            result[stack2.pop()] = nums[i];\\n        }\\n        // this is require to store the value in increasing order so that the min value get processs. Otherwise min value will be blocked by a greater value in stack2. \\n        let tempStack = [];\\n        while(stack1.length && peek(1) < nums[i]){\\n            tempStack.push(stack1.pop());\\n        }\\n        while(tempStack.length) stack2.push(tempStack.pop());\\n        stack1.push(i);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821123,
                "title": "binary-search-on-sparse-table",
                "content": "```\\nclass SparseTable:\\n    def __init__(self, arr, func, init):\\n        self.func = func\\n        self.init = init\\n        n = len(arr)\\n        k = n.bit_length()\\n        table = [[self.init] * k for _ in range(n)]\\n        self.mpow = [(0, 1)] * (n + 1)\\n        l = 0\\n        p = 1\\n        for i in range(1, n + 1):\\n            if p * 2 <= i:\\n                l += 1\\n                p *= 2\\n            self.mpow[i] = (l, p)\\n        for l in range(k):\\n            for i in range(n):\\n                if l == 0:\\n                    table[i][l] = arr[i]\\n                else:\\n                    a = table[i][l - 1]\\n                    b = self.init\\n                    if i + (1 << l - 1) < n:\\n                        b = table[i + (1 << l - 1)][l - 1]\\n                    table[i][l] = self.func(a, b)\\n        self.table = table\\n\\n    def query(self, l, r):\\n        i, p = self.mpow[r - l + 1]\\n        return self.func(self.table[l][i], self.table[r - p + 1][i])\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        sp = SparseTable(nums, func = max, init = float(\\'-inf\\'))\\n        s = []\\n        res = [-1] * n\\n        for i in range(n):\\n            while len(s) > 0 and nums[s[-1]] < nums[i]:\\n                curr = s.pop()\\n                if i + 1 >= n:\\n                    continue\\n                beg = i + 1\\n                end = n - 1\\n                while beg <= end:\\n                    mid = (beg + end) // 2\\n                    if sp.query(i + 1, mid) > nums[curr]:\\n                        res[curr] = nums[mid]\\n                        end = mid - 1\\n                    else:\\n                        beg = mid + 1\\n            s.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass SparseTable:\\n    def __init__(self, arr, func, init):\\n        self.func = func\\n        self.init = init\\n        n = len(arr)\\n        k = n.bit_length()\\n        table = [[self.init] * k for _ in range(n)]\\n        self.mpow = [(0, 1)] * (n + 1)\\n        l = 0\\n        p = 1\\n        for i in range(1, n + 1):\\n            if p * 2 <= i:\\n                l += 1\\n                p *= 2\\n            self.mpow[i] = (l, p)\\n        for l in range(k):\\n            for i in range(n):\\n                if l == 0:\\n                    table[i][l] = arr[i]\\n                else:\\n                    a = table[i][l - 1]\\n                    b = self.init\\n                    if i + (1 << l - 1) < n:\\n                        b = table[i + (1 << l - 1)][l - 1]\\n                    table[i][l] = self.func(a, b)\\n        self.table = table\\n\\n    def query(self, l, r):\\n        i, p = self.mpow[r - l + 1]\\n        return self.func(self.table[l][i], self.table[r - p + 1][i])\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        sp = SparseTable(nums, func = max, init = float(\\'-inf\\'))\\n        s = []\\n        res = [-1] * n\\n        for i in range(n):\\n            while len(s) > 0 and nums[s[-1]] < nums[i]:\\n                curr = s.pop()\\n                if i + 1 >= n:\\n                    continue\\n                beg = i + 1\\n                end = n - 1\\n                while beg <= end:\\n                    mid = (beg + end) // 2\\n                    if sp.query(i + 1, mid) > nums[curr]:\\n                        res[curr] = nums[mid]\\n                        end = mid - 1\\n                    else:\\n                        beg = mid + 1\\n            s.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537975,
                "title": "python-o-n-use-two-monotonic-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the question asked next biggest element, an intuitive solution would be to use a monotonic stack. But, the quesiton is asking the \"second\" biggest element, so it might be worthwhile to explore the use of a second stack. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst stack is used for things that haven\\'t seen the next greater element yet. Once an element has seen the next biggest element, it is moved to the second stack. When we traverse the list, we first compare the new element against the second stack and pop things off and update the result array. Then, we compare against the first stack. For this, we also need to store the indices to know what index/element to update.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) as each element is compared a constant number of times as we have two stacks. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        firstStack = []\\n        secondStack = []\\n        n = len(nums)\\n        res = [-1] * n\\n        for index, x in enumerate(nums):\\n            acc = []\\n            while secondStack and x > secondStack[-1][0]:\\n                resX, resI = secondStack.pop()\\n                res[resI] = x\\n            while firstStack and x > firstStack[-1][0]:\\n                acc.append(firstStack.pop())\\n            for ac in acc[::-1]:\\n                secondStack.append(ac)\\n            firstStack.append((x, index))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        firstStack = []\\n        secondStack = []\\n        n = len(nums)\\n        res = [-1] * n\\n        for index, x in enumerate(nums):\\n            acc = []\\n            while secondStack and x > secondStack[-1][0]:\\n                resX, resI = secondStack.pop()\\n                res[resI] = x\\n            while firstStack and x > firstStack[-1][0]:\\n                acc.append(firstStack.pop())\\n            for ac in acc[::-1]:\\n                secondStack.append(ac)\\n            firstStack.append((x, index))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492286,
                "title": "c-monotonic-stack",
                "content": "```\\npublic class Solution {\\n    public int[] SecondGreaterElement(int[] nums) {\\n        Stack<int> st1=new Stack<int>();\\n        Stack<int> st2=new Stack<int>();\\n        int n= nums.Length;\\n        int[] res = Enumerable.Repeat(-1,n).ToArray();\\n        \\n        for(int i=0;i<n;i++){\\n            while(st2.Count>0 && nums[st2.Peek()]<nums[i])\\n                res[st2.Pop()]=nums[i];\\n            Stack<int> st3=new Stack<int>();\\n            \\n            while(st1.Count>0 && nums[st1.Peek()]<nums[i])\\n                st3.Push(st1.Pop());\\n            \\n            while(st3.Count>0)\\n                st2.Push(st3.Pop());\\n\\n            st1.Push(i);\\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] SecondGreaterElement(int[] nums) {\\n        Stack<int> st1=new Stack<int>();\\n        Stack<int> st2=new Stack<int>();\\n        int n= nums.Length;\\n        int[] res = Enumerable.Repeat(-1,n).ToArray();\\n        \\n        for(int i=0;i<n;i++){\\n            while(st2.Count>0 && nums[st2.Peek()]<nums[i])\\n                res[st2.Pop()]=nums[i];\\n            Stack<int> st3=new Stack<int>();\\n            \\n            while(st1.Count>0 && nums[st1.Peek()]<nums[i])\\n                st3.Push(st1.Pop());\\n            \\n            while(st3.Count>0)\\n                st2.Push(st3.Pop());\\n\\n            st1.Push(i);\\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477943,
                "title": "very-easy-solution-with-vector-an-set-in-o-n-time-complexity",
                "content": "# Intuition\\nJust first do same thing as you do for finding first nearest largest element but the only difference is instead of keeping the smallest element in stack to your answer array just put it into a set and for every iteration just try to find the element present in set which is smaller than our current element and just put that element to our ans array.\\n\\n# Approach\\nJust first do same thing as you do for finding first nearest largest element but the only difference is instead of keeping the smallest element in stack to your answer array just put it into a set and for every iteration just try to find the element present in set which is smaller than our current element and just put that element to our ans array.\\n\\n# Complexity\\n- Time complexity:\\nO(N*log(N))\\n\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& a) {\\n            int n = a.size();\\n          set<pair<int,int>>lst;\\n          vector<pair<int,int>>st;\\n          vector<int>ans(n,-1);\\n          for(int i=0;i<n;i++)\\n          {\\n                while(lst.size())\\n                     {\\n                        auto it = lst.begin();\\n                        if((it->first)>=a[i])\\n                        break;\\n                        else\\n                        {\\n                                ans[it->second]=a[i];\\n                                lst.erase(it);\\n                        }\\n                     }\\n\\n                     while(st.size()){\\n                     if(st[st.size()-1].first>=a[i])\\n                     break;\\n                     lst.insert(st[st.size()-1]);\\n                     st.pop_back();\\n                     }\\n                     st.push_back({a[i],i});\\n                     \\n          }\\n          return ans;  \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& a) {\\n            int n = a.size();\\n          set<pair<int,int>>lst;\\n          vector<pair<int,int>>st;\\n          vector<int>ans(n,-1);\\n          for(int i=0;i<n;i++)\\n          {\\n                while(lst.size())\\n                     {\\n                        auto it = lst.begin();\\n                        if((it->first)>=a[i])\\n                        break;\\n                        else\\n                        {\\n                                ans[it->second]=a[i];\\n                                lst.erase(it);\\n                        }\\n                     }\\n\\n                     while(st.size()){\\n                     if(st[st.size()-1].first>=a[i])\\n                     break;\\n                     lst.insert(st[st.size()-1]);\\n                     st.pop_back();\\n                     }\\n                     st.push_back({a[i],i});\\n                     \\n          }\\n          return ans;  \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466318,
                "title": "similar-to-next-greater-element-ii-using-stack-and-priority-queue-faster-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly solve the next greater element using decreasing stack.\\nfrom left to right\\n\\n# Approach\\nWe are storing elements in decreasing order in stack if new element is greater than the top element of stack we are removing it from the stack and inserting it in the priority queue which means that these element have one greater element.\\nBefore doing the above operation we check the element which have one greater element present in priority queue is greater than current element than it is the second greater element of that index so we will mark it and remove it from priority_queue.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(2n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        //jai shri ram\\n        stack<int>st1;\\n        using pi=pair<int,int>;\\n        priority_queue<pi,vector<pi>,greater<pi>>st2;\\n        int n=nums.size();\\n        vector<int>ans(n,-1);\\n        st1.push(0);\\n        for(int i=1;i<n;i++){\\n            while(st2.size()>0 && st2.top().first<nums[i]){\\n                ans[st2.top().second]=nums[i];\\n                st2.pop();\\n            }\\n            while(st1.size()>0 && nums[st1.top()]<nums[i]){\\n                st2.push({nums[st1.top()],st1.top()});\\n                st1.pop();\\n            }\\n            st1.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Heap (Priority Queue)",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        //jai shri ram\\n        stack<int>st1;\\n        using pi=pair<int,int>;\\n        priority_queue<pi,vector<pi>,greater<pi>>st2;\\n        int n=nums.size();\\n        vector<int>ans(n,-1);\\n        st1.push(0);\\n        for(int i=1;i<n;i++){\\n            while(st2.size()>0 && st2.top().first<nums[i]){\\n                ans[st2.top().second]=nums[i];\\n                st2.pop();\\n            }\\n            while(st1.size()>0 && nums[st1.top()]<nums[i]){\\n                st2.push({nums[st1.top()],st1.top()});\\n                st1.pop();\\n            }\\n            st1.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228014,
                "title": "o-nlogn-using-sparse-table-bs-on-indexes-python-cooler",
                "content": "# Intuition\\nvery good\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(NLOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SparseTable():\\n\\tdef __init__(self, n, data):\\n\\t\\tself.n = n\\n\\t\\tself.k = floor(log2(n))\\n\\t\\tself.table = [[0] * (self.k + 1) for i in range(n)]\\n\\t\\tself.data = data\\n\\t\\tself.log=[0]*(self.n+100)\\n\\n\\n\\tdef RMQ_build(self):\\n\\t\\tfor i in range(0, self.n):\\n\\t\\t\\tself.table[i][0] = self.data[i]\\n\\t\\tfor j in range(1, self.k + 1):\\n\\t\\t\\ti = 0\\n\\t\\t\\twhile i + (1 << j) <= self.n:\\n\\t\\t\\t\\tself.table[i][j] = max(self.table[i][j - 1], self.table[i + (1 << (j - 1))][j - 1])\\n\\t\\t\\t\\ti += 1\\n\\t\\tfor i in range(2,self.n+100):\\n\\t\\t\\tself.log[i]=self.log[i//2]+1\\n\\n\\tdef RMQ_Q(self, l, r):  # 0 indexing l r please [l,r]\\n\\t\\tj = self.log[r-l+1]\\n\\t\\treturn max(self.table[l][j], self.table[r - (1 << j) + 1][j])\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        # st=SegmentTree(nums)\\n        n=len(nums)\\n        st=SparseTable(n,nums)\\n        st.RMQ_build()\\n\\n        ans=[-1]*n\\n        res=defaultdict(int)\\n        for id,i in enumerate(nums):\\n            if res[i]==-1:\\n                continue\\n            lo=id+1\\n            hi=n-1\\n            mx1=-1\\n            while lo<=hi:\\n                mid=(lo+hi)//2\\n                if st.RMQ_Q(id+1,mid)>i:\\n                    hi=mid-1\\n                    mx1=mid\\n                else:\\n                    lo=mid+1\\n            if mx1==-1 or mx1+1==n:\\n                res[i]=-1\\n                continue\\n            lo=mx1+1\\n            hi=n-1\\n            mx2=-1\\n            while lo<=hi:\\n                mid=(lo+hi)//2\\n                if st.RMQ_Q(mx1+1,mid)>i:\\n                    hi=mid-1\\n                    mx2=mid\\n                else:\\n                    lo=mid+1\\n            if mx2!=-1:\\n                ans[id]=nums[mx2]\\n            else:\\n                res[i]=-1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SparseTable():\\n\\tdef __init__(self, n, data):\\n\\t\\tself.n = n\\n\\t\\tself.k = floor(log2(n))\\n\\t\\tself.table = [[0] * (self.k + 1) for i in range(n)]\\n\\t\\tself.data = data\\n\\t\\tself.log=[0]*(self.n+100)\\n\\n\\n\\tdef RMQ_build(self):\\n\\t\\tfor i in range(0, self.n):\\n\\t\\t\\tself.table[i][0] = self.data[i]\\n\\t\\tfor j in range(1, self.k + 1):\\n\\t\\t\\ti = 0\\n\\t\\t\\twhile i + (1 << j) <= self.n:\\n\\t\\t\\t\\tself.table[i][j] = max(self.table[i][j - 1], self.table[i + (1 << (j - 1))][j - 1])\\n\\t\\t\\t\\ti += 1\\n\\t\\tfor i in range(2,self.n+100):\\n\\t\\t\\tself.log[i]=self.log[i//2]+1\\n\\n\\tdef RMQ_Q(self, l, r):  # 0 indexing l r please [l,r]\\n\\t\\tj = self.log[r-l+1]\\n\\t\\treturn max(self.table[l][j], self.table[r - (1 << j) + 1][j])\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        # st=SegmentTree(nums)\\n        n=len(nums)\\n        st=SparseTable(n,nums)\\n        st.RMQ_build()\\n\\n        ans=[-1]*n\\n        res=defaultdict(int)\\n        for id,i in enumerate(nums):\\n            if res[i]==-1:\\n                continue\\n            lo=id+1\\n            hi=n-1\\n            mx1=-1\\n            while lo<=hi:\\n                mid=(lo+hi)//2\\n                if st.RMQ_Q(id+1,mid)>i:\\n                    hi=mid-1\\n                    mx1=mid\\n                else:\\n                    lo=mid+1\\n            if mx1==-1 or mx1+1==n:\\n                res[i]=-1\\n                continue\\n            lo=mx1+1\\n            hi=n-1\\n            mx2=-1\\n            while lo<=hi:\\n                mid=(lo+hi)//2\\n                if st.RMQ_Q(mx1+1,mid)>i:\\n                    hi=mid-1\\n                    mx2=mid\\n                else:\\n                    lo=mid+1\\n            if mx2!=-1:\\n                ans[id]=nums[mx2]\\n            else:\\n                res[i]=-1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159124,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        vector<int> secondGreaterElement(vector<int>& A) {\\n        int n = A.size();\\n        vector<int> res(n, -1), s1, s2, tmp;\\n        for (int i = 0 ;i < n; ++i) {\\n            while (!s2.empty() && A[s2.back()] < A[i])\\n                res[s2.back()] = A[i], s2.pop_back();\\n            while (!s1.empty() && A[s1.back()] < A[i])\\n                tmp.push_back(s1.back()), s1.pop_back();\\n            while (!tmp.empty())\\n                s2.push_back(tmp.back()), tmp.pop_back();\\n            s1.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        vector<int> secondGreaterElement(vector<int>& A) {\\n        int n = A.size();\\n        vector<int> res(n, -1), s1, s2, tmp;\\n        for (int i = 0 ;i < n; ++i) {\\n            while (!s2.empty() && A[s2.back()] < A[i])\\n                res[s2.back()] = A[i], s2.pop_back();\\n            while (!s1.empty() && A[s1.back()] < A[i])\\n                tmp.push_back(s1.back()), s1.pop_back();\\n            while (!tmp.empty())\\n                s2.push_back(tmp.back()), tmp.pop_back();\\n            s1.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140853,
                "title": "swift-solution",
                "content": "# Approach\\n1. Create two stacks s1 and s2\\n2. Create a temporary stack tmp\\n3. Traverse the array from start to end\\n4. If s2 is not empty and A[s2.top] < A[i], then pop s2 and store the popped element in res\\n5. If s1 is not empty and A[s1.top] < A[i], then pop s1 and push the popped element in tmp\\n6. If tmp is not empty, then pop tmp and push the popped element in s2\\n7. Push i in s1\\n8. Return res\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func secondGreaterElement(_ A: [Int]) -> [Int] {\\n        var n = A.count,  res = Array(repeating: -1, count: n)\\n        var s1 = [Int](), s2 = [Int](), tmp = [Int]()\\n        for i in 0..<n {\\n            while !s2.isEmpty && A[s2.last!] < A[i] {\\n                res[s2.removeLast()] = A[i]\\n            }\\n            while !s1.isEmpty && A[s1.last!] < A[i] {\\n                tmp.append(s1.removeLast())\\n            }\\n            while !tmp.isEmpty {\\n                s2.append(tmp.removeLast())\\n            }\\n            s1.append(i)\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func secondGreaterElement(_ A: [Int]) -> [Int] {\\n        var n = A.count,  res = Array(repeating: -1, count: n)\\n        var s1 = [Int](), s2 = [Int](), tmp = [Int]()\\n        for i in 0..<n {\\n            while !s2.isEmpty && A[s2.last!] < A[i] {\\n                res[s2.removeLast()] = A[i]\\n            }\\n            while !s1.isEmpty && A[s1.last!] < A[i] {\\n                tmp.append(s1.removeLast())\\n            }\\n            while !tmp.isEmpty {\\n                s2.append(tmp.removeLast())\\n            }\\n            s1.append(i)\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053943,
                "title": "c-monotonic-stack-priority-queue-o-nlog-n",
                "content": "# Approach\\n\\nUse a monotonic stack to get elements that are smaller than the element which is inspect in the `ith` iteration. Store elements `<` in a priority queue. Before popping the stack, remove all elements from queue that are `<` than the current element which is the second greatest. Because we use a priority queue, we can terminate early. \\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nstruct Comparator {\\n    bool operator()(pair<int,int>& a, pair<int,int>& b) {\\n        return a.first > b.first;\\n    }\\n};\\n\\nclass Solution {\\n    public:\\n        vector<int> secondGreaterElement(vector<int>& nums) {\\n            const int n = nums.size();\\n\\n            vector<int> result(n, -1);\\n            priority_queue<pair<int,int>, vector<pair<int,int>>, Comparator> pq;\\n\\n\\n            // Save indices of elements less than the current element\\n            stack<int> mon_stack;\\n\\n            for (int i = 0; i < n; i++) {\\n                while (!pq.empty()) {\\n                    auto top = pq.top();\\n                    if (top.first >= nums[i]) {break;}\\n                    else {pq.pop(); result[top.second] = nums[i];}\\n                }\\n\\n                while (mon_stack.size() > 0 && nums[mon_stack.top()] < nums[i]) {\\n                    int top_idx = mon_stack.top();\\n                    mon_stack.pop();\\n                    pq.push({nums[top_idx], top_idx});\\n                }\\n                mon_stack.push(i);\\n            }\\n            \\n            return result;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nstruct Comparator {\\n    bool operator()(pair<int,int>& a, pair<int,int>& b) {\\n        return a.first > b.first;\\n    }\\n};\\n\\nclass Solution {\\n    public:\\n        vector<int> secondGreaterElement(vector<int>& nums) {\\n            const int n = nums.size();\\n\\n            vector<int> result(n, -1);\\n            priority_queue<pair<int,int>, vector<pair<int,int>>, Comparator> pq;\\n\\n\\n            // Save indices of elements less than the current element\\n            stack<int> mon_stack;\\n\\n            for (int i = 0; i < n; i++) {\\n                while (!pq.empty()) {\\n                    auto top = pq.top();\\n                    if (top.first >= nums[i]) {break;}\\n                    else {pq.pop(); result[top.second] = nums[i];}\\n                }\\n\\n                while (mon_stack.size() > 0 && nums[mon_stack.top()] < nums[i]) {\\n                    int top_idx = mon_stack.top();\\n                    mon_stack.pop();\\n                    pq.push({nums[top_idx], top_idx});\\n                }\\n                mon_stack.push(i);\\n            }\\n            \\n            return result;\\n        }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3029871,
                "title": "java-stack-heap-nger",
                "content": "\\n```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int n=nums.length;\\n        int []nger=new int[n];\\n          int []res=new int[n];\\n          Arrays.fill(res,-1);\\n        Arrays.fill(nger,-1);\\n      Stack<Integer>st=new Stack<>();\\n    \\n    for(int i=n-1;i>=0;i--)\\n    {\\n        while(st.size()!=0&&nums[st.peek()]<=nums[i])\\n        {\\n            st.pop();\\n\\n        }\\n        if(st.size()!=0)\\n        {\\n            nger[i]=st.peek();\\n        }\\n        st.push(i);\\n    }\\n\\n    HashMap<Integer,List<Integer>>map=new HashMap<>();\\nfor(int i=0;i<n;i++)\\n{\\n    if(nger[i]!=-1)\\n    {\\n      List<Integer>ls= map.getOrDefault(nger[i],new ArrayList<>());\\n      ls.add(i);\\n      map.put(nger[i],ls);\\n    }\\n\\n}   \\nPriorityQueue<Integer>pq=new PriorityQueue<>((a,b)->nums[a]-nums[b]);\\nfor(int i=0;i<n;i++)\\n{\\n    if(map.containsKey(i-1)) \\n    {  for(int idx:map.get(i-1))\\n        {\\n            pq.add(idx);\\n\\n        }\\n      \\n    }\\n       while(pq.size()!=0&&nums[pq.peek()]<nums[i])\\n        {\\n            res[pq.remove()]=nums[i];\\n\\n        }\\n\\n}\\n\\n\\nreturn res;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int n=nums.length;\\n        int []nger=new int[n];\\n          int []res=new int[n];\\n          Arrays.fill(res,-1);\\n        Arrays.fill(nger,-1);\\n      Stack<Integer>st=new Stack<>();\\n    \\n    for(int i=n-1;i>=0;i--)\\n    {\\n        while(st.size()!=0&&nums[st.peek()]<=nums[i])\\n        {\\n            st.pop();\\n\\n        }\\n        if(st.size()!=0)\\n        {\\n            nger[i]=st.peek();\\n        }\\n        st.push(i);\\n    }\\n\\n    HashMap<Integer,List<Integer>>map=new HashMap<>();\\nfor(int i=0;i<n;i++)\\n{\\n    if(nger[i]!=-1)\\n    {\\n      List<Integer>ls= map.getOrDefault(nger[i],new ArrayList<>());\\n      ls.add(i);\\n      map.put(nger[i],ls);\\n    }\\n\\n}   \\nPriorityQueue<Integer>pq=new PriorityQueue<>((a,b)->nums[a]-nums[b]);\\nfor(int i=0;i<n;i++)\\n{\\n    if(map.containsKey(i-1)) \\n    {  for(int idx:map.get(i-1))\\n        {\\n            pq.add(idx);\\n\\n        }\\n      \\n    }\\n       while(pq.size()!=0&&nums[pq.peek()]<nums[i])\\n        {\\n            res[pq.remove()]=nums[i];\\n\\n        }\\n\\n}\\n\\n\\nreturn res;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027207,
                "title": "monotonic-stack-priority-queue",
                "content": "# Code\\n```\\nimport heapq\\nfrom typing import List\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = [-1] * n\\n        stack = []\\n        heap = []\\n\\n        for idx, num in enumerate(nums):\\n            while heap and heap[0][0] < num:\\n                ans[heap[0][1]] = num\\n                heapq.heappop(heap)\\n\\n            while stack and num > nums[stack[-1]]:\\n                heapq.heappush(heap, (nums[stack[-1]], stack[-1]))\\n                stack.pop()\\n\\n            stack.append(idx)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nfrom typing import List\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = [-1] * n\\n        stack = []\\n        heap = []\\n\\n        for idx, num in enumerate(nums):\\n            while heap and heap[0][0] < num:\\n                ans[heap[0][1]] = num\\n                heapq.heappop(heap)\\n\\n            while stack and num > nums[stack[-1]]:\\n                heapq.heappush(heap, (nums[stack[-1]], stack[-1]))\\n                stack.pop()\\n\\n            stack.append(idx)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004713,
                "title": "python-monotonic-stack-heap-64-time-38-space",
                "content": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        output = [-1] * len(nums)\\n        stack, heap = [], []\\n        for i, num in enumerate(nums):\\n            while heap and num > heap[0][0]:\\n                _, idx2 = heapq.heappop(heap)\\n                output[idx2] = num\\n\\n            while stack and num > nums[stack[-1]]:\\n                idx1 = stack.pop()\\n                heapq.heappush(heap, [nums[idx1], idx1])\\n            stack.append(i)\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        output = [-1] * len(nums)\\n        stack, heap = [], []\\n        for i, num in enumerate(nums):\\n            while heap and num > heap[0][0]:\\n                _, idx2 = heapq.heappop(heap)\\n                output[idx2] = num\\n\\n            while stack and num > nums[stack[-1]]:\\n                idx1 = stack.pop()\\n                heapq.heappush(heap, [nums[idx1], idx1])\\n            stack.append(i)\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931280,
                "title": "simply-modify-mono-stack",
                "content": "First, we start below with the standard monotonic stack setup, for finding the next larger element\\'s location for every single index in a list:\\n```\\ndef nextlarger(a):\\n\\tnextlarge = [float(\\'inf\\')] * len(a) \\n\\tmstack = [] #[value, location]\\n\\n\\tfor i in range(len(a)):\\n\\t\\tif mstack != [] and a[i] > mstack[-1][0]:\\n\\n\\t\\t\\t#go back through stack until no longer smaller.\\n\\t\\t\\twhile mstack != [] and mstack[-1][0] < a[i]:\\n\\t\\t\\t\\tnextlarge[mstack[-1][1]] = i #the next largest is this one.\\n\\n\\t\\t\\t\\tdel mstack[-1]\\n\\n\\t\\tmstack.append([a[i], i])\\n```\\n\\nMy strategy: After finding the first largest element for an index, we queue up all of those indexes into a self sorting list (can be heap too) named \"ready\". Then everytime we check a new element in list, we pop out however many elements in \"ready\" that\\'s smaller than the new element, because for those things in \"ready\" that\\'s popped out, the new element would be the second largest for them.\\n\\nOur final result:\\n```\\ndef nextlarger(a):\\n\\tnextlarge = [float(\\'inf\\')] * len(a) \\n\\tmstack = [] #[value, location]\\n\\n\\tready = SortedList() #ready for the second largest! [value, location]\\n\\n\\tanswer=[-1]*len(a) #second next large\\n\\tfor i in range(len(a)):\\n\\n\\n\\t\\twhile ready != [] and ready[0][0] < a[i]: #pop everything that\\'s smaller than current\\n\\t\\t\\tloc=ready[0][1]\\n\\n\\t\\t\\tanswer[loc]=a[i]\\n\\t\\t\\tready.pop(0)\\n\\t\\t\\t# print(ready)\\n\\n\\n\\t\\tif mstack != [] and a[i] > mstack[-1][0]:\\n\\n\\t\\t\\t#go back through stack until no longer smaller.\\n\\t\\t\\twhile mstack != [] and mstack[-1][0] < a[i]:\\n\\t\\t\\t\\tnextlarge[mstack[-1][1]] = i #the next largest is this one.\\n\\n\\t\\t\\t\\t# del mstack[-1]\\n\\t\\t\\t\\tready.add([mstack[-1][0], mstack[-1][1]])\\n\\t\\t\\t\\tdel mstack[-1]\\n\\n\\t\\tmstack.append([a[i], i])\\n\\n\\treturn answer\\n\\n\\n\\nreturn nextlarger(a)\\n```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\ndef nextlarger(a):\\n\\tnextlarge = [float(\\'inf\\')] * len(a) \\n\\tmstack = [] #[value, location]\\n\\n\\tfor i in range(len(a)):\\n\\t\\tif mstack != [] and a[i] > mstack[-1][0]:\\n\\n\\t\\t\\t#go back through stack until no longer smaller.\\n\\t\\t\\twhile mstack != [] and mstack[-1][0] < a[i]:\\n\\t\\t\\t\\tnextlarge[mstack[-1][1]] = i #the next largest is this one.\\n\\n\\t\\t\\t\\tdel mstack[-1]\\n\\n\\t\\tmstack.append([a[i], i])\\n```\n```\\ndef nextlarger(a):\\n\\tnextlarge = [float(\\'inf\\')] * len(a) \\n\\tmstack = [] #[value, location]\\n\\n\\tready = SortedList() #ready for the second largest! [value, location]\\n\\n\\tanswer=[-1]*len(a) #second next large\\n\\tfor i in range(len(a)):\\n\\n\\n\\t\\twhile ready != [] and ready[0][0] < a[i]: #pop everything that\\'s smaller than current\\n\\t\\t\\tloc=ready[0][1]\\n\\n\\t\\t\\tanswer[loc]=a[i]\\n\\t\\t\\tready.pop(0)\\n\\t\\t\\t# print(ready)\\n\\n\\n\\t\\tif mstack != [] and a[i] > mstack[-1][0]:\\n\\n\\t\\t\\t#go back through stack until no longer smaller.\\n\\t\\t\\twhile mstack != [] and mstack[-1][0] < a[i]:\\n\\t\\t\\t\\tnextlarge[mstack[-1][1]] = i #the next largest is this one.\\n\\n\\t\\t\\t\\t# del mstack[-1]\\n\\t\\t\\t\\tready.add([mstack[-1][0], mstack[-1][1]])\\n\\t\\t\\t\\tdel mstack[-1]\\n\\n\\t\\tmstack.append([a[i], i])\\n\\n\\treturn answer\\n\\n\\n\\nreturn nextlarger(a)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2907766,
                "title": "c-segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing segment tree\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> tree;\\n\\n    // range max tree\\n    int buildTree(int i, int l, int r, vector<int> &nums) {\\n        if (l == r) \\n            return tree[i] = nums[l];\\n        int mid = (l + r) / 2;\\n        return tree[i] = max(buildTree(2*i+1, l, mid, nums), buildTree(2*i+2, mid+1, r, nums));\\n    }\\n\\n    int query(int num, int pos, int i, int l, int r, vector<int> &nums) {\\n        if(tree[i] <= num || r < pos)\\n            return INT_MAX;\\n        else if(l == r)\\n            return l;\\n\\n        int mid = (l + r) / 2;\\n        int res = query(num, pos, 2*i+1, l, mid, nums);\\n        if (res == INT_MAX)\\n            res = query(num, pos, 2*i+2, mid+1, r, nums);\\n\\n        return res;\\n    }\\n\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, -1);\\n\\n        tree.resize(4*n);\\n        buildTree(0, 0, n-1, nums);\\n\\n        for (int i = 0; i < n; i++) {\\n            int ng = query(nums[i], i+1, 0, 0, n-1, nums);\\n            if(ng != INT_MAX) {\\n                int sng = query(nums[i], ng+1, 0, 0, n-1, nums);\\n                cout << sng << \" \";\\n                if(sng != INT_MAX)\\n                    ans[i] = nums[sng];\\n            } \\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> tree;\\n\\n    // range max tree\\n    int buildTree(int i, int l, int r, vector<int> &nums) {\\n        if (l == r) \\n            return tree[i] = nums[l];\\n        int mid = (l + r) / 2;\\n        return tree[i] = max(buildTree(2*i+1, l, mid, nums), buildTree(2*i+2, mid+1, r, nums));\\n    }\\n\\n    int query(int num, int pos, int i, int l, int r, vector<int> &nums) {\\n        if(tree[i] <= num || r < pos)\\n            return INT_MAX;\\n        else if(l == r)\\n            return l;\\n\\n        int mid = (l + r) / 2;\\n        int res = query(num, pos, 2*i+1, l, mid, nums);\\n        if (res == INT_MAX)\\n            res = query(num, pos, 2*i+2, mid+1, r, nums);\\n\\n        return res;\\n    }\\n\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, -1);\\n\\n        tree.resize(4*n);\\n        buildTree(0, 0, n-1, nums);\\n\\n        for (int i = 0; i < n; i++) {\\n            int ng = query(nums[i], i+1, 0, 0, n-1, nums);\\n            if(ng != INT_MAX) {\\n                int sng = query(nums[i], ng+1, 0, 0, n-1, nums);\\n                cout << sng << \" \";\\n                if(sng != INT_MAX)\\n                    ans[i] = nums[sng];\\n            } \\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2841481,
                "title": "c-solution",
                "content": "```\\nstruct unfind{\\n    int val;\\n    int place;\\n    bool first;\\n    struct unfind* next;\\n};\\n\\nvoid check (struct unfind* root, struct unfind* now, struct unfind* this, int* nums){\\n    if (now == NULL){\\n        this->next = NULL;\\n        root->next = this;\\n        return;\\n    }\\n    if (this->val > now->val){\\n        if (now->first){\\n            nums[now->place] = this->val;\\n            root->next = now->next;\\n            free(now);\\n            check(root, root->next, this, nums);\\n        } else {\\n            now->first = true;\\n            check(now, now->next, this, nums);\\n        }\\n    } else {\\n        this->next = root->next;\\n        root->next = this;\\n    }\\n}\\n\\nvoid freelist(struct unfind* root, int* nums){\\n    if (root == NULL){\\n        return;\\n    }\\n    nums[root->place] = -1;\\n    freelist(root->next, nums);\\n    free(root);\\n}\\n\\nint* secondGreaterElement(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    struct unfind* root = malloc(sizeof(struct unfind));\\n    struct unfind* zero = malloc(sizeof(struct unfind));\\n    root->place = numsSize-1;   //Imput the place where must be -1  Just for write freelist();\\n    root->next = zero;\\n    \\n    zero->val = nums[0];\\n    zero->place = 0;\\n    zero->first = false;\\n    zero->next = NULL;\\n    \\n    for (int i = 1 ; i < numsSize ; i++){\\n        struct unfind* this = malloc(sizeof(struct unfind));\\n        this->val = nums[i];\\n        this->place = i;\\n        this->first = false;\\n        check(root, root->next, this, ans);\\n    }\\n    freelist(root, ans);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct unfind{\\n    int val;\\n    int place;\\n    bool first;\\n    struct unfind* next;\\n};\\n\\nvoid check (struct unfind* root, struct unfind* now, struct unfind* this, int* nums){\\n    if (now == NULL){\\n        this->next = NULL;\\n        root->next = this;\\n        return;\\n    }\\n    if (this->val > now->val){\\n        if (now->first){\\n            nums[now->place] = this->val;\\n            root->next = now->next;\\n            free(now);\\n            check(root, root->next, this, nums);\\n        } else {\\n            now->first = true;\\n            check(now, now->next, this, nums);\\n        }\\n    } else {\\n        this->next = root->next;\\n        root->next = this;\\n    }\\n}\\n\\nvoid freelist(struct unfind* root, int* nums){\\n    if (root == NULL){\\n        return;\\n    }\\n    nums[root->place] = -1;\\n    freelist(root->next, nums);\\n    free(root);\\n}\\n\\nint* secondGreaterElement(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n    int* ans = malloc(sizeof(int)*numsSize);\\n    struct unfind* root = malloc(sizeof(struct unfind));\\n    struct unfind* zero = malloc(sizeof(struct unfind));\\n    root->place = numsSize-1;   //Imput the place where must be -1  Just for write freelist();\\n    root->next = zero;\\n    \\n    zero->val = nums[0];\\n    zero->place = 0;\\n    zero->first = false;\\n    zero->next = NULL;\\n    \\n    for (int i = 1 ; i < numsSize ; i++){\\n        struct unfind* this = malloc(sizeof(struct unfind));\\n        this->val = nums[i];\\n        this->place = i;\\n        this->first = false;\\n        check(root, root->next, this, ans);\\n    }\\n    freelist(root, ans);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2817174,
                "title": "can-any-one-please-tell-me-why-i-am-getting-tle-on-42-test-case",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& a) {\\n        int n=a.size();\\n        if(n<=2){\\n            if(n==1)\\n            return {-1};\\n            else\\n                return {-1,-1};\\n        }\\n        auto cmp=[&](int i,int j){\\n            if(a[i]==a[j]){\\n                return i<j;\\n            }\\n            return a[i]>a[j];\\n        };\\n        vector<int> p(n);\\n        iota(begin(p),end(p),0);\\n        sort(begin(p),end(p),cmp);\\n        set<int> s;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;++i){\\n            int t=p[i];\\n            if(s.size()<2){\\n                ans[t]=-1;\\n            }else{\\n                auto it=upper_bound(begin(s),end(s),t);\\n                if(it++==end(s)){\\n                    ans[t]=-1;\\n                }else if(it==end(s)){\\n                    ans[t]=-1;\\n                }else{\\n                    ans[t]=a[*it];\\n                }\\n            }\\n            s.insert(t);\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& a) {\\n        int n=a.size();\\n        if(n<=2){\\n            if(n==1)\\n            return {-1};\\n            else\\n                return {-1,-1};\\n        }\\n        auto cmp=[&](int i,int j){\\n            if(a[i]==a[j]){\\n                return i<j;\\n            }\\n            return a[i]>a[j];\\n        };\\n        vector<int> p(n);\\n        iota(begin(p),end(p),0);\\n        sort(begin(p),end(p),cmp);\\n        set<int> s;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;++i){\\n            int t=p[i];\\n            if(s.size()<2){\\n                ans[t]=-1;\\n            }else{\\n                auto it=upper_bound(begin(s),end(s),t);\\n                if(it++==end(s)){\\n                    ans[t]=-1;\\n                }else if(it==end(s)){\\n                    ans[t]=-1;\\n                }else{\\n                    ans[t]=a[*it];\\n                }\\n            }\\n            s.insert(t);\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804757,
                "title": "segment-tree-stack-binary-search",
                "content": "```\\nclass Solution {\\nprivate:\\n    int construct (int ss, int se, int si, vector<int>&stree, vector<int>&nums){\\n        if(ss==se){\\n            stree[si]=nums[se];\\n            return stree[si];\\n        }\\n        \\n        int mid = (ss+se)/2;\\n        \\n        stree[si]= max(construct(ss,mid,2*si+1,stree,nums), construct(mid+1,se,2*si+2,stree,nums));\\n        return stree[si];\\n    }\\n    \\n    int get(int qs, int qe, int ss, int se, int si, vector<int>&stree){\\n        if(se<qs || ss>qe) return INT_MIN;\\n        \\n        if(qs<=ss && qe>=se) {\\n            return stree[si];\\n        }\\n        \\n        int mid = (ss+se)/2;\\n        int ans = max(get(qs,qe,ss,mid,2*si+1,stree), get(qs,qe,mid+1,se,2*si+2,stree));\\n        return ans;\\n    }\\n    \\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> st;\\n        \\n        vector<int>next(n,-1);\\n        \\n        for(int i = n-1; i >=0 ; i--) {\\n            while(!st.empty() && nums[st.top()]<=nums[i]){\\n                st.pop();\\n            }\\n            if(st.empty())next[i]=-1;\\n            else next[i]=st.top();\\n            st.push(i);\\n        }\\n        \\n       \\n       // using segment tree fro nex t to next greater \\n        \\n        vector<int>stree(6*n,-1);\\n        construct(0,n-1,0,stree,nums);\\n        \\n        vector<int>res(n);\\n        for(int i=0; i<n; i++){\\n            if(next[i]==-1 || next[i]==n-1){\\n                res[i]=-1;\\n            }\\n            else{\\n                int low = next[i];\\n                int high = n-1;\\n                //if(next[low]!=-1)high = next[low];\\n                int v =-1;\\n                low = low+1;\\n                \\n                while(low<=high){\\n                    int mid = low+(high-low)/2;\\n                    int q = get(low,mid,0,n-1,0,stree);\\n                    \\n                    if(q>nums[i]){\\n                        v=q;\\n                        high = mid-1;\\n                    }\\n                    else low = mid+1;\\n                }\\n                \\n                res[i]=v;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int construct (int ss, int se, int si, vector<int>&stree, vector<int>&nums){\\n        if(ss==se){\\n            stree[si]=nums[se];\\n            return stree[si];\\n        }\\n        \\n        int mid = (ss+se)/2;\\n        \\n        stree[si]= max(construct(ss,mid,2*si+1,stree,nums), construct(mid+1,se,2*si+2,stree,nums));\\n        return stree[si];\\n    }\\n    \\n    int get(int qs, int qe, int ss, int se, int si, vector<int>&stree){\\n        if(se<qs || ss>qe) return INT_MIN;\\n        \\n        if(qs<=ss && qe>=se) {\\n            return stree[si];\\n        }\\n        \\n        int mid = (ss+se)/2;\\n        int ans = max(get(qs,qe,ss,mid,2*si+1,stree), get(qs,qe,mid+1,se,2*si+2,stree));\\n        return ans;\\n    }\\n    \\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> st;\\n        \\n        vector<int>next(n,-1);\\n        \\n        for(int i = n-1; i >=0 ; i--) {\\n            while(!st.empty() && nums[st.top()]<=nums[i]){\\n                st.pop();\\n            }\\n            if(st.empty())next[i]=-1;\\n            else next[i]=st.top();\\n            st.push(i);\\n        }\\n        \\n       \\n       // using segment tree fro nex t to next greater \\n        \\n        vector<int>stree(6*n,-1);\\n        construct(0,n-1,0,stree,nums);\\n        \\n        vector<int>res(n);\\n        for(int i=0; i<n; i++){\\n            if(next[i]==-1 || next[i]==n-1){\\n                res[i]=-1;\\n            }\\n            else{\\n                int low = next[i];\\n                int high = n-1;\\n                //if(next[low]!=-1)high = next[low];\\n                int v =-1;\\n                low = low+1;\\n                \\n                while(low<=high){\\n                    int mid = low+(high-low)/2;\\n                    int q = get(low,mid,0,n-1,0,stree);\\n                    \\n                    if(q>nums[i]){\\n                        v=q;\\n                        high = mid-1;\\n                    }\\n                    else low = mid+1;\\n                }\\n                \\n                res[i]=v;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793162,
                "title": "visualization-mono-stack-priority-queue-approach",
                "content": "# Visualization of Mono Stack & Priority Queue \\n\\n![LtHard (1).jpg](https://assets.leetcode.com/users/images/8949c7e1-b161-48cf-b02e-cc8b4fe2137c_1667913701.661309.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public Map<Integer,List<Integer>> giveNextGreater(int[] nums){\\n        Map<Integer,List<Integer>> nextGreaterMap = new HashMap<> ();\\n        Stack<Pair<Integer,Integer>> stack = new Stack<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            while(!stack.empty() && stack.peek().getKey() < nums[i]){\\n                Pair<Integer,Integer> currPair = stack.pop();\\n                List<Integer> tempList= nextGreaterMap.getOrDefault(i,new ArrayList<Integer>());\\n                tempList.add(currPair.getValue());\\n                nextGreaterMap.put(i,tempList); \\n            }\\n            stack.push(new Pair(nums[i],i));\\n        }\\n        \\n        return nextGreaterMap;\\n    }\\n    \\n    public int[] secondGreaterElement(int[] nums) {\\n        Map<Integer,List<Integer>> nextGreaterMap = giveNextGreater(nums);\\n        Queue<Pair<Integer,Integer>> minHeap = new PriorityQueue<>((p1,p2)-> p1.getKey()>=p2.getKey()?1:-1);\\n        int[] answer = new int[nums.length];\\n        Arrays.fill(answer,-1);\\n        \\n        for(int i=0;i<nums.length;i++){\\n            while(minHeap.size()>0 && minHeap.peek().getKey() < nums[i]){\\n                answer[minHeap.peek().getValue()] = nums[i]; \\n                minHeap.poll();\\n            }\\n            \\n            for(Integer x : nextGreaterMap.getOrDefault(i,new ArrayList<Integer>())) {\\n                Pair<Integer,Integer> p = new Pair<Integer,Integer>(nums[x],x);\\n                minHeap.add(p);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Map<Integer,List<Integer>> giveNextGreater(int[] nums){\\n        Map<Integer,List<Integer>> nextGreaterMap = new HashMap<> ();\\n        Stack<Pair<Integer,Integer>> stack = new Stack<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            while(!stack.empty() && stack.peek().getKey() < nums[i]){\\n                Pair<Integer,Integer> currPair = stack.pop();\\n                List<Integer> tempList= nextGreaterMap.getOrDefault(i,new ArrayList<Integer>());\\n                tempList.add(currPair.getValue());\\n                nextGreaterMap.put(i,tempList); \\n            }\\n            stack.push(new Pair(nums[i],i));\\n        }\\n        \\n        return nextGreaterMap;\\n    }\\n    \\n    public int[] secondGreaterElement(int[] nums) {\\n        Map<Integer,List<Integer>> nextGreaterMap = giveNextGreater(nums);\\n        Queue<Pair<Integer,Integer>> minHeap = new PriorityQueue<>((p1,p2)-> p1.getKey()>=p2.getKey()?1:-1);\\n        int[] answer = new int[nums.length];\\n        Arrays.fill(answer,-1);\\n        \\n        for(int i=0;i<nums.length;i++){\\n            while(minHeap.size()>0 && minHeap.peek().getKey() < nums[i]){\\n                answer[minHeap.peek().getValue()] = nums[i]; \\n                minHeap.poll();\\n            }\\n            \\n            for(Integer x : nextGreaterMap.getOrDefault(i,new ArrayList<Integer>())) {\\n                Pair<Integer,Integer> p = new Pair<Integer,Integer>(nums[x],x);\\n                minHeap.add(p);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785415,
                "title": "o-nlogn-using-binary-search-on-sorted-index-examples",
                "content": "**Main Idea**:\\n+ Building sorted index **a_idx** for array **nums** with **value asscending**, and **index descending**.\\n```\\nnums:  [11, 13, 15, 12, 0, 15, 12, 11, 9]\\na_idx: [4, 8, 7, 0, 6, 3, 1, 5, 2]\\n\\nnums[a_idx[0]] = 0 < nums[a_idx[1]] = 9, a_idx[0]=4, a_idx[1]=9\\nnums[a_idx[4]] = 12 == nums[a_idx[5]] = 12, a_idx[4]=6 > a_idx[5]=3\\n```\\n+ Building sorted list **s_idx** = {0, 1, 2, ..., n-1}\\n+ At the position k in [0, n-1], we try to find the position **pos** in sorted list **{s_idx \\\\ a_idx[0->k]}** where **s_idx[pos]>k**.\\nIf **pos+1<n**, ans[k] = nums[a_idx[pos+1]]. Otherwise, ans[k] = -1\\n+ Reasoning sorting by index descending to elemenate the case where **nums[s_idx[pos]] = nums[k]**. We prioritily process the higher index first.\\n\\n**Examples**:\\n```\\nnums:  [11, 13, 15, 12, 0, 15, 12, 11, 9]\\na_idx: [4, 8, 7, 0, 6, 3, 1, 5, 2]\\ns_idx: [0, 1, 2, 3, 4, 5, 6, 7, 8]\\n+  0 4 [0, 1, 2, 3, 5, 6, 7, 8] 5 12 -> [-1, -1, -1, -1, 12, -1, -1, -1, -1]\\n+  1 8 [0, 1, 2, 3, 5, 6, 7] 8 -1 -> [-1, -1, -1, -1, 12, -1, -1, -1, -1]\\n+  2 7 [0, 1, 2, 3, 5, 6] 7 -1 -> [-1, -1, -1, -1, 12, -1, -1, -1, -1]\\n+  3 0 [1, 2, 3, 5, 6] 1 15 -> [15, -1, -1, -1, 12, -1, -1, -1, -1]\\n+  4 6 [1, 2, 3, 5] 5 -1 -> [15, -1, -1, -1, 12, -1, -1, -1, -1]\\n+  5 3 [1, 2, 5] 3 -1 -> [15, -1, -1, -1, 12, -1, -1, -1, -1]\\n+  6 1 [2, 5] 1 15 -> [15, 15, -1, -1, 12, -1, -1, -1, -1]\\nans:  [15, 15, -1, -1, 12, -1, -1, -1, -1]\\n==================== \\n\\nnums:  [1, 17, 18, 0, 18, 10, 20, 0]\\na_idx: [7, 3, 0, 5, 1, 4, 2, 6]\\ns_idx: [0, 1, 2, 3, 4, 5, 6, 7]\\n+  0 7 [0, 1, 2, 3, 4, 5, 6] 8 -1 -> [-1, -1, -1, -1, -1, -1, -1, -1]\\n+  1 3 [0, 1, 2, 4, 5, 6] 4 10 -> [-1, -1, -1, 10, -1, -1, -1, -1]\\n+  2 0 [1, 2, 4, 5, 6] 1 18 -> [18, -1, -1, 10, -1, -1, -1, -1]\\n+  3 5 [1, 2, 4, 6] 4 -1 -> [18, -1, -1, 10, -1, -1, -1, -1]\\n+  4 1 [2, 4, 6] 1 18 -> [18, 18, -1, 10, -1, -1, -1, -1]\\n+  5 4 [2, 6] 2 -1 -> [18, 18, -1, 10, -1, -1, -1, -1]\\nans:  [18, 18, -1, 10, -1, -1, -1, -1]\\n==================== \\n\\nnums:  [2, 4, 0, 9, 6]\\na_idx: [2, 0, 1, 4, 3]\\ns_idx: [0, 1, 2, 3, 4]\\n+  0 2 [0, 1, 3, 4] 3 6 -> [-1, -1, 6, -1, -1]\\n+  1 0 [1, 3, 4] 1 9 -> [9, -1, 6, -1, -1]\\n+  2 1 [3, 4] 1 6 -> [9, 6, 6, -1, -1]\\nans:  [9, 6, 6, -1, -1]\\n==================== \\n\\nnums:  [3, 3]\\na_idx: [1, 0]\\ns_idx: [0, 1]\\nans:  [-1, -1]\\n==================== \\n```\\n\\n**Code**:\\n+ Python\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)        \\n        a_idx = list(range(n))\\n        a_idx = sorted(a_idx, key = lambda x: (nums[x], -x))\\n        s_idx = SortedList(a_idx)\\n        \\n        print(\"nums: \", nums)\\n        print(\"a_idx:\",a_idx)\\n        print(\"s_idx:\", list(s_idx))\\n        \\n        ans = [-1] * n\\n        for i in range(n-2):\\n            x = a_idx[i]\\n            s_idx.remove(x)\\n            pos = s_idx.bisect_right(x) + 1\\n            val = -1; \\n            if pos<len(s_idx):\\n                val = nums[s_idx[pos]]\\n            ans[x] = val\\n            print(\"+ \", i, x, list(s_idx), pos, val, \"->\", ans)\\n        \\n        print(\"ans: \", ans)\\n        print(\"=\" * 20, \"\\\\n\")\\n        \\n        return ans\\n    \\n# print = lambda *a, **aa: ()\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nnums:  [11, 13, 15, 12, 0, 15, 12, 11, 9]\\na_idx: [4, 8, 7, 0, 6, 3, 1, 5, 2]\\n\\nnums[a_idx[0]] = 0 < nums[a_idx[1]] = 9, a_idx[0]=4, a_idx[1]=9\\nnums[a_idx[4]] = 12 == nums[a_idx[5]] = 12, a_idx[4]=6 > a_idx[5]=3\\n```\n```\\nnums:  [11, 13, 15, 12, 0, 15, 12, 11, 9]\\na_idx: [4, 8, 7, 0, 6, 3, 1, 5, 2]\\ns_idx: [0, 1, 2, 3, 4, 5, 6, 7, 8]\\n+  0 4 [0, 1, 2, 3, 5, 6, 7, 8] 5 12 -> [-1, -1, -1, -1, 12, -1, -1, -1, -1]\\n+  1 8 [0, 1, 2, 3, 5, 6, 7] 8 -1 -> [-1, -1, -1, -1, 12, -1, -1, -1, -1]\\n+  2 7 [0, 1, 2, 3, 5, 6] 7 -1 -> [-1, -1, -1, -1, 12, -1, -1, -1, -1]\\n+  3 0 [1, 2, 3, 5, 6] 1 15 -> [15, -1, -1, -1, 12, -1, -1, -1, -1]\\n+  4 6 [1, 2, 3, 5] 5 -1 -> [15, -1, -1, -1, 12, -1, -1, -1, -1]\\n+  5 3 [1, 2, 5] 3 -1 -> [15, -1, -1, -1, 12, -1, -1, -1, -1]\\n+  6 1 [2, 5] 1 15 -> [15, 15, -1, -1, 12, -1, -1, -1, -1]\\nans:  [15, 15, -1, -1, 12, -1, -1, -1, -1]\\n==================== \\n\\nnums:  [1, 17, 18, 0, 18, 10, 20, 0]\\na_idx: [7, 3, 0, 5, 1, 4, 2, 6]\\ns_idx: [0, 1, 2, 3, 4, 5, 6, 7]\\n+  0 7 [0, 1, 2, 3, 4, 5, 6] 8 -1 -> [-1, -1, -1, -1, -1, -1, -1, -1]\\n+  1 3 [0, 1, 2, 4, 5, 6] 4 10 -> [-1, -1, -1, 10, -1, -1, -1, -1]\\n+  2 0 [1, 2, 4, 5, 6] 1 18 -> [18, -1, -1, 10, -1, -1, -1, -1]\\n+  3 5 [1, 2, 4, 6] 4 -1 -> [18, -1, -1, 10, -1, -1, -1, -1]\\n+  4 1 [2, 4, 6] 1 18 -> [18, 18, -1, 10, -1, -1, -1, -1]\\n+  5 4 [2, 6] 2 -1 -> [18, 18, -1, 10, -1, -1, -1, -1]\\nans:  [18, 18, -1, 10, -1, -1, -1, -1]\\n==================== \\n\\nnums:  [2, 4, 0, 9, 6]\\na_idx: [2, 0, 1, 4, 3]\\ns_idx: [0, 1, 2, 3, 4]\\n+  0 2 [0, 1, 3, 4] 3 6 -> [-1, -1, 6, -1, -1]\\n+  1 0 [1, 3, 4] 1 9 -> [9, -1, 6, -1, -1]\\n+  2 1 [3, 4] 1 6 -> [9, 6, 6, -1, -1]\\nans:  [9, 6, 6, -1, -1]\\n==================== \\n\\nnums:  [3, 3]\\na_idx: [1, 0]\\ns_idx: [0, 1]\\nans:  [-1, -1]\\n==================== \\n```\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)        \\n        a_idx = list(range(n))\\n        a_idx = sorted(a_idx, key = lambda x: (nums[x], -x))\\n        s_idx = SortedList(a_idx)\\n        \\n        print(\"nums: \", nums)\\n        print(\"a_idx:\",a_idx)\\n        print(\"s_idx:\", list(s_idx))\\n        \\n        ans = [-1] * n\\n        for i in range(n-2):\\n            x = a_idx[i]\\n            s_idx.remove(x)\\n            pos = s_idx.bisect_right(x) + 1\\n            val = -1; \\n            if pos<len(s_idx):\\n                val = nums[s_idx[pos]]\\n            ans[x] = val\\n            print(\"+ \", i, x, list(s_idx), pos, val, \"->\", ans)\\n        \\n        print(\"ans: \", ans)\\n        print(\"=\" * 20, \"\\\\n\")\\n        \\n        return ans\\n    \\n# print = lambda *a, **aa: ()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781939,
                "title": "c-only-stack-simpleeest-solution-well-explained",
                "content": "# Approach\\n- Store index of elements which found first grater in stack s2\\n- Store index of elements who need to find 1st grater in stack s1\\n- move from s1 when found first grater to s2\\n- while moving need to take extra care for keeping the order intact, so we use stack temp\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> s1;  // For storing new elements\\n        stack<int> s2;  // For storings elements who need 2nd grater\\n        stack<int> temp; // For keeping the order intact while moving from s1 to s2\\n        vector<int> res(n, -1); \\n        for(int i=0; i<n; i++){\\n            // Check if current element is grater than top, then push to answer\\n            while(!s2.empty() && nums[s2.top()] < nums[i]){\\n                res[s2.top()] = nums[i];\\n                s2.pop();\\n            }\\n\\n            // check if we found first grater element in current\\n            while(!s1.empty() && nums[s1.top()] < nums[i]){\\n                temp.push(s1.top());\\n                s1.pop();\\n            }\\n\\n            // keep the sequence intact while storing into s1\\n            while(!temp.empty()){\\n                s2.push(temp.top());\\n                temp.pop();\\n            }\\n\\n            // Need to find first grater element\\n            s1.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> s1;  // For storing new elements\\n        stack<int> s2;  // For storings elements who need 2nd grater\\n        stack<int> temp; // For keeping the order intact while moving from s1 to s2\\n        vector<int> res(n, -1); \\n        for(int i=0; i<n; i++){\\n            // Check if current element is grater than top, then push to answer\\n            while(!s2.empty() && nums[s2.top()] < nums[i]){\\n                res[s2.top()] = nums[i];\\n                s2.pop();\\n            }\\n\\n            // check if we found first grater element in current\\n            while(!s1.empty() && nums[s1.top()] < nums[i]){\\n                temp.push(s1.top());\\n                s1.pop();\\n            }\\n\\n            // keep the sequence intact while storing into s1\\n            while(!temp.empty()){\\n                s2.push(temp.top());\\n                temp.pop();\\n            }\\n\\n            // Need to find first grater element\\n            s1.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775444,
                "title": "using-2-stacks-easy-to-understand-o-n-solution",
                "content": "```\\nvector<int> secondGreaterElement(vector<int>& nums) {\\n        vector<int> gt1;\\n        vector<int> gt2;\\n        vector<int> result(nums.size(),-1);\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            // First check if the incoming element is greater than element\\n            // captured in second stack which have already seen their first greater \\n            // element\\n            while(gt2.size() && nums[gt2.back()] < nums[i]) {\\n                result[gt2.back()] = nums[i];\\n                gt2.pop_back();\\n            }\\n            int n = gt2.size();\\n            // check the current element with elements waiting for first greater element\\n            while(gt1.size() && nums[gt1.back()] < nums[i]) {\\n                // promote element from first stack which has seen first greater element\\n                // to second stack\\n                gt2.push_back(gt1.back());\\n                gt1.pop_back();\\n            }\\n            gt1.push_back(i);\\n            reverse(gt2.begin()+n, gt2.end());\\n        }\\n        return result;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvector<int> secondGreaterElement(vector<int>& nums) {\\n        vector<int> gt1;\\n        vector<int> gt2;\\n        vector<int> result(nums.size(),-1);\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            // First check if the incoming element is greater than element\\n            // captured in second stack which have already seen their first greater \\n            // element\\n            while(gt2.size() && nums[gt2.back()] < nums[i]) {\\n                result[gt2.back()] = nums[i];\\n                gt2.pop_back();\\n            }\\n            int n = gt2.size();\\n            // check the current element with elements waiting for first greater element\\n            while(gt1.size() && nums[gt1.back()] < nums[i]) {\\n                // promote element from first stack which has seen first greater element\\n                // to second stack\\n                gt2.push_back(gt1.back());\\n                gt1.pop_back();\\n            }\\n            gt1.push_back(i);\\n            reverse(gt2.begin()+n, gt2.end());\\n        }\\n        return result;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774347,
                "title": "intuition-explained-priority-queue-c",
                "content": "# Intuition\\nAt every point we keep track of the numbers who\\'ve found:\\n-  1 no greater than them\\n-  2 nos greater than them\\n\\nand after updating them in the latter one we would update our answer array about it.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe would use two min heaps for this. A min heap would keep a pair of the number and index associated with it.\\nFor an index\\'s value check the top value of the first heap (the smallest value) if it is smaller than the current value, the heap\\'s top value has found its first greater number and it needs to be shifted to the second heap. Do it until the top value is greater than current.\\nSimilarly, do the same in the second heap and if they\\'ve found a greater number than them (which is the current index value) then remove them from there and add current number to answer array. Again, repeat this until top value is smaller than current number.\\nUpdate the second heap first to avoid infinite loop.\\nAt last if the heaps are left with some numbers this means they\\'re to be mapped with -1 in the answer array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq_first, pq_second;\\n        pq_first.push({nums[0], 0});\\n        vector<int> ans(nums.size(), -1);\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            // checking for the numbers who already have one number greater than them\\n            while(pq_second.size()){\\n                pair<int, int> temp = pq_second.top();\\n                if(temp.first < nums[i]){\\n                    ans[temp.second] = nums[i];\\n                    pq_second.pop();\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            //checking for numbers who has no number greater than them yet\\n            while(pq_first.size()){\\n                pair<int, int> temp = pq_first.top();\\n                if(temp.first < nums[i]){\\n                    pq_first.pop();\\n                    pq_second.push({temp.first, temp.second});\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            // insert current index number among those who haven\\'t found any no greater than them.\\n            pq_first.push({nums[i], i});\\n        }\\n        while(pq_first.size()){\\n            ans[pq_first.top().second] = -1;\\n            pq_first.pop();\\n        }\\n        while(pq_second.size()){\\n            ans[pq_second.top().second] = -1;\\n            pq_second.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq_first, pq_second;\\n        pq_first.push({nums[0], 0});\\n        vector<int> ans(nums.size(), -1);\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            // checking for the numbers who already have one number greater than them\\n            while(pq_second.size()){\\n                pair<int, int> temp = pq_second.top();\\n                if(temp.first < nums[i]){\\n                    ans[temp.second] = nums[i];\\n                    pq_second.pop();\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            //checking for numbers who has no number greater than them yet\\n            while(pq_first.size()){\\n                pair<int, int> temp = pq_first.top();\\n                if(temp.first < nums[i]){\\n                    pq_first.pop();\\n                    pq_second.push({temp.first, temp.second});\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            // insert current index number among those who haven\\'t found any no greater than them.\\n            pq_first.push({nums[i], i});\\n        }\\n        while(pq_first.size()){\\n            ans[pq_first.top().second] = -1;\\n            pq_first.pop();\\n        }\\n        while(pq_second.size()){\\n            ans[pq_second.top().second] = -1;\\n            pq_second.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772324,
                "title": "simple-python-solution-with-2-heap",
                "content": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        res, heap1, heap2 = [-1] * len(nums), [], []\\n        for i in range(len(nums)):\\n            while heap2 and heap2[0][0] < nums[i]:\\n                num, idx = heapq.heappop(heap2)\\n                res[idx] = nums[i]\\n            while heap1 and heap1[0][0] < nums[i]:\\n                heapq.heappush(heap2, (heapq.heappop(heap1)))\\n            heapq.heappush(heap1, (nums[i], i))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        res, heap1, heap2 = [-1] * len(nums), [], []\\n        for i in range(len(nums)):\\n            while heap2 and heap2[0][0] < nums[i]:\\n                num, idx = heapq.heappop(heap2)\\n                res[idx] = nums[i]\\n            while heap1 and heap1[0][0] < nums[i]:\\n                heapq.heappush(heap2, (heapq.heappop(heap1)))\\n            heapq.heappush(heap1, (nums[i], i))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770783,
                "title": "java-two-stack-easy-solution",
                "content": "class Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        Stack<Integer> st1=new Stack<>();\\n        Stack<Integer> st2=new Stack<>();\\n        int ans[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            if(st1.isEmpty()){\\n                st1.push(i);\\n            }\\n            else if(nums[st1.peek()]<nums[i]){\\n                if(st2.isEmpty()){\\n                    \\n                        st2.push(st1.pop());\\n                    \\n                    st1.push(i);\\n                }\\n                else{\\n                    while(!st2.isEmpty() && nums[st2.peek()]<nums[i]){\\n                        ans[st2.peek()]=nums[i];\\n                        st2.pop();\\n                    }\\n                    st1.push(i);\\n                }\\n            }\\n        }\\n        while(!st2.isEmpty()){\\n            ans[st2.pop()]=st1.peek();\\n        }\\n        while(!st1.isEmpty()){\\n            ans[st1.peek()]=-1;\\n            st1.pop();\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        Stack<Integer> st1=new Stack<>();\\n        Stack<Integer> st2=new Stack<>();\\n        int ans[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            if(st1.isEmpty()){\\n                st1.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2766653,
                "title": "c-max-segment-tree-with-approach",
                "content": "# Intuition\\nSimilar to Next greater element(If you think). Used simply max segment tree.\\n\\n# Approach\\nJust find the first greater element using max segment tree for nums[i] where (0<=i< n). And if the first greater element for the current element is present in the array then find the second greater element for the nums[i] from the range first greater element index(which is represented as a first variable in a code) to the size of the segment tree(which is represented as a size variable in a code).\\n\\n# Code\\n```\\nstruct segtree {\\n    int size;\\n    vector<int> seg;\\n    void init(int n)\\n    {\\n        size = 1;\\n        while(size<=n)\\n        {\\n            size *=2;\\n        }\\n        seg.resize(4*size,0);\\n    }\\n    \\n    void build(int l,int r,int x,vector<int> &nums)\\n    {\\n        if(l == r)\\n        {\\n            if(l < nums.size())\\n            {\\n                seg[x] = nums[l];\\n            }\\n            return;\\n        }\\n        int mid = l + (r-l)/2;\\n        build(l,mid,2*x+1,nums);\\n        build(mid+1,r,2*x+2,nums);\\n        seg[x] = max(seg[2*x+1],seg[2*x+2]);\\n    }\\n    int query(int k,int l,int x,int lx,int rx)\\n    {\\n        if(seg[x] <=k || rx < l) return -1;\\n        if(lx == rx) return lx;\\n        int mid = lx + (rx-lx)/2;\\n        int res = query(k,l,2*x+1,lx,mid);\\n        if(res == -1)\\n        {\\n            res = query(k,l,2*x+2,mid+1,rx);\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        segtree st;\\n        st.init(n);\\n        st.build(0,st.size-1,0,nums);\\n        vector<int> res(n,-1);\\n        for(int i = 0; i < n; i++)\\n        {\\n            int first = st.query(nums[i],i+1,0,0,st.size-1);\\n            if(first!=-1)\\n            {\\n                int second = st.query(nums[i],first+1,0,0,st.size-1);\\n                if(second!=-1) res[i] = nums[second];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```\\nif(liked(\\u2764)==true) Upvote(\\u2B06);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn\\xA0Thank\\xA0You\\uD83D\\uDE01;\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct segtree {\\n    int size;\\n    vector<int> seg;\\n    void init(int n)\\n    {\\n        size = 1;\\n        while(size<=n)\\n        {\\n            size *=2;\\n        }\\n        seg.resize(4*size,0);\\n    }\\n    \\n    void build(int l,int r,int x,vector<int> &nums)\\n    {\\n        if(l == r)\\n        {\\n            if(l < nums.size())\\n            {\\n                seg[x] = nums[l];\\n            }\\n            return;\\n        }\\n        int mid = l + (r-l)/2;\\n        build(l,mid,2*x+1,nums);\\n        build(mid+1,r,2*x+2,nums);\\n        seg[x] = max(seg[2*x+1],seg[2*x+2]);\\n    }\\n    int query(int k,int l,int x,int lx,int rx)\\n    {\\n        if(seg[x] <=k || rx < l) return -1;\\n        if(lx == rx) return lx;\\n        int mid = lx + (rx-lx)/2;\\n        int res = query(k,l,2*x+1,lx,mid);\\n        if(res == -1)\\n        {\\n            res = query(k,l,2*x+2,mid+1,rx);\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        segtree st;\\n        st.init(n);\\n        st.build(0,st.size-1,0,nums);\\n        vector<int> res(n,-1);\\n        for(int i = 0; i < n; i++)\\n        {\\n            int first = st.query(nums[i],i+1,0,0,st.size-1);\\n            if(first!=-1)\\n            {\\n                int second = st.query(nums[i],first+1,0,0,st.size-1);\\n                if(second!=-1) res[i] = nums[second];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nif(liked(\\u2764)==true) Upvote(\\u2B06);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn\\xA0Thank\\xA0You\\uD83D\\uDE01;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765676,
                "title": "c-o-n-solution-using-3-stacks",
                "content": "class Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        \\n        //elements from stack1 whose 1st greater is found are pushed in stack2\\n        //stack2 contains elements whose 1st greater is found but second greater is not found\\n        //stack3 is a temporary stack which is used for pushing elements\\n        //from stack1 to stack2 in same order i.e non-increasing \\n        \\n        int n=nums.size();\\n        stack<int>st1;\\n        stack<int>st2;\\n        stack<int>st3;\\n        vector<int>res(n,-1);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st2.empty() && nums[i]>nums[st2.top()])\\n            {\\n                res[st2.top()]=nums[i];\\n                st2.pop();\\n            }\\n            while(!st1.empty() && nums[i]>nums[st1.top()])\\n            {\\n                st3.push(st1.top());\\n                st1.pop();\\n            }\\n            while(!st3.empty())\\n            {\\n                st2.push(st3.top());\\n                st3.pop();\\n            }\\n            st1.push(i);\\n        }\\n        return res;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        \\n        //elements from stack1 whose 1st greater is found are pushed in stack2\\n        //stack2 contains elements whose 1st greater is found but second greater is not found\\n        //stack3 is a temporary stack which is used for pushing elements\\n        //from stack1 to stack2 in same order i.e non-increasing \\n        \\n        int n=nums.size();\\n        stack<int>st1;\\n        stack<int>st2;\\n        stack<int>st3;\\n        vector<int>res(n,-1);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!st2.empty() && nums[i]>nums[st2.top()])\\n            {\\n                res[st2.top()]=nums[i];\\n                st2.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2764947,
                "title": "c-o-n-log-n-sort-set",
                "content": "```\\nbool comp(vector<int> &x, vector<int> &y) {\\n    if (x[0] != y[0]) return x[0] < y[0];\\n    return x[1] > y[1];\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& a) {\\n        vector<vector<int>> dat; \\n        for (int i = 0; i < a.size(); i++) {\\n            dat.push_back({a[i], i});\\n        }\\n        sort(dat.begin(), dat.end(), comp);\\n        vector<int> ans(a.size(),-1);\\n        set<int> got;\\n        for (int i = dat.size()-1; i >=0; i--) {\\n            auto it = got.upper_bound(dat[i][1]);\\n            if (it != got.end()) ++it;\\n            if (it != got.end()) ans[dat[i][1]] = a[*it];\\n            got.insert(dat[i][1]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool comp(vector<int> &x, vector<int> &y) {\\n    if (x[0] != y[0]) return x[0] < y[0];\\n    return x[1] > y[1];\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& a) {\\n        vector<vector<int>> dat; \\n        for (int i = 0; i < a.size(); i++) {\\n            dat.push_back({a[i], i});\\n        }\\n        sort(dat.begin(), dat.end(), comp);\\n        vector<int> ans(a.size(),-1);\\n        set<int> got;\\n        for (int i = dat.size()-1; i >=0; i--) {\\n            auto it = got.upper_bound(dat[i][1]);\\n            if (it != got.end()) ++it;\\n            if (it != got.end()) ans[dat[i][1]] = a[*it];\\n            got.insert(dat[i][1]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764918,
                "title": "java-time-o-nlogn-space-o-n-or-o-logn-sorting-treeset-orderedset-k-th-greater",
                "content": "```\\n\\n//1. sort in descending order of nums[i], and ascending order of index i\\n//2. create an ordered set, in Java, we use treeset\\n//3. traverse the sorted array and get k-th greater element.\\n\\n//Example\\n//[2,4,0,9,6]\\n\\n//1. sort\\n//[[2,0],[4,1],[0,2],[9,3],[6,4]] => [[9,3],[6,4],[4,1],[2,0],[0,2]]\\n\\n//2. create a treeset and we traverse the above array\\n\\n//processing, [9,3], treeset is empty, so i = 3 has no greater element, result[i=3] = -1\\n// add 3 into the treeset, treeset = {3}\\n\\n//processing [6,4], treeset has element {3}, but it is not after i=4, so no greater element, result[i=4] = -1\\n// add 4 into the treeset, treeset = {3,4}, note that treeset stores indices.\\n\\n//processing [4,1], treeset has element {3,4}, and both are after i=1, first greater is i=3\\n//next greater is i=4, and nums[i=4] = 6, perfect, result[i=1] = 6\\n//add i=1 into the treeset, treeset = {1,3,4}\\n\\n//processing [2,0], treeset has element {1,3,4}, and all are after i=0, first greater is i=1,\\n//next greater is i = 3, nums[i=3] = 9, result[i=0] = 9\\n//add i = 0 into the treeset, treeset = {0,1,3,4}\\n\\n//finally, we process [0,2], treeset has element {0,1,3,4}, and i = 2 should be between 1 and 3\\n//so first greater is i=3, and next greater is i=4, and nums[i=4] = 6, so result[i=2] = 4\\n//add i=2 into the treeset, treeset = {0,1,2,3,4} and that is all.\\n\\n//finally, we get our result = [9, 6, 6, -1, -1]\\n\\n//this approach performs way slower than using a stack and a priority queue, but you can\\n//generalize the result and can be a great follow-up question practice.\\n\\n//complexity is sorting and binary search, so its O(nlogn), notice that treeset uses red\\n//black tree, so complexity is O(nlogn) and extra space is either O(n) or O(logn) depends on\\n//the language you use, in java it is O(log n)\\n\\n\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int n = nums.length;\\n        List<int[]> list = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            list.add(new int[]{nums[i],i});\\n        int[] result = new int[n];\\n        Arrays.fill(result, -1);\\n        \\n        Collections.sort(list,(a,b)->(a[0]==b[0]?a[1]-b[1]:b[0]-a[0]));\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int[] l:list){\\n            int val = l[0], index = l[1];\\n            Integer h = set.higher(index);\\n            if(h!=null&&set.higher(h)!=null)\\n                result[index] = nums[set.higher(h)];\\n            \\n            set.add(index);\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Tree",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n\\n//1. sort in descending order of nums[i], and ascending order of index i\\n//2. create an ordered set, in Java, we use treeset\\n//3. traverse the sorted array and get k-th greater element.\\n\\n//Example\\n//[2,4,0,9,6]\\n\\n//1. sort\\n//[[2,0],[4,1],[0,2],[9,3],[6,4]] => [[9,3],[6,4],[4,1],[2,0],[0,2]]\\n\\n//2. create a treeset and we traverse the above array\\n\\n//processing, [9,3], treeset is empty, so i = 3 has no greater element, result[i=3] = -1\\n// add 3 into the treeset, treeset = {3}\\n\\n//processing [6,4], treeset has element {3}, but it is not after i=4, so no greater element, result[i=4] = -1\\n// add 4 into the treeset, treeset = {3,4}, note that treeset stores indices.\\n\\n//processing [4,1], treeset has element {3,4}, and both are after i=1, first greater is i=3\\n//next greater is i=4, and nums[i=4] = 6, perfect, result[i=1] = 6\\n//add i=1 into the treeset, treeset = {1,3,4}\\n\\n//processing [2,0], treeset has element {1,3,4}, and all are after i=0, first greater is i=1,\\n//next greater is i = 3, nums[i=3] = 9, result[i=0] = 9\\n//add i = 0 into the treeset, treeset = {0,1,3,4}\\n\\n//finally, we process [0,2], treeset has element {0,1,3,4}, and i = 2 should be between 1 and 3\\n//so first greater is i=3, and next greater is i=4, and nums[i=4] = 6, so result[i=2] = 4\\n//add i=2 into the treeset, treeset = {0,1,2,3,4} and that is all.\\n\\n//finally, we get our result = [9, 6, 6, -1, -1]\\n\\n//this approach performs way slower than using a stack and a priority queue, but you can\\n//generalize the result and can be a great follow-up question practice.\\n\\n//complexity is sorting and binary search, so its O(nlogn), notice that treeset uses red\\n//black tree, so complexity is O(nlogn) and extra space is either O(n) or O(logn) depends on\\n//the language you use, in java it is O(log n)\\n\\n\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int n = nums.length;\\n        List<int[]> list = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            list.add(new int[]{nums[i],i});\\n        int[] result = new int[n];\\n        Arrays.fill(result, -1);\\n        \\n        Collections.sort(list,(a,b)->(a[0]==b[0]?a[1]-b[1]:b[0]-a[0]));\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for(int[] l:list){\\n            int val = l[0], index = l[1];\\n            Integer h = set.higher(index);\\n            if(h!=null&&set.higher(h)!=null)\\n                result[index] = nums[set.higher(h)];\\n            \\n            set.add(index);\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764797,
                "title": "golang-123-ms-8-5-mb",
                "content": "```\\nfunc secondGreaterElement(nums []int) []int {\\n\\ts1 := make([]int32, 0, 1)\\n\\ts2 := make([]int32, 0, 1)\\n\\n\\tfor i, num := range nums {\\n\\t\\tfor len(s2) != 0 && nums[s2[len(s2)-1]] < num {\\n\\t\\t\\tnums[s2[len(s2)-1]] = num\\n\\t\\t\\ts2 = s2[:len(s2)-1]\\n\\t\\t}\\n\\n\\t\\tidx := sort.Search(len(s1), func(i int) bool {\\n\\t\\t\\treturn nums[s1[i]] < num\\n\\t\\t})\\n\\t\\tif idx == len(s1) {\\n\\t\\t\\ts1 = append(s1, int32(i))\\n\\t\\t} else {\\n\\t\\t\\ts2 = append(s2, s1[idx:]...)\\n\\t\\t\\ts1[idx] = int32(i)\\n\\t\\t\\ts1 = s1[:idx+1]\\n\\t\\t}\\n\\t}\\n\\tfor _, s := range [...][]int32{s1, s2} {\\n\\t\\tfor _, idx := range s {\\n\\t\\t\\tnums[idx] = -1\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc secondGreaterElement(nums []int) []int {\\n\\ts1 := make([]int32, 0, 1)\\n\\ts2 := make([]int32, 0, 1)\\n\\n\\tfor i, num := range nums {\\n\\t\\tfor len(s2) != 0 && nums[s2[len(s2)-1]] < num {\\n\\t\\t\\tnums[s2[len(s2)-1]] = num\\n\\t\\t\\ts2 = s2[:len(s2)-1]\\n\\t\\t}\\n\\n\\t\\tidx := sort.Search(len(s1), func(i int) bool {\\n\\t\\t\\treturn nums[s1[i]] < num\\n\\t\\t})\\n\\t\\tif idx == len(s1) {\\n\\t\\t\\ts1 = append(s1, int32(i))\\n\\t\\t} else {\\n\\t\\t\\ts2 = append(s2, s1[idx:]...)\\n\\t\\t\\ts1[idx] = int32(i)\\n\\t\\t\\ts1 = s1[:idx+1]\\n\\t\\t}\\n\\t}\\n\\tfor _, s := range [...][]int32{s1, s2} {\\n\\t\\tfor _, idx := range s {\\n\\t\\t\\tnums[idx] = -1\\n\\t\\t}\\n\\t}\\n\\treturn nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2763365,
                "title": "python-monotonic-stack-and-heap-solution",
                "content": "Eg: [2,4,0,9,6]\\nAlgorithm:\\n1. Find next greater element for each element and store them in list such that \\n  nextG[i]->[ ] each index is list of nums for all the indices this element was next greater element.\\n  Eg:nextG=[[], [0], [], [2, 1], []] \\n  \\n2.   For finding the second largest element, consider heap and iterate over nextG\\n\\tFor a particular index:\\n\\t\\t* \\tCheck the top elment of heap is smaller then nextG,then this heap\\'s top element\\'s 2 greater element is the current particular index ->Loop till top element is smaller\\n\\t\\t* Push all current list for partiuclar index in heap for whihc next elements will be 2nd greater element.\\n\\t\\t\\theap-> (nums[i] ,index) \\n\\t\\t\\tEg.i==3 in nextG (0,2),(4,1) is getting pushed in heap\\n\\n\\n\\n```    \\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        \\n        nextG=[[] for i in range(0,len(nums))]\\n        print(nextG)\\n        stack=[]\\n        for i in range(0,len(nums)):\\n            \\n            while(len(stack)!=0 and nums[stack[-1]]<nums[i]):\\n                nextG[i].append(stack.pop())\\n            stack.append(i)    \\n        print(nextG)         \\n        \\n        heap=[]\\n        sol=[-1]*len(nums)\\n        for i in range(0,len(nums)):\\n            while(len(heap)!=0 and heap[0][0]<nums[i]):\\n                sol[heappop(heap)[1]]=nums[i]\\n            for j in range(0,len(nextG[i])):\\n                heappush(heap,(nums[nextG[i][j]],nextG[i][j]))\\n        print(sol)\\n        return sol        \\n\\n\\n```\\n\\nComplexity: \\nTime(O(nlogn))\\nLoop and heap are in indirect variation\\nWorst complexity of heap , For Loop will be in best complexity whereas vice-versa.\\nSpace O(n)",
                "solutionTags": [],
                "code": "```    \\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        \\n        nextG=[[] for i in range(0,len(nums))]\\n        print(nextG)\\n        stack=[]\\n        for i in range(0,len(nums)):\\n            \\n            while(len(stack)!=0 and nums[stack[-1]]<nums[i]):\\n                nextG[i].append(stack.pop())\\n            stack.append(i)    \\n        print(nextG)         \\n        \\n        heap=[]\\n        sol=[-1]*len(nums)\\n        for i in range(0,len(nums)):\\n            while(len(heap)!=0 and heap[0][0]<nums[i]):\\n                sol[heappop(heap)[1]]=nums[i]\\n            for j in range(0,len(nextG[i])):\\n                heappush(heap,(nums[nextG[i][j]],nextG[i][j]))\\n        print(sol)\\n        return sol        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763307,
                "title": "java-beats-100-single-pass-no-stack-solution",
                "content": "Here we maintain a right array to get the next greater element at every index to its right side(just like we do in next greater element question).\\n\\nAfter this we further check for the positions right of the next greater element and if we find one more number we add it to the ans array otherwise we add -1. \\n\\n```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] right=new int[nums.length];\\n        Arrays.fill(right,-1);\\n        int ans[]=new int[nums.length];\\n        Arrays.fill(ans,-1);\\n        for(int i=nums.length-2;i>=0;i--){\\n            int j=i+1;\\n            \\n            while(j!=-1 &&nums[j]<=nums[i]){\\n                j=right[j];\\n            }\\n            right[i]=j;\\n            if(j!=-1 && j<nums.length-1){\\n               j=j+1;\\n                \\n                 while(j!=-1 &&nums[j]<=nums[i]){\\n                j=right[j];\\n            }\\n                if(j!=-1)ans[i]=nums[j];\\n                }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] right=new int[nums.length];\\n        Arrays.fill(right,-1);\\n        int ans[]=new int[nums.length];\\n        Arrays.fill(ans,-1);\\n        for(int i=nums.length-2;i>=0;i--){\\n            int j=i+1;\\n            \\n            while(j!=-1 &&nums[j]<=nums[i]){\\n                j=right[j];\\n            }\\n            right[i]=j;\\n            if(j!=-1 && j<nums.length-1){\\n               j=j+1;\\n                \\n                 while(j!=-1 &&nums[j]<=nums[i]){\\n                j=right[j];\\n            }\\n                if(j!=-1)ans[i]=nums[j];\\n                }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762722,
                "title": "java-monotonically-decreasing-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        int idx;\\n        int val;\\n        public Pair(int idx, int val) {\\n            this.idx = idx;\\n            this.val = val;\\n        }\\n        public int compareTo(Pair a){\\n            if(this.val == a.val) return this.idx - a.idx;\\n            return this.val - a.val;\\n        }\\n    }\\n\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] result = new int[nums.length];\\n\\n        Arrays.fill(result, -1);\\n        Stack<Integer> stack = new Stack<>();\\n        HashMap<Integer, TreeSet<Pair>> maps = new HashMap<>();\\n\\n        stack.push(nums.length - 1);\\n        for(int i = nums.length - 2; i >= 0; i--) {\\n            while(!stack.isEmpty()) {\\n                if(nums[stack.peek()] > nums[i]) {\\n                    maps.computeIfAbsent(stack.peek(), v -> new TreeSet<>()).add(new Pair(i, nums[i]));\\n                    break;\\n                }\\n                stack.pop();\\n            }\\n            stack.push(i);\\n        }\\n        \\n        stack.clear();\\n\\n        stack.push(nums[nums.length - 1]);\\n\\n        for(int i = nums.length - 2; i >= 0; i--) {\\n            if(maps.containsKey(i)) {\\n                for(Pair p : maps.get(i)) {\\n                    while(!stack.isEmpty() && stack.peek() <= p.val) stack.pop();\\n                    if(!stack.isEmpty()) result[p.idx] = stack.peek();\\n                }\\n            }\\n\\n            while(!stack.isEmpty()) {\\n                if(nums[i] >= stack.peek()) stack.pop();\\n                else break;\\n            }\\n            stack.push(nums[i]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        int idx;\\n        int val;\\n        public Pair(int idx, int val) {\\n            this.idx = idx;\\n            this.val = val;\\n        }\\n        public int compareTo(Pair a){\\n            if(this.val == a.val) return this.idx - a.idx;\\n            return this.val - a.val;\\n        }\\n    }\\n\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] result = new int[nums.length];\\n\\n        Arrays.fill(result, -1);\\n        Stack<Integer> stack = new Stack<>();\\n        HashMap<Integer, TreeSet<Pair>> maps = new HashMap<>();\\n\\n        stack.push(nums.length - 1);\\n        for(int i = nums.length - 2; i >= 0; i--) {\\n            while(!stack.isEmpty()) {\\n                if(nums[stack.peek()] > nums[i]) {\\n                    maps.computeIfAbsent(stack.peek(), v -> new TreeSet<>()).add(new Pair(i, nums[i]));\\n                    break;\\n                }\\n                stack.pop();\\n            }\\n            stack.push(i);\\n        }\\n        \\n        stack.clear();\\n\\n        stack.push(nums[nums.length - 1]);\\n\\n        for(int i = nums.length - 2; i >= 0; i--) {\\n            if(maps.containsKey(i)) {\\n                for(Pair p : maps.get(i)) {\\n                    while(!stack.isEmpty() && stack.peek() <= p.val) stack.pop();\\n                    if(!stack.isEmpty()) result[p.idx] = stack.peek();\\n                }\\n            }\\n\\n            while(!stack.isEmpty()) {\\n                if(nums[i] >= stack.peek()) stack.pop();\\n                else break;\\n            }\\n            stack.push(nums[i]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762574,
                "title": "next-greater-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we have to find the next greater element \\nso we have to implement next greater element \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Apply next greater element concept but this store the indexes not the element\\n2.iterative for next greater element array \\n3.set a variable ind=greater[i]+1\\n4.check the condition \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nas we are iterative one loop for n times so T.C.:-O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nas we are using stack and vector to store the answer  so S.C.:-O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n     int n=nums.size();\\n     vector<int>ans(n),ngr(n,n);\\n     stack<int>s;\\n     for(int i=n-1;i>=0;i--)\\n     {\\n         while(!s.empty() && nums[s.top()]<=nums[i]) s.pop();\\n         \\n         if(!s.empty()) ngr[i]=s.top();\\n         \\n         s.push(i);\\n     }\\n        for(int i=0;i<n;i++)\\n        {\\n            int ind=ngr[i]+1;\\n            \\n            while(ind<n && nums[i]>=nums[ind]) \\n            {\\n                ind=ngr[ind];\\n            }\\n            if(ind>=n) ans[i]=-1;\\n            \\n            else ans[i]=nums[ind];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n     int n=nums.size();\\n     vector<int>ans(n),ngr(n,n);\\n     stack<int>s;\\n     for(int i=n-1;i>=0;i--)\\n     {\\n         while(!s.empty() && nums[s.top()]<=nums[i]) s.pop();\\n         \\n         if(!s.empty()) ngr[i]=s.top();\\n         \\n         s.push(i);\\n     }\\n        for(int i=0;i<n;i++)\\n        {\\n            int ind=ngr[i]+1;\\n            \\n            while(ind<n && nums[i]>=nums[ind]) \\n            {\\n                ind=ngr[ind];\\n            }\\n            if(ind>=n) ans[i]=-1;\\n            \\n            else ans[i]=nums[ind];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762383,
                "title": "python-o-nlogn-monotonic-stack-sortedlist",
                "content": "```\\nfrom bisect import bisect\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        if len(nums) <= 2: return [-1] * len(nums)\\n        ans = [-1] * len(nums)\\n        stk, sl = [], SortedList()\\n        for i, v in enumerate(nums):\\n            pos = sl.bisect((v, -1)) - 1\\n            while pos >= 0:\\n                ans[sl.pop(pos)[1]] = v\\n                pos -= 1\\n            while stk and nums[stk[-1]] < v:\\n                sl.add((nums[stk[-1]], stk[-1]))\\n                stk.pop(-1)\\n            stk.append(i)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        if len(nums) <= 2: return [-1] * len(nums)\\n        ans = [-1] * len(nums)\\n        stk, sl = [], SortedList()\\n        for i, v in enumerate(nums):\\n            pos = sl.bisect((v, -1)) - 1\\n            while pos >= 0:\\n                ans[sl.pop(pos)[1]] = v\\n                pos -= 1\\n            while stk and nums[stk[-1]] < v:\\n                sl.add((nums[stk[-1]], stk[-1]))\\n                stk.pop(-1)\\n            stk.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761396,
                "title": "python-3-segment-tree-cache",
                "content": "Tried to solve with Python segment tree, TLE into a case with [8] * 49999 + [9] + [8] * 50000. Modified query slightly to load cached results if a same nums[i] with the same first greater element index encountered, and AC.\\n\\n```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        # monotonic dec stack to get index of the first greater element\\n        n = len(nums)\\n        g1 = [-1] * n\\n        stk = []\\n        for i, v in enumerate(nums):\\n            if not stk or v <= nums[stk[-1]]:\\n                stk.append(i)\\n            else:\\n                while stk and v > nums[stk[-1]]:\\n                    j = stk.pop()\\n                    g1[j] = i\\n                stk.append(i)\\n\\n        def build(node, l, r):\\n            if l == r:\\n                tree[node] = nums[l]\\n            else:\\n                mid = (l + r) // 2\\n                build(node * 2, l, mid)\\n                build(node * 2 + 1, mid + 1, r)\\n                tree[node] = tree[node * 2] + tree[node * 2 + 1]\\n        \\n        def query(node, l, r, s, val):\\n            if r < s or tree[node] <= val:\\n                return -1\\n            if l == r:\\n                return nums[l]\\n            mid = (l + r) // 2\\n            ansl = query(node * 2, l, mid, s, val)\\n            if ansl > -1:\\n                return ansl\\n            return query(node * 2 + 1, mid + 1, r, s, val)\\n        \\n        # for each nums[i], segment tree to query the first element > nums[i] from g1[i] to n - 1\\n        tree = [0] * (4 * n)\\n        build(1, 0, n - 1)\\n        ans = [-1] * n\\n        cac = {}\\n        for i in range(n):\\n            j = g1[i]\\n            if j > -1:\\n                # cache the results, otherwise TLE for a case with\\n                # [8] * 49999 + [9] + [8] * 50000\\n                if (nums[i], j) not in cac:\\n                    ans[i] = query(1, 0, n - 1, j + 1, nums[i]) # query g1[i] to n - 1\\n                    cac[(nums[i], j)] = ans[i]\\n                else:\\n                    ans[i] = cac[(nums[i], j)]\\n        return ans\\n```",
                "solutionTags": [
                    "Tree",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        # monotonic dec stack to get index of the first greater element\\n        n = len(nums)\\n        g1 = [-1] * n\\n        stk = []\\n        for i, v in enumerate(nums):\\n            if not stk or v <= nums[stk[-1]]:\\n                stk.append(i)\\n            else:\\n                while stk and v > nums[stk[-1]]:\\n                    j = stk.pop()\\n                    g1[j] = i\\n                stk.append(i)\\n\\n        def build(node, l, r):\\n            if l == r:\\n                tree[node] = nums[l]\\n            else:\\n                mid = (l + r) // 2\\n                build(node * 2, l, mid)\\n                build(node * 2 + 1, mid + 1, r)\\n                tree[node] = tree[node * 2] + tree[node * 2 + 1]\\n        \\n        def query(node, l, r, s, val):\\n            if r < s or tree[node] <= val:\\n                return -1\\n            if l == r:\\n                return nums[l]\\n            mid = (l + r) // 2\\n            ansl = query(node * 2, l, mid, s, val)\\n            if ansl > -1:\\n                return ansl\\n            return query(node * 2 + 1, mid + 1, r, s, val)\\n        \\n        # for each nums[i], segment tree to query the first element > nums[i] from g1[i] to n - 1\\n        tree = [0] * (4 * n)\\n        build(1, 0, n - 1)\\n        ans = [-1] * n\\n        cac = {}\\n        for i in range(n):\\n            j = g1[i]\\n            if j > -1:\\n                # cache the results, otherwise TLE for a case with\\n                # [8] * 49999 + [9] + [8] * 50000\\n                if (nums[i], j) not in cac:\\n                    ans[i] = query(1, 0, n - 1, j + 1, nums[i]) # query g1[i] to n - 1\\n                    cac[(nums[i], j)] = ans[i]\\n                else:\\n                    ans[i] = cac[(nums[i], j)]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761086,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums)\\n    {\\n        stack<int> s1, s2, temp;\\n        \\n        int n = nums.size();\\n        \\n        vector<int> res(n,-1);\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            while(!s2.empty() && nums[s2.top()] < nums[i])\\n            {\\n                res[s2.top()] = nums[i];\\n                \\n                s2.pop();\\n            }\\n            \\n            while(!s1.empty() && nums[s1.top()] < nums[i])\\n            {\\n                temp.push(s1.top());\\n                s1.pop();\\n            }\\n            \\n            while(!temp.empty())\\n            {\\n                s2.push(temp.top());\\n                temp.pop();\\n            }\\n            \\n            s1.push(i);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums)\\n    {\\n        stack<int> s1, s2, temp;\\n        \\n        int n = nums.size();\\n        \\n        vector<int> res(n,-1);\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            while(!s2.empty() && nums[s2.top()] < nums[i])\\n            {\\n                res[s2.top()] = nums[i];\\n                \\n                s2.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2761072,
                "title": "short-and-simple-o-n",
                "content": "```\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        vector<int> s1, s2;\\n        int N = nums.size();\\n        vector<int> res(N, -1);\\n        for (int i = 0; i < N; i++) {\\n            // s1: nums not found first greater element\\n            // s2: nums found first greater, but not 2nd greater\\n            while(s2.size() && nums[s2.back()] < nums[i]) {\\n                res[s2.back()] = nums[i];\\n                s2.pop_back();\\n            }\\n            \\n            // move number from s1 to s2 after first greater is found\\n            int cnt = 0;\\n            while(s1.size() && nums[s1.back()] < nums[i]) {\\n                s2.push_back(s1.back());\\n                cnt++;\\n                s1.pop_back();\\n            }\\n            \\n            // every number will only appear in s1 and s2 once, and reverse once\\n            // complexity: O(N)\\n            reverse(s2.end()-cnt, s2.end());\\n            \\n            s1.push_back(i);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        vector<int> s1, s2;\\n        int N = nums.size();\\n        vector<int> res(N, -1);\\n        for (int i = 0; i < N; i++) {\\n            // s1: nums not found first greater element\\n            // s2: nums found first greater, but not 2nd greater\\n            while(s2.size() && nums[s2.back()] < nums[i]) {\\n                res[s2.back()] = nums[i];\\n                s2.pop_back();\\n            }\\n            \\n            // move number from s1 to s2 after first greater is found\\n            int cnt = 0;\\n            while(s1.size() && nums[s1.back()] < nums[i]) {\\n                s2.push_back(s1.back());\\n                cnt++;\\n                s1.pop_back();\\n            }\\n            \\n            // every number will only appear in s1 and s2 once, and reverse once\\n            // complexity: O(N)\\n            reverse(s2.end()-cnt, s2.end());\\n            \\n            s1.push_back(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2760827,
                "title": "c-stack-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> arr(n,-1);\\n        stack<int> st;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[st.top()]<=nums[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            if(!st.empty()) arr[i] = st.top();\\n            st.push(i);\\n        }\\n        \\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i] == -1) continue;\\n            \\n            int ind = arr[i]+1;\\n            while(ind != -1 && ind<n && nums[ind]<=nums[i])\\n            {\\n                ind = arr[ind];\\n            }\\n            if(ind != -1 && ind<n)\\n            {\\n                ans[i] = nums[ind];\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> arr(n,-1);\\n        stack<int> st;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[st.top()]<=nums[i])\\n            {\\n                st.pop();\\n            }\\n            \\n            if(!st.empty()) arr[i] = st.top();\\n            st.push(i);\\n        }\\n        \\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i] == -1) continue;\\n            \\n            int ind = arr[i]+1;\\n            while(ind != -1 && ind<n && nums[ind]<=nums[i])\\n            {\\n                ind = arr[ind];\\n            }\\n            if(ind != -1 && ind<n)\\n            {\\n                ans[i] = nums[ind];\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760535,
                "title": "how",
                "content": "how is this solution correct?\\nfinding the next greater element for first time will lost some elements which create the problem for second time.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2760422,
                "title": "java-mono-stack",
                "content": "# 3.mono stack X 2\\n```\\n\\t//3.mono stack X 2\\n    //Runtime: 24 ms, faster than 100.00% of Java online submissions for Next Greater Element IV.\\n    //Memory Usage: 57.2 MB, less than 88.89% of Java online submissions for Next Greater Element IV.\\n    //Time: O(N); Space: O(N)\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] res = new int[nums.length];\\n        Arrays.fill(res, -1);\\n\\n        Deque<Integer> stack1 = new ArrayDeque<>(); //first\\n        Deque<Integer> stack2 = new ArrayDeque<>(); //second\\n        Deque<Integer> tmp = new ArrayDeque<>();\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            while (!stack2.isEmpty() && nums[i] > nums[stack2.peek()])\\n                res[stack2.pop()] = nums[i];\\n\\n            while (!stack1.isEmpty() && nums[i] > nums[stack1.peek()])\\n                tmp.push(stack1.pop());\\n\\n            while(!tmp.isEmpty())\\n                stack2.push(tmp.pop());\\n\\n            stack1.push(i);\\n        }\\n        return res;\\n    }\\n\\n```\\n# 2. mono stack\\n```\\n    //2. mono stack\\n    //Runtime: 39 ms, faster than 77.78% of Java online submissions for Next Greater Element IV.\\n    //Memory Usage: 105.6 MB, less than 11.11% of Java online submissions for Next Greater Element IV.\\n    //Time: O(N + N * N); Space: O(N)\\n    public int[] secondGreaterElement_2(int[] nums) {\\n        int[] res = new int[nums.length];\\n        Arrays.fill(res, -1);\\n\\n        //first larger\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            while (!stack.isEmpty() && nums[i] > nums[stack.peekLast()])\\n                res[stack.pollLast()] = i;\\n            stack.add(i);\\n        }\\n\\n        //search second larger\\n        for (int i = 0; i < res.length; i++) {\\n            if (res[i] == -1) continue;\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                res[i] = res[i - 1]; continue;\\n            }\\n\\n            int secondIdx = res[i];\\n            for (int j = secondIdx + 1; j < nums.length; j++) {\\n                if (nums[j] > nums[i]) {\\n                    secondIdx = j; break;\\n                }\\n            }\\n            res[i] = secondIdx == res[i] ? -1 : nums[secondIdx];\\n        }\\n        return res;\\n    }\\n\\n```\\n# 1. Slide window\\n```\\n    //1. Slide window\\n    //TLE\\n    //Time: O(N * N); Space: O(1)\\n    public int[] secondGreaterElement_1(int[] nums) {\\n        int[] res = new int[nums.length];\\n        Arrays.fill(res,-1);\\n        if (nums.length <= 2) return res;\\n\\n        int left = 0, right = 1;\\n        int k = 0;\\n        while (left < nums.length - 2) {\\n\\n            if (nums[right++] > nums[left]) k++;\\n\\n            if (k == 2 || right == nums.length){\\n                res[left] = k == 2 ? nums[right - 1] :  -1;\\n                left++;\\n                while (left < nums.length - 2 && nums[left] == nums[left - 1]) {\\n                    res[left] = res[left - 1];\\n                    left++;\\n                }\\n\\n                if (right == nums.length) {\\n                    while (left < nums.length - 2 && nums[left] >= nums[left - 1]) {\\n                        res[left] = res[left - 1];\\n                        left++;\\n                    }\\n                }\\n\\n                if (k == 2 && right - left> 2 && left < nums.length - 2 && nums[left] > nums[left - 1]) {\\n                    k--;\\n                }else {\\n                    right = left + 1;\\n                    k = 0;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t//3.mono stack X 2\\n    //Runtime: 24 ms, faster than 100.00% of Java online submissions for Next Greater Element IV.\\n    //Memory Usage: 57.2 MB, less than 88.89% of Java online submissions for Next Greater Element IV.\\n    //Time: O(N); Space: O(N)\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] res = new int[nums.length];\\n        Arrays.fill(res, -1);\\n\\n        Deque<Integer> stack1 = new ArrayDeque<>(); //first\\n        Deque<Integer> stack2 = new ArrayDeque<>(); //second\\n        Deque<Integer> tmp = new ArrayDeque<>();\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            while (!stack2.isEmpty() && nums[i] > nums[stack2.peek()])\\n                res[stack2.pop()] = nums[i];\\n\\n            while (!stack1.isEmpty() && nums[i] > nums[stack1.peek()])\\n                tmp.push(stack1.pop());\\n\\n            while(!tmp.isEmpty())\\n                stack2.push(tmp.pop());\\n\\n            stack1.push(i);\\n        }\\n        return res;\\n    }\\n\\n```\n```\\n    //2. mono stack\\n    //Runtime: 39 ms, faster than 77.78% of Java online submissions for Next Greater Element IV.\\n    //Memory Usage: 105.6 MB, less than 11.11% of Java online submissions for Next Greater Element IV.\\n    //Time: O(N + N * N); Space: O(N)\\n    public int[] secondGreaterElement_2(int[] nums) {\\n        int[] res = new int[nums.length];\\n        Arrays.fill(res, -1);\\n\\n        //first larger\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            while (!stack.isEmpty() && nums[i] > nums[stack.peekLast()])\\n                res[stack.pollLast()] = i;\\n            stack.add(i);\\n        }\\n\\n        //search second larger\\n        for (int i = 0; i < res.length; i++) {\\n            if (res[i] == -1) continue;\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                res[i] = res[i - 1]; continue;\\n            }\\n\\n            int secondIdx = res[i];\\n            for (int j = secondIdx + 1; j < nums.length; j++) {\\n                if (nums[j] > nums[i]) {\\n                    secondIdx = j; break;\\n                }\\n            }\\n            res[i] = secondIdx == res[i] ? -1 : nums[secondIdx];\\n        }\\n        return res;\\n    }\\n\\n```\n```\\n    //1. Slide window\\n    //TLE\\n    //Time: O(N * N); Space: O(1)\\n    public int[] secondGreaterElement_1(int[] nums) {\\n        int[] res = new int[nums.length];\\n        Arrays.fill(res,-1);\\n        if (nums.length <= 2) return res;\\n\\n        int left = 0, right = 1;\\n        int k = 0;\\n        while (left < nums.length - 2) {\\n\\n            if (nums[right++] > nums[left]) k++;\\n\\n            if (k == 2 || right == nums.length){\\n                res[left] = k == 2 ? nums[right - 1] :  -1;\\n                left++;\\n                while (left < nums.length - 2 && nums[left] == nums[left - 1]) {\\n                    res[left] = res[left - 1];\\n                    left++;\\n                }\\n\\n                if (right == nums.length) {\\n                    while (left < nums.length - 2 && nums[left] >= nums[left - 1]) {\\n                        res[left] = res[left - 1];\\n                        left++;\\n                    }\\n                }\\n\\n                if (k == 2 && right - left> 2 && left < nums.length - 2 && nums[left] > nums[left - 1]) {\\n                    k--;\\n                }else {\\n                    right = left + 1;\\n                    k = 0;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2760318,
                "title": "o-nlogn-approach-using-set-of-vectors",
                "content": "```\\nclass Solution {\\n    vector<int> st;\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& a) {\\n        set<vector<int>> st;\\n        int n=a.size();\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++){\\n            vector<vector<int>> t;\\n            while(st.size()){\\n                vector<int> v=*st.begin();\\n                if(v[0]>=a[i])\\n                    break;\\n                st.erase(st.begin());\\n                v[1]++;\\n                if(v[1]<2)\\n                    t.push_back(v);\\n                else\\n                    ans[v[2]]=a[i];\\n            }\\n            st.insert({a[i],0,i});\\n            for(auto v:t)\\n                st.insert(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> st;\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& a) {\\n        set<vector<int>> st;\\n        int n=a.size();\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++){\\n            vector<vector<int>> t;\\n            while(st.size()){\\n                vector<int> v=*st.begin();\\n                if(v[0]>=a[i])\\n                    break;\\n                st.erase(st.begin());\\n                v[1]++;\\n                if(v[1]<2)\\n                    t.push_back(v);\\n                else\\n                    ans[v[2]]=a[i];\\n            }\\n            st.insert({a[i],0,i});\\n            for(auto v:t)\\n                st.insert(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760018,
                "title": "c-stack-solution-commented-code",
                "content": "**C++ code**\\n```\\n vector<int> secondGreaterElement(vector<int>& nums) {\\n       vector<int> ans(nums.size(),-1);\\n        \\n        stack<int> s1,s2,tmp;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            //update ans\\n            while(!s2.empty() && nums[s2.top()]<nums[i]){\\n                ans[s2.top()]=nums[i];\\n                s2.pop();\\n            }\\n            //if find first max go for second so push it to the s2 \\n            while(!s1.empty() && nums[s1.top()]<nums[i]){\\n                tmp.push_back(s1.top());\\n                s1.pop();\\n            }\\n            //this while is becoz we want all elm in decresing order\\n            while(!tmp.empty()){\\n                s2.push_back(tmp.top());\\n                tmp.pop();\\n            }\\n            s1.push_back(i);\\n        }\\n        return ans;\\n    }\\n\\t//code by sachin\\n```\\n**Upvote if solution was helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n vector<int> secondGreaterElement(vector<int>& nums) {\\n       vector<int> ans(nums.size(),-1);\\n        \\n        stack<int> s1,s2,tmp;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            //update ans\\n            while(!s2.empty() && nums[s2.top()]<nums[i]){\\n                ans[s2.top()]=nums[i];\\n                s2.pop();\\n            }\\n            //if find first max go for second so push it to the s2 \\n            while(!s1.empty() && nums[s1.top()]<nums[i]){\\n                tmp.push_back(s1.top());\\n                s1.pop();\\n            }\\n            //this while is becoz we want all elm in decresing order\\n            while(!tmp.empty()){\\n                s2.push_back(tmp.top());\\n                tmp.pop();\\n            }\\n            s1.push_back(i);\\n        }\\n        return ans;\\n    }\\n\\t//code by sachin\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2759647,
                "title": "java-stack-o-n",
                "content": "```\\n\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int length = nums.length, nextPosition = 0;\\n        int[] answer = new int[length];\\n        Stack<Integer> stack1 = new Stack<>(), stack2 = new Stack<>();\\n        List<Integer> nextPositions = null;\\n        Map<Integer, List<Integer>> cache = new HashMap<>();\\n        Arrays.fill(answer, -1);\\n        for(int index = (length - 1); index >= 0; index--) {\\n            while(!stack1.isEmpty() && (nums[index] >= nums[stack1.peek()])) {\\n                stack1.pop();\\n            }\\n            if(!stack1.isEmpty()) {\\n                nextPosition = (1 + stack1.peek());\\n                nextPositions = cache.getOrDefault(nextPosition, new ArrayList<>());\\n                nextPositions.add(index);\\n                cache.put(nextPosition, nextPositions);\\n            }\\n            stack1.push(index);\\n        }\\n        for(int index = (length - 1); index >= 0; index--) {\\n            stack2.push(index);\\n            for(int position : cache.getOrDefault(index, new ArrayList<>())) {\\n                while(!stack2.isEmpty() && (nums[position] >= nums[stack2.peek()])) {\\n                    stack2.pop();\\n                }\\n                if(!stack2.isEmpty()) {\\n                    answer[position] = nums[stack2.peek()];\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int length = nums.length, nextPosition = 0;\\n        int[] answer = new int[length];\\n        Stack<Integer> stack1 = new Stack<>(), stack2 = new Stack<>();\\n        List<Integer> nextPositions = null;\\n        Map<Integer, List<Integer>> cache = new HashMap<>();\\n        Arrays.fill(answer, -1);\\n        for(int index = (length - 1); index >= 0; index--) {\\n            while(!stack1.isEmpty() && (nums[index] >= nums[stack1.peek()])) {\\n                stack1.pop();\\n            }\\n            if(!stack1.isEmpty()) {\\n                nextPosition = (1 + stack1.peek());\\n                nextPositions = cache.getOrDefault(nextPosition, new ArrayList<>());\\n                nextPositions.add(index);\\n                cache.put(nextPosition, nextPositions);\\n            }\\n            stack1.push(index);\\n        }\\n        for(int index = (length - 1); index >= 0; index--) {\\n            stack2.push(index);\\n            for(int position : cache.getOrDefault(index, new ArrayList<>())) {\\n                while(!stack2.isEmpty() && (nums[position] >= nums[stack2.peek()])) {\\n                    stack2.pop();\\n                }\\n                if(!stack2.isEmpty()) {\\n                    answer[position] = nums[stack2.peek()];\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759521,
                "title": "swift-two-stacks-solution-o-n",
                "content": "# Approach\\nWe put element index into first stack. After we have found first greater element we move that index into second stack. After we have found second greater element we put it into result array.\\n\\n# Code\\n```\\nclass Solution {\\n    func secondGreaterElement(_ nums: [Int]) -> [Int] {\\n        var res: [Int] = .init(repeating: -1, count: nums.count)\\n        var s1: [Int] = []\\n        var s2: [Int] = []\\n\\n        for i in 0..<nums.count {\\n            var temp: [Int] = []\\n            while !s2.isEmpty && nums[s2.last!] < nums[i] {\\n                res[s2.removeLast()] = nums[i]\\n            }\\n            \\n            while !s1.isEmpty && nums[s1.last!] < nums[i] {\\n                temp.append(s1.removeLast())\\n            }\\n            \\n            s2 += temp.reversed()\\n            \\n            s1.append(i)\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func secondGreaterElement(_ nums: [Int]) -> [Int] {\\n        var res: [Int] = .init(repeating: -1, count: nums.count)\\n        var s1: [Int] = []\\n        var s2: [Int] = []\\n\\n        for i in 0..<nums.count {\\n            var temp: [Int] = []\\n            while !s2.isEmpty && nums[s2.last!] < nums[i] {\\n                res[s2.removeLast()] = nums[i]\\n            }\\n            \\n            while !s1.isEmpty && nums[s1.last!] < nums[i] {\\n                temp.append(s1.removeLast())\\n            }\\n            \\n            s2 += temp.reversed()\\n            \\n            s1.append(i)\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759129,
                "title": "my-python3-solution",
                "content": "```\\nclass Solution:\\n      def secondGreaterElement(self, A: List[int]) -> List[int]:\\n        res, s1, s2 = [-1] * len(A), [], []\\n        for i,a in enumerate(A):\\n            while s2 and A[s2[-1]] < a:\\n                res[s2.pop()] = a;\\n            tmp = []\\n            while s1 and A[s1[-1]] < a:\\n                tmp.append(s1.pop())\\n            s2 += tmp[::-1]\\n            s1.append(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n      def secondGreaterElement(self, A: List[int]) -> List[int]:\\n        res, s1, s2 = [-1] * len(A), [], []\\n        for i,a in enumerate(A):\\n            while s2 and A[s2[-1]] < a:\\n                res[s2.pop()] = a;\\n            tmp = []\\n            while s1 and A[s1[-1]] < a:\\n                tmp.append(s1.pop())\\n            s2 += tmp[::-1]\\n            s1.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758955,
                "title": "c-segment-tree-and-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[400002];\\n    int n;\\n    void build(int v, int tl, int tr) \\n    {\\n        if (tl == tr) {\\n            t[v] = -1;\\n        } else {\\n            int tm = (tl + tr) / 2;\\n            build( v*2, tl, tm);\\n            build( v*2+1, tm+1, tr);\\n            t[v] = max(t[v*2], t[v*2+1]);\\n        }\\n    }\\n    void upd(int node,int l,int r,int idx,int val)\\n    {\\n        if(l==r)\\n        {\\n            t[node]=val;\\n            return ;\\n        }\\n        int m=(l+r)/2;\\n        if(idx<=m)\\n        {\\n            upd(2*node,l,m,idx,val);\\n        }\\n        else\\n        {\\n            upd(2*node+1,m+1,r,idx,val);\\n        }\\n        t[node]=max(t[2*node],t[2*node+1]);\\n    }\\n    int query(int node,int i,int j,int l,int r,int x)\\n    {\\n        if((l>j) || (r<i))\\n            return n;\\n        \\n        if(l<=i&&j<=r)\\n        {\\n            if(t[node] <= x) \\n                return n;\\n            \\n            while(i < j) {\\n                int mid = (i+j)/2;\\n                if(t[2*node] > x)\\n                {\\n                    node = 2*node;\\n                    j = mid;\\n                }\\n                else \\n                {\\n                    node= 2*node+1;\\n                    i = mid+1;\\n                }\\n            }\\n            return i;\\n        }\\n        \\n        int m=(i+j)/2;\\n        int id=query(2*node,i,m,l,r,x);\\n        if(id!=n)\\n            return id;\\n        else\\n            return query(2*node+1,m+1,j,l,r,x);\\n    }\\n    \\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        n=nums.size();\\n        build(1,0,n-1);\\n        vector<int> res(n);\\n        vector<int> tmp(n);\\n        for(int i=0;i<n;++i)\\n        {\\n            tmp[i]=nums[i];\\n        }\\n        \\n        for(int i=n-1;i>=0;--i)\\n        {\\n            int x=query(1,0,n-1,i+1,n-1,tmp[i]);\\n            if(x>=n)\\n            {\\n                res[i]=-1;\\n            }\\n            else\\n            {\\n                int tp=tmp[x];\\n                upd(1,0,n-1,x,-1);\\n                int tpy=query(1,0,n-1,i+1,n-1,tmp[i]);\\n                cout<<tpy<<\" \";\\n                if(tpy>=n)\\n                {\\n                    res[i]=-1;\\n                }\\n                else\\n                {\\n                    res[i]=tmp[tpy];\\n                }\\n                upd(1,0,n-1,x,tp);\\n            }\\n            upd(1,0,n-1,i,tmp[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[400002];\\n    int n;\\n    void build(int v, int tl, int tr) \\n    {\\n        if (tl == tr) {\\n            t[v] = -1;\\n        } else {\\n            int tm = (tl + tr) / 2;\\n            build( v*2, tl, tm);\\n            build( v*2+1, tm+1, tr);\\n            t[v] = max(t[v*2], t[v*2+1]);\\n        }\\n    }\\n    void upd(int node,int l,int r,int idx,int val)\\n    {\\n        if(l==r)\\n        {\\n            t[node]=val;\\n            return ;\\n        }\\n        int m=(l+r)/2;\\n        if(idx<=m)\\n        {\\n            upd(2*node,l,m,idx,val);\\n        }\\n        else\\n        {\\n            upd(2*node+1,m+1,r,idx,val);\\n        }\\n        t[node]=max(t[2*node],t[2*node+1]);\\n    }\\n    int query(int node,int i,int j,int l,int r,int x)\\n    {\\n        if((l>j) || (r<i))\\n            return n;\\n        \\n        if(l<=i&&j<=r)\\n        {\\n            if(t[node] <= x) \\n                return n;\\n            \\n            while(i < j) {\\n                int mid = (i+j)/2;\\n                if(t[2*node] > x)\\n                {\\n                    node = 2*node;\\n                    j = mid;\\n                }\\n                else \\n                {\\n                    node= 2*node+1;\\n                    i = mid+1;\\n                }\\n            }\\n            return i;\\n        }\\n        \\n        int m=(i+j)/2;\\n        int id=query(2*node,i,m,l,r,x);\\n        if(id!=n)\\n            return id;\\n        else\\n            return query(2*node+1,m+1,j,l,r,x);\\n    }\\n    \\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        n=nums.size();\\n        build(1,0,n-1);\\n        vector<int> res(n);\\n        vector<int> tmp(n);\\n        for(int i=0;i<n;++i)\\n        {\\n            tmp[i]=nums[i];\\n        }\\n        \\n        for(int i=n-1;i>=0;--i)\\n        {\\n            int x=query(1,0,n-1,i+1,n-1,tmp[i]);\\n            if(x>=n)\\n            {\\n                res[i]=-1;\\n            }\\n            else\\n            {\\n                int tp=tmp[x];\\n                upd(1,0,n-1,x,-1);\\n                int tpy=query(1,0,n-1,i+1,n-1,tmp[i]);\\n                cout<<tpy<<\" \";\\n                if(tpy>=n)\\n                {\\n                    res[i]=-1;\\n                }\\n                else\\n                {\\n                    res[i]=tmp[tpy];\\n                }\\n                upd(1,0,n-1,x,tp);\\n            }\\n            upd(1,0,n-1,i,tmp[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2757753,
                "title": "python-monotonic-stack-binary-search",
                "content": "Did not come out with the O(N) solution. Here is one for O(NlogN)\\n```\\n   def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        A = nums \\n        n = len(A)\\n        pos = [-1]*n\\n        for i,a in enumerate(A):\\n            while stack and A[stack[-1]] < a:\\n                pos[stack[-1]] = i\\n                stack.pop()\\n            stack.append(i)\\n        ans = [-1]*n\\n        pos2i = defaultdict(list)\\n        for i,p in enumerate(pos):\\n            if p != -1:\\n                pos2i[p+1].append(i)\\n        stack = []\\n        def binarysearch(arr, x):\\n            l, r = 0, len(arr)\\n            while l < r:\\n                mid = l + (r-l)//2\\n                if arr[mid] > x:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n            return l-1\\n        for i in range(n-1, -1, -1):\\n            while stack and stack[-1] <= A[i]:\\n                stack.pop()\\n            stack.append(A[i])     \\n            if i in pos2i:\\n                for j in pos2i[i]:                    \\n                    idx = binarysearch(stack, A[j])\\n                    if idx >= 0:\\n                        ans[j] = stack[idx]\\n                    elif stack[idx+1] > A[j]:\\n                        ans[j] = stack[idx+1]\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Monotonic Stack",
                    "Binary Tree"
                ],
                "code": "```\\n   def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        A = nums \\n        n = len(A)\\n        pos = [-1]*n\\n        for i,a in enumerate(A):\\n            while stack and A[stack[-1]] < a:\\n                pos[stack[-1]] = i\\n                stack.pop()\\n            stack.append(i)\\n        ans = [-1]*n\\n        pos2i = defaultdict(list)\\n        for i,p in enumerate(pos):\\n            if p != -1:\\n                pos2i[p+1].append(i)\\n        stack = []\\n        def binarysearch(arr, x):\\n            l, r = 0, len(arr)\\n            while l < r:\\n                mid = l + (r-l)//2\\n                if arr[mid] > x:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n            return l-1\\n        for i in range(n-1, -1, -1):\\n            while stack and stack[-1] <= A[i]:\\n                stack.pop()\\n            stack.append(A[i])     \\n            if i in pos2i:\\n                for j in pos2i[i]:                    \\n                    idx = binarysearch(stack, A[j])\\n                    if idx >= 0:\\n                        ans[j] = stack[idx]\\n                    elif stack[idx+1] > A[j]:\\n                        ans[j] = stack[idx+1]\\n        return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2757699,
                "title": "python-three-stacks-o-n-100-faster-in-time-and-space",
                "content": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        heap = []\\n        res = [-1]*n\\n        stack_low = []\\n        stack_mid = []\\n        stack_high = []\\n        for i, num in enumerate(nums):\\n            while stack_high and nums[stack_high[-1]] < num:\\n                res[stack_high.pop()] = i\\n            while stack_low and nums[stack_low[-1]] < num:\\n                stack_mid.append(stack_low.pop())\\n            while stack_mid:\\n                stack_high.append(stack_mid.pop())\\n            stack_low.append(i)\\n        return [ (nums[v] if v != -1 else -1) for v in res]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        heap = []\\n        res = [-1]*n\\n        stack_low = []\\n        stack_mid = []\\n        stack_high = []\\n        for i, num in enumerate(nums):\\n            while stack_high and nums[stack_high[-1]] < num:\\n                res[stack_high.pop()] = i\\n            while stack_low and nums[stack_low[-1]] < num:\\n                stack_mid.append(stack_low.pop())\\n            while stack_mid:\\n                stack_high.append(stack_mid.pop())\\n            stack_low.append(i)\\n        return [ (nums[v] if v != -1 else -1) for v in res]",
                "codeTag": "Java"
            },
            {
                "id": 2757665,
                "title": "java-easy-understood-o-n-logn-time-o-n-space-treeset",
                "content": "The idea is learnt from [@yxc\\'s video](https://www.bilibili.com/video/BV1Z14y157rZ/?spm_id_from=333.337.search-card.all.click&vd_source=1e76c6792d63c37f5b33ade7d74b6a87).\\n\\n## Intuition\\nInstead of finding next 2nd greater element, we iterate the array **from largest value to smallest value.**\\n\\nWhen traversing, we store current `idx` into `treeSet`. In this case, we can use `treeSet.higher(idx)` to find next first greater. Then we use it again to find second greater.\\n\\nIn order to traverse in descending order, I am using `int[][] nodes` where each node has `{idx, val}` for original `nums`. Then sort `nodes` based on `node[1]`;\\n\\n## Code\\n```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        TreeSet<Integer> treeSet = new TreeSet<>();\\n        // [idx, value], value descending, \\n        int[][] nodes = new int[nums.length][2];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            nodes[i] = new int[]{i, nums[i]};\\n        }\\n        // sort by val descending order\\n        Arrays.sort(nodes, (a, b) -> (b[1] - a[1]));\\n        int[] ret = new int[nums.length];\\n        \\n        // traverse from largest value to smallest\\n        for (int[] node : nodes) {\\n            int val = node[1];\\n            int idx = node[0];\\n            // get idx 2nd greater element in treeSet\\n            if (treeSet.size() < 2) ret[idx] = -1;\\n            else {\\n                Integer next = treeSet.higher(idx);\\n                if (next == null) ret[idx] = -1;\\n                else {\\n                    Integer nnext = treeSet.higher(next);\\n                    if (nnext == null) ret[idx] = -1;\\n                    else ret[idx] = nums[nnext];\\n                }\\n            }\\n            \\n            treeSet.add(idx);\\n        }\\n        \\n        return ret;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        TreeSet<Integer> treeSet = new TreeSet<>();\\n        // [idx, value], value descending, \\n        int[][] nodes = new int[nums.length][2];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            nodes[i] = new int[]{i, nums[i]};\\n        }\\n        // sort by val descending order\\n        Arrays.sort(nodes, (a, b) -> (b[1] - a[1]));\\n        int[] ret = new int[nums.length];\\n        \\n        // traverse from largest value to smallest\\n        for (int[] node : nodes) {\\n            int val = node[1];\\n            int idx = node[0];\\n            // get idx 2nd greater element in treeSet\\n            if (treeSet.size() < 2) ret[idx] = -1;\\n            else {\\n                Integer next = treeSet.higher(idx);\\n                if (next == null) ret[idx] = -1;\\n                else {\\n                    Integer nnext = treeSet.higher(next);\\n                    if (nnext == null) ret[idx] = -1;\\n                    else ret[idx] = nums[nnext];\\n                }\\n            }\\n            \\n            treeSet.add(idx);\\n        }\\n        \\n        return ret;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757605,
                "title": "javascript-monostack-heap",
                "content": "use first first stack to track elements searching for 1st greatest element\\nsecond stack to track elements searching for 2nd greatest element\\nmust use heap for the second stack so that we dont cover smaller elements when we push them into the 2nd stack\\n```\\nvar secondGreaterElement = function(nums) {\\n    let monoStack1 = []\\n    let monoStack2 = new MinPriorityQueue({priority: (a) => a[0]})\\n    let res = Array(nums.length).fill(-1)\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i]\\n        while (monoStack2.size() && monoStack2.front().element[0] < num) {\\n            res[monoStack2.dequeue().element[1]] = num\\n        }\\n        while (monoStack1.length && monoStack1.at(-1)[0] < num) {\\n            monoStack2.enqueue((monoStack1.pop()))\\n        }\\n        monoStack1.push([num, i])\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar secondGreaterElement = function(nums) {\\n    let monoStack1 = []\\n    let monoStack2 = new MinPriorityQueue({priority: (a) => a[0]})\\n    let res = Array(nums.length).fill(-1)\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i]\\n        while (monoStack2.size() && monoStack2.front().element[0] < num) {\\n            res[monoStack2.dequeue().element[1]] = num\\n        }\\n        while (monoStack1.length && monoStack1.at(-1)[0] < num) {\\n            monoStack2.enqueue((monoStack1.pop()))\\n        }\\n        monoStack1.push([num, i])\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2757556,
                "title": "one-pass-stack-solution-o-n-guarantee-easy-to-understand",
                "content": "It should be standard knowledge to get next greater elements in an array using monostack to achieve O(n), e.g., for nums = [2 4 0 9 6], we should obtain [1 3 3 -1 -1] as the indices of their next greater elements. Using the nums[0] = 2 as an example, it tells you that its next greater element is at nums[1] which is 4. Easy and straightforward.\\n\\nThen from here how do we get its 2nd greater element? **This can be done by pretending to put 2 at the position of 4 and wait for the next element greater than 2 to come.**\\n\\nSo we still use a primary (mono-)stack as we did before which stores pairs of `{i, j}` meaning `nums[i]` and its next greater element index `j`. The initial `j` is `-1`.\\n\\nWhen a greater element `nums[k]` arrives, we check whether `nums[i]` in `{i, j}` is less than `nums[k]`, if so, check if \\'j\\' is `-1`, if `j` is already modified to some indices, we know `res[i]` should be `nums[k]`. Otherwise, after `{k, -1}` is pushed to the stack we continue to push `{i, k}` into the stack, indicating that `nums[k]` is the first greater element than `nums[i]`.\\n\\nWe know the elements in monostack is sorted so that larger elements do not block smaller elements. Note that all these `{i, k}` pairs has their `nums[i]` sorted already because they were popped from the primary stack one after another. When we are pushing these (potentially multiple) `{i, k}` pairs back to the stack, we want `nums[i]` continues to be sorted to avoid the algorithm to crash. This can be achieved by a secondary \"cache\" below.\\n\\nThis implementation may not be the most optimal, but it should be among the easist to understand. Please upvote if you like.\\n\\n**P.S. This approach can be generalized to problems that require finite passes. Maintain a primary stack as usual, when a new elem comes, keep popping stack.top() and check, if the condition of finite passes has already reached, write to results; otherwise, write to a secondary stack then write back to the primary mono-stack to maintain elem order in the stack and wait for next elem to come.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        stack<pair<int, int>> stk;\\n        stack<pair<int, int>> cache;\\n        vector<int> res(nums.size(), -1);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (stk.size() && nums[stk.top().first] < nums[i]) {\\n                if (stk.top().second != -1) {\\n                    res[stk.top().first] = nums[i];\\n                } else {\\n                    cache.push(make_pair(stk.top().first, i));\\n                }\\n                stk.pop();\\n            }\\n            stk.push(make_pair(i, -1));\\n            while (cache.size()) {\\n                stk.push(cache.top());\\n                cache.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        stack<pair<int, int>> stk;\\n        stack<pair<int, int>> cache;\\n        vector<int> res(nums.size(), -1);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (stk.size() && nums[stk.top().first] < nums[i]) {\\n                if (stk.top().second != -1) {\\n                    res[stk.top().first] = nums[i];\\n                } else {\\n                    cache.push(make_pair(stk.top().first, i));\\n                }\\n                stk.pop();\\n            }\\n            stk.push(make_pair(i, -1));\\n            while (cache.size()) {\\n                stk.push(cache.top());\\n                cache.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757550,
                "title": "using-segment-tree-to-find-2nd-greater-element",
                "content": "Using max segment tree of find the first element greater than x in a range [l,r]\\nFor element a[i] we will find first index in range [i+1,n-1] having value greater than a[i]   => x\\nNow for next greater element we will find first index in [x+1,n-1] having value greater than a[i]   => y\\nans[i]=y\\n\\n```\\n\\nvector<int> tree;\\nvector<int> A;\\nint f(int x,int y){\\n    return max(x,y);\\n}\\nint border=-1;//INT_MIN in maxima and INT_MAX in minima\\n\\nvoid build(int node, int start, int end)\\n{\\n    if(start == end)\\n    {\\n        // Leaf node will have a single element\\n        tree[node] = A[start];\\n    }\\n    else\\n    {\\n        int mid = (start + end) / 2;\\n        // Recurse on the left child\\n        build(2*node, start, mid);\\n        // Recurse on the right child\\n        build(2*node+1, mid+1, end);\\n        // Internal node will have the sum of both of its children\\n        tree[node] = f(tree[2*node],tree[2*node+1]);\\n    }\\n}\\n\\n\\n\\nint query(int node, int start, int end, int l, int r,int x)\\n{\\n    if(r<l)return -1;\\n    if(r < start or end < l)\\n    {\\n        // range represented by a node is completely outside the given range\\n        return -1;\\n    }\\n    if(tree[node]<=x)return -1;//this segment doesnt have a greater element\\n    if(start==end)return start;//found\\n    // range represented by a node is partially inside and partially outside the given range\\n    int mid = (start + end) / 2;\\n    int p1 = query(2*node, start, mid, l, r,x);\\n    if(p1!=-1)return p1;\\n    int p2 = query(2*node+1, mid+1, end, l, r,x);\\n    return p2;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> secondGreaterElement(vector<int>& a) {\\n    \\n            int n=a.size();\\n        //cout<<n<<endl;\\n        A.assign(n,0);\\n        tree.assign(4*n,0);\\n        for(int i=0;i<n;i++)A[i]=a[i];\\n        build(1,0,n-1);\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++){\\n            int x=query(1,0,n-1,i+1,n-1,a[i]);\\n            if(x!=-1){\\n                //cout<<x<<endl;\\n                int y=query(1,0,n-1,x+1,n-1,a[i]);\\n                if(y!=-1)\\n                ans[i]=a[y];\\n            }\\n        }\\n        return ans;\\n  \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n\\nvector<int> tree;\\nvector<int> A;\\nint f(int x,int y){\\n    return max(x,y);\\n}\\nint border=-1;//INT_MIN in maxima and INT_MAX in minima\\n\\nvoid build(int node, int start, int end)\\n{\\n    if(start == end)\\n    {\\n        // Leaf node will have a single element\\n        tree[node] = A[start];\\n    }\\n    else\\n    {\\n        int mid = (start + end) / 2;\\n        // Recurse on the left child\\n        build(2*node, start, mid);\\n        // Recurse on the right child\\n        build(2*node+1, mid+1, end);\\n        // Internal node will have the sum of both of its children\\n        tree[node] = f(tree[2*node],tree[2*node+1]);\\n    }\\n}\\n\\n\\n\\nint query(int node, int start, int end, int l, int r,int x)\\n{\\n    if(r<l)return -1;\\n    if(r < start or end < l)\\n    {\\n        // range represented by a node is completely outside the given range\\n        return -1;\\n    }\\n    if(tree[node]<=x)return -1;//this segment doesnt have a greater element\\n    if(start==end)return start;//found\\n    // range represented by a node is partially inside and partially outside the given range\\n    int mid = (start + end) / 2;\\n    int p1 = query(2*node, start, mid, l, r,x);\\n    if(p1!=-1)return p1;\\n    int p2 = query(2*node+1, mid+1, end, l, r,x);\\n    return p2;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> secondGreaterElement(vector<int>& a) {\\n    \\n            int n=a.size();\\n        //cout<<n<<endl;\\n        A.assign(n,0);\\n        tree.assign(4*n,0);\\n        for(int i=0;i<n;i++)A[i]=a[i];\\n        build(1,0,n-1);\\n        vector<int> ans(n,-1);\\n        for(int i=0;i<n;i++){\\n            int x=query(1,0,n-1,i+1,n-1,a[i]);\\n            if(x!=-1){\\n                //cout<<x<<endl;\\n                int y=query(1,0,n-1,x+1,n-1,a[i]);\\n                if(y!=-1)\\n                ans[i]=a[y];\\n            }\\n        }\\n        return ans;\\n  \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2757543,
                "title": "python3-monotonic-stack-priority-queue-o-n-log-n-with-line-by-line-comments",
                "content": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        ### initialize the result array with -1 in case there isn\\'t a second greater integer\\n        res = [-1] * len(nums)\\n        ### monotonic decreasing stack stores index in nums\\n        stack = []\\n        ### the heapq that stores the elements that already have the first greater integer\\n        q = []\\n        for i,n in enumerate(nums):\\n            ### pop the smallest element in q if it is smaller than the current n, and n is its second greater integer\\n            ### so put n in the result array using the q[0]\\'s index\\n            while q and n>q[0][0]:\\n                _,indx = heappop(q)\\n                res[indx] = n\\n            ### regular monotonic stack operation\\n            ### store the popped element in the q to wait for its second greater integer \\n            while stack and n>nums[stack[-1]]:\\n                indx = stack.pop(-1)\\n                heappush(q,(nums[indx],indx))\\n            stack.append(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        ### initialize the result array with -1 in case there isn\\'t a second greater integer\\n        res = [-1] * len(nums)\\n        ### monotonic decreasing stack stores index in nums\\n        stack = []\\n        ### the heapq that stores the elements that already have the first greater integer\\n        q = []\\n        for i,n in enumerate(nums):\\n            ### pop the smallest element in q if it is smaller than the current n, and n is its second greater integer\\n            ### so put n in the result array using the q[0]\\'s index\\n            while q and n>q[0][0]:\\n                _,indx = heappop(q)\\n                res[indx] = n\\n            ### regular monotonic stack operation\\n            ### store the popped element in the q to wait for its second greater integer \\n            while stack and n>nums[stack[-1]]:\\n                indx = stack.pop(-1)\\n                heappush(q,(nums[indx],indx))\\n            stack.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757516,
                "title": "using-next-greater-element-concept-no-priority-queue-used-easy-with-explanation",
                "content": "// For an element at position i, just find its next greater element using stack(suppose its index is j) after that look for element after after j+1 to find second next greater element\\n\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        stack<int>stk;\\n        vector<int>nge(nums.size(),nums.size());\\n           \\n            for(int i=nums.size()-1;i>=0;i--){\\n                while(stk.size()>0 && nums[stk.top()]<=nums[i]){\\n                    stk.pop();\\n                }\\n                \\n                if(stk.size()>0)\\n                    nge[i]=stk.top();\\n                \\n                stk.push(i);\\n            }\\n        \\n        vector<int>ans(nums.size());\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int l=nge[i]+1;\\n            // int idx=first_larger+1;\\n            \\n            while(l<nums.size() && nums[i]>=nums[l]){\\n                l=nge[l];\\n            }\\n            if(l>=nums.size()){\\n                ans[i]=-1;\\n            }\\n            else\\n            ans[i]=nums[l];\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n//Please upvote if you like my solution : ))\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        stack<int>stk;\\n        vector<int>nge(nums.size(),nums.size());\\n           \\n            for(int i=nums.size()-1;i>=0;i--){\\n                while(stk.size()>0 && nums[stk.top()]<=nums[i]){\\n                    stk.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2757307,
                "title": "c-2-stacks-tc-o-n-sc-o-n-monotonic-stack",
                "content": "```\\n/*\\n\\tApproach : Using 2 Stack we can Solve this problem easily\\n\\tSecond Stack contain those element whose first greater element is encountered \\n\\tNew Element always pussed into the first stack \\n\\t\\n\\tWhen any new element comes than check is it is greater than some of the elements of second stack if yes than update our ans  \\n\\tAfter that check is current element greater than some of the elements of first stack if yes than push those element into second stack (Earlier I said that second stack contain those elements whose first greater element is encountered )\\n\\tAt last push current Element in first stack (Earlier I said that first stack contain new element)\\n\\t\\n\\tAt Every Point of Time stack is monotonic means Elements are stored in increasing / decreasing order\\n*/\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        stack<int> st1,st2;  // both stack store index of elements not value of elements so that we can update our ans at that index\\n        vector<int> ans(nums.size(),-1);  // To store second max element\\n        for(int i=0;i<nums.size();i++){\\n            while(st2.size() && nums[i]>nums[st2.top()]){  // if current elelment greater than second stack elements than update our ans\\n                ans[st2.top()] = nums[i];\\n                st2.pop();\\n            }\\n            stack<int> temp; // here I created temp stack so that we can push elements of stack first into stack second in increasing order \\n            while(st1.size() && nums[i]>nums[st1.top()]){\\n                temp.push(st1.top());\\n                st1.pop();\\n            }\\n            while(temp.size()) { // Now push Element of temp into second stack \\n                st2.push(temp.top());\\n                temp.pop();\\n            }\\n            st1.push(i); // push current index into first stack\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf You Like Solution Please Upvote :)\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\n/*\\n\\tApproach : Using 2 Stack we can Solve this problem easily\\n\\tSecond Stack contain those element whose first greater element is encountered \\n\\tNew Element always pussed into the first stack \\n\\t\\n\\tWhen any new element comes than check is it is greater than some of the elements of second stack if yes than update our ans  \\n\\tAfter that check is current element greater than some of the elements of first stack if yes than push those element into second stack (Earlier I said that second stack contain those elements whose first greater element is encountered )\\n\\tAt last push current Element in first stack (Earlier I said that first stack contain new element)\\n\\t\\n\\tAt Every Point of Time stack is monotonic means Elements are stored in increasing / decreasing order\\n*/\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        stack<int> st1,st2;  // both stack store index of elements not value of elements so that we can update our ans at that index\\n        vector<int> ans(nums.size(),-1);  // To store second max element\\n        for(int i=0;i<nums.size();i++){\\n            while(st2.size() && nums[i]>nums[st2.top()]){  // if current elelment greater than second stack elements than update our ans\\n                ans[st2.top()] = nums[i];\\n                st2.pop();\\n            }\\n            stack<int> temp; // here I created temp stack so that we can push elements of stack first into stack second in increasing order \\n            while(st1.size() && nums[i]>nums[st1.top()]){\\n                temp.push(st1.top());\\n                st1.pop();\\n            }\\n            while(temp.size()) { // Now push Element of temp into second stack \\n                st2.push(temp.top());\\n                temp.pop();\\n            }\\n            st1.push(i); // push current index into first stack\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757157,
                "title": "o-n-log-n-python-sorted-list-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first two ideas to solve this problem were wrong, which is why I could not solve it during the allotted time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe keep a sorted list of values together with their indices and a list a higher values for each.\\n\\nValues from the original list are inserted in consecutive order. Each time we insert a new value, we look at all strictly smaller ones (which we know because we are keeping a sorted list) and append the new value to the lists of higher values whenever appropriate.\\n\\nOnce the list of higher values reaches length two for some number, we can give the answer for that case and remove the item (value, index, and list of higher values) from the sorted list.\\n\\nAnswers not found in this manner default to -1.\\n\\nThe procedure is complicated, but the algorithm is basic.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe running time is $O(n \\\\log n)$, because we keep a sorted list: insertions and deletions take $O(\\\\log n)$ time on average and there are $O(n)$ of them. Other steps take $O(n)$ time, because we never consider more than two higher values for any number.\\n\\nEdit: actually, list management should be faster on average, because we keep deleting items, so the average length is of size $n$ only in the worst-case scenario.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe memory needed is proportional to the size of the data, so $O(n)$.\\n\\n# Code\\n```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        from sortedcontainers import SortedList as slist\\n        l=len(nums)\\n        ans=[-1]*l\\n        print(ans)\\n        lst=slist([(nums[0], 0, [])], key=lambda x:(x[0], x[1]))\\n        i=1\\n        while i<l:\\n            tmp=nums[i]\\n            j=0\\n            while j<len(lst) and lst[j][0]<tmp:\\n                lst[j][2].append(nums[i])\\n                if len(lst[j][2])>=2:\\n                    ans[lst[j][1]]=lst[j][2][1]\\n                    lst.discard(lst[j])\\n                else:\\n                    j+=1\\n            lst.add((nums[i], i, []))\\n            i+=1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        from sortedcontainers import SortedList as slist\\n        l=len(nums)\\n        ans=[-1]*l\\n        print(ans)\\n        lst=slist([(nums[0], 0, [])], key=lambda x:(x[0], x[1]))\\n        i=1\\n        while i<l:\\n            tmp=nums[i]\\n            j=0\\n            while j<len(lst) and lst[j][0]<tmp:\\n                lst[j][2].append(nums[i])\\n                if len(lst[j][2])>=2:\\n                    ans[lst[j][1]]=lst[j][2][1]\\n                    lst.discard(lst[j])\\n                else:\\n                    j+=1\\n            lst.add((nums[i], i, []))\\n            i+=1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757122,
                "title": "python-3-heap-monotonic-queue-hint-solution",
                "content": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:        \\n    \\n        \\n        n = len(nums)\\n        first, second = [], []\\n        ans = [-1] * n\\n        \\n        for i in range(n):\\n            # check if current greater than candidates waiting for second greater element\\n            while second and nums[i] > second[0][0]:\\n                val, idx = heappop(second)\\n                ans[idx] = nums[i]\\n            \\n            # check if current greater than candidates waiting for first greater element\\n            while first and nums[i] > nums[first[-1]]:\\n                tmp = first.pop()\\n                # push into candidates waiting for second greater element\\n                # min-heap with smallest value on top\\n                heappush(second, (nums[tmp], tmp))\\n            first.append(i)\\n        \\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:        \\n    \\n        \\n        n = len(nums)\\n        first, second = [], []\\n        ans = [-1] * n\\n        \\n        for i in range(n):\\n            # check if current greater than candidates waiting for second greater element\\n            while second and nums[i] > second[0][0]:\\n                val, idx = heappop(second)\\n                ans[idx] = nums[i]\\n            \\n            # check if current greater than candidates waiting for first greater element\\n            while first and nums[i] > nums[first[-1]]:\\n                tmp = first.pop()\\n                # push into candidates waiting for second greater element\\n                # min-heap with smallest value on top\\n                heappush(second, (nums[tmp], tmp))\\n            first.append(i)\\n        \\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2757053,
                "title": "c-stack-priority-queue-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    struct comp{  \\n        bool operator()(const pair<int,int>&x,const pair<int,int>&y){\\n            return x.first > y.first;\\n        }\\n    };\\n    \\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int>next(n,-1);\\n        \\n        stack<int>S;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!S.empty() && nums[i]>=nums[S.top()]){\\n                S.pop();\\n            }\\n            if(!S.empty()){\\n                next[i]=S.top();\\n            }\\n            S.push(i);\\n        }\\n        \\n        vector<vector<pair<int,int>>>index(n);\\n        \\n        for(int i=0;i<n;i++){\\n            if(next[i]==-1) continue;\\n            int j=next[i];\\n            index[j].push_back({nums[i],i});\\n        }\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comp>pq;\\n        \\n        vector<int>ans(n,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            while(!pq.empty() && pq.top().first < nums[i]){\\n                ans[pq.top().second] = nums[i];\\n                pq.pop();\\n            }\\n            for(auto &ele:index[i]){\\n                pq.push({ele.first,ele.second});\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct comp{  \\n        bool operator()(const pair<int,int>&x,const pair<int,int>&y){\\n            return x.first > y.first;\\n        }\\n    };\\n    \\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int>next(n,-1);\\n        \\n        stack<int>S;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!S.empty() && nums[i]>=nums[S.top()]){\\n                S.pop();\\n            }\\n            if(!S.empty()){\\n                next[i]=S.top();\\n            }\\n            S.push(i);\\n        }\\n        \\n        vector<vector<pair<int,int>>>index(n);\\n        \\n        for(int i=0;i<n;i++){\\n            if(next[i]==-1) continue;\\n            int j=next[i];\\n            index[j].push_back({nums[i],i});\\n        }\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comp>pq;\\n        \\n        vector<int>ans(n,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            while(!pq.empty() && pq.top().first < nums[i]){\\n                ans[pq.top().second] = nums[i];\\n                pq.pop();\\n            }\\n            for(auto &ele:index[i]){\\n                pq.push({ele.first,ele.second});\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756958,
                "title": "my-solutions",
                "content": "**1. Use the set**\\n```\\n/**\\n * Space Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<int> secondGreaterElement(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> sorted_indices(n);\\n    iota(sorted_indices.begin(), sorted_indices.begin() + n, 0);\\n    sort(sorted_indices.begin(), sorted_indices.begin() + n, [&nums](const int lhs, const int rhs) -> bool {\\n      return nums[lhs] < nums[rhs] || (nums[lhs] == nums[rhs] && lhs > rhs);\\n    });\\n    set<int> indices;\\n    vector<int> ret(n, -1);\\n    for (int i = n - 1; i > -1; --i) {\\n      const int index = sorted_indices[i];\\n      auto itr = indices.emplace(index).first;\\n      auto next_itr = next(itr);\\n      auto next_next_itr = next_itr == indices.end() ? indices.end() : next(next_itr);\\n      if (next_next_itr != indices.end()) {\\n        ret[index] = nums[*next_next_itr];\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the stack**\\n```\\n/**\\n * Space Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<int> secondGreaterElement(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> st1;\\n    vector<int> st2;\\n    vector<int> ret(n, -1);\\n    for (int i = 0; i < n; ++i) {\\n      while (!st2.empty() && nums[st2.back()] < nums[i]) {\\n        ret[st2.back()] = nums[i];\\n        st2.pop_back();\\n      }\\n      size_t n_st2 = st2.size();\\n      while (!st1.empty() && nums[st1.back()] < nums[i]) {\\n        st2.emplace_back(st1.back());\\n        st1.pop_back();\\n      }\\n      reverse(st2.begin() + n_st2, st2.end());\\n      st1.emplace_back(i);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Space Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<int> secondGreaterElement(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> sorted_indices(n);\\n    iota(sorted_indices.begin(), sorted_indices.begin() + n, 0);\\n    sort(sorted_indices.begin(), sorted_indices.begin() + n, [&nums](const int lhs, const int rhs) -> bool {\\n      return nums[lhs] < nums[rhs] || (nums[lhs] == nums[rhs] && lhs > rhs);\\n    });\\n    set<int> indices;\\n    vector<int> ret(n, -1);\\n    for (int i = n - 1; i > -1; --i) {\\n      const int index = sorted_indices[i];\\n      auto itr = indices.emplace(index).first;\\n      auto next_itr = next(itr);\\n      auto next_next_itr = next_itr == indices.end() ? indices.end() : next(next_itr);\\n      if (next_next_itr != indices.end()) {\\n        ret[index] = nums[*next_next_itr];\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Space Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<int> secondGreaterElement(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    vector<int> st1;\\n    vector<int> st2;\\n    vector<int> ret(n, -1);\\n    for (int i = 0; i < n; ++i) {\\n      while (!st2.empty() && nums[st2.back()] < nums[i]) {\\n        ret[st2.back()] = nums[i];\\n        st2.pop_back();\\n      }\\n      size_t n_st2 = st2.size();\\n      while (!st1.empty() && nums[st1.back()] < nums[i]) {\\n        st2.emplace_back(st1.back());\\n        st1.pop_back();\\n      }\\n      reverse(st2.begin() + n_st2, st2.end());\\n      st1.emplace_back(i);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756924,
                "title": "4th-question-was-damn-hard-always",
                "content": "The third question taken up so much of energy, that it was hard to focus on fourth question and it was also too much hard. I had left with 30 minutes only and decided to leave the contest 30 minutes before,  I know it before that it was not be possible for me to solve 4th one within 30 minutes.\\n\\nI had never given weekly-contest and all I had given was bi-weekly and only 1 time I was able to solve all 4th question during contest (June 2022). \\n\\nI hope one day, I will improved myself a lot that I will be able to solve all 4 problems within contest.",
                "solutionTags": [],
                "code": "The third question taken up so much of energy, that it was hard to focus on fourth question and it was also too much hard. I had left with 30 minutes only and decided to leave the contest 30 minutes before,  I know it before that it was not be possible for me to solve 4th one within 30 minutes.\\n\\nI had never given weekly-contest and all I had given was bi-weekly and only 1 time I was able to solve all 4th question during contest (June 2022). \\n\\nI hope one day, I will improved myself a lot that I will be able to solve all 4 problems within contest.",
                "codeTag": "Unknown"
            },
            {
                "id": 2756889,
                "title": "c-o-nlogn-set-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> s;\\n        set<pair<int, int>> m;\\n        vector<int> ans(n,-1);\\n        \\n        for (int i=0; i<n; i++){\\n            // check if current element is greater than any element present in set\\n            while(!m.empty() && nums[i] > (*m.begin()).first){\\n                ans[(*m.begin()).second] = nums[i];\\n                m.erase(m.begin());\\n            }\\n            // all the elements whose next greater element exist will be pushed in set, we keep this track with the help of stack\\n            while (!s.empty() && nums[i]>nums[s.top()]){\\n                m.insert({nums[s.top()],s.top()});\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> s;\\n        set<pair<int, int>> m;\\n        vector<int> ans(n,-1);\\n        \\n        for (int i=0; i<n; i++){\\n            // check if current element is greater than any element present in set\\n            while(!m.empty() && nums[i] > (*m.begin()).first){\\n                ans[(*m.begin()).second] = nums[i];\\n                m.erase(m.begin());\\n            }\\n            // all the elements whose next greater element exist will be pushed in set, we keep this track with the help of stack\\n            while (!s.empty() && nums[i]>nums[s.top()]){\\n                m.insert({nums[s.top()],s.top()});\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756871,
                "title": "c-another-concept-not-monotonic-stack-not-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecord every number from index zero, and update each value that less than current value and its count.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwhen the count is equal to two, it mean that the second greater is found.\\nIn order to reduce the time complexity, remove the item that has been find second gerater.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res(n, -1);\\n        map<pair<int, int>, int> cnt;\\n        vector<map<pair<int, int>, int>::iterator> needDelete;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            /* traversal every one who less than current value and add count once */\\n            for (auto it = cnt.begin(); it != cnt.end() && it->first.first < nums[i]; ++it) {\\n                if (++it->second == 2) {\\n                    res[it->first.second] = nums[i];\\n                    needDelete.push_back(it);\\n                }\\n            }\\n\\n            if (!needDelete.empty()) {\\n                for (auto &need : needDelete) cnt.erase(need);\\n                needDelete.clear();\\n            }\\n            /* record every one */\\n            cnt.insert({{nums[i], i}, 0});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res(n, -1);\\n        map<pair<int, int>, int> cnt;\\n        vector<map<pair<int, int>, int>::iterator> needDelete;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            /* traversal every one who less than current value and add count once */\\n            for (auto it = cnt.begin(); it != cnt.end() && it->first.first < nums[i]; ++it) {\\n                if (++it->second == 2) {\\n                    res[it->first.second] = nums[i];\\n                    needDelete.push_back(it);\\n                }\\n            }\\n\\n            if (!needDelete.empty()) {\\n                for (auto &need : needDelete) cnt.erase(need);\\n                needDelete.clear();\\n            }\\n            /* record every one */\\n            cnt.insert({{nums[i], i}, 0});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756785,
                "title": "python-monotonic-stack-priority-queue-o-nlogn",
                "content": "```\\n\\n# use monotonic decreasing stack to find next first greater element\\n# for a number, if its first greater element has been found we will add the number to a minHeap\\n# if we come across any NUMBER in nums greater than an ELEMENT in minHeap, the NUMBER will be the second greater element for the ELEMENT in minHeap\\n\\nO(nlogn) time\\nO(n) space\\n\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        \\n        res = [-1 for i in range(len(nums))]\\n        \\n        stack = [] # (val, idx)\\n        minH = [] # (val, idx)\\n        \\n        for i, v in enumerate(nums):\\n        \\n            while minH and v > minH[0][0]:\\n                val, idx = heapq.heappop(minH)\\n                res[idx] = v\\n                \\n            while stack and v > stack[-1][0]:\\n                val, idx = stack.pop()\\n                heapq.heappush(minH, (val, idx))\\n                \\n            stack.append((v, i))\\n    \\n        return res\\n                \\n                \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\n\\n# use monotonic decreasing stack to find next first greater element\\n# for a number, if its first greater element has been found we will add the number to a minHeap\\n# if we come across any NUMBER in nums greater than an ELEMENT in minHeap, the NUMBER will be the second greater element for the ELEMENT in minHeap\\n\\nO(nlogn) time\\nO(n) space\\n\\n\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        \\n        res = [-1 for i in range(len(nums))]\\n        \\n        stack = [] # (val, idx)\\n        minH = [] # (val, idx)\\n        \\n        for i, v in enumerate(nums):\\n        \\n            while minH and v > minH[0][0]:\\n                val, idx = heapq.heappop(minH)\\n                res[idx] = v\\n                \\n            while stack and v > stack[-1][0]:\\n                val, idx = stack.pop()\\n                heapq.heappush(minH, (val, idx))\\n                \\n            stack.append((v, i))\\n    \\n        return res\\n                \\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756705,
                "title": "tle-in-contest-but-pass-after-contest",
                "content": "Same code gives me tle in contest byt after contest the same code is accepted by leetcode. Thats completely illogical @Leetcode.\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll int\\n    struct segtree{\\n    ll n;\\n    vector<ll>sg;\\n    void build(ll start,ll end,vector<int>&v,ll node){\\n        if(start==end){\\n            sg[node]=v[start];\\n            return;\\n        }\\n        ll mid=(start+end)/2;\\n        build(start,mid,v,2*node+1);\\n        build(mid+1,end,v,2*node+2);\\n        sg[node]=max(sg[2*node+1],sg[2*node+2]);\\n        return;\\n    }\\n\\n    ll query(ll l,ll r,ll start,ll end,ll node){\\n        // no overlap with given node range\\n        if(l>end || r<start) return -1;\\n\\n        // if complete overlap\\n        if(start>=l && end<=r){\\n            return sg[node];\\n        }\\n\\n        // partial overlap\\n        ll mid=(start+end)/2;\\n        ll ql=query(l,r,start,mid,2*node+1);\\n        ll qr=query(l,r,mid+1,end,2*node+2);\\n\\n        return max(ql,qr);\\n    }\\n\\n    void build(vector<ll>&v){\\n        n=v.size();\\n        sg=vector<ll>(4*n,0);\\n        build(0,n-1,v,0);\\n        return;\\n    }\\n\\n    ll query(ll l,ll r){\\n        return query(l,r,0,n-1,0);\\n    }\\n};\\n    \\n    \\n    vector<int> secondGreaterElement(vector<int>& v){\\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n        int n=v.size();\\n        vector<int>ans(n,-1);\\n        segtree s;\\n        s.build(v);\\n        for(int i=n-3;i>=0;i--){\\n            ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n            int grtr=-1;\\n            int L=i+1,l=i+1,r=n-1;\\n            while(l<=r){\\n                ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n                int m=(l+r)/2;\\n                int cur=s.query(L,m);\\n                if(cur>v[i]){\\n                    grtr=m;\\n                    r=m-1;\\n                }\\n                else{\\n                    l=m+1;\\n                }\\n            }\\n            if(grtr==-1){\\n                continue;\\n            }\\n            L=grtr+1,l=grtr+1,r=n-1;\\n            int next_grtr=-1;\\n            while(l<=r){\\n                ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n                int m=(l+r)/2;\\n                int cur=s.query(L,m);\\n                if(cur>v[i]){\\n                    next_grtr=m;\\n                    r=m-1;\\n                }\\n                else{\\n                    l=m+1;\\n                }\\n            }\\n            if(next_grtr!=-1) ans[i]=v[next_grtr];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll int\\n    struct segtree{\\n    ll n;\\n    vector<ll>sg;\\n    void build(ll start,ll end,vector<int>&v,ll node){\\n        if(start==end){\\n            sg[node]=v[start];\\n            return;\\n        }\\n        ll mid=(start+end)/2;\\n        build(start,mid,v,2*node+1);\\n        build(mid+1,end,v,2*node+2);\\n        sg[node]=max(sg[2*node+1],sg[2*node+2]);\\n        return;\\n    }\\n\\n    ll query(ll l,ll r,ll start,ll end,ll node){\\n        // no overlap with given node range\\n        if(l>end || r<start) return -1;\\n\\n        // if complete overlap\\n        if(start>=l && end<=r){\\n            return sg[node];\\n        }\\n\\n        // partial overlap\\n        ll mid=(start+end)/2;\\n        ll ql=query(l,r,start,mid,2*node+1);\\n        ll qr=query(l,r,mid+1,end,2*node+2);\\n\\n        return max(ql,qr);\\n    }\\n\\n    void build(vector<ll>&v){\\n        n=v.size();\\n        sg=vector<ll>(4*n,0);\\n        build(0,n-1,v,0);\\n        return;\\n    }\\n\\n    ll query(ll l,ll r){\\n        return query(l,r,0,n-1,0);\\n    }\\n};\\n    \\n    \\n    vector<int> secondGreaterElement(vector<int>& v){\\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n        int n=v.size();\\n        vector<int>ans(n,-1);\\n        segtree s;\\n        s.build(v);\\n        for(int i=n-3;i>=0;i--){\\n            ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n            int grtr=-1;\\n            int L=i+1,l=i+1,r=n-1;\\n            while(l<=r){\\n                ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n                int m=(l+r)/2;\\n                int cur=s.query(L,m);\\n                if(cur>v[i]){\\n                    grtr=m;\\n                    r=m-1;\\n                }\\n                else{\\n                    l=m+1;\\n                }\\n            }\\n            if(grtr==-1){\\n                continue;\\n            }\\n            L=grtr+1,l=grtr+1,r=n-1;\\n            int next_grtr=-1;\\n            while(l<=r){\\n                ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n                int m=(l+r)/2;\\n                int cur=s.query(L,m);\\n                if(cur>v[i]){\\n                    next_grtr=m;\\n                    r=m-1;\\n                }\\n                else{\\n                    l=m+1;\\n                }\\n            }\\n            if(next_grtr!=-1) ans[i]=v[next_grtr];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2756671,
                "title": "python-one-loop-with-heap-mono-stack",
                "content": "```python\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        res, stack, heap = [-1] * len(nums), [], []\\n        for i in range(len(nums)):\\n            while heap and heap[0][0] < nums[i]:\\n                res[heappop(heap)[1]] = nums[i]\\n            while stack and nums[stack[-1]] < nums[i]:\\n                j = stack.pop()\\n                heappush(heap, (nums[j], j))\\n            stack.append(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        res, stack, heap = [-1] * len(nums), [], []\\n        for i in range(len(nums)):\\n            while heap and heap[0][0] < nums[i]:\\n                res[heappop(heap)[1]] = nums[i]\\n            while stack and nums[stack[-1]] < nums[i]:\\n                j = stack.pop()\\n                heappush(heap, (nums[j], j))\\n            stack.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756655,
                "title": "stack-with-priority-queue-detailed-explanation",
                "content": "\\nLet elements in priority queue denote the all elements looking for second element\\n\\nLet elements in stack denote all elements looking for first next greater element\\n\\nlooping through each elements:\\n\\twhile (current element is greater than element on priority queue)\\n\\t\\t second next greater number for element on priority queue = current element\\n    while (current element id greater than element on stack):\\n\\t\\tfirst next greater number for  element on stack = current element \\n\\n**here elements denote numbers in array**\\n\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        \\n        stack<int> s1;\\n        priority_queue<pair<int,int>> s2;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            \\n            while(!s2.empty() && nums[i]>nums[s2.top().second])\\n            {\\n                    dp[s2.top().second] = nums[i];\\n                    s2.pop();\\n            }\\n            \\n            while(!s1.empty() && nums[i]>nums[s1.top()])\\n            {\\n                    s2.push({-nums[s1.top()],s1.top()});\\n                    s1.pop();\\n            }\\n                s1.push(i);\\n            \\n            \\n        }\\n        \\n        return dp;\\n        \\n        \\n    }\\n",
                "solutionTags": [],
                "code": "\\nLet elements in priority queue denote the all elements looking for second element\\n\\nLet elements in stack denote all elements looking for first next greater element\\n\\nlooping through each elements:\\n\\twhile (current element is greater than element on priority queue)\\n\\t\\t second next greater number for element on priority queue = current element\\n    while (current element id greater than element on stack):\\n\\t\\tfirst next greater number for  element on stack = current element \\n\\n**here elements denote numbers in array**\\n\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        \\n        stack<int> s1;\\n        priority_queue<pair<int,int>> s2;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            \\n            while(!s2.empty() && nums[i]>nums[s2.top().second])\\n            {\\n                    dp[s2.top().second] = nums[i];\\n                    s2.pop();\\n            }\\n            \\n            while(!s1.empty() && nums[i]>nums[s1.top()])\\n            {\\n                    s2.push({-nums[s1.top()],s1.top()});\\n                    s1.pop();\\n            }\\n                s1.push(i);\\n            \\n            \\n        }\\n        \\n        return dp;\\n        \\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2756654,
                "title": "python3-heapq",
                "content": "class Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        dict1={}\\n        n=len(nums)\\n        res=[-1]*n\\n        \\n        list2=[0]*n\\n        list1=[]\\n        rest=[]\\n        for i,val in enumerate(nums):\\n            if nums[i] not in dict1:\\n                dict1[nums[i]]=[]\\n            dict1[nums[i]].append(i)\\n            while len(list1)!=0:\\n                popval=heapq.heappop(list1)\\n                if popval[0]>=val:\\n                    heapq.heappush(list1,popval)\\n                    break\\n                else:\\n                    list2[popval[1]]+=1\\n                    if list2[popval[1]]==2:\\n\\n                        res[popval[1]]=val\\n\\n                    if list2[popval[1]]<2:\\n                        rest.append(popval)\\n            heapq.heappush(list1,[val,i])\\n            for k in rest:\\n                heapq.heappush(list1,k)\\n            rest=[]\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        dict1={}",
                "codeTag": "Java"
            },
            {
                "id": 2756625,
                "title": "no-heap-no-sorting-only-stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& vec) {\\n        int n=vec.size();\\n        vector<vector<int>> adj(n);\\n        stack<int> a, b;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!a.empty() && vec[i]>=vec[a.top()]) \\n\\t\\t\\t\\ta.pop();\\n            if(!a.empty()) \\n\\t\\t\\t\\tadj[a.top()].push_back(i);\\n            a.push(i);\\n        }\\n        vector<int> res(n,-1);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(auto j:adj[i])\\n            {\\n                while(!b.empty() && vec[j]>=vec[b.top()]) \\n\\t\\t\\t\\t\\tb.pop();\\n                if(!b.empty()) \\n\\t\\t\\t\\t\\tres[j] = vec[b.top()];\\n            }\\n            b.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& vec) {\\n        int n=vec.size();\\n        vector<vector<int>> adj(n);\\n        stack<int> a, b;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!a.empty() && vec[i]>=vec[a.top()]) \\n\\t\\t\\t\\ta.pop();\\n            if(!a.empty()) \\n\\t\\t\\t\\tadj[a.top()].push_back(i);\\n            a.push(i);\\n        }\\n        vector<int> res(n,-1);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(auto j:adj[i])\\n            {\\n                while(!b.empty() && vec[j]>=vec[b.top()]) \\n\\t\\t\\t\\t\\tb.pop();\\n                if(!b.empty()) \\n\\t\\t\\t\\t\\tres[j] = vec[b.top()];\\n            }\\n            b.push(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756619,
                "title": "java-2-treesets-o-nlogn",
                "content": "After an hour of scratching my head during the contest, this is what I came up with. Realizing now from other answers that it can also be done with other combinations of stacks and heaps.\\n\\n```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] output = new int[nums.length];\\n        Arrays.fill(output, -1);\\n\\t\\t\\n\\t\\t// sort by increasing value first, then by increasing index\\n        TreeSet<int[]> set1 = new TreeSet<>((a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n        TreeSet<int[]> set2 = new TreeSet<>((a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            \\n\\t\\t\\t// mark all for which num is the second greater element\\n            Iterator<int[]> it = set2.iterator();\\n            while (it.hasNext()) {\\n                int[] entry = it.next(); // value, index\\n                if (entry[0] < num) {\\n                    output[entry[1]] = num;\\n                    it.remove();\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n\\t\\t\\t// move all for which num is the first greater element\\n            it = set1.iterator();\\n            while (it.hasNext()) {\\n                int[] entry = it.next(); // value, index\\n                if (entry[0] < num) {\\n                    set2.add(entry);\\n                    it.remove();\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            set1.add(new int[] { num, i });\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int[] output = new int[nums.length];\\n        Arrays.fill(output, -1);\\n\\t\\t\\n\\t\\t// sort by increasing value first, then by increasing index\\n        TreeSet<int[]> set1 = new TreeSet<>((a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n        TreeSet<int[]> set2 = new TreeSet<>((a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            \\n\\t\\t\\t// mark all for which num is the second greater element\\n            Iterator<int[]> it = set2.iterator();\\n            while (it.hasNext()) {\\n                int[] entry = it.next(); // value, index\\n                if (entry[0] < num) {\\n                    output[entry[1]] = num;\\n                    it.remove();\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n\\t\\t\\t// move all for which num is the first greater element\\n            it = set1.iterator();\\n            while (it.hasNext()) {\\n                int[] entry = it.next(); // value, index\\n                if (entry[0] < num) {\\n                    set2.add(entry);\\n                    it.remove();\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            set1.add(new int[] { num, i });\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756612,
                "title": "java-solution-brute-force-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int arr[]=new int[nums.length];\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tint max=Integer.MIN_VALUE;\\n\\t\\t\\tint smax=-1;\\n\\t\\t\\tfor(int j=i+1;j<nums.length;j++) {\\n\\t\\t\\t\\tif(nums[j]>nums[i] && max==Integer.MIN_VALUE && nums[j]>max && smax==-1) max=nums[j];\\n\\t\\t\\t\\telse if(nums[i]<nums[j] && max!=Integer.MIN_VALUE && smax==-1) smax=nums[j];\\n\\t\\t\\t}\\n\\t\\t\\tarr[i]=smax;\\n\\t\\t}\\n\\t\\treturn arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] secondGreaterElement(int[] nums) {\\n        int arr[]=new int[nums.length];\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tint max=Integer.MIN_VALUE;\\n\\t\\t\\tint smax=-1;\\n\\t\\t\\tfor(int j=i+1;j<nums.length;j++) {\\n\\t\\t\\t\\tif(nums[j]>nums[i] && max==Integer.MIN_VALUE && nums[j]>max && smax==-1) max=nums[j];\\n\\t\\t\\t\\telse if(nums[i]<nums[j] && max!=Integer.MIN_VALUE && smax==-1) smax=nums[j];\\n\\t\\t\\t}\\n\\t\\t\\tarr[i]=smax;\\n\\t\\t}\\n\\t\\treturn arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756574,
                "title": "o-n-stack-based-solution",
                "content": "You can find a O(n) stack-based solution at https://codeforces.com/blog/entry/64950.",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "You can find a O(n) stack-based solution at https://codeforces.com/blog/entry/64950.",
                "codeTag": "Unknown"
            },
            {
                "id": 2756572,
                "title": "python-heapq",
                "content": "Keep a heapq of 3 element tuples. The number, its index, a list of numbers found to the right that is greater.\\n\\nNow iterate over the numbers.\\n\\nWhile a number is bigger then lowest element, extend its list of bigger numbers to the right. \\n\\nOnce the length of the list reaches 2. We have the anwser.\\n\\nif has less then 2 length reinsert it into the tuple with extended list.\\n\\n```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        h = []\\n        heapq.heapify(h)\\n        \\n        A = {}\\n\\n        for i in range(len(nums)):\\n            if h:\\n                td = []\\n                while h and h[0][0] < nums[i]:\\n                    x,pos, l = heappop(h)\\n\\n                    l = list(l)\\n                    l.append(nums[i])\\n                    l = tuple(l)\\n                    \\n                    td.append((x,pos, l))\\n                for x,y,l in td:\\n                    \\n                    if len(l)<2:\\n                        heappush(h, (x,y,l))\\n                    if len(l)==2:\\n                        A[y] = l[1]\\n                        \\n            heappush(h, (nums[i],i, ()))\\n            \\n        ans = [-1] * len(nums)\\n        \\n        for key in A:\\n            ans[key] = A[key]\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        h = []\\n        heapq.heapify(h)\\n        \\n        A = {}\\n\\n        for i in range(len(nums)):\\n            if h:\\n                td = []\\n                while h and h[0][0] < nums[i]:\\n                    x,pos, l = heappop(h)\\n\\n                    l = list(l)\\n                    l.append(nums[i])\\n                    l = tuple(l)\\n                    \\n                    td.append((x,pos, l))\\n                for x,y,l in td:\\n                    \\n                    if len(l)<2:\\n                        heappush(h, (x,y,l))\\n                    if len(l)==2:\\n                        A[y] = l[1]\\n                        \\n            heappush(h, (nums[i],i, ()))\\n            \\n        ans = [-1] * len(nums)\\n        \\n        for key in A:\\n            ans[key] = A[key]\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756571,
                "title": "stack-priority-queue-c-simple",
                "content": "```\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n=nums.size();\\n        stack<int> s1;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>s2;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            while(s2.size() && s2.top().first<nums[i]){\\n                m[s2.top().second]=nums[i];\\n                s2.pop();\\n            }\\n            while(s1.size() && nums[s1.top()]<nums[i]){\\n                s2.push({nums[s1.top()],s1.top()});\\n                s1.pop();\\n            }\\n            s1.push(i);\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(m.count(i)?m[i]:-1);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n=nums.size();\\n        stack<int> s1;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>s2;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            while(s2.size() && s2.top().first<nums[i]){\\n                m[s2.top().second]=nums[i];\\n                s2.pop();\\n            }\\n            while(s1.size() && nums[s1.top()]<nums[i]){\\n                s2.push({nums[s1.top()],s1.top()});\\n                s1.pop();\\n            }\\n            s1.push(i);\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(m.count(i)?m[i]:-1);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756541,
                "title": "c-monotonic-stack-only-no-sorting-no-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ng(n, -1);\\n        stack<int> s;\\n        for(int i=n-1; i>=0; i--) {\\n            while(not s.empty() and nums[s.top()] <= nums[i]) s.pop();\\n            if(not s.empty()) ng[i] = s.top();\\n            s.push(i);\\n        }\\n        vector<int> a(n, -1);\\n        for(int i=n-1; i>=0; i--) {\\n            if(ng[i] == -1) continue;\\n            int j= ng[i] + 1;\\n            while(j != -1 and j < n and nums[j] <= nums[i]) {\\n                j = ng[j];\\n            }\\n            if(j == -1 or j == n) continue;\\n            else a[i] = nums[j];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ng(n, -1);\\n        stack<int> s;\\n        for(int i=n-1; i>=0; i--) {\\n            while(not s.empty() and nums[s.top()] <= nums[i]) s.pop();\\n            if(not s.empty()) ng[i] = s.top();\\n            s.push(i);\\n        }\\n        vector<int> a(n, -1);\\n        for(int i=n-1; i>=0; i--) {\\n            if(ng[i] == -1) continue;\\n            int j= ng[i] + 1;\\n            while(j != -1 and j < n and nums[j] <= nums[i]) {\\n                j = ng[j];\\n            }\\n            if(j == -1 or j == n) continue;\\n            else a[i] = nums[j];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756509,
                "title": "two-multiset",
                "content": "class Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        \\n        \\n        \\n       multiset<pair<int,int>> m1,m2;\\n        \\n        vector<int> ans(nums.size(),-1);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          \\n          \\n            vector<pair<int,int>> v2;\\n           while(!m1.empty())\\n           {\\n               \\n               auto it=m1.begin();\\n               if((*it).first<nums[i])\\n               {\\n                 pair<int,int> p1=*it;\\n                   v2.push_back(p1);\\n                   m1.erase(it);\\n               }\\n               else\\n                   break;\\n           }\\n            while(!m2.empty())\\n            {\\n                \\n                auto it=m2.begin();\\n               if((*it).first<nums[i])\\n               {\\n                 pair<int,int> p1=*it;\\n                  ans[p1.second]=nums[i];\\n                   m2.erase(it);\\n               }\\n               else\\n                   break;\\n            }\\n            for(auto xx:v2)\\n            {\\n                m2.insert(xx);\\n            }\\n            m1.insert({nums[i],i});\\n             \\n            \\n            \\n            \\n        }\\n        \\n    \\n       \\n     \\n      \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        \\n        \\n        \\n       multiset<pair<int,int>> m1,m2;\\n        \\n        vector<int> ans(nums.size(),-1);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          \\n          \\n            vector<pair<int,int>> v2;\\n           while(!m1.empty())\\n           {\\n               \\n               auto it=m1.begin();\\n               if((*it).first<nums[i])\\n               {\\n                 pair<int,int> p1=*it;\\n                   v2.push_back(p1);\\n                   m1.erase(it);\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 2756506,
                "title": "c-o-nlogn-monotonic-stack-binary-search",
                "content": "If you are familar with the [496. Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/), this problem is just a simple follow-up question.\\n\\nFor each ```nums[i]```, we can maintain a monotonic stack to record the next first greater element of it.\\n\\nConsider the second greater element, there are only two cases.\\n1. **The second element of the monotonic stack,** which can be easily obtained.\\n2. **Any element between the first and second element of the monotonic stack in the original array ```nums```.** In this case, we should record all candidates by using a hash map, and the can then find it with a binary search (here I use the func ```upper_bound()```).\\n\\nMy code are shown below.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        vector<int> st;\\n        unordered_map<int, vector<int>> m;\\n        vector<int> res(nums.size(), -1);\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            m[nums[i]].clear();\\n            while (!st.empty() && nums[i] >= st.back()) {\\n                // all removed elements are possbile candidates of second greater integer, and thus should be saved in m[nums[i]]\\n                m[nums[i]].push_back(st.back());\\n                st.pop_back();\\n            }\\n            if (!st.empty()) {\\n                auto it = upper_bound(m[st.back()].begin(), m[st.back()].end(), nums[i]);\\n                if (it != m[st.back()].end()) {\\n                    res[i] = *it;\\n                }\\n                else if (st.size() > 1) {\\n                    res[i] = st[st.size() - 2];\\n                }\\n            }\\n            st.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```nums[i]```\n```nums```\n```upper_bound()```\n```\\nclass Solution {\\npublic:\\n    vector<int> secondGreaterElement(vector<int>& nums) {\\n        vector<int> st;\\n        unordered_map<int, vector<int>> m;\\n        vector<int> res(nums.size(), -1);\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            m[nums[i]].clear();\\n            while (!st.empty() && nums[i] >= st.back()) {\\n                // all removed elements are possbile candidates of second greater integer, and thus should be saved in m[nums[i]]\\n                m[nums[i]].push_back(st.back());\\n                st.pop_back();\\n            }\\n            if (!st.empty()) {\\n                auto it = upper_bound(m[st.back()].begin(), m[st.back()].end(), nums[i]);\\n                if (it != m[st.back()].end()) {\\n                    res[i] = *it;\\n                }\\n                else if (st.size() > 1) {\\n                    res[i] = st[st.size() - 2];\\n                }\\n            }\\n            st.push_back(nums[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756483,
                "title": "python3-stack-priority-queue",
                "content": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        st1,st2=[],[]\\n        heapify(st2)\\n        ans=[-1 for i in range(len(nums))]\\n        for i in range(len(nums)):\\n            while st2 and nums[-st2[0]]<nums[i]:\\n                ans[-heappop(st2)]=nums[i]\\n            while st1 and nums[st1[-1]]<nums[i]:\\n                heappush(st2,-st1.pop())\\n            st1.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        st1,st2=[],[]\\n        heapify(st2)\\n        ans=[-1 for i in range(len(nums))]\\n        for i in range(len(nums)):\\n            while st2 and nums[-st2[0]]<nums[i]:\\n                ans[-heappop(st2)]=nums[i]\\n            while st1 and nums[st1[-1]]<nums[i]:\\n                heappush(st2,-st1.pop())\\n            st1.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1672292,
                "content": [
                    {
                        "username": "YogiV07",
                        "content": "Feels like this problem is way beyond my limits, still trying my best to understand things :)"
                    },
                    {
                        "username": "daotdia",
                        "content": "I can\\xB4t code it with <O(n\\xB2)..."
                    },
                    {
                        "username": "at218808",
                        "content": "how to get second greater from first greater element.\\n"
                    }
                ]
            },
            {
                "id": 1957269,
                "content": [
                    {
                        "username": "YogiV07",
                        "content": "Feels like this problem is way beyond my limits, still trying my best to understand things :)"
                    },
                    {
                        "username": "daotdia",
                        "content": "I can\\xB4t code it with <O(n\\xB2)..."
                    },
                    {
                        "username": "at218808",
                        "content": "how to get second greater from first greater element.\\n"
                    }
                ]
            },
            {
                "id": 2017846,
                "content": [
                    {
                        "username": "YogiV07",
                        "content": "Feels like this problem is way beyond my limits, still trying my best to understand things :)"
                    },
                    {
                        "username": "daotdia",
                        "content": "I can\\xB4t code it with <O(n\\xB2)..."
                    },
                    {
                        "username": "at218808",
                        "content": "how to get second greater from first greater element.\\n"
                    }
                ]
            }
        ]
    }
]