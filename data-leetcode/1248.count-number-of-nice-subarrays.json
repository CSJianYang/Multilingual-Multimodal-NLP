[
    {
        "title": "Score of Parentheses",
        "question_content": "Given a balanced parentheses string s, return the score of the string.\nThe score of a balanced parentheses string is based on the following rule:\n\n\t\"()\" has score 1.\n\tAB has score A + B, where A and B are balanced parentheses strings.\n\t(A) has score 2 * A, where A is a balanced parentheses string.\n\n&nbsp;\nExample 1:\n\nInput: s = \"()\"\nOutput: 1\n\nExample 2:\n\nInput: s = \"(())\"\nOutput: 2\n\nExample 3:\n\nInput: s = \"()()\"\nOutput: 2\n\n&nbsp;\nConstraints:\n\n\t2 <= s.length <= 50\n\ts consists of only '(' and ')'.\n\ts is a balanced parentheses string.",
        "solutions": [
            {
                "id": 1856519,
                "title": "java-c-visually-explained",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. **Score of Parentheses**\\n\\nIn order to solve this problem we are assigned with few rules :-\\n```\\n\"()\" has score 1.\\nAB has score A + B, where A and B are balanced parentheses strings.\\n(A) has score 2 * A, where A is a balanced parentheses string.\\n```\\n\\nLet\\'s understand our rule\\'s first of all :-\\n* If our input string is **\"()\"** then our score will be **`1`**, so this is our first rule\\n\\n\\n* If we have input string **\"()()\"** then our score will be **1 + 1** i.e. **`2`**, where `1` is a score of a balanced parentheses. So, this is our second rule\\n* Now last rule say\\'s, if we have given something like **\"(())\"** in our input string, our score will be **2 X 1** i.e. **`2`**, it means that we have something like `nested parenthesis`. Then multiply it by 2.\\n\\nLet\\'s take one example, inorder to solve this problem :-\\n\\n**Input :** \"( ( ) ( ( ) ) )\"\\n**Output :** 6\\n\\n![image](https://assets.leetcode.com/users/images/d4cd1104-d9d1-48b7-ada3-f3f4b98568da_1647481533.8082087.png)\\n\\nOkay, so first thing came in our mind is can we solve this problem using stack, and I say yes we\\'ll solve this problem using stack.\\n\\n* First create one stack of **Integer** not ~~**Character**~~\\n* So, as we are using Integer, what we gonna put in stack is intially **0** when we encounter `(`\\n* And we\\'ll calculate the score when we encounter `)`\\n\\n```\\nLet\\'s Understand it visually :-\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b80fe1d1-6ffc-4d49-b52e-a9749b50bdaf_1647483490.0576897.gif)\\n\\n*I hope you got the idea* **Let\\'s Code it up :-**\\n\\n**Java**\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int score = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }\\n            else {\\n                score = st.pop() + Math.max(2 * score, 1);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int score = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }\\n            else {\\n                score = st.top() + max(2 * score, 1);\\n                st.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n\"()\" has score 1.\\nAB has score A + B, where A and B are balanced parentheses strings.\\n(A) has score 2 * A, where A is a balanced parentheses string.\\n```\n```\\nLet\\'s Understand it visually :-\\n```\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int score = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }\\n            else {\\n                score = st.pop() + Math.max(2 * score, 1);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int score = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }\\n            else {\\n                score = st.top() + max(2 * score, 1);\\n                st.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856699,
                "title": "c-beats-100-omg-o-1-space-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nLet\\'s take a look how do we calculate the score on following examples: \\n\\n`()()` => `1+1`\\n`(()())` => `2*(1+1)`\\n`((()()))` => `2*2*(1+1)`\\n`((()(())))` => `2*2*(1+2*1)`\\n\\nWe can see that any `()` in the string gives a score depending on its depth. If `()` is located on the higher possible level (depth=0), the score is simply a 1. If it\\'s located deeper, we just multiply it by 2 as many times as its depth. The found score we can just add to the final result. Why can we do that? Remember that, for example, this expression `2*2*(1+1)` can be expressed as `2*2+2*2`. No matter how deep parenthesis, the final expression of score can be represented as a sum of `()` scores.\\n\\nTime: **O(N)** - traversing\\nSpace: **O(1)** - OMAGAD!!! (\\xB4\\u25BD`\\u0283\\u01AA)\\n\\nRuntime: 0 ms, faster than **100.00%** of C++ online submissions for Score of Parentheses.\\nMemory Usage: 6.1 MB, less than **83.25%** of C++ online submissions for Score of Parentheses.\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        char prev = \\'(\\';\\n        \\n        for (const char &ch: s) {\\n            if (ch == \\'(\\')\\n                depth++;\\n            else {\\n                depth--;\\n                if (prev == \\'(\\')\\n                    res += pow(2, depth);\\n            }\\n            \\n            prev = ch;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        char prev = \\'(\\';\\n        \\n        for (const char &ch: s) {\\n            if (ch == \\'(\\')\\n                depth++;\\n            else {\\n                depth--;\\n                if (prev == \\'(\\')\\n                    res += pow(2, depth);\\n            }\\n            \\n            prev = ch;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856520,
                "title": "java-easy-to-understand-intuition-and-solution-o-n-o-1",
                "content": "****\\nPlease upvote if the solution helps, as it keeps up the motivation to provide such posts.\\n\\n****\\n\\u2318 **Explanation Flow :**\\n* Observations.\\n* Code Flow : Rules and Dry Run\\n* Implementations\\n\\t* Using Stack of Character\\n\\t* Using Stack of Integer\\n\\t* Constant Space Solution\\n\\t* Complexity Analysis\\n\\n\\u2318 **Observations :**\\n\\nAs the given string is balanced, thus it makes our task easy. \\nWe solve the self-dependant `()` and store the result in stack and follow the simulation acc. to the given rules.\\n\\nRight off the bat, first intuition is always using a `stack` here, but we can definately reduce the `SC` to `O(1)` as input constraints to use just two chars `( and )`.\\n\\n# Code Flow : \\n**Rules**:\\n1. \"()\" has score 1.\\n2. AB has score A + B, where A and B are balanced parentheses strings.\\n3. (A) has score 2 * A, where A is a balanced parentheses string.\\n\\n\\n`str =  ( () ( () ) )`\\n\\n* if `ch == (`:\\n\\t* push `ch` in stack\\n* if `ch == )`:\\n\\t* Check the top of stack. It can either of two :\\n\\t\\t* `stack.top() == (` : \\n\\t\\t\\t* i.e. we got a pair `()`. Thus, we push `1`  as per the `1st rule`\\n\\t\\t* `stack.top() == \\'NUMBER\\'`\\n\\t\\t\\t* `Using rule 2 & rule 3` : We add all the numbers till we find the starting `(` of this. ( let `A`)\\n\\t\\t\\t* `Push 2*A back in the stack`\\n* Check if stack is empty. If not, use `rule #2` \\n\\n\\n# \\u2318Code Dry Run States :\\n\\n* `( () ( () ) )`\\n* `( 1 ( () ) )`\\n* `( 1 ( 1 ) )`\\n* `( 1 2 )`\\n* `( 3 )`\\n* `6`\\n\\n****\\n\\n\\uD83D\\uDCCE **First Implementation :** \\n\\nUsing stack of `Character`\\n\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\') {\\n                stack.push(ch);\\n            } else {\\n                // if top of stack is \\'(\\'\\n                if(!stack.isEmpty() && stack.peek() == \\'(\\') {\\n                    stack.pop();\\n                    stack.push(\\'1\\');\\n                } else {\\n                    // if top of stack is a \\'(char) number\\'\\n                    int sum = 0;\\n                    while(!stack.isEmpty() && stack.peek()!=\\'(\\') {\\n                        sum += stack.pop()-\\'0\\';\\n                    }\\n                    // pop \\'(\\'\\n                    stack.pop();\\n                    stack.push((char)(2*sum+\\'0\\'));\\n                }\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.isEmpty()) {\\n            sum += (stack.pop()-\\'0\\');\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n****\\n\\n\\uD83D\\uDCCE **Second Implementation :** \\n\\nUsing `stack of int`\\n\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\')\\n                stack.push(-1);\\n            else {\\n                if(!stack.isEmpty() && stack.peek() == -1)\\n                {\\n                    stack.pop(); // remove \\'(\\'\\n                    stack.push(1);\\n                }\\n                else {\\n                    // top of the stack is number\\n                    int sum = 0;\\n                    while(!stack.isEmpty() && stack.peek()!=-1) {\\n                        sum += stack.pop();\\n                    }\\n                    \\n                    stack.pop();\\n                    stack.push(2*sum);\\n                }\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.isEmpty()) {\\n            sum += stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n\\u2318 **Complexity Analysis** : \\n\\n`TC : O(n)\\nSC: O(n)\\n`\\n****\\n\\n\\uD83D\\uDCCE **Constant Space :** \\n\\nAs the string is balanced, a `(` bracket could be used to mark the start of a new depth (`i.e. 2 times the depth`) & a `)` bracket would indicate us the end of a valid sub-portion of paranthesis. Hence, \\n\\n* We need to update the depth of a paranthesis.\\n\\t* If `(` - our depth increases\\n\\t* If `)` - our depth decreases \\n\\t\\t* If at any point, we see a valid balanced pair `()`, then we need to update the output acc to `Rule #3`\\n\\nFor eg: \\n\\n```\\nstr =    (   (   (   (   )  (   )  (   )   )  )  )\\ndepth =  1   2   3   4   3  4   3  4   3   2  1  0\\nR =                      8      8      8\\n\\nFinal result = 8 + 8 + 8 = 24\\n\\nWhy are we decrementing when we find a `)` ? It is because the intermediate `()` lies at d-1 depth. \\neg: (   (   (  **(   )** - this valid pair lies at depth 3.\\n```\\n\\n# Code Implementation : \\n\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int n = s.length(), d = 0, R = 0;\\n        \\n        for(int i=0;i<n;i++) {\\n            char ch = s.charAt(i);\\n            // if `(` increase the depth\\n            if(ch == \\'(\\')\\n                d++;\\n            else {\\n            // if `)` decrease the depth\\n                --d;\\n                // check if a balanced pair is getting formed, if yes update the result\\n                if(s.charAt(i-1) == \\'(\\')\\n                    R += Math.pow(2, d);\\n            }\\n        }\\n        return R;\\n    }\\n}\\n\\n```\\n\\n\\u2318 **Complexity Analysis** : \\n\\n`TC : O(n)\\nSC: O(1)\\n`",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\') {\\n                stack.push(ch);\\n            } else {\\n                // if top of stack is \\'(\\'\\n                if(!stack.isEmpty() && stack.peek() == \\'(\\') {\\n                    stack.pop();\\n                    stack.push(\\'1\\');\\n                } else {\\n                    // if top of stack is a \\'(char) number\\'\\n                    int sum = 0;\\n                    while(!stack.isEmpty() && stack.peek()!=\\'(\\') {\\n                        sum += stack.pop()-\\'0\\';\\n                    }\\n                    // pop \\'(\\'\\n                    stack.pop();\\n                    stack.push((char)(2*sum+\\'0\\'));\\n                }\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.isEmpty()) {\\n            sum += (stack.pop()-\\'0\\');\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\')\\n                stack.push(-1);\\n            else {\\n                if(!stack.isEmpty() && stack.peek() == -1)\\n                {\\n                    stack.pop(); // remove \\'(\\'\\n                    stack.push(1);\\n                }\\n                else {\\n                    // top of the stack is number\\n                    int sum = 0;\\n                    while(!stack.isEmpty() && stack.peek()!=-1) {\\n                        sum += stack.pop();\\n                    }\\n                    \\n                    stack.pop();\\n                    stack.push(2*sum);\\n                }\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.isEmpty()) {\\n            sum += stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nstr =    (   (   (   (   )  (   )  (   )   )  )  )\\ndepth =  1   2   3   4   3  4   3  4   3   2  1  0\\nR =                      8      8      8\\n\\nFinal result = 8 + 8 + 8 = 24\\n\\nWhy are we decrementing when we find a `)` ? It is because the intermediate `()` lies at d-1 depth. \\neg: (   (   (  **(   )** - this valid pair lies at depth 3.\\n```\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int n = s.length(), d = 0, R = 0;\\n        \\n        for(int i=0;i<n;i++) {\\n            char ch = s.charAt(i);\\n            // if `(` increase the depth\\n            if(ch == \\'(\\')\\n                d++;\\n            else {\\n            // if `)` decrease the depth\\n                --d;\\n                // check if a balanced pair is getting formed, if yes update the result\\n                if(s.charAt(i-1) == \\'(\\')\\n                    R += Math.pow(2, d);\\n            }\\n        }\\n        return R;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141777,
                "title": "c-java-python-o-1-space",
                "content": "# **Approach 0: Stack**\\n\\n`cur` record the score at the current layer level.\\n\\nIf we meet `\\'(\\'`,\\nwe push the current score to `stack`,\\nenter the next inner layer level,\\nand reset `cur = 0`.\\n\\nIf we meet `\\')\\'`,\\nthe `cur` score will be doubled and will be at least 1.\\nWe exit the current layer level,\\nand set `cur += stack.pop() + cur`\\n\\n**Complexity:** `O(N)` time and `O(N)` space\\n\\n**Java**\\n```java\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(cur * 2, 1);\\n            }\\n        }\\n        return cur;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int scoreOfParentheses(string S) {\\n        stack<int> stack;\\n        int cur = 0;\\n        for (char i : S)\\n            if (i == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            }\\n            else {\\n                cur += stack.top() + max(cur, 1);\\n                stack.pop();\\n            }\\n        return cur;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def scoreOfParentheses(self, S):\\n        stack, cur = [], 0\\n        for i in S:\\n            if i == \\'(\\':\\n                stack.append(cur)\\n                cur = 0\\n            else:\\n                cur += stack.pop() + max(cur, 1)\\n        return cur\\n```\\n<br>\\n\\n# **Approach 1: Array**\\n\\nSame as stack, I do it with an array.\\nWe change a pointer instead of pushing/popping repeatedly.\\n\\nComplexity: `O(N)` time and `O(N)` space\\n\\n\\n**Java:**\\n```java\\n    public int scoreOfParentheses(String S) {\\n        int res[] = new int[30], i = 0;\\n        for (char c : S.toCharArray())\\n            if (c == \\'(\\') res[++i] = 0;\\n            else res[i - 1] += Math.max(res[i--] * 2, 1);\\n        return res[0];\\n    }\\n```\\n**C++:**\\n```cpp\\n    int scoreOfParentheses(string S) {\\n        int res[30] = {0}, i = 0;\\n        for (char c : S)\\n            if (c == \\'(\\') res[++i] = 0;\\n            else res[i - 1] += max(res[i] * 2, 1), i--;\\n        return res[0];\\n    }\\n```\\n**Python:**\\n```py\\n    def scoreOfParentheses(self, S):\\n        res, i = [0] * 30, 0\\n        for c in S:\\n            i += 1 if c == \\'(\\' else -1\\n            res[i] = res[i] + max(res[i + 1] * 2, 1) if c == \\')\\' else 0\\n        return res[0]\\n```\\n<br>\\n\\n# **Follow-Up**\\nCan you solve it in `O(1)` space?\\n<br>\\n\\n# **Approach 2: O(1) Space**\\n\\nWe count the number of layers.\\nIf we meet `\\'(\\'` layers number `l++`\\nelse we meet `\\')\\'` layers number `l--`\\n\\nIf we meet `\"()\"`, we know the number of layer outside,\\nso we can calculate the score `res += 1 << l`.\\n\\n**C++:**\\n```cpp\\n    int scoreOfParentheses(string S) {\\n        int res = 0, l = 0;\\n        for (int i = 0; i < S.length(); ++i) {\\n            if (S[i] == \\'(\\') l++; else l--;\\n            if (S[i] == \\')\\' && S[i - 1] == \\'(\\') res += 1 << l;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```jave\\n    public int scoreOfParentheses(String S) {\\n        int res = 0, l = 0;\\n        for (int i = 0; i < S.length(); ++i) {\\n            if (S.charAt(i) == \\'(\\') l++; else l--;\\n            if (S.charAt(i) == \\')\\' && S.charAt(i - 1) == \\'(\\') res += 1 << l;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def scoreOfParentheses(self, S):\\n        res = l = 0\\n        for a, b in itertools.izip(S, S[1:]):\\n            if a + b == \\'()\\': res += 2 ** l\\n            l += 1 if a == \\'(\\' else -1\\n        return res\\n```\\n<br>\\n\\n# More Good Stack Problems\\nHere are some problems that impressed me.\\nGood luck and have fun.\\n\\n[1130. Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n[901. Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n[856. Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n[503. Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n496. Next Greater Element I\\n84. Largest Rectangle in Histogram\\n42. Trapping Rain Water\\n",
                "solutionTags": [],
                "code": "```java\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(cur * 2, 1);\\n            }\\n        }\\n        return cur;\\n    }\\n```\n```cpp\\n    int scoreOfParentheses(string S) {\\n        stack<int> stack;\\n        int cur = 0;\\n        for (char i : S)\\n            if (i == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            }\\n            else {\\n                cur += stack.top() + max(cur, 1);\\n                stack.pop();\\n            }\\n        return cur;\\n    }\\n```\n```py\\n    def scoreOfParentheses(self, S):\\n        stack, cur = [], 0\\n        for i in S:\\n            if i == \\'(\\':\\n                stack.append(cur)\\n                cur = 0\\n            else:\\n                cur += stack.pop() + max(cur, 1)\\n        return cur\\n```\n```java\\n    public int scoreOfParentheses(String S) {\\n        int res[] = new int[30], i = 0;\\n        for (char c : S.toCharArray())\\n            if (c == \\'(\\') res[++i] = 0;\\n            else res[i - 1] += Math.max(res[i--] * 2, 1);\\n        return res[0];\\n    }\\n```\n```cpp\\n    int scoreOfParentheses(string S) {\\n        int res[30] = {0}, i = 0;\\n        for (char c : S)\\n            if (c == \\'(\\') res[++i] = 0;\\n            else res[i - 1] += max(res[i] * 2, 1), i--;\\n        return res[0];\\n    }\\n```\n```py\\n    def scoreOfParentheses(self, S):\\n        res, i = [0] * 30, 0\\n        for c in S:\\n            i += 1 if c == \\'(\\' else -1\\n            res[i] = res[i] + max(res[i + 1] * 2, 1) if c == \\')\\' else 0\\n        return res[0]\\n```\n```cpp\\n    int scoreOfParentheses(string S) {\\n        int res = 0, l = 0;\\n        for (int i = 0; i < S.length(); ++i) {\\n            if (S[i] == \\'(\\') l++; else l--;\\n            if (S[i] == \\')\\' && S[i - 1] == \\'(\\') res += 1 << l;\\n        }\\n        return res;\\n    }\\n```\n```jave\\n    public int scoreOfParentheses(String S) {\\n        int res = 0, l = 0;\\n        for (int i = 0; i < S.length(); ++i) {\\n            if (S.charAt(i) == \\'(\\') l++; else l--;\\n            if (S.charAt(i) == \\')\\' && S.charAt(i - 1) == \\'(\\') res += 1 << l;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def scoreOfParentheses(self, S):\\n        res = l = 0\\n        for a, b in itertools.izip(S, S[1:]):\\n            if a + b == \\'()\\': res += 2 ** l\\n            l += 1 if a == \\'(\\' else -1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 141975,
                "title": "c-solution-using-stack-5ms-detail-explained",
                "content": "When travel through S, only meets \\')\\', we need to calculate the score of this pair of parenthese. If we know the score of inner parentheses, such as 3, we can double it and pass to the outer parenthese.  But the question is how do we know the score of inner parentheses? Using stack.\\n\\nexplain with \"( ( ) ( ( ) ) )\"\\n\\nstack: 0-> \\nstring_traveled :\"\"\\nWhen start only 0 in stack, this int will store the total score\\n\\nstack: 0->0->0->\\nstring_traveled:\"( (\"\\nMeet two \\'(\\', push two zeros to the stack\\n\\nstack: 0->1->\\nstring_traveled: \"( ( )\"\\nFirst time meets \\')\\', it balance the last \\'(\\', so pop the stack. But 0 indicates no inner parentheses exists, so just pass 1 to parent parenthese.\\n\\nstack: 0->1->0->0->\\nstring_traveled: \"( ( ) ( (\"\\nKeep pushing zeros\\n\\nstack 0->1->1->\\nstring_traveled: \"( ( ) ( ( )\"\\nBalance one \\'(\\', and still no inner parenthese, so pass 1 to parent\\n\\nstack 0->3->\\nstring_traveled: \"( ( ) ( ( ) )\"\\nBalance another \\'(\\', but the inner is not zero, so double it and add to parent\\'s score\\n\\nstack 6->\\nstring_traveled: \"( ( ) ( ( ) ) )\"\\nSame as last step, double the inner score and add to parent\\'s\\n\\n```\\nint scoreOfParentheses(string S)\\n{\\n    stack<int> m_stack;\\n    m_stack.push(0); // to keep the total score\\n    for(char c:S){\\n        if(c==\\'(\\')\\n            m_stack.push(0); //When meets \\'(\\', just push a zero to stack\\n        else{\\n            int tmp=m_stack.top(); //  balance the last \\'(\\', it stored the score of inner parentheses\\n            m_stack.pop();\\n            int val=0;\\n            if(tmp>0) // not zero means inner parentheses exists and double it\\n                val=tmp*2;\\n            else // zero means no inner parentheses, just using 1\\n                val=1;\\n            m_stack.top()+=val; // pass the score of this level to parent parenthese\\n        }   \\n    }\\n    return m_stack.top();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string S)\\n{\\n    stack<int> m_stack;\\n    m_stack.push(0); // to keep the total score\\n    for(char c:S){\\n        if(c==\\'(\\')\\n            m_stack.push(0); //When meets \\'(\\', just push a zero to stack\\n        else{\\n            int tmp=m_stack.top(); //  balance the last \\'(\\', it stored the score of inner parentheses\\n            m_stack.pop();\\n            int val=0;\\n            if(tmp>0) // not zero means inner parentheses exists and double it\\n                val=tmp*2;\\n            else // zero means no inner parentheses, just using 1\\n                val=1;\\n            m_stack.top()+=val; // pass the score of this level to parent parenthese\\n        }   \\n    }\\n    return m_stack.top();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141778,
                "title": "1-line-python",
                "content": "```\\n    def scoreOfParentheses(self, S):\\n        return eval(S.replace(\\')(\\', \\')+(\\').replace(\\'()\\', \\'1\\').replace(\\')\\', \\')*2\\'))\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def scoreOfParentheses(self, S):\\n        return eval(S.replace(\\')(\\', \\')+(\\').replace(\\'()\\', \\'1\\').replace(\\')\\', \\')*2\\'))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 141763,
                "title": "java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(-1);\\n            } else {\\n                int cur = 0;\\n                while (stack.peek() != -1) {\\n                    cur += stack.pop();\\n                }\\n                stack.pop();\\n                stack.push(cur == 0 ? 1 : cur * 2);\\n            }\\n        }\\n        int sum = 0;\\n        while (!stack.isEmpty()) {\\n            sum += stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(-1);\\n            } else {\\n                int cur = 0;\\n                while (stack.peek() != -1) {\\n                    cur += stack.pop();\\n                }\\n                stack.pop();\\n                stack.push(cur == 0 ? 1 : cur * 2);\\n            }\\n        }\\n        int sum = 0;\\n        while (!stack.isEmpty()) {\\n            sum += stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856417,
                "title": "c-explained-with-algorithm-0ms-100-easy-simple",
                "content": "# 856. Score of Parentheses\\n**KNOCKCAT**\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Stack Approach with initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n``` ```\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n``` ```\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**ALGORITHM**\\n1. **\"()\"** has a **score of 1.**\\n2. **\"xy**\" has a **score of x + y** ,  here x & y are balanced pairs of balanced parenthese.\\n3. **\"(x) \"** has a **score of x , (i.e) 2 * score of x.**\\n\\tExample.\\n\\t**Input: str = \\u201C()()\\u201D\\n\\tOutput: 2**\\n\\t\\tExplanation: There are are two individual pairs of balanced parenthesis \\u201C() ()\\u201D. Therefore, **score = score of \\u201C()\\u201D + score of \\u201C()\\u201D = 1 + 1 = 2**\\n\\n\\tInput: str = \\u201C(())\\u201D\\n\\tOutput: 2\\n\\t\\tExplanation: Since the input is of the form \\u201C(x)\\u201D, **the total score = 2 * score of \\u201C()\\u201D = 2 * 1 = 2**\\n\\t\\t\\n* **Take a Stack**, **Iterate  over the characters of string.**\\n* For every i**th character check if the character is \\u2018(\\u2018 or not.** If found to be true, then **insert the character score into the stack.**\\n* Initialize a **stack to store the current traversed character score** of inner balanced parenthesis.\\n* For every i check for the conditions.\\n\\t* **if the current character is \\'(\\' push the current score into stack** , enter the next inner layer and **reset score to 0.**\\n\\t* if the **current character is \\')\\'** then **ind score will be doubled and will be at  least one .**\\n\\t* we **exit the current level**  and **set ind = stack.top() + max(ind * 2, 1).**\\n\\t* and pop the  score from the stack.\\n\\t\\nANALYSIS :-\\n* \\t**Time Complexity : O(N)**\\n\\n* \\t**Space Complexity : O(N)**\\n\\n\\n![image](https://assets.leetcode.com/users/images/096896ec-5acf-4e04-b049-6f70de10349d_1647479213.4339418.png)\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        \\n        stack<int> st;\\n        int ind = 0;\\n        \\n        for(auto i : s)\\n        {\\n\\t\\t\\t// if we find open parenthesis\\n\\t\\t\\t// push the current score into the stack\\n            if(i == \\'(\\')\\n            {\\n                st.push(ind);\\n\\t\\t\\t\\t// reset the score to 0\\n                ind = 0;\\n            }\\n            else // if we find close parenthesis\\n            {\\n                ind = st.top() + max(ind*2 ,1);\\n                st.pop();\\n            }\\n                \\n        }\\n        return ind;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Stack Approach with initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        \\n        stack<int> st;\\n        int ind = 0;\\n        \\n        for(auto i : s)\\n        {\\n\\t\\t\\t// if we find open parenthesis\\n\\t\\t\\t// push the current score into the stack\\n            if(i == \\'(\\')\\n            {\\n                st.push(ind);\\n\\t\\t\\t\\t// reset the score to 0\\n                ind = 0;\\n            }\\n            else // if we find close parenthesis\\n            {\\n                ind = st.top() + max(ind*2 ,1);\\n                st.pop();\\n            }\\n                \\n        }\\n        return ind;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080518,
                "title": "python-o-1-space-solution-explained",
                "content": "When you see parentheses in problem forlumation you should think about stack and indeed, there is stack solution for this problem. This solution will be optimal in time, but in place we can do better! Let us look at the following string:\\n`(((()))(()(())))` and try tu understand what will be the score of such string.\\nFirst of all it can be written as 2 * `((()))(()(()))`, which can be written as `2*((())) + 2*(()(())) = 2*2*(()) + 2*2*() + 2*2*(()) = 2*2*2 + 2*2 + 2*2*2 = 20` and it helps us to notice that what acutally matters is how many `()` we meet in our string, and how deep they are located. So, let us traverse through our string, keep `bal`: balance, or depth of current place, that is how many brackets we need to close to get correct expression, and also if we see `()`, we update `ans += 1<< bal`.\\n\\n**Complexity**: time complexity is `O(n)`: we need to traverse our string once, space complexity is just `O(1)`.\\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S):\\n        ans, bal = 0, 0\\n        for i, s in enumerate(S):\\n            bal = bal + 1 if s == \"(\" else bal - 1\\n            if i > 0 and S[i-1:i+1] == \"()\":\\n                ans += 1 << bal\\n        return ans\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S):\\n        ans, bal = 0, 0\\n        for i, s in enumerate(S):\\n            bal = bal + 1 if s == \"(\" else bal - 1\\n            if i > 0 and S[i-1:i+1] == \"()\":\\n                ans += 1 << bal\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141779,
                "title": "java-8ms-11-lines-recursion-with-explanation",
                "content": "```\\nclass Solution {\\n    int i=0;\\n    public int scoreOfParentheses(String S) {\\n        int res=0;\\n        while(i<S.length()){\\n            char c=S.charAt(i++);\\n            if (c==\\'(\\'){\\n                if (S.charAt(i)==\\')\\'){\\n                    res+=1;\\n                    i++;\\n                } else res+=2*scoreOfParentheses(S);\\n            }else return res;\\n        }\\n        return res;\\n    }\\n}\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/caraxin/image_1529810228.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int i=0;\\n    public int scoreOfParentheses(String S) {\\n        int res=0;\\n        while(i<S.length()){\\n            char c=S.charAt(i++);\\n            if (c==\\'(\\'){\\n                if (S.charAt(i)==\\')\\'){\\n                    res+=1;\\n                    i++;\\n                } else res+=2*scoreOfParentheses(S);\\n            }else return res;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141828,
                "title": "python-javascript-simple-and-readable-stack-solution",
                "content": "When we see \"(\" character, we are entering new valid paranthesis cluster, so we append initalized value 0 to stack.\\nWhen we see \")\" character, we should process currently open valid paranthesis cluster(Stack.pop()). If valid paranthesis cluster is still valued 0, it is a valid empty paranthesis cluster, so value is 1. Otherwise multiply inside value by 2. Add processed value to outer valid paranthesis cluster(Stack[-1]) \\n* Python\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S):\\n        stack = [0]\\n        for c in S:\\n            if c == \"(\":\\n                stack.append(0)\\n            else:\\n                last = stack.pop()\\n                stack[-1] += 2 * last or 1\\n        return stack.pop()\\n```\\n* Javascript\\n```\\nvar scoreOfParentheses = function(S) {\\n    let stack = [0];\\n    for (i in S) {\\n        if (S[i] == \"(\") {\\n            stack.push(0);\\n        }\\n        else {\\n            last = stack.pop();\\n            stack[stack.length - 1] += 2 * last || 1\\n        }\\n    }\\n    return stack.pop();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S):\\n        stack = [0]\\n        for c in S:\\n            if c == \"(\":\\n                stack.append(0)\\n            else:\\n                last = stack.pop()\\n                stack[-1] += 2 * last or 1\\n        return stack.pop()\\n```\n```\\nvar scoreOfParentheses = function(S) {\\n    let stack = [0];\\n    for (i in S) {\\n        if (S[i] == \"(\") {\\n            stack.push(0);\\n        }\\n        else {\\n            last = stack.pop();\\n            stack[stack.length - 1] += 2 * last || 1\\n        }\\n    }\\n    return stack.pop();\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204576,
                "title": "simple-python-stack-solution-o-n-time-beats-100-easy-to-understand",
                "content": "Please give me some upvotes if you like it.\\n```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        stack = [0]\\n        for par in S:\\n            if par == \"(\": stack.append(0)\\n            else:\\n                last = stack.pop()\\n                if last == 0: score = 1\\n                else: score = last * 2\\n                stack[-1] += score\\n        return stack[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        stack = [0]\\n        for par in S:\\n            if par == \"(\": stack.append(0)\\n            else:\\n                last = stack.pop()\\n                if last == 0: score = 1\\n                else: score = last * 2\\n                stack[-1] += score\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080625,
                "title": "js-python-java-c-easy-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nAny time we see a problem that describes a doubling operation and an incrementing operation, we should at least think about a potential binary solution. In this case, those are really the only two operations. Nested doubling operations means powers of **2** depending on the nesting depth, and a simple closed pair of parentheses is a **+1**.\\n\\nAt first glance, the addition operation would seem to cause a problem, but math once again comes to our aid.\\n\\nConsider the following:\\n```js\\nS = \"(((()()())))\"\\n  = \"(((\" 1 + 1 + 1 \")))\"    // After replacing completed \"()\"s with 1s\\n  = (1 + 1 + 1) * 2^3        // Applying the power operations\\n  = 2^3 + 2^3 + 2^3          // Through the distributive property of multiplication\\n```\\nAs we can see, we don\\'t *really* have to wait for the summation before applying the power operation, because it will get distributed across the summation anyway. And since we know how many nested parentheses there are (**pwr**) when we finish a simple parentheses pair, we can immediately add the appropriate value to our answer (**ans**).\\n\\nThis means that we can solve this problem in **O(n) time** and **O(1) space**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor JavaScript **S.charAt(i)** is faster at processing string iteration than **S[i]**.\\n\\nWe can start our iteration at **i = 1** because we know the first character is going to be **\"(\"**. We *could* start at **i = 0**, but then we\\'d have to either start with **pwr = 1** or make sure to decrement **pwr** before the power operation instead of after.\\n\\nWe can use a **bitwise shift** for the power operation to more accurately reflect the solution\\'s binary nature.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **64ms / 38.4MB** (beats 99% / 77%).\\n```javascript\\nvar scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.0MB** (beats 96% / 90%).\\n```python\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 37.0MB** (beats 100% / 60%).\\n```java\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S.charAt(i) == \\'(\\') pwr++;\\n            else if (S.charAt(i-1) == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.9MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S[i] == \\'(\\') pwr++;\\n            else if (S[i-1] == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```js\\nS = \"(((()()())))\"\\n  = \"(((\" 1 + 1 + 1 \")))\"    // After replacing completed \"()\"s with 1s\\n  = (1 + 1 + 1) * 2^3        // Applying the power operations\\n  = 2^3 + 2^3 + 2^3          // Through the distributive property of multiplication\\n```\n```javascript\\nvar scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S.charAt(i) == \\'(\\') pwr++;\\n            else if (S.charAt(i-1) == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S[i] == \\'(\\') pwr++;\\n            else if (S[i-1] == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568087,
                "title": "c-easy-to-understand-well-commented-solution-stack-solution-100-time-100-space",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int n=S.size();\\n        stack<int> s;\\n        for(int i=0;i<n;i++){\\n            if(S[i]==\\'(\\'){ //Whenever we get opening brackets, we will push it in the stack, it tells we have to do some calculation\\n                // \\'(\\' will be represented by -1, as any computaitional value can become ascii value of \\'(\\' i.e. 40\\n                s.push(-1);\\n            }\\n            else{   //S[i]==\\')\\'  ,now we have to do calculation\\n                //We have to see top of the stack\\n                if(s.top()==-1){ //Case 1- ()=1\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else{ //We have some number \\n                    int res=s.top();\\n                    s.pop();\\n                    if(s.top()==-1){ //Case 2- (A)=2*A\\n                        s.pop();\\n                        s.push(2*res);\\n                    }\\n                    else{  //Case 3- ABC..=A+B+C+..\\n                        //I will keep adding elements until I get to opening loop\\n                        while(!s.empty()&&s.top()!=-1){\\n                            res+=s.top();\\n                            s.pop();\\n                        }\\n                        if(!s.empty()&&s.top()==-1){\\n                            s.pop();\\n                            res=res*2;\\n                        }\\n                        s.push(res);//I will add calculated value in stack after popping out all brackets within which value is calculated\\n                    }\\n                }\\n            }\\n        }\\n        //I have eliminated all brackets \\n        //I only have numbers remaining in my stack like 1,2,3...\\n        //So I have to do AB= A+B\\n        int ans=0;\\n        while(!s.empty()){\\n            ans+=s.top();\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int n=S.size();\\n        stack<int> s;\\n        for(int i=0;i<n;i++){\\n            if(S[i]==\\'(\\'){ //Whenever we get opening brackets, we will push it in the stack, it tells we have to do some calculation\\n                // \\'(\\' will be represented by -1, as any computaitional value can become ascii value of \\'(\\' i.e. 40\\n                s.push(-1);\\n            }\\n            else{   //S[i]==\\')\\'  ,now we have to do calculation\\n                //We have to see top of the stack\\n                if(s.top()==-1){ //Case 1- ()=1\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else{ //We have some number \\n                    int res=s.top();\\n                    s.pop();\\n                    if(s.top()==-1){ //Case 2- (A)=2*A\\n                        s.pop();\\n                        s.push(2*res);\\n                    }\\n                    else{  //Case 3- ABC..=A+B+C+..\\n                        //I will keep adding elements until I get to opening loop\\n                        while(!s.empty()&&s.top()!=-1){\\n                            res+=s.top();\\n                            s.pop();\\n                        }\\n                        if(!s.empty()&&s.top()==-1){\\n                            s.pop();\\n                            res=res*2;\\n                        }\\n                        s.push(res);//I will add calculated value in stack after popping out all brackets within which value is calculated\\n                    }\\n                }\\n            }\\n        }\\n        //I have eliminated all brackets \\n        //I only have numbers remaining in my stack like 1,2,3...\\n        //So I have to do AB= A+B\\n        int ans=0;\\n        while(!s.empty()){\\n            ans+=s.top();\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856451,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time complexity : O(n)**\\n\\n```java []\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        int cur = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(1, cur*2);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```\\n```javascript []\\nvar scoreOfParentheses = function(s) {\\n    let stack = []\\n    let cur = 0;\\n    for(let c of s) {\\n        if(c == \\'(\\') {\\n            stack.push(cur);\\n            cur = 0;\\n        } else {\\n            cur = stack.pop() + Math.max(1, cur*2);\\n        }\\n    }\\n    return cur;\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = []\\n        cur = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(cur)\\n                cur = 0\\n            else:\\n                cur = stack.pop() + max(1, cur*2)\\n        return cur \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        int cur = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(1, cur*2);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```\n```javascript []\\nvar scoreOfParentheses = function(s) {\\n    let stack = []\\n    let cur = 0;\\n    for(let c of s) {\\n        if(c == \\'(\\') {\\n            stack.push(cur);\\n            cur = 0;\\n        } else {\\n            cur = stack.pop() + Math.max(1, cur*2);\\n        }\\n    }\\n    return cur;\\n};\\n```\n```python []\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = []\\n        cur = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(cur)\\n                cur = 0\\n            else:\\n                cur = stack.pop() + max(1, cur*2)\\n        return cur \\n```",
                "codeTag": "Java"
            },
            {
                "id": 332150,
                "title": "python3-recursion-solution-beats-100",
                "content": "\\tclass Solution:\\n\\t\\tdef scoreOfParentheses(self, S: str) -> int:\\n\\t\\t\\treturn self.helper(S,0,len(S)-1)        \\n\\t\\tdef helper(self,S,l,r):\\n\\t\\t\\tif r-l==1:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(l,r):\\n\\t\\t\\t\\tif S[i]==\\'(\\':\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\tif S[i]==\\')\\':\\n\\t\\t\\t\\t\\tcount-=1\\n\\t\\t\\t\\tif count==0:\\n\\t\\t\\t\\t\\treturn self.helper(S,l,i)+self.helper(S,i+1,r)\\n\\t\\t\\treturn 2*self.helper(S,l+1,r-1)",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef scoreOfParentheses(self, S: str) -> int:\\n\\t\\t\\treturn self.helper(S,0,len(S)-1)        \\n\\t\\tdef helper(self,S,l,r):\\n\\t\\t\\tif r-l==1:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(l,r):\\n\\t\\t\\t\\tif S[i]==\\'(\\':\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\tif S[i]==\\')\\':\\n\\t\\t\\t\\t\\tcount-=1\\n\\t\\t\\t\\tif count==0:\\n\\t\\t\\t\\t\\treturn self.helper(S,l,i)+self.helper(S,i+1,r)\\n\\t\\t\\treturn 2*self.helper(S,l+1,r-1)",
                "codeTag": "Java"
            },
            {
                "id": 1857157,
                "title": "detail-explanation-using-stack",
                "content": "\\n\\n```\\n/*\\nfirst ->we are gonna create a stack of int . . .\\nmain motive is whenever we find \\'(\\' just push -1  into the stack  . . .\\n\\nafter that we have to do this operations --->\\n\\t\\t1) when stack\\'s top == -1 and we find a \\')\\' then it\\'s mean we found () and its value is 1 . so pop the\\n\\t\\t    front element and push 1 . . .\\n\\t\\t2) in 2nd scenario we find a \\')\\' but the stack\\'s top == 1 it\\'s mean the 3rd rule applied here and we have to\\n\\t\\t    calculate all the () parentheses value and after that push the calculated value in the stack . . .\\n\\t\\t3) now if the provided string is \\'()()()\\' then you have to calculate all the value present in the stack . . .\\n\\t\\t4) calculate the stack and return the ans . . .\\n*/\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int i = 0 ;\\n        while(s[i] != \\'\\\\0\\'){\\n\\t\\t\\n\\t\\t\\t// when we find a open parentheses . . .\\n            if(s[i] == \\'(\\') st.push(-1);\\n\\t\\t\\t\\n\\t\\t\\t// when we find a close parentheses . . .\\n            else{\\n\\t\\t\\t\\t// when we find a () . . .\\n                if(st.top() == -1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n\\t\\t\\t\\t//apply the 3rd rule\\n                else{\\n                    int ans = 0;\\n                    while(st.top() != -1){\\n                        ans += st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*ans);\\n                }\\n            }\\n            i++;\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n## If(solution == helpfull ) upvote \\uD83E\\uDD17 . . .",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n/*\\nfirst ->we are gonna create a stack of int . . .\\nmain motive is whenever we find \\'(\\' just push -1  into the stack  . . .\\n\\nafter that we have to do this operations --->\\n\\t\\t1) when stack\\'s top == -1 and we find a \\')\\' then it\\'s mean we found () and its value is 1 . so pop the\\n\\t\\t    front element and push 1 . . .\\n\\t\\t2) in 2nd scenario we find a \\')\\' but the stack\\'s top == 1 it\\'s mean the 3rd rule applied here and we have to\\n\\t\\t    calculate all the () parentheses value and after that push the calculated value in the stack . . .\\n\\t\\t3) now if the provided string is \\'()()()\\' then you have to calculate all the value present in the stack . . .\\n\\t\\t4) calculate the stack and return the ans . . .\\n*/\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int i = 0 ;\\n        while(s[i] != \\'\\\\0\\'){\\n\\t\\t\\n\\t\\t\\t// when we find a open parentheses . . .\\n            if(s[i] == \\'(\\') st.push(-1);\\n\\t\\t\\t\\n\\t\\t\\t// when we find a close parentheses . . .\\n            else{\\n\\t\\t\\t\\t// when we find a () . . .\\n                if(st.top() == -1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n\\t\\t\\t\\t//apply the 3rd rule\\n                else{\\n                    int ans = 0;\\n                    while(st.top() != -1){\\n                        ans += st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*ans);\\n                }\\n            }\\n            i++;\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288667,
                "title": "easy-c-solution-using-stack-passess-100-submission",
                "content": "Time Complexity: O(n)\\nSpace Complexiy: O(n)  // using stack\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> a;  // lets assume 0 as (\\n        for(char c : s){\\n            if(c==\\'(\\'){\\n                a.push(0);\\n            } else if(c==\\')\\'){\\n                if(a.top() ==0){   // detect () and replace that with 1\\n                    a.pop();\\n                    a.push(1);\\n                }else {\\n                    int x=0;\\n                    while(a.top() != 0){   // detects complex nested (()) types cases and replaces the block with sum *2 \\n                        x+=a.top();\\n                        a.pop();\\n                    }\\n                    a.pop();\\n                    a.push(2*x);\\n                }\\n            }\\n        }\\n        int x=0;\\n        while(a.size()>0){   // sum the stack value and store in x\\n            x+=a.top();\\n            a.pop();\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> a;  // lets assume 0 as (\\n        for(char c : s){\\n            if(c==\\'(\\'){\\n                a.push(0);\\n            } else if(c==\\')\\'){\\n                if(a.top() ==0){   // detect () and replace that with 1\\n                    a.pop();\\n                    a.push(1);\\n                }else {\\n                    int x=0;\\n                    while(a.top() != 0){   // detects complex nested (()) types cases and replaces the block with sum *2 \\n                        x+=a.top();\\n                        a.pop();\\n                    }\\n                    a.pop();\\n                    a.push(2*x);\\n                }\\n            }\\n        }\\n        int x=0;\\n        while(a.size()>0){   // sum the stack value and store in x\\n            x+=a.top();\\n            a.pop();\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856782,
                "title": "c-efficient-stack-tc-o-n-sc-o-n-with-explanation-clean-solution",
                "content": "##### *Please, Upvote , if you find its helpful :)*\\n##### Let\\'s understand our rule\\'s first of all :-\\n```\\nIf our input string is \"()\" then our score will be 1, so this is our first rule\\nIf we have input string \"()()\" then our score will be 1 + 1 i.e. 2, where 1 is a score of a balanced parentheses. So, this is our second rule\\nNow last rule say\\'s, if we have given something like \"(())\" in our input string, our score will be 2 X 1 i.e. 2, it means that we have something like nested parenthesis. \\nThen multiply it by 2.\\n\\nLet\\'s take a look how do we calculate the score on following examples:\\n()() => 1+1\\n(()()) => 2*(1+1)\\n((()())) => 2*2*(1+1)\\n((()(()))) => 2*2*(1+2*1)\\n```\\n#### Code:-\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int>st;\\n        int score=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){//if we find open parenthesis, push the current score into the stack\\n                st.push(score);\\n                score=0;//reset the score to 0\\n            }\\n            else if(s[i]==\\')\\'){//if we find close parenthesis\\n                score=st.top()+ max(2* score , 1);\\n                st.pop();\\n            }\\n        }\\n        return score;//return score\\n    }\\n};\\n```\\n*Time Complexity :- O(N)\\nSpace Complexity :- O(N)*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nIf our input string is \"()\" then our score will be 1, so this is our first rule\\nIf we have input string \"()()\" then our score will be 1 + 1 i.e. 2, where 1 is a score of a balanced parentheses. So, this is our second rule\\nNow last rule say\\'s, if we have given something like \"(())\" in our input string, our score will be 2 X 1 i.e. 2, it means that we have something like nested parenthesis. \\nThen multiply it by 2.\\n\\nLet\\'s take a look how do we calculate the score on following examples:\\n()() => 1+1\\n(()()) => 2*(1+1)\\n((()())) => 2*2*(1+1)\\n((()(()))) => 2*2*(1+2*1)\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int>st;\\n        int score=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){//if we find open parenthesis, push the current score into the stack\\n                st.push(score);\\n                score=0;//reset the score to 0\\n            }\\n            else if(s[i]==\\')\\'){//if we find close parenthesis\\n                score=st.top()+ max(2* score , 1);\\n                st.pop();\\n            }\\n        }\\n        return score;//return score\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281710,
                "title": "c-code-easy-to-understand-stack-use",
                "content": "int scoreOfParentheses(string s) {\\n        stack<int>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')\\n                st.push(-1);\\n            else if(s[i]==\\')\\'){\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else {\\n                    int val=0;\\n                    while(st.top()!=-1){\\n                        val+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*val);\\n                }\\n            }\\n        }\\n        int val=0;\\n        while(st.size()>0){\\n            val+=st.top();\\n            st.pop();\\n        }\\n        return val;\\n    }",
                "solutionTags": [],
                "code": "int scoreOfParentheses(string s) {\\n        stack<int>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')\\n                st.push(-1);\\n            else if(s[i]==\\')\\'){\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else {\\n                    int val=0;\\n                    while(st.top()!=-1){\\n                        val+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*val);\\n                }\\n            }\\n        }\\n        int val=0;\\n        while(st.size()>0){\\n            val+=st.top();\\n            st.pop();\\n        }\\n        return val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1858780,
                "title": "multiple-c-solutions-with-explanations-using-stack",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019re using a stack to store the values, to store parentheses we\\u2019re using -1, else the value for the parentheses.\\n- There can be 3 cases:\\n    - `if(x == \\'(\\')` we\\u2019ll **push *-1*** in this case to our stack, as it\\u2019s a open parentheses.\\n    - `else if(x == \\')\\' && st.top() == -1)` in this case we are getting open and close parentheses side by side, which derives the value 1, so we pop the top element and **push *1*** to the stack.\\n    - `else if(x == \\')\\' && st.top() != -1)` in this case we\\u2019ve some value in the stack, before a open parentheses. Here we\\u2019ll use a while loop to pop the elements till we found a open parentheses(-1) & add the values to count. After breaking this loop we have a open parentheses at top, we pop that & **push *count*2***\\n- Now add the stack integers to ans and return it.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- This is the optimal solution of the previous one.\\n- Here we\\u2019re pushing the count only if it is an open parentheses.\\n- If it\\u2019s a closing parentheses then we\\u2019ll update the count with `max(1, 2*count)` & add the top element from stack, then pop it. Next time when there is a open parentheses then it\\u2019ll push it to stack and update count to 0.\\n- return count.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.size();\\n        int count = 0, ans = 0;\\n        stack<int> st;\\n        \\n        for(auto x:s){\\n            if(x == \\'(\\'){\\n                st.push(-1);\\n            }\\n            else if(x == \\')\\' && st.top() == -1){\\n                st.pop();\\n                st.push(1);\\n            }\\n            else if(x == \\')\\' && st.top() != -1){\\n                while(st.top() != -1){\\n                    count += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*count);\\n                count = 0;\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int count = 0;\\n        \\n        for(auto x:s){\\n            if(x == \\'(\\'){\\n                st.push(count);\\n                count = 0;\\n            }\\n            else{\\n                count = st.top() + max(1, 2*count);\\n                st.pop();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.size();\\n        int count = 0, ans = 0;\\n        stack<int> st;\\n        \\n        for(auto x:s){\\n            if(x == \\'(\\'){\\n                st.push(-1);\\n            }\\n            else if(x == \\')\\' && st.top() == -1){\\n                st.pop();\\n                st.push(1);\\n            }\\n            else if(x == \\')\\' && st.top() != -1){\\n                while(st.top() != -1){\\n                    count += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*count);\\n                count = 0;\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int count = 0;\\n        \\n        for(auto x:s){\\n            if(x == \\'(\\'){\\n                st.push(count);\\n                count = 0;\\n            }\\n            else{\\n                count = st.top() + max(1, 2*count);\\n                st.pop();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655150,
                "title": "2-approaches-o-1-space-c",
                "content": "Implementation\\n\\n**1st Approach\\nUsing stack\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        st.push(0);\\n        \\n        for(auto itr : s){\\n            // if meets this \\'(\\' then just add 0 to stack\\n            if(itr == \\'(\\'){\\n                st.push(0);\\n            }\\n            else{\\n                // if we meets \\')\\' then take out the top value, and\\n                // check if its 0 then simply add 1 to the next top of the stack, or\\n                // if its more than 0 it means we are already in one inside the level, then\\n                // simply multiply that value by 2, and add it into the next top of the stack\\n                int val = st.top();\\n                st.pop();\\n                int newValue = 0;\\n                if(val){\\n                    newValue = val * 2;\\n                }\\n                else{                    \\n                    newValue = 1;\\n                }\\n                st.top() += newValue;                \\n            }\\n        }\\n        return st.top();\\n    }\\n};\\n```\\n\\n\\n**2nd Approach\\nMost Efficient Approach\\nTime Complexity = O(N), Space Complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        \\n        for(int itr = 0; itr < s.size(); itr++){\\n            if(s[itr] == \\'(\\') depth++;\\n            else depth--;\\n            \\n\\t\\t\\t// we need to add the 2^depth, when we are getting any pair like ()\\n            if(s[itr] == \\')\\' && s[itr-1] == \\'(\\'){\\n                res += pow(2, depth);\\n            }            \\n        }\\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        st.push(0);\\n        \\n        for(auto itr : s){\\n            // if meets this \\'(\\' then just add 0 to stack\\n            if(itr == \\'(\\'){\\n                st.push(0);\\n            }\\n            else{\\n                // if we meets \\')\\' then take out the top value, and\\n                // check if its 0 then simply add 1 to the next top of the stack, or\\n                // if its more than 0 it means we are already in one inside the level, then\\n                // simply multiply that value by 2, and add it into the next top of the stack\\n                int val = st.top();\\n                st.pop();\\n                int newValue = 0;\\n                if(val){\\n                    newValue = val * 2;\\n                }\\n                else{                    \\n                    newValue = 1;\\n                }\\n                st.top() += newValue;                \\n            }\\n        }\\n        return st.top();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        \\n        for(int itr = 0; itr < s.size(); itr++){\\n            if(s[itr] == \\'(\\') depth++;\\n            else depth--;\\n            \\n\\t\\t\\t// we need to add the 2^depth, when we are getting any pair like ()\\n            if(s[itr] == \\')\\' && s[itr-1] == \\'(\\'){\\n                res += pow(2, depth);\\n            }            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141848,
                "title": "c-o-1-space-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int a=0;\\n        int result=0;\\n        for(int i=0;i<S.length()-1;++i)\\n        {\\n            if(S[i]==\\'(\\')\\n            {\\n                if(S[i+1]==\\')\\')\\n                    result+=1<<a;\\n                a++;\\n            }\\n            else\\n                a--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int a=0;\\n        int result=0;\\n        for(int i=0;i<S.length()-1;++i)\\n        {\\n            if(S[i]==\\'(\\')\\n            {\\n                if(S[i+1]==\\')\\')\\n                    result+=1<<a;\\n                a++;\\n            }\\n            else\\n                a--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299821,
                "title": "python-faster-than-83-easy-understanding-explaining-with-comments",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stk = [0]   # temp value to help us\\n\\n        for char in s:\\n            if char == \\'(\\':\\n                stk.append(0)   # new parent: current sum = 0\\n            else:\\n                # An expression will be closed\\n                # Find its value: either 1 for empty () or 2 * its sub-expressions\\n                # we can calc both with a simple max()\\n                value = max(2 * stk.pop(), 1)\\n\\n                # Add the expression sum to its parent current sum\\n                #  Assume we have expression E that is (CHD)\\n                # where C, H, D are valid-subexpressions with values 5, 10, 4\\n                # then E is (5+10+4) = (19) = 38\\n                # Every time we finish an expression, we add its value to its parent\\n                # get the parent and update its sum with a finished sub-expression\\n                stk[-1] += value\\n\\n        return stk.pop()\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stk = [0]   # temp value to help us\\n\\n        for char in s:\\n            if char == \\'(\\':\\n                stk.append(0)   # new parent: current sum = 0\\n            else:\\n                # An expression will be closed\\n                # Find its value: either 1 for empty () or 2 * its sub-expressions\\n                # we can calc both with a simple max()\\n                value = max(2 * stk.pop(), 1)\\n\\n                # Add the expression sum to its parent current sum\\n                #  Assume we have expression E that is (CHD)\\n                # where C, H, D are valid-subexpressions with values 5, 10, 4\\n                # then E is (5+10+4) = (19) = 38\\n                # Every time we finish an expression, we add its value to its parent\\n                # get the parent and update its sum with a finished sub-expression\\n                stk[-1] += value\\n\\n        return stk.pop()\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1149968,
                "title": "c-o-n-time-o-1-space-have-illustration-very-straightforward-and-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/1097015d-9a3d-4aa5-ab1c-f541f4fdb844_1617961993.5570076.png)\\n\\nBy apply rules in the question, we get:\\n**Score**= 2 x (  2x(1+(2x1)+1) + 1 + 2x1 )\\n### = (2x2x1)+ (2x2x2x1) + (2x2x1) + (2x1) + (2x2x1) (**\\\\***)\\n= 22\\n\\nLook at above (\\\\*) expression and line-chart, I see some logical: \\n1. **number of 1s is equal to number of top** in line-chart\\n2. **number of 2s of each sub-expression == (height_of_top  - 1)**\\n\\nExample: Assume height of top is 4 (the second top of above chart), so we have to **multiply 1 by 2^3** \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int top=0, ans=0;\\n        for(int i=0; i<S.size(); i++)\\n        {\\n          if(S[i]==\\'(\\') {\\n            top++;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(S[i+1]==\\')\\') ans+=pow(2,top-1);  // on top\\n\\t\\t  } else top--;\\n        }\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int top=0, ans=0;\\n        for(int i=0; i<S.size(); i++)\\n        {\\n          if(S[i]==\\'(\\') {\\n            top++;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(S[i+1]==\\')\\') ans+=pow(2,top-1);  // on top\\n\\t\\t  } else top--;\\n        }\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080600,
                "title": "score-of-parentheses-stack-python-3-o-n",
                "content": "crr record the score at the current layer level.\\n\\n**If we meet \\'(\\':**\\n1. we push the current score to stack,\\n1. enter the next inner layer level,\\n1. and reset crr = 0.\\n\\n**If we meet \\')\\':**\\n1. we cumulative points of crr while not meet \\'(\\' yet.\\n1. We exit the current layer level,\\n1. and set crr = stack.pop() + crr\\n\\nComplexity: O(N) time and O(N) space\\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        crr, stack = 0, []\\n        for pos in range(len(S)):\\n            if S[pos] == \\'(\\':\\n                stack.append(\\'(\\')\\n            else:\\n                while stack[-1] != \\'(\\':\\n                    crr += stack[-1]\\n                    stack.pop()\\n                stack[-1] = crr * 2 if crr else 1\\n                crr = 0\\n        return sum(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        crr, stack = 0, []\\n        for pos in range(len(S)):\\n            if S[pos] == \\'(\\':\\n                stack.append(\\'(\\')\\n            else:\\n                while stack[-1] != \\'(\\':\\n                    crr += stack[-1]\\n                    stack.pop()\\n                stack[-1] = crr * 2 if crr else 1\\n                crr = 0\\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080516,
                "title": "c-easy-stack-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int> stack;\\n        int res = 0;\\n        for (auto c : S) {\\n            if (c == \\'(\\') {\\n                stack.push(res);\\n                res = 0;\\n            }\\n            else {\\n                int prev = stack.top();\\n                stack.pop();\\n                res += prev + max(res, 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int> stack;\\n        int res = 0;\\n        for (auto c : S) {\\n            if (c == \\'(\\') {\\n                stack.push(res);\\n                res = 0;\\n            }\\n            else {\\n                int prev = stack.top();\\n                stack.pop();\\n                res += prev + max(res, 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718346,
                "title": "java-use-stack",
                "content": "```\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> st = new Stack<>();\\n        int res = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                st.push(res);\\n                res = 0;\\n            } else {\\n                res = Math.max(1, res * 2);\\n                res += st.pop();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> st = new Stack<>();\\n        int res = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                st.push(res);\\n                res = 0;\\n            } else {\\n                res = Math.max(1, res * 2);\\n                res += st.pop();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189588,
                "title": "python-concise-100-solution",
                "content": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        stack = [0]\\n        for c in S:\\n            if c == \\'(\\':\\n                stack.append(0)\\n            else:\\n                num = stack.pop()\\n                stack[-1] += (1 if num==0 else 2*num)\\n        return stack[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        stack = [0]\\n        for c in S:\\n            if c == \\'(\\':\\n                stack.append(0)\\n            else:\\n                num = stack.pop()\\n                stack[-1] += (1 if num==0 else 2*num)\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856351,
                "title": "single-pass-o-n-no-stack-no-recursion",
                "content": "\\n\\n```csharp\\npublic class Solution\\n{\\n    public int ScoreOfParentheses(string s)\\n    {\\n        int res = 0;\\n        int n = 1;\\n        \\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                n *= 2;\\n            }\\n            else\\n            {\\n                n /= 2;\\n                if (s[i - 1] == \\'(\\') res += n;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int ScoreOfParentheses(string s)\\n    {\\n        int res = 0;\\n        int n = 1;\\n        \\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                n *= 2;\\n            }\\n            else\\n            {\\n                n /= 2;\\n                if (s[i - 1] == \\'(\\') res += n;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248095,
                "title": "solution-swift-score-of-parentheses",
                "content": "```swift\\nclass Solution {\\n    func scoreOfParentheses(_ s: String) -> Int {\\n        \\n        var arr = Array(s), val = 0, res = 0\\n        \\n        for i in 0 ..< arr.count {\\n            if arr[i] == \"(\" {\\n                val += 1\\n            } else {\\n                val -= 1\\n                if arr[i-1] == \"(\" { res += 1 << val }\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.008 (0.009) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.scoreOfParentheses(\"()\")\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.scoreOfParentheses(\"(())\")\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.scoreOfParentheses(\"()()\")\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func scoreOfParentheses(_ s: String) -> Int {\\n        \\n        var arr = Array(s), val = 0, res = 0\\n        \\n        for i in 0 ..< arr.count {\\n            if arr[i] == \"(\" {\\n                val += 1\\n            } else {\\n                val -= 1\\n                if arr[i-1] == \"(\" { res += 1 << val }\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.scoreOfParentheses(\"()\")\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.scoreOfParentheses(\"(())\")\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.scoreOfParentheses(\"()()\")\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354283,
                "title": "python-using-stack",
                "content": "class Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        \\n        if not S:\\n            return 0\\n\\n        count = 0\\n        stack = []\\n        flag = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                flag = 1\\n                stack.append(\"(\")\\n            if S[i] == \")\":\\n                if flag == 1:\\n                    count += 2**(len(stack)-1)\\n                    flag = 0                \\n                stack.pop()\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        \\n        if not S:\\n            return 0\\n\\n        count = 0\\n        stack = []\\n        flag = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                flag = 1\\n                stack.append(\"(\")\\n            if S[i] == \")\":\\n                if flag == 1:\\n                    count += 2**(len(stack)-1)\\n                    flag = 0                \\n                stack.pop()\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 3100132,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int x=0;\\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                st.push(x);\\n                x=0;\\n            }\\n            else\\n            {\\n                if(x==0)\\n                x=1;\\n                else\\n                x*=2;\\n                x+=st.top();\\n                st.pop();\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int x=0;\\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                st.push(x);\\n                x=0;\\n            }\\n            else\\n            {\\n                if(x==0)\\n                x=1;\\n                else\\n                x*=2;\\n                x+=st.top();\\n                st.pop();\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197544,
                "title": "java-basic-stack-based-solution-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        int res = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            char c = S.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(0);\\n            } else if (c == \\')\\') {\\n                int pop = stack.pop() * 2;\\n                pop = (pop == 0) ? 1 : pop;\\n                if (! stack.isEmpty()) {\\n                    int top = stack.pop();\\n                    stack.push(top + pop);\\n                } else {\\n                    res += pop;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nOur line of thinking is like this: when you see a new opening bracket, you\\'ll later need to double the \"score\" of everything inside of it. When you see a closing bracket, pop the stack to retrieve the \"score\" of what\\'s inside the pair, double the score (because of (A) = 2 * A, given in problem), then use it as a sum term; if it\\'s inside another bracket, then add that to what\\'s now at the top of the stack, because it needs to be part of that \"doubling\" operation. If the stack is empty, then just add it straight to your final answer.\\n\\nThe ternary operator in the popping operation area is because if you end up with \\'()\\', there is nothing inside of it, but the score should be 1, not 0. So, we treat that as a special case.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        int res = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            char c = S.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(0);\\n            } else if (c == \\')\\') {\\n                int pop = stack.pop() * 2;\\n                pop = (pop == 0) ? 1 : pop;\\n                if (! stack.isEmpty()) {\\n                    int top = stack.pop();\\n                    stack.push(top + pop);\\n                } else {\\n                    res += pop;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142807,
                "title": "a-few-solutions",
                "content": "Perform a linear scan of the input string `s` keeping track of the parenthesis `depth` to accumulate the answer `ans` by performing reductions when the previous `pre` and current `cur` characters are `\\'(\\'` and `\\')\\'` correspondingly.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun scoreOfParentheses(s: String): Int {\\n        var ans = 0\\n        var pre = \\'0\\'\\n        var depth = 0\\n        for (cur in s) {\\n            depth += if (cur == \\'(\\') 1 else -1\\n            if (pre == \\'(\\' && cur == \\')\\')\\n                ans += 1 shl depth\\n            pre = cur\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet scoreOfParentheses = (s, depth = 0, pre = \\'0\\', ans = 0) => {\\n    for (cur of s) {\\n        depth = cur == \\'(\\' ? depth + 1 : depth - 1;\\n        if (pre == \\'(\\' && cur == \\')\\')\\n            ans += 1 << depth;\\n        pre = cur;\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str, depth = 0, pre = \\'0\\', ans = 0) -> int:\\n        for cur in s:\\n            depth += 1 if cur == \\'(\\' else -1\\n            if pre == \\'(\\' and cur == \\')\\':\\n                ans += 1 << depth\\n            pre = cur\\n        return ans\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn score_of_parentheses(s: String) -> i32 {\\n        let mut ans = 0;\\n        let mut pre = \\'0\\';\\n        let mut depth = 0;\\n        for cur in s.chars() {\\n            depth += if cur == \\'(\\' { 1 } else { -1 };\\n            if pre == \\'(\\' && cur == \\')\\' {\\n                ans += 1 << depth;\\n            }\\n            pre = cur;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s, int depth = 0, char pre = \\'0\\', int ans = 0) {\\n        for (auto cur: s) {\\n            depth = cur == \\'(\\' ? depth + 1 : depth - 1;\\n            if (pre == \\'(\\' && cur == \\')\\')\\n                ans += 1 << depth;\\n            pre = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun scoreOfParentheses(s: String): Int {\\n        var ans = 0\\n        var pre = \\'0\\'\\n        var depth = 0\\n        for (cur in s) {\\n            depth += if (cur == \\'(\\') 1 else -1\\n            if (pre == \\'(\\' && cur == \\')\\')\\n                ans += 1 shl depth\\n            pre = cur\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nlet scoreOfParentheses = (s, depth = 0, pre = \\'0\\', ans = 0) => {\\n    for (cur of s) {\\n        depth = cur == \\'(\\' ? depth + 1 : depth - 1;\\n        if (pre == \\'(\\' && cur == \\')\\')\\n            ans += 1 << depth;\\n        pre = cur;\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str, depth = 0, pre = \\'0\\', ans = 0) -> int:\\n        for cur in s:\\n            depth += 1 if cur == \\'(\\' else -1\\n            if pre == \\'(\\' and cur == \\')\\':\\n                ans += 1 << depth\\n            pre = cur\\n        return ans\\n```\n```\\nimpl Solution {\\n    pub fn score_of_parentheses(s: String) -> i32 {\\n        let mut ans = 0;\\n        let mut pre = \\'0\\';\\n        let mut depth = 0;\\n        for cur in s.chars() {\\n            depth += if cur == \\'(\\' { 1 } else { -1 };\\n            if pre == \\'(\\' && cur == \\')\\' {\\n                ans += 1 << depth;\\n            }\\n            pre = cur;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s, int depth = 0, char pre = \\'0\\', int ans = 0) {\\n        for (auto cur: s) {\\n            depth = cur == \\'(\\' ? depth + 1 : depth - 1;\\n            if (pre == \\'(\\' && cur == \\')\\')\\n                ans += 1 << depth;\\n            pre = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141786,
                "title": "c-java-3-lines-recursion",
                "content": "Search for the first balanced group, multiply by 2 the value of the inner string, and add the value of the remaning string.\\n```\\nint scoreOfParentheses(string S, int i = 1) {\\n  if (S.size() == 0) return 0;\\n  for (auto ch = 1; ch != 0; ++i) ch += S[i] == \\'(\\' ? 1 : -1;\\n  return (i == 2 ? 1 : 2 * scoreOfParentheses(S.substr(1, i - 2))) + scoreOfParentheses(S.substr(i));\\n}\\n```\\nJava version:\\n```\\npublic int scoreOfParentheses(String S) {\\n    int ch = S.length() == 0 ? 0 : 1, i = 1;\\n    for (; ch != 0; ++i) ch += S.charAt(i) == \\'(\\' ? 1 : -1;\\n    return i == 1 ? 0 : (i == 2 ? 1 : 2 * scoreOfParentheses(S.substring(1, i - 1))) + scoreOfParentheses(S.substring(i));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string S, int i = 1) {\\n  if (S.size() == 0) return 0;\\n  for (auto ch = 1; ch != 0; ++i) ch += S[i] == \\'(\\' ? 1 : -1;\\n  return (i == 2 ? 1 : 2 * scoreOfParentheses(S.substr(1, i - 2))) + scoreOfParentheses(S.substr(i));\\n}\\n```\n```\\npublic int scoreOfParentheses(String S) {\\n    int ch = S.length() == 0 ? 0 : 1, i = 1;\\n    for (; ch != 0; ++i) ch += S.charAt(i) == \\'(\\' ? 1 : -1;\\n    return i == 1 ? 0 : (i == 2 ? 1 : 2 * scoreOfParentheses(S.substring(1, i - 1))) + scoreOfParentheses(S.substring(i));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858290,
                "title": "score-of-parentheses-o-n-simple-java-for-loop",
                "content": "Hello everyone,\\n\\nThe description looks like an easy one, but little tricks are there.\\n\\nI did not use data structures as the restrictions are straightforward.\\nThe idea and thought process behind this is as follows:\\n\\t1. Based on the conditions, we could see the first character will be an open bracket\\n\\t2. Whenever open bracket and close bracket comes together -> () we will sum the result\\n\\t3. Another thing is we have to double the bracket whenever we see an open bracket -> \\'(\\'  and divide the bracket whenever we see close bracket -> \\')\\'\\n\\nThese 3 points will work even with any loops. Please upvote if its helpful.. Happy learning :)\\n\\n```\\n    public int scoreOfParentheses(String s) {\\n        int res = 0;\\n        int bracket = 0;\\n        for(int i=0; i<s.length(); i++){\\n        \\tif(s.charAt(i)==\\'(\\')\\n            \\tbracket*=2;\\n        \\tif(bracket==0)\\n        \\t\\tbracket=1;\\n        \\tif(s.charAt(i)==\\')\\' && s.charAt(i-1)==\\'(\\')\\n        \\t\\tres = res + bracket;\\n        \\tif(s.charAt(i)==\\')\\')\\n        \\t\\tbracket/=2;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hello everyone,\\n\\nThe description looks like an easy one, but little tricks are there.\\n\\nI did not use data structures as the restrictions are straightforward.\\nThe idea and thought process behind this is as follows:\\n\\t1. Based on the conditions, we could see the first character will be an open bracket\\n\\t2. Whenever open bracket and close bracket comes together -> () we will sum the result\\n\\t3. Another thing is we have to double the bracket whenever we see an open bracket -> \\'(\\'  and divide the bracket whenever we see close bracket -> \\')\\'\\n\\nThese 3 points will work even with any loops. Please upvote if its helpful.. Happy learning :)\\n\\n```\\n    public int scoreOfParentheses(String s) {\\n        int res = 0;\\n        int bracket = 0;\\n        for(int i=0; i<s.length(); i++){\\n        \\tif(s.charAt(i)==\\'(\\')\\n            \\tbracket*=2;\\n        \\tif(bracket==0)\\n        \\t\\tbracket=1;\\n        \\tif(s.charAt(i)==\\')\\' && s.charAt(i-1)==\\'(\\')\\n        \\t\\tres = res + bracket;\\n        \\tif(s.charAt(i)==\\')\\')\\n        \\t\\tbracket/=2;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1857804,
                "title": "c-3-approach-stack-in-place-stack-counter",
                "content": "# 1. stack approach\\nBy intuitation of this problem, many people can use stack to solve it.\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> stk;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                stk.push( stk.empty()?1:stk.top()*2);\\n            } else {//s[i]==\\')\\'\\n                sum +=stk.top();\\n                stk.pop();\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        return sum;        \\t\\n\\t}\\n};\\n```\\nTime complexity = O(n), Space complexity = O(n)\\nNow, we want to improve space complexity from O(n) to O(1)\\n\\n\\n# in-place stack approach but out of value\\n\\nWe use the space in left part of string s as the in-place stack. \\nWe can have the following solution but character only can show 0~255. \\nbut 2^50 is larget than 255. \\nSo, the in-place stack approach is out of char value for this algorithm.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        //stack<int> stk;\\n        int stk_idx=-1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                //stk.push( stk.empty()?1:stk.top()*2);\\n                s[++stk_idx] = stk_idx==-1?1:s[stk_idx]*2;\\n            } else {//s[i]==\\')\\'\\n                //sum +=stk.top();\\n                sum +=s[stk_idx];\\n                //stk.pop();\\n                --stk_idx;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    //stk.pop();\\n                    --stk_idx;\\n                }\\n            }\\n        }\\n        return sum;\\n\\t}\\n};\\n```\\n# 2. in-place stack approach \\nBecause the sum always add value of power(2, x). \\nwe can save x in the in-place stack. so the in-place stack \\nwill not out of value. \\n\\nTime complexity O(n)\\nSpace complexity O(1)\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        //stack<int> stk;\\n        int stk_idx=-1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                //stk.push( stk.empty()?1:stk.top()*2);\\n                s[++stk_idx] = stk_idx==-1?0:s[stk_idx]+1;\\n            } else {//s[i]==\\')\\'\\n                //sum +=stk.top();\\n                //sum +=s[stk_idx];\\n                sum += 1<<s[stk_idx];\\n                //stk.pop();\\n                --stk_idx;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    //stk.pop();\\n                    --stk_idx;\\n                }\\n            }\\n        }\\n        return sum;\\t\\n\\t}\\n};\\n```\\n\\n# in-place stack approach that simplify into one variable\\nIn the previous method, you can observe the values store in your stack \\nis somethign like [1,2,3,4,5,...,t]. Thus one variable can represent this stack. \\nWe have the following code to use one variable to represent this stack.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int stk= -1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                ++stk;\\n            } else {\\n                sum += 1<<(stk);\\n                --stk;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    ++i;\\n                    --stk;\\n                }\\n            }\\n        }\\n        return sum;        \\n\\t}\\n};\\n```\\n\\nThat\\'s so interesting, the stack is become a counter.\\nAnd we need to observe more and find out new approach. \\n`()` = 1 = 2^`0` .The substring lead by `()` is `()`.\\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 0\\n\\n((((`()`)))) = 2^`4`  The substring lead by `()` is (((((), \\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 4\\n\\nObserve this string\\n((((`()`)(`()`))))\\n\\nthere are two `()` in this string, and each `()` mean one value.\\nso we need to sum of this two values. \\nThe substring lead by left `()` is (((((), so \\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 4\\nSo, the value for left  `()` is 2^4. \\n\\nThe substring lead by right `()` is (((((), so \\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 4\\nSo, the value for left  `()` is 2^4. \\n\\nFor the right `()`, the substring it lead is ((((())(() , so \\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 4\\nThe value of right `()` is 2^4. \\n\\nSo the value of \"((((())(()))))\" is 2^4 + 2^4 = 32 \\n\\nFor this observation , we can write the following counter approach.\\n# 3. counter approach\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int cnt= 0;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                ++cnt;\\n            } else if(s[i]==\\')\\') {\\n                --cnt;\\n            }\\n            if(i-1>=0 && s[i-1]==\\'(\\' && s[i]==\\')\\') {\\n                sum += 1<<cnt;\\n            }\\n            \\n        }\\n        return sum;\\t\\n\\t}\\n};\\n```\\nTime complexity : O(n)\\nSpace complexity: O(1)\\n\\nThere is something intresting here. \\nIf you compare the two source code from \\n**in-place stack approach that simplify into one variable**  \\nand **counter approach**. these two source code  are almost the same. \\n\\nBy the way, if you want to optimize the code of counter approach, we can do this\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int cnt= 0, ans =0, n = s.length();\\n        for(int i = 0;i<n;i++) \\n            if(s[i] == \\'(\\')\\n                ++cnt;\\n            else\\n                ans += (s[i-1]==\\'(\\')<<--cnt;\\n        return ans;\\t\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> stk;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                stk.push( stk.empty()?1:stk.top()*2);\\n            } else {//s[i]==\\')\\'\\n                sum +=stk.top();\\n                stk.pop();\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        return sum;        \\t\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        //stack<int> stk;\\n        int stk_idx=-1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                //stk.push( stk.empty()?1:stk.top()*2);\\n                s[++stk_idx] = stk_idx==-1?1:s[stk_idx]*2;\\n            } else {//s[i]==\\')\\'\\n                //sum +=stk.top();\\n                sum +=s[stk_idx];\\n                //stk.pop();\\n                --stk_idx;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    //stk.pop();\\n                    --stk_idx;\\n                }\\n            }\\n        }\\n        return sum;\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        //stack<int> stk;\\n        int stk_idx=-1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                //stk.push( stk.empty()?1:stk.top()*2);\\n                s[++stk_idx] = stk_idx==-1?0:s[stk_idx]+1;\\n            } else {//s[i]==\\')\\'\\n                //sum +=stk.top();\\n                //sum +=s[stk_idx];\\n                sum += 1<<s[stk_idx];\\n                //stk.pop();\\n                --stk_idx;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    //stk.pop();\\n                    --stk_idx;\\n                }\\n            }\\n        }\\n        return sum;\\t\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int stk= -1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                ++stk;\\n            } else {\\n                sum += 1<<(stk);\\n                --stk;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    ++i;\\n                    --stk;\\n                }\\n            }\\n        }\\n        return sum;        \\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int cnt= 0;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                ++cnt;\\n            } else if(s[i]==\\')\\') {\\n                --cnt;\\n            }\\n            if(i-1>=0 && s[i-1]==\\'(\\' && s[i]==\\')\\') {\\n                sum += 1<<cnt;\\n            }\\n            \\n        }\\n        return sum;\\t\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int cnt= 0, ans =0, n = s.length();\\n        for(int i = 0;i<n;i++) \\n            if(s[i] == \\'(\\')\\n                ++cnt;\\n            else\\n                ans += (s[i-1]==\\'(\\')<<--cnt;\\n        return ans;\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856605,
                "title": "c-simplest-solution-0ms-w-explanation",
                "content": "The approach is to use stack but it\\'s a little different from our intuition. We do not push the characters in the given string. \\nInstead, we push the score onto stack.\\n\\n**APPROACH :**\\n\\n* We start with ```score = 0```.\\n\\n* If the current char is ```(```, we push the curr score on to the stack & reset the score to ```0```.\\n\\n*  Else if the current character is ```)```, we calculate the score & pop the top of the stack :\\n\\n         1. ```score = st.top() + max(score*2 + 1)``` .\\n         \\n         2. This is because, we need to add the previous score as we traverse the string & compute the current score (```st.top()```)\\n         \\n         3. If the score is set back to ```0```, after a ```(``` is pushed, then the score has to be ```1``` when ```)``` is encountered.\\n         \\n         4. If the parantheses are this way -- ```( ( ) )```, then the inner parantheses score is computed as ```1``` & then we encounter the outer ```)```.\\n         \\n         5. Now, the score is ```1```, so we need to do ```2*score```.\\n         \\n         6. Add the current score to the previous : ```curr score+ st.top()```\\n\\n\\n**Time Complexity :** O(n) - We are visiting each character only once.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.size(), score = 0;\\n        stack<int> st;\\n        \\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\') {\\n                st.push(score);\\n                score = 0;\\n            } else {\\n                score = st.top() + max(2*score, 1);\\n                st.pop();\\n            }\\n            \\n        }\\n        return score;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```score = 0```\n```(```\n```0```\n```)```\n```score = st.top() + max(score*2 + 1)```\n```st.top()```\n```0```\n```(```\n```1```\n```)```\n```( ( ) )```\n```1```\n```)```\n```1```\n```2*score```\n```curr score+ st.top()```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.size(), score = 0;\\n        stack<int> st;\\n        \\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\') {\\n                st.push(score);\\n                score = 0;\\n            } else {\\n                score = st.top() + max(2*score, 1);\\n                st.pop();\\n            }\\n            \\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231515,
                "title": "c-0ms-sol-beats-100-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> stk;\\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                //we store the \\'(\\' as -1 in stack\\n                stk.push(-1);\\n            }\\n            else{\\n                int res=0;\\n                    while(stk.top()!=-1)\\n                    {\\n                        //until a opening bracket\\n                        //we sum up all the numbers \\n                        //multiply by 2 and we push it\\n                        res+=stk.top();\\n                        stk.pop();\\n                    }\\n                //remove the opening bracket\\n                stk.pop();\\n                (res==0) ? stk.push(1) : stk.push(2*res);\\n            }\\n        }\\n        int ans=0;\\n        while (!stk.empty()){\\n            ans+=stk.top();\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> stk;\\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                //we store the \\'(\\' as -1 in stack\\n                stk.push(-1);\\n            }\\n            else{\\n                int res=0;\\n                    while(stk.top()!=-1)\\n                    {\\n                        //until a opening bracket\\n                        //we sum up all the numbers \\n                        //multiply by 2 and we push it\\n                        res+=stk.top();\\n                        stk.pop();\\n                    }\\n                //remove the opening bracket\\n                stk.pop();\\n                (res==0) ? stk.push(1) : stk.push(2*res);\\n            }\\n        }\\n        int ans=0;\\n        while (!stk.empty()){\\n            ans+=stk.top();\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098596,
                "title": "2-solutions-with-pictures",
                "content": "The first idea is straightforward:\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/b908f74e-09de-4e16-b417-a529bc2bdecd_1615384272.95443.png)\\n\\n<br>\\n\\nIn order to store the results of `B` calculation we need a separate variable from the one we used for `A`. After we are done with `B` we no longer need it as we add it to \\'A\\'. But in the process of calculating `B` we may need new variable to calculate say `C`. It seems like we have recursion and we need a stack to store the calculations on the current recursive call. Also there are two alternatives:\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/428b95c1-25b5-47fd-a4dc-68fd0c01920a_1615386243.2236943.png)\\n\\n\\n<br>\\n\\nThat\\'s not that important, you can do it either way.\\n\\n**`Stack` based \"delayed\" calculations**: time `O(N)`, space `O(N)`\\nAs we have seen the basic idea is the following:\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/617dfffb-40f5-448a-96af-3ed18cbb45fa_1615301025.9395669.png)\\n\\n<br>\\n\\nHere the caller does the doubling and adding.\\nYou can think about it like a company that has bank account(stack frame). Inside a mother company there are multiple projects(labs). Every time a new project is created it\\'s given it\\'s own bank account with `0` money on it. At the end of the project it\\'s earned money is funnelled back into the mother organization. Projects are allowed to open it\\'s own subprojects. That\\'s recursion, hence the use of stack.\\n\\nHere\\'s implementation and a more accurate picture. The calee does the doubling and the caller does the adding. New stack is created every time `\\'(\\'` is encountered and is closed in case of `\\')\\'`.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/86ed0703-b119-489d-bd03-4acc2c0aef20_1615397817.871677.png)\\n\\n<br>\\n\\nAll in all the above algo is **DFS** in the following tree.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/fdcd1f99-6a9a-4725-9eee-ea7bab0084e8_1615402799.2036629.png)\\n\\n<br>\\n\\n*Iterative*\\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tstack<int> st({0});\\n\\tfor(const auto & c : s)\\n\\t\\tif(c==\\')\\')\\n\\t\\t{\\n\\t\\t\\tauto t{max(1, 2*st.top())};\\n\\t\\t\\tst.pop();\\n\\t\\t\\tst.top() += t;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tst.push(0);\\n\\n\\treturn st.top();\\n}\\n```\\n*Recursive*\\n```\\nint scoreOfParentheses(string & s, int && i = -1) \\n{\\n\\tint out{0};\\n\\tfor( ; ++i<size(s); )\\n\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\tout+=scoreOfParentheses(s, move(i)); \\n\\t\\telse\\n\\t\\t\\treturn max(1, 2*out);\\n\\n\\treturn out;\\n}\\n```\\n**Global_state_variable based \"global\" calculations**:  time `O(N)`, space `O(1)`\\nAs we can see all we do is the doubling and adding (in other words we are adding the powers of two). Instead of adding `b` and `c` and then adding the `out` variable, we can add `b` to result and  `c` to `out` **directly**.\\nThus the adding is done only at the **leaf-nodes** of the tree, but to do that they need to know their height.\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/e339f56e-5836-4b07-9146-e0dbd3c145fb_1615402274.453685.png)\\n\\n\\n<br>\\n\\nIn fact you don\\'t need stacks and trees, you can use one variable to track height (or power of two) and modify `out` when you encounter `()`(leaf).\\n\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/06b5736c-5fab-4a1b-91ee-1de12514b9d1_1615298484.7858808.png)\\n\\n*Iterative*\\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tauto out{0};\\n\\tfor(auto i{0}, p{1}; i<size(s); ++i)\\n\\t{\\n\\t\\tp = s[i]==\\')\\' ? p/2 : p*2;\\n\\t\\tif(s[i]==\\')\\' and s[i-1]==\\'(\\') out+=p;            \\n\\t}\\n\\n\\treturn out;\\n}\\n```\\n||\\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tauto out{0};\\n\\tfor(auto i{0}, p{1}; i<size(s); ++i)\\n\\t\\tif(s[i]==\\')\\')\\n\\t\\t{\\n\\t\\t\\tp>>=1;\\n\\t\\t\\tif(s[i-1]==\\'(\\') out+=p;   \\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tp<<=1;\\n\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint scoreOfParentheses(string s) \\n{\\n\\tstack<int> st({0});\\n\\tfor(const auto & c : s)\\n\\t\\tif(c==\\')\\')\\n\\t\\t{\\n\\t\\t\\tauto t{max(1, 2*st.top())};\\n\\t\\t\\tst.pop();\\n\\t\\t\\tst.top() += t;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tst.push(0);\\n\\n\\treturn st.top();\\n}\\n```\n```\\nint scoreOfParentheses(string & s, int && i = -1) \\n{\\n\\tint out{0};\\n\\tfor( ; ++i<size(s); )\\n\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\tout+=scoreOfParentheses(s, move(i)); \\n\\t\\telse\\n\\t\\t\\treturn max(1, 2*out);\\n\\n\\treturn out;\\n}\\n```\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tauto out{0};\\n\\tfor(auto i{0}, p{1}; i<size(s); ++i)\\n\\t{\\n\\t\\tp = s[i]==\\')\\' ? p/2 : p*2;\\n\\t\\tif(s[i]==\\')\\' and s[i-1]==\\'(\\') out+=p;            \\n\\t}\\n\\n\\treturn out;\\n}\\n```\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tauto out{0};\\n\\tfor(auto i{0}, p{1}; i<size(s); ++i)\\n\\t\\tif(s[i]==\\')\\')\\n\\t\\t{\\n\\t\\t\\tp>>=1;\\n\\t\\t\\tif(s[i-1]==\\'(\\') out+=p;   \\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tp<<=1;\\n\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081394,
                "title": "c-single-pass-constant-space-solutions-explained-100-time-80-space",
                "content": "Read this problem this morning, had an intuition (well, a partial one) and my mind kept working on it in any break I took.\\n\\nAnd this is the final version.\\n\\nThe key intuition was to navigate it like a tree, but possibly in constant time; and then I realised that the trick is to keep track of how deep we go and add something to an accumulator variable only when we find `\\'(\\'` immediately followed by `\\')\\'` - which means we found a base expression `\"()\"` whose score is going to be equal to `pow(2, depthOfTheExpression)`.\\n\\nAny other instance of `\\'(\\'` or `\\')\\'` will just mean to go either deeper or up in an ideally nested tree.\\n\\nTo do so, we declared a few support variables:\\n* `res` is going to be our accumulator, initially set to `0`;\\n* `isOpen` is a boolean to keep track of the logic above and we will set it to `true` after each `\\'(\\'` and to `false` after each `\\')\\'`.\\n\\nTime then for the main loop, going with `i` up to `lmt` (the length of the string), setting also a counting variable `c = 0` and:\\n* when `s[i] == \\'(\\'` we will:\\n\\t* set `isOpen` to `true`;\\n\\t* increase `c`;\\n* otherwise:\\n\\t* decrease `c`;\\n\\t* if `isOpen` we will additionally:\\n\\t\\t* increase `res` by `pow(2, c)` (note that we decrease `c` in advance, not to count the current level);\\n\\t\\t* reset `isOpen` to `false`.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        // support variables\\n        int res = 0;\\n        bool isOpen;\\n        // looping through all the characters\\n        for (int i = 0, c = 0, lmt = s.size(); i < lmt; i++) {\\n            // opening parentheses\\n            if (s[i] == \\'(\\') {\\n                c++;\\n                isOpen = true;\\n            }\\n            // closing parentheses\\n            else {\\n                c--;\\n                if (isOpen) {\\n                    isOpen = false;\\n                    res += pow(2, c);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\nAnd then it occurred to me that we do not really need even the boolean flag, since just looking at the previous character (and we know that since the string is balance we will never encounter a `\\')\\'` at the beginning of the string) tells us just the same; surprisingly, we save a good chunk of memory this way - I guess mostly for not having to do needless operations:\\n\\n```cpp\\npublic:\\n    int scoreOfParentheses(string s) {\\n        // support variables\\n        int res = 0;\\n        // looping through all the characters\\n        for (int i = 0, c = 0, lmt = s.size(); i < lmt; i++) {\\n            // opening parentheses\\n            if (s[i] == \\'(\\') c++;\\n            // closing parentheses\\n            else {\\n                c--;\\n                if (s[i - 1] == \\'(\\') res += pow(2, c);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFinally, same logic in recursive format, just for the lolZ - going as fast, just burning a bit more memory:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s, int pos = 0, int c = 0, int res = 0) {\\n        return pos == s.size() ? res : scoreOfParentheses(s, pos + 1, c + (s[pos] == \\'(\\' ? 1 : -1), res + ((c && s[pos - 1] == \\'(\\' && s[pos] == \\')\\') ? pow(2, c - 1) : 0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        // support variables\\n        int res = 0;\\n        bool isOpen;\\n        // looping through all the characters\\n        for (int i = 0, c = 0, lmt = s.size(); i < lmt; i++) {\\n            // opening parentheses\\n            if (s[i] == \\'(\\') {\\n                c++;\\n                isOpen = true;\\n            }\\n            // closing parentheses\\n            else {\\n                c--;\\n                if (isOpen) {\\n                    isOpen = false;\\n                    res += pow(2, c);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\npublic:\\n    int scoreOfParentheses(string s) {\\n        // support variables\\n        int res = 0;\\n        // looping through all the characters\\n        for (int i = 0, c = 0, lmt = s.size(); i < lmt; i++) {\\n            // opening parentheses\\n            if (s[i] == \\'(\\') c++;\\n            // closing parentheses\\n            else {\\n                c--;\\n                if (s[i - 1] == \\'(\\') res += pow(2, c);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s, int pos = 0, int c = 0, int res = 0) {\\n        return pos == s.size() ? res : scoreOfParentheses(s, pos + 1, c + (s[pos] == \\'(\\' ? 1 : -1), res + ((c && s[pos - 1] == \\'(\\' && s[pos] == \\')\\') ? pow(2, c - 1) : 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081329,
                "title": "score-of-parentheses-easy-to-understand-explanation-javascript-code",
                "content": "Initially I read this and it seemed quite easy.  However once I tried to implement it, I was caught up in odd recursive calls which sometimes worked, and others didn\\'t.  After passing my 30minute self timer I gave up and went to the solution.  Even understanding that was a challenge so I will attempt to improve on the solution explanation.\\n\\nOk, one way to think of this problem is in the number of \\'()\\' or cores.  I dont mean nesting, I mean the literal \\'()\\'.  The answer is the sum of those values.  The nesting only serves to double their value.  So, no need to do a recursive call, or even use a stack.  \\n\\nHow can we do this in a linear fashion?  Ok, loop though your string.  Every time u notice a (, you increment your depth counter.  If the current char is not a (, it must be a ).  Now you have two possibilities, the previous char could have been a (, in which case, u\\'ve got a core (), so add its value to the score (more on the calc later, see next paragraph).  Or the previous character could have been another ), ie )).  In that case u don\\'t have a core, but you still need to decrement the nesting level, which previously you had incremented on a prior iteration of seeing (.  \\n\\nRegarding that core value.  What is it?  Well check how many levels it is nested and double its value that many times.  So (()) would be 1*2^depth or using a bitwise operator, 1 shifted 1 place, so 1 << 1 = 2  \\n\\nIn summary: The trick is to evaluate each \\'core\\' as you encounter it, adding its value to the score. For it\\'s score, you\\'ll keep track of how deep the nesting is, sometimes decrementing the nesting as necessary when you find closing parens.\\n\\n```\\nvar scoreOfParentheses = function(S) {\\n  let score = 0, depth = 0;\\n  for (let i=0, j=S.length; i<j; i++) { // linear left to right iteration\\n    if (S.charAt(i) == \\'(\\')  // found ( so increment depth\\n\\t\\tdepth++;\\n    else if (S.charAt(i-1) == \\'(\\')  // found () a core, so time to add its calculated value to score\\n       score += 1 << --depth;  //binary bit shift operator, doubling value by depth\\n    else \\n\\t\\t--depth; // not a core, but need to unwrap a layer of nesting\\n  }\\n  return score;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar scoreOfParentheses = function(S) {\\n  let score = 0, depth = 0;\\n  for (let i=0, j=S.length; i<j; i++) { // linear left to right iteration\\n    if (S.charAt(i) == \\'(\\')  // found ( so increment depth\\n\\t\\tdepth++;\\n    else if (S.charAt(i-1) == \\'(\\')  // found () a core, so time to add its calculated value to score\\n       score += 1 << --depth;  //binary bit shift operator, doubling value by depth\\n    else \\n\\t\\t--depth; // not a core, but need to unwrap a layer of nesting\\n  }\\n  return score;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1080564,
                "title": "python-o-n-by-stack-w-comment",
                "content": "Python O(n) by stack\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        \\n        \\n        stack = []\\n\\t\\t\\n\\t\\t# cur: total score so far\\n\\t\\t# prev: previous score\\n        cur, prev = 0, 0\\n        \\n        \\n        # scan each symbol in input S\\n        for char in S:\\n            \\n            if char == \\'(\\':\\n                \\n                # \\'(\\', push in with current socre\\n                stack.append( cur )\\n                \\n                # reset previous and current to zero\\n                prev, cur = 0, 0\\n            \\n            else:\\n                \\n                # \\')\\' match with latest \\'(\\', get top score\\n                top = stack.pop()\\n                \\n                if prev:\\n                    # we have valid parenthesis pair inside, add prev\\n                    cur += top + prev\\n                else:\\n                    # no parenthesis pair inside, directly add 1\\n                    cur += top + 1\\n            \\n            # update previous as current\\n            prev = cur\\n        \\n        \\n        # total score so far\\n        return cur\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        \\n        \\n        stack = []\\n\\t\\t\\n\\t\\t# cur: total score so far\\n\\t\\t# prev: previous score\\n        cur, prev = 0, 0\\n        \\n        \\n        # scan each symbol in input S\\n        for char in S:\\n            \\n            if char == \\'(\\':\\n                \\n                # \\'(\\', push in with current socre\\n                stack.append( cur )\\n                \\n                # reset previous and current to zero\\n                prev, cur = 0, 0\\n            \\n            else:\\n                \\n                # \\')\\' match with latest \\'(\\', get top score\\n                top = stack.pop()\\n                \\n                if prev:\\n                    # we have valid parenthesis pair inside, add prev\\n                    cur += top + prev\\n                else:\\n                    # no parenthesis pair inside, directly add 1\\n                    cur += top + 1\\n            \\n            # update previous as current\\n            prev = cur\\n        \\n        \\n        # total score so far\\n        return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939553,
                "title": "python3-stack-o-n",
                "content": "Approach 1 - stack `O(N)` space \\nDefine `stack` to store values when entering into a pair parenthesis. \\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, stack = 0, []\\n        for c in S: \\n            if c == \"(\": \\n                stack.append(ans)\\n                ans = 0\\n            else: ans = max(1, 2*ans) + stack.pop()\\n        return ans\\n```\\n\\nApproach 2 - `O(1)` space \\nThe required value is related to the depth of parenthesis via `2**k`. \\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans = k = 0\\n        for i in range(len(S)): \\n            k += 1 if S[i] == \"(\" else -1\\n            if S[i-1:i+1] == \"()\": ans += 2**k\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, stack = 0, []\\n        for c in S: \\n            if c == \"(\": \\n                stack.append(ans)\\n                ans = 0\\n            else: ans = max(1, 2*ans) + stack.pop()\\n        return ans\\n```\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans = k = 0\\n        for i in range(len(S)): \\n            k += 1 if S[i] == \"(\" else -1\\n            if S[i-1:i+1] == \"()\": ans += 2**k\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 512631,
                "title": "python-simple-readable-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, val = 0, 1\\n        for i in range(len(S) - 1):\\n            if S[i: i+2] == \\'((\\': val *= 2\\n            if S[i: i+2] == \\'()\\': ans += val\\n            if S[i: i+2] == \\'))\\': val //= 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, val = 0, 1\\n        for i in range(len(S) - 1):\\n            if S[i: i+2] == \\'((\\': val *= 2\\n            if S[i: i+2] == \\'()\\': ans += val\\n            if S[i: i+2] == \\'))\\': val //= 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141823,
                "title": "c-recursive",
                "content": "This is how many of the top scorers solved the problem.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(string s, int a, int b) {\\n        \\n        int v = 0;\\n        \\n        if (b - a == 1)  return 1; // \"()\"\\n                \\n        for (int i=a; i<=b; i++) {\\n            \\n            if (s[i] == \\'(\\') v++;\\n            else if (s[i] == \\')\\') v--;\\n            \\n            if (v==0 && i!=b)\\n                return helper(s, a, i) + helper(s, i+1, b); // (...) + (...)\\n        }\\n        \\n        return 2*helper(s, a+1, b-1); // (...)\\n\\n    }\\n\\n    \\n    int scoreOfParentheses(string S) {\\n        return helper(S, 0, S.length()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(string s, int a, int b) {\\n        \\n        int v = 0;\\n        \\n        if (b - a == 1)  return 1; // \"()\"\\n                \\n        for (int i=a; i<=b; i++) {\\n            \\n            if (s[i] == \\'(\\') v++;\\n            else if (s[i] == \\')\\') v--;\\n            \\n            if (v==0 && i!=b)\\n                return helper(s, a, i) + helper(s, i+1, b); // (...) + (...)\\n        }\\n        \\n        return 2*helper(s, a+1, b-1); // (...)\\n\\n    }\\n\\n    \\n    int scoreOfParentheses(string S) {\\n        return helper(S, 0, S.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405044,
                "title": "c-100-beats-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n\\n        for(auto it : s)    {\\n            if(it == \\'(\\')   st.push(-1);\\n            else if(st.top()==-1)    {\\n                st.pop();\\n                st.push(1);\\n            }\\n            else    {\\n                int x = 0;\\n                while(st.top() != -1)   {\\n                    x += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*x);\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty())  {\\n            ans += st.top();\\n            st.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n\\n        for(auto it : s)    {\\n            if(it == \\'(\\')   st.push(-1);\\n            else if(st.top()==-1)    {\\n                st.pop();\\n                st.push(1);\\n            }\\n            else    {\\n                int x = 0;\\n                while(st.top() != -1)   {\\n                    x += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*x);\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty())  {\\n            ans += st.top();\\n            st.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860335,
                "title": "explained-go-clean-solution-using-stack-beats-100-on-runtime-92-on-memory",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe Stack is a common data structure we use when dealing with parentheses problems.\\n\\nSo let\\'s implement a simple slice-based Stack:\\n    1. Create a Stack structure that holds the data field of type []rune.\\n    2. Define the Push method to add a new value to the Stack using simple append().\\n    3. Define the Pop method to remove the top element from the Stack returning this very element. We can remove the last element of the array using slicing: slice = slice[:len(slice)-1].\\n\\nThen we implement our business logic:\\n1. Initialize an empty stack and a multiplier equal to 1. The multiplier variable will be added to the answer every time we see the \"()\" in our input string.\\n2. Let\\'s loop through the input string: \\n    a. Pop the element from the top of the stack.\\n    b. If the top element is \\'(\\' and we got \\')\\' as the current character, add the multiplier to the answer.\\n    c. If we get two consecutive \"((\", then, as stated in the problem description, multiply the multiplier by 2.\\n    d. If we get two consecutive \"))\", then we divide the multiplier by 2.\\n    e. Push the current character to the stack.\\n\\n# Complexity\\n- Time complexity: $O(n)$ - one pass through the input string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$ - we need to store **at most** half of the input string in our stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Stack struct {\\n    data []rune\\n}\\n\\nfunc (s *Stack) Push(val rune) {\\n    s.data = append(s.data, val)\\n}\\n\\nfunc (s *Stack) Pop() rune {\\n    if len(s.data) == 0 {\\n        var r rune\\n        return r\\n    }\\n\\n    top := s.data[len(s.data) - 1]\\n    (*s).data = s.data[:len(s.data) - 1]\\n    return top\\n}\\n\\nfunc scoreOfParentheses(s string) int {\\n    var stack Stack\\n\\n    ans := 0\\n    multiplier := 1\\n    for _, c := range s {\\n        top := stack.Pop()\\n\\n        switch {\\n        case top == \\'(\\' && c == \\')\\':\\n            ans += multiplier\\n        case top == \\'(\\' && c == \\'(\\':\\n            multiplier *= 2\\n        case top == \\')\\' && c == \\')\\':\\n            multiplier /= 2\\n        }\\n\\n        stack.Push(c)\\n    }\\n\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Stack"
                ],
                "code": "```\\ntype Stack struct {\\n    data []rune\\n}\\n\\nfunc (s *Stack) Push(val rune) {\\n    s.data = append(s.data, val)\\n}\\n\\nfunc (s *Stack) Pop() rune {\\n    if len(s.data) == 0 {\\n        var r rune\\n        return r\\n    }\\n\\n    top := s.data[len(s.data) - 1]\\n    (*s).data = s.data[:len(s.data) - 1]\\n    return top\\n}\\n\\nfunc scoreOfParentheses(s string) int {\\n    var stack Stack\\n\\n    ans := 0\\n    multiplier := 1\\n    for _, c := range s {\\n        top := stack.Pop()\\n\\n        switch {\\n        case top == \\'(\\' && c == \\')\\':\\n            ans += multiplier\\n        case top == \\'(\\' && c == \\'(\\':\\n            multiplier *= 2\\n        case top == \\')\\' && c == \\')\\':\\n            multiplier /= 2\\n        }\\n\\n        stack.Push(c)\\n    }\\n\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1857575,
                "title": "python-solution-using-stack-with-explanation",
                "content": "```\\n######################################################\\n\\n#   Runtime: 28ms   -   94.45%\\n#   Memory: 13.8MB  -   70.86%\\n\\n######################################################\\n\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n\\n        stack = []\\n        # Looping through string\\n        for char in s:\\n            # If char is \"(\" we add it to stack\\n            if char == \"(\":\\n                stack.append(\"(\")\\n            else:\\n                # If char is \")\", we pop out the top element from stack till\\n                # we find \"(\". The popped elements will be 2 * score of child\\n                # balanced parentheses of current closed parentheses we have found\\n                # So we will add them to score var\\n                score = 0\\n                while stack[-1] != \"(\":\\n                    score += stack.pop()\\n                # If score is 0, that means the top of stack is \"(\" and we have\\n                # () in the string. So we make score 1\\n                if score == 0: score = 1\\n                # We remove \"(\" from stack\\n                stack.pop()\\n                # We append twice the actual score that a balanced parentheses should\\n                # have into the stack\\n                stack.append( 2 * score)\\n        # stack will have only 1 element if s is of format \"(A)\"\\n        # Else it will have > 1 element.\\n        # Each element will be int of scores multiplied by 2.\\n        # We add them and divide by 2 to remove that extra multiple 2 which we have done\\n        # in our logic\\n        return sum(stack) // 2\\n\\n        \"\"\"\\n            Example: \"(()())()\"\\n            char        stack\\n             (            [\"(\"]\\n             (            [\"(\", \"(\"]\\n             )            [\"(\", 2]\\n             (            [\"(\", 2, \"(\"]\\n             )            [\"(\", 2, 2]\\n             )            [8]\\n             (            [8, \"(\"]\\n             )            [8, 2]\\n\\n            Finally sum(stack) // 2\\n                    = (8 + 2) // 2\\n                    = 5\\n            which is the score of that string\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n######################################################\\n\\n#   Runtime: 28ms   -   94.45%\\n#   Memory: 13.8MB  -   70.86%\\n\\n######################################################\\n\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n\\n        stack = []\\n        # Looping through string\\n        for char in s:\\n            # If char is \"(\" we add it to stack\\n            if char == \"(\":\\n                stack.append(\"(\")\\n            else:\\n                # If char is \")\", we pop out the top element from stack till\\n                # we find \"(\". The popped elements will be 2 * score of child\\n                # balanced parentheses of current closed parentheses we have found\\n                # So we will add them to score var\\n                score = 0\\n                while stack[-1] != \"(\":\\n                    score += stack.pop()\\n                # If score is 0, that means the top of stack is \"(\" and we have\\n                # () in the string. So we make score 1\\n                if score == 0: score = 1\\n                # We remove \"(\" from stack\\n                stack.pop()\\n                # We append twice the actual score that a balanced parentheses should\\n                # have into the stack\\n                stack.append( 2 * score)\\n        # stack will have only 1 element if s is of format \"(A)\"\\n        # Else it will have > 1 element.\\n        # Each element will be int of scores multiplied by 2.\\n        # We add them and divide by 2 to remove that extra multiple 2 which we have done\\n        # in our logic\\n        return sum(stack) // 2\\n\\n        \"\"\"\\n            Example: \"(()())()\"\\n            char        stack\\n             (            [\"(\"]\\n             (            [\"(\", \"(\"]\\n             )            [\"(\", 2]\\n             (            [\"(\", 2, \"(\"]\\n             )            [\"(\", 2, 2]\\n             )            [8]\\n             (            [8, \"(\"]\\n             )            [8, 2]\\n\\n            Finally sum(stack) // 2\\n                    = (8 + 2) // 2\\n                    = 5\\n            which is the score of that string\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857281,
                "title": "java-0ms-no-stack-use-with-simple-math-based-on-depth-intuitive-with-explanation-o-1-space",
                "content": "## Score of Parentheses\\n[Based on the Amazing c++ solution given by @artod](https://leetcode.com/problems/score-of-parentheses/discuss/1856699/C%2B%2B-BEATS-100-OMG!!!)\\n\\nCredit to [Soba_1](https://leetcode.com/Soba_1/) for recommending the use of left shift operator on the original post to calculate the power of 2 which can increase the effeciency even more.\\n\\nFirst of all, wow, what an amazing solution by Artod for c++, it\\'s so simple and at the same time genius.\\nI am just adding on a bit more thought into it and trying to explain a bit more in depth about why it works with a solution in Java.\\n**Time: O(N) \\n Space: O(1)**\\n\\n**Explanation**\\n\\n**Problem with the simple detect nesting and add/multiply approach/ What didn\\'t work so smoothly:**\\n\\nWhile we can get caught up on the fact that how we can add the score when there is no nestin and how we can multiply it by 2 when there is nesting, when you start to code it, you realize that it becomes very complicated when you have to detect deep nesting, let\\'s say something like (()(((((()))))))). Trying to use a stack and a loop to track where the nesting starts and stops is possible but kind of complicated and can lead to a lot of issues which I faced as well when I was trying to brute force my way through it, I tried assigning a 1 every time opening and closing brackets were next to one another then I quickly realised there could be something like this (((()()())))()() and now I\\'ll need too many functions and loops with potential infinity loop problems if I tried to brute force my way through this.\\n\\n**How it was avoided with Math**\\n**Approach:** Score for each pair is actually dependent on how deep the pair is inside.\\n1. This Appraoch in comparison to brute forcing to detect nesting notices a very simple thing, instead of looking at a string (()()) as 2(1+1) we can also look at it like `2*1 +2*1` or `2^1 + 2^1`.\\n2. You can also look at something like ((( () () ) () ) as `2^3 + 2^3 + 2^2` instead of `((1+1)*2+1)*2`\\n3. What does this signify? For a deep bracket ((())) it\\'s going to be `2*2*1` which is actually just 2^how deep the pair without nesting was, hence if we calculate the individual score based upon the depth of non nested parentheses and add those, we\\'ll get the correct score.\\n4. If we look at it for a while, we\\'ll realise that we\\'re first following the distributive property of multiplication over addition and after that instead of multiplying by 2 for every level of nesting, we\\'re just using the power of 2.\\n\\nHence for example ((( () () ) () ) answer is more like\\n> score of how deep first () was + score of how deep second () was +score of how deep third () was.\\n which is in other words, 2^how deep the first () was+2^how deep the second () was + 2^ how deep the third () was.\\n \\n \\n **Code:**\\n```\\n class Solution {\\n    public int scoreOfParentheses(String s) {\\n        int score =0;\\n        int depth=0;\\n        int s_length=s.length();\\n        char prev=\\' \\';\\n        for(int i=0;i<s_length;i++){\\n            if(s.charAt(i)==\\'(\\')\\n                depth++;\\n            else{\\n                depth--;// ignore the parentheses we found just before ) as it\\'s not contributing to the depth\\n                if(prev==\\'(\\'){\\n                    score+=Math.pow(2,depth); //Calculate score for the () we just found and add it\\n\\t\\t\\t\\t\\t//score+=1<<depth; this can calculate the power even more effeciently. Thanks soba_1 <3\\n                }\\n            }\\n            prev=s.charAt(i);//Keep track of the last character we found for deciding if we\\'re just decreasing the depth or we\\'ve also got a new ()? Why this?\\n\\t\\t\\t\\t\\t\\t//Two reasons, one to detect the () non nested bracket\\n\\t\\t\\t\\t\\t\\t//other one:\\n\\t\\t\\t\\t\\t\\t//For example; (()) ()  -> (()) | after this point previous depth doesn\\'t matter to us, so in this case we\\'re just decreasing the depth and moving forward. the () in the end has a depth of 1\\n        }\\n        return score;\\n    }\\n}\\n \\n```",
                "solutionTags": [
                    "Math",
                    "Stack"
                ],
                "code": "```\\n class Solution {\\n    public int scoreOfParentheses(String s) {\\n        int score =0;\\n        int depth=0;\\n        int s_length=s.length();\\n        char prev=\\' \\';\\n        for(int i=0;i<s_length;i++){\\n            if(s.charAt(i)==\\'(\\')\\n                depth++;\\n            else{\\n                depth--;// ignore the parentheses we found just before ) as it\\'s not contributing to the depth\\n                if(prev==\\'(\\'){\\n                    score+=Math.pow(2,depth); //Calculate score for the () we just found and add it\\n\\t\\t\\t\\t\\t//score+=1<<depth; this can calculate the power even more effeciently. Thanks soba_1 <3\\n                }\\n            }\\n            prev=s.charAt(i);//Keep track of the last character we found for deciding if we\\'re just decreasing the depth or we\\'ve also got a new ()? Why this?\\n\\t\\t\\t\\t\\t\\t//Two reasons, one to detect the () non nested bracket\\n\\t\\t\\t\\t\\t\\t//other one:\\n\\t\\t\\t\\t\\t\\t//For example; (()) ()  -> (()) | after this point previous depth doesn\\'t matter to us, so in this case we\\'re just decreasing the depth and moving forward. the () in the end has a depth of 1\\n        }\\n        return score;\\n    }\\n}\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857252,
                "title": "python-solution",
                "content": "\\n    class Solution:\\n\\t\\tdef scoreOfParentheses(self, s: str) -> int:\\n\\t\\t\\tif s == \"()\":           # Base condition for recursion\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tstack = []\\n\\t\\t\\ti = j = 0\\n\\t\\t\\tans = 0\\n\\t\\t\\tlength = len(s)\\n\\t\\t\\twhile i < length:\\n\\t\\t\\t\\tstack.append(i)   \\'\\'\\'It will be surely opening parentheses\\'\\'\\'\\n\\t\\t\\t\\tj = i              \\'\\'\\'Now we will look for it\\'s closing parentheses \\'\\'\\'\\n\\t\\t\\t\\twhile stack:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tif s[j] == \\'(\\':\\n\\t\\t\\t\\t\\t\\tstack.append(j)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\tif (i+1) != j:      \\'\\'\\'If string b/w parentheses (found above) is not empty \\'\\'\\'\\n\\t\\t\\t\\t\\tans += 2 * self.scoreOfParentheses(s[i+1:j])    #recursion\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans += 1\\n\\t\\t\\t\\ti = j+1     \\'\\'\\'Continuing ahead closing parentheses \\'\\'\\'\\n\\t\\t\\treturn ans\\n\\n                    \\n        \\n                \\n                    \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\n    class Solution:\\n\\t\\tdef scoreOfParentheses(self, s: str) -> int:\\n\\t\\t\\tif s == \"()\":           # Base condition for recursion\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tstack = []\\n\\t\\t\\ti = j = 0\\n\\t\\t\\tans = 0\\n\\t\\t\\tlength = len(s)\\n\\t\\t\\twhile i < length:\\n\\t\\t\\t\\tstack.append(i)   \\'\\'\\'It will be surely opening parentheses\\'\\'\\'\\n\\t\\t\\t\\tj = i              \\'\\'\\'Now we will look for it\\'s closing parentheses \\'\\'\\'\\n\\t\\t\\t\\twhile stack:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tif s[j] == \\'(\\':\\n\\t\\t\\t\\t\\t\\tstack.append(j)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\tif (i+1) != j:      \\'\\'\\'If string b/w parentheses (found above) is not empty \\'\\'\\'\\n\\t\\t\\t\\t\\tans += 2 * self.scoreOfParentheses(s[i+1:j])    #recursion\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans += 1\\n\\t\\t\\t\\ti = j+1     \\'\\'\\'Continuing ahead closing parentheses \\'\\'\\'\\n\\t\\t\\treturn ans\\n\\n                    \\n        \\n                \\n                    \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1857214,
                "title": "c-easy-to-understand-algorithm-daily-leetcoding-challenge-march-day-17",
                "content": "Please Upvote if it helps\\u2B06\\uFE0F\\n\\n**Algorithm**\\n\\n* Just create an **empty stack** to store the **pair of parenthesis**\\n\\n* Iterate over the given string then checked **2 cases**:\\n     1.      if we found \\'(\\' parenthesis **store it into stack** and set score of pair 0 again \\n     2.      if we found \\')\\' parenthesis calculate the score for that parensthis by using formula **score = stack.top() + max(2*score, 1)** **and pop**\\n* After whole iteration **return the score**\\n\\n**Time Complexity: O(N)** \\n**Space Complexity: O(N)**\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int score = 0;\\n        stack<int> st;\\n        \\n        for(auto it : s)\\n        {\\n            // when we found ( just push it to the stack\\n            if(it==\\'(\\')\\n            {\\n                // pushing a pair\\n                st.push(score);\\n                \\n                // set score to 0 again for new pair\\n                score = 0;\\n            }\\n            \\n            // if we found ) parenthesis for a pair then change the score\\n            else\\n            {\\n                score = st.top() + max(2*score, 1);\\n                st.pop();\\n            }\\n        }\\n        \\n        return score;\\n    }\\n};\\n```\\nPlease Upvote if it helps\\u2B06\\uFE0F",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int score = 0;\\n        stack<int> st;\\n        \\n        for(auto it : s)\\n        {\\n            // when we found ( just push it to the stack\\n            if(it==\\'(\\')\\n            {\\n                // pushing a pair\\n                st.push(score);\\n                \\n                // set score to 0 again for new pair\\n                score = 0;\\n            }\\n            \\n            // if we found ) parenthesis for a pair then change the score\\n            else\\n            {\\n                score = st.top() + max(2*score, 1);\\n                st.pop();\\n            }\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857005,
                "title": "python3-runtime-24-ms-faster-than-98-71-memory-13-8-mb-less-than-97-15",
                "content": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = []\\n        ans = 0\\n        for i in s:\\n            if i == \")\":\\n                ans += stack.pop()+ max(ans,1)   \\n            else:\\n                stack.append(ans)\\n                ans = 0   \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = []\\n        ans = 0\\n        for i in s:\\n            if i == \")\":\\n                ans += stack.pop()+ max(ans,1)   \\n            else:\\n                stack.append(ans)\\n                ans = 0   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856804,
                "title": "c-java-easy-to-understand-o-1-without-stack-simple-efficient",
                "content": "**856. Score of Parentheses**\\n\\n##### **APPROACH -**\\n* **`() = 1, (()) = 2, ((())) = 4, (((()))) = 8; ==> score = 2^(level - 1)`**\\n\\n*Create `level` to store current level, i.e. number of continuously nested pair of parentheses\\n**Level increases at every open parenthesis and decreases at every close parenthesis**\\nWhenever a set of continously nested pair of parenthesis ends, add the score for this set*\\n\\n<br/>\\n\\n##### **ANALYSIS -**\\n* **Time Complexity : O(N)**, where N = length of string\\n* **Space Complexity : O(1)**\\n\\n<br/>\\n\\n##### **IMPLEMENTATION -**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int score = 0, level = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s[i] == \\'(\\')    \\n\\t\\t\\t\\tlevel++;\\n            else    \\n\\t\\t\\t\\tlevel--;\\n            if(s[i] == \\')\\' && s[i-1] == \\'(\\')\\n                score += 1 << level;\\n        }\\n        return score;\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int score = 0, level = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s.charAt(i) == \\'(\\')    \\n                level++;\\n            else    \\n                level--;\\n            if(s.charAt(i) == \\')\\' && s.charAt(i-1) == \\'(\\')\\n                score += 1 << level;\\n        }\\n        return score;\\n    }\\n}\\n```\\n**If you found this helpful, please Upvote \\u2B06\\uFE0F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int score = 0, level = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s[i] == \\'(\\')    \\n\\t\\t\\t\\tlevel++;\\n            else    \\n\\t\\t\\t\\tlevel--;\\n            if(s[i] == \\')\\' && s[i-1] == \\'(\\')\\n                score += 1 << level;\\n        }\\n        return score;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int score = 0, level = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s.charAt(i) == \\'(\\')    \\n                level++;\\n            else    \\n                level--;\\n            if(s.charAt(i) == \\')\\' && s.charAt(i-1) == \\'(\\')\\n                score += 1 << level;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856797,
                "title": "856-c-o-n-solution-with-explanation",
                "content": "**Please upvote if you find this solution helpful :)**\\n\\n**Approach:**\\n* Use stack to store the score of the parenthesis pair.\\n* Iterate over the string if we find open parenthesis put current_score into the stack and initialize current_score to 0 (for the new parenthesis pair).\\n* If we find close parenthesis we calculate the current score by using the formula **current_score = stack.top() + max(2*current_score, 1)** and pop out the top most element.\\n* At the end return the current_score.\\n**Time Complexity: O(N), Space Complexity: O(N)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        stack<int> st;\\n        int ind=0;\\n        \\n        for(auto i : s)\\n        {\\n            //if we found open parenthesis\\n            if(i==\\'(\\')\\n            {\\n                st.push(ind);\\n                \\n                //set ind to 0\\n                ind = 0;    \\n            }\\n            //if we found close parenthesis\\n            else\\n            {\\n                ind = st.top() + max(2*ind, 1);\\n                st.pop();\\n            }\\n            \\n        }\\n        return ind;\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if you find this solution helpful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        stack<int> st;\\n        int ind=0;\\n        \\n        for(auto i : s)\\n        {\\n            //if we found open parenthesis\\n            if(i==\\'(\\')\\n            {\\n                st.push(ind);\\n                \\n                //set ind to 0\\n                ind = 0;    \\n            }\\n            //if we found close parenthesis\\n            else\\n            {\\n                ind = st.top() + max(2*ind, 1);\\n                st.pop();\\n            }\\n            \\n        }\\n        return ind;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856359,
                "title": "time-o-n-space-o-n-recursion-solution-in-python",
                "content": "Move the index from left to right.\\nWhen we find open parenthesis `(`, we call recursion from the next character.\\nWhen we find close parenthesis `)`, we return the values inside the recursion, and also return the length of the expression inside parenthesis.\\n\\nAll numbers are stored in the `stack`, and we return the sum of the value in `stack` and the end. When `stack` is empty, that means there was a `()` pair with nothing inside, so return 1 as value.\\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        def rec(s):\\n            stack = []\\n            idx = 0\\n            L = len(s)\\n            while idx < L:\\n                if s[idx] == \\'(\\':\\n                    val, length = rec(s[idx + 1:])\\n                    idx += length + 1\\n                    stack.append(val)\\n                elif s[idx] == \\')\\':\\n                    val = 2 * sum(stack) if stack else 1\\n                    return val, idx\\n                idx += 1\\n            \\n            val = sum(stack) if stack else 1\\n            return val, idx\\n            \\n        return rec(s)[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        def rec(s):\\n            stack = []\\n            idx = 0\\n            L = len(s)\\n            while idx < L:\\n                if s[idx] == \\'(\\':\\n                    val, length = rec(s[idx + 1:])\\n                    idx += length + 1\\n                    stack.append(val)\\n                elif s[idx] == \\')\\':\\n                    val = 2 * sum(stack) if stack else 1\\n                    return val, idx\\n                idx += 1\\n            \\n            val = sum(stack) if stack else 1\\n            return val, idx\\n            \\n        return rec(s)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374384,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int sum=0;\\n        int level=1;\\n        Deque<Character> stack =new ArrayDeque<>();\\n        \\n        s = s.replace(\"()\", \"1\");\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\'){\\n                level*=2;\\n            }else if(c==\\')\\'){\\n                level/=2;\\n            }else if(c==\\'1\\'){\\n                sum += level*1;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int sum=0;\\n        int level=1;\\n        Deque<Character> stack =new ArrayDeque<>();\\n        \\n        s = s.replace(\"()\", \"1\");\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\'){\\n                level*=2;\\n            }else if(c==\\')\\'){\\n                level/=2;\\n            }else if(c==\\'1\\'){\\n                sum += level*1;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195998,
                "title": "java-stack-easy-solution",
                "content": "\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i)==\\'(\\'){\\n            stack.push(-1);\\n          }\\n          else if(stack.peek()==-1){\\n            stack.pop();\\n            stack.push(1);\\n          }\\n          else{\\n            int score=0;\\n            while(stack.peek()!=-1){\\n              score+=stack.pop();\\n            }\\n            stack.pop();\\n            stack.push(2*score);\\n          }\\n        }\\n      int score=0;\\n      while(stack.size()>0){\\n        score+=stack.pop();\\n      }\\n      return score;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i)==\\'(\\'){\\n            stack.push(-1);\\n          }\\n          else if(stack.peek()==-1){\\n            stack.pop();\\n            stack.push(1);\\n          }\\n          else{\\n            int score=0;\\n            while(stack.peek()!=-1){\\n              score+=stack.pop();\\n            }\\n            stack.pop();\\n            stack.push(2*score);\\n          }\\n        }\\n      int score=0;\\n      while(stack.size()>0){\\n        score+=stack.pop();\\n      }\\n      return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187189,
                "title": "o-1-space-o-n-time-intuitive-concise-and-efficient",
                "content": "Approach:\\n(()(())) = (()) + ((())) = 2 + 4\\n(1+2)  \\n6\\n\\nAt every \\'(\\' we are moving deeper, so we multiply the current depth with 2\\nAt the first \\')\\', add the current depth to final score; \\nAt every \\')\\' (including first) reduce the depth by dividing by 2\\n\\n```\\n// Time O(n), Space O(1)\\n// No stack\\n\\nfunc scoreOfParentheses(S string) int {\\n    \\n    var score int\\n    depth := 1  \\n    flag := false\\n    \\n    for _, ch := range S {\\n        if ch == \\'(\\' {\\n            depth *= 2\\n            flag = true\\n        } else {\\n            depth /= 2\\n            if flag {\\n                score += depth\\n                flag = false\\n            }\\n        }    \\n    }\\n    \\n    return score\\n    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// Time O(n), Space O(1)\\n// No stack\\n\\nfunc scoreOfParentheses(S string) int {\\n    \\n    var score int\\n    depth := 1  \\n    flag := false\\n    \\n    for _, ch := range S {\\n        if ch == \\'(\\' {\\n            depth *= 2\\n            flag = true\\n        } else {\\n            depth /= 2\\n            if flag {\\n                score += depth\\n                flag = false\\n            }\\n        }    \\n    }\\n    \\n    return score\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1085077,
                "title": "java-recursion-beats-100-14-line-code",
                "content": "```\\nclass Solution {\\n    int index = 0;\\n    public int scoreOfParentheses(String S) {\\n        int score = 0;\\n        while(index<S.length()){\\n            if(S.charAt(index)==\\'(\\'){\\n                index++;\\n                score+=scoreOfParentheses(S);\\n            }\\n            else if(S.charAt(index)==\\')\\'){\\n                index++;\\n                score= score==0 ? 1 : 2*score;\\n                return score;\\n            }   \\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int index = 0;\\n    public int scoreOfParentheses(String S) {\\n        int score = 0;\\n        while(index<S.length()){\\n            if(S.charAt(index)==\\'(\\'){\\n                index++;\\n                score+=scoreOfParentheses(S);\\n            }\\n            else if(S.charAt(index)==\\')\\'){\\n                index++;\\n                score= score==0 ? 1 : 2*score;\\n                return score;\\n            }   \\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082430,
                "title": "c-2-approaches-o-n-0ms-beats-100-no-extra-space-best-easy-to-understand",
                "content": "**APPROACH 1 ( Using Stack ) CODE IMPLEMENTATION**\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int>st;\\n        int ans=0;\\n        st.push(0);\\n        int i=1;\\n        while(i<S.length()){\\n            if(S[i]==\\'(\\'){\\n                st.push(0);\\n            }            \\n            else{\\n                int top=st.top();                                           \\n                st.pop();\\n                int curr = top ? top : 1;\\n                if(st.empty()){\\n                    ans+=curr;  \\n                }\\n                else{\\n                    int new_top=st.top();\\n                    st.pop();\\n                    curr=curr<<1; // curr*2 = curr<<1\\n                    st.push(new_top+curr); \\n                }\\n            }\\n            ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(n)**\\n\\n---\\n\\n**APPROACH 2 ( No Extra Space ) CODE IMPLEMENTATION**\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int ans=0;\\n        int dm=2; // depth-multiplier\\n        for(int i=1;i<S.length();++i){\\n            if(S[i]==\\'(\\'){\\n                dm=dm<<1; // dm=dm*2\\n            } \\n            else{\\n                dm=dm>>1; // dm=dm/2\\n                if(S[i-1]==\\'(\\') ans += dm; // \"()\" is encountered        \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int>st;\\n        int ans=0;\\n        st.push(0);\\n        int i=1;\\n        while(i<S.length()){\\n            if(S[i]==\\'(\\'){\\n                st.push(0);\\n            }            \\n            else{\\n                int top=st.top();                                           \\n                st.pop();\\n                int curr = top ? top : 1;\\n                if(st.empty()){\\n                    ans+=curr;  \\n                }\\n                else{\\n                    int new_top=st.top();\\n                    st.pop();\\n                    curr=curr<<1; // curr*2 = curr<<1\\n                    st.push(new_top+curr); \\n                }\\n            }\\n            ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int ans=0;\\n        int dm=2; // depth-multiplier\\n        for(int i=1;i<S.length();++i){\\n            if(S[i]==\\'(\\'){\\n                dm=dm<<1; // dm=dm*2\\n            } \\n            else{\\n                dm=dm>>1; // dm=dm/2\\n                if(S[i-1]==\\'(\\') ans += dm; // \"()\" is encountered        \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081068,
                "title": "score-of-parentheses-c-easy-using-stack",
                "content": "\\t\\tint n=s.size();\\n        int count=0;\\n        stack<int> st;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                sum=0;\\n                st.push(0);\\n            }\\n            else\\n            {\\n                if(st.top()==0)\\n                {\\n                    sum+=1;\\n                    st.pop();\\n                    st.push(sum);\\n                    \\n                }\\n                else if(st.top()>0)\\n                {\\n                    int val=0;\\n                    while(st.top()!=0)\\n                    {\\n                        val+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*val);\\n                }\\n            }\\n        }\\n        sum=0;\\n        while(!st.empty())\\n        {\\n            sum+=st.top();\\n            st.pop();\\n        }\\n        return sum;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\tint n=s.size();\\n        int count=0;\\n        stack<int> st;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                sum=0;\\n                st.push(0);\\n            }\\n            else\\n            {\\n                if(st.top()==0)\\n                {\\n                    sum+=1;\\n                    st.pop();\\n                    st.push(sum);\\n                    \\n                }\\n                else if(st.top()>0)\\n                {\\n                    int val=0;\\n                    while(st.top()!=0)\\n                    {\\n                        val+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*val);\\n                }\\n            }\\n        }\\n        sum=0;\\n        while(!st.empty())\\n        {\\n            sum+=st.top();\\n            st.pop();\\n        }\\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 1080638,
                "title": "c-0-ms-faster-than-100-00-o-1-space-super-simple-solution",
                "content": "```\\nint scoreOfParentheses(char * S){\\n    int res = 0, balance = 0;\\n    for ( int index = 0; S[index]; ++index )\\n    {\\n        balance += S[index] == \\'(\\' ? 1 : -1;\\n        if ( index && S[index - 1] == \\'(\\' && S[index] == \\')\\' )\\n            res += pow( 2, balance );\\n    }\\n    return res;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint scoreOfParentheses(char * S){\\n    int res = 0, balance = 0;\\n    for ( int index = 0; S[index]; ++index )\\n    {\\n        balance += S[index] == \\'(\\' ? 1 : -1;\\n        if ( index && S[index - 1] == \\'(\\' && S[index] == \\')\\' )\\n            res += pow( 2, balance );\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1080614,
                "title": "python-super-simple-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, balance = 0, 0\\n        for index, par in enumerate(S):\\n            balance += 1 if par == \"(\" else -1\\n            if index and S[index - 1] + par == \"()\":\\n                res += 2 ** balance\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, balance = 0, 0\\n        for index, par in enumerate(S):\\n            balance += 1 if par == \"(\" else -1\\n            if index and S[index - 1] + par == \"()\":\\n                res += 2 ** balance\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1080527,
                "title": "python-o-n-time-o-1-or-o-n-space-with-stack-and-without-stack-1-pass",
                "content": "#### Solution I\\nscan the string, \\n1. char is `(`,  push it into the stack and record it\\'s inner `val` to `0`.  `val` is used to record all its inner value;\\n2. char is `)`,  then last elem in the stack is the match one. \\n\\t* \\tif its inner value is 0, which means there is no inner parentheses in it, set `val=1`\\n\\t* \\telse, there are some parentheses in it, we need to double it;\\n\\t* \\tthen we need to check whether is has outer parentheses\\n\\t\\t* \\tif not, just add it to the result;\\n\\t\\t* \\telse, record to its outer parentheses\\' val, which is the last element in the stack;\\n\\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res = 0\\n        st = []\\n        for c in S:\\n            if c == \\'(\\': st.append(0)\\n            elif c == \\')\\':\\n                inner_val = st.pop()\\n                val = 2 * inner_val if inner_val > 0 else 1\\n                if not st: res += val\\n                else: st[-1] += val\\n        return res\\n```\\n\\n\\n#### Solution II\\n1. using `depth` to record depth of `(` in current group;\\n2. If we come across a leaf node `()`,  we know the `result` of current group; \\n\\n\\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, depth = 0, 0\\n        for idx, c in enumerate(S):\\n            if c == \\'(\\':\\n                depth += 1\\n                if S[idx + 1] == \\')\\': res += 1 << (depth-1)\\n            else:\\n                depth -= 1\\n        return res\\n```\\n\\n\\nIf there are same useless chars in the string, we\\'ll have to identify the leaf node by some trick.\\n\\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, depth, isleaf = 0, 0, False\\n        for idx, c in enumerate(S):\\n            if c == \\'(\\':\\n                depth += 1\\n                isleaf = True\\n            else:\\n                depth -= 1\\n                if isleaf: res += 1 << depth\\n                isleaf = False\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res = 0\\n        st = []\\n        for c in S:\\n            if c == \\'(\\': st.append(0)\\n            elif c == \\')\\':\\n                inner_val = st.pop()\\n                val = 2 * inner_val if inner_val > 0 else 1\\n                if not st: res += val\\n                else: st[-1] += val\\n        return res\\n```\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, depth = 0, 0\\n        for idx, c in enumerate(S):\\n            if c == \\'(\\':\\n                depth += 1\\n                if S[idx + 1] == \\')\\': res += 1 << (depth-1)\\n            else:\\n                depth -= 1\\n        return res\\n```\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, depth, isleaf = 0, 0, False\\n        for idx, c in enumerate(S):\\n            if c == \\'(\\':\\n                depth += 1\\n                isleaf = True\\n            else:\\n                depth -= 1\\n                if isleaf: res += 1 << depth\\n                isleaf = False\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 907389,
                "title": "very-simple-o-1-space-linear-solution-without-stack",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int depth = 0;\\n        int ans = 0;\\n        \\n        for( int i=0; i<S.length(); i++){\\n            \\n            if( S.charAt(i) == \\'(\\' && S.charAt(i+1) == \\')\\' ) {\\n                ans += Math.pow(2, depth);\\n\\t\\t\\t\\t//skipping the next closing paranthesis\\n                i++; \\n            }\\n            \\n            else if( S.charAt(i) == \\'(\\')\\n                depth++;\\n            \\n            else if( S.charAt(i) == \\')\\')\\n                depth--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int depth = 0;\\n        int ans = 0;\\n        \\n        for( int i=0; i<S.length(); i++){\\n            \\n            if( S.charAt(i) == \\'(\\' && S.charAt(i+1) == \\')\\' ) {\\n                ans += Math.pow(2, depth);\\n\\t\\t\\t\\t//skipping the next closing paranthesis\\n                i++; \\n            }\\n            \\n            else if( S.charAt(i) == \\'(\\')\\n                depth++;\\n            \\n            else if( S.charAt(i) == \\')\\')\\n                depth--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746700,
                "title": "java-0ms-100-solution",
                "content": "```\\n   public int scoreOfParentheses(String S) {\\n        \\n        int i = 0, n = S.length(), open = -1, ans = 0;\\n        while (i < n) {\\n            while (i < n && S.charAt(i++) == \\'(\\') open++;\\n            \\n            ans += Math.pow(2, open);\\n            \\n            while(i < n && S.charAt(i++) == \\')\\') open--;\\n        }\\n            \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n   public int scoreOfParentheses(String S) {\\n        \\n        int i = 0, n = S.length(), open = -1, ans = 0;\\n        while (i < n) {\\n            while (i < n && S.charAt(i++) == \\'(\\') open++;\\n            \\n            ans += Math.pow(2, open);\\n            \\n            while(i < n && S.charAt(i++) == \\')\\') open--;\\n        }\\n            \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 545261,
                "title": "beats-100-c-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Score of Parentheses.\\nMemory Usage: 5.1 MB, less than 100.00% of C online submissions for Score of Parentheses.\\n```\\n\\nint scoreOfParentheses(char * s){\\n    int score=0,flag=0;\\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\'){\\n            flag++;\\n        }\\n        else{\\n            flag--;\\n            if(s[i-1]==\\'(\\')\\n                score += 1 << flag;\\n        }\\n    }\\n    return score;\\n}\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C online submissions for Score of Parentheses.\\nMemory Usage: 5.1 MB, less than 100.00% of C online submissions for Score of Parentheses.\\n```\\n\\nint scoreOfParentheses(char * s){\\n    int score=0,flag=0;\\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\'){\\n            flag++;\\n        }\\n        else{\\n            flag--;\\n            if(s[i-1]==\\'(\\')\\n                score += 1 << flag;\\n        }\\n    }\\n    return score;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 497396,
                "title": "java-solution-with-code-templates-for-similar-problems",
                "content": "The solution might not as concise as others, but can be used as the template to solve most similar string interpretor problem like 729 Number of Atoms, 394 Decode string...etc\\nPlease check the comments in the code\\n\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        if(S == null || S.length() == 0) return 0;\\n\\t\\t\\n\\t//Need initialize the Stack with String for all Number/Symbol/Letter\\n        Stack<String> stack = new Stack<>();\\n        \\n\\t/**Loop through the entire string and each character\\n\\tUsing if/else statement to think about all the cases for each character:\\n\\t\\'(\\' , \\')\\', \\'[\\', \\']\\', \\'number\\', \\'letter\\', \\'upperCase\\', \\'lowerCase\\' depends on the input of the problem**/\\n        for(int i = 0; i<S.length(); i++) {\\n            char c = S.charAt(i);\\n            \\n            if(c == \\'(\\') {\\n\\t\\t\\t\\n\\t\\t/**Usually need push the symbol like \\'(\\' to be the stop sign when you loop back**/\\n                stack.push(\"(\");\\n            }\\n\\t\\t\\t\\n\\t\\t/**And \\')\\' would be the symbol to start looking back, \\n\\t\\twhich needs to popup previous element until the stop sign, \\n\\t\\tand calculate the values according to the problem, \\n\\t\\tthen push back the new value to the stack**/\\n            else if(c == \\')\\'){\\n                //()\\n                if(stack.peek() == \"(\") {\\n                    stack.pop();\\n                    stack.push(\"1\");\\n                }\\n                //(1234...)\\n                else{\\n                    int num = 0;\\n                    while(!stack.isEmpty() && stack.peek() != \"(\") {\\n                        num += Integer.parseInt(stack.pop());\\n                    }\\n                    stack.pop();\\n                    stack.push(String.valueOf(num * 2));\\n                }\\n            }\\n        }\\n        \\n\\t//finally popup all the elements from the stack \\n        int res = 0;\\n        while(!stack.isEmpty()) {\\n            res += Integer.parseInt(stack.pop());\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        if(S == null || S.length() == 0) return 0;\\n\\t\\t\\n\\t//Need initialize the Stack with String for all Number/Symbol/Letter\\n        Stack<String> stack = new Stack<>();\\n        \\n\\t/**Loop through the entire string and each character\\n\\tUsing if/else statement to think about all the cases for each character:\\n\\t\\'(\\' , \\')\\', \\'[\\', \\']\\', \\'number\\', \\'letter\\', \\'upperCase\\', \\'lowerCase\\' depends on the input of the problem**/\\n        for(int i = 0; i<S.length(); i++) {\\n            char c = S.charAt(i);\\n            \\n            if(c == \\'(\\') {\\n\\t\\t\\t\\n\\t\\t/**Usually need push the symbol like \\'(\\' to be the stop sign when you loop back**/\\n                stack.push(\"(\");\\n            }\\n\\t\\t\\t\\n\\t\\t/**And \\')\\' would be the symbol to start looking back, \\n\\t\\twhich needs to popup previous element until the stop sign, \\n\\t\\tand calculate the values according to the problem, \\n\\t\\tthen push back the new value to the stack**/\\n            else if(c == \\')\\'){\\n                //()\\n                if(stack.peek() == \"(\") {\\n                    stack.pop();\\n                    stack.push(\"1\");\\n                }\\n                //(1234...)\\n                else{\\n                    int num = 0;\\n                    while(!stack.isEmpty() && stack.peek() != \"(\") {\\n                        num += Integer.parseInt(stack.pop());\\n                    }\\n                    stack.pop();\\n                    stack.push(String.valueOf(num * 2));\\n                }\\n            }\\n        }\\n        \\n\\t//finally popup all the elements from the stack \\n        int res = 0;\\n        while(!stack.isEmpty()) {\\n            res += Integer.parseInt(stack.pop());\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188525,
                "title": "c-solution-0ms-no-stack-no-recursion-with-explanation-o-n-runtime",
                "content": "Move forward through the string and meanwhile keep track of the number visited open and close parenthesis. \\nOnce we reach each close parenthesis followed by an open parenthesis, do calculation. The calculation is as simple as subtracting the visited closed parenthesis from visited open parenthesis used till now. \\nLet\\u2019s call it diff (cnt = open - close).\\nThen add the pow(2,cnt) and add it to result.\\nRunning Complexity O(n)\\nSpace Complexity O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {      \\n      int res=0;  int cnt=1;        \\n      if (S.size()==0)\\n           return res;\\n      for (int i=1; i<S.size();++i) {\\n          if (S[i]==\\'(\\')\\n             cnt++;\\n          else {\\n              cnt--;\\n              if (S[i-1]==\\'(\\') {\\n                  res+= pow(2,(cnt));  // or  1<<cnt;           \\n              }              \\n          }              \\n      }\\n      return res;\\n    }           \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {      \\n      int res=0;  int cnt=1;        \\n      if (S.size()==0)\\n           return res;\\n      for (int i=1; i<S.size();++i) {\\n          if (S[i]==\\'(\\')\\n             cnt++;\\n          else {\\n              cnt--;\\n              if (S[i-1]==\\'(\\') {\\n                  res+= pow(2,(cnt));  // or  1<<cnt;           \\n              }              \\n          }              \\n      }\\n      return res;\\n    }           \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624991,
                "title": "easy-to-understand-c-solution-stack-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<string>st;\\n        for(auto ch: s){\\n            if(ch == \\'(\\') st.push(\"(\");\\n            else{\\n                int temp = 0;\\n                while(st.top() != \"(\"){\\n                    temp += (stoi(st.top()));\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(temp == 0) st.push(\"1\");\\n                else st.push(to_string(2 * temp));\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans += stoi(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<string>st;\\n        for(auto ch: s){\\n            if(ch == \\'(\\') st.push(\"(\");\\n            else{\\n                int temp = 0;\\n                while(st.top() != \"(\"){\\n                    temp += (stoi(st.top()));\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(temp == 0) st.push(\"1\");\\n                else st.push(to_string(2 * temp));\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans += stoi(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495372,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans=0;\\n        stack<int> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(-1);\\n            }\\n            else if(st.top()==-1){\\n               st.pop();\\n               st.push(1);\\n            }\\n            else{\\n                int temp=0;\\n                while(st.top()!=-1){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*temp);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = [0]\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(0)\\n            else:\\n                v = stack.pop()\\n                stack[-1] += max(2 * v, 1)\\n        return stack.pop()        \\n```\\n\\n```Java []\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(cur * 2, 1);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans=0;\\n        stack<int> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(-1);\\n            }\\n            else if(st.top()==-1){\\n               st.pop();\\n               st.push(1);\\n            }\\n            else{\\n                int temp=0;\\n                while(st.top()!=-1){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*temp);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = [0]\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(0)\\n            else:\\n                v = stack.pop()\\n                stack[-1] += max(2 * v, 1)\\n        return stack.pop()        \\n```\n```Java []\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(cur * 2, 1);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758390,
                "title": "c-easy-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        char prev = \\'(\\';\\n        \\n        for (const char &ch: s) {\\n            if (ch == \\'(\\')\\n                depth++;\\n            else {\\n                depth--;\\n                if (prev == \\'(\\')\\n                    res += pow(2, depth);\\n            }\\n            \\n            prev = ch;\\n        }\\n        \\n        return res;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        char prev = \\'(\\';\\n        \\n        for (const char &ch: s) {\\n            if (ch == \\'(\\')\\n                depth++;\\n            else {\\n                depth--;\\n                if (prev == \\'(\\')\\n                    res += pow(2, depth);\\n            }\\n            \\n            prev = ch;\\n        }\\n        \\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637318,
                "title": "100-fastest-solution-simple-stack-implementation",
                "content": "The idea is that whenever we encouter any opening \\')\\' we put in stack and when we get a closing \\'(\\' and if it is \\'( )\\' then we add 1 in stack so that we can keep track of no of balanced bracket for outer one.\\nAs the brackets are balanced so there exist a \\'(\\' for every \\')\\' .\\nwe move in stack till we dont get a \\')\\' for any oter bracket and add all the previous inside parenthesis value and multiply it by 2 and push int stack.\\n\\n\\n\\n\\n```\\nclass Solution\\n{\\n    public:\\n        int scoreOfParentheses(string s)\\n        {\\n            stack<int> st;\\n            int ans = 0;\\n            for (int i = s.size() - 1; i >= 0; i--)\\n            {\\n                if (s[i] == \\')\\')\\n                    st.push(s[i]);\\n\\n                else\\n                {\\n                    if (s[i + 1] == \\')\\')\\n                    {\\n                        st.pop();\\n                        st.push(1);\\n                    }\\n                    else\\n                    {\\n                        int cnt = 0;\\n                        while (st.top() != \\')\\')\\n                        {\\n                            cnt += st.top();\\n                            st.pop();\\n                        }\\n                        st.pop();\\n                        st.push(cnt *2);\\n                    }\\n                }\\n            }\\n            while (st.size() != 0)\\n            {\\n                ans += st.top();\\n                st.pop();\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int scoreOfParentheses(string s)\\n        {\\n            stack<int> st;\\n            int ans = 0;\\n            for (int i = s.size() - 1; i >= 0; i--)\\n            {\\n                if (s[i] == \\')\\')\\n                    st.push(s[i]);\\n\\n                else\\n                {\\n                    if (s[i + 1] == \\')\\')\\n                    {\\n                        st.pop();\\n                        st.push(1);\\n                    }\\n                    else\\n                    {\\n                        int cnt = 0;\\n                        while (st.top() != \\')\\')\\n                        {\\n                            cnt += st.top();\\n                            st.pop();\\n                        }\\n                        st.pop();\\n                        st.push(cnt *2);\\n                    }\\n                }\\n            }\\n            while (st.size() != 0)\\n            {\\n                ans += st.top();\\n                st.pop();\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589641,
                "title": "c-solution-score-of-parentheses",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        char lastChar = \\'(\\';\\n        int n = 0;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'(\\')\\n                n++;\\n            else{\\n                n--;\\n                if(lastChar == \\'(\\')\\n                    ans = ans + pow(2 , n);\\n            }\\n            lastChar = s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        char lastChar = \\'(\\';\\n        int n = 0;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'(\\')\\n                n++;\\n            else{\\n                n--;\\n                if(lastChar == \\'(\\')\\n                    ans = ans + pow(2 , n);\\n            }\\n            lastChar = s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323927,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-for-score-of-parentheses",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE :**\\n```\\nint scoreOfParentheses(string s) {\\n        stack<int> st;\\n        st.push(0); // to keep the total score\\n        for(char i:s) {\\n            if(i==\\'(\\') {\\n                st.push(0);\\n            }\\n            else {\\n                int A = st.top(), val=0;\\n                st.pop();\\n                if(A>0) \\n                    val = 2*A;\\n                else\\n                    val = 1;\\n                st.top() += val;\\n            }\\n        }\\n        return st.top();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        stack<int> st;\\n        st.push(0); // to keep the total score\\n        for(char i:s) {\\n            if(i==\\'(\\') {\\n                st.push(0);\\n            }\\n            else {\\n                int A = st.top(), val=0;\\n                st.pop();\\n                if(A>0) \\n                    val = 2*A;\\n                else\\n                    val = 1;\\n                st.top() += val;\\n            }\\n        }\\n        return st.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152478,
                "title": "recursive-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(string &s,int i,int j){\\n        if(j == i+1)\\n            return 1;\\n        int ans = 0;\\n        int x = 0;\\n        int st = i;\\n        int n = s.length();\\n        while(i < j){\\n            if(s[i] == \\'(\\')\\n                x++;\\n            if(s[i] == \\')\\')\\n                x--;\\n            if(x == 0){\\n                return helper(s,st,i)+helper(s,i+1,j);\\n            }\\n            i++;\\n        }\\n        return 2*helper(s,st+1,j-1);\\n    }\\n    int scoreOfParentheses(string s) {\\n        return helper(s,0,s.length()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string &s,int i,int j){\\n        if(j == i+1)\\n            return 1;\\n        int ans = 0;\\n        int x = 0;\\n        int st = i;\\n        int n = s.length();\\n        while(i < j){\\n            if(s[i] == \\'(\\')\\n                x++;\\n            if(s[i] == \\')\\')\\n                x--;\\n            if(x == 0){\\n                return helper(s,st,i)+helper(s,i+1,j);\\n            }\\n            i++;\\n        }\\n        return 2*helper(s,st+1,j-1);\\n    }\\n    int scoreOfParentheses(string s) {\\n        return helper(s,0,s.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019616,
                "title": "100-fastest-solution-constant-space-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n=s.size(),ans=0;\\n        int d=0,i=0;\\n        while(i<n) {\\n            if(s[i]==\\'(\\') d++;\\n            else {\\n                d--;\\n                if(i>0 && s[i-1]==\\'(\\') ans+=1<<d;\\n                }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n=s.size(),ans=0;\\n        int d=0,i=0;\\n        while(i<n) {\\n            if(s[i]==\\'(\\') d++;\\n            else {\\n                d--;\\n                if(i>0 && s[i-1]==\\'(\\') ans+=1<<d;\\n                }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858474,
                "title": "cpp-solution-runtime-0ms",
                "content": "```\\nint scoreOfParentheses(string s) {\\n        \\n     stack<pair<int,char>>st1; //this stack is used for the follow the \\'(\\'\\n       stack<pair<int,int>>st2;// this stack is used for the  count the score of a where  the string is \"(a)\".\\n        for(int i=0; i<s.length(); ){\\n            if(st1.empty()){\\n                st1.push({i,\\'(\\'});\\n                i++;\\n            }else{\\n                if(s[i] == \\')\\'){\\n                    \\n                    while(!st1.empty() && i < s.length() && s[i] == \\')\\'){\\n                       if(st2.empty()){\\n                           st2.push({1,st1.top().first});\\n                           st1.pop(); \\n                           i++;\\n                       }else{\\n                           int res = 0;\\n                           \\n                           while(!st2.empty() && st2.top().second > st1.top().first){ \\n\\t\\t\\t\\t\\t\\t   // here is the main idea if you understand above condition \\n\\t\\t\\t\\t\\t\\t   // then you will be able  to understand whole code.\\n\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t   // here i basically do the thing that while(curr = st1.top().first) \\n\\t\\t\\t\\t\\t\\t   //means current index of \\'(\\'   is smaller than the st2.top().first\\n\\t\\t\\t\\t\\t\\t   //we remove the element from the st2 and take the total sum\\n\\t\\t\\t\\t\\t\\t   //of all popped elements  \\n\\t\\t\\n\\t\\t\\n\\t\\t\\t\\t\\t\\n                               res += st2.top().first;\\n                               st2.pop();\\n                               \\n                           }\\n                           if(res != 0)\\n                           st2.push({2*res,st1.top().first});\\n                           else\\n                               st2.push({1,st1.top().first});\\n                           st1.pop();\\n                           i++;\\n                       }\\n                    }\\n                }else{\\n                    st1.push({i,\\'(\\'});\\n                    i++;\\n                }\\n            }\\n        }\\n        int res = 0;\\n        while(!st2.empty()){\\n            res += st2.top().first;\\n            st2.pop();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        \\n     stack<pair<int,char>>st1; //this stack is used for the follow the \\'(\\'\\n       stack<pair<int,int>>st2;// this stack is used for the  count the score of a where  the string is \"(a)\".\\n        for(int i=0; i<s.length(); ){\\n            if(st1.empty()){\\n                st1.push({i,\\'(\\'});\\n                i++;\\n            }else{\\n                if(s[i] == \\')\\'){\\n                    \\n                    while(!st1.empty() && i < s.length() && s[i] == \\')\\'){\\n                       if(st2.empty()){\\n                           st2.push({1,st1.top().first});\\n                           st1.pop(); \\n                           i++;\\n                       }else{\\n                           int res = 0;\\n                           \\n                           while(!st2.empty() && st2.top().second > st1.top().first){ \\n\\t\\t\\t\\t\\t\\t   // here is the main idea if you understand above condition \\n\\t\\t\\t\\t\\t\\t   // then you will be able  to understand whole code.\\n\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t   // here i basically do the thing that while(curr = st1.top().first) \\n\\t\\t\\t\\t\\t\\t   //means current index of \\'(\\'   is smaller than the st2.top().first\\n\\t\\t\\t\\t\\t\\t   //we remove the element from the st2 and take the total sum\\n\\t\\t\\t\\t\\t\\t   //of all popped elements  \\n\\t\\t\\n\\t\\t\\n\\t\\t\\t\\t\\t\\n                               res += st2.top().first;\\n                               st2.pop();\\n                               \\n                           }\\n                           if(res != 0)\\n                           st2.push({2*res,st1.top().first});\\n                           else\\n                               st2.push({1,st1.top().first});\\n                           st1.pop();\\n                           i++;\\n                       }\\n                    }\\n                }else{\\n                    st1.push({i,\\'(\\'});\\n                    i++;\\n                }\\n            }\\n        }\\n        int res = 0;\\n        while(!st2.empty()){\\n            res += st2.top().first;\\n            st2.pop();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858163,
                "title": "easy-cpp-solution",
                "content": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int result=0,d=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                d++;\\n            }\\n            else{\\n                d--;\\n                if(s[i-1]==\\'(\\')\\n                    result+=pow(2,d);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int result=0,d=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                d++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1857834,
                "title": "easy-c-100-faster-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n       \\n        int count=0;//for opening parentheses count\\n        int rcount=0;//for closing parentheses count\\n        int ans=0;\\n        int i=0;//for iterating over string s\\n        while(i<s.size()){\\n            if(s[i]==\\'(\\'){ //counting opening bracket\\n                count++;\\n                i++;\\n            }\\n            else { // if closing bracket then count it in rcount, think of case. (()((())))\\n                while(s[i]==\\')\\'){\\n                    rcount++;\\n                    i++;\\n                }\\n                ans+=pow(2,count-1); //(A)--> 2*A  , see in question explanation\\n                count-=rcount; //if count==rcount, both equal and counted in answer and if count!=rcount,we will do the operations for rcount only\\n                rcount=0;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n       \\n        int count=0;//for opening parentheses count\\n        int rcount=0;//for closing parentheses count\\n        int ans=0;\\n        int i=0;//for iterating over string s\\n        while(i<s.size()){\\n            if(s[i]==\\'(\\'){ //counting opening bracket\\n                count++;\\n                i++;\\n            }\\n            else { // if closing bracket then count it in rcount, think of case. (()((())))\\n                while(s[i]==\\')\\'){\\n                    rcount++;\\n                    i++;\\n                }\\n                ans+=pow(2,count-1); //(A)--> 2*A  , see in question explanation\\n                count-=rcount; //if count==rcount, both equal and counted in answer and if count!=rcount,we will do the operations for rcount only\\n                rcount=0;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857674,
                "title": "python-stack-simplest-solution",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = []\\n        for ch in s:\\n            if ch == \\')\\':\\n\\t\\t\\t\\t# If ch is \\')\\' then calculate the score till previous \\'(\\' as per the formula and append the score into stack.\\n                score = 0\\n                while stack and stack[-1] != \\'(\\':\\n                    score += stack.pop()\\n                if stack and stack[-1] == \\'(\\':\\n                    stack.pop()\\n                stack.append(2*score if score > 0 else 1)\\n            else:\\n\\t\\t\\t\\t# If ch is \\'(\\' then simple put it into stack\\n                stack.append(ch)\\n        return sum(stack)\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = []\\n        for ch in s:\\n            if ch == \\')\\':\\n\\t\\t\\t\\t# If ch is \\')\\' then calculate the score till previous \\'(\\' as per the formula and append the score into stack.\\n                score = 0\\n                while stack and stack[-1] != \\'(\\':\\n                    score += stack.pop()\\n                if stack and stack[-1] == \\'(\\':\\n                    stack.pop()\\n                stack.append(2*score if score > 0 else 1)\\n            else:\\n\\t\\t\\t\\t# If ch is \\'(\\' then simple put it into stack\\n                stack.append(ch)\\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857442,
                "title": "score-of-parentheses-t-c-o-n-s-c-o-1",
                "content": "() maximum depth is 0. hence 2^0 will result as 1.\\n()() maximum depth is 0, and is occuring twice, hence (2^0) + (2^0) = 2;\\n(()()) maximum depth is 1, and is occuring twice, hence (2^1) + (2^1) = 4;\\n(()) maximum depth is 1, and is occuring once, hence (2^1) = 2;\\nin same manner the below code is implemented.\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int d = 1; // Varibale d measures the depth of the current parenteses.\\n        int ans = 0; // ans stores the total score of the parentheses, till the current parentheses.\\n        int n = s.size();\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (s[i] == \\'(\\')  // Increment the depth whenever you encounter a opening bracket.\\n                d++;\\n            else  // Decrement the depth whenever you encounter a closing bracket.\\n                d--;\\n            if (s[i] == \\')\\' && s[i - 1] == \\'(\\') whenever this condition satisfy. get the score by 2 power the depth.\\n                ans += pow(2, d);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUpvote the solution.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int d = 1; // Varibale d measures the depth of the current parenteses.\\n        int ans = 0; // ans stores the total score of the parentheses, till the current parentheses.\\n        int n = s.size();\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (s[i] == \\'(\\')  // Increment the depth whenever you encounter a opening bracket.\\n                d++;\\n            else  // Decrement the depth whenever you encounter a closing bracket.\\n                d--;\\n            if (s[i] == \\')\\' && s[i - 1] == \\'(\\') whenever this condition satisfy. get the score by 2 power the depth.\\n                ans += pow(2, d);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856716,
                "title": "c-0ms-better-then-100-cpp-solution",
                "content": "# Please Upvote if tou find this helpfull\\n![image](https://assets.leetcode.com/users/images/a73b9a52-854b-4c00-832e-d05db3e803c6_1647489700.5493279.png)\\n```\\nclass Solution {\\npublic:\\n\\tint scoreOfParentheses(string s) {\\n\\t\\t  stack<int> st;\\n\\t\\tint ans=0;\\n\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\tif(s[i]==\\'(\\') st.push(0);\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(st.top()==0){\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tst.push(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint temp=0;\\n\\t\\t\\t\\t\\twhile(!st.empty() && st.top()!=0){\\n\\t\\t\\t\\t\\t\\ttemp+=st.top();\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tst.push(2*temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(!st.empty())\\n\\t\\t{\\n\\t\\t\\tans+=st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\tint scoreOfParentheses(string s) {\\n\\t\\t  stack<int> st;\\n\\t\\tint ans=0;\\n\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\tif(s[i]==\\'(\\') st.push(0);\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(st.top()==0){\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tst.push(1);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1856432,
                "title": "java-using-stack",
                "content": "Approach 1: Using Stack\\n```\\n\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n       Stack<Integer> stack = new Stack<>();\\n        int score = 0;\\n        for(char c: s.toCharArray()){\\n            if(c == \\'(\\'){\\n                // when you encounter a opening paranthesis you add current score to stack to be popped in future to calculate score with its pair closing paranthesis\\n\\t\\t\\t\\tstack.push(score);\\n\\t\\t\\t\\t// reset score here for next open paranthesis\\n                score = 0;\\n            }else{\\n\\t\\t\\t// when ever you meet a closing parantheses score will be updated\\n                score = stack.pop() + Math.max(2*score,1);\\n            }\\n        }\\n    return score;\\n    }\\n}\\n```\\n\\n```\\nExample 1 : ()\\n\\nstep 1 : 0 // current score will be pushed to stack at initial if\\nstep 2: In else block score will be updated as score = 0 + max(2*0 + 1) = 1\\nnote : in else block you need to get max of 2*(count of open parantheses encounter sofar until you find a closing)  + 1(minimum score for a pair of () )\\n```\\n```\\nExample 2 : ()()\\nstep 1: 0 // for initial opening stack will be pushed with current score\\nstep 2: score will be updated as score = 0 + max(2*0,1) = 1 // for the first pair encountered sofar ()\\nstep 3: 1 // current score will be pushed to stack for second opening and score will be reset to 0\\nstep 4: score will be updated as score  = 1 + max(2*0,1) = 1 + 1 = 2\\n\\nNote : In case of adjacent valid pairs AB = A + B stack.pop() will always give calculated score sofar  and max(2*score,1) will give score for current closing paranthesis. It is important to reset score after pushing to stack because for every new opening score should start with 0\\n\\n```\\n\\n```\\nExample 3 : (())\\nstep 1: 0 // current stack\\nstep 2: 0 0 // updated stack for second opening paranthesis\\nstep 3: calculate score = 0 + max(2*0,1) = 0 + 1 = 1 (which is for inside nested pair ())\\nstep 4 : calculate score = 0 + max(2*1,1) = 0 + 2 = 2 (which is for outer pair 2*(score of innner pair 1))\\n\\nNote : In case of nested pairs max(2*current_score,1) will provide multiplication factor for nested pairs\\n\\nsimilary \\nif you have nested at 3 (2*(2*(1))) levels score = 2*(2*(1))  = 4\\nif you have nested at 4 (2*(2*(2*(1)))) levels score = 2*(2*(2*(1)))  = 8\\n\\n```\\n\\nApproach 2: Without additional data structure O(1) memory\\n\\n```\\npublic int scoreOfParentheses(String S) {\\n    int score = 0;\\n    int depth = 0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            depth++;\\n        } else {\\n            depth--;\\n        }\\n\\n        if (s.charAt(i) == \\')\\' && s.charAt(i - 1) == \\'(\\') {\\n            // Whenever you meet a () pair, you multiply 1 by all the 2 outside of it, and accumulate the result\\n            score += Math.pow(2, depth);\\n        }\\n    }\\n\\n    return score;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n       Stack<Integer> stack = new Stack<>();\\n        int score = 0;\\n        for(char c: s.toCharArray()){\\n            if(c == \\'(\\'){\\n                // when you encounter a opening paranthesis you add current score to stack to be popped in future to calculate score with its pair closing paranthesis\\n\\t\\t\\t\\tstack.push(score);\\n\\t\\t\\t\\t// reset score here for next open paranthesis\\n                score = 0;\\n            }else{\\n\\t\\t\\t// when ever you meet a closing parantheses score will be updated\\n                score = stack.pop() + Math.max(2*score,1);\\n            }\\n        }\\n    return score;\\n    }\\n}\\n```\n```\\nExample 1 : ()\\n\\nstep 1 : 0 // current score will be pushed to stack at initial if\\nstep 2: In else block score will be updated as score = 0 + max(2*0 + 1) = 1\\nnote : in else block you need to get max of 2*(count of open parantheses encounter sofar until you find a closing)  + 1(minimum score for a pair of () )\\n```\n```\\nExample 2 : ()()\\nstep 1: 0 // for initial opening stack will be pushed with current score\\nstep 2: score will be updated as score = 0 + max(2*0,1) = 1 // for the first pair encountered sofar ()\\nstep 3: 1 // current score will be pushed to stack for second opening and score will be reset to 0\\nstep 4: score will be updated as score  = 1 + max(2*0,1) = 1 + 1 = 2\\n\\nNote : In case of adjacent valid pairs AB = A + B stack.pop() will always give calculated score sofar  and max(2*score,1) will give score for current closing paranthesis. It is important to reset score after pushing to stack because for every new opening score should start with 0\\n\\n```\n```\\nExample 3 : (())\\nstep 1: 0 // current stack\\nstep 2: 0 0 // updated stack for second opening paranthesis\\nstep 3: calculate score = 0 + max(2*0,1) = 0 + 1 = 1 (which is for inside nested pair ())\\nstep 4 : calculate score = 0 + max(2*1,1) = 0 + 2 = 2 (which is for outer pair 2*(score of innner pair 1))\\n\\nNote : In case of nested pairs max(2*current_score,1) will provide multiplication factor for nested pairs\\n\\nsimilary \\nif you have nested at 3 (2*(2*(1))) levels score = 2*(2*(1))  = 4\\nif you have nested at 4 (2*(2*(2*(1)))) levels score = 2*(2*(2*(1)))  = 8\\n\\n```\n```\\npublic int scoreOfParentheses(String S) {\\n    int score = 0;\\n    int depth = 0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            depth++;\\n        } else {\\n            depth--;\\n        }\\n\\n        if (s.charAt(i) == \\')\\' && s.charAt(i - 1) == \\'(\\') {\\n            // Whenever you meet a () pair, you multiply 1 by all the 2 outside of it, and accumulate the result\\n            score += Math.pow(2, depth);\\n        }\\n    }\\n\\n    return score;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818803,
                "title": "easy-based-solution-c-fcuk-u",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string x) {\\n        stack<int>s;\\n        //here we are putting these scores in here eyou can see\\n        for(int i=0;i<x.length();i++)\\n        {\\n            if(x[i]==\\'(\\')\\n            {\\n                s.push(0);\\n            }\\n            else if(x[i]==\\')\\')\\n            {\\n                //here we make two cases of simple and complex \\n                if(s.top()==0)\\n                {\\n                    //simple ()\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else\\n                {\\n                    //for complex case\\n                    int ans=0;\\n                    while(s.top()!=0)\\n                    {\\n                        ans=ans+s.top();\\n                        s.pop();\\n                    }\\n                    s.pop();\\n                    s.push(2*ans);\\n                }\\n            }\\n                \\n        }\\n        int count=0;\\n        while(!s.empty())\\n        {\\n            count=count+s.top();\\n            s.pop();\\n        }\\n        return count;\\n    }\\n};\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string x) {\\n        stack<int>s;\\n        //here we are putting these scores in here eyou can see\\n        for(int i=0;i<x.length();i++)\\n        {\\n            if(x[i]==\\'(\\')\\n            {\\n                s.push(0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1496748,
                "title": "o-n-solution",
                "content": "class Solution {\\n    public int scoreOfParentheses(String s) {\\n    int cur=0;\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                st.push(cur);\\n                cur=0;\\n            }\\n            else{\\n                cur=st.pop()+Math.max(2*cur,1);\\n            }\\n        }\\n        return cur;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int scoreOfParentheses(String s) {\\n    int cur=0;\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                st.push(cur);\\n                cur=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1487703,
                "title": "cpp-using-stack-o-n",
                "content": "class Solution {\\npublic:\\n    int scoreOfParentheses(string st) {\\n        stack<int> s;\\n        int val=0;\\n        for(int i=0;i<st.length();i++)\\n        {\\n            if(st[i]==\\'(\\')\\n                s.push(-1);\\n            else\\n            {\\n                if(s.top()==-1)\\n                {\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else\\n                {\\n                     val=0;\\n                    while(!s.empty()&&s.top()!=-1)\\n                    {\\n                        val+=s.top();\\n                        s.pop();\\n                    }\\n                    s.pop();\\n                    s.push(2*val);\\n                }\\n            }\\n        }\\n        val=0;\\n        while(!s.empty())\\n        {\\n            val+=s.top();\\n            s.pop();\\n        }\\n        return val;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string st) {\\n        stack<int> s;\\n        int val=0;\\n        for(int i=0;i<st.length();i++)\\n        {\\n            if(st[i]==\\'(\\')\\n                s.push(-1);\\n            else\\n            {\\n                if(s.top()==-1)\\n                {\\n                    s.pop();\\n                    s.push(1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1219205,
                "title": "100-faster-intuitive-recursive-solution-with-proper-comments",
                "content": "```\\n    int scoreOfParentheses(string s) \\n    {\\n        unordered_map<int,int> map;  //key will be index of \\'(\\' and value will be index of corresponding closing bracket\\n        stack<int> stack; //stack will be used to find index of \\')\\' corresponding to each \\'(\\'\\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++)  // fill entries in map(preprocessing)\\n        {\\n            if(s[i]==\\'(\\')\\n                stack.push(i);\\n            else\\n            {\\n                int ind=stack.top();\\n                stack.pop();\\n                map[ind]=i;\\n            }\\n                \\n        }\\n        \\n        return score(0,n-1,map); //calling recursive function to calculate score for whole expression\\n    }\\n\\t\\n\\tint score(int start,int end,unordered_map<int,int> map)\\n    {\\n        \\n        if(start+1==end and map[start]==end) // if \\'(\\' and \\')\\' are adjacent like \"()\"\\n        {\\n            return 1;\\n        }\\n        else if(map[start]==end) // if \\')\\' corresponding to first \\'(\\' is at last index like \"(..........)\"\\n            return 2*score(start+1,end-1,map);\\n        else\\n            return score(start,map[start],map)+score(map[start]+1,end,map); //case where \"()()\" \\n            \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n    int scoreOfParentheses(string s) \\n    {\\n        unordered_map<int,int> map;  //key will be index of \\'(\\' and value will be index of corresponding closing bracket\\n        stack<int> stack; //stack will be used to find index of \\')\\' corresponding to each \\'(\\'\\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++)  // fill entries in map(preprocessing)\\n        {\\n            if(s[i]==\\'(\\')\\n                stack.push(i);\\n            else\\n            {\\n                int ind=stack.top();\\n                stack.pop();\\n                map[ind]=i;\\n            }\\n                \\n        }\\n        \\n        return score(0,n-1,map); //calling recursive function to calculate score for whole expression\\n    }\\n\\t\\n\\tint score(int start,int end,unordered_map<int,int> map)\\n    {\\n        \\n        if(start+1==end and map[start]==end) // if \\'(\\' and \\')\\' are adjacent like \"()\"\\n        {\\n            return 1;\\n        }\\n        else if(map[start]==end) // if \\')\\' corresponding to first \\'(\\' is at last index like \"(..........)\"\\n            return 2*score(start+1,end-1,map);\\n        else\\n            return score(start,map[start],map)+score(map[start]+1,end,map); //case where \"()()\" \\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081334,
                "title": "score-of-parentheses-easy-to-understand-explanation-javascript-code",
                "content": "Initially I read this and it seemed quite easy.  However once I tried to implement it, I was caught up in odd recursive calls which sometimes worked, and others didn\\'t.  After passing my 30minute self timer I gave up and went to the solution.  Even understanding that was a challenge so I will attempt to improve on the solution explanation.\\n\\nOk, one way to think of this problem is in the number of \\'()\\' or cores.  I dont mean nesting, I mean the literal \\'()\\'.  The answer is the sum of those values.  The nesting only serves to double their value.  So, no need to do a recursive call, or even use a stack.  \\n\\nHow can we do this in a linear fashion?  Ok, loop though your string.  Every time u notice a (, you increment your depth counter.  If the current char is not a (, it must be a ).  Now you have two possibilities, the previous char could have been a (, in which case, u\\'ve got a core (), so add its value to the score (more on the calc later, see next paragraph).  Or the previous character could have been another ), ie )).  In that case u don\\'t have a core, but you still need to decrement the nesting level, which previously you had incremented on a prior iteration of seeing (.  \\n\\nRegarding that core value.  What is it?  Well check how many levels it is nested and double its value that many times.  So (()) would be 1*2^depth or using a bitwise operator, 1 shifted 1 place, so 1 << 1 = 2  \\n\\nIn summary: The trick is to evaluate each \\'core\\' as you encounter it, adding its value to the score. For it\\'s score, you\\'ll keep track of how deep the nesting is, sometimes decrementing the nesting as necessary when you find closing parens.\\n\\n```\\nvar scoreOfParentheses = function(S) {\\n  let score = 0, depth = 0;\\n  for (let i=0, j=S.length; i<j; i++) { // linear left to right iteration\\n    if (S.charAt(i) == \\'(\\')  // found ( so increment depth\\n\\t\\tdepth++;\\n    else if (S.charAt(i-1) == \\'(\\')  // found () a core, so time to add its calculated value to score\\n       score += 1 << --depth; // binary bit shift operator, doubling value by depth\\n    else \\n\\t\\t--depth; // not a core, but need to unwrap a layer of nesting\\n  }\\n  return score;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar scoreOfParentheses = function(S) {\\n  let score = 0, depth = 0;\\n  for (let i=0, j=S.length; i<j; i++) { // linear left to right iteration\\n    if (S.charAt(i) == \\'(\\')  // found ( so increment depth\\n\\t\\tdepth++;\\n    else if (S.charAt(i-1) == \\'(\\')  // found () a core, so time to add its calculated value to score\\n       score += 1 << --depth; // binary bit shift operator, doubling value by depth\\n    else \\n\\t\\t--depth; // not a core, but need to unwrap a layer of nesting\\n  }\\n  return score;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081212,
                "title": "score-of-parentheses-python-recursive-solution",
                "content": "The variable \"layer\" is equal to 0 when the iterator is between two balanced parentheses while not inside any parentheses.\\n```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        if S == \"()\":\\n            return 1\\n        layer = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                layer += 1\\n            elif S[i] == \")\":\\n                layer -= 1\\n                if layer == 0 and i < len(S)-1:\\n                    return self.scoreOfParentheses(S[:i+1]) + self.scoreOfParentheses(S[i+1:])\\n        return 2 * self.scoreOfParentheses(S[1:len(S)-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        if S == \"()\":\\n            return 1\\n        layer = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                layer += 1\\n            elif S[i] == \")\":\\n                layer -= 1\\n                if layer == 0 and i < len(S)-1:\\n                    return self.scoreOfParentheses(S[:i+1]) + self.scoreOfParentheses(S[i+1:])\\n        return 2 * self.scoreOfParentheses(S[1:len(S)-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080627,
                "title": "score-of-parentheses-js-python-java-c-easy-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nAny time we see a problem that describes a doubling operation and an incrementing operation, we should at least think about a potential binary solution. In this case, those are really the only two operations. Nested doubling operations means powers of **2** depending on the nesting depth, and a simple closed pair of parentheses is a **+1**.\\n\\nAt first glance, the addition operation would seem to cause a problem, but math once again comes to our aid.\\n\\nConsider the following:\\n```js\\nS = \"(((()()())))\"\\n  = \"(((\" 1 + 1 + 1 \")))\"    // After replacing completed \"()\"s with 1s\\n  = (1 + 1 + 1) * 2^3        // Applying the power operations\\n  = 2^3 + 2^3 + 2^3          // Through the distributive property of multiplication\\n```\\nAs we can see, we don\\'t *really* have to wait for the summation before applying the power operation, because it will get distributed across the summation anyway. And since we know how many nested parentheses there are (**pwr**) when we finish a simple parentheses pair, we can immediately add the appropriate value to our answer (**ans**).\\n\\nThis means that we can solve this problem in **O(n) time** and **O(1) space**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor JavaScript **S.charAt(i)** is faster at processing string iteration than **S[i]**.\\n\\nWe can start our iteration at **i = 1** because we know the first character is going to be **\"(\"**. We *could* start at **i = 0**, but then we\\'d have to either start with **pwr = 1** or make sure to decrement **pwr** before the power operation instead of after.\\n\\nWe can use a **bitwise shift** for the power operation to more accurately reflect the solution\\'s binary nature.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **64ms / 38.4MB** (beats 99% / 77%).\\n```javascript\\nvar scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.0MB** (beats 96% / 90%).\\n```python\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 37.0MB** (beats 100% / 60%).\\n```java\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S.charAt(i) == \\'(\\') pwr++;\\n            else if (S.charAt(i-1) == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.9MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S[i] == \\'(\\') pwr++;\\n            else if (S[i-1] == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nS = \"(((()()())))\"\\n  = \"(((\" 1 + 1 + 1 \")))\"    // After replacing completed \"()\"s with 1s\\n  = (1 + 1 + 1) * 2^3        // Applying the power operations\\n  = 2^3 + 2^3 + 2^3          // Through the distributive property of multiplication\\n```\n```javascript\\nvar scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S.charAt(i) == \\'(\\') pwr++;\\n            else if (S.charAt(i-1) == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S[i] == \\'(\\') pwr++;\\n            else if (S[i-1] == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070470,
                "title": "java-easy-to-understand-stack-solution",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n        for(char ch: S.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n            {\\n                stack.push(\"(\");\\n            }\\n            else\\n            {\\n                if(stack.peek().equals(\"(\"))\\n                {\\n                    stack.pop();\\n                    stack.push(\"1\");\\n                }\\n                else\\n                {\\n                    int val = 0;\\n                    while(!stack.isEmpty() && !stack.peek().equals(\"(\"))\\n                        val += Integer.parseInt(stack.pop());\\n                    val *= 2;\\n                    stack.pop();\\n                    stack.push(String.valueOf(val));\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans = 0;\\n        while(!stack.isEmpty())\\n        {\\n            \\n            ans += Integer.parseInt(stack.pop());\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n        for(char ch: S.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n            {\\n                stack.push(\"(\");\\n            }\\n            else\\n            {\\n                if(stack.peek().equals(\"(\"))\\n                {\\n                    stack.pop();\\n                    stack.push(\"1\");\\n                }\\n                else\\n                {\\n                    int val = 0;\\n                    while(!stack.isEmpty() && !stack.peek().equals(\"(\"))\\n                        val += Integer.parseInt(stack.pop());\\n                    val *= 2;\\n                    stack.pop();\\n                    stack.push(String.valueOf(val));\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans = 0;\\n        while(!stack.isEmpty())\\n        {\\n            \\n            ans += Integer.parseInt(stack.pop());\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906001,
                "title": "c-o-n-solution-beats-100-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/score-of-parentheses/submissions/\\n    \\n    Since the scoring happens based on the nested braces, we need a way\\n    to know the level of nested braces. To indicate each nested level we\\n    use 0 when a \\'(\\' is encountered. Then everytime we get a \\')\\', we find \\n    the total score between the start of the \\'(\\' and current \\')\\', \\n    use the rule 2 * A and push the result back.\\n    \\n    Eg: ()()\\n    ( Stack: 0,\\n    ) Stack: 1,\\n    ( Stack: 1, 0\\n    ) Stack: 1, 1\\n    \\n    Final: 1 + 1 = 2\\n    \\n    TC: O(N)\\n    SC: O(N)\\n*/\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int total = 0;\\n        int curr_score = 0;\\n        \\n        stack<int> vals;\\n        \\n        for(char &c: s) {\\n            // opening bracket\\n            if(c == \\'(\\') { \\n                vals.emplace(0);\\n            }\\n            else {\\n                int curr_val = 0;\\n                // find the total sum\\n                while(vals.top() != 0) {\\n                    curr_val += vals.top();\\n                    vals.pop(); \\n                }\\n                // remove score for the opening brace of current )\\n                vals.pop();\\n                // assign score based on whether the current \\n                // closing brace has enclosed brace \\n                curr_val = curr_val == 0 ? 1 : 2 * curr_val;\\n                vals.emplace(curr_val);\\n            }\\n        }\\n        // final score is sum of all remaining brace scores\\n        while(!vals.empty()) {\\n            total += vals.top();\\n            vals.pop();\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/score-of-parentheses/submissions/\\n    \\n    Since the scoring happens based on the nested braces, we need a way\\n    to know the level of nested braces. To indicate each nested level we\\n    use 0 when a \\'(\\' is encountered. Then everytime we get a \\')\\', we find \\n    the total score between the start of the \\'(\\' and current \\')\\', \\n    use the rule 2 * A and push the result back.\\n    \\n    Eg: ()()\\n    ( Stack: 0,\\n    ) Stack: 1,\\n    ( Stack: 1, 0\\n    ) Stack: 1, 1\\n    \\n    Final: 1 + 1 = 2\\n    \\n    TC: O(N)\\n    SC: O(N)\\n*/\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int total = 0;\\n        int curr_score = 0;\\n        \\n        stack<int> vals;\\n        \\n        for(char &c: s) {\\n            // opening bracket\\n            if(c == \\'(\\') { \\n                vals.emplace(0);\\n            }\\n            else {\\n                int curr_val = 0;\\n                // find the total sum\\n                while(vals.top() != 0) {\\n                    curr_val += vals.top();\\n                    vals.pop(); \\n                }\\n                // remove score for the opening brace of current )\\n                vals.pop();\\n                // assign score based on whether the current \\n                // closing brace has enclosed brace \\n                curr_val = curr_val == 0 ? 1 : 2 * curr_val;\\n                vals.emplace(curr_val);\\n            }\\n        }\\n        // final score is sum of all remaining brace scores\\n        while(!vals.empty()) {\\n            total += vals.top();\\n            vals.pop();\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877174,
                "title": "python-stack-o-n-explanations",
                "content": "The solution is below. The intuition follows.\\n\\n```python\\ndef scoreOfParentheses(self, S: str) -> int:\\n                \\n        stack = []\\n        for p in S:\\n            if p == \\'(\\':\\n                stack.append(0)\\n            \\n            else:\\n                score = 0\\n                while stack[-1]:       # case AB: score(A) + score(B)\\n                    score += stack[-1]\\n                    stack.pop()\\n                stack.pop() # pop 0 that corresponds to \\'(\\'\\n                stack.append(2 * score if score else 1) # if score = 0 => case: \"()\" if score>0 => case \"(A)\"\\n              \\n        return sum(stack)\\n\\t\\t\\n```\\n\\nIntuition: \\nFor every character in S:\\n- if it\\'s an `(` push 0 to the stack\\n- If it\\'s an `)`:\\n\\t- `pop` and `sum` all values of the stack unitl reaching `0` which corresponds to the open `(`\\n\\t- if the `sum = 0`, this means we\\'re in the case `()`, then push `1` to the stack\\n\\t- if the `sum > 0`, this means we\\'re in the case `(A)`, then push `2 * sum` to the stack\\n- Finally, return the `sum` of all remaining values of the stack\\n\\nComplexity Analysis:\\n\\t- Time Complexity: `O(n)`\\n\\t- Space Complexity: `O(n/2) = O(n)`\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef scoreOfParentheses(self, S: str) -> int:\\n                \\n        stack = []\\n        for p in S:\\n            if p == \\'(\\':\\n                stack.append(0)\\n            \\n            else:\\n                score = 0\\n                while stack[-1]:       # case AB: score(A) + score(B)\\n                    score += stack[-1]\\n                    stack.pop()\\n                stack.pop() # pop 0 that corresponds to \\'(\\'\\n                stack.append(2 * score if score else 1) # if score = 0 => case: \"()\" if score>0 => case \"(A)\"\\n              \\n        return sum(stack)\\n\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 750647,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int t = 0;\\n        int res = 0;\\n        for (int i = 0; i < S.length() - 1; i++) {\\n            if (S[i] == \\'(\\') {\\n                t++;\\n                if (S[i + 1] == \\')\\') {\\n                    res += pow(2, t - 1);\\n                }\\n            } else {\\n                t--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int t = 0;\\n        int res = 0;\\n        for (int i = 0; i < S.length() - 1; i++) {\\n            if (S[i] == \\'(\\') {\\n                t++;\\n                if (S[i + 1] == \\')\\') {\\n                    res += pow(2, t - 1);\\n                }\\n            } else {\\n                t--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740991,
                "title": "c-0ms-runtime-100-using-stack-14-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int>stackk;\\n        int result=0;\\n        for(int i=0;i<S.size();i++){\\n            if(S[i]==\\'(\\'){stackk.push(0);}\\n            else{\\n                int score = (stackk.top()==0)? 1 : stackk.top();\\n                stackk.pop();\\n                if(stackk.empty()){result+=score;}\\n                else{stackk.top() += 2*score;}\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int>stackk;\\n        int result=0;\\n        for(int i=0;i<S.size();i++){\\n            if(S[i]==\\'(\\'){stackk.push(0);}\\n            else{\\n                int score = (stackk.top()==0)? 1 : stackk.top();\\n                stackk.pop();\\n                if(stackk.empty()){result+=score;}\\n                else{stackk.top() += 2*score;}\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630695,
                "title": "java-4-lines-recursive",
                "content": "```\\nclass Solution {\\n    int i = 0;\\n    public int scoreOfParentheses(String S) {\\n\\n        int k = 0;\\n        while ( i < S.length()) {\\n            if (S.charAt(i++) == \\')\\')\\n                return k == 0 ? 1 : k;\\n            k += 2 * scoreOfParentheses(S);\\n        }\\n        return k/2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int i = 0;\\n    public int scoreOfParentheses(String S) {\\n\\n        int k = 0;\\n        while ( i < S.length()) {\\n            if (S.charAt(i++) == \\')\\')\\n                return k == 0 ? 1 : k;\\n            k += 2 * scoreOfParentheses(S);\\n        }\\n        return k/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581799,
                "title": "java-recursion-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        return helper(S, 0, S.length()-1);\\n        \\n    }\\n    \\n    public int helper(String S, int l, int r){\\n        if(r-l == 1) return 1;\\n        \\n        int count = 0;\\n        for(int i = l; i < r; i++){\\n            \\n            if (S.charAt(i) == \\'(\\') count++;\\n            if (S.charAt(i) == \\')\\') count--;\\n            \\n            if (count == 0){\\n                return helper(S, l, i) + helper(S, i+1, r);\\n            }\\n        }\\n        \\n        return 2 * helper(S, l+1, r-1);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        return helper(S, 0, S.length()-1);\\n        \\n    }\\n    \\n    public int helper(String S, int l, int r){\\n        if(r-l == 1) return 1;\\n        \\n        int count = 0;\\n        for(int i = l; i < r; i++){\\n            \\n            if (S.charAt(i) == \\'(\\') count++;\\n            if (S.charAt(i) == \\')\\') count--;\\n            \\n            if (count == 0){\\n                return helper(S, l, i) + helper(S, i+1, r);\\n            }\\n        }\\n        \\n        return 2 * helper(S, l+1, r-1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522559,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        vector<pair<char, int>> stack;\\n        int sum = 0, score;\\n        for(int i = 0; i < S.size(); i++){\\n            if(stack.empty() || S[i] == \\'(\\'){\\n                stack.push_back(make_pair(S[i], 0));\\n            }\\n            else{ //S is valid so S[i] == \\')\\' and stack.back().first == \\'(\\'\\n                score = stack.back().second * 2;\\n                score = score == 0? 1 : score;\\n                stack.pop_back();\\n                if(stack.empty()){\\n                    sum += score;\\n                }\\n                else{ //S is valid so stack.back().fist ==\\'(\\'\\n                    stack.back().second += score;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        vector<pair<char, int>> stack;\\n        int sum = 0, score;\\n        for(int i = 0; i < S.size(); i++){\\n            if(stack.empty() || S[i] == \\'(\\'){\\n                stack.push_back(make_pair(S[i], 0));\\n            }\\n            else{ //S is valid so S[i] == \\')\\' and stack.back().first == \\'(\\'\\n                score = stack.back().second * 2;\\n                score = score == 0? 1 : score;\\n                stack.pop_back();\\n                if(stack.empty()){\\n                    sum += score;\\n                }\\n                else{ //S is valid so stack.back().fist ==\\'(\\'\\n                    stack.back().second += score;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442398,
                "title": "c-0ms-solution",
                "content": "````\\n#include<bits/stdc++.h>\\n#define FOR(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\\n#define RFOR(i,a,b) for(long long i = (long long)(a); i >= (long long)(b); i--)\\n#define MIN3(a,b,c) (a)<(b)?((a)<(c)?(a):(c)):((b)<(c)?(b):(c))\\n#define MAX(a,b) (a)>(b)?(a):(b)\\n#define MIN2(a,b) (a)<(b)?(a):(b)\\nusing namespace std;\\ntypedef pair<int, int> ii;\\ntypedef pair<int, ii> iii;\\ntypedef vector<ii> vii;\\ntypedef vector<int> vi;\\ntypedef long long ll;\\n#define ull unsigned long long\\ntypedef long double ld;\\ntypedef vector<ll> vll;\\ntypedef pair<ll,ll> lll;\\n#define deb(x )     cerr << #x << \" here \"<< x << endl;\\n#define endl    \"\\\\n\"\\n#define printCase() \"Case #\" << caseNum << \": \"\\ninline bool is_palindrome(const string& s){ return std::equal(s.begin(), s.end(), s.rbegin()); }\\nconst ll MOD = 1000000007;\\nconst ll INF = 1e9+5;\\nconst double eps = 1e-7;\\nconst double PI = acos(-1.0);\\n#define coud(a,d) cout << fixed << showpoint << setprecision(d) << a;\\ninline void debug_vi(vi a) {FOR(i, 0, a.size()) cout<<a[i]<<\" \";}\\ninline void debug_vll(vll a) {FOR(i, 0, a.size()) cout<<a[i]<<\" \";}\\n#define ff first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int> st;\\n        int cnt = 0;\\n        // ) = 0  ( = -1\\n        FOR(i,0,S.length()) {\\n            if(S[i] == \\')\\') {\\n                int a = st.top();\\n                st.pop();\\n                int n = 0;\\n                while(a != 0) {\\n                    n+=a;\\n                    a = st.top();\\n                    st.pop();\\n                }\\n                st.push(n== 0?1:2*n);\\n            } else {\\n                st.push(0);\\n            }\\n        }\\n        int n = 0;\\n        while(!st.empty()) {\\n            n+=st.top();\\n            st.pop();\\n        }\\n        return n;\\n    }\\n};\\n```\\n\\nimplemented using stack . \\nPlease tell if you find any error in this approach",
                "solutionTags": [],
                "code": "````\\n#include<bits/stdc++.h>\\n#define FOR(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\\n#define RFOR(i,a,b) for(long long i = (long long)(a); i >= (long long)(b); i--)\\n#define MIN3(a,b,c) (a)<(b)?((a)<(c)?(a):(c)):((b)<(c)?(b):(c))\\n#define MAX(a,b) (a)>(b)?(a):(b)\\n#define MIN2(a,b) (a)<(b)?(a):(b)\\nusing namespace std;\\ntypedef pair<int, int> ii;\\ntypedef pair<int, ii> iii;\\ntypedef vector<ii> vii;\\ntypedef vector<int> vi;\\ntypedef long long ll;\\n#define ull unsigned long long\\ntypedef long double ld;\\ntypedef vector<ll> vll;\\ntypedef pair<ll,ll> lll;\\n#define deb(x )     cerr << #x << \" here \"<< x << endl;\\n#define endl    \"\\\\n\"\\n#define printCase() \"Case #\" << caseNum << \": \"\\ninline bool is_palindrome(const string& s){ return std::equal(s.begin(), s.end(), s.rbegin()); }\\nconst ll MOD = 1000000007;\\nconst ll INF = 1e9+5;\\nconst double eps = 1e-7;\\nconst double PI = acos(-1.0);\\n#define coud(a,d) cout << fixed << showpoint << setprecision(d) << a;\\ninline void debug_vi(vi a) {FOR(i, 0, a.size()) cout<<a[i]<<\" \";}\\ninline void debug_vll(vll a) {FOR(i, 0, a.size()) cout<<a[i]<<\" \";}\\n#define ff first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int> st;\\n        int cnt = 0;\\n        // ) = 0  ( = -1\\n        FOR(i,0,S.length()) {\\n            if(S[i] == \\')\\') {\\n                int a = st.top();\\n                st.pop();\\n                int n = 0;\\n                while(a != 0) {\\n                    n+=a;\\n                    a = st.top();\\n                    st.pop();\\n                }\\n                st.push(n== 0?1:2*n);\\n            } else {\\n                st.push(0);\\n            }\\n        }\\n        int n = 0;\\n        while(!st.empty()) {\\n            n+=st.top();\\n            st.pop();\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 263080,
                "title": "javascript-recursive-solution",
                "content": "```js\\nconst scoreOfParentheses = (S) => {\\n    if (S === \\'()\\') return 1;\\n    \\n    const stack = [], parts = [];\\n    let part = \\'\\';\\n    for (const char of S) {\\n        part += char;\\n        if (char === \\'(\\') {\\n            stack.push(0);\\n        } else {\\n            stack.pop();\\n            if (stack.length === 0) {\\n                parts.push(part);\\n                part = \\'\\';\\n            }\\n        }\\n    }\\n    if (parts.length === 1) {\\n        return scoreOfParentheses(S.slice(1, S.length - 1)) * 2;\\n    }\\n    return parts.reduce((prev, item) => prev + scoreOfParentheses(item), 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\nconst scoreOfParentheses = (S) => {\\n    if (S === \\'()\\') return 1;\\n    \\n    const stack = [], parts = [];\\n    let part = \\'\\';\\n    for (const char of S) {\\n        part += char;\\n        if (char === \\'(\\') {\\n            stack.push(0);\\n        } else {\\n            stack.pop();\\n            if (stack.length === 0) {\\n                parts.push(part);\\n                part = \\'\\';\\n            }\\n        }\\n    }\\n    if (parts.length === 1) {\\n        return scoreOfParentheses(S.slice(1, S.length - 1)) * 2;\\n    }\\n    return parts.reduce((prev, item) => prev + scoreOfParentheses(item), 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150131,
                "title": "java-solution-o-1-space-o-n-time",
                "content": "The key is to recognize that we only add to result when a \\')\\' is found right after a \\'(\\'. Use an interger to keep track of how much we should add to result when a \"()\" pattern is found.\\n\\n```\\npublic int scoreOfParentheses(String S) {\\n    int mult = 0, res = 0;  //Multiplier determines how much should be added to result when a \"()\" is found\\n    for (int i = 0; i < S.length(); i++){\\n        if (S.charAt(i)==\\'(\\'){\\n            mult+=mult==0?1:mult;\\n        }else{\\n            if (S.charAt(i-1)==\\'(\\'){\\n                res+=mult;\\n            }\\n            mult/=2;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int scoreOfParentheses(String S) {\\n    int mult = 0, res = 0;  //Multiplier determines how much should be added to result when a \"()\" is found\\n    for (int i = 0; i < S.length(); i++){\\n        if (S.charAt(i)==\\'(\\'){\\n            mult+=mult==0?1:mult;\\n        }else{\\n            if (S.charAt(i-1)==\\'(\\'){\\n                res+=mult;\\n            }\\n            mult/=2;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142048,
                "title": "python-o-n-solution-with-explanation",
                "content": "Each element or collection of elements in the string can be considered a primitive or an object. Primitives are single elements `(` or `)` while objects are constructs that can be created out of primitives, such as `(())` or `()()`. By keeping track of the score of objects as we traverse the string, the total score can be computed easily.\\n\\nThe stack contains tuples of the form `(x, y)` where `x` is a boolean indicating whether the item is a primitive or object and `y` is an integer describing the primitive/object\\'s score.\\n* When encountering `(`, we push `(` onto the stack as a primitive with score 0\\n* When encountering `)`, there are two cases: the `)` either (1) the closes a `(` primitive or (2) encompasses an object or series of objects that contains a `(` in the beginning. For (1), we can construct an object `()` with score `1` and push it onto the stack. For (2), we can compute the score of the series of objects, multiply it by two when we discover a `(`, then push the newly formed object onto the stack.\\n\\nIn the end, the stack will contain a series of objects since all primitives will have turned into objects. Therefore, we can simply compute the score of all objects, which is the result.\\n\\n    def scoreOfParentheses(self, S):\\n        stack = []\\n        res = 0\\n        \\n        for c in S:\\n            if c == \\'(\\':\\n                stack.append((False, 0))\\n            if c == \\')\\':\\n                obj, new_score = stack.pop()\\n                if obj:\\n                    while obj:\\n                        obj, score = stack.pop()\\n                        new_score += score\\n                    stack.append((True, new_score * 2))\\n                else:\\n                    stack.append((True, 1))\\n\\n        while stack:\\n            obj, score = stack.pop()\\n            res += score\\n        \\n        return res",
                "solutionTags": [],
                "code": "Each element or collection of elements in the string can be considered a primitive or an object. Primitives are single elements `(` or `)` while objects are constructs that can be created out of primitives, such as `(())` or `()()`. By keeping track of the score of objects as we traverse the string, the total score can be computed easily.\\n\\nThe stack contains tuples of the form `(x, y)` where `x` is a boolean indicating whether the item is a primitive or object and `y` is an integer describing the primitive/object\\'s score.\\n* When encountering `(`, we push `(` onto the stack as a primitive with score 0\\n* When encountering `)`, there are two cases: the `)` either (1) the closes a `(` primitive or (2) encompasses an object or series of objects that contains a `(` in the beginning. For (1), we can construct an object `()` with score `1` and push it onto the stack. For (2), we can compute the score of the series of objects, multiply it by two when we discover a `(`, then push the newly formed object onto the stack.\\n\\nIn the end, the stack will contain a series of objects since all primitives will have turned into objects. Therefore, we can simply compute the score of all objects, which is the result.\\n\\n    def scoreOfParentheses(self, S):\\n        stack = []\\n        res = 0\\n        \\n        for c in S:\\n            if c == \\'(\\':\\n                stack.append((False, 0))\\n            if c == \\')\\':\\n                obj, new_score = stack.pop()\\n                if obj:\\n                    while obj:\\n                        obj, score = stack.pop()\\n                        new_score += score\\n                    stack.append((True, new_score * 2))\\n                else:\\n                    stack.append((True, 1))\\n\\n        while stack:\\n            obj, score = stack.pop()\\n            res += score\\n        \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 141865,
                "title": "short-java-solution",
                "content": "```\\n    public int scoreOfParentheses(String S) {\\n        int ans = 0, depth = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            depth += S.charAt(i) == \\'(\\' ? 1 : -1;\\n            if (S.charAt(i) == \\'(\\' && S.charAt(i + 1) == \\')\\') ans += 1 << (depth - 1); \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int scoreOfParentheses(String S) {\\n        int ans = 0, depth = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            depth += S.charAt(i) == \\'(\\' ? 1 : -1;\\n            if (S.charAt(i) == \\'(\\' && S.charAt(i + 1) == \\')\\') ans += 1 << (depth - 1); \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141804,
                "title": "java-o-n-one-pass-non-recursive-using-stack",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int[] sum = new int[S.length() * 2];\\n        int top = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            if (S.charAt(i) == \\'(\\') {\\n                sum[++top] = 0;\\n            } else {\\n                sum[top - 1] += (S.charAt(i - 1) == \\'(\\' ? 1 : 2 * sum[top]);\\n                top--;\\n            }\\n        }\\n        return sum[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int[] sum = new int[S.length() * 2];\\n        int top = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            if (S.charAt(i) == \\'(\\') {\\n                sum[++top] = 0;\\n            } else {\\n                sum[top - 1] += (S.charAt(i - 1) == \\'(\\' ? 1 : 2 * sum[top]);\\n                top--;\\n            }\\n        }\\n        return sum[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141803,
                "title": "no-3-4-liners-easily-understood-c-recursive-solution-with-explanation",
                "content": "No Hard feelings against 3-4 liners. But I just feel that its sometimes too difficult to come up with 3-4 lines of optimal solution during an actual interview :)\\n\\nThe idea is simple. Once you encounter a \\'(\\', you check whether the next element is \\')\\'. If it is, then you add 1 to the current result, else you recursively calculate the inner parentheses pattern value and multiply it by 2 and add to the current result.\\nSince we are using C++, so we can use pass by reference for index. \\nPlease do let me know if solution can be optimized further.\\n\\n```\\nclass Solution {\\npublic:\\n    int util(string& S,int& index){\\n        int result = 0;\\n        while(index < S.length()){\\n            if(S[index] == \\')\\') return result;\\n            else{\\n                if(S[index + 1] == \\')\\'){\\n                    result += 1;\\n                    index++;\\n                }\\n                else result += 2*util(S,++index);\\n            }\\n            index++;\\n        }\\n        return result;\\n    }\\n    \\n    int scoreOfParentheses(string S) {\\n        int n = S.length();\\n        if(n == 2) return 1;\\n        int index = 0;\\n        return util(S,index);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int util(string& S,int& index){\\n        int result = 0;\\n        while(index < S.length()){\\n            if(S[index] == \\')\\') return result;\\n            else{\\n                if(S[index + 1] == \\')\\'){\\n                    result += 1;\\n                    index++;\\n                }\\n                else result += 2*util(S,++index);\\n            }\\n            index++;\\n        }\\n        return result;\\n    }\\n    \\n    int scoreOfParentheses(string S) {\\n        int n = S.length();\\n        if(n == 2) return 1;\\n        int index = 0;\\n        return util(S,index);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011105,
                "title": "very-easy-soln-stack-greedy-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        # Initialize an empty stack to keep track of scores\\n        st = []\\n        # Initialize a variable to store the final result\\n        res = 0\\n        \\n        # Iterate through each character in the input string \\'s\\'\\n        for i in s:\\n            if i == \"(\":\\n                # When an opening parenthesis is encountered, push the current result onto the stack\\n                st.append(res)\\n                # Reset the current result to 0\\n                res = 0\\n            else:\\n                # When a closing parenthesis is encountered, pop the last result from the stack\\n                popd = st.pop()\\n                # Calculate the new result for the current parenthesis pair and update \\'res\\'\\n                res = popd + max(2 * res, 1)\\n        \\n        # The final \\'res\\' will contain the score of the entire expression\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        # Initialize an empty stack to keep track of scores\\n        st = []\\n        # Initialize a variable to store the final result\\n        res = 0\\n        \\n        # Iterate through each character in the input string \\'s\\'\\n        for i in s:\\n            if i == \"(\":\\n                # When an opening parenthesis is encountered, push the current result onto the stack\\n                st.append(res)\\n                # Reset the current result to 0\\n                res = 0\\n            else:\\n                # When a closing parenthesis is encountered, pop the last result from the stack\\n                popd = st.pop()\\n                # Calculate the new result for the current parenthesis pair and update \\'res\\'\\n                res = popd + max(2 * res, 1)\\n        \\n        # The final \\'res\\' will contain the score of the entire expression\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005820,
                "title": "simple-cpp-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans = 0;\\n\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'(\\')st.push(-1);\\n            if(s[i]==\\')\\'){\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }else{\\n                    int temp = 0;\\n                    while(st.top()!=-1){\\n                        temp+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*temp);\\n                }\\n            }\\n        }\\n\\n        while(st.size()){ans+=st.top(); st.pop();}\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans = 0;\\n\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'(\\')st.push(-1);\\n            if(s[i]==\\')\\'){\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }else{\\n                    int temp = 0;\\n                    while(st.top()!=-1){\\n                        temp+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*temp);\\n                }\\n            }\\n        }\\n\\n        while(st.size()){ans+=st.top(); st.pop();}\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756768,
                "title": "c-beats-100-recursive-simple-beginner-solution-commented",
                "content": "\\n# Approach\\nThink it as :- If we encounter a \\'(\\', then we see next char to it , if the next char is \\')\\' ,then we simply add 1 to ans ,else we call recursively to the next index and multiply the recursive sub-solution with 2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(string &s,int &i)\\n    {\\n        int ans=0;\\n        while(i<s.size() && s[i]!=\\')\\')\\n        {\\n            // if we have entered the loop => s[i]==\\'(\\' , now look for next char, so i++;\\n            i++;\\n            if(s[i]==\\')\\')  // now if next char is \\')\\' , => we got one pair so ans++;  \\n            ans++;\\n            else // if next char is \\'(\\' then we call recursion to i and multiply the recursive  \\n            ans += 2*solve(s,i);    //sub-solution with 2 , as per the rule of problem\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n    int scoreOfParentheses(string s) {\\n        int i=0;\\n        return solve(s,i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(string &s,int &i)\\n    {\\n        int ans=0;\\n        while(i<s.size() && s[i]!=\\')\\')\\n        {\\n            // if we have entered the loop => s[i]==\\'(\\' , now look for next char, so i++;\\n            i++;\\n            if(s[i]==\\')\\')  // now if next char is \\')\\' , => we got one pair so ans++;  \\n            ans++;\\n            else // if next char is \\'(\\' then we call recursion to i and multiply the recursive  \\n            ans += 2*solve(s,i);    //sub-solution with 2 , as per the rule of problem\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n    int scoreOfParentheses(string s) {\\n        int i=0;\\n        return solve(s,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643447,
                "title": "easy-to-understand-stack-c-solution",
                "content": "# Intuition\\nWhenever we see a parenthesis problem first intuition is using stacks.\\nThis is a special problem as here we have to carry the previous scores of the closed parenthesis.\\nThe code written below is a true beauty.\\nU will easily understand the logic behind it however it took time to come this solution on paper using many Testcases.\\n Below is the most beautiful line which reinitialise score as 0 .\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nUsing s.top() is understood but max function is used because score is being calculated inside which can be at times 0 so in that case we add to s.top(). rest applies to the condition\\n (()()\\')\\'\\nthis bracket is used for multiplication only.\\n\\nBasically every ( is carying the past scores in the stack and reinstatting its own score =0;\\n\\nupvote if you find it helpful !\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string str) {\\n\\n        stack<char> s;\\n        int n=str.size();\\n        int score=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(str[i]==\\'(\\'){\\n\\n                s.push(score);\\n                score=0;\\n\\n            }\\n\\n            else{\\n\\n                score=s.top()+max(2*score,1);\\n                s.pop();\\n            }\\n\\n        }\\n\\n\\n        return score;\\n\\n       \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string str) {\\n\\n        stack<char> s;\\n        int n=str.size();\\n        int score=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(str[i]==\\'(\\'){\\n\\n                s.push(score);\\n                score=0;\\n\\n            }\\n\\n            else{\\n\\n                score=s.top()+max(2*score,1);\\n                s.pop();\\n            }\\n\\n        }\\n\\n\\n        return score;\\n\\n       \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338104,
                "title": "very-simple-java-solution-beats-100-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        \\n        // instead of calculating like 2*(2*(1+1)+1). calculating like : 4*1 + 4*1 + 2*1\\n        int mul = 1;\\n        int add = 0;\\n        int ans = 0;\\n\\n        for(int i=0;i<s.length();i++){\\n\\n            char ch = s.charAt(i);\\n\\n            // keeping track of depth\\n            if(ch==\\'(\\' && s.charAt(i+1)==\\'(\\') mul *=2;  // for each nesting having a multiplier 2\\n\\n            else if(ch==\\'(\\' && s.charAt(i+1)==\\')\\'){\\n                add++;\\n                ans += add*mul;         // seperatly calculating the score\\n                add = 0;\\n                i++;\\n            }else if(ch==\\')\\'){\\n                mul /= 2;           // moving out of a nesting\\n            }\\n        }\\n\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        \\n        // instead of calculating like 2*(2*(1+1)+1). calculating like : 4*1 + 4*1 + 2*1\\n        int mul = 1;\\n        int add = 0;\\n        int ans = 0;\\n\\n        for(int i=0;i<s.length();i++){\\n\\n            char ch = s.charAt(i);\\n\\n            // keeping track of depth\\n            if(ch==\\'(\\' && s.charAt(i+1)==\\'(\\') mul *=2;  // for each nesting having a multiplier 2\\n\\n            else if(ch==\\'(\\' && s.charAt(i+1)==\\')\\'){\\n                add++;\\n                ans += add*mul;         // seperatly calculating the score\\n                add = 0;\\n                i++;\\n            }else if(ch==\\')\\'){\\n                mul /= 2;           // moving out of a nesting\\n            }\\n        }\\n\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217612,
                "title": "python-96-faster-easy-sliding-window",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        a,n=[],len(s)\\n        c=t=0\\n        for i in range(1,n):\\n            if s[i]==\\'(\\':\\n                t+=1\\n            elif s[i-1]==\\'(\\':\\n                c+=1<<t\\n                t-=1\\n            else:\\n                t-=1\\n        return c\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        a,n=[],len(s)\\n        c=t=0\\n        for i in range(1,n):\\n            if s[i]==\\'(\\':\\n                t+=1\\n            elif s[i-1]==\\'(\\':\\n                c+=1<<t\\n                t-=1\\n            else:\\n                t-=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019659,
                "title": "use-stack-to-store-intermediate-values-as-well-push-1-when-you-see",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.length();\\n        stack<int> st;\\n        int res = 0;\\n        bool f = false;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(-1);\\n            }\\n            else\\n            {\\n                int temp=0;\\n                while(!st.empty() && st.top()>-1)\\n                {\\n                    temp+=st.top();\\n                    st.pop();\\n                    f=1;\\n                }\\n                if(!st.empty() && st.top()==-1)\\n                {\\n                    if(!f){\\n                        st.pop();\\n                        st.push(1);\\n                    }\\n                    else\\n                    {\\n                        f=0;\\n                        st.pop();\\n                        st.push(temp*2);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            if(st.top()!=-1)\\n                res+=st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.length();\\n        stack<int> st;\\n        int res = 0;\\n        bool f = false;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(-1);\\n            }\\n            else\\n            {\\n                int temp=0;\\n                while(!st.empty() && st.top()>-1)\\n                {\\n                    temp+=st.top();\\n                    st.pop();\\n                    f=1;\\n                }\\n                if(!st.empty() && st.top()==-1)\\n                {\\n                    if(!f){\\n                        st.pop();\\n                        st.push(1);\\n                    }\\n                    else\\n                    {\\n                        f=0;\\n                        st.pop();\\n                        st.push(temp*2);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            if(st.top()!=-1)\\n                res+=st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959716,
                "title": "c-runtime-beats-100-using-stack-basics",
                "content": "**856. Score of Parentheses \\u23E9 An implementation problem**\\n\\nIf `s[i]==\\'(\\'` we will push it in stack as something to add to score has come.\\nif `s[i]==\\')\\'` now is the time to increment our score by factor ***k*** because it is time for this balanced bracket to leave. \\n\\n**Q.** How much should ***k*** be?\\n**Ans:** If `(((` is a sequence and a `)` comes, we can see that ( ( **( )** the bold balanced-bracket comes after 2 continuous brackets and it is given that `(A) = 2*A`. \\nTherefore, here `((()` will be `2*2*1` as `()` = 1 Or we can see this as `2^(size_of_stack-1)`, hence ***k*** = `pow(2,size_of_stack-1)`.\\n**Then we stop adding scores for upcoming continuous `)` brackets as obviously they are already included in `2^x`**.\\n\\nNote: Approach is very simple, but if you find the explanation unclear, kindly go through the code and dry-run for `s = \"(())((())())\"` and you\\'ll understand it. \\n\\nSome examples:\\n```\\n* ()() => 1+1\\n* (()()) => 2*(1+1)\\n* ((()())) => 2*2*(1+1)\\n* ((()(()))) => 2*2*(1+2*1)\\n```\\n\\n\\nTime: **O(N)** \\nSpace: **O(N)** \\n\\n**`C++ CODE` \\u2B07**\\n\\n```\\nint scoreOfParentheses(string s) {\\n        stack<char>st;\\n        int score=0;\\n        bool addScore=false;\\n        for(int i=0;i<s.size();i++){\\n            int sz = st.size()-1;\\n            if(s[i]==\\')\\'){\\n                if(addScore) \\n                    score+=pow(2,sz), addScore=false;\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n                addScore=true;\\n            }\\n        }\\n        return score;\\n}\\n```\\n\\n**UPVOTE if you like \\uD83D\\uDE07, feel free to ask doubts, I\\'ll try to reply asap.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n* ()() => 1+1\\n* (()()) => 2*(1+1)\\n* ((()())) => 2*2*(1+1)\\n* ((()(()))) => 2*2*(1+2*1)\\n```\n```\\nint scoreOfParentheses(string s) {\\n        stack<char>st;\\n        int score=0;\\n        bool addScore=false;\\n        for(int i=0;i<s.size();i++){\\n            int sz = st.size()-1;\\n            if(s[i]==\\')\\'){\\n                if(addScore) \\n                    score+=pow(2,sz), addScore=false;\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n                addScore=true;\\n            }\\n        }\\n        return score;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2704363,
                "title": "javascript-most-intuitive-solution",
                "content": "I think it\\'s much more intuitive solution than others, also Larry from video below\\nwas able to come up with it on spot which partly proves that it\\'s more intuitive, \\nthe easiest way to understand it is to dry run this test case:\\n\\'(()()())\\'\\nEsentially we push \\'(\\' if there is opening brackets and we calculate current sum if there is closing bracket, \\ncurrent sum might be spread across many groups, so we need to loop till we find previous opening bracket which we also going to \\npop as we found closing bracket to that particular opening bracket.\\n\\nFull explaination:\\nhttps://www.youtube.com/watch?v=QM7YYNFcgAU\\n\\n```\\nvar scoreOfParentheses = function(s) {\\n  const stack = []  \\n  \\n  for(let i = 0; i < s.length; i++) {\\n      const curr = s[i]\\n      \\n      if(curr===\\'(\\') {\\n          stack.push(\\'(\\')\\n          continue\\n      }\\n      \\n      let currSum = 0\\n      while(stack.length && stack[stack.length-1] !== \\'(\\') {\\n         currSum += stack.pop()\\n      }\\n      \\n      stack.pop()\\n      \\n      if(currSum===0) {\\n          stack.push(1)\\n      } else {\\n          stack.push(2*currSum)\\n      }\\n  }\\n    \\n    return stack.reduce((a,b) => a+b,0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar scoreOfParentheses = function(s) {\\n  const stack = []  \\n  \\n  for(let i = 0; i < s.length; i++) {\\n      const curr = s[i]\\n      \\n      if(curr===\\'(\\') {\\n          stack.push(\\'(\\')\\n          continue\\n      }\\n      \\n      let currSum = 0\\n      while(stack.length && stack[stack.length-1] !== \\'(\\') {\\n         currSum += stack.pop()\\n      }\\n      \\n      stack.pop()\\n      \\n      if(currSum===0) {\\n          stack.push(1)\\n      } else {\\n          stack.push(2*currSum)\\n      }\\n  }\\n    \\n    return stack.reduce((a,b) => a+b,0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2682015,
                "title": "c-solution",
                "content": "```\\npublic int ScoreOfParentheses(string s) {\\n\\tStack<int> stack = new Stack<int>();\\n\\tint score = 0;\\n\\tchar[] chars = s.ToCharArray();\\n\\tforeach(char c in chars)\\n\\t{\\n\\t\\tint val = 0;\\n\\t\\tif (c == \\'(\\') stack.Push(0);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t// calculate\\n\\t\\t\\twhile (stack.Peek() != 0) val = val + stack.Pop();\\n\\t\\t\\tval = Math.Max(2 * val, 1);\\n\\t\\t\\tstack.Pop();\\n\\t\\t\\tstack.Push(val);\\n\\t\\t}\\n\\t}\\n\\twhile(stack.Count > 0)\\n\\t\\tscore = score + stack.Pop();\\n\\treturn score;\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack"
                ],
                "code": "```\\npublic int ScoreOfParentheses(string s) {\\n\\tStack<int> stack = new Stack<int>();\\n\\tint score = 0;\\n\\tchar[] chars = s.ToCharArray();\\n\\tforeach(char c in chars)\\n\\t{\\n\\t\\tint val = 0;\\n\\t\\tif (c == \\'(\\') stack.Push(0);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t// calculate\\n\\t\\t\\twhile (stack.Peek() != 0) val = val + stack.Pop();\\n\\t\\t\\tval = Math.Max(2 * val, 1);\\n\\t\\t\\tstack.Pop();\\n\\t\\t\\tstack.Push(val);\\n\\t\\t}\\n\\t}\\n\\twhile(stack.Count > 0)\\n\\t\\tscore = score + stack.Pop();\\n\\treturn score;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664560,
                "title": "python-solution-explained-line-by-line",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int: \\n        st=[] #stack declared\\n        \\n        for i in s:\\n            #if ( is found put in stack\\n            if i==\\'(\\': \\n                st.append(i)\\n                \\n            #if ) is found \\n            elif i==\\')\\': \\n                \\n                #and stack top is opening bracket then need to enter the score 1\\n                #as said in question => \"()\" has score 1\\n                if st[-1]==\\'(\\': \\n                    st.pop()\\n                    st.append(1)\\n                \\n                #but if opening bracket is not found in st then there must me score numbers\\n                #are present in above opening bracket => 2nd rule (check in ques)\\n                #eg: st=[(,(,1,1,1,)] , closing bracket in st only for understanding, we are not really append it\\n                else:\\n                    #calculate the score till the opening bracket found\\n                    score=0\\n                    while st[-1]!=\\'(\\':\\n                        score+=st.pop()\\n                        \\n                    #so pop the opening bracket as we have calculated the score above it and \\n                    #now we have reached the 3rd rule => (A) has score 2 * A\\n                    #eg: st=[(,(,3,)] , closing bracket in st only for understanding, we are not really append it\\n                    st.pop()\\n                    st.append(2*score)\\n                    \\n        #return total sum of numbers present in st\\n        return sum(st)\\n        \\n```\\n**PLEASE UPVOTE IF YOU FOUND THE SOLUTION HELPFUL, THANKS !!**\\n**AND FREELY ASK YOUR DOUBTS** \\uD83C\\uDF3A",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int: \\n        st=[] #stack declared\\n        \\n        for i in s:\\n            #if ( is found put in stack\\n            if i==\\'(\\': \\n                st.append(i)\\n                \\n            #if ) is found \\n            elif i==\\')\\': \\n                \\n                #and stack top is opening bracket then need to enter the score 1\\n                #as said in question => \"()\" has score 1\\n                if st[-1]==\\'(\\': \\n                    st.pop()\\n                    st.append(1)\\n                \\n                #but if opening bracket is not found in st then there must me score numbers\\n                #are present in above opening bracket => 2nd rule (check in ques)\\n                #eg: st=[(,(,1,1,1,)] , closing bracket in st only for understanding, we are not really append it\\n                else:\\n                    #calculate the score till the opening bracket found\\n                    score=0\\n                    while st[-1]!=\\'(\\':\\n                        score+=st.pop()\\n                        \\n                    #so pop the opening bracket as we have calculated the score above it and \\n                    #now we have reached the 3rd rule => (A) has score 2 * A\\n                    #eg: st=[(,(,3,)] , closing bracket in st only for understanding, we are not really append it\\n                    st.pop()\\n                    st.append(2*score)\\n                    \\n        #return total sum of numbers present in st\\n        return sum(st)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639620,
                "title": "c-o-n-simple-solution",
                "content": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(-1);\\n            else\\n            {\\n                if(!st.empty() && st.top()==-1)\\n                {\\n                    int count=1;\\n                    st.pop();\\n                    while(!st.empty() && st.top()!=-1)\\n                    {\\n                        count=count+st.top();\\n                        st.pop();\\n                    }\\n                    st.push(count);\\n                }\\n                else \\n                {\\n                    int count=0;\\n                    while(!st.empty() && st.top()!=-1)\\n                    {\\n                        count=count+st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(count*2);\\n                }\\n            }\\n            \\n        }\\n        int res=0;\\n        while(!st.empty()){\\n            res+=(int)st.top();st.pop();}\\n        return(res);\\n    }\\n};\\nWe simply assume \\'(\\' to be -1 and make a stack of integers and simply follow the instructions given in the question.",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(-1);\\n            else\\n            {\\n                if(!st.empty() && st.top()==-1)\\n                {\\n                    int count=1;\\n                    st.pop();\\n                    while(!st.empty() && st.top()!=-1)\\n                    {\\n                        count=count+st.top();\\n                        st.pop();\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2603270,
                "title": "easy-javascript-solution",
                "content": "```\\nvar scoreOfParentheses = function(s) {\\n    let stack = [0];\\n    \\n    for (let el of s) {\\n        if (el === \\'(\\') stack.push(0);\\n        \\n        else {\\n            let popped = stack.pop();\\n            \\n            if (popped === 0) stack[stack.length - 1] += 1;\\n            else {\\n                popped *= 2;\\n                stack[stack.length - 1] += popped;\\n            }\\n        }\\n    }\\n    \\n    return stack[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar scoreOfParentheses = function(s) {\\n    let stack = [0];\\n    \\n    for (let el of s) {\\n        if (el === \\'(\\') stack.push(0);\\n        \\n        else {\\n            let popped = stack.pop();\\n            \\n            if (popped === 0) stack[stack.length - 1] += 1;\\n            else {\\n                popped *= 2;\\n                stack[stack.length - 1] += popped;\\n            }\\n        }\\n    }\\n    \\n    return stack[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522600,
                "title": "c-100-fastest-easy-solution",
                "content": "Push -1 for \\'(\\' and push the value of corresponding balanced paranthesis string when you encounter \\')\\'.\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        \\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            st.push(-1);\\n            else\\n            {\\n                int x=0;\\n                while(st.size() and st.top()>0) // pop all numbers stored and store sum in x\\n                {\\n                    x+=st.top();\\n                    st.pop();\\n                }\\n                st.pop(); // pop the \\'(\\' char\\n                if(x==0) // if there was no number push 1 [for simple () ]\\n                st.push(1);\\n                else\\n                st.push(x*2); // else push total value * 2\\n            }\\n        }\\n        int ans=0;\\n        while(st.size()) //  sum all the remaining numbers and return sum\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        \\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            st.push(-1);\\n            else\\n            {\\n                int x=0;\\n                while(st.size() and st.top()>0) // pop all numbers stored and store sum in x\\n                {\\n                    x+=st.top();\\n                    st.pop();\\n                }\\n                st.pop(); // pop the \\'(\\' char\\n                if(x==0) // if there was no number push 1 [for simple () ]\\n                st.push(1);\\n                else\\n                st.push(x*2); // else push total value * 2\\n            }\\n        }\\n        int ans=0;\\n        while(st.size()) //  sum all the remaining numbers and return sum\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457022,
                "title": "java-solution-stack",
                "content": "```java \\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n                st.push(0);\\n            else\\n            {\\n                int a = 0;\\n                while(st.peek()!=0)\\n                    a+=st.pop();\\n                st.pop();\\n                st.push(Math.max(1,2*a));\\n            }\\n        }\\n        int score=0;\\n        while(!st.isEmpty()){\\n            score+=st.pop();\\n        }\\n        return score;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n                st.push(0);\\n            else\\n            {\\n                int a = 0;\\n                while(st.peek()!=0)\\n                    a+=st.pop();\\n                st.pop();\\n                st.push(Math.max(1,2*a));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2366247,
                "title": "easy-gredy-without-stack-o-n",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        \\n        level = 0\\n        result = 0\\n        prev = \"\"\\n        \\n        for c in s:           \\n            if c == \"(\":\\n                level += 1\\n            if c == \")\":\\n                if prev == \"(\":\\n                    result += 2 ** (level - 1)\\n                level -= 1                \\n            prev = c\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        \\n        level = 0\\n        result = 0\\n        prev = \"\"\\n        \\n        for c in s:           \\n            if c == \"(\":\\n                level += 1\\n            if c == \")\":\\n                if prev == \"(\":\\n                    result += 2 ** (level - 1)\\n                level -= 1                \\n            prev = c\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347385,
                "title": "c-iterative-stack-solution",
                "content": "(i) for a single opening brace, push score 0\\n(ii) if we found a closing brace then caluculate the score and push the curr score into the stack\\n(iii) at the end sum up all the scores and return \\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans =0;\\n        for(char c : s){\\n            int curr = 0;\\n            if(c == \\'(\\') st.push(0);\\n            else{\\n                while(st.top() != 0){\\n                    curr += st.top();\\n                    st.pop();\\n                }\\n                curr = max(curr*2,1);\\n                st.pop();\\n                st.push(curr);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans =0;\\n        for(char c : s){\\n            int curr = 0;\\n            if(c == \\'(\\') st.push(0);\\n            else{\\n                while(st.top() != 0){\\n                    curr += st.top();\\n                    st.pop();\\n                }\\n                curr = max(curr*2,1);\\n                st.pop();\\n                st.push(curr);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322146,
                "title": "c-stack-o-n-time-complexity",
                "content": "```\\nint scoreOfParentheses(string s) {\\n        \\n        stack<int> st;\\n        for(int i=0;i<s.length();i++)\\n            if(s[i]==\\'(\\')\\n                st.push(0);\\n            else\\n            {\\n                int flag=0;\\n                if(!st.top())\\n                {\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else\\n                {\\n                    while(st.top())\\n                    {\\n                        flag+=st.top();\\n                        st.pop();\\n                    }\\n                st.pop();\\n                st.push(2*flag);\\n                }\\n            }\\n        int result=0;\\n        while(!st.empty())\\n        {\\n            result+=st.top();\\n            st.pop();\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        \\n        stack<int> st;\\n        for(int i=0;i<s.length();i++)\\n            if(s[i]==\\'(\\')\\n                st.push(0);\\n            else\\n            {\\n                int flag=0;\\n                if(!st.top())\\n                {\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else\\n                {\\n                    while(st.top())\\n                    {\\n                        flag+=st.top();\\n                        st.pop();\\n                    }\\n                st.pop();\\n                st.push(2*flag);\\n                }\\n            }\\n        int result=0;\\n        while(!st.empty())\\n        {\\n            result+=st.top();\\n            st.pop();\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2219644,
                "title": "c-easy-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<char> st;\\n        int ans =0;\\n        char prev;\\n        for(auto &e : s){\\n            if(e == \\'(\\') st.push(e);\\n            else{\\n              st.pop();\\n              if(prev == \\'(\\') ans+= pow(2, st.size());               \\n            }\\n            prev = e;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<char> st;\\n        int ans =0;\\n        char prev;\\n        for(auto &e : s){\\n            if(e == \\'(\\') st.push(e);\\n            else{\\n              st.pop();\\n              if(prev == \\'(\\') ans+= pow(2, st.size());               \\n            }\\n            prev = e;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166066,
                "title": "c-simple-implementation-0ms-without-stack",
                "content": "**Please do upvote if you liked my efforts :)**\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int ans = 0, open = 0, idx = 0;\\n                \\n        while(idx < s.length())\\n        {\\n            if(s[idx] == \\'(\\') ++open;\\n            else\\n            {\\n                --open;\\n                if(s[idx-1] == \\'(\\') ans += (1 << open);\\n            }\\n            ++idx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int ans = 0, open = 0, idx = 0;\\n                \\n        while(idx < s.length())\\n        {\\n            if(s[idx] == \\'(\\') ++open;\\n            else\\n            {\\n                --open;\\n                if(s[idx-1] == \\'(\\') ans += (1 << open);\\n            }\\n            ++idx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134388,
                "title": "python-856-solution",
                "content": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if 2 == len(s):\\n            return 1\\n        if 0 == len(s):\\n\\t        return 0\\n        left_count = 0\\n        right_count = 0\\n        for i in range(len(s)): \\n            if s[i] == \\'(\\':\\n\\t\\t        left_count += 1\\n            if s[i] == \\')\\':\\n\\t\\t        right_count += 1\\n\\n            if left_count == right_count:\\n                if left_count > 1:\\n                    return 2*self.scoreOfParentheses(s[1:i]) + self.scoreOfParentheses(s[i+1:])\\n                else:\\n                    return self.scoreOfParentheses(s[:i+1]) + self.scoreOfParentheses(s[i+1:])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if 2 == len(s):\\n            return 1\\n        if 0 == len(s):\\n\\t        return 0\\n        left_count = 0\\n        right_count = 0\\n        for i in range(len(s)): \\n            if s[i] == \\'(\\':\\n\\t\\t        left_count += 1\\n            if s[i] == \\')\\':\\n\\t\\t        right_count += 1\\n\\n            if left_count == right_count:\\n                if left_count > 1:\\n                    return 2*self.scoreOfParentheses(s[1:i]) + self.scoreOfParentheses(s[i+1:])\\n                else:\\n                    return self.scoreOfParentheses(s[:i+1]) + self.scoreOfParentheses(s[i+1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117775,
                "title": "java-2ms-easy-code",
                "content": "class Solution {\\n\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int ans  = 0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                st.push(-1);\\n            }\\n            else{\\n                if(st.peek() == -1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else{\\n                    int sum = 0;\\n                    while(st.peek()!=-1){\\n                        sum += st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*sum);\\n                }\\n            }\\n        }\\n        while(st.size()>0){\\n            ans +=st.pop();\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int ans  = 0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                st.push(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2092537,
                "title": "intuitive-solution-with-commentary-hope-this-is-helpful",
                "content": "\\n```\\nExample: ()(()())\\n\\nVisualization :\\n\\tStep 1: [1 ,(1,1)]\\n\\tStep 2: [1, (2)]\\n\\tStep 3: [1, 4]\\n\\tStep 4: [5]\\n\\n```\\n\\n```\\nclass Solution {\\n    \\n    public int scoreOfParentheses(String s) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int ans = 0;\\n        \\n        int i=0;\\n        while(i< s.length()){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                // I\\'m using -1 to represent \\'(\\' in the stack\\n                st.push(-1);\\n            }\\n            else {\\n                if(st.peek() == -1){\\n                    // Solve case:() and push the answer into the stack\\n                    st.pop(); // pop -1 i.e \\'(\\'\\n                    st.push(1);// push the answer\\n                }else{\\n                    // Sum while we do not encounter \\'(\\' \\n                    // End of while loop represents case: ( A+B+C... )\\n                    int sum = 0;\\n                    while(st.peek()!=-1){\\n                        sum+=st.pop();\\n                    }\\n                    \\n                    // Remove the \\'(\\' and multiple by 2 \\n                    // same as 2 * [A+B+C]\\n                    // Push the result into the stack\\n                    st.pop(); // Pop the \\'(\\' in the beginning of case: ( A+B+C... )\\n                    st.push(2*sum); // sum = A+B+C+..\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        \\n        // At the end, stack will have \\n        // a) one element : Case : (()()) : everything is enclosed inside one ()\\n        // b) multiple elements: Case: ()(()())\\n        while(!st.isEmpty()){\\n            ans+=st.pop();\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\\n\\nPlease upvote if this was helpful. I\\'d use that as an indicator that it\\'s helping folks and I\\'d try to post more.",
                "solutionTags": [],
                "code": "```\\nExample: ()(()())\\n\\nVisualization :\\n\\tStep 1: [1 ,(1,1)]\\n\\tStep 2: [1, (2)]\\n\\tStep 3: [1, 4]\\n\\tStep 4: [5]\\n\\n```\n```\\nclass Solution {\\n    \\n    public int scoreOfParentheses(String s) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int ans = 0;\\n        \\n        int i=0;\\n        while(i< s.length()){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                // I\\'m using -1 to represent \\'(\\' in the stack\\n                st.push(-1);\\n            }\\n            else {\\n                if(st.peek() == -1){\\n                    // Solve case:() and push the answer into the stack\\n                    st.pop(); // pop -1 i.e \\'(\\'\\n                    st.push(1);// push the answer\\n                }else{\\n                    // Sum while we do not encounter \\'(\\' \\n                    // End of while loop represents case: ( A+B+C... )\\n                    int sum = 0;\\n                    while(st.peek()!=-1){\\n                        sum+=st.pop();\\n                    }\\n                    \\n                    // Remove the \\'(\\' and multiple by 2 \\n                    // same as 2 * [A+B+C]\\n                    // Push the result into the stack\\n                    st.pop(); // Pop the \\'(\\' in the beginning of case: ( A+B+C... )\\n                    st.push(2*sum); // sum = A+B+C+..\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        \\n        // At the end, stack will have \\n        // a) one element : Case : (()()) : everything is enclosed inside one ()\\n        // b) multiple elements: Case: ()(()())\\n        while(!st.isEmpty()){\\n            ans+=st.pop();\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085095,
                "title": "go-faster-than-100-without-stack",
                "content": "Counting the power of 2 by using bit shift:\\n\\n```\\nfunc scoreOfParentheses(s string) int {\\n    var open, result int\\n    var closeLast bool\\n    for _, letter := range s {\\n        if letter == \\'(\\' {\\n            closeLast = false\\n            open++\\n            continue\\n        }\\n        open--\\n        if closeLast {\\n            continue\\n        }\\n        result+= 1 << open\\n        closeLast = true \\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc scoreOfParentheses(s string) int {\\n    var open, result int\\n    var closeLast bool\\n    for _, letter := range s {\\n        if letter == \\'(\\' {\\n            closeLast = false\\n            open++\\n            continue\\n        }\\n        open--\\n        if closeLast {\\n            continue\\n        }\\n        result+= 1 << open\\n        closeLast = true \\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074800,
                "title": "100-faster-simply-explained",
                "content": "Whenever the incoming character is opening parathesis,-1 will be pushed into stack. if closing is occuring, top element of stack will be checked whether it is -1 ( indicating that the last character was opening paranthesis) or other positive number ( indicating that last character was a closing paranthesis).\\n\\n-1 -> (last char was opening paranthesis) 1 will be pushed in in place of -1 ( indication tha one valid paranthesis) \\npoitiive number other than -1 ->(last char was closing paranthesis) all positive numbers will be added and popped out untill we reach -1 again ( in order to put valid paranthesis value in stack)\\n![image](https://assets.leetcode.com/users/images/d882a64b-d40c-4371-be17-7bb5bf13aabd_1653543491.691877.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans=0;\\n        \\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                st.push(-1);        \\n            }else{\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }else{\\n                    ans=0;\\n                    while(st.top()!=-1){\\n                        ans+=st.top();\\n                        st.pop();\\n                    }\\n                    \\n                    st.pop();\\n                    \\n                    ans*=2;\\n                    st.push(ans);\\n                }\\n            }\\n            \\n        }\\n        \\n        ans=0;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans=0;\\n        \\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                st.push(-1);        \\n            }else{\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }else{\\n                    ans=0;\\n                    while(st.top()!=-1){\\n                        ans+=st.top();\\n                        st.pop();\\n                    }\\n                    \\n                    st.pop();\\n                    \\n                    ans*=2;\\n                    st.push(ans);\\n                }\\n            }\\n            \\n        }\\n        \\n        ans=0;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071648,
                "title": "python-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = []\\n        for i in s:\\n            if i == \"(\":\\n                stack.append(i)\\n                \\n            #checking for this ()\\n            elif stack[-1] == \"(\" and i == \")\":\\n                stack.pop()\\n                stack.append(1)\\n                \\n            else:\\n                \\n                #until did not found open parentheses adding the numbers\\n                count = 0\\n                while stack[-1] != \"(\":\\n                    count += stack.pop()\\n                if(stack[-1] == \"(\"):\\n                    stack.pop()\\n                    stack.append(count*2)\\n        return sum(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = []\\n        for i in s:\\n            if i == \"(\":\\n                stack.append(i)\\n                \\n            #checking for this ()\\n            elif stack[-1] == \"(\" and i == \")\":\\n                stack.pop()\\n                stack.append(1)\\n                \\n            else:\\n                \\n                #until did not found open parentheses adding the numbers\\n                count = 0\\n                while stack[-1] != \"(\":\\n                    count += stack.pop()\\n                if(stack[-1] == \"(\"):\\n                    stack.pop()\\n                    stack.append(count*2)\\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870460,
                "title": "java-0ms-submission-with-o-1-space",
                "content": "Basically when you open a bracket, you times the base with 2, when you close the bracket, you devided by 2. You only settle up the score when you meet a `()` i.e. (when `s.charAt(i) == \\')\\' && s.charAt(i-1) == \\'(\\'`.\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int res = 0, base = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                base *= 2;\\n            }\\n            else {\\n                base /= 2;\\n                if (s.charAt(i-1) == \\'(\\') {\\n                    res += base;\\n                }   \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int res = 0, base = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                base *= 2;\\n            }\\n            else {\\n                base /= 2;\\n                if (s.charAt(i-1) == \\'(\\') {\\n                    res += base;\\n                }   \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861572,
                "title": "c-clear-solution-o-n-time-o-1-space",
                "content": "```\\n\\tpublic int ScoreOfParentheses(string s) {\\n\\t\\tvar result = 0;\\n        var level = 0;\\n        for (int i=0; i<s.Length; i++) {\\n            if (s[i] == \\'(\\')\\n                level++;\\n            if (s[i] == \\')\\') {\\n                level--;\\n                result += s[i-1] == \\'(\\' ? 1 << level : 0;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int ScoreOfParentheses(string s) {\\n\\t\\tvar result = 0;\\n        var level = 0;\\n        for (int i=0; i<s.Length; i++) {\\n            if (s[i] == \\'(\\')\\n                level++;\\n            if (s[i] == \\')\\') {\\n                level--;\\n                result += s[i-1] == \\'(\\' ? 1 << level : 0;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1859699,
                "title": "easy-cpp-based-solution-0ms",
                "content": "```\\nint scoreOfParentheses(string s) {\\n        stack<int>s1;\\n        int n=0;\\n        int sum=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                s1.push(sum);\\n                sum=0;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                sum=s1.top() + max(2*sum,1);\\n                s1.pop();\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        stack<int>s1;\\n        int n=0;\\n        int sum=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                s1.push(sum);\\n                sum=0;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                sum=s1.top() + max(2*sum,1);\\n                s1.pop();\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1859042,
                "title": "rust-0ms-2mb",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Score of Parentheses.\\nMemory Usage: 2 MB, less than 100.00% of Rust online submissions for Score of Parentheses.\\n\\n```\\nimpl Solution {\\n    pub fn score_of_parentheses(s: String) -> i32 {\\n        let mut stack = vec![0];\\n        for ch in s.chars() { \\n            match ch  { \\n                \\'(\\' => stack.push(0),\\n                _ => { \\n                    let v = stack.pop().unwrap();\\n                    *stack.last_mut().unwrap() += i32::max(2 * v, 1)\\n                }\\n            }\\n        }\\n        stack.pop().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn score_of_parentheses(s: String) -> i32 {\\n        let mut stack = vec![0];\\n        for ch in s.chars() { \\n            match ch  { \\n                \\'(\\' => stack.push(0),\\n                _ => { \\n                    let v = stack.pop().unwrap();\\n                    *stack.last_mut().unwrap() += i32::max(2 * v, 1)\\n                }\\n            }\\n        }\\n        stack.pop().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858745,
                "title": "python-o-n-approach-stack-simple-and-easy",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack, ans = [0], 0\\n        for i in range(len(s)):\\n            if s[i] == \\')\\':\\n                curr = stack.pop()\\n                if curr == 0: ans = 1\\n                else: ans = 2*curr\\n                stack[-1] += ans\\n            else:\\n                stack.append(0)\\n        return stack[0]\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack, ans = [0], 0\\n        for i in range(len(s)):\\n            if s[i] == \\')\\':\\n                curr = stack.pop()\\n                if curr == 0: ans = 1\\n                else: ans = 2*curr\\n                stack[-1] += ans\\n            else:\\n                stack.append(0)\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858447,
                "title": "this-easy-code-is-not-mentioned-anywhere",
                "content": "Just push the character until you are getting \\'(\\' and when you iterator pointing to the closing braces \\')\\', then you have to check the stack size, if the stack size is 1, then ans++. Why.? For this type of cases \\'()\\', If stack size is greater than 1, than you just need to add the power of 2 raise to the stack.size()-1. \\nYou get the answer....!!!\\nTime Complexity - O(n)\\nSpace Complexity - O(n)\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        stack<char> st;\\n        int i = 0;\\n        int n = s.length();\\n        \\n        while(i<n){\\n            while(i <n && s[i] == \\'(\\'){\\n                st.push(s[i]);\\n                i++;\\n            }\\n            if(st.size() > 1){\\n                int sz = st.size();\\n                sz--;\\n                ans += (int)(pow(2, sz) + 1e-9);\\n            }\\n            else if(st.size() == 1){\\n                ans++;\\n            }\\n            while(i<n && s[i] == \\')\\'){\\n                st.pop();\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        stack<char> st;\\n        int i = 0;\\n        int n = s.length();\\n        \\n        while(i<n){\\n            while(i <n && s[i] == \\'(\\'){\\n                st.push(s[i]);\\n                i++;\\n            }\\n            if(st.size() > 1){\\n                int sz = st.size();\\n                sz--;\\n                ans += (int)(pow(2, sz) + 1e-9);\\n            }\\n            else if(st.size() == 1){\\n                ans++;\\n            }\\n            while(i<n && s[i] == \\')\\'){\\n                st.pop();\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858440,
                "title": "both-s-n-s-1-easiest-way-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    // O(N) && S(N)  \\n//     int scoreOfParentheses(string str) {\\n//         int ans=0;\\n//         stack<int> s;\\n//         for(auto it:str)\\n//             if(it==\\'(\\')\\n//                 s.push(ans),ans=0;\\n//             else\\n//                 ans=s.top()+max(2*ans,1),s.pop();\\n            \\n\\n//         return ans;\\n//     }\\n    \\n    //O(N) && S(1)\\n    int scoreOfParentheses(string str) {\\n        int ans=0;\\n        int score=1;\\n        int f=1;\\n        for(auto it:str)\\n            if(it==\\'(\\')\\n                score*=2,f=1;\\n            else{\\n                score/=2;\\n                if(f){\\n                    f=0;\\n                    ans+=score;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // O(N) && S(N)  \\n//     int scoreOfParentheses(string str) {\\n//         int ans=0;\\n//         stack<int> s;\\n//         for(auto it:str)\\n//             if(it==\\'(\\')\\n//                 s.push(ans),ans=0;\\n//             else\\n//                 ans=s.top()+max(2*ans,1),s.pop();\\n            \\n\\n//         return ans;\\n//     }\\n    \\n    //O(N) && S(1)\\n    int scoreOfParentheses(string str) {\\n        int ans=0;\\n        int score=1;\\n        int f=1;\\n        for(auto it:str)\\n            if(it==\\'(\\')\\n                score*=2,f=1;\\n            else{\\n                score/=2;\\n                if(f){\\n                    f=0;\\n                    ans+=score;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858355,
                "title": "c-solution-0ms-time-using-stack-brief-explanation",
                "content": "Here\\'s my C++ Solution using Stack ( 0ms time taken, 100% faster )-\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        stack<int> st;\\n        \\n        /* An Extra value to get final answer starting as 0 */\\n        st.push(0);\\n\\n        for(auto it:s){\\n            /* Simply add 0 in cases of opening braces */\\n            if(it==\\'(\\'){\\n                st.push(0);\\n            }\\n            \\n            /* start manipulating values when getting closing braces */\\n            else{\\n                /* Got the top of the Stack and removed it*/\\n                int k = st.top();\\n                st.pop();\\n                \\n                /* If the top was storing 0 that indicates this was first pair of opening and closing   braces, In this case just increase value by 1 */\\n                if(k== 0) k = k=1;\\n                \\n                /* If the value of top was greater than 0 that indicates inner pairs of so we\\'ll increase value by 2 */\\n                else k *= 2;\\n                \\n                /* This value will be added to the next top element to contribute in final answer */\\n                st.top()+=k;\\n            }\\n            \\n        }\\n       \\n        // Our extra 0 stored in the starting now actually contains the final answer\\n        return st.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        stack<int> st;\\n        \\n        /* An Extra value to get final answer starting as 0 */\\n        st.push(0);\\n\\n        for(auto it:s){\\n            /* Simply add 0 in cases of opening braces */\\n            if(it==\\'(\\'){\\n                st.push(0);\\n            }\\n            \\n            /* start manipulating values when getting closing braces */\\n            else{\\n                /* Got the top of the Stack and removed it*/\\n                int k = st.top();\\n                st.pop();\\n                \\n                /* If the top was storing 0 that indicates this was first pair of opening and closing   braces, In this case just increase value by 1 */\\n                if(k== 0) k = k=1;\\n                \\n                /* If the value of top was greater than 0 that indicates inner pairs of so we\\'ll increase value by 2 */\\n                else k *= 2;\\n                \\n                /* This value will be added to the next top element to contribute in final answer */\\n                st.top()+=k;\\n            }\\n            \\n        }\\n       \\n        // Our extra 0 stored in the starting now actually contains the final answer\\n        return st.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858298,
                "title": "c-faster-than-100-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<char> st;\\n        vector<int> dp(26,0);\\n        for(int i=0;i<s.length();i++) {\\n            if(s[i] == \\'(\\') {\\n                st.push(\\'(\\');\\n            } else {\\n                int idx = st.size();\\n                if(dp[idx] == 0)\\n                    dp[idx-1] += 1;\\n                else {\\n                    dp[idx-1] += 2*dp[idx];\\n                    dp[idx] = 0;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<char> st;\\n        vector<int> dp(26,0);\\n        for(int i=0;i<s.length();i++) {\\n            if(s[i] == \\'(\\') {\\n                st.push(\\'(\\');\\n            } else {\\n                int idx = st.size();\\n                if(dp[idx] == 0)\\n                    dp[idx-1] += 1;\\n                else {\\n                    dp[idx-1] += 2*dp[idx];\\n                    dp[idx] = 0;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858222,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    int scoreOfParentheses(string str) {\\n        \\n        int n = str.length();\\n        \\n        stack<int>s;\\n         \\n        for(int i=0;i<n;i++)\\n        {\\n            if(str[i]==\\'(\\')\\n            {\\n                s.push(-1);\\n            }\\n            else\\n            {\\n                if(s.top()==-1)\\n                {\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else\\n                {\\n                    int x = s.top();\\n                    s.pop();\\n                    if(!s.empty() and s.top()<0)\\n                    {\\n                        s.pop();\\n                    }\\n                    s.push(x*2);\\n                }\\n            }\\n            int y=0;\\n            while(!s.empty() and s.top()>0)\\n            {\\n               y += s.top();\\n                s.pop();\\n            }\\n            if(y)\\n                s.push(y);\\n        }\\n        return s.top();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string str) {\\n        \\n        int n = str.length();\\n        \\n        stack<int>s;\\n         \\n        for(int i=0;i<n;i++)\\n        {\\n            if(str[i]==\\'(\\')\\n            {\\n                s.push(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1858111,
                "title": "simple-c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int>stk;\\n        for(auto x:s){\\n            if(x==\\'(\\'){\\n                stk.push(-1);\\n            }else{\\n                if(stk.top()==-1){\\n                    stk.pop();\\n                    stk.push(1);\\n                }else{\\n                    int val=0;\\n                    while(stk.top()!=-1){\\n                        val+=stk.top();stk.pop();\\n                    }\\n                    stk.pop();\\n                    stk.push(2*val);\\n                }\\n            }\\n        }\\n        int val=0;\\n        while(stk.size()>0){\\n            val+=stk.top();stk.pop();\\n        }\\n        return val;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int>stk;\\n        for(auto x:s){\\n            if(x==\\'(\\'){\\n                stk.push(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1858043,
                "title": "100-faster-time-o-n-space-o-n",
                "content": "***Upvote if you like it*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int res = 0;\\n        int count = 0;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(0);\\n            }\\n            else{\\n                while(!st.empty() && st.top() != 0){\\n                    count += st.top(); // To calculate the inner brackets\\n                    st.pop();\\n                }\\n                count = max(2 * count , 1); // If () is the case\\n                st.pop();\\n                st.push(count);\\n                count = 0;\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            res += st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int res = 0;\\n        int count = 0;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(0);\\n            }\\n            else{\\n                while(!st.empty() && st.top() != 0){\\n                    count += st.top(); // To calculate the inner brackets\\n                    st.pop();\\n                }\\n                count = max(2 * count , 1); // If () is the case\\n                st.pop();\\n                st.push(count);\\n                count = 0;\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            res += st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858004,
                "title": "runtime-0ms-o-1-space-no-stack-used-java-100-faster-self-explanatory-code",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int two = 0;\\n        int sum = 0;\\n        boolean wasOpen = true;\\n        for(int i = 0; i< s.length(); i++){\\n           char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n              if(two == 0) two = 1;\\n                else two *= 2;\\n                wasOpen = true;\\n            }\\n            else{\\n                if(wasOpen) sum += two;\\n                wasOpen = false;\\n                two = two/2;\\n            }\\n        }\\n    return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public int scoreOfParentheses(String s) {\\n        int two = 0;\\n        int sum = 0;\\n        boolean wasOpen = true;\\n        for(int i = 0; i< s.length(); i++){\\n           char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n              if(two == 0) two = 1;\\n                else two *= 2;\\n                wasOpen = true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1857975,
                "title": "o-1-counting-open-paranthesis",
                "content": "We just find out the number of open paranthesis. There are only two cases:\\n1. `()` (paranthesis with no content inside) will contribute to answer by +1. for eg. ()()() = 3;\\n2.  `(()....())` (paranthesis with content inside) will contribute to answer by multiplying by 2;\\nThe depth of paranthesis will decide the power of 2 and the (inner) paranthesis with no content i.e. `s[i-1] == \\'(\\'` will contribute only and the outers will decide the power of 2.\\n\\ncode:\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int opens = 0;\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            char c = s[i];\\n            if (c == \\'(\\') \\n            {\\n                opens++;\\n            } else {\\n                if (s[i-1] == \\'(\\') ans += pow(2, opens-1);  // only applied for solo and the inner ones;\\n                opens--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int opens = 0;\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            char c = s[i];\\n            if (c == \\'(\\') \\n            {\\n                opens++;\\n            } else {\\n                if (s[i-1] == \\'(\\') ans += pow(2, opens-1);  // only applied for solo and the inner ones;\\n                opens--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857925,
                "title": "easy-c-solution-o-1-space-complexity-o-n-time-complexity-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n     int st = 0, score = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st++;\\n            }\\n            else if(s[i]==\\')\\' && s[i-1]==\\'(\\'){\\n               st--;\\n                score+=1<<st;\\n            }\\n            else st--;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n     int st = 0, score = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st++;\\n            }\\n            else if(s[i]==\\')\\' && s[i-1]==\\'(\\'){\\n               st--;\\n                score+=1<<st;\\n            }\\n            else st--;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857884,
                "title": "c-no-stack-100-99-9",
                "content": "```\\nint scoreOfParentheses(string s) {\\n        int ans = 0,two=1;\\n        for(int ind = 0;ind<s.size();ind++){\\n            if(s[ind]==\\'(\\'){\\n                two+=two;\\n            }\\n            else{\\n                two/=2;\\n                if(s[ind-1]==\\'(\\'){\\n                    ans+=two;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nWe keep track of the current depth with the \"two\" variable which we can calculate each time by doubling or halving the value.",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        int ans = 0,two=1;\\n        for(int ind = 0;ind<s.size();ind++){\\n            if(s[ind]==\\'(\\'){\\n                two+=two;\\n            }\\n            else{\\n                two/=2;\\n                if(s[ind-1]==\\'(\\'){\\n                    ans+=two;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1797276,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            },
            {
                "id": 1567739,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            },
            {
                "id": 1953309,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            },
            {
                "id": 1978296,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            },
            {
                "id": 2000809,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Number of Nice Subarrays",
        "question_content": "<p>Given an array of integers <code>nums</code> and an integer <code>k</code>. A continuous subarray is called <strong>nice</strong> if there are <code>k</code> odd numbers on it.</p>\r\n\r\n<p>Return <em>the number of <strong>nice</strong> sub-arrays</em>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,2,1,1], k = 3\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [2,4,6], k = 1\r\n<strong>Output:</strong> 0\r\n<strong>Explanation:</strong> There is no odd numbers in the array.\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [2,2,2,1,2,2,1,2,2,2], k = 2\r\n<strong>Output:</strong> 16\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= nums.length &lt;= 50000</code></li>\r\n\t<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>\r\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 419378,
                "title": "java-c-python-sliding-window-o-1-space",
                "content": "# **Solution 1: atMost**\\nHave you read this? [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\nExactly `K` times = at most `K` times - at most `K - 1` times\\n<br>\\n\\n# **Complexity**\\nTime `O(N)` for one pass\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int numberOfSubarrays(int[] A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n\\n    public int atMost(int[] A, int k) {\\n        int res = 0, i = 0, n = A.length;\\n        for (int j = 0; j < n; j++) {\\n            k -= A[j] % 2;\\n            while (k < 0)\\n                k += A[i++] % 2;\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n\\n    int atMost(vector<int>& A, int k) {\\n        int res = 0, i = 0, n = A.size();\\n        for (int j = 0; j < n; j++) {\\n            k -= A[j] % 2;\\n            while (k < 0)\\n                k += A[i++] % 2;\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def numberOfSubarrays(self, A, k):\\n        def atMost(k):\\n            res = i = 0\\n            for j in xrange(len(A)):\\n                k -= A[j] % 2\\n                while k < 0:\\n                    k += A[i] % 2\\n                    i += 1\\n                res += j - i + 1\\n            return res\\n\\n        return atMost(k) - atMost(k - 1)\\n```\\n<br><br>\\n\\n# Solution II: One pass\\n\\nActually it\\'s same as three pointers.\\nThough we use `count` to count the number of even numebers.\\nInsprired by @yannlecun.\\n\\nTime `O(N)` for one pass\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int numberOfSubarrays(int[] A, int k) {\\n        int res = 0, i = 0, count = 0, n = A.length;\\n        for (int j = 0; j < n; j++) {\\n            if (A[j] % 2 == 1) {\\n                --k;\\n                count = 0;\\n            }\\n            while (k == 0) {\\n                k += A[i++] & 1;\\n                ++count;\\n            }\\n            res += count;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int res = 0, i = 0, count = 0, n = A.size();\\n        for (int j = 0; j < n; j++) {\\n            if (A[j] & 1)\\n                --k, count = 0;\\n            while (k == 0)\\n                k += A[i++] & 1, ++count;\\n            res += count;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def numberOfSubarrays(self, A, k):\\n        i = count = res = 0\\n        for j in xrange(len(A)):\\n            if A[j] & 1:\\n                k -= 1\\n                count = 0\\n            while k == 0:\\n                k += A[i] & 1\\n                i += 1\\n                count += 1\\n            res += count\\n        return res\\n```\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/javacpython-sliding-window/379427?page=3)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public int numberOfSubarrays(int[] A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n\\n    public int atMost(int[] A, int k) {\\n        int res = 0, i = 0, n = A.length;\\n        for (int j = 0; j < n; j++) {\\n            k -= A[j] % 2;\\n            while (k < 0)\\n                k += A[i++] % 2;\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n\\n    int atMost(vector<int>& A, int k) {\\n        int res = 0, i = 0, n = A.size();\\n        for (int j = 0; j < n; j++) {\\n            k -= A[j] % 2;\\n            while (k < 0)\\n                k += A[i++] % 2;\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def numberOfSubarrays(self, A, k):\\n        def atMost(k):\\n            res = i = 0\\n            for j in xrange(len(A)):\\n                k -= A[j] % 2\\n                while k < 0:\\n                    k += A[i] % 2\\n                    i += 1\\n                res += j - i + 1\\n            return res\\n\\n        return atMost(k) - atMost(k - 1)\\n```\n```java\\n    public int numberOfSubarrays(int[] A, int k) {\\n        int res = 0, i = 0, count = 0, n = A.length;\\n        for (int j = 0; j < n; j++) {\\n            if (A[j] % 2 == 1) {\\n                --k;\\n                count = 0;\\n            }\\n            while (k == 0) {\\n                k += A[i++] & 1;\\n                ++count;\\n            }\\n            res += count;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int res = 0, i = 0, count = 0, n = A.size();\\n        for (int j = 0; j < n; j++) {\\n            if (A[j] & 1)\\n                --k, count = 0;\\n            while (k == 0)\\n                k += A[i++] & 1, ++count;\\n            res += count;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def numberOfSubarrays(self, A, k):\\n        i = count = res = 0\\n        for j in xrange(len(A)):\\n            if A[j] & 1:\\n                k -= 1\\n                count = 0\\n            while k == 0:\\n                k += A[i] & 1\\n                i += 1\\n                count += 1\\n            res += count\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 508217,
                "title": "c-visual-explanation-o-1-space-two-pointers",
                "content": "##### Algorithm\\nThe best way to explain this approach is to look at the example:\\nLet\\'s say **k = 2** and we have the following array:\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1582094442.png)\\n\\nWe only going to work with numbers `1` and `2` because we are only interested in if number is odd or even, we don\\'t care what the actual value is.\\n1. Using `i` iterate over the array counting **only odd** numbers:\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1582094637.png)\\n\\n2. When **odd** is equal to **k**, we can analyse our **left part** and count how many subarrays with **odd == k** we can produce.\\nWe are doing it with `j` iterating until we get to **odd number**.\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1582094795.png)\\n\\nWe can see that there are `3` subarrays we can produce with **odd == k**.\\n\\n3. Continue with `i` again. Since **odd >= k** then every next **even number** we meet is going to **double previous count**. Let\\'s see:\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1582095218.png)\\n\\n4. When we meet **odd number** again we need to reset `count=1` and repeat step (2) with `j` again. In our example there\\'s going to be only one subarray:\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1582095418.png)\\n\\n5. And finish with counting last **even number** as in step (3).\\n\\nSince we are reseting `count` variable to 0, we are adding sum of all subarrays in `total` variable.\\n\\n##### Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int j = 0, odd = 0, count = 0, total = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] & 1) {\\n                odd++;\\n                if (odd >= k) {\\n                    count = 1;\\n                    while (!(nums[j++] & 1)) count++;\\n                    total += count;\\n                }\\n            } else if (odd >= k) total += count;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int j = 0, odd = 0, count = 0, total = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] & 1) {\\n                odd++;\\n                if (odd >= k) {\\n                    count = 1;\\n                    while (!(nums[j++] & 1)) count++;\\n                    total += count;\\n                }\\n            } else if (odd >= k) total += count;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419545,
                "title": "deque-with-picture",
                "content": "#### Intuition\\nThis is similar to [992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C%2B%2BJava-with-picture-prefixed-sliding-window).\\n\\nWhen we find `k` odd numbers, we have one nice subarray, plus an additional subarray for each even number preceding the first odd number. This is also true for each even number that follows.\\n\\nFor example, in the picture below we found `k == 2` odd numbers at index `4`. We have 3 nice subarrays therefore: `[2, 4], [1, 4], [0, 4]`. For even number at index `5`, we also have 3 nice subarrays: `[2, 5], [1, 5], [0, 5]`. Plus 3 subarrays for index `6`.\\n\\nWhen we encounter `k + 1` odd number at index `7`, we need to get rid of the first odd number (at index `2`) to have exactly `k` odd numbers. So, we count nice subarrays as if the array starts at index `3`. \\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1572762880.png)\\n\\n#### Approach 1: Deque\\nWe do not have to use `deque`, but it makes tracking the window easier (comparing to moving pointers). Note that in Java, the deque interface does not provide a random access, so we\\'ll just use `LinkedList` instead.\\n\\n**Java**\\n```java\\npublic int numberOfSubarrays(int[] nums, int k) {\\n  LinkedList<Integer> deq = new LinkedList();\\n  deq.add(-1);\\n  int res = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    if (nums[i] % 2 == 1) \\n        deq.add(i);\\n    if (deq.size() > k + 1) \\n        deq.pop();\\n    if (deq.size() == k + 1) \\n        res += deq.get(1) - deq.get(0);\\n  }\\n  return res;\\n}\\n```\\n**C++**\\n```cpp\\nint numberOfSubarrays(vector<int>& nums, int k, int res = 0) {\\n  deque<int> deq = { -1 };\\n  for (int i = 0; i < nums.size(); ++i) {\\n    if (nums[i] % 2)\\n        deq.push_back(i);\\n    if (deq.size() > k + 1)\\n        deq.pop_front();\\n    if (deq.size() == k + 1)\\n        res += deq[1] - deq[0];\\n  }\\n  return res;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n).\\n- Memory: O(k) for the deque.",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int numberOfSubarrays(int[] nums, int k) {\\n  LinkedList<Integer> deq = new LinkedList();\\n  deq.add(-1);\\n  int res = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    if (nums[i] % 2 == 1) \\n        deq.add(i);\\n    if (deq.size() > k + 1) \\n        deq.pop();\\n    if (deq.size() == k + 1) \\n        res += deq.get(1) - deq.get(0);\\n  }\\n  return res;\\n}\\n```\n```cpp\\nint numberOfSubarrays(vector<int>& nums, int k, int res = 0) {\\n  deque<int> deq = { -1 };\\n  for (int i = 0; i < nums.size(); ++i) {\\n    if (nums[i] % 2)\\n        deq.push_back(i);\\n    if (deq.size() > k + 1)\\n        deq.pop_front();\\n    if (deq.size() == k + 1)\\n        res += deq[1] - deq[0];\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419483,
                "title": "subarray-sum-equals-k",
                "content": "If you transform the input array into binary, then the problem becomes the \\'Subarray Sum Equals K\\' problem. You can think of k odd numbers means sum of then is k.\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        const int n = nums.size();\\n        int rst = 0;\\n        int acc = 0;\\n        m[0] = 1;\\n        for (int i = 0; i < n; ++i) {\\n            acc += (nums[i]%2);\\n            rst += m[acc-k];\\n            m[acc]++;\\n        }\\n        return rst;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        const int n = nums.size();\\n        int rst = 0;\\n        int acc = 0;\\n        m[0] = 1;\\n        for (int i = 0; i < n; ++i) {\\n            acc += (nums[i]%2);\\n            rst += m[acc-k];\\n            m[acc]++;\\n        }\\n        return rst;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419502,
                "title": "java-prefixsum-1pass-10line-7ms",
                "content": "At index i, if current odd numbers from the beginning is M,\\nand we checked there was N previous index with (M - K) oddnum, then we got N subarrays\\nres += N\\n\\n\\n```\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int cur = 0, ans = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        for (int i = 0; i < nums.length; i++) {\\n            cur += nums[i] % 2 == 1 ? 1 : 0;\\n            map.put(cur, map.getOrDefault(cur, 0) + 1);\\n            ans += map.getOrDefault(cur - k, 0);\\n        }\\n        return ans;\\n    }\\n```\\n\\nArray version 7ms, faster then sliding window\\n```\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int cur = 0, ans = 0;\\n        int[] visited = new int[nums.length + 1];\\n        visited[0] = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            cur += nums[i] % 2 == 1 ? 1 : 0;\\n            visited[cur] += 1;\\n            ans += cur >= k ? visited[cur - k] : 0;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int cur = 0, ans = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        for (int i = 0; i < nums.length; i++) {\\n            cur += nums[i] % 2 == 1 ? 1 : 0;\\n            map.put(cur, map.getOrDefault(cur, 0) + 1);\\n            ans += map.getOrDefault(cur - k, 0);\\n        }\\n        return ans;\\n    }\\n```\n```\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int cur = 0, ans = 0;\\n        int[] visited = new int[nums.length + 1];\\n        visited[0] = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            cur += nums[i] % 2 == 1 ? 1 : 0;\\n            visited[cur] += 1;\\n            ans += cur >= k ? visited[cur - k] : 0;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419321,
                "title": "java-python-3-1-pass-sliding-window-o-n-time-o-1-space-w-brief-explanation",
                "content": "1. Whenever the count of odd numbers reach `k`, for each high boundary of the sliding window, we have `indexOfLeftMostOddInWin - lowBound` options for the low boundary, where `indexOfLeftMostOddInWin` is the index of the leftmost odd number within the window, and `lowBound` is the index of the low boundary exclusively;\\n2. Whenever the count of odd numbers more than `k`, shrink the low boundary so that the count back to `k`;\\n```java\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int ans = 0, indexOfLeftMostOddInWin = 0, lowBound = -1;\\n        for (int num : nums) {\\n            k -= num % 2;\\n            if (nums[indexOfLeftMostOddInWin] % 2 == 0) // move to the index of first odd.\\n                ++indexOfLeftMostOddInWin;\\n            if (k < 0) { // more than k odds in window, need to shrink from low bound.\\n                lowBound = indexOfLeftMostOddInWin; // update the low bound value.\\n            }\\n            while (k < 0) {\\n                k += nums[++indexOfLeftMostOddInWin] % 2; // move to the index of next odd.\\n            }\\n            if (k == 0) { // accumulated k odd numbers in window.\\n                ans += indexOfLeftMostOddInWin - lowBound; // update result.\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        low_bound, index_of_left_most_odd_in_win, ans = -1, 0, 0\\n        for num in nums:\\n            k -= num % 2\\n            if nums[index_of_left_most_odd_in_win] % 2 == 0:\\n                index_of_left_most_odd_in_win += 1\\n            if k < 0:\\n                low_bound = index_of_left_most_odd_in_win\\n            while k < 0:    \\n                index_of_left_most_odd_in_win += 1\\n                k += nums[index_of_left_most_odd_in_win] % 2\\n            if k == 0:\\n                ans += index_of_left_most_odd_in_win - low_bound\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int ans = 0, indexOfLeftMostOddInWin = 0, lowBound = -1;\\n        for (int num : nums) {\\n            k -= num % 2;\\n            if (nums[indexOfLeftMostOddInWin] % 2 == 0) // move to the index of first odd.\\n                ++indexOfLeftMostOddInWin;\\n            if (k < 0) { // more than k odds in window, need to shrink from low bound.\\n                lowBound = indexOfLeftMostOddInWin; // update the low bound value.\\n            }\\n            while (k < 0) {\\n                k += nums[++indexOfLeftMostOddInWin] % 2; // move to the index of next odd.\\n            }\\n            if (k == 0) { // accumulated k odd numbers in window.\\n                ans += indexOfLeftMostOddInWin - lowBound; // update result.\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        low_bound, index_of_left_most_odd_in_win, ans = -1, 0, 0\\n        for num in nums:\\n            k -= num % 2\\n            if nums[index_of_left_most_odd_in_win] % 2 == 0:\\n                index_of_left_most_odd_in_win += 1\\n            if k < 0:\\n                low_bound = index_of_left_most_odd_in_win\\n            while k < 0:    \\n                index_of_left_most_odd_in_win += 1\\n                k += nums[index_of_left_most_odd_in_win] % 2\\n            if k == 0:\\n                ans += index_of_left_most_odd_in_win - low_bound\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1265615,
                "title": "python-two-pointer",
                "content": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        right ,left = 0,0\\n        ans = 0 \\n        odd_cnt = 0\\n        ans = 0\\n        cur_sub_cnt = 0\\n        for right in range(len(nums)):\\n            \\n            if nums[right]%2 == 1:\\n                odd_cnt += 1\\n                cur_sub_cnt = 0\\n                \\n            while odd_cnt == k:\\n                if nums[left]%2 == 1:\\n                    odd_cnt -= 1\\n                cur_sub_cnt += 1\\n                left += 1\\n                \\n            ans += cur_sub_cnt\\n            \\n        return ans  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        right ,left = 0,0\\n        ans = 0 \\n        odd_cnt = 0\\n        ans = 0\\n        cur_sub_cnt = 0\\n        for right in range(len(nums)):\\n            \\n            if nums[right]%2 == 1:\\n                odd_cnt += 1\\n                cur_sub_cnt = 0\\n                \\n            while odd_cnt == k:\\n                if nums[left]%2 == 1:\\n                    odd_cnt -= 1\\n                cur_sub_cnt += 1\\n                left += 1\\n                \\n            ans += cur_sub_cnt\\n            \\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 419992,
                "title": "easy-peasy-python-solution-with-explanation",
                "content": "\\t# Just keep count of the current odd number.\\n\\t# Look in the dictionary if we can find (currendOds - k), \\n\\t# if it exisits that means I can get an subarray with k odds.\\n\\t# Also keep count of number of different types of odds too,\\n\\t# because for K =1 , [2,2,1] is a valid list, so does, [2,1] and [1].\\n\\t\\n        def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tdic = { 0: 1 }\\n\\t\\t\\tcnt = res = 0\\n\\t\\t\\tfor idx, num in enumerate(nums):\\n\\t\\t\\t\\tif num % 2 == 1:\\n\\t\\t\\t\\t\\tcnt += 1\\n\\n\\t\\t\\t\\tif cnt - k in dic:\\n\\t\\t\\t\\t\\tres += dic[cnt-k]\\n\\n\\t\\t\\t\\tdic[cnt] = dic.get(cnt, 0) + 1\\n\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# Just keep count of the current odd number.\\n\\t# Look in the dictionary if we can find (currendOds - k), \\n\\t# if it exisits that means I can get an subarray with k odds.\\n\\t# Also keep count of number of different types of odds too,\\n\\t# because for K =1 , [2,2,1] is a valid list, so does, [2,1] and [1].\\n\\t\\n        def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tdic = { 0: 1 }\\n\\t\\t\\tcnt = res = 0\\n\\t\\t\\tfor idx, num in enumerate(nums):\\n\\t\\t\\t\\tif num % 2 == 1:\\n\\t\\t\\t\\t\\tcnt += 1\\n\\n\\t\\t\\t\\tif cnt - k in dic:\\n\\t\\t\\t\\t\\tres += dic[cnt-k]\\n\\n\\t\\t\\t\\tdic[cnt] = dic.get(cnt, 0) + 1\\n\\n\\t\\t\\treturn res",
                "codeTag": "Python3"
            },
            {
                "id": 1315238,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int oddcount=0;\\n        int res=0;\\n        int i=0;\\n        int count=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]%2==1){\\n                oddcount++;\\n                count=0;\\n            }\\n            while(oddcount==k){\\n                if(nums[i++]%2==1) oddcount--;\\n                count++;\\n            }\\n            res+=count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int oddcount=0;\\n        int res=0;\\n        int i=0;\\n        int count=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]%2==1){\\n                oddcount++;\\n                count=0;\\n            }\\n            while(oddcount==k){\\n                if(nums[i++]%2==1) oddcount--;\\n                count++;\\n            }\\n            res+=count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478035,
                "title": "c-two-pointers-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0,odd = 0,cnt = 0;\\n        int l = 0,r = 0;\\n        while(r<n)\\n        {\\n            if(nums[r]%2 != 0)\\n            {\\n                odd++;\\n                cnt = 0;\\n            }\\n            while(odd == k)\\n            {\\n                ++cnt;\\n                odd -= nums[l++]&1; \\n            }\\n            ans += cnt;\\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# If you find my solution useful , then kindly upvote it.",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0,odd = 0,cnt = 0;\\n        int l = 0,r = 0;\\n        while(r<n)\\n        {\\n            if(nums[r]%2 != 0)\\n            {\\n                odd++;\\n                cnt = 0;\\n            }\\n            while(odd == k)\\n            {\\n                ++cnt;\\n                odd -= nums[l++]&1; \\n            }\\n            ans += cnt;\\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824621,
                "title": "c-sliding-window-solution-o-1-space",
                "content": "Similar to https://leetcode.com/problems/subarrays-with-k-different-integers/\\n```\\npublic:\\n    int numarr(vector<int>&nums,int k){\\n        int ans=0;\\n        int count=0;\\n        int i=0,j=0,n=nums.size();\\n        while(j<n){\\n            if(nums[j]%2==1){\\n                count++;\\n            }\\n            if(count>k){\\n                while(i<=j && count>k){\\n                    if(nums[i]%2==1){\\n                        count--;\\n                    }\\n                    i++;\\n                }\\n            }\\n            ans+=(j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return numarr(nums,k)-numarr(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    int numarr(vector<int>&nums,int k){\\n        int ans=0;\\n        int count=0;\\n        int i=0,j=0,n=nums.size();\\n        while(j<n){\\n            if(nums[j]%2==1){\\n                count++;\\n            }\\n            if(count>k){\\n                while(i<=j && count>k){\\n                    if(nums[i]%2==1){\\n                        count--;\\n                    }\\n                    i++;\\n                }\\n            }\\n            ans+=(j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return numarr(nums,k)-numarr(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560994,
                "title": "c-3-approaches-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        int result=0;\\n        int first_occur=0;\\n        vector<int>occur(nums.size(),0);\\n        int index=0;\\n        int current=0;\\n        // Variable window size problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation\\n            if(nums[j]%2!=0)\\n            {count++;\\n             occur[index++]=j;}\\n            // Play with condition\\n            if(count<k)\\n                j++;\\n            else\\n            {\\n              while(count>k)\\n              {\\n                  // remove calculation for i\\n                  if(nums[i]%2!=0)\\n                  {count--;current++;}\\n                  i++;\\n              }\\n                \\n                // Store result\\n                result+=occur[current]+1-i;\\n                j++;\\n            }\\n            \\n            \\n        }\\n        return result;\\n    }\\n};\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        // Replace all odd with 1 and even with 0\\n        for(auto &num:nums)\\n            if(num%2)\\n                num=1;\\n            else\\n                num=0;\\n        \\n        // Now find the subarray with sum at most k and k-1\\n        return atMost(nums,k)-atMost(nums,k-1);\\n    }\\n    int atMost(vector<int>&nums,int k)\\n    {\\n        int i=0;\\n        int j=0;\\n        int result=0;\\n        int sum=0;\\n        // Variable size window problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation\\n            sum+=nums[j];\\n            \\n           \\n                while(sum>k)\\n                {\\n                    // remove calculation for i\\n                    sum-=nums[i];\\n                    i++;\\n                }\\n                // store result\\n                result+=j-i+1;\\n                j++;\\n            \\n        }\\n        return result;\\n    }\\n};\\n\\nTime Complexity: O(3*n)\\nSpace Complexity: O(1)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        // Replace odd with 1 and even with 0\\n        for(auto &num:nums)\\n            if(num%2)\\n                num=1;\\n            else \\n                num=0;\\n        mp[0]=1;\\n        int sum=0;\\n        int count=0;\\n        for(auto num:nums)\\n        {\\n            sum+=num;\\n            count+=mp[sum-k];\\n            mp[sum]++;\\n        }\\n        return count;\\n    }\\n    \\n};\\n\\nTime Complexity: O(2*n)\\nSpace Complexity: O(n)\\n```\\n\\n***PLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELPFUL, MEANS A LOT ;)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        int result=0;\\n        int first_occur=0;\\n        vector<int>occur(nums.size(),0);\\n        int index=0;\\n        int current=0;\\n        // Variable window size problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation\\n            if(nums[j]%2!=0)\\n            {count++;\\n             occur[index++]=j;}\\n            // Play with condition\\n            if(count<k)\\n                j++;\\n            else\\n            {\\n              while(count>k)\\n              {\\n                  // remove calculation for i\\n                  if(nums[i]%2!=0)\\n                  {count--;current++;}\\n                  i++;\\n              }\\n                \\n                // Store result\\n                result+=occur[current]+1-i;\\n                j++;\\n            }\\n            \\n            \\n        }\\n        return result;\\n    }\\n};\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        // Replace all odd with 1 and even with 0\\n        for(auto &num:nums)\\n            if(num%2)\\n                num=1;\\n            else\\n                num=0;\\n        \\n        // Now find the subarray with sum at most k and k-1\\n        return atMost(nums,k)-atMost(nums,k-1);\\n    }\\n    int atMost(vector<int>&nums,int k)\\n    {\\n        int i=0;\\n        int j=0;\\n        int result=0;\\n        int sum=0;\\n        // Variable size window problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation\\n            sum+=nums[j];\\n            \\n           \\n                while(sum>k)\\n                {\\n                    // remove calculation for i\\n                    sum-=nums[i];\\n                    i++;\\n                }\\n                // store result\\n                result+=j-i+1;\\n                j++;\\n            \\n        }\\n        return result;\\n    }\\n};\\n\\nTime Complexity: O(3*n)\\nSpace Complexity: O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        // Replace odd with 1 and even with 0\\n        for(auto &num:nums)\\n            if(num%2)\\n                num=1;\\n            else \\n                num=0;\\n        mp[0]=1;\\n        int sum=0;\\n        int count=0;\\n        for(auto num:nums)\\n        {\\n            sum+=num;\\n            count+=mp[sum-k];\\n            mp[sum]++;\\n        }\\n        return count;\\n    }\\n    \\n};\\n\\nTime Complexity: O(2*n)\\nSpace Complexity: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500001,
                "title": "java-sliding-window-two-pinter",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int i=0;\\n        int j=0;\\n        int oddCount=0;\\n        int count=0;\\n        int temp=0;\\n        \\n        while(j<nums.length){\\n            if(nums[j]%2==1){\\n                oddCount++;\\n                temp=0;\\n            }\\n            while(oddCount==k){\\n                temp++;\\n                if(nums[i]%2==1){\\n                    oddCount--;\\n                }\\n                i++;\\n            }\\n            count+=temp;\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int i=0;\\n        int j=0;\\n        int oddCount=0;\\n        int count=0;\\n        int temp=0;\\n        \\n        while(j<nums.length){\\n            if(nums[j]%2==1){\\n                oddCount++;\\n                temp=0;\\n            }\\n            while(oddCount==k){\\n                temp++;\\n                if(nums[i]%2==1){\\n                    oddCount--;\\n                }\\n                i++;\\n            }\\n            count+=temp;\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600316,
                "title": "nice-subarrays-c-easy",
                "content": "//exactly similar to the problem:subarrays sum equal to given sum(k)\\n// we just need to convert odds with 1 and even with 0\\n//and find the given sub arrays having sum k\\nUPVOTE IF YOU GET:)\\n```\\nclass Solution {\\npublic:\\n    \\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        int ans=0,sum=0,n=a.size();\\n        map<int,int>mp;\\n        mp[0]=1;\\n        for(int i=0;i<n;i++){\\n            sum+=a[i]%2; // converting even with 0 & odd wiht 1;\\n            if(mp.find(sum-k)!=mp.end())\\n                ans+=mp[sum-k];\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        int ans=0,sum=0,n=a.size();\\n        map<int,int>mp;\\n        mp[0]=1;\\n        for(int i=0;i<n;i++){\\n            sum+=a[i]%2; // converting even with 0 & odd wiht 1;\\n            if(mp.find(sum-k)!=mp.end())\\n                ans+=mp[sum-k];\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331485,
                "title": "c-sliding-window-solution-probability-rule-o-n",
                "content": "Runtime: 112 ms, faster than 93.17% of C++ online submissions for Count Number of Nice Subarrays.\\nMemory Usage: 67.5 MB, less than 91.98% of C++ online submissions for Count Number of Nice Subarrays.\\n\\n```\\nInorder to solve the problem we can easily find the main subarray containing K odd numbers using Sliding\\nWindow approach. Here main subarray means the subarray which has window such as all left most values\\nof first odd number are even if possible and all right most values of last odd number are even if possible\\ncause there can be exactly K odd numbers and this main subarray will get the subarrays where all odd\\nnumbers of the window wil be present. So, we expand window in each step and shrink window if odd count >K. \\nWhen odd count == K, we have to find the main subarray and so we expand the window as long as there\\nis no new odd number. Now we need the possible subarrays from this main subarray where al odd numbers\\nwill be present. For calculating the number of such possible subarrays we can consider the subarry from the\\nfirst to last occurence of odd number as a single number X. Then we have to count the number of even\\nnumbers EL at the left of X and the number of even numbers ER at the right of X cause they will make the\\npossible subarrays from main subarray. \\nFor the current main subarray the possible subarray count = (EL +1) * (ER+1)\\n```\\n\\n```\\nThis equation comes from the Independent Probability Rule: P(AB) = P(A) * P(B)\\nFor example given array : [a,b,c,d,e] and X = c then the number of possible subarray where X exists are,\\nNo of way of taking or not taking element from the left of X = EL + 1\\nNo of way of taking or not taking element from the right of X = ER + 1\\nSo, total possible subarrays with element X = (EL + 1) * (ER + 1) cause here taking element from left and\\nright of element X in the subarray is Independent.\\nFor  [a,b,c,d,e] and X = c => Subarray count = (2+1) * (2+1) = 3\\n{a,b,c}, {b,c},{c}, {a,b,c,d},{b,c,d},{a,b,c,d,e},{b,c,d,e},{c,d},{c,d,e}\\n\\nSo using above formula we can count the total subarray from a main subarray and sum up the count of \\nall main subarrays in the given array and get the result.\\n\\nExample Input: nums = [2,2,1,2,1,2,2,1,2,2], k = 2,  Output: 15 Below is the simulation of this example\\n```\\n\\n![image](https://assets.leetcode.com/users/images/93861dec-986d-45f7-89e8-d79b938a0c7e_1626024085.1761098.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        // total number of calid subarray\\n        int res = 0;\\n        \\n        // count the odd numbers in the window\\n        int cnt = 0;\\n        \\n        // first and last pointer of sliding window\\n        int i = 0;\\n        int j = 0;\\n        while(j<n)\\n        {\\n            // update count of the odd number in window\\n            if((nums[j++]&1)==1)cnt++;            \\n            \\n            // shrink window until odd number count == k\\n            while(cnt>k)if((nums[i++]&1)==1)cnt--;      \\n            \\n            // if odd number count == k then we found our main subarray\\n            if(cnt==k)\\n            {\\n                int lc = 0, rc = 0;\\n                \\n                // shrink window from left till any odd number found\\n                // means, count number of even number at the left of first odd number in window, EL\\n                while(j<n && (nums[j]&1)==0)j++,rc++;\\n\\n                // expand window to right till any odd number found\\n                // means, count number of even number at the right of last odd number in window, ER\\n                while(i<n && (nums[i]&1)==0)i++,lc++;\\n                \\n                // based on probability formula the total possible subarray inclusing all odd numbers\\n                // of the main subarray window is (EL + 1) * (ER + 1)\\n                res+= ((lc+1) * (rc+1));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sliding Window",
                    "Probability and Statistics"
                ],
                "code": "```\\nInorder to solve the problem we can easily find the main subarray containing K odd numbers using Sliding\\nWindow approach. Here main subarray means the subarray which has window such as all left most values\\nof first odd number are even if possible and all right most values of last odd number are even if possible\\ncause there can be exactly K odd numbers and this main subarray will get the subarrays where all odd\\nnumbers of the window wil be present. So, we expand window in each step and shrink window if odd count >K. \\nWhen odd count == K, we have to find the main subarray and so we expand the window as long as there\\nis no new odd number. Now we need the possible subarrays from this main subarray where al odd numbers\\nwill be present. For calculating the number of such possible subarrays we can consider the subarry from the\\nfirst to last occurence of odd number as a single number X. Then we have to count the number of even\\nnumbers EL at the left of X and the number of even numbers ER at the right of X cause they will make the\\npossible subarrays from main subarray. \\nFor the current main subarray the possible subarray count = (EL +1) * (ER+1)\\n```\n```\\nThis equation comes from the Independent Probability Rule: P(AB) = P(A) * P(B)\\nFor example given array : [a,b,c,d,e] and X = c then the number of possible subarray where X exists are,\\nNo of way of taking or not taking element from the left of X = EL + 1\\nNo of way of taking or not taking element from the right of X = ER + 1\\nSo, total possible subarrays with element X = (EL + 1) * (ER + 1) cause here taking element from left and\\nright of element X in the subarray is Independent.\\nFor  [a,b,c,d,e] and X = c => Subarray count = (2+1) * (2+1) = 3\\n{a,b,c}, {b,c},{c}, {a,b,c,d},{b,c,d},{a,b,c,d,e},{b,c,d,e},{c,d},{c,d,e}\\n\\nSo using above formula we can count the total subarray from a main subarray and sum up the count of \\nall main subarrays in the given array and get the result.\\n\\nExample Input: nums = [2,2,1,2,1,2,2,1,2,2], k = 2,  Output: 15 Below is the simulation of this example\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        // total number of calid subarray\\n        int res = 0;\\n        \\n        // count the odd numbers in the window\\n        int cnt = 0;\\n        \\n        // first and last pointer of sliding window\\n        int i = 0;\\n        int j = 0;\\n        while(j<n)\\n        {\\n            // update count of the odd number in window\\n            if((nums[j++]&1)==1)cnt++;            \\n            \\n            // shrink window until odd number count == k\\n            while(cnt>k)if((nums[i++]&1)==1)cnt--;      \\n            \\n            // if odd number count == k then we found our main subarray\\n            if(cnt==k)\\n            {\\n                int lc = 0, rc = 0;\\n                \\n                // shrink window from left till any odd number found\\n                // means, count number of even number at the left of first odd number in window, EL\\n                while(j<n && (nums[j]&1)==0)j++,rc++;\\n\\n                // expand window to right till any odd number found\\n                // means, count number of even number at the right of last odd number in window, ER\\n                while(i<n && (nums[i]&1)==0)i++,lc++;\\n                \\n                // based on probability formula the total possible subarray inclusing all odd numbers\\n                // of the main subarray window is (EL + 1) * (ER + 1)\\n                res+= ((lc+1) * (rc+1));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832587,
                "title": "java-solution",
                "content": "Replace all odd numbers with 1 and even with zeroes\\n\\nNow the problem becomes\\n[https://leetcode.com/problems/subarray-sum-equals-k/](https://leetcode.com/problems/subarray-sum-equals-k/)\\n\\nFind number of sub arrys with sum = K\\n```\\npublic int numberOfSubarrays(int[] nums, int k) {\\n         //Replace all odd by 1 and even by 0\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = (nums[i] %2 == 0) ? 0 : 1;\\n        }\\n        \\n        //problem becomes number of subarrays with sum = k\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int res = 0;\\n        int sum = 0;//cumulative sum\\n        map.put(0,1);\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            if(map.containsKey(sum - k)){\\n                res+=map.get(sum - k);\\n            }\\n            map.put(sum,map.getOrDefault(sum,0)+1);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numberOfSubarrays(int[] nums, int k) {\\n         //Replace all odd by 1 and even by 0\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = (nums[i] %2 == 0) ? 0 : 1;\\n        }\\n        \\n        //problem becomes number of subarrays with sum = k\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int res = 0;\\n        int sum = 0;//cumulative sum\\n        map.put(0,1);\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            if(map.containsKey(sum - k)){\\n                res+=map.get(sum - k);\\n            }\\n            map.put(sum,map.getOrDefault(sum,0)+1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419362,
                "title": "python-solution-prefix-sum",
                "content": "```\\ndef numberOfSubarrays(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        count = 0\\n        prefix = {}\\n        prefix[0] = 1\\n        for i in range(len(nums)):\\n            \\n            if nums[i] % 2 != 0:\\n                count += 1\\n            if count in prefix:\\n                prefix[count] += 1\\n            else: \\n                prefix[count] = 1\\n\\t\"\"\"the key of prefix represent the number of odd number untill  certain position, the value represent the number of positions\"\"\"\\n        \\n        for c in prefix:\\n            if c - k in prefix:\\n                res += prefix[c] *prefix[c - k]\\n        return res\\n ```",
                "solutionTags": [],
                "code": "```\\ndef numberOfSubarrays(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        count = 0\\n        prefix = {}\\n        prefix[0] = 1\\n        for i in range(len(nums)):\\n            \\n            if nums[i] % 2 != 0:\\n                count += 1\\n            if count in prefix:\\n                prefix[count] += 1\\n            else: \\n                prefix[count] = 1\\n\\t\"\"\"the key of prefix represent the number of odd number untill  certain position, the value represent the number of positions\"\"\"\\n        \\n        for c in prefix:\\n            if c - k in prefix:\\n                res += prefix[c] *prefix[c - k]\\n        return res\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 3405192,
                "title": "c-sliding-window-with-explaination-easy-to-understand",
                "content": "# Intuition:\\r\\nThe problem requires finding the number of subarrays having exactly k odd integers. We can solve the problem using sliding window technique where we maintain a window of contiguous subarray and slide it from left to right. While sliding the window, we keep track of the number of odd integers inside the window and count the number of subarrays having exactly k odd integers.\\r\\n\\r\\n# Approach:\\r\\nWe initialize two pointers, start and end, to the first element of the array. We also initialize count to zero and ans to zero. We then traverse the array using the end pointer and for each element, we increment count if it is odd. We then slide the window to the right until count becomes equal to k. At each step, we update ans with the number of subarrays having exactly k odd integers. Finally, we return ans.\\r\\n\\r\\nTo find the number of subarrays having exactly k odd integers, we subtract the number of subarrays having less than k odd integers from the number of subarrays having at most k-1 odd integers. We can reuse the same subArray function to compute both.\\r\\n\\r\\n# Complexity:\\r\\n- Time complexity: O(n), where n is the size of the array. We traverse the array only once.\\r\\n- Space complexity: O(1), as we use constant extra space.\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int subArray(vector<int>& nums, int k) {\\r\\n        int count = 0, ans = 0, start = 0, end = 0;\\r\\n        int n = nums.size();\\r\\n        while(end<n){\\r\\n            if(nums[end]%2==1){\\r\\n                count++;\\r\\n            }\\r\\n            while(count>k){\\r\\n                if(nums[start]%2==1){\\r\\n                    count--;\\r\\n                }\\r\\n                start++;\\r\\n            }\\r\\n            ans += end-start+1;\\r\\n            end++;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n      return subArray(nums, k) - subArray(nums, k - 1);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int subArray(vector<int>& nums, int k) {\\r\\n        int count = 0, ans = 0, start = 0, end = 0;\\r\\n        int n = nums.size();\\r\\n        while(end<n){\\r\\n            if(nums[end]%2==1){\\r\\n                count++;\\r\\n            }\\r\\n            while(count>k){\\r\\n                if(nums[start]%2==1){\\r\\n                    count--;\\r\\n                }\\r\\n                start++;\\r\\n            }\\r\\n            ans += end-start+1;\\r\\n            end++;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n      return subArray(nums, k) - subArray(nums, k - 1);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567466,
                "title": "easiest-best-code-in-c-with-explanation-hashmap",
                "content": "**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int size=nums.size(),i=0,j=0;\\n        for(auto &it:nums){\\n            if((it & 1)==0)\\n                it=0;\\n            else           //Replacing all the even nos. with 0 & odd nos. with 1 \\n                it=1;\\n        }\\n       //Now simply to get the ans we have to return the no of subarrays with sum = k\\n        unordered_map<int,int> mp;\\n        int prefixSum=0,ans=0;\\n        for(auto it:nums){\\n            prefixSum+=it;\\n            if(prefixSum==k)\\n                ans++;\\n            if(mp.find(prefixSum-k)!=mp.end())\\n                ans+=mp[prefixSum-k];\\n            mp[prefixSum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Happy LeetCoding\\uD83D\\uDCAF\\nPlease Upvote**\\uD83D\\uDE42",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int size=nums.size(),i=0,j=0;\\n        for(auto &it:nums){\\n            if((it & 1)==0)\\n                it=0;\\n            else           //Replacing all the even nos. with 0 & odd nos. with 1 \\n                it=1;\\n        }\\n       //Now simply to get the ans we have to return the no of subarrays with sum = k\\n        unordered_map<int,int> mp;\\n        int prefixSum=0,ans=0;\\n        for(auto it:nums){\\n            prefixSum+=it;\\n            if(prefixSum==k)\\n                ans++;\\n            if(mp.find(prefixSum-k)!=mp.end())\\n                ans+=mp[prefixSum-k];\\n            mp[prefixSum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768342,
                "title": "c-sliding-window-two-pointers-o-n-space",
                "content": "This question is slightly based on sliding window, however one needs proper idea of whats going on.\\nWe actually just need to maintain the condition of (Oddnumbers==k), once we get it equal.\\nTill the time our odd number count is less than k, we just simply keep updating **\"end\"**.\\nOnce our oddnum count is equal to k, we start increamenting **\"start\"**, till the time we reach an odd number(this actually gives us the number of nice subarrays till that end point, let it be **\"cnt\"**).\\nAfter this , we continue our quest till we get our (k+1)th odd number but before that each even number means that we again have cnt number of nice subarrays possible so we keep updating total.\\nOnce we get an odd number , we increament **\"start\"**, reduce oddnumber count by 2(because we do not increament end , so just reducing count by 1 would lead us to take the new odd number more than once and an infinte loop would start).\\nSo , like this the process continues.\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int start=0,end=0;\\n        int count=0, total=0, cnt=0;\\n        while(end<nums.size())\\n        {\\n            if(nums[end]%2!=0)\\n                count++;\\n            if(nums[end]%2==0 && count==k)\\n               { total+=cnt;end++;continue;}\\n            if(count<k)\\n                end++;\\n            else if(count==k)\\n            {\\n             while(count==k)\\n             {\\n                 cnt++;\\n                 if(nums[start]%2==0)\\n                 {start++;continue;}\\n                 else\\n                 {break;}\\n                 \\n             }\\n                total+=cnt;\\n                \\n                end++;\\n            }\\n            else if(count>k)\\n            {\\n                start++;\\n                cnt=0;\\n                count-=2;\\n               \\n               \\n                \\n            }\\n         \\n        }\\n        return total;\\n    }\\n};\\n\\n```\\nThis is the code !!\\nPlease upvote if you find it even slightly helpful !! : )\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int start=0,end=0;\\n        int count=0, total=0, cnt=0;\\n        while(end<nums.size())\\n        {\\n            if(nums[end]%2!=0)\\n                count++;\\n            if(nums[end]%2==0 && count==k)\\n               { total+=cnt;end++;continue;}\\n            if(count<k)\\n                end++;\\n            else if(count==k)\\n            {\\n             while(count==k)\\n             {\\n                 cnt++;\\n                 if(nums[start]%2==0)\\n                 {start++;continue;}\\n                 else\\n                 {break;}\\n                 \\n             }\\n                total+=cnt;\\n                \\n                end++;\\n            }\\n            else if(count>k)\\n            {\\n                start++;\\n                cnt=0;\\n                count-=2;\\n               \\n               \\n                \\n            }\\n         \\n        }\\n        return total;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532109,
                "title": "java-picture-detail-explanation-prefix-sum-hashmap-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/27b0cd6e-ffd3-4eca-8787-6b8d0b15b43f_1634763142.2267573.png)\\n\\n* In this problem , First we will change the odd digit from 1 and even with zero in given array.\\n* then we use the same approach which we used in the leetcode problem 560. If you want detail explanation then ->\\nHere is the link of the problem \\n[https://leetcode.com/problems/subarray-sum-equals-k/discuss/1532102/java-picture-explanation-2-methods-prefix-sum-hashmap-easy-solution]\\n\\n```\\n  public int numberOfSubarrays(int[] nums, int k) {\\n   \\n     int s=0,e=nums.length;\\n   \\n    for(int i=0;i<e;i++){\\n        if(nums[i]%2!=0){\\n            nums[i]=1;\\n        }else{\\n            nums[i]=0;\\n        }\\n    }\\n      \\n       Map<Integer,Integer> p = new HashMap();\\n        \\n     p.put(0,1);   \\nint ans=0,sum=0;\\n        \\n     for(int i=0;i<nums.length;i++){\\n         sum+=nums[i];\\n        if(p.containsKey(sum-k)){\\n            ans+=p.get(sum-k);\\n        } \\n         p.put(sum,p.getOrDefault(sum,0)+1);\\n     }   \\n       return ans; \\n        \\n    }\\n```\\n\\nif you like it , then please upvote it",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\n  public int numberOfSubarrays(int[] nums, int k) {\\n   \\n     int s=0,e=nums.length;\\n   \\n    for(int i=0;i<e;i++){\\n        if(nums[i]%2!=0){\\n            nums[i]=1;\\n        }else{\\n            nums[i]=0;\\n        }\\n    }\\n      \\n       Map<Integer,Integer> p = new HashMap();\\n        \\n     p.put(0,1);   \\nint ans=0,sum=0;\\n        \\n     for(int i=0;i<nums.length;i++){\\n         sum+=nums[i];\\n        if(p.containsKey(sum-k)){\\n            ans+=p.get(sum-k);\\n        } \\n         p.put(sum,p.getOrDefault(sum,0)+1);\\n     }   \\n       return ans; \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419414,
                "title": "c-o-n-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        vector<int> prefixSum(nums.size());\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if (nums[i] % 2 == 1){\\n                prefixSum[i] = 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            prefixSum[i] += prefixSum[i - 1];\\n        }\\n        \\n        unordered_map<int,int> map;\\n        \\n        map[0] = 1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if (prefixSum[i] - k >= 0){\\n                ans += map[prefixSum[i] - k];\\n            }\\n            map[prefixSum[i]]++;\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        vector<int> prefixSum(nums.size());\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if (nums[i] % 2 == 1){\\n                prefixSum[i] = 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i < nums.size(); i++){\\n            prefixSum[i] += prefixSum[i - 1];\\n        }\\n        \\n        unordered_map<int,int> map;\\n        \\n        map[0] = 1;\\n        \\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if (prefixSum[i] - k >= 0){\\n                ans += map[prefixSum[i] - k];\\n            }\\n            map[prefixSum[i]]++;\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575910,
                "title": "python-2-sliding-window-solutions",
                "content": "\\n# **APPROACH 1- NOT O(1) SPACE**\\n\\nThere are some things to take care of in this problem. We cannot simply consider one window to be valid and just increment count by 1.\\n\\nConsider this ->\\n\\n\\t\\tnums = [2,2,2,1,2,2,1,2,2,2] and k = 2\\n\\t\\t\\t\\t0 1 2 3 4 5 6 7 8 9\\n\\t\\t\\nSo, if we use the sliding window approach, then we will start from index 0 and until the count of odd numbers does not become k, we will keep increasing window size. Now just by looking at the array you will see that when index is  6 then it will have two odd numbers from 0th index to 6th index.\\n\\nSo we will have a valid window with k odd numbers -\\n\\n\\t\\t\\t[2,2,2,1,2,2,1]\\n\\nBut, at this moment, we cannot simply do count += 1. Just think about it. If [2,2,2,1,2,2,1] is a valid subarray with k odd numbers, then how many subarrays of this are also valid?\\n\\n\\tThese are all valid subarrays with k odd numbers\\n\\t[2,2,2,1,2,2,1]\\n\\t[2,2,1,2,2,1]\\n\\t[2,1,2,2,1]\\n\\t[1,2,2,1]\\n\\t\\nThis means, we cannot do count += 1 only. We have to check for a particular nice subarray, how many total nice subarrays are possible.\\n\\nAnd to find that, just see above what is the smallest possible subarray. It is [1,2,2,1]. Why we were not able to get more subarrays smaller than it? Because we would\\'ve lost one odd number and that would\\'ve violated the condition of k odd numbers.\\n\\nSo this means, just see how many numbers are there between the beginning of the window and the first odd number in the window i.e., the leftmost odd number.\\n\\nFinally, we will get a general formula as \\n\\t\\n\\t\\t(index of leftmost odd number in current window - index of beginning of window) + 1\\n\\t\\t\\nSo basically, we want to keep track of not just the odd numbers but also their indices. \\n\\nAnd so I used a queue here to keep all the indices in it from left to right as we encounter odd numbers so that to calculate the count, we can simply get the first item in the queue as that will always be the leftmost odd number index of current window.\\n\\nAnd as we shrink the window, we will keep checking if the item we are removing from window is an odd number or not. If yes, that means we need to remove the leftmost item from queue as well. \\n\\n\\n```\\ndef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        subarrayCount = 0\\n        \\n        i,j = 0,0\\n\\n        queue = deque()\\n        \\n\\n        while( j < len(nums) ):\\n            # If we encounter an odd number push the index of this odd number to queue\\n            if(nums[j] % 2 != 0): queue.append(j)\\n            \\n            #If the number of odd numbers in this window exceeds k, then shrink the window from left until the count of odds is not greater than k\\n            if(len(queue) > k):\\n                while(len(queue) > k):\\n                    #If the number at ith index is odd, that means we have to remove this odd number\\'s index from queue\\n                    if(nums[i] % 2 != 0): queue.popleft()\\n                    #Shrink the window from left by incrementing i\\n                    i += 1\\n            \\n            # If number of odd numbers in current window = k\\n            # Then total subarrays we can get out of this current window with k odd numbers => (leftmost odd number index - starting of window + 1)\\n            if(len(queue) == k): subarrayCount += queue[0] - i + 1\\n            \\n            #Increase window size from right side\\n            j += 1\\n            \\n        \\n        return subarrayCount\\n```\\n\\n# **APPROACH 2 - O(1) SPACE**\\nJust remember one thing for such problems where we have to find how many subarrays have \"exactly\" K something. \\n\\n\\tSubarrays with K something = Subarrays with at most K something - Subarrays with at most K-1 something\\n\\t\\nAt most K means that a subarray should have something <= K. \\n\\t\\nFor this problem, since we have to find subarrays with exactly K odd numbers. That means, \\n\\t\\n\\tSubarrays with exactly K odd numbers  = Subarrays with at most K odd numbers  - Subarrays with at most K-1 odd numbers\\n\\t\\nLet me prove it with an example.\\n\\n\\t\\tnums = [1,1,2,1,1], k = 3\\n\\t\\t\\nSo here, what are the subarrays with <= 3 odd number ? i.e., how many subarrays have at most 3 odd numbers?\\n\\n\\t[1], [1, 1], [1], [1, 1, 2], [1, 2], [2], [1, 1, 2, 1], [1, 2, 1], [2, 1], [1], [1, 2, 1, 1], [2, 1, 1], [1, 1], [1] => 14 Subarrays\\n\\nNow, lets see how many subarrays have <= 2 odd numbers i.e., <= K- 1 odd numbers\\n\\t\\n\\t[1], [1, 1], [1], [1, 1, 2], [1, 2], [2],  [1, 2, 1], [2, 1], [1], [2, 1, 1], [1, 1], [1] => 12 Subarrays\\n\\t\\nSo that means, Subarrays with exactly 3 odd numbers are => 14 - 12 => 2\\n\\nAnd to prove this, here are all the subarrays with exactly 3 odd numbers\\n\\t\\n\\t\\t[1,1,2,1] and [1,2,1,1].\\n\\t\\t\\nAnd these are the only ones that are not in the list of subarrays with <= 2 odd numbers. \\n\\nYou can use this template in many similar problems where we are asked to find how many subarrays have exactly K sum, exactly K odd numbers and so on. And there is little to no change you have to make which makes this solution so damn useful.\\n\\n```\\nclass Solution:\\n    \\n    def atMost(self, nums: List[int], k: int) -> int:\\n        \\n        countOfSubarrays = 0\\n        \\n        i,j = 0,0\\n        n = len(nums)\\n        \\n        countOfOdds = 0\\n        \\n        while j < n:\\n            if nums[j] % 2 != 0 : countOfOdds += 1\\n                \\n            if countOfOdds > k:\\n                while countOfOdds > k:\\n                    if nums[i] % 2 != 0: countOfOdds -= 1\\n                    i += 1\\n            \\n            countOfSubarrays += j - i + 1\\n            j += 1\\n        \\n        return countOfSubarrays\\n        \\n    \\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        return self.atMost(nums, k) - self.atMost(nums, k-1)\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\ndef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        subarrayCount = 0\\n        \\n        i,j = 0,0\\n\\n        queue = deque()\\n        \\n\\n        while( j < len(nums) ):\\n            # If we encounter an odd number push the index of this odd number to queue\\n            if(nums[j] % 2 != 0): queue.append(j)\\n            \\n            #If the number of odd numbers in this window exceeds k, then shrink the window from left until the count of odds is not greater than k\\n            if(len(queue) > k):\\n                while(len(queue) > k):\\n                    #If the number at ith index is odd, that means we have to remove this odd number\\'s index from queue\\n                    if(nums[i] % 2 != 0): queue.popleft()\\n                    #Shrink the window from left by incrementing i\\n                    i += 1\\n            \\n            # If number of odd numbers in current window = k\\n            # Then total subarrays we can get out of this current window with k odd numbers => (leftmost odd number index - starting of window + 1)\\n            if(len(queue) == k): subarrayCount += queue[0] - i + 1\\n            \\n            #Increase window size from right side\\n            j += 1\\n            \\n        \\n        return subarrayCount\\n```\n```\\nclass Solution:\\n    \\n    def atMost(self, nums: List[int], k: int) -> int:\\n        \\n        countOfSubarrays = 0\\n        \\n        i,j = 0,0\\n        n = len(nums)\\n        \\n        countOfOdds = 0\\n        \\n        while j < n:\\n            if nums[j] % 2 != 0 : countOfOdds += 1\\n                \\n            if countOfOdds > k:\\n                while countOfOdds > k:\\n                    if nums[i] % 2 != 0: countOfOdds -= 1\\n                    i += 1\\n            \\n            countOfSubarrays += j - i + 1\\n            j += 1\\n        \\n        return countOfSubarrays\\n        \\n    \\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        return self.atMost(nums, k) - self.atMost(nums, k-1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515501,
                "title": "c-prefix-state-map-two-pointers-sliding-window",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Prefix State Map\\n\\nUse a map `m` to store the mapping from the count of odd numbers `cnt` to the first index in the array that has `cnt` numbers in front of it and including itself.\\n\\nWhen `cnt >= k`, we add `m[cnt - k + 1] - m[cnt - k]` to the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int N = A.size(), cnt = 0, ans = 0;\\n        unordered_map<int, int> m{{0,-1}};\\n        for (int i = 0; i < N; ++i) {\\n            cnt += A[i] % 2;\\n            if (m.count(cnt) == 0) m[cnt] = i;\\n            if (cnt >= k) ans += m[cnt - k + 1] - m[cnt - k]; \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Two Pointers\\n\\nAssume the current pointer is `j` and the corresponding odd number count is `cj`, we need two pointers to get the answer.\\n\\nThe first pointer `i` is the index whose corresponding odd number count is `cj - k + 1`.\\n\\nThe second pointer `prev` is the index whose corresponding odd number count is `cj - k`.\\n\\nSo when `cj >= k`, we add `i - prev` to the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int N = A.size(), i = 0, j = 0, prev = -1, ans = 0, ci = 0, cj = 0;\\n        while (j < N) {\\n            cj += A[j++] % 2;\\n            if (ci <= cj - k) {\\n                prev = i;\\n                while (ci <= cj - k) ci += A[i++] % 2;\\n            }\\n            if (cj >= k) ans += i - prev;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nOr use a single count.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int N = A.size(), i = 0, j = 0, prev = -1, ans = 0, cnt = 0;\\n        while (j < N) {\\n            int c = A[j++] % 2;\\n            cnt += c;\\n            if (c && cnt >= k) {\\n                prev = i;\\n                while (A[i] % 2 == 0) ++i;\\n                ++i;\\n            }\\n            if (cnt >= k) ans += i - prev;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 3. AtMost to Equal\\n\\nCheck out \"[C++ Maximum Sliding Window Cheatsheet Template!](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!)\"\\n\\nExactly `k` times = At Most `k` times - At Most `k - 1` times.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\n// Ref: https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-O(1)-Space\\nclass Solution {\\n    int atMost(vector<int> &A, int k) {\\n        int N = A.size(), i = 0, ans = 0;\\n        for (int j = 0; j < N; ++j) {\\n            k -= A[j] % 2;\\n            while (k < 0) k += A[i++] % 2;\\n            ans += j - i;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int N = A.size(), cnt = 0, ans = 0;\\n        unordered_map<int, int> m{{0,-1}};\\n        for (int i = 0; i < N; ++i) {\\n            cnt += A[i] % 2;\\n            if (m.count(cnt) == 0) m[cnt] = i;\\n            if (cnt >= k) ans += m[cnt - k + 1] - m[cnt - k]; \\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int N = A.size(), i = 0, j = 0, prev = -1, ans = 0, ci = 0, cj = 0;\\n        while (j < N) {\\n            cj += A[j++] % 2;\\n            if (ci <= cj - k) {\\n                prev = i;\\n                while (ci <= cj - k) ci += A[i++] % 2;\\n            }\\n            if (cj >= k) ans += i - prev;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        int N = A.size(), i = 0, j = 0, prev = -1, ans = 0, cnt = 0;\\n        while (j < N) {\\n            int c = A[j++] % 2;\\n            cnt += c;\\n            if (c && cnt >= k) {\\n                prev = i;\\n                while (A[i] % 2 == 0) ++i;\\n                ++i;\\n            }\\n            if (cnt >= k) ans += i - prev;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-number-of-nice-subarrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\n// Ref: https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-O(1)-Space\\nclass Solution {\\n    int atMost(vector<int> &A, int k) {\\n        int N = A.size(), i = 0, ans = 0;\\n        for (int j = 0; j < N; ++j) {\\n            k -= A[j] % 2;\\n            while (k < 0) k += A[i++] % 2;\\n            ans += j - i;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        return atMost(A, k) - atMost(A, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619352,
                "title": "java-solution-current-problem-transformed-to-problem-560-hashmap",
                "content": "#### *Please Upvote !!!* **(\\u25E0\\u203F\\u25E0)**\\nWe traverse the whole array and put 0 in place of even elements and 1 in place of odd elements. \\nSo instead of finding k odd numbers, we now find subarrays whose sum will be equal to k (Because the odd numbers are all 1 and k odd numbers will give a sum of k now).\\n\\nThis takes us to the problem [**560. Subarray Sum Equals K**](https://leetcode.com/problems/subarray-sum-equals-k/).\\n\\nWe can put 0s and 1s in place of even and odd number by simply iterating through the array. \\n```\\nfor (int i = 0; i < nums.length; i++) {\\n\\tnums[i] = (nums[i] % 2 == 0) ? 0 : 1;\\n}\\n```\\nBut that would take an extra O(n) time complexity. \\n\\nSo we won\\'t do that. In Problem 560, we add ```nums[i]``` to ```sum``` at each iteration. So why not decide there itself whether to add 0 or 1 to sum!\\n\\nBelow is the solution, exactly similar to Problem 560.\\n```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int total = 0, sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += (nums[i] % 2 == 0) ? 0 : 1;\\n            int rem = sum - k;\\n\\n            if (map.containsKey(rem)) {\\n                total += map.get(rem);\\n            }\\n\\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n\\n        return total;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nfor (int i = 0; i < nums.length; i++) {\\n\\tnums[i] = (nums[i] % 2 == 0) ? 0 : 1;\\n}\\n```\n```nums[i]```\n```sum```\n```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int total = 0, sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += (nums[i] % 2 == 0) ? 0 : 1;\\n            int rem = sum - k;\\n\\n            if (map.containsKey(rem)) {\\n                total += map.get(rem);\\n            }\\n\\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n\\n        return total;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600712,
                "title": "python-easy-prefix-sum-solution",
                "content": "Hi guys,\\n\\nHere is a simple solution using the prefix sum of an array where each element is equal to 1 if nums[i]%2==1 and 0 if nums[i]%2==0. \\n\\nWe initialize the dictionary so that we take into account the arrays with k odd numbers starting at index 0.\\n\\n\\t\\tpref=list(accumulate([0 if num%2==0 else 1 for num in nums]))\\n        dico=defaultdict(int)\\n        res=0\\n        dico[0]=1\\n        for num in pref:\\n            if num-k in dico:\\n                res+=dico[num-k]\\n            dico[num]+=1\\n        return res\\n\\t\\t\\nThen if pref[i]==j it means we have j odd numbers from index 0 to index j. Hence if j-k is in our hash table, it means that for dico[j-k] indices, we had j-k odd numbers. So between these indices and index i, we have a total k odd numbers : j-(j-k)=k.\\n\\nPlease upvote if you liked!\\n\\nCheers,\\nBerthouille",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "Hi guys,\\n\\nHere is a simple solution using the prefix sum of an array where each element is equal to 1 if nums[i]%2==1 and 0 if nums[i]%2==0. \\n\\nWe initialize the dictionary so that we take into account the arrays with k odd numbers starting at index 0.\\n\\n\\t\\tpref=list(accumulate([0 if num%2==0 else 1 for num in nums]))\\n        dico=defaultdict(int)\\n        res=0\\n        dico[0]=1\\n        for num in pref:\\n            if num-k in dico:\\n                res+=dico[num-k]\\n            dico[num]+=1\\n        return res\\n\\t\\t\\nThen if pref[i]==j it means we have j odd numbers from index 0 to index j. Hence if j-k is in our hash table, it means that for dico[j-k] indices, we had j-k odd numbers. So between these indices and index i, we have a total k odd numbers : j-(j-k)=k.\\n\\nPlease upvote if you liked!\\n\\nCheers,\\nBerthouille",
                "codeTag": "Unknown"
            },
            {
                "id": 1487672,
                "title": "c-sliding-window",
                "content": "**Exactly = atMostK(k) - atMostK(k-1)**\\n```\\nint atMostK(vector<int>& a, int k) {\\n        int i=0,count = 0,res =0;\\n        for(int j=0;j<a.size();j++){\\n            if(a[j]%2==1) count++;\\n            if(count > k){\\n                while(count>k){\\n                    if(a[i]%2==1) count--;\\n                    i++;\\n                }\\n            }\\n            res += j-i+1;\\n        }\\n        return res;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        return atMostK(a,k) - atMostK(a,k-1);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint atMostK(vector<int>& a, int k) {\\n        int i=0,count = 0,res =0;\\n        for(int j=0;j<a.size();j++){\\n            if(a[j]%2==1) count++;\\n            if(count > k){\\n                while(count>k){\\n                    if(a[i]%2==1) count--;\\n                    i++;\\n                }\\n            }\\n            res += j-i+1;\\n        }\\n        return res;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        return atMostK(a,k) - atMostK(a,k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350447,
                "title": "c-two-pointer-o-n-solution",
                "content": "For finding a subarray with **exactly k odd elements = count(subarray with at most k odd elements) - count(subarray with at most k-1 odd elements)**. This solution consists of passing through the arrays twice (once for k odd elements and once for k-1 odd elements)\\n\\n```\\nclass Solution {\\n    \\n    int atMostK(vector<int> &nums, int k){\\n        \\n        int len = nums.size();\\n        int result = 0;\\n        int start = 0;\\n        int currOddCnt = 0;\\n        \\n        for(int end=0; end<len; end++){\\n            //if the current element is odd\\n            if(nums[end]&1) currOddCnt++;\\n            \\n            //if the number of odd elements in the window exceeds k -> start contarcting the window\\n            while(start<=end && currOddCnt>k){\\n                //reducing the count of odd numbers if the start of window is odd\\n                if(nums[start]&1) currOddCnt--;\\n                start++;\\n            }\\n            \\n            //number of subarrays with at most k odd elements\\n            result += end-start+1;\\n        }\\n        \\n        return result;\\n    }\\n    \\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return atMostK(nums, k) - atMostK(nums, k-1);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int atMostK(vector<int> &nums, int k){\\n        \\n        int len = nums.size();\\n        int result = 0;\\n        int start = 0;\\n        int currOddCnt = 0;\\n        \\n        for(int end=0; end<len; end++){\\n            //if the current element is odd\\n            if(nums[end]&1) currOddCnt++;\\n            \\n            //if the number of odd elements in the window exceeds k -> start contarcting the window\\n            while(start<=end && currOddCnt>k){\\n                //reducing the count of odd numbers if the start of window is odd\\n                if(nums[start]&1) currOddCnt--;\\n                start++;\\n            }\\n            \\n            //number of subarrays with at most k odd elements\\n            result += end-start+1;\\n        }\\n        \\n        return result;\\n    }\\n    \\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return atMostK(nums, k) - atMostK(nums, k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707970,
                "title": "easy-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nConsider the window with k prime numbers, the number of evens on either side are variables, Maintain evens on left and right of every odd numbers, ans is sum of (evens on left of first number + 1 * evens on right of last number + 1). \\r\\n\\r\\n![lc.jpg](https://assets.leetcode.com/users/images/28f2ce74-3258-44e1-b592-a785dd278d4c_1688292738.8399723.jpeg)\\r\\n\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nStore the evens on left of every number in a vector and evens on the right of last element in last. Slide a window of size k , add (s[i]+1 * s[i+k]+1 ) to the sum. \\r\\n\\r\\n# Complexity\\r\\n- Time complexity:O(N)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:O(N)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\nPlease upvote if you find it helpful \\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        // Vector to store the evens between odd numbers\\r\\n        vector<int> t;\\r\\n        int temp = 0, ans = 0; \\r\\n        // Store Evens between odds\\r\\n        for(int i=0; i<nums.size(); i++) {\\r\\n            if(nums[i]%2 == 0) temp++; \\r\\n            else {\\r\\n                t.push_back(temp); temp = 0; \\r\\n            }\\r\\n        }\\r\\n        t.push_back(temp); \\r\\n        int ind = 0; \\r\\n        //sliding window to count number of subarrays\\r\\n        while(ind + k < t.size()){ ans += (t[ind]+1) * (t[ind+k]+1); ind++; }\\r\\n\\r\\n        return ans; \\r\\n\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        // Vector to store the evens between odd numbers\\r\\n        vector<int> t;\\r\\n        int temp = 0, ans = 0; \\r\\n        // Store Evens between odds\\r\\n        for(int i=0; i<nums.size(); i++) {\\r\\n            if(nums[i]%2 == 0) temp++; \\r\\n            else {\\r\\n                t.push_back(temp); temp = 0; \\r\\n            }\\r\\n        }\\r\\n        t.push_back(temp); \\r\\n        int ind = 0; \\r\\n        //sliding window to count number of subarrays\\r\\n        while(ind + k < t.size()){ ans += (t[ind]+1) * (t[ind+k]+1); ind++; }\\r\\n\\r\\n        return ans; \\r\\n\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534455,
                "title": "dont-fall-into-the-two-pointer-sliding-window-trap",
                "content": "This question is a direct variation of running subarray sum. This approach is simple and highly intuitive compared to sliding window and 2 pointers.\\n\\nThe map is storing {key, val} == {num of odds in subarray, num of subarray with these many odds that have been encountered till now}\\n\\nKey insight --> The map only stores subarrays starting from the first element of the array. All the other subarrays are are taken care of using the below logic.\\n\\nSay we want to find all 2 odd num size subarrays. And now we are at a point where we have 5 odd nums with us, we want to look into the map for all the subarrays with 3 odd nums that have been encountered yet(map). This is because if we have a 5 odd num subarray and we know of previous 3 odd num subarrays. All of those 3 odd num sized subarrays when removed out of the 5 sized subarray will give us 2 odd num sized subarrays. Hence add it to result.\\n\\n----------------------\\n```\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int res = 0; int cnt = 0;\\n        unordered_map<int, int> mp; mp[0] = 1;\\n        \\n        for(auto n : nums) {\\n            \\n            if(n % 2) cnt++;\\n            res += mp[cnt - k];\\n            mp[cnt]++;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int res = 0; int cnt = 0;\\n        unordered_map<int, int> mp; mp[0] = 1;\\n        \\n        for(auto n : nums) {\\n            \\n            if(n % 2) cnt++;\\n            res += mp[cnt - k];\\n            mp[cnt]++;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232436,
                "title": "easy-commented-o-n-time-and-o-1-space-window-sliding",
                "content": "```\\nclass Solution {\\n   public:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int l = 0, r = 0, n = nums.size(), kCount = 0, count = 0, prefix = 0;\\n        while (r < n) {\\n            // increase odd count\\n            kCount += (nums[r++] & 1);\\n            if (kCount > k) {\\n                l++;\\n                kCount--;\\n                prefix = 0;\\n            }\\n\\n            // Count the number of prefix which is even because either we include them or not still we get the nice one\\n            while (l < r && (nums[l] % 2 == 0)) prefix++, l++;\\n            if (kCount == k) {\\n                count += (1 + prefix);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int l = 0, r = 0, n = nums.size(), kCount = 0, count = 0, prefix = 0;\\n        while (r < n) {\\n            // increase odd count\\n            kCount += (nums[r++] & 1);\\n            if (kCount > k) {\\n                l++;\\n                kCount--;\\n                prefix = 0;\\n            }\\n\\n            // Count the number of prefix which is even because either we include them or not still we get the nice one\\n            while (l < r && (nums[l] % 2 == 0)) prefix++, l++;\\n            if (kCount == k) {\\n                count += (1 + prefix);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776981,
                "title": "javascript-sliding-window",
                "content": "Move right pointer until odd number reach k, then count even number towards right until reach next odd number or the end, count even number towards left untill left pointer is sitting on an odd number, the product of left and right is the answer for this window, at last move left pointer and reduce odd number for 1 for next window.\\n\\n```\\nvar numberOfSubarrays = function(nums, k) {\\n    let count = 0;\\n    let odd = 0;\\n    let l = 0, r = -1;\\n    while(r < nums.length-1) {\\n        r++;\\n        if (nums[r]%2 !== 0) odd++;\\n        if (odd === k) {\\n            let right = 1;\\n            let left = 1;\\n            // move r if next element is even\\n            while(r < nums.length-1 && nums[r+1]%2 === 0) {\\n                r++;\\n                right++;\\n            }\\n            // move l if current element for l is even\\n            while(l < r && nums[l]%2 === 0) {\\n                l++;\\n                left++;\\n            }\\n            count += left*right;\\n            l++;\\n            odd--;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numberOfSubarrays = function(nums, k) {\\n    let count = 0;\\n    let odd = 0;\\n    let l = 0, r = -1;\\n    while(r < nums.length-1) {\\n        r++;\\n        if (nums[r]%2 !== 0) odd++;\\n        if (odd === k) {\\n            let right = 1;\\n            let left = 1;\\n            // move r if next element is even\\n            while(r < nums.length-1 && nums[r+1]%2 === 0) {\\n                r++;\\n                right++;\\n            }\\n            // move l if current element for l is even\\n            while(l < r && nums[l]%2 === 0) {\\n                l++;\\n                left++;\\n            }\\n            count += left*right;\\n            l++;\\n            odd--;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1915838,
                "title": "java-easy-consise-o-n",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        return count(nums,k) - count(nums,k-1); \\n\\t\\t// number of subarrays with k odd integers  = number of subarrays with atmost k odd integer -  number of subarrays with atmost k-1 odd integers\\n    }\\n    public int count(int[] nums,int k){\\n        int res = 0,start = 0,end = 0, count =0;\\n        while(end < nums.length){\\n            if(nums[end] % 2 == 1) count++;\\n            while(start <= end && count > k){\\n                if(nums[start] % 2 == 1) count--;\\n                start++;\\n            }\\n            res += (end - start + 1);\\n            end++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        return count(nums,k) - count(nums,k-1); \\n\\t\\t// number of subarrays with k odd integers  = number of subarrays with atmost k odd integer -  number of subarrays with atmost k-1 odd integers\\n    }\\n    public int count(int[] nums,int k){\\n        int res = 0,start = 0,end = 0, count =0;\\n        while(end < nums.length){\\n            if(nums[end] % 2 == 1) count++;\\n            while(start <= end && count > k){\\n                if(nums[start] % 2 == 1) count--;\\n                start++;\\n            }\\n            res += (end - start + 1);\\n            end++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878351,
                "title": "c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int atmost (vector<int>& arr, int k){\\n        if(arr.size()==0)\\n            return 0 ;\\n        int ans = 0;\\n        int j= 0;\\n        int count = 0;\\n        for ( int i =0;i<arr.size();i++){\\n            if(arr[i]&1){\\n                count++;\\n            }\\n            while(count>k){\\n                if(arr[j]&1)\\n                    count--;\\n                j++;\\n            }\\n            ans+=i-j+1;\\n        }\\n        return ans;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& v, int k) {\\n        return atmost(v,k)-atmost(v,k-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int atmost (vector<int>& arr, int k){\\n        if(arr.size()==0)\\n            return 0 ;\\n        int ans = 0;\\n        int j= 0;\\n        int count = 0;\\n        for ( int i =0;i<arr.size();i++){\\n            if(arr[i]&1){\\n                count++;\\n            }\\n            while(count>k){\\n                if(arr[j]&1)\\n                    count--;\\n                j++;\\n            }\\n            ans+=i-j+1;\\n        }\\n        return ans;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& v, int k) {\\n        return atmost(v,k)-atmost(v,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644359,
                "title": "java-two-pointer-sliding-window-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n     \\n        int odds = 0;\\n        int i = 0, j = 0, flag = 0;\\n        int n = nums.length;\\n        int ans = 0;\\n        while(j < n){\\n            if(nums[j]%2!=0){\\n                odds++;\\n            }\\n            while(odds > k){\\n                if(nums[i++]%2!=0)odds--;\\n                flag = i;\\n            }\\n            if(odds == k){\\n                ans+=(i+1-flag);\\n                while(nums[i]%2==0){\\n                    i++;\\n                    ans++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n     \\n        int odds = 0;\\n        int i = 0, j = 0, flag = 0;\\n        int n = nums.length;\\n        int ans = 0;\\n        while(j < n){\\n            if(nums[j]%2!=0){\\n                odds++;\\n            }\\n            while(odds > k){\\n                if(nums[i++]%2!=0)odds--;\\n                flag = i;\\n            }\\n            if(odds == k){\\n                ans+=(i+1-flag);\\n                while(nums[i]%2==0){\\n                    i++;\\n                    ans++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631869,
                "title": "count-number-of-nice-subarray",
                "content": "\\n\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/edf56675-d477-426e-ae38-2c78ff496b20_1640928608.742415.png)\\n\\n**Discuss**\\n\\n1. In this problem , First we will change the odd digit from 1 and even with zero in given array.\\n2. calculating the sum from start to end index with comparison k value\\ni.e. sum - k == 0\\n3. then we find subarray whose array has k odd value and stored in map. after this check again for another subarray because if we got odd value equal to the given k value then we got the subarray which has k odd value.\\n\\n**Note : this problem basically similar to the find subarray whose sum is equal to 0**\\n\\nclass Solution {\\n\\n    public int numberOfSubarrays(int[] nums, int k) {          \\n        Map<Integer, Integer> mp = new HashMap<>();\\n        int res = 0;\\n        int sum = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            sum += nums[j] % 2;\\n            if (sum - k == 0) {\\n                res++;\\n            }\\n            if (mp.containsKey(sum - k)) {\\n                res += mp.get(sum - k);\\n            }\\n            mp.put(sum, mp.getOrDefault(sum, 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\n    public int numberOfSubarrays(int[] nums, int k) {          \\n        Map<Integer, Integer> mp = new HashMap<>();\\n        int res = 0;\\n        int sum = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            sum += nums[j] % 2;\\n            if (sum - k == 0) {\\n                res++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 426285,
                "title": "easy-solution-using-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int odd=0,l=0,res=0;\\n        for(int r=0;r<n;r++)\\n        {\\n            if(nums[r]%2==1)\\n                odd++;\\n            while(l<r && odd>k)\\n            {\\n                if(nums[l]%2==1)\\n                    odd--;\\n                l++;\\n            }\\n            if(odd==k)\\n                res++;\\n            for(int i=l; odd==k && i<r && nums[i]%2==0;i++)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\nA problem similar to this:\\nhttps://leetcode.com/problems/binary-subarrays-with-sum/description/\\nsolution:\\nhttps://leetcode.com/problems/binary-subarrays-with-sum/discuss/426284/Easy-Solution-Using-Sliding-Window!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int odd=0,l=0,res=0;\\n        for(int r=0;r<n;r++)\\n        {\\n            if(nums[r]%2==1)\\n                odd++;\\n            while(l<r && odd>k)\\n            {\\n                if(nums[l]%2==1)\\n                    odd--;\\n                l++;\\n            }\\n            if(odd==k)\\n                res++;\\n            for(int i=l; odd==k && i<r && nums[i]%2==0;i++)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419358,
                "title": "java-simple-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        ArrayList<Integer> pos = new ArrayList<>();\\n        pos.add(0);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==1){\\n                pos.add(i+1);\\n            }\\n        }\\n        pos.add(nums.length+1);\\n        int res=0;\\n\\n        for(int i=1;i<=pos.size()-k-1;i++){\\n            int start=pos.get(i)-pos.get(i-1);\\n            int end = pos.get(i+k)-pos.get(i+k-1);\\n            res+=start*end;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        ArrayList<Integer> pos = new ArrayList<>();\\n        pos.add(0);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==1){\\n                pos.add(i+1);\\n            }\\n        }\\n        pos.add(nums.length+1);\\n        int res=0;\\n\\n        for(int i=1;i<=pos.size()-k-1;i++){\\n            int start=pos.get(i)-pos.get(i-1);\\n            int end = pos.get(i+k)-pos.get(i+k-1);\\n            res+=start*end;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419345,
                "title": "simple-java-hashmap-solution-o-n-by-keeping-track-of-count-of-odd-numbers",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        \\n        int n = nums.length;\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int ans = 0;\\n        int currCount = 0;\\n        \\n        map.put(0, 1);\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] % 2 == 1) currCount ++;\\n            if(map.containsKey(currCount - k)) ans += map.get(currCount - k);\\n            if(!map.containsKey(currCount)) map.put(currCount, 1);\\n            else map.put(currCount, 1 + map.get(currCount));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        \\n        int n = nums.length;\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int ans = 0;\\n        int currCount = 0;\\n        \\n        map.put(0, 1);\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] % 2 == 1) currCount ++;\\n            if(map.containsKey(currCount - k)) ans += map.get(currCount - k);\\n            if(!map.containsKey(currCount)) map.put(currCount, 1);\\n            else map.put(currCount, 1 + map.get(currCount));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 419317,
                "title": "java-sliding-window-two-pointers-o-n",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int start = 0, end = 0, len = nums.length;\\n        int count = 0, oddCount = 0, evenCount = 0;\\n        \\n        while(end < len){\\n            \\n            while(end < len && oddCount < k){\\n                if(nums[end++] % 2 != 0)  ++oddCount;\\n            }\\n            \\n           evenCount = 1;\\n           while(end < len && nums[end] % 2 == 0){\\n                ++evenCount;\\n                ++end;\\n           }\\n           \\n           while(start < len && oddCount == k){\\n                count += evenCount;\\n                if(nums[start++] % 2 != 0) --oddCount;\\n           }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int start = 0, end = 0, len = nums.length;\\n        int count = 0, oddCount = 0, evenCount = 0;\\n        \\n        while(end < len){\\n            \\n            while(end < len && oddCount < k){\\n                if(nums[end++] % 2 != 0)  ++oddCount;\\n            }\\n            \\n           evenCount = 1;\\n           while(end < len && nums[end] % 2 == 0){\\n                ++evenCount;\\n                ++end;\\n           }\\n           \\n           while(start < len && oddCount == k){\\n                count += evenCount;\\n                if(nums[start++] % 2 != 0) --oddCount;\\n           }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058966,
                "title": "sliding-window-c",
                "content": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int n = nums.size(), dis = 1, i = 0, cnt = 0, ans = 0;\\r\\n        vector<int> d(n + 1, 1);\\r\\n\\r\\n        for(int i=n-1; i>=0; i--) {\\r\\n            nums[i] % 2 ? dis = 1 : dis++;\\r\\n            d[i] = dis;\\r\\n        }\\r\\n       \\r\\n        for(int j=0; j<n; j++) {\\r\\n            if(nums[j] % 2) cnt++;\\r\\n\\r\\n            while(i <= j && cnt == k) {\\r\\n                ans += d[j + 1];\\r\\n                if(nums[i] % 2) cnt--;\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int n = nums.size(), dis = 1, i = 0, cnt = 0, ans = 0;\\r\\n        vector<int> d(n + 1, 1);\\r\\n\\r\\n        for(int i=n-1; i>=0; i--) {\\r\\n            nums[i] % 2 ? dis = 1 : dis++;\\r\\n            d[i] = dis;\\r\\n        }\\r\\n       \\r\\n        for(int j=0; j<n; j++) {\\r\\n            if(nums[j] % 2) cnt++;\\r\\n\\r\\n            while(i <= j && cnt == k) {\\r\\n                ans += d[j + 1];\\r\\n                if(nums[i] % 2) cnt--;\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368474,
                "title": "c-3-ideas-solution-and-explanation-for-beginners",
                "content": "First, the naive solution, we check every possible subarray and increment the count everytime we encounter a nice subarray.\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            for(int j = i; j < n; j++) {\\n                if(nums[j] & 1 != 0) {\\n                    count++;\\n                }\\n                \\n                if(count == k) sum++;\\n                if(count > k) break;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\nVery standard, not much to talk about. The time complexity is `O(n^2)`while the space complexity is `O(1)`. Submitting this will cause an TLE...so it is clear we must do better on time complexity.\\n\\nHere is an observation, given a minimum length nice subarray with even number surrounding it. The total amount of different subarray we can construct is the \"left wing\" * \"right wing\". Take a look at the following example:\\n```\\n2,2,2,2,1,2,2,1,2,2,2,2       k = 2\\n```\\nHow many nice subarray can we construct? The answer is `5 * 5 = 25`. While we can count everything out, a better way is to notice the following pattern `1,2,2,1 -> 1,2,2,1,2 -> 1,2,2,1,2,2 -> ...`, for every element in the \"left wing\" we can pair it up with every other element in the \"right wing\" and vice versa. Simple math tells us the number of such combination is simply `left wing * right wing`. I will sepereate the two wings to make it clearer `2,2,2,2,1 | 2,2 | 1,2,2,2,2` (notice that we include the odd number in the wing). How we can locate a \"minimum length nice subarray\"? Easy, we can simple store indexs of all odd numbers and create a sliding window of length `k`. For every such window, we will calculate the length of both wing, either terminate at the start or end of an array, or terminate immediate before another odd number. For example, our minimum length nice subarray is from index 7 to index 9. \\n`2,2,1       |       2,2,2,2,1| 2 |1,2,2,2,2        |        1,1`\\nIf you don\\'t get it, stare at it for a while and I\\'m sure it will come to you. Time for the implementation:\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> idx;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] & 1 != 0) idx.push_back(i);\\n        }\\n        \\n        int sum = 0;\\n        \\n        int i = 0;\\n        for(int j = k - 1; j < idx.size(); j++) {\\n            int left = idx[i] - (i == 0 ? -1 : idx[i - 1]);\\n            int right = (j == idx.size() - 1 ? n : idx[j + 1]) - idx[j];\\n            \\n            sum += left * right;\\n            i++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\nTime complexity is `O(n)` while space complexity is also `O(n)`. \\n\\nSubmit and the code runs fine. I always like looking for other solutions even after finishing a question. I find it a good practice and also interesting that 1 problem can have so many different solutions.\\n\\nThis question might remind you of https://leetcode.com/problems/subarrays-with-k-different-integers/. This is a great question and I would definitely recommend checking out. When we do our standard sliding window solutions we get stuck because there is no easy way to slide the window through all possible subarrays. However, we can actually find all subarray with ATMOST `k` odd numbers pretty easily with sliding window. You should try and do this on your own. Eitherway, simple math tells us that `exactly(k) = atmost(k) - atmost(k - 1)`. This gives us a relatively simple algorithm:\\n```\\nclass Solution {\\n    \\n    int atMost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i = 0;\\n        int sum = 0;\\n        \\n        for(int j = 0; j < n; j++) {\\n            if((nums[j] & 1) != 0) k--;\\n            while(k < 0) {\\n                if((nums[i] & 1) != 0) k++;\\n                i++;\\n            }\\n            \\n            sum += j - i + 1;\\n        }\\n        \\n        return sum;\\n    }\\n    \\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return atMost(nums, k) - atMost(nums, k - 1);\\n    }\\n};\\n```\\nSame time complexity as the solution above, but space complexity is `O(1)`.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            for(int j = i; j < n; j++) {\\n                if(nums[j] & 1 != 0) {\\n                    count++;\\n                }\\n                \\n                if(count == k) sum++;\\n                if(count > k) break;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\n```\\n2,2,2,2,1,2,2,1,2,2,2,2       k = 2\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> idx;\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] & 1 != 0) idx.push_back(i);\\n        }\\n        \\n        int sum = 0;\\n        \\n        int i = 0;\\n        for(int j = k - 1; j < idx.size(); j++) {\\n            int left = idx[i] - (i == 0 ? -1 : idx[i - 1]);\\n            int right = (j == idx.size() - 1 ? n : idx[j + 1]) - idx[j];\\n            \\n            sum += left * right;\\n            i++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\n    int atMost(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i = 0;\\n        int sum = 0;\\n        \\n        for(int j = 0; j < n; j++) {\\n            if((nums[j] & 1) != 0) k--;\\n            while(k < 0) {\\n                if((nums[i] & 1) != 0) k++;\\n                i++;\\n            }\\n            \\n            sum += j - i + 1;\\n        }\\n        \\n        return sum;\\n    }\\n    \\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return atMost(nums, k) - atMost(nums, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283963,
                "title": "very-easy-c-solution-in-o-n-beats-99-48-submissions",
                "content": "To achieve good time complexity we need to use bit munpulation for checking odd number\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```\\n#pragma GCC optimize(\"Ofast\")  \\n#pragma GCC target(\"avx,avx2,fma\") \\nstatic auto _ = [] ()\\n{ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int j = 0, odd = 0, ctr = 0, ans = 0;\\n        for (int i = 0; i < nums.size(); i++) \\n        {\\n            if (nums[i] & 1)\\n            {\\n                odd++;\\n                if (odd >= k) \\n                {\\n                    ctr = 1;\\n                    while (!(nums[j++] & 1))\\n                        ctr++;\\n                    ans += ctr;\\n                }\\n            \\n            } else if (odd >=k) \\n                ans += ctr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\")  \\n#pragma GCC target(\"avx,avx2,fma\") \\nstatic auto _ = [] ()\\n{ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int j = 0, odd = 0, ctr = 0, ans = 0;\\n        for (int i = 0; i < nums.size(); i++) \\n        {\\n            if (nums[i] & 1)\\n            {\\n                odd++;\\n                if (odd >= k) \\n                {\\n                    ctr = 1;\\n                    while (!(nums[j++] & 1))\\n                        ctr++;\\n                    ans += ctr;\\n                }\\n            \\n            } else if (odd >=k) \\n                ans += ctr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1257767,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    // Function to calculate the number of subarrays having count of odd numbers lees than or equals to k\\n    int helper(vector<int>&nums,int k)\\n    {\\n        int ans=0,i=0,count=0;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            if(nums[j]%2!=0)\\n            {\\n                count++;\\n            }\\n            while(i<=j && count>k)\\n            {\\n                if(nums[i]%2!=0)\\n                {\\n                    count--;\\n                }\\n                i++;\\n            }\\n            ans+=(j-i+1);\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) \\n    {\\n        // Number of subarrays with count of odd numbers <=k = (Numbers of subarrays with count of odd numbers <k + Numbers of subarrays with count of odd numbers =k)\\n        // so if we exclude the number of subarrays with odd number count less than k from number of subarrays with odd number count equals to k , we\\'ll get our answer.\\n        return helper(nums,k)-helper(nums,k-1);\\n    }\\n};\\n```\\n**Please upvote if you have got any help from my code. Thank you.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    // Function to calculate the number of subarrays having count of odd numbers lees than or equals to k\\n    int helper(vector<int>&nums,int k)\\n    {\\n        int ans=0,i=0,count=0;\\n        for(int j=0;j<nums.size();j++)\\n        {\\n            if(nums[j]%2!=0)\\n            {\\n                count++;\\n            }\\n            while(i<=j && count>k)\\n            {\\n                if(nums[i]%2!=0)\\n                {\\n                    count--;\\n                }\\n                i++;\\n            }\\n            ans+=(j-i+1);\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) \\n    {\\n        // Number of subarrays with count of odd numbers <=k = (Numbers of subarrays with count of odd numbers <k + Numbers of subarrays with count of odd numbers =k)\\n        // so if we exclude the number of subarrays with odd number count less than k from number of subarrays with odd number count equals to k , we\\'ll get our answer.\\n        return helper(nums,k)-helper(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615004,
                "title": "c-o-1-space-97-faster-100-space-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n    }\\n    int func(vector<int> &nums,int k)\\n    {\\n        int j=0;\\n        int cnt=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2)k--;\\n            while(k<0)\\n            {\\n                if(nums[j]%2)k++;\\n                j++;\\n            }\\n            cnt+=i-j+1;\\n        }\\n        return cnt;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\t\\t\\treturn func(nums,k)-func(nums,k-1);//func calculate for atmost case. exact k=atmost k -atmost k-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n    }\\n    int func(vector<int> &nums,int k)\\n    {\\n        int j=0;\\n        int cnt=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2)k--;\\n            while(k<0)\\n            {\\n                if(nums[j]%2)k++;\\n                j++;\\n            }\\n            cnt+=i-j+1;\\n        }\\n        return cnt;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\t\\t\\treturn func(nums,k)-func(nums,k-1);//func calculate for atmost case. exact k=atmost k -atmost k-1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 562635,
                "title": "c-map-solution-easy-implementation",
                "content": "```\\nint numberOfSubarrays(vector<int>& nums, int k) {\\n\\tint res = 0, sum = 0, n = nums.size();\\n\\tunordered_map<int, int> mpp;\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tmpp[sum]++;\\n\\t\\tsum += nums[i] & 1;\\n\\t\\tres += mpp[sum - k];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numberOfSubarrays(vector<int>& nums, int k) {\\n\\tint res = 0, sum = 0, n = nums.size();\\n\\tunordered_map<int, int> mpp;\\n\\tfor (int i = 0; i < n; ++i) {\\n\\t\\tmpp[sum]++;\\n\\t\\tsum += nums[i] & 1;\\n\\t\\tres += mpp[sum - k];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419934,
                "title": "python-easy-to-understand-sliding-window-left-right-evens-faster-than-100",
                "content": "\\tclass Solution(object):\\n\\t\\tdef numberOfSubarrays(self, nums, k):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\te.g. k = 2\\n\\t\\t\\tnums = [2, 2, 1, 2, 1, 2, 2]\\n\\t\\t\\tindex=  0  1  2  3  4  5  6\\n\\t\\t\\t2 even numbers to left of first 1\\n\\t\\t\\t2 even numbers to right of last 1\\n\\t\\t\\ttotal number of subarrays = pick between 0-2 numbers on left, then, pick between 0-2 numbers on right\\n\\t\\t\\ti.e (left+1)  (right+1)\\n\\t\\t\\tThen slide window to next set of 2 odd numbers\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\todds = []\\n\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] & 1:\\n\\t\\t\\t\\t\\todds.append(i)                      #\\' Find index of all odd numbers \\'\\n\\n\\t\\t\\todds = [-1] + odds + [len(nums)]            #\\' Handle edge cases \\'\\n\\t\\t\\tnice = 0\\n\\n\\t\\t\\tfor i in range(1, len(odds)-k):\\n\\t\\t\\t\\tleft = odds[i] - odds[i-1] - 1          #\\' Number of \\'left\\' even numbers \\'\\n\\t\\t\\t\\tright = odds[i+k] - odds[i+k-1] - 1     #\\' Number of \\'right\\' even numbers \\'\\n\\t\\t\\t\\tnice += (left+1)*(right+1)              #\\' Total sub-arrays in current window \\'\\n\\n\\t\\t\\treturn nice\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef numberOfSubarrays(self, nums, k):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\te.g. k = 2\\n\\t\\t\\tnums = [2, 2, 1, 2, 1, 2, 2]\\n\\t\\t\\tindex=  0  1  2  3  4  5  6\\n\\t\\t\\t2 even numbers to left of first 1\\n\\t\\t\\t2 even numbers to right of last 1\\n\\t\\t\\ttotal number of subarrays = pick between 0-2 numbers on left, then, pick between 0-2 numbers on right\\n\\t\\t\\ti.e (left+1)  (right+1)\\n\\t\\t\\tThen slide window to next set of 2 odd numbers\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\todds = []\\n\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] & 1:\\n\\t\\t\\t\\t\\todds.append(i)                      #\\' Find index of all odd numbers \\'\\n\\n\\t\\t\\todds = [-1] + odds + [len(nums)]            #\\' Handle edge cases \\'\\n\\t\\t\\tnice = 0\\n\\n\\t\\t\\tfor i in range(1, len(odds)-k):\\n\\t\\t\\t\\tleft = odds[i] - odds[i-1] - 1          #\\' Number of \\'left\\' even numbers \\'\\n\\t\\t\\t\\tright = odds[i+k] - odds[i+k-1] - 1     #\\' Number of \\'right\\' even numbers \\'\\n\\t\\t\\t\\tnice += (left+1)*(right+1)              #\\' Total sub-arrays in current window \\'\\n\\n\\t\\t\\treturn nice\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 419350,
                "title": "sliding-window-solution",
                "content": "The idea is sliding window with minor modification. Here is an example:\\n```2, 2, 3, 2, 2```\\nWe want to find 1 odd number. Using sliding window, we can find  `2, 2, 1`. And we delete the first two \\'2\\', which means that there are 3 sub-arrays that contain one 3. \\n\\nBut it\\'s not over, there are still two 2 left in the end. Thus, for any even number afterwards, we add 3 to the final result, which means that, given an even number, we can find 3 sub-arrays. Since there are two 2, we have 2 extra 3.\\n\\nThus, there are in total 3 * 3 = 9 sub-arrays that contain 1 odd number. \\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int i = 0, j = 0, odd_cnt = 0, tot_res = 0, tmp_res = 0;\\n        for (i = 0; i < nums.size(); i++) {\\n            if (nums[i] % 2 == 1) odd_cnt++;\\n            while (odd_cnt == k) {\\n                tmp_res++;\\n                if (nums[j] % 2 == 1) odd_cnt--;\\n                j++;\\n            }\\n            tot_res += tmp_res;\\n            i++;\\n            while (i < nums.size() && nums[i] % 2 == 0) {\\n                tot_res += tmp_res;\\n                i++;\\n            }\\n            i--;\\n            tmp_res = 0;\\n        }\\n        \\n        return tot_res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```2, 2, 3, 2, 2```\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int i = 0, j = 0, odd_cnt = 0, tot_res = 0, tmp_res = 0;\\n        for (i = 0; i < nums.size(); i++) {\\n            if (nums[i] % 2 == 1) odd_cnt++;\\n            while (odd_cnt == k) {\\n                tmp_res++;\\n                if (nums[j] % 2 == 1) odd_cnt--;\\n                j++;\\n            }\\n            tot_res += tmp_res;\\n            i++;\\n            while (i < nums.size() && nums[i] % 2 == 0) {\\n                tot_res += tmp_res;\\n                i++;\\n            }\\n            i--;\\n            tmp_res = 0;\\n        }\\n        \\n        return tot_res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940024,
                "title": "sliding-window-prefixsum-approach",
                "content": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        prefixsum=0\\n        dic=defaultdict(int)\\n        dic[0]=1\\n        ans=0\\n        for i in nums:\\n            if i%2==1:\\n                prefixsum+=1\\n            ans+=dic[prefixsum-k]\\n            dic[prefixsum]+=1\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        prefixsum=0\\n        dic=defaultdict(int)\\n        dic[0]=1\\n        ans=0\\n        for i in nums:\\n            if i%2==1:\\n                prefixsum+=1\\n            ans+=dic[prefixsum-k]\\n            dic[prefixsum]+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722242,
                "title": "modifying-the-question-making-it-much-more-easier-sliding-window-easy-to-understand",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nTreat odd numbers as 1 and even numbers as 0, then solve as if you want sum of subarray having sum = k.\\r\\n\\r\\nSame as this question: [930. Binary Subarrays With Sum\\r\\n](https://leetcode.com/problems/binary-subarrays-with-sum/)\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. Replace all the odd elements with 1 and all the even elements with 0.\\r\\n2. Now calculate the subarrays with sum = k.\\r\\n3. This can be done by finding the subarrays with **sum <= k** and finding subarrays with **sum <= k - 1** and subtrack later from the previous one.\\r\\n\\r\\n**Feel free to post your doubts in the comments :)**\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: **O(n)**\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: **O(1)**\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int atMost(vector<int>& nums, int k)\\r\\n    {\\r\\n        int left = 0;\\r\\n        int right = 0;\\r\\n        int ans = 0;\\r\\n\\r\\n        for(right = 0; right < nums.size(); right++)\\r\\n        {\\r\\n            k -= nums[right];\\r\\n            while(k < 0)\\r\\n            {\\r\\n                k += nums[left];\\r\\n                left++;\\r\\n            }\\r\\n            ans += right - left + 1;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        for(int i = 0; i < nums.size(); i++)\\r\\n        {\\r\\n            if(nums[i] % 2 == 1) nums[i] = 1;\\r\\n            else nums[i] = 0;\\r\\n        }\\r\\n        return atMost(nums, k) - atMost(nums, k - 1);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int atMost(vector<int>& nums, int k)\\r\\n    {\\r\\n        int left = 0;\\r\\n        int right = 0;\\r\\n        int ans = 0;\\r\\n\\r\\n        for(right = 0; right < nums.size(); right++)\\r\\n        {\\r\\n            k -= nums[right];\\r\\n            while(k < 0)\\r\\n            {\\r\\n                k += nums[left];\\r\\n                left++;\\r\\n            }\\r\\n            ans += right - left + 1;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        for(int i = 0; i < nums.size(); i++)\\r\\n        {\\r\\n            if(nums[i] % 2 == 1) nums[i] = 1;\\r\\n            else nums[i] = 0;\\r\\n        }\\r\\n        return atMost(nums, k) - atMost(nums, k - 1);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488177,
                "title": "java-very-easy",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        int i=0;\\r\\n        int j=0;\\r\\n        int oddCount=0;\\r\\n        int ans=0;\\r\\n         int count=0;\\r\\n\\r\\n        while(j<nums.length){\\r\\n            \\r\\n            if(nums[j]%2!=0){\\r\\n                oddCount++;\\r\\n                ans=0;\\r\\n            }\\r\\n            \\r\\n            while(oddCount==k){\\r\\n                ans++;\\r\\n                if(nums[i]%2!=0){  \\r\\n                    oddCount--;\\r\\n    \\r\\n                }\\r\\n                i++;\\r\\n            }\\r\\n            count+=ans;\\r\\n            j++;\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        int i=0;\\r\\n        int j=0;\\r\\n        int oddCount=0;\\r\\n        int ans=0;\\r\\n         int count=0;\\r\\n\\r\\n        while(j<nums.length){\\r\\n            \\r\\n            if(nums[j]%2!=0){\\r\\n                oddCount++;\\r\\n                ans=0;\\r\\n            }\\r\\n            \\r\\n            while(oddCount==k){\\r\\n                ans++;\\r\\n                if(nums[i]%2!=0){  \\r\\n                    oddCount--;\\r\\n    \\r\\n                }\\r\\n                i++;\\r\\n            }\\r\\n            count+=ans;\\r\\n            j++;\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270751,
                "title": "easy-sliding-window-solution-with-o-n-time-complexity",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThis Problem is talking about subarrays so the first thought that should come in your mind -> sliding window\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. first take two pointer on index 0\\r\\n2. now the second pointer will diverse from start , until the number of odds are not equals to k\\r\\n3. when the number of equal to k start increasing the second pointer until it eliminates the odd from start and makes number of odds less than k, along with it increase the prefix \\r\\n4.add the prefix in count until the next odd are not found \\r\\n5. Repeat the steps again\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nO(n)\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nO(1)\\r\\n# Code\\r\\n```\\r\\n/**\\r\\n * @param {number[]} nums\\r\\n * @param {number} k\\r\\n * @return {number}\\r\\n */\\r\\nvar numberOfSubarrays = function(nums, k) {\\r\\n    let odds=0;\\r\\n    let count=0;\\r\\n    let prefix=0\\r\\n\\r\\n    let i=0;\\r\\n\\r\\n    for(let j=0;j<nums.length;j++){\\r\\n        if(nums[j]%2!=0){ \\r\\n            odds+=1\\r\\n            prefix=0\\r\\n            }\\r\\n\\r\\n        while(odds==k && i<=j){\\r\\n         if(nums[i]%2!=0)   odds-=1\\r\\n            i++\\r\\n           prefix++\\r\\n      \\r\\n        }\\r\\n       \\r\\n   count+=prefix\\r\\n\\r\\n    }\\r\\n    return count\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\r\\n/**\\r\\n * @param {number[]} nums\\r\\n * @param {number} k\\r\\n * @return {number}\\r\\n */\\r\\nvar numberOfSubarrays = function(nums, k) {\\r\\n    let odds=0;\\r\\n    let count=0;\\r\\n    let prefix=0\\r\\n\\r\\n    let i=0;\\r\\n\\r\\n    for(let j=0;j<nums.length;j++){\\r\\n        if(nums[j]%2!=0){ \\r\\n            odds+=1\\r\\n            prefix=0\\r\\n            }\\r\\n\\r\\n        while(odds==k && i<=j){\\r\\n         if(nums[i]%2!=0)   odds-=1\\r\\n            i++\\r\\n           prefix++\\r\\n      \\r\\n        }\\r\\n       \\r\\n   count+=prefix\\r\\n\\r\\n    }\\r\\n    return count\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3165207,
                "title": "easy-approach-c",
                "content": "# Intuition\\r\\nUsing prefix sum!!\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n       int j=0;\\r\\n       int count=0;\\r\\n       int sum=0;\\r\\n       unordered_map<int,int>m;\\r\\n       while(j<nums.size()){\\r\\n           if(nums[j]%2!=0)\\r\\n               sum+=1;\\r\\n\\r\\n           if(sum==k)\\r\\n           count++;\\r\\n\\r\\n           if(m.find(sum-k)!=m.end())\\r\\n           count+=m[sum-k];\\r\\n\\r\\n           m[sum]++;\\r\\n           j++;\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n       int j=0;\\r\\n       int count=0;\\r\\n       int sum=0;\\r\\n       unordered_map<int,int>m;\\r\\n       while(j<nums.size()){\\r\\n           if(nums[j]%2!=0)\\r\\n               sum+=1;\\r\\n\\r\\n           if(sum==k)\\r\\n           count++;\\r\\n\\r\\n           if(m.find(sum-k)!=m.end())\\r\\n           count+=m[sum-k];\\r\\n\\r\\n           m[sum]++;\\r\\n           j++;\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165203,
                "title": "c-easy-6-lines-of-code",
                "content": "# Intuition\\nIf you remember two sum question you can have refrence \\uD83D\\uDD25 \\uD83D\\uDD25\\nEnjoy !\\n\\n# UPVOTE IF IT HELPED \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int i=0 , sum=0 ,count=0;\\n        unordered_map<int,int>map;\\n        while(i<nums.size()){\\n            if(nums[i]%2 != 0) sum+=1;\\n            if(sum == k) count++;\\n             if(map.find(sum-k) != map.end()) count+=map[sum-k];\\n        map[sum]++;\\n         i++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int i=0 , sum=0 ,count=0;\\n        unordered_map<int,int>map;\\n        while(i<nums.size()){\\n            if(nums[i]%2 != 0) sum+=1;\\n            if(sum == k) count++;\\n             if(map.find(sum-k) != map.end()) count+=map[sum-k];\\n        map[sum]++;\\n         i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979885,
                "title": "c-two-pointer-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCalculating the subarrays having (k) odd numbers and subtracting the value with subarrays having (k-1) odd numbers.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint anss(vector<int>& nums, int k){\\n        int n = nums.size();\\n        vector<int> v(100001,0);\\n        int diff = 0;\\n        int j = 0;\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i]%2){\\n                v[nums[i]]++;\\n                diff++;\\n            }\\n            if(diff <= k){\\n                ans += (i-j+1);\\n            }else{\\n                while(j < n && j <= i && diff > k){\\n                    if(nums[j]%2 == 1){\\n                        v[nums[j]]--;\\n                        diff--;\\n                        \\n                    }\\n                    j++;\\n                }\\n                ans += (i-j +1);\\n            }\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        // cout<<anss(nums,k-1)<<endl;\\n        // cout<<anss(nums,k)<<endl;\\n        return (anss(nums,k) - anss(nums,k-1)) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint anss(vector<int>& nums, int k){\\n        int n = nums.size();\\n        vector<int> v(100001,0);\\n        int diff = 0;\\n        int j = 0;\\n        int ans = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i]%2){\\n                v[nums[i]]++;\\n                diff++;\\n            }\\n            if(diff <= k){\\n                ans += (i-j+1);\\n            }else{\\n                while(j < n && j <= i && diff > k){\\n                    if(nums[j]%2 == 1){\\n                        v[nums[j]]--;\\n                        diff--;\\n                        \\n                    }\\n                    j++;\\n                }\\n                ans += (i-j +1);\\n            }\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        // cout<<anss(nums,k-1)<<endl;\\n        // cout<<anss(nums,k)<<endl;\\n        return (anss(nums,k) - anss(nums,k-1)) ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2334366,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        int odd = 0;\\n        int result = 0;\\n        int temp = 0;\\n        \\n        \\n        /* \\n            Approach : two pointer + sliding window technique\\n            \\n            step 1 : we have fix i and moving j until our count of odd numbers == k\\n            step 2 : when(odd == count) we are counting every possible subarray by reducing the size of subarray from i\\n            \\n        why temp?\\n        from reducing the size of subarray we will count all the possible subarray from between i and j\\n        but when i encounter a odd element the odd count will reduce and that while will stop executing\\n        \\n        now there are two possible cases\\n        1.The leftover elements have a odd number\\n        2.The leftover elements do not have any odd number\\n        \\n        1. if our leftover elements have a odd number \\n                then we cannot include our old possible subarrays into new possible subarrays because now new window for having odd == k is formed\\n                that\\'s why temp = 0;\\n                \\n        2. if out leftover elements do not have any odd element left\\n            then our leftover elements must also take in consideration becuase they will also contribute in forming subarrays\\n        */\\n        while(j< nums.length){\\n            if(nums[j]%2 != 0)\\n            {\\n                odd++;\\n                //if leftover elements have odd element then new window is formed so we set temp = 0;\\n                temp = 0;\\n            }\\n            while(odd ==k){\\n                temp++;\\n                if(nums[i] %2 != 0)\\n                    odd--;\\n                i++;\\n             }\\n          //if no leftover elements is odd, each element will part in forming subarray\\n        //so include them\\n            result += temp;\\n            j++;\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        int odd = 0;\\n        int result = 0;\\n        int temp = 0;\\n        \\n        \\n        /* \\n            Approach : two pointer + sliding window technique\\n            \\n            step 1 : we have fix i and moving j until our count of odd numbers == k\\n            step 2 : when(odd == count) we are counting every possible subarray by reducing the size of subarray from i\\n            \\n        why temp?\\n        from reducing the size of subarray we will count all the possible subarray from between i and j\\n        but when i encounter a odd element the odd count will reduce and that while will stop executing\\n        \\n        now there are two possible cases\\n        1.The leftover elements have a odd number\\n        2.The leftover elements do not have any odd number\\n        \\n        1. if our leftover elements have a odd number \\n                then we cannot include our old possible subarrays into new possible subarrays because now new window for having odd == k is formed\\n                that\\'s why temp = 0;\\n                \\n        2. if out leftover elements do not have any odd element left\\n            then our leftover elements must also take in consideration becuase they will also contribute in forming subarrays\\n        */\\n        while(j< nums.length){\\n            if(nums[j]%2 != 0)\\n            {\\n                odd++;\\n                //if leftover elements have odd element then new window is formed so we set temp = 0;\\n                temp = 0;\\n            }\\n            while(odd ==k){\\n                temp++;\\n                if(nums[i] %2 != 0)\\n                    odd--;\\n                i++;\\n             }\\n          //if no leftover elements is odd, each element will part in forming subarray\\n        //so include them\\n            result += temp;\\n            j++;\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040140,
                "title": "java-solution-similar-to-subarray-sum-equals-k",
                "content": "Just convert all the odds to 1 and even to 0. Now it\\'s the same problem as sum of subarrays equals to k\\n```java\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        for (int i = 0; i<nums.length; i++) {\\n            if (nums[i]%2!=0) nums[i] = 1;\\n            else nums[i] = 0;\\n        }\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0, ans = 0;\\n        for (int i = 0; i<nums.length; i++) {\\n            map.put(sum, map.getOrDefault(sum, 0)+1);\\n            sum+=nums[i];\\n            if (map.containsKey(sum-k)) {\\n                ans+=map.get(sum-k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        for (int i = 0; i<nums.length; i++) {\\n            if (nums[i]%2!=0) nums[i] = 1;\\n            else nums[i] = 0;\\n        }\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0, ans = 0;\\n        for (int i = 0; i<nums.length; i++) {\\n            map.put(sum, map.getOrDefault(sum, 0)+1);\\n            sum+=nums[i];\\n            if (map.containsKey(sum-k)) {\\n                ans+=map.get(sum-k);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941025,
                "title": "easy-c-solution-6-lines-subarray-with-sum-k",
                "content": "```\\nint numberOfSubarrays(vector<int>& nums, int k) {\\n    int ans=0, sum=0;\\n    unordered_map<int,int> freq;\\n    for(auto a:nums){\\n        if(a%2!=0) ++sum;\\n        if(sum==k) ++ans;\\n        if(freq.count(sum-k)) ans += freq[sum-k];\\n        ++freq[sum];\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint numberOfSubarrays(vector<int>& nums, int k) {\\n    int ans=0, sum=0;\\n    unordered_map<int,int> freq;\\n    for(auto a:nums){\\n        if(a%2!=0) ++sum;\\n        if(sum==k) ++ans;\\n        if(freq.count(sum-k)) ans += freq[sum-k];\\n        ++freq[sum];\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1808819,
                "title": "python-solution-beats-95-81",
                "content": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        odd_ls = []\\n        for i, num in enumerate(nums):\\n            if num % 2 == 1:\\n                odd_ls.append(i)\\n                \\n        odd_ls = [-1] + odd_ls + [len(nums)]\\n        count = 0\\n        for i in range(1, len(odd_ls) - k):\\n            count += (odd_ls[i] - odd_ls[i - 1]) * (odd_ls[i + k] - odd_ls[i + k - 1])\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        odd_ls = []\\n        for i, num in enumerate(nums):\\n            if num % 2 == 1:\\n                odd_ls.append(i)\\n                \\n        odd_ls = [-1] + odd_ls + [len(nums)]\\n        count = 0\\n        for i in range(1, len(odd_ls) - k):\\n            count += (odd_ls[i] - odd_ls[i - 1]) * (odd_ls[i + k] - odd_ls[i + k - 1])\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243159,
                "title": "simple-c-solution-using-map",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>nums, int k) \\n    {\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           nums[i]=nums[i]%2;\\n       }\\n        int ans=0;\\n        int cur_sum=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cur_sum+=nums[i];\\n            if(cur_sum==k)\\n            {\\n                ans++;\\n            }\\n            if(mp.find(cur_sum-k)!=mp.end())\\n            {\\n                ans+=mp[cur_sum-k];\\n            }\\n            mp[cur_sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>nums, int k) \\n    {\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           nums[i]=nums[i]%2;\\n       }\\n        int ans=0;\\n        int cur_sum=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cur_sum+=nums[i];\\n            if(cur_sum==k)\\n            {\\n                ans++;\\n            }\\n            if(mp.find(cur_sum-k)!=mp.end())\\n            {\\n                ans+=mp[cur_sum-k];\\n            }\\n            mp[cur_sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165997,
                "title": "c-two-pointers-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        // Suppose we have a nice subarray from indices i to j.\\n        // Then every subarray that includes the even numbers before\\n        // i is also nice. Every subarray that includes the even\\n        // numbers after j is also nice. Suppose we have m contiguous\\n        // even numbers before i and n contiguous even numbers after\\n        // j. Then using the k odd numbers in our nice subarray from\\n        // i to j, we can create (m+1)*(n+1) nice subarrays.\\n        int N = nums.size();\\n        \\n        int i = 0;\\n        // Get i to the starting position\\n        while (i < N && nums[i] % 2 == 0) {\\n            i++;\\n        }\\n        \\n        // Edge case when there are no odd numbers in the array\\n        if (i >= N)\\n            return 0;\\n        \\n        // Get j to the starting position\\n        int j = i;\\n        int num_odd = 0;\\n        while (j < N && num_odd < k) {\\n            if (nums[j] % 2 == 1) {\\n                num_odd++;\\n            }\\n            j++;\\n        }\\n        \\n        if (j >= N && num_odd < k) {\\n            // Edge case when there are less than k odd numbers\\n            // in the array\\n            return 0;\\n        }\\n        \\n        // At this j is the index 1 after the kth odd number, so decrement\\n        j--;\\n        \\n        int prev_i = -1;\\n        int ans = 0;\\n        while (j < N) {\\n            // Find the next odd element after j, and count the gap between\\n            int next_j = j+1;\\n            while (next_j < N && nums[next_j] % 2 == 0)\\n                next_j++;\\n            \\n            // Num even between previous i and current i\\n            int m = i - prev_i - 1;\\n            // Num even between current j and next j\\n            int n = next_j - j - 1;\\n            \\n            // Add nice subarrays to answers\\n            int num_nice_subarrays = (m+1)*(n+1);\\n            ans += (m+1)*(n+1);\\n            \\n            // Update i and j\\n            prev_i = i;\\n            ++i;\\n            while (i < N && nums[i] % 2 == 0) {\\n                ++i;\\n            }\\n            \\n            j = next_j;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        // Suppose we have a nice subarray from indices i to j.\\n        // Then every subarray that includes the even numbers before\\n        // i is also nice. Every subarray that includes the even\\n        // numbers after j is also nice. Suppose we have m contiguous\\n        // even numbers before i and n contiguous even numbers after\\n        // j. Then using the k odd numbers in our nice subarray from\\n        // i to j, we can create (m+1)*(n+1) nice subarrays.\\n        int N = nums.size();\\n        \\n        int i = 0;\\n        // Get i to the starting position\\n        while (i < N && nums[i] % 2 == 0) {\\n            i++;\\n        }\\n        \\n        // Edge case when there are no odd numbers in the array\\n        if (i >= N)\\n            return 0;\\n        \\n        // Get j to the starting position\\n        int j = i;\\n        int num_odd = 0;\\n        while (j < N && num_odd < k) {\\n            if (nums[j] % 2 == 1) {\\n                num_odd++;\\n            }\\n            j++;\\n        }\\n        \\n        if (j >= N && num_odd < k) {\\n            // Edge case when there are less than k odd numbers\\n            // in the array\\n            return 0;\\n        }\\n        \\n        // At this j is the index 1 after the kth odd number, so decrement\\n        j--;\\n        \\n        int prev_i = -1;\\n        int ans = 0;\\n        while (j < N) {\\n            // Find the next odd element after j, and count the gap between\\n            int next_j = j+1;\\n            while (next_j < N && nums[next_j] % 2 == 0)\\n                next_j++;\\n            \\n            // Num even between previous i and current i\\n            int m = i - prev_i - 1;\\n            // Num even between current j and next j\\n            int n = next_j - j - 1;\\n            \\n            // Add nice subarrays to answers\\n            int num_nice_subarrays = (m+1)*(n+1);\\n            ans += (m+1)*(n+1);\\n            \\n            // Update i and j\\n            prev_i = i;\\n            ++i;\\n            while (i < N && nums[i] % 2 == 0) {\\n                ++i;\\n            }\\n            \\n            j = next_j;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649585,
                "title": "three-ways-to-solve",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int atMostKOdds(vector<int>& nums, int k) {\\n        int l = 0, r = 0;\\n        int odds = 0;\\n        int result = 0;\\n        for (; r < nums.size(); r++) {\\n            if (nums[r]&1)\\n                odds++;\\n            while (odds>k) {\\n                if (nums[l]&1)\\n                    odds--;\\n                l++;\\n            }\\n            result += r-l+1;\\n        }\\n        return result;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        // Approach 1: [ACCEPTED]\\n        // Based on \"Subarray sum equals K\" \\n        /*\\n            unordered_map<int,int> mp;\\n            int odds  = 0;\\n            mp[0]++;\\n            int n = nums.size();\\n            int ans = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i]&1) {\\n                    odds++;\\n                }\\n                if (mp.find(odds-k)!=mp.end())\\n                    ans += mp[odds-k];\\n                mp[odds]++;\\n                \\n            }\\n            return ans;\\n        */\\n        \\n        //\\n        \\n        \\n        // Approach 2 : [ACCEPTED] \\n        // Based on sliding window\\n        // The function atMostKOdds(int k) returns count of subarrays with at most k odd numbers.\\n        // So for this question, Ans = atMostKOdds(K)-atMostKOdds(K-1)\\n        /*\\n            return atMostKOdds(nums, k)-atMostKOdds(nums, k-1);\\n        */\\n        \\n        // Approach 3 : [ACCEPTED]\\n        // Based on using two sliding windows\\n        // Keep track of longest and shortest subarrays ending at index \\'r\\' with K odd numbers.\\n        // Add up their difference in length\\n        \\n        int l1 = 0, l2 = 0;\\n        int r1 = 0, r2 = 0;\\n        int odds1 = 0, odds2 = 0;\\n        int ans = 0;\\n        \\n        for (; r1<nums.size(); r1++, r2++) {\\n            if (nums[r1]&1)\\n                odds1++;\\n            if (nums[r2]&1)\\n                odds2++;\\n            while (odds1>k) {\\n                if (nums[l1]&1)\\n                    odds1--;\\n                l1++;\\n            }\\n            while (odds2>=k) {\\n                if (nums[l2]&1) \\n                    odds2--;\\n                l2++;\\n            }\\n            ans += l2-l1;\\n        }\\n        return ans;      \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int atMostKOdds(vector<int>& nums, int k) {\\n        int l = 0, r = 0;\\n        int odds = 0;\\n        int result = 0;\\n        for (; r < nums.size(); r++) {\\n            if (nums[r]&1)\\n                odds++;\\n            while (odds>k) {\\n                if (nums[l]&1)\\n                    odds--;\\n                l++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 625894,
                "title": "python-2-lines",
                "content": "```accumulate([x%2 for x in nums], initial=0)``` calcuates prefix, turns [3,3,4] into [0,1,2,2], for example.\\n```prefix[odd_count] * prefix[odd_count-k]``` calcualtes the subarray counts for prefixes with each odd_count value.\\n\\n\\n```\\ndef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n    prefix = Counter(accumulate([x%2 for x in nums], initial=0))\\n    return sum(prefix[odd_count] * prefix[odd_count-k] for odd_count in prefix)\\n```",
                "solutionTags": [],
                "code": "```accumulate([x%2 for x in nums], initial=0)```\n```prefix[odd_count] * prefix[odd_count-k]```\n```\\ndef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n    prefix = Counter(accumulate([x%2 for x in nums], initial=0))\\n    return sum(prefix[odd_count] * prefix[odd_count-k] for odd_count in prefix)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 552854,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int count = 0;\\n        int l = 0;\\n        int r = 0;\\n        int oddCount = 0;\\n        int size = nums.size();\\n        while (r < size) {\\n            while (oddCount < k && r < size) {\\n                if (nums[r] % 2 != 0) {\\n                    oddCount++;\\n                }\\n                r++;\\n            }\\n            int c1 = 1;\\n            while (r < size && nums[r] % 2 == 0) {\\n                r++;\\n                c1++;\\n            } \\n            int c2 = 0;\\n            while (oddCount == k && l < r) {\\n                if (nums[l] % 2 != 0) {\\n                    oddCount--;\\n                }\\n                l++;\\n                c2++;\\n            }\\n            count += c1 * c2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int count = 0;\\n        int l = 0;\\n        int r = 0;\\n        int oddCount = 0;\\n        int size = nums.size();\\n        while (r < size) {\\n            while (oddCount < k && r < size) {\\n                if (nums[r] % 2 != 0) {\\n                    oddCount++;\\n                }\\n                r++;\\n            }\\n            int c1 = 1;\\n            while (r < size && nums[r] % 2 == 0) {\\n                r++;\\n                c1++;\\n            } \\n            int c2 = 0;\\n            while (oddCount == k && l < r) {\\n                if (nums[l] % 2 != 0) {\\n                    oddCount--;\\n                }\\n                l++;\\n                c2++;\\n            }\\n            count += c1 * c2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443122,
                "title": "c-simplest-solution-ever",
                "content": "```\\n int numberOfSubarrays(vector<int>& nums, int k) {\\n         unordered_map<int,int>m;\\n         int res=0,cnt=0;\\n         m[0]=1;\\n \\xA0 \\xA0 \\xA0 \\xA0 for(int i : nums)\\n         {\\n             cnt+=(i%2);\\n             res+=m[cnt-k];\\n             m[cnt]++;\\n         }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int numberOfSubarrays(vector<int>& nums, int k) {\\n         unordered_map<int,int>m;\\n         int res=0,cnt=0;\\n         m[0]=1;\\n \\xA0 \\xA0 \\xA0 \\xA0 for(int i : nums)\\n         {\\n             cnt+=(i%2);\\n             res+=m[cnt-k];\\n             m[cnt]++;\\n         }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 423675,
                "title": "python-solution-beats-99",
                "content": "There is a simple solution, by enumerate list and count the combinations of numbers.\\n\\n```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        # count\\n        arr = []\\n        for i, x in enumerate(nums):\\n            if x % 2 != 0:\\n                arr.append(i)   \\n        arr.append(len(nums))\\n        \\n        # not satisify\\n        if len(arr) <= k:\\n            return 0\\n        \\n        # calculate\\n        count = 0\\n        count +=  (arr[0] + 1) * (arr[k] - arr[k-1])\\n        for i in range(k+1, len(arr)):\\n            count += (arr[i-k] - arr[i-k-1]) * (arr[i] - arr[i-1])\\n            \\n        return count \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        # count\\n        arr = []\\n        for i, x in enumerate(nums):\\n            if x % 2 != 0:\\n                arr.append(i)   \\n        arr.append(len(nums))\\n        \\n        # not satisify\\n        if len(arr) <= k:\\n            return 0\\n        \\n        # calculate\\n        count = 0\\n        count +=  (arr[0] + 1) * (arr[k] - arr[k-1])\\n        for i in range(k+1, len(arr)):\\n            count += (arr[i-k] - arr[i-k-1]) * (arr[i] - arr[i-1])\\n            \\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 421003,
                "title": "python-straightforward-solution",
                "content": "Straightforward Solution: similar to the idea in [the solution for 828. Unique Letter String](https://leetcode.com/problems/unique-letter-string/discuss/128952/One-pass-O(N)-Straight-Forward)\\n```\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        lst = [-1]\\n        for i in range(len(nums)):\\n            if nums[i] % 2:\\n                lst.append(i)\\n        lst.append(len(nums))\\n        res = 0\\n        for i in range(1, len(lst) - k):\\n\\t\\t    # plus the number of windows containing [lst[i], lst[i+k-1]]\\n            res += (lst[i] - lst[i-1]) * (lst[i+k] - lst[i+k-1])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        lst = [-1]\\n        for i in range(len(nums)):\\n            if nums[i] % 2:\\n                lst.append(i)\\n        lst.append(len(nums))\\n        res = 0\\n        for i in range(1, len(lst) - k):\\n\\t\\t    # plus the number of windows containing [lst[i], lst[i+k-1]]\\n            res += (lst[i] - lst[i-1]) * (lst[i+k] - lst[i+k-1])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 419615,
                "title": "java-prefix-array-approach-explained",
                "content": "For each index count is the number increase index of prefix array if it is odd. Increase the value of the prefix array for every element. prefix[0] denotes the number of elements of nums we traversed to get the first odd number. \\n\\nLets take the example nums= 2 2 2 1 2 2 1 2 2 2\\nprefix = 4 3 3 0 0 ....\\n\\nWe found 1st odd number at index 3 so we travesed 4 indexes and similarly second odd number is at index 6 so prefix[1] is 3. Now since k=2 we can start making subarrays. At index 6 we can have 4 subarrays starting at index 0,1,2 or 3 and including index 6 similarly for index we have 4 subarrays and so on.\\n```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) \\n    {\\n        int count=0;\\n        int odd=0;\\n        int ans=0;\\n        int prefix[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            prefix[odd]++;\\n            if(nums[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n            if(odd>=k)\\n            {\\n                ans+=prefix[odd-k];\\n            }\\n        }\\n        for(int i:prefix)\\n            System.out.print(i+\" \");\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) \\n    {\\n        int count=0;\\n        int odd=0;\\n        int ans=0;\\n        int prefix[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            prefix[odd]++;\\n            if(nums[i]%2!=0)\\n            {\\n                odd++;\\n            }\\n            if(odd>=k)\\n            {\\n                ans+=prefix[odd-k];\\n            }\\n        }\\n        for(int i:prefix)\\n            System.out.print(i+\" \");\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419319,
                "title": "o-n-solution",
                "content": "In the example [2,2,2,1,2,2,1,2,2,2] for k = 2 the first element of a nice subarray can be the first 1 or any 2 before it and the last element can be the second 1 or any 2 after it. We transform this array to [4,3,4] (every number in the new array is the length of subarray of even numbers plus 1). The answer is 16 = 4 (any of the 3 even numbers + 1 odd number at the right end of subarray of even numbers) * 4 (1 odd number at the left end of subarray + any of the 3 even numbers). In general case the distance between multipliers is k for resulting subarray to contain exactly k odd numbers.\\n\\n\\n```\\n    int numberOfSubarrays(vector<int>& nums, int k)\\n    {\\n        int count = 0;\\n        vector<int> groups;\\n        groups.push_back(1);\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] % 2 == 1) groups.push_back(1);\\n            else groups.back()++;\\n        }\\n        for (int i = k; i < groups.size(); i++)\\n            count += groups[i - k] * groups[i];\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numberOfSubarrays(vector<int>& nums, int k)\\n    {\\n        int count = 0;\\n        vector<int> groups;\\n        groups.push_back(1);\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] % 2 == 1) groups.push_back(1);\\n            else groups.back()++;\\n        }\\n        for (int i = k; i < groups.size(); i++)\\n            count += groups[i - k] * groups[i];\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968413,
                "title": "easy-c-solution-using-an-array-in-o-n-time",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nWe will be storing all the indices having odd number in an array and the we will be traversing that array in **window size of k** to find the number of subarrays in that specific window.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n#  **O(n)**\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n# O(n)\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int n=nums.size();\\r\\n        vector<int> res;//to store the index of odd numbers\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(nums[i]%2){\\r\\n                res.push_back(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(res.size()==0 || res.size() < k) return 0;\\r\\n        long long ans = 0;\\r\\n        int sz=res.size();\\r\\n\\r\\n        for(int i=0;i<=sz-k;i++){\\r\\n            //st is the index of the first odd number in window of size k\\r\\n            int st = res[i];\\r\\n            //end is the index of the last odd number in window of size k\\r\\n            int end = res[i+k-1];\\r\\n            //left and right are used to store the number of even behind start and after end \\r\\n            int left;int right;\\r\\n            if(i==0){\\r\\n                //if we are taking first index then no of even on left would be index+1.\\r\\n                left = res[i]+1;\\r\\n            }\\r\\n            else{\\r\\n                //to find even numbers between present odd and previous odd we will do res[i]-res[i-1];\\r\\n                left = abs(st - res[i-1]);\\r\\n            }\\r\\n\\r\\n            if((i+k-1)==sz-1) {\\r\\n                //if we are on last odd occurence then even after that number would be nums.size()-end\\r\\n                right = abs(n-end);\\r\\n            }\\r\\n            else{\\r\\n                //to find even numbers between last odd in window size of k and last+1 odd we will do res[i+k]-res[i+k-1];\\r\\n                right = abs(res[i+k] - end);\\r\\n            }\\r\\n            //for that window of size k between index i and i+k-1 ans will be left*right \\r\\n            //we will go on adding sum to get the final answer\\r\\n            ans += (left*right);\\r\\n        }\\r\\n        return ans;\\r\\n\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int n=nums.size();\\r\\n        vector<int> res;//to store the index of odd numbers\\r\\n        for(int i=0;i<n;i++){\\r\\n            if(nums[i]%2){\\r\\n                res.push_back(i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(res.size()==0 || res.size() < k) return 0;\\r\\n        long long ans = 0;\\r\\n        int sz=res.size();\\r\\n\\r\\n        for(int i=0;i<=sz-k;i++){\\r\\n            //st is the index of the first odd number in window of size k\\r\\n            int st = res[i];\\r\\n            //end is the index of the last odd number in window of size k\\r\\n            int end = res[i+k-1];\\r\\n            //left and right are used to store the number of even behind start and after end \\r\\n            int left;int right;\\r\\n            if(i==0){\\r\\n                //if we are taking first index then no of even on left would be index+1.\\r\\n                left = res[i]+1;\\r\\n            }\\r\\n            else{\\r\\n                //to find even numbers between present odd and previous odd we will do res[i]-res[i-1];\\r\\n                left = abs(st - res[i-1]);\\r\\n            }\\r\\n\\r\\n            if((i+k-1)==sz-1) {\\r\\n                //if we are on last odd occurence then even after that number would be nums.size()-end\\r\\n                right = abs(n-end);\\r\\n            }\\r\\n            else{\\r\\n                //to find even numbers between last odd in window size of k and last+1 odd we will do res[i+k]-res[i+k-1];\\r\\n                right = abs(res[i+k] - end);\\r\\n            }\\r\\n            //for that window of size k between index i and i+k-1 ans will be left*right \\r\\n            //we will go on adding sum to get the final answer\\r\\n            ans += (left*right);\\r\\n        }\\r\\n        return ans;\\r\\n\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791225,
                "title": "count-number-of-subarrays-with-exactly-k-odd-numbers-easy-solution",
                "content": "# Intuition\\r\\nThe problem requires counting the number of subarrays with exactly \\'k\\' odd numbers. To simplify the counting process, we can convert even elements in the array to 0 and odd elements to 1. This way, we only need to find subarrays with a prefix sum of \\'k\\'.\\r\\n\\r\\n\\r\\n\\r\\n# Approach\\r\\nApproach:\\r\\n\\r\\nConvert the even elements in the \\'nums\\' array to 0 and odd elements to 1.\\r\\nInitialize variables: \\'cnt\\' to count the subarrays with exactly \\'k\\' odd numbers, \\'mpp\\' as an unordered_map to store prefix sum and its occurrences, and \\'sum\\' to keep track of the prefix sum.\\r\\nIterate through the \\'nums\\' array, calculate the prefix sum, and update the \\'cnt\\' accordingly based on prefix sum \\'k\\'.\\r\\nFor each prefix sum, check if the difference \\'rem\\' (sum - k) exists in \\'mpp\\'. If so, there are subarrays with exactly \\'k\\' odd numbers ending at the current index. Update \\'cnt\\' by the number of such subarrays found in \\'mpp\\'.\\r\\nStore the current prefix sum\\'s index in \\'mpp\\'.\\r\\nReturn the final count \\'cnt\\' as the result.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\nO(n), where \\'n\\' is the size of the \\'nums\\' array, as we only need to iterate through the array once.\\r\\n\\r\\n- Space complexity:\\r\\nO(n), since the unordered_map \\'mpp\\' can have up to \\'n\\' elements.\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        // Convert even elements to 0 and odd elements to 1 in the \\'nums\\' array.\\r\\n        for (int i = 0; i < nums.size(); i++) {\\r\\n            if (nums[i] % 2 == 0) {\\r\\n                nums[i] = 0;\\r\\n            } else {\\r\\n                nums[i] = 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int cnt = 0; // Initialize the count of subarrays with exactly \\'k\\' odd numbers.\\r\\n        unordered_map<int, list<int>> mpp; // Create a map to store the prefix sum and its occurrences.\\r\\n        int sum = 0; // Initialize the prefix sum.\\r\\n\\r\\n        for (int i = 0; i < nums.size(); i++) {\\r\\n            sum += nums[i]; // Calculate the prefix sum.\\r\\n\\r\\n            if (sum == k) {\\r\\n                cnt++; // If the prefix sum equals \\'k\\', we found one subarray with exactly \\'k\\' odd numbers.\\r\\n            }\\r\\n\\r\\n            int rem = sum - k; // Calculate the difference between the current prefix sum and \\'k\\'.\\r\\n\\r\\n            // If the difference exists in the map, it means there are subarrays with exactly \\'k\\' odd numbers ending at the current index.\\r\\n            if (mpp.find(rem) != mpp.end()) {\\r\\n                cnt += mpp[rem].size(); // Increment the count by the number of such subarrays.\\r\\n            }\\r\\n\\r\\n            mpp[sum].push_back(i); // Store the current prefix sum\\'s index in the map.\\r\\n        }\\r\\n\\r\\n        return cnt; // Return the count of subarrays with exactly \\'k\\' odd numbers.\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        // Convert even elements to 0 and odd elements to 1 in the \\'nums\\' array.\\r\\n        for (int i = 0; i < nums.size(); i++) {\\r\\n            if (nums[i] % 2 == 0) {\\r\\n                nums[i] = 0;\\r\\n            } else {\\r\\n                nums[i] = 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int cnt = 0; // Initialize the count of subarrays with exactly \\'k\\' odd numbers.\\r\\n        unordered_map<int, list<int>> mpp; // Create a map to store the prefix sum and its occurrences.\\r\\n        int sum = 0; // Initialize the prefix sum.\\r\\n\\r\\n        for (int i = 0; i < nums.size(); i++) {\\r\\n            sum += nums[i]; // Calculate the prefix sum.\\r\\n\\r\\n            if (sum == k) {\\r\\n                cnt++; // If the prefix sum equals \\'k\\', we found one subarray with exactly \\'k\\' odd numbers.\\r\\n            }\\r\\n\\r\\n            int rem = sum - k; // Calculate the difference between the current prefix sum and \\'k\\'.\\r\\n\\r\\n            // If the difference exists in the map, it means there are subarrays with exactly \\'k\\' odd numbers ending at the current index.\\r\\n            if (mpp.find(rem) != mpp.end()) {\\r\\n                cnt += mpp[rem].size(); // Increment the count by the number of such subarrays.\\r\\n            }\\r\\n\\r\\n            mpp[sum].push_back(i); // Store the current prefix sum\\'s index in the map.\\r\\n        }\\r\\n\\r\\n        return cnt; // Return the count of subarrays with exactly \\'k\\' odd numbers.\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758219,
                "title": "simple-soln-am-i-the-only-one-who-thought-this-is-similar-to-binary-subarrays-with-sum-beats-92",
                "content": "# Intuition\\nPlzz Refer my soln for **Binary subarrays with sum** question here\\n[https://leetcode.com/problems/binary-subarrays-with-sum/solutions/3102433/c-sliding-window-easy-explanation/]()\\n# Approach\\nTreat the even numbers as Zeroes and odd numbers as Ones.\\nnow change the Nums array accordingly.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]&1) nums[i]=1;\\n            else nums[i]=0;\\n        }\\n        return helper(nums,k,n)-helper(nums,k-1,n);\\n    }\\n//Helper function helps to count the no of subarrays with sum less than or equal to k.\\n    int helper(vector<int>&nums,int k,int n){\\n        int count=0,sum=0,j=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            while(sum>k){\\n                sum-=nums[j++];\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]&1) nums[i]=1;\\n            else nums[i]=0;\\n        }\\n        return helper(nums,k,n)-helper(nums,k-1,n);\\n    }\\n//Helper function helps to count the no of subarrays with sum less than or equal to k.\\n    int helper(vector<int>&nums,int k,int n){\\n        int count=0,sum=0,j=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            while(sum>k){\\n                sum-=nums[j++];\\n            }\\n            count+=(i-j+1);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544150,
                "title": "java-simple-with-complete-explanation",
                "content": "# Approach\\r\\nThe provided solution employs a sliding window technique to solve the problem. Let\\'s break down the approach step by step:\\r\\n\\r\\n- Initialize variables left, right, count, max, and temp. Set len as the length of the input array nums. Here, left and right represent the left and right pointers of the sliding window, count keeps track of the number of odd numbers encountered, max stores the total count of nice subarrays, and temp is a temporary variable to count the number of nice subarrays at each position.\\r\\n\\r\\n- Start iterating through the array using the right pointer until it reaches the end of the array.\\r\\n\\r\\n- At each iteration, check if the current number at position right is odd or even. If it is odd\\r\\n-       (nums[right] % 2 == 1)\\r\\n-  increment the count by 1 to indicate the presence of an odd number in the current subarray. Reset temp to 0 to start counting the number of nice subarrays at the current position.\\r\\n\\r\\n- Inside the while loop, check if the condition of having exactly k odd numbers is satisfied \\r\\n-      (count == k). \\r\\n-   If this condition is met, it means we have found a nice subarray.\\r\\n\\r\\n- Increment temp by 1 to count the number of nice subarrays starting from the current position right.\\r\\n\\r\\n- Move the left pointer inside a nested while loop to shrink the window and find more nice subarrays. We keep moving the left pointer and decrementing the count whenever we encounter an odd number. This step ensures that we maintain exactly k odd numbers in the subarray.\\r\\n\\r\\n- After finding all possible nice subarrays starting from the current right position, add temp to max to update the total count of nice subarrays.\\r\\n\\r\\n- Finally, increment the right pointer to expand the window and continue the process until we reach the end of the array.\\r\\n\\r\\n- Return max, which represents the total number of nice subarrays.- \\r\\n\\r\\n# Complexity\\r\\n- **Time complexity:** \\r\\n\\r\\n-     O(n)\\r\\nThe time complexity of this approach is O(N), where N is the length of the input array nums. The algorithm only iterates through the array once using the sliding window technique.\\r\\n<hr>\\r\\n\\r\\n- **Space complexity:**\\r\\nslid \\r\\n-     O(1)\\r\\nThe space complexity is O(1) because no extra space is used apart from the input array and a few variables to track indices and counts.\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        int len=nums.length;\\r\\n        int left=0,right=0,count=0,max=0,temp=0;\\r\\n        while(right<len)\\r\\n        {\\r\\n            if(nums[right]%2==1)\\r\\n            {\\r\\n                count++;\\r\\n                temp=0;\\r\\n            }\\r\\n           \\r\\n            while(count==k)\\r\\n            {\\r\\n                temp++;\\r\\n                    if(nums[left]%2==1)\\r\\n                    {\\r\\n                        count--;\\r\\n                    }\\r\\n                   \\r\\n                    left++;\\r\\n            }\\r\\n            max=max+temp;\\r\\n            \\r\\n            right++;\\r\\n        }\\r\\n        return max;\\r\\n        \\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        int len=nums.length;\\r\\n        int left=0,right=0,count=0,max=0,temp=0;\\r\\n        while(right<len)\\r\\n        {\\r\\n            if(nums[right]%2==1)\\r\\n            {\\r\\n                count++;\\r\\n                temp=0;\\r\\n            }\\r\\n           \\r\\n            while(count==k)\\r\\n            {\\r\\n                temp++;\\r\\n                    if(nums[left]%2==1)\\r\\n                    {\\r\\n                        count--;\\r\\n                    }\\r\\n                   \\r\\n                    left++;\\r\\n            }\\r\\n            max=max+temp;\\r\\n            \\r\\n            right++;\\r\\n        }\\r\\n        return max;\\r\\n        \\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496223,
                "title": "two-pointer-approach-sliding-window-c-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int start = 0;\\r\\n        int ans = 0;\\r\\n        int odds = 0;\\r\\n        int i, temp = 0;\\r\\n        for( i=0; i<nums.size(); i++){\\r\\n            if(odds < k){\\r\\n                if(nums[i]%2 == 1){\\r\\n                    odds++;\\r\\n                }\\r\\n                if(odds == k) ans++;\\r\\n            }\\r\\n            else if(odds == k && nums[i]%2 == 0){\\r\\n                ans++;\\r\\n                temp++;\\r\\n            }\\r\\n            else{\\r\\n                while(nums[start] % 2 == 0){\\r\\n                    start++;\\r\\n                    ans+=(temp+1);\\r\\n                }\\r\\n                if(nums[i] % 2 == 1){\\r\\n                    temp = 0;\\r\\n                    start++;\\r\\n                    ans++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        while(start < nums.size() && nums[start] % 2 == 0 && odds == k){\\r\\n            start++;\\r\\n            ans+=(temp+1);\\r\\n        }\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int start = 0;\\r\\n        int ans = 0;\\r\\n        int odds = 0;\\r\\n        int i, temp = 0;\\r\\n        for( i=0; i<nums.size(); i++){\\r\\n            if(odds < k){\\r\\n                if(nums[i]%2 == 1){\\r\\n                    odds++;\\r\\n                }\\r\\n                if(odds == k) ans++;\\r\\n            }\\r\\n            else if(odds == k && nums[i]%2 == 0){\\r\\n                ans++;\\r\\n                temp++;\\r\\n            }\\r\\n            else{\\r\\n                while(nums[start] % 2 == 0){\\r\\n                    start++;\\r\\n                    ans+=(temp+1);\\r\\n                }\\r\\n                if(nums[i] % 2 == 1){\\r\\n                    temp = 0;\\r\\n                    start++;\\r\\n                    ans++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        while(start < nums.size() && nums[start] % 2 == 0 && odds == k){\\r\\n            start++;\\r\\n            ans+=(temp+1);\\r\\n        }\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338831,
                "title": "easy-map-must-see-easy-to-understand",
                "content": "# Code\\r\\n```\\r\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\r\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\r\\n\\r\\nstatic int fast_io = []() \\r\\n{ \\r\\n    std::ios::sync_with_stdio(false); \\r\\n    cin.tie(nullptr); \\r\\n    cout.tie(nullptr); \\r\\n    return 0; \\r\\n}();\\r\\n\\r\\n#ifdef LOCAL\\r\\n    freopen(\"input.txt\", \"r\" , stdin);\\r\\n    freopen(\"output.txt\", \"w\", stdout);\\r\\n#endif\\r\\n\\r\\nclass Solution {\\r\\npublic:\\r\\n    //for keeping the track of the no of number of subarray haveing \\r\\n    //distinct odd number count\\r\\n    unordered_map<int,int>mp;\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) \\r\\n    {\\r\\n        //initially we dont have any odd number prior to the 0 index\\r\\n        mp[0]++;\\r\\n\\r\\n        //to keep the number of subarrays having \\r\\n        //odd number exactly k times\\r\\n        int ans = 0;\\r\\n\\r\\n        int oddcount = 0;\\r\\n        for(int i=0;i<(nums.size());i++)\\r\\n        {\\r\\n            if((nums[i]%2) != 0)\\r\\n            {\\r\\n                 oddcount++;  \\r\\n            }\\r\\n            if(mp.find(oddcount - k) != mp.end())\\r\\n            {\\r\\n                ans = ans + mp[oddcount-k];\\r\\n            }              \\r\\n            mp[oddcount]++;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```\\r\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\r\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\r\\n\\r\\nstatic int fast_io = []() \\r\\n{ \\r\\n    std::ios::sync_with_stdio(false); \\r\\n    cin.tie(nullptr); \\r\\n    cout.tie(nullptr); \\r\\n    return 0; \\r\\n}();\\r\\n\\r\\n#ifdef LOCAL\\r\\n    freopen(\"input.txt\", \"r\" , stdin);\\r\\n    freopen(\"output.txt\", \"w\", stdout);\\r\\n#endif\\r\\n\\r\\nclass Solution {\\r\\npublic:\\r\\n    //for keeping the track of the no of number of subarray haveing \\r\\n    //distinct odd number count\\r\\n    unordered_map<int,int>mp;\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) \\r\\n    {\\r\\n        //initially we dont have any odd number prior to the 0 index\\r\\n        mp[0]++;\\r\\n\\r\\n        //to keep the number of subarrays having \\r\\n        //odd number exactly k times\\r\\n        int ans = 0;\\r\\n\\r\\n        int oddcount = 0;\\r\\n        for(int i=0;i<(nums.size());i++)\\r\\n        {\\r\\n            if((nums[i]%2) != 0)\\r\\n            {\\r\\n                 oddcount++;  \\r\\n            }\\r\\n            if(mp.find(oddcount - k) != mp.end())\\r\\n            {\\r\\n                ans = ans + mp[oddcount-k];\\r\\n            }              \\r\\n            mp[oddcount]++;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3254182,
                "title": "two-pointer-solution-easy",
                "content": "\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nIn this solution we basically take 2 pointers (i and j). If the nums[j] is odd we increase the odd counter. If off is equal to k we count all the subarrays in between i and j by increasing i position till odd == k. We add the result in res.\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        int i=0,j=0,odd=0,count=0,res=0;\\r\\n        while(j<nums.length){\\r\\n            if(nums[j]%2!=0){\\r\\n                odd++;\\r\\n                count=0;\\r\\n            }\\r\\n            while(odd==k){\\r\\n                if(nums[i++]%2!=0){\\r\\n                    odd--;\\r\\n                }\\r\\n                count++;\\r\\n            }\\r\\n            res+=count;\\r\\n            j++;\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int numberOfSubarrays(int[] nums, int k) {\\r\\n        int i=0,j=0,odd=0,count=0,res=0;\\r\\n        while(j<nums.length){\\r\\n            if(nums[j]%2!=0){\\r\\n                odd++;\\r\\n                count=0;\\r\\n            }\\r\\n            while(odd==k){\\r\\n                if(nums[i++]%2!=0){\\r\\n                    odd--;\\r\\n                }\\r\\n                count++;\\r\\n            }\\r\\n            res+=count;\\r\\n            j++;\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069091,
                "title": "simple-python-prefix-sum-and-hashmap-beats-90-single-pass",
                "content": "Extremely common pattern\\n\\n```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        hashmap = defaultdict(int)\\n        odd_counts,res = 0,0\\n        hashmap[0] = 1\\n        for i in range(len(nums)):\\n            if nums[i]%2 != 0:\\n                odd_counts+=1\\n            res += hashmap[odd_counts-k]\\n            hashmap[odd_counts]+=1\\n        return res",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "Extremely common pattern\\n\\n```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        hashmap = defaultdict(int)\\n        odd_counts,res = 0,0\\n        hashmap[0] = 1\\n        for i in range(len(nums)):\\n            if nums[i]%2 != 0:\\n                odd_counts+=1\\n            res += hashmap[odd_counts-k]\\n            hashmap[odd_counts]+=1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2814913,
                "title": "1248-count-number-of-nice-subarrays",
                "content": "class Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n\\t\\t#initially take these variables\\n        main_count=0\\n        temp_count=0\\n        start,end=0,0\\n        cur_subarray_count=0\\n\\t\\t\\n\\t\\t#A loop to move across whole length, ie taking window to the last\\n        while end < len(nums):\\n\\t\\t\\t#if current element is even we skip,else we increase temp_count or we can say presence of odd is encountered and added\\n            if nums[end] % 2 != 0 :\\n                temp_count += 1\\n\\t\\t\\t\\t#reset the sub_array_count\\n                cur_subarray_count=0\\n\\t\\t\\t\\t#once number of odds have become equal to k, we count number of subarrays within ie. cur_subarray_count\\n            while temp_count == k :\\n\\t\\t\\t#when an odd is encountered we reduce temp_count or the odd_count\\n                if nums[start] % 2 != 0:\\n                    temp_count -= 1\\n                cur_subarray_count+=1\\n\\t\\t\\t\\t#increment start to shrink the window\\n                start += 1\\n\\t\\t\\t#add number of sub_array count to main_count\\n            main_count += cur_subarray_count\\n            end += 1\\n        return main_count",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "class Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n\\t\\t#initially take these variables\\n        main_count=0\\n        temp_count=0\\n        start,end=0,0\\n        cur_subarray_count=0\\n\\t\\t\\n\\t\\t#A loop to move across whole length, ie taking window to the last\\n        while end < len(nums):\\n\\t\\t\\t#if current element is even we skip,else we increase temp_count or we can say presence of odd is encountered and added\\n            if nums[end] % 2 != 0 :\\n                temp_count += 1\\n\\t\\t\\t\\t#reset the sub_array_count\\n                cur_subarray_count=0\\n\\t\\t\\t\\t#once number of odds have become equal to k, we count number of subarrays within ie. cur_subarray_count\\n            while temp_count == k :\\n\\t\\t\\t#when an odd is encountered we reduce temp_count or the odd_count\\n                if nums[start] % 2 != 0:\\n                    temp_count -= 1\\n                cur_subarray_count+=1\\n\\t\\t\\t\\t#increment start to shrink the window\\n                start += 1\\n\\t\\t\\t#add number of sub_array count to main_count\\n            main_count += cur_subarray_count\\n            end += 1\\n        return main_count",
                "codeTag": "Java"
            },
            {
                "id": 2774830,
                "title": "python-prefix-sum-solution",
                "content": "```\\ndef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n\\tremainders = []\\n\\trem = 0\\n\\tnum_subarray = 0\\n\\tfor num in nums:\\n\\t\\trem += num % 2\\n\\t\\tremainders.append(rem)\\n\\tprefix = {0: 1}\\n\\tfor remainder in remainders:\\n\\t\\tif remainder - k in prefix:\\n\\t\\t\\tnum_subarray += prefix[remainder - k]\\n\\t\\tif remainder not in prefix:\\n\\t\\t\\tprefix[remainder] =1\\n\\t\\telse:\\n\\t\\t\\tprefix[remainder] += 1\\n\\treturn num_subarray",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\ndef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n\\tremainders = []\\n\\trem = 0\\n\\tnum_subarray = 0\\n\\tfor num in nums:\\n\\t\\trem += num % 2\\n\\t\\tremainders.append(rem)\\n\\tprefix = {0: 1}\\n\\tfor remainder in remainders:\\n\\t\\tif remainder - k in prefix:\\n\\t\\t\\tnum_subarray += prefix[remainder - k]\\n\\t\\tif remainder not in prefix:\\n\\t\\t\\tprefix[remainder] =1\\n\\t\\telse:\\n\\t\\t\\tprefix[remainder] += 1\\n\\treturn num_subarray",
                "codeTag": "Python3"
            },
            {
                "id": 2676369,
                "title": "simple-maths-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int numberOfSubarrays(vector<int> &nums, int k)\\n        {\\n\\n            long ans = 0;\\n            vector<int> vec;\\n            for (int end = 0; end < nums.size(); end++)\\n            {\\n                if ((nums[end] &1) == 1)\\n                    vec.push_back(end);\\n            }\\n            int start = 0;\\n            int end = k - 1;\\n            while (end < vec.size())\\n            {\\n\\n                int left, right;\\n                if (start == 0) left = vec[start];\\n                else left = vec[start] - vec[start - 1] - 1;\\n\\n                if (end == vec.size() - 1) right = nums.size() - vec[end] - 1;\\n                else right = vec[end + 1] - vec[end] - 1;\\n\\n                if (left + right == 0)\\n                    ans += 1;\\n                else\\n                    ans += (left + 1) *(right + 1);\\n\\n                start += 1;\\n                end += 1;\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int numberOfSubarrays(vector<int> &nums, int k)\\n        {\\n\\n            long ans = 0;\\n            vector<int> vec;\\n            for (int end = 0; end < nums.size(); end++)\\n            {\\n                if ((nums[end] &1) == 1)\\n                    vec.push_back(end);\\n            }\\n            int start = 0;\\n            int end = k - 1;\\n            while (end < vec.size())\\n            {\\n\\n                int left, right;\\n                if (start == 0) left = vec[start];\\n                else left = vec[start] - vec[start - 1] - 1;\\n\\n                if (end == vec.size() - 1) right = nums.size() - vec[end] - 1;\\n                else right = vec[end + 1] - vec[end] - 1;\\n\\n                if (left + right == 0)\\n                    ans += 1;\\n                else\\n                    ans += (left + 1) *(right + 1);\\n\\n                start += 1;\\n                end += 1;\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537180,
                "title": "c-solution-sliding-window",
                "content": "```\\nclass Solution {\\n  public:\\n    int numberOfSubarrays(vector < int > & nums, int k) {\\n      int ans = 0;\\n      int n = nums.size();\\n      int oddCount = 0;\\n      int slidingEnd = 0, slidingStart = 0;\\n      queue < int > q;\\n      while (slidingEnd < n) {\\n        if (nums[slidingEnd] % 2 != 0) {\\n          ++oddCount;\\n          q.push(slidingEnd);\\n        }\\n        if (oddCount > k) {\\n          while (oddCount != k) {\\n            if (nums[slidingStart] % 2 != 0) --oddCount;\\n            ++slidingStart;\\n          }\\n          q.pop();\\n        }\\n        if (oddCount == k) ans += (q.front() - slidingStart + 1);\\n        ++slidingEnd;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    int numberOfSubarrays(vector < int > & nums, int k) {\\n      int ans = 0;\\n      int n = nums.size();\\n      int oddCount = 0;\\n      int slidingEnd = 0, slidingStart = 0;\\n      queue < int > q;\\n      while (slidingEnd < n) {\\n        if (nums[slidingEnd] % 2 != 0) {\\n          ++oddCount;\\n          q.push(slidingEnd);\\n        }\\n        if (oddCount > k) {\\n          while (oddCount != k) {\\n            if (nums[slidingStart] % 2 != 0) --oddCount;\\n            ++slidingStart;\\n          }\\n          q.pop();\\n        }\\n        if (oddCount == k) ans += (q.front() - slidingStart + 1);\\n        ++slidingEnd;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498838,
                "title": "java-solution-using-sliding-window-explained",
                "content": "**Upvote If this Helped You**\\n```\\n\\n// [2,2,2,1,2,2,1,2,2,2] k-2\\n// [0,1,2,3,4,5,6,7,8,9] -> index\\n\\n// when ws is at index 6 odd==k. So the number of sub array are 4 (0,6),(1,6),(2,6),(3,6) , cur_subcount=4\\n    \\n// no the cur_subcount come into play when ws=7 the subarray from 0->7 are (0,7),(1,7),(2,7),(3,7) =4\\n\\n// when ws=8 the subarray from 0->7 are (0,8),(1,8),(2,8),(3,8) =4,  ... and like this  upto ws=9\\n\\n// so total subarrays possible =4+4+4+4=16\\n\\nclass Solution \\n{\\n    public int numberOfSubarrays(int[] nums, int k) \\n    {\\n        int ws=0,we=0,ans=0,odd=0,cur_subcount=0;\\n        \\n        while(ws<nums.length)\\n        {\\n            if(nums[ws]%2!=0)\\n            {\\n                odd++;\\n                cur_subcount=0;\\n            }\\n            \\n             // time to reduce the window length and find the no. of subarrays\\n            \\n            while(odd==k)\\n            {\\n                if(nums[we]%2!=0)\\n                    odd--;\\n                \\n                cur_subcount+=1;\\n                we++;\\n            }\\n            \\n            ans+=cur_subcount;  // Total possible subarrays\\n            ws++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n\\n// [2,2,2,1,2,2,1,2,2,2] k-2\\n// [0,1,2,3,4,5,6,7,8,9] -> index\\n\\n// when ws is at index 6 odd==k. So the number of sub array are 4 (0,6),(1,6),(2,6),(3,6) , cur_subcount=4\\n    \\n// no the cur_subcount come into play when ws=7 the subarray from 0->7 are (0,7),(1,7),(2,7),(3,7) =4\\n\\n// when ws=8 the subarray from 0->7 are (0,8),(1,8),(2,8),(3,8) =4,  ... and like this  upto ws=9\\n\\n// so total subarrays possible =4+4+4+4=16\\n\\nclass Solution \\n{\\n    public int numberOfSubarrays(int[] nums, int k) \\n    {\\n        int ws=0,we=0,ans=0,odd=0,cur_subcount=0;\\n        \\n        while(ws<nums.length)\\n        {\\n            if(nums[ws]%2!=0)\\n            {\\n                odd++;\\n                cur_subcount=0;\\n            }\\n            \\n             // time to reduce the window length and find the no. of subarrays\\n            \\n            while(odd==k)\\n            {\\n                if(nums[we]%2!=0)\\n                    odd--;\\n                \\n                cur_subcount+=1;\\n                we++;\\n            }\\n            \\n            ans+=cur_subcount;  // Total possible subarrays\\n            ws++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170085,
                "title": "simple-java-solution-based-o-n-and-space-o-n-based-on-leetcode-560",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,1);\\n        int sum = 0, result = 0;\\n        for(int val: nums){\\n            sum += val%2;\\n            int d = sum - k;\\n            if(map.containsKey(d))\\n                result += map.get(d);\\n            map.put(sum, map.getOrDefault(sum, 0)+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,1);\\n        int sum = 0, result = 0;\\n        for(int val: nums){\\n            sum += val%2;\\n            int d = sum - k;\\n            if(map.containsKey(d))\\n                result += map.get(d);\\n            map.put(sum, map.getOrDefault(sum, 0)+1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148579,
                "title": "permutation-based-c-solution-o-n-time-and-space",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) \\n    {\\n        int numberOfSubs = 0;\\n        std::vector<int> oddLocations;\\n        \\n        // add every odd number\\'s index to the oddLocations vector\\n\\t\\t// pad the beginning and ends of the oddLocations vector with \\'pseudo\\' locations \\n        oddLocations.push_back(-1);\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 != 0)\\n            {\\n                // the number is odd\\n                oddLocations.push_back(i);\\n            }\\n        }\\n        oddLocations.push_back(nums.size());\\n        \\n        int start = 1;\\n        int end = k;\\n        int rightEvens;\\n        int leftEvens;\\n\\t\\t// loop through the oddLocations and add the permutations of each k-odd number setup\\n        while(end < oddLocations.size() - 1)\\n        {\\n            numberOfSubs += (oddLocations[end + 1] - oddLocations[end]) * (oddLocations[start] - oddLocations[start - 1]);\\n            start++;\\n            end++;\\n        }\\n        \\n        return numberOfSubs;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) \\n    {\\n        int numberOfSubs = 0;\\n        std::vector<int> oddLocations;\\n        \\n        // add every odd number\\'s index to the oddLocations vector\\n\\t\\t// pad the beginning and ends of the oddLocations vector with \\'pseudo\\' locations \\n        oddLocations.push_back(-1);\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 != 0)\\n            {\\n                // the number is odd\\n                oddLocations.push_back(i);\\n            }\\n        }\\n        oddLocations.push_back(nums.size());\\n        \\n        int start = 1;\\n        int end = k;\\n        int rightEvens;\\n        int leftEvens;\\n\\t\\t// loop through the oddLocations and add the permutations of each k-odd number setup\\n        while(end < oddLocations.size() - 1)\\n        {\\n            numberOfSubs += (oddLocations[end + 1] - oddLocations[end]) * (oddLocations[start] - oddLocations[start - 1]);\\n            start++;\\n            end++;\\n        }\\n        \\n        return numberOfSubs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079386,
                "title": "c-using-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==0){\\n                nums[i] =0;\\n            }else{\\n                nums[i] = 1;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            if(mp.find(sum-k)!=mp.end()){\\n                ans+=mp[sum-k];\\n            }\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==0){\\n                nums[i] =0;\\n            }else{\\n                nums[i] = 1;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            if(mp.find(sum-k)!=mp.end()){\\n                ans+=mp[sum-k];\\n            }\\n            mp[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024075,
                "title": "go-solution-w-comments-diagram",
                "content": "```\\n/*\\nExample\\n\\nnums := []int{2, 2, 2, 1, 2, 2, 1, 2, 2, 2}\\nk := 2\\n\\nAlgorithm: Sliding Window (2 pointers)\\n- Outer loop keeps incrementing window end until k odd numbers are found, every time an odd number is found we reset our nice count (case 1)\\n- If k odd numbers are found, in an inner loop, increment nice subbarrays and shift window start until an odd number is popped off (making oddCount < k)\\n- Finally, add the number of nice subarrays to the result (case 1 or case 2)\\n\\ncase1: add all the nice counted subarrays to the total count\\ncase2: encountered a new even number (regardless of the current odd count)\\n       so we need to add all previous nice counted subarrays (with the new even number appended) to the total count\\n\\t   \\ncase summary: \\nultimately add all nice counted subarrays found while oddcount >= k to the total, \\nthen after oddcount if < k, for each new number that is not an odd, add all the nice counted subarrays \\nto the total. If a new odd is encountered we reset the nice counted subarrays \\nbecause that is a new combination!\\n\\n\\nnums              | []int{2, 2, 2, 1, 2, 2, 1, 2, 2, 2}\\n\\nouter-loop 00     | []int{2                           } | oddCount = 0, niceCount = 0 result = 0\\nouter-loop 01     | []int{2, 2                        } | oddCount = 0, niceCount = 0 result = 0\\nouter-loop 02     | []int{2, 2, 2                     } | oddCount = 0, niceCount = 0 result = 0\\nouter-loop 03     | []int{2, 2, 2, 1                  } | oddCount = 1, niceCount = 0 result = 0\\nouter-loop 04     | []int{2, 2, 2, 1, 2               } | oddCount = 1, niceCount = 0 result = 0\\nouter-loop 05     | []int{2, 2, 2, 1, 2, 2            } | oddCount = 1, niceCount = 0 result = 0\\nouter-loop 06     | []int{2, 2, 2, 1, 2, 2, 1         } | oddCount = 2, niceCount = 0 result = 4 // see case 1\\n    inner-loop 00 | []int{   2, 2, 1, 2, 2, 1         } | oddCount = 2, niceCount = 1 result = 0\\n    inner-loop 01 | []int{      2, 1, 2, 2, 1         } | oddCount = 2, niceCount = 2 result = 0\\n    inner-loop 02 | []int{         1, 2, 2, 1         } | oddCount = 2, niceCount = 3 result = 0\\n    inner-loop 04 | []int{            2, 2, 1         } | oddCount = 1, niceCount = 4 result = 0\\nouter-loop 07     | []int{            2, 2, 1, 2      } | oddCount = 1, niceCount = 4 result = 8  (4 + 4) see case 2!\\nouter-loop 08     | []int{            2, 2, 1, 2, 2   } | oddCount = 1, niceCount = 4 result = 12 (8 + 4)\\nouter-loop 09     | []int{            2, 2, 1, 2, 2, 2} | oddCount = 1, niceCount = 4 result = 16 (12 + 4)\\n*/\\n\\nfunc numberOfSubarrays(nums []int, k int) int {\\n    totalCount := 0\\n    oddCount := 0 // keep track of odds to see if odds == k\\n    niceCount := 0 // keep track of current nice subarrays count (reset if a new odd number is found)\\n    \\n    start := 0\\n    for end := 0; end < len(nums); end++ { // outer-loop\\n        if nums[end] % 2 != 0 {\\n            oddCount++\\n            niceCount = 0 // new odd number encountered, reset the nice subarray count\\n        }\\n        \\n        for oddCount == k { // inner-loop\\n            niceCount++\\n            \\n            if nums[start] %2 != 0 {\\n                oddCount--\\n            }\\n            start++\\n        }\\n        \\n        // case 1: we just exited our inner-loop, and we want to add the number of nice subarrays to the total\\n        // case 2: we encountered no odd number, after a prior oddCount in the inner loop and\\n        // // must add the combination the even number added to all the previous nice subarrays.\\n        totalCount += niceCount\\n    }\\n    \\n    return totalCount\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/*\\nExample\\n\\nnums := []int{2, 2, 2, 1, 2, 2, 1, 2, 2, 2}\\nk := 2\\n\\nAlgorithm: Sliding Window (2 pointers)\\n- Outer loop keeps incrementing window end until k odd numbers are found, every time an odd number is found we reset our nice count (case 1)\\n- If k odd numbers are found, in an inner loop, increment nice subbarrays and shift window start until an odd number is popped off (making oddCount < k)\\n- Finally, add the number of nice subarrays to the result (case 1 or case 2)\\n\\ncase1: add all the nice counted subarrays to the total count\\ncase2: encountered a new even number (regardless of the current odd count)\\n       so we need to add all previous nice counted subarrays (with the new even number appended) to the total count\\n\\t   \\ncase summary: \\nultimately add all nice counted subarrays found while oddcount >= k to the total, \\nthen after oddcount if < k, for each new number that is not an odd, add all the nice counted subarrays \\nto the total. If a new odd is encountered we reset the nice counted subarrays \\nbecause that is a new combination!\\n\\n\\nnums              | []int{2, 2, 2, 1, 2, 2, 1, 2, 2, 2}\\n\\nouter-loop 00     | []int{2                           } | oddCount = 0, niceCount = 0 result = 0\\nouter-loop 01     | []int{2, 2                        } | oddCount = 0, niceCount = 0 result = 0\\nouter-loop 02     | []int{2, 2, 2                     } | oddCount = 0, niceCount = 0 result = 0\\nouter-loop 03     | []int{2, 2, 2, 1                  } | oddCount = 1, niceCount = 0 result = 0\\nouter-loop 04     | []int{2, 2, 2, 1, 2               } | oddCount = 1, niceCount = 0 result = 0\\nouter-loop 05     | []int{2, 2, 2, 1, 2, 2            } | oddCount = 1, niceCount = 0 result = 0\\nouter-loop 06     | []int{2, 2, 2, 1, 2, 2, 1         } | oddCount = 2, niceCount = 0 result = 4 // see case 1\\n    inner-loop 00 | []int{   2, 2, 1, 2, 2, 1         } | oddCount = 2, niceCount = 1 result = 0\\n    inner-loop 01 | []int{      2, 1, 2, 2, 1         } | oddCount = 2, niceCount = 2 result = 0\\n    inner-loop 02 | []int{         1, 2, 2, 1         } | oddCount = 2, niceCount = 3 result = 0\\n    inner-loop 04 | []int{            2, 2, 1         } | oddCount = 1, niceCount = 4 result = 0\\nouter-loop 07     | []int{            2, 2, 1, 2      } | oddCount = 1, niceCount = 4 result = 8  (4 + 4) see case 2!\\nouter-loop 08     | []int{            2, 2, 1, 2, 2   } | oddCount = 1, niceCount = 4 result = 12 (8 + 4)\\nouter-loop 09     | []int{            2, 2, 1, 2, 2, 2} | oddCount = 1, niceCount = 4 result = 16 (12 + 4)\\n*/\\n\\nfunc numberOfSubarrays(nums []int, k int) int {\\n    totalCount := 0\\n    oddCount := 0 // keep track of odds to see if odds == k\\n    niceCount := 0 // keep track of current nice subarrays count (reset if a new odd number is found)\\n    \\n    start := 0\\n    for end := 0; end < len(nums); end++ { // outer-loop\\n        if nums[end] % 2 != 0 {\\n            oddCount++\\n            niceCount = 0 // new odd number encountered, reset the nice subarray count\\n        }\\n        \\n        for oddCount == k { // inner-loop\\n            niceCount++\\n            \\n            if nums[start] %2 != 0 {\\n                oddCount--\\n            }\\n            start++\\n        }\\n        \\n        // case 1: we just exited our inner-loop, and we want to add the number of nice subarrays to the total\\n        // case 2: we encountered no odd number, after a prior oddCount in the inner loop and\\n        // // must add the combination the even number added to all the previous nice subarrays.\\n        totalCount += niceCount\\n    }\\n    \\n    return totalCount\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1950812,
                "title": "python-all-approaches-explained-with-notes-80-faster",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    Firstly I can think of a brute force approach that will have time complexity of O(n^3)\\n    The idea is to exhaust all the possible subarrays and then find the ones having k odd numbers\\n    if subarray has k odd numbers, add 1 to count\\n    The outer loop will signify the subarray ending at i\\n    The inner loop will signify the subarray starting at j\\n    The innermost loop will be used to calculate the number of odd terms in subarray nums[j..i]\\n    return the count\\n    \\n    Once I thought of above approach, we can try to remove the innermost loop by storing the \\n    number of odd numbers till nums[i] position in another array and use that array for lookup\\n    dp[i] will signify the number of odd numbers till nums[i]\\n    Then we can have the running time complexity of O(n^2)\\n    we need to find indexes where dp[i] - dp[j] == k where i ranges from 0 to len(nums) \\n    and j ranges from 0 to i\\n    \\n    Third approach:\\n    we can identify the number of subarrays in a single pass\\n    keep track of the indexes where odd no has occured.\\n    basically, we need to keep track of the first odd occurence (of the k odd numbers)\\n    and one previous to the first odd occurence (of the k odd numbers)\\n    example: 1 2 2 1 1 2 1\\n    k = 2\\n    we will start iterating, \\n    for i = 0, odd_indices = [0]\\n    for i = 1, odd_indices = [0]\\n    for i = 2, odd_indices = [0, 3]\\n        since len(odd_indices) == k:\\n        count+=1\\n    for i = 3, odd_indices = [0, 3, 4]\\n        since len(odd_indices) > k:\\n            update j = min(odd_indices) #j = 0\\n            odd_indices.pop(j)\\n            count += odd_indices[0] - j\\n    for i = 4, odd_indices = [3, 4]\\n        count += odd_indices[0] - j # 3 - 0\\n        \\n    for i = 5, odd_indices = [3, 4, 6]\\n        since len(odd_indices) > k:\\n            update j = min(odd_indices) # j= 3\\n            odd_indices.pop(j)\\n            count += odd_indices[0] - j # 4 - 3\\n    \"\"\"\\n    # O(n^3) approach\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(nums)+1)]\\n        for i in range(1, len(nums)+1):\\n            if nums[i-1] % 2 != 0:\\n                dp[i] = dp[i-1] + 1\\n            else:\\n                dp[i] = dp[i-1]\\n        count = 0\\n        for i in range(1, len(nums)+1):\\n            for j in range(1, i+1):\\n                if dp[i] - dp[j-1] == k:\\n                    count+=1\\n                elif dp[i] - dp[j-1] <k:\\n                    break\\n        return count\\n    \\n    #--------------------------\\n    # O(n^2) approach\\n    #---------------------------\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        odd_count_so_far = 0\\n        seen_k_odd = False\\n        for i in range(len(nums)):\\n            if nums[i] % 2 != 0:\\n                # nums[i] is odd then check the odd_count seen so far\\n                odd_count_so_far += 1\\n                if odd_count_so_far == k:\\n                    count = count + 1 \\n                elif odd_count_so_far > k:\\n                    \\n                if seen_k_odd:\\n                    count = count + odd_count_so_far\\n                if not seen_k_odd:\\n                    odd_count_so_far+=1\\n                    if odd_count_so_far == k:\\n                        count+=1\\n                        seen_k_odd = True\\n    \\n    #----------------------\\n    # O(n) approach\\n    #----------------------\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        j = -1\\n        odd_indices = []\\n        count = 0\\n        for i in range(len(nums)):\\n            if nums[i] % 2 != 0:\\n                odd_indices.append(i)\\n            if len(odd_indices) == k:\\n                count += odd_indices[0] - j\\n            elif len(odd_indices) > k:\\n                j = odd_indices[0]\\n                odd_indices.pop(0)\\n                count += odd_indices[0] - j\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    Firstly I can think of a brute force approach that will have time complexity of O(n^3)\\n    The idea is to exhaust all the possible subarrays and then find the ones having k odd numbers\\n    if subarray has k odd numbers, add 1 to count\\n    The outer loop will signify the subarray ending at i\\n    The inner loop will signify the subarray starting at j\\n    The innermost loop will be used to calculate the number of odd terms in subarray nums[j..i]\\n    return the count\\n    \\n    Once I thought of above approach, we can try to remove the innermost loop by storing the \\n    number of odd numbers till nums[i] position in another array and use that array for lookup\\n    dp[i] will signify the number of odd numbers till nums[i]\\n    Then we can have the running time complexity of O(n^2)\\n    we need to find indexes where dp[i] - dp[j] == k where i ranges from 0 to len(nums) \\n    and j ranges from 0 to i\\n    \\n    Third approach:\\n    we can identify the number of subarrays in a single pass\\n    keep track of the indexes where odd no has occured.\\n    basically, we need to keep track of the first odd occurence (of the k odd numbers)\\n    and one previous to the first odd occurence (of the k odd numbers)\\n    example: 1 2 2 1 1 2 1\\n    k = 2\\n    we will start iterating, \\n    for i = 0, odd_indices = [0]\\n    for i = 1, odd_indices = [0]\\n    for i = 2, odd_indices = [0, 3]\\n        since len(odd_indices) == k:\\n        count+=1\\n    for i = 3, odd_indices = [0, 3, 4]\\n        since len(odd_indices) > k:\\n            update j = min(odd_indices) #j = 0\\n            odd_indices.pop(j)\\n            count += odd_indices[0] - j\\n    for i = 4, odd_indices = [3, 4]\\n        count += odd_indices[0] - j # 3 - 0\\n        \\n    for i = 5, odd_indices = [3, 4, 6]\\n        since len(odd_indices) > k:\\n            update j = min(odd_indices) # j= 3\\n            odd_indices.pop(j)\\n            count += odd_indices[0] - j # 4 - 3\\n    \"\"\"\\n    # O(n^3) approach\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(nums)+1)]\\n        for i in range(1, len(nums)+1):\\n            if nums[i-1] % 2 != 0:\\n                dp[i] = dp[i-1] + 1\\n            else:\\n                dp[i] = dp[i-1]\\n        count = 0\\n        for i in range(1, len(nums)+1):\\n            for j in range(1, i+1):\\n                if dp[i] - dp[j-1] == k:\\n                    count+=1\\n                elif dp[i] - dp[j-1] <k:\\n                    break\\n        return count\\n    \\n    #--------------------------\\n    # O(n^2) approach\\n    #---------------------------\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        odd_count_so_far = 0\\n        seen_k_odd = False\\n        for i in range(len(nums)):\\n            if nums[i] % 2 != 0:\\n                # nums[i] is odd then check the odd_count seen so far\\n                odd_count_so_far += 1\\n                if odd_count_so_far == k:\\n                    count = count + 1 \\n                elif odd_count_so_far > k:\\n                    \\n                if seen_k_odd:\\n                    count = count + odd_count_so_far\\n                if not seen_k_odd:\\n                    odd_count_so_far+=1\\n                    if odd_count_so_far == k:\\n                        count+=1\\n                        seen_k_odd = True\\n    \\n    #----------------------\\n    # O(n) approach\\n    #----------------------\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        j = -1\\n        odd_indices = []\\n        count = 0\\n        for i in range(len(nums)):\\n            if nums[i] % 2 != 0:\\n                odd_indices.append(i)\\n            if len(odd_indices) == k:\\n                count += odd_indices[0] - j\\n            elif len(odd_indices) > k:\\n                j = odd_indices[0]\\n                odd_indices.pop(0)\\n                count += odd_indices[0] - j\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701501,
                "title": "java-o-n-sliding-window-clear-solution-similar-to-lc930-and-lc992",
                "content": "This question is similar to lc930 and lc992. Please upvote if you find it useful! Or leave comments or suggestions below!\\nI will try my best to answer them! Thank you so much!\\n\\n```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        return niceSubarraysAtMostK(nums, k) - niceSubarraysAtMostK(nums, k-1);\\n    }\\n    \\n    private int niceSubarraysAtMostK(int[] nums, int k) {\\n        int numOfOdd = 0, left = 0, right = 0;\\n        int numOfNiceArrays = 0;\\n        \\n        while (right < nums.length) {\\n            int rightNum = nums[right++];\\n            if ((rightNum & 1) == 1) numOfOdd++;\\n            \\n            while (left < right && numOfOdd > k) {\\n                int leftNum = nums[left++];\\n                if ((leftNum & 1) == 1) numOfOdd--;\\n            }\\n            \\n            numOfNiceArrays += (right - left);\\n        }\\n        \\n        return numOfNiceArrays;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        return niceSubarraysAtMostK(nums, k) - niceSubarraysAtMostK(nums, k-1);\\n    }\\n    \\n    private int niceSubarraysAtMostK(int[] nums, int k) {\\n        int numOfOdd = 0, left = 0, right = 0;\\n        int numOfNiceArrays = 0;\\n        \\n        while (right < nums.length) {\\n            int rightNum = nums[right++];\\n            if ((rightNum & 1) == 1) numOfOdd++;\\n            \\n            while (left < right && numOfOdd > k) {\\n                int leftNum = nums[left++];\\n                if ((leftNum & 1) == 1) numOfOdd--;\\n            }\\n            \\n            numOfNiceArrays += (right - left);\\n        }\\n        \\n        return numOfNiceArrays;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673709,
                "title": "python-easy-solution-using-the-concept-of-sliding-window-100-less-memory-usage",
                "content": "\\tdef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        \\n        # This is just converting the even number to 0 and odd numbers to 1 in the array\\n        for i in range(len(nums)):\\n            \\n            if nums[i] % 2 == 0:\\n                nums[i] = 0\\n            else:\\n                nums[i] = 1\\n                \\n        # Then doing exactly the same thing as subarray sum equal k problem\\n                \\n        currsum = 0\\n        subarray = 0\\n        hashmap = {}\\n        \\n        for num in nums:\\n            currsum += num\\n            \\n            if currsum == k:\\n                subarray += 1\\n            \\n            if currsum - k in hashmap:\\n                subarray += hashmap[currsum - k]\\n            \\n            if currsum in hashmap:\\n                hashmap[currsum] += 1\\n            \\n            else:\\n                hashmap[currsum] = 1\\n        \\n        return subarray\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "\\tdef numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        \\n        # This is just converting the even number to 0 and odd numbers to 1 in the array\\n        for i in range(len(nums)):\\n            \\n            if nums[i] % 2 == 0:\\n                nums[i] = 0\\n            else:\\n                nums[i] = 1\\n                \\n        # Then doing exactly the same thing as subarray sum equal k problem\\n                \\n        currsum = 0\\n        subarray = 0\\n        hashmap = {}\\n        \\n        for num in nums:\\n            currsum += num\\n            \\n            if currsum == k:\\n                subarray += 1\\n            \\n            if currsum - k in hashmap:\\n                subarray += hashmap[currsum - k]\\n            \\n            if currsum in hashmap:\\n                hashmap[currsum] += 1\\n            \\n            else:\\n                hashmap[currsum] = 1\\n        \\n        return subarray\\n            \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1642587,
                "title": "javascript-solution",
                "content": "```\\nvar numberOfSubarrays = function(nums, k) {\\n    // similar to Question https://leetcode.com/problems/subarray-sum-equals-k/\\n   let map = new Map();\\n    map.set(0, 1);\\n    let sum = 0;\\n    let counter =0;\\n    let len = nums.length;\\n    for(let g=0; g<len; g++){\\n        let curNumModified = (nums[g] %2 == 0) ? 0 : 1;\\n        sum = sum + curNumModified;\\n        if( map.has(sum-k) ) counter = map.get(sum-k)  + counter;\\n        if(map.has(sum)) map.set(sum, map.get(sum) + 1);\\n        else map.set(sum, 1)\\n    }\\n    return counter\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberOfSubarrays = function(nums, k) {\\n    // similar to Question https://leetcode.com/problems/subarray-sum-equals-k/\\n   let map = new Map();\\n    map.set(0, 1);\\n    let sum = 0;\\n    let counter =0;\\n    let len = nums.length;\\n    for(let g=0; g<len; g++){\\n        let curNumModified = (nums[g] %2 == 0) ? 0 : 1;\\n        sum = sum + curNumModified;\\n        if( map.has(sum-k) ) counter = map.get(sum-k)  + counter;\\n        if(map.has(sum)) map.set(sum, map.get(sum) + 1);\\n        else map.set(sum, 1)\\n    }\\n    return counter\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600149,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int ws = 0,we = 0,c = 0,res = 0,n = nums.size(),odd = 0;\\n        while(we<n){\\n            if(nums[we]%2) odd++;\\n            while(odd>k){\\n                if(nums[ws]%2){\\n                    odd--;\\n                    c = 0;\\n                }\\n                ws++;\\n            }\\n            while(odd == k && nums[ws]%2 == 0){\\n                ws++;\\n                c++;\\n            }\\n            if(odd == k){\\n                res+=c+1;\\n            }\\n            we++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int ws = 0,we = 0,c = 0,res = 0,n = nums.size(),odd = 0;\\n        while(we<n){\\n            if(nums[we]%2) odd++;\\n            while(odd>k){\\n                if(nums[ws]%2){\\n                    odd--;\\n                    c = 0;\\n                }\\n                ws++;\\n            }\\n            while(odd == k && nums[ws]%2 == 0){\\n                ws++;\\n                c++;\\n            }\\n            if(odd == k){\\n                res+=c+1;\\n            }\\n            we++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374009,
                "title": "simple-java-solution",
                "content": "public int numberOfSubarrays(int[] nums, int k) {\\n        //sub array with at most K = subsrray with ATMOST(k) - subarray with ATMOST(k-1)\\n        int ans = func(nums,k) - func(nums,k-1);\\n        return ans;\\n    }\\n    \\n    public int func(int[] nums,int k){\\n        int left = 0;\\n        int ans = 0;\\n        \\n        for(int right=0;right<nums.length;right++){\\n            //subtract whenever we find a odd number, move the sliding window towards right\\n            if(nums[right]%2 != 0){\\n                k--;\\n            }\\n            \\n            //if subarray contains more than required odd numbers, move the array from left\\n            //till we have k odd elements\\n            while(k<0){\\n                if(nums[left]%2 != 0){\\n                    k++;\\n                }\\n                left++;\\n            }\\n            \\n            //will increase whenever we have atmost K odd numbers\\n            ans += right-left+1;\\n            \\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "public int numberOfSubarrays(int[] nums, int k) {\\n        //sub array with at most K = subsrray with ATMOST(k) - subarray with ATMOST(k-1)\\n        int ans = func(nums,k) - func(nums,k-1);\\n        return ans;\\n    }\\n    \\n    public int func(int[] nums,int k){\\n        int left = 0;\\n        int ans = 0;\\n        \\n        for(int right=0;right<nums.length;right++){\\n            //subtract whenever we find a odd number, move the sliding window towards right\\n            if(nums[right]%2 != 0){\\n                k--;\\n            }\\n            \\n            //if subarray contains more than required odd numbers, move the array from left\\n            //till we have k odd elements\\n            while(k<0){\\n                if(nums[left]%2 != 0){\\n                    k++;\\n                }\\n                left++;\\n            }\\n            \\n            //will increase whenever we have atmost K odd numbers\\n            ans += right-left+1;\\n            \\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1273805,
                "title": "simple-c-solution-using-two-pointers-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberofSubarraysAtmost(vector<int>nums,int k){\\n        int j=0,i=0,odd=0,count=0;\\n        int n=nums.size(); \\n        while(j<n){\\n            if(nums[j]%2!=0){odd++;}\\n            j++;\\n            while(i<j&&odd>k){\\n                \\n                if(nums[i]%2!=0)\\n                    odd--;\\n                i++;\\n            }\\n            count+=j-i;\\n        }\\n        return count;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return numberofSubarraysAtmost(nums,k)- numberofSubarraysAtmost(nums,k-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberofSubarraysAtmost(vector<int>nums,int k){\\n        int j=0,i=0,odd=0,count=0;\\n        int n=nums.size(); \\n        while(j<n){\\n            if(nums[j]%2!=0){odd++;}\\n            j++;\\n            while(i<j&&odd>k){\\n                \\n                if(nums[i]%2!=0)\\n                    odd--;\\n                i++;\\n            }\\n            count+=j-i;\\n        }\\n        return count;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return numberofSubarraysAtmost(nums,k)- numberofSubarraysAtmost(nums,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243550,
                "title": "sliding-window-approach",
                "content": "Firstly Convert the odd elements of array to 1 and even to 0.\\nThen follow the approach to find the no. of subarrays having sum equal to K\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& a, int k)\\n    {\\n        int i=0,j=0,s=0,cnt=0;\\n        while(j<a.size())\\n        {\\n            s=s+a[j];\\n            while(s>k)\\n            {\\n                s=s-a[i];\\n                i++;\\n            }\\n            cnt=cnt+(j-i+1);\\n            j++;\\n        }\\n    \\n        return cnt;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        vector<int>a;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n                a.push_back(0);\\n            else\\n                a.push_back(1);\\n        }\\n        return solve(a,k)-solve(a,k-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& a, int k)\\n    {\\n        int i=0,j=0,s=0,cnt=0;\\n        while(j<a.size())\\n        {\\n            s=s+a[j];\\n            while(s>k)\\n            {\\n                s=s-a[i];\\n                i++;\\n            }\\n            cnt=cnt+(j-i+1);\\n            j++;\\n        }\\n    \\n        return cnt;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        vector<int>a;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n                a.push_back(0);\\n            else\\n                a.push_back(1);\\n        }\\n        return solve(a,k)-solve(a,k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928352,
                "title": "same-idea-as-count-subarrays-with-sum-k-560",
                "content": "```\\n# Same idea as count subarrays with sum k #560\\nfrom collections import defaultdict\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        arr = [1 if num % 2 else 0 for num in nums]\\n        cSum, ans = 0, 0\\n        mem = defaultdict(int)\\n        mem[0] = 1\\n        for i in range(len(nums)):\\n            cSum += arr[i]\\n            # print(cSum, cSum-k, mem, ans)\\n            if (cSum-k in mem):\\n                ans += mem[cSum-k]\\n            mem[cSum] += 1\\n        # print(arr)\\n        return ans",
                "solutionTags": [],
                "code": "```\\n# Same idea as count subarrays with sum k #560\\nfrom collections import defaultdict\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        arr = [1 if num % 2 else 0 for num in nums]\\n        cSum, ans = 0, 0\\n        mem = defaultdict(int)\\n        mem[0] = 1\\n        for i in range(len(nums)):\\n            cSum += arr[i]\\n            # print(cSum, cSum-k, mem, ans)\\n            if (cSum-k in mem):\\n                ans += mem[cSum-k]\\n            mem[cSum] += 1\\n        # print(arr)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 804977,
                "title": "java-sliding-window-with-explanation",
                "content": "The approach is to first find the largest subarray with \\'k\\' odd elements and count the number of subarrays that can be formed out of this.\\n1. Loop through the array and keep a count of odd numbers\\n2. Once the odd numbers exceed k (exceed because we need largest subarry with k odd elements), calculate the total number of subarrays that can be formed.\\neg: \\narray -> 2 2 2 1 2 1 2 2 1 2, k = 2\\nindex-> 0 1 2 3 4 5 6 7 8 9\\nThe first largest subarray with 2 odd elements is from index 0 to index 7. To calculate the total subarrays, find the total left and right elements before encountering odd number. In the above example lcount = 3 and rcount = 2. If you write down the list of all subarrays, you observe that the total subarrays is [lcount * (rcount + 1) + 1 + rcount]\\n```\\nclass Solution {\\n    int res;\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int left = 0, odd = 0, i = 0;\\n        res = 0;\\n        for (i=0;i<n;i++) {\\n            if (nums[i] % 2 == 1)\\n                odd++;\\n\\t\\t\\n            if (odd > k) {\\n                /* Got largest subarray with k odd elements */\\n\\t\\t\\t\\tleft = totSubarray(nums, left, i);\\n                odd--;\\n            }\\n        }\\n        \\n        if (odd == k)\\n            totSubarray(nums, left, i);\\n\\n        return res;\\n    }\\n    \\n    private int totSubarray(int[] a, int left, int i) {\\n        int lcount = 0, rcount = 0;\\n\\t\\t\\n\\t\\t/* Find number of even elements before start of odd */\\n        while (a[left++] % 2 == 0)\\n            lcount++;\\n\\t\\t\\n\\t\\t/* Find the number of even elements after k odd numbers */\\n        while (a[--i] % 2 == 0)\\n            rcount++;\\n\\t\\t\\n        res += lcount * (rcount + 1) + rcount + 1;\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res;\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int left = 0, odd = 0, i = 0;\\n        res = 0;\\n        for (i=0;i<n;i++) {\\n            if (nums[i] % 2 == 1)\\n                odd++;\\n\\t\\t\\n            if (odd > k) {\\n                /* Got largest subarray with k odd elements */\\n\\t\\t\\t\\tleft = totSubarray(nums, left, i);\\n                odd--;\\n            }\\n        }\\n        \\n        if (odd == k)\\n            totSubarray(nums, left, i);\\n\\n        return res;\\n    }\\n    \\n    private int totSubarray(int[] a, int left, int i) {\\n        int lcount = 0, rcount = 0;\\n\\t\\t\\n\\t\\t/* Find number of even elements before start of odd */\\n        while (a[left++] % 2 == 0)\\n            lcount++;\\n\\t\\t\\n\\t\\t/* Find the number of even elements after k odd numbers */\\n        while (a[--i] % 2 == 0)\\n            rcount++;\\n\\t\\t\\n        res += lcount * (rcount + 1) + rcount + 1;\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729535,
                "title": "java-sliding-window-mimic-o-n",
                "content": "```\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        List<Integer> l = new ArrayList<>();\\n        int res = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] % 2 != 0) l.add(i);\\n        }\\n        for (int i = 0; i + k <= l.size(); i++) {\\n            int a = l.get(i) - (i == 0 ? -1 : l.get(i - 1)), b = ((i + k >= l.size()) ? n : l.get(i + k)) - l.get(i + k - 1);\\n            res += a * b;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        List<Integer> l = new ArrayList<>();\\n        int res = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] % 2 != 0) l.add(i);\\n        }\\n        for (int i = 0; i + k <= l.size(); i++) {\\n            int a = l.get(i) - (i == 0 ? -1 : l.get(i - 1)), b = ((i + k >= l.size()) ? n : l.get(i + k)) - l.get(i + k - 1);\\n            res += a * b;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719600,
                "title": "javascript-solution-o-n-time-o-n-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar numberOfSubarrays = function(nums, k) {\\n    const oddPrefixCount = new Map();\\n    \\n    oddPrefixCount.set(0, 1);\\n    let oddCount = 0;\\n    let result = 0;\\n    \\n    for (const num of nums) {\\n        if (num % 2 === 1) {\\n            oddCount++;\\n        }\\n        \\n        oddPrefixCount.set(oddCount, oddPrefixCount.get(oddCount) + 1 || 1);\\n        result += oddPrefixCount.has(oddCount - k) ? oddPrefixCount.get(oddCount - k) : 0;\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar numberOfSubarrays = function(nums, k) {\\n    const oddPrefixCount = new Map();\\n    \\n    oddPrefixCount.set(0, 1);\\n    let oddCount = 0;\\n    let result = 0;\\n    \\n    for (const num of nums) {\\n        if (num % 2 === 1) {\\n            oddCount++;\\n        }\\n        \\n        oddPrefixCount.set(oddCount, oddPrefixCount.get(oddCount) + 1 || 1);\\n        result += oddPrefixCount.has(oddCount - k) ? oddPrefixCount.get(oddCount - k) : 0;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 714812,
                "title": "smartest-approach-through-sliding-window",
                "content": "**exactly(nums,k)=atMost(nums,k)-atMost(nums,k-1)**\\nPlease upvote if you like the solution because it will help me to share more solutions\\n```\\n int atMost(vector<int>&nums,int k)\\n    {\\n        int n=nums.size();\\n        int l=0;\\n        int i=0;\\n        int subArray=0;\\n        int count=0;\\n        \\n        \\n        while(i<n)\\n        {\\n            count+=nums[i]%2;\\n            while(l<n&&count>k)\\n            {\\n                count-=nums[l]%2;\\n                l++;\\n                \\n            }\\n            if(count<=k)\\n            subArray+=(i-l+1);\\n            i++;\\n        }\\n       return subArray;\\n    }\\n    \\n    \\n    \\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return atMost(nums,k)-atMost(nums,k-1);\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "**exactly(nums,k)=atMost(nums,k)-atMost(nums,k-1)**\\nPlease upvote if you like the solution because it will help me to share more solutions\\n```\\n int atMost(vector<int>&nums,int k)\\n    {\\n        int n=nums.size();\\n        int l=0;\\n        int i=0;\\n        int subArray=0;\\n        int count=0;\\n        \\n        \\n        while(i<n)\\n        {\\n            count+=nums[i]%2;\\n            while(l<n&&count>k)\\n            {\\n                count-=nums[l]%2;\\n                l++;\\n                \\n            }\\n            if(count<=k)\\n            subArray+=(i-l+1);\\n            i++;\\n        }\\n       return subArray;\\n    }\\n    \\n    \\n    \\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return atMost(nums,k)-atMost(nums,k-1);\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 593249,
                "title": "c-single-pass-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, int>hm;\\n        \\n        int sum = 0, res = 0; hm[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            sum += (nums[i] % 2 == 0) ? 0 : 1;\\n            if(hm.find(sum-k) != hm.end())\\n                res += hm[sum-k];\\n            hm[sum]++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, int>hm;\\n        \\n        int sum = 0, res = 0; hm[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            sum += (nums[i] % 2 == 0) ? 0 : 1;\\n            if(hm.find(sum-k) != hm.end())\\n                res += hm[sum-k];\\n            hm[sum]++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545453,
                "title": "c-sliding-window",
                "content": "On each step we expand a right border of a subarray until there are less than k odd numbers.\\nIf we found exactly k numbers, add all subarrays to answer which is built by adding even numbers to the existing valid subarray.\\nThen consider subarray by removing the first item of a window.\\n```\\nint numberOfSubarrays(vector<int>& nums, int k) {\\n\\tint n = nums.size();\\n\\n\\tint i = 0, j = 0, m = 0, ans = 0;\\n\\n\\twhile(i < n){\\n\\t\\n\\t\\twhile(j < n && m < k)\\n\\t\\t\\tif(nums[j++] % 2)\\n\\t\\t\\t\\t++m;\\n\\n\\t\\tif(m == k){\\n\\t\\t\\t++ans;\\n\\n\\t\\t\\tint l = j;\\n\\n\\t\\t\\twhile(l < n && !(nums[l++] % 2))\\n\\t\\t\\t\\t++ans;\\n\\t\\t}\\n\\n\\t\\tif(nums[i++] % 2)\\n\\t\\t\\t--m;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint numberOfSubarrays(vector<int>& nums, int k) {\\n\\tint n = nums.size();\\n\\n\\tint i = 0, j = 0, m = 0, ans = 0;\\n\\n\\twhile(i < n){\\n\\t\\n\\t\\twhile(j < n && m < k)\\n\\t\\t\\tif(nums[j++] % 2)\\n\\t\\t\\t\\t++m;\\n\\n\\t\\tif(m == k){\\n\\t\\t\\t++ans;\\n\\n\\t\\t\\tint l = j;\\n\\n\\t\\t\\twhile(l < n && !(nums[l++] % 2))\\n\\t\\t\\t\\t++ans;\\n\\t\\t}\\n\\n\\t\\tif(nums[i++] % 2)\\n\\t\\t\\t--m;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481920,
                "title": "c",
                "content": "```\\npublic int NumberOfSubarrays(int[] nums, int k) {\\n\\tvar odds = new List<int>();\\n\\tfor (var i = 0; i < nums.Length; i++) {\\n\\t\\tif (nums[i] % 2 == 1) {\\n\\t\\t\\todds.Add(i);\\n\\t\\t}\\n\\t}\\n\\n\\tvar n = odds.Count;\\n\\tif (n < k) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tvar count = 0;\\n\\tfor (var i = 0; i < n - k + 1; i++) {\\n\\t\\tvar left = i == 0 ? odds[0] + 1 : odds[i] - odds[i - 1];\\n\\t\\tvar right = i == n - k ? nums.Length - odds[n - 1] : odds[i + k] - odds[i + k - 1];\\n\\t\\tcount += left * right;\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumberOfSubarrays(int[] nums, int k) {\\n\\tvar odds = new List<int>();\\n\\tfor (var i = 0; i < nums.Length; i++) {\\n\\t\\tif (nums[i] % 2 == 1) {\\n\\t\\t\\todds.Add(i);\\n\\t\\t}\\n\\t}\\n\\n\\tvar n = odds.Count;\\n\\tif (n < k) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tvar count = 0;\\n\\tfor (var i = 0; i < n - k + 1; i++) {\\n\\t\\tvar left = i == 0 ? odds[0] + 1 : odds[i] - odds[i - 1];\\n\\t\\tvar right = i == n - k ? nums.Length - odds[n - 1] : odds[i + k] - odds[i + k - 1];\\n\\t\\tcount += left * right;\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 422627,
                "title": "javascript-easy-to-understand-2-solutions-72ms",
                "content": "The first solution costs O(n) time and O(n) space.\\n\\n- Traversal the nums\\n\\t- treat each odd number as a split point\\n\\t- counting the odd number\\n\\t- save the count for every even part\\n- Loop to odd count and calculate the count of nice subarrays for every split point\\n\\n```js\\nconst numberOfSubarrays = (nums, k) => {\\n  let ret = 0;\\n  let even = new Uint16Array(nums.length + 1);\\n  let odd = 0;\\n  for (let i = 0; i < nums.length; ++i) {\\n    (nums[i] & 1) === 1 ? ++odd : ++even[odd];\\n  }\\n  for (let i = 0; i <= odd - k; ++i) {\\n    ret += even[i] + even[i + k] + 1 + even[i] * even[i + k];\\n  }\\n  return ret;\\n};\\n```\\n\\nThe second solution costs O(n) time and O(1) space.\\n\\n- Initial the sliding window\\n- Move the window forward and counting\\n\\n```\\nconst numberOfSubarrays = (nums, k) => {\\n  let ret = 0;\\n  for (let left = 0, right = 0, c = 1; right < nums.length; ++right) {\\n    k -= nums[right] & 1;\\n    (nums[left] & 1) === 0 && ++left && ++c;\\n    k === 0 && (ret += c);\\n    if (k < 0) {\\n      ++k;\\n      c = 1;\\n      while ((nums[++left] & 1) === 0) ++c;\\n      ret += c;\\n    }\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst numberOfSubarrays = (nums, k) => {\\n  let ret = 0;\\n  let even = new Uint16Array(nums.length + 1);\\n  let odd = 0;\\n  for (let i = 0; i < nums.length; ++i) {\\n    (nums[i] & 1) === 1 ? ++odd : ++even[odd];\\n  }\\n  for (let i = 0; i <= odd - k; ++i) {\\n    ret += even[i] + even[i + k] + 1 + even[i] * even[i + k];\\n  }\\n  return ret;\\n};\\n```\n```\\nconst numberOfSubarrays = (nums, k) => {\\n  let ret = 0;\\n  for (let left = 0, right = 0, c = 1; right < nums.length; ++right) {\\n    k -= nums[right] & 1;\\n    (nums[left] & 1) === 0 && ++left && ++c;\\n    k === 0 && (ret += c);\\n    if (k < 0) {\\n      ++k;\\n      c = 1;\\n      while ((nums[++left] & 1) === 0) ++c;\\n      ret += c;\\n    }\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066264,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        helper = [-1] + [i for i, el in enumerate(nums) if el % 2] + [len(nums)]\\n\\n        for i in range(1, len(helper) - k):\\n            ans += (helper[i] - helper[i - 1]) * (helper[i + k] - helper[i + k - 1])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        helper = [-1] + [i for i, el in enumerate(nums) if el % 2] + [len(nums)]\\n\\n        for i in range(1, len(helper) - k):\\n            ans += (helper[i] - helper[i - 1]) * (helper[i + k] - helper[i + k - 1])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720790,
                "title": "using-queue-python-explained",
                "content": "# Intuition\\r\\nIn your queue store the index of all odd elements.\\r\\nNow acc to question each subarray must have only k odd elements so we have to design our window limits such that there are only k odd\\r\\n**So what must be the boundaries?**\\r\\n`window start = curr Index`\\r\\n`atleast window End = min k odd from window start i.e q[k-1]`\\r\\nNow upto where we can extend the end of our window? Untill and unless we find next odd element index i.e q[k]\\r\\n`window maxLimit = q[k]`\\r\\nso the `no of subarrays which can be formed = window max Limit - atleast window end`\\r\\nand increment ur curr index\\r\\nif ur currIndex > q[0] -> pop out the index as we calculated all possible sub arrays for it\\r\\n\\r\\nNow the only base case here is what if the odd number sits at the end of the array so we can still make one subarray from it\\r\\n**so add len(arr) to queue at end and this will be the maxWindowLimit for the last subarray if possible**\\r\\n\\r\\nThis might not be the best solution space optimization wise but many sliding window problems for counting subarrays can be solved with similar pattern approach.\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\r\\n        q = deque()\\r\\n        n = len(nums)\\r\\n        for i in range(len(nums)):\\r\\n            if nums[i] % 2 != 0:\\r\\n                q.append(i)\\r\\n        q.append(n) # for the subarray can be formed by odd ele at last index\\r\\n        i = 0\\r\\n        subarrays = 0\\r\\n        while len(q) > k:\\r\\n            minWindowLen = q[k-1]\\r\\n            nextWindow = q[k]\\r\\n            subarrays += nextWindow - minWindowLen\\r\\n            if i == q[0]:\\r\\n                q.popleft()\\r\\n            i += 1\\r\\n        return subarrays\\r\\n        \\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\r\\n        q = deque()\\r\\n        n = len(nums)\\r\\n        for i in range(len(nums)):\\r\\n            if nums[i] % 2 != 0:\\r\\n                q.append(i)\\r\\n        q.append(n) # for the subarray can be formed by odd ele at last index\\r\\n        i = 0\\r\\n        subarrays = 0\\r\\n        while len(q) > k:\\r\\n            minWindowLen = q[k-1]\\r\\n            nextWindow = q[k]\\r\\n            subarrays += nextWindow - minWindowLen\\r\\n            if i == q[0]:\\r\\n                q.popleft()\\r\\n            i += 1\\r\\n        return subarrays\\r\\n        \\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578127,
                "title": "sliding-window-c-try-it",
                "content": "\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\nchange the array in binary array **1 for odd and 0 for even**.\\r\\nand try to find out number of subarray having sum equal to k.\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(N)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:O(1)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n\\r\\n    int solve(vector<int> arr,int k)\\r\\n    {\\r\\n      int n = arr.size();\\r\\n      int sum = 0,i = 0,j = 0;\\r\\n      int ans = 0;\\r\\n\\r\\n      while(j<n)\\r\\n      {\\r\\n         sum+=arr[j];\\r\\n\\r\\n         while(sum>k)\\r\\n         {\\r\\n            sum-=arr[i];\\r\\n            i++;\\r\\n         }\\r\\n\\r\\n         ans+=(j-i+1);\\r\\n         j++;\\r\\n      }\\r\\n\\r\\n      return ans;\\r\\n    }\\r\\n    int numberOfSubarrays(vector<int>& arr, int k) {\\r\\n        \\r\\n        int n = arr.size();\\r\\n        for(int i = 0;i<n;i++)\\r\\n        arr[i] = (arr[i]%2) ? 1 : 0;\\r\\n\\r\\n        return solve(arr,k)-solve(arr,k-1);\\r\\n    }\\r\\n};\\r\\n```\\r\\n\\r\\n\\r\\n\\r\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n\\r\\n    int solve(vector<int> arr,int k)\\r\\n    {\\r\\n      int n = arr.size();\\r\\n      int sum = 0,i = 0,j = 0;\\r\\n      int ans = 0;\\r\\n\\r\\n      while(j<n)\\r\\n      {\\r\\n         sum+=arr[j];\\r\\n\\r\\n         while(sum>k)\\r\\n         {\\r\\n            sum-=arr[i];\\r\\n            i++;\\r\\n         }\\r\\n\\r\\n         ans+=(j-i+1);\\r\\n         j++;\\r\\n      }\\r\\n\\r\\n      return ans;\\r\\n    }\\r\\n    int numberOfSubarrays(vector<int>& arr, int k) {\\r\\n        \\r\\n        int n = arr.size();\\r\\n        for(int i = 0;i<n;i++)\\r\\n        arr[i] = (arr[i]%2) ? 1 : 0;\\r\\n\\r\\n        return solve(arr,k)-solve(arr,k-1);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562667,
                "title": "c-queue-solution-sliding-window-short-code",
                "content": "\\tint numberOfSubarrays(vector<int>& nums, int k) {\\n\\t\\tqueue<int> q;\\n\\t\\tint count = 0 , start = -1;\\n\\n\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\tif(nums[i] % 2 == 1)q.push(i);\\n\\t\\t\\tif(q.size() > k){\\n\\t\\t\\t\\tstart = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif(q.size() == k)count += q.front()-start;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "\\tint numberOfSubarrays(vector<int>& nums, int k) {\\n\\t\\tqueue<int> q;\\n\\t\\tint count = 0 , start = -1;\\n\\n\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\tif(nums[i] % 2 == 1)q.push(i);\\n\\t\\t\\tif(q.size() > k){\\n\\t\\t\\t\\tstart = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif(q.size() == k)count += q.front()-start;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3562160,
                "title": "easy-to-understand-intuition-explained-with-visuals-prefix-contribution-technique",
                "content": "**INTUITION **\\n\\nso intuition is that to calculate number of subarrays we can built from the valid prefix subarray \\n**what do i mean by valid prefix subarray ?**\\nso a valid subarray is having exactly k odd elements ,\\nlets take an example \\n2 2 2 1 2 2 1 2 2 2 1 2 1    k=2\\nfirst valid subarray is\\n2 2 2 1 2 2 1\\nnow taking this as a prefix how many subarray we can built \\n2 2 2 1 2 2 1\\n2 2 2 1 2 2 1 2\\n2 2 2 1 2 2 1 2 2\\n2 2 2 1 2 2 1 2 2 2\\nthese all are valid subarrays we can built we the prefix\\nto calculate these subarrays recall a trick in which we have to find the number of subarrays starting from given index i  which is equal to **(n-i)**  n=>arr length\\nso we can  applying same concept here but instead of n we have to know the valid boundary\\n\\n**what do i mean by valid boundary ?**\\nconsider the above example we have built the  4 number of subarrays using 2 2 2 1 2 2 1 as a prefix now if i take **2 2 2 1 2 2 1** 2 2 2 1  this an subarray will it be valid , according to given condition we can take k(2) odd elements but in this subarray we have taken more than k elements so here we can say that whenever we have found the valid subarray after this we have to find a boundary which will be an index of first odd element after the valid subarray \\nint our eg 2 2 2 1 2 2 1 2 2 2 1 2 1  for prefix subarray  2 2 2 1 2 2 1 boundary will be 10\\nso number of subarrays we can built with this prefix is 10-6 (boundary-end index of valid subarray) which is 4 .\\nso doing this for one valid subarray we will simply shrink out window i++ OR startptr++ and then continue the above process\\n\\nTo find a boundary we can take a pointer which will find the first odd index after endptr\\n\\nYou can refer the image or dry run the solution yourself\\n**sorry for the handwriting**\\n\\n![image](https://assets.leetcode.com/users/images/2ac981c8-237e-4f83-b2dc-570e766e3674_1685037616.3853507.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/a348518f-e96f-4d8e-9cc8-e72642fdb93f_1685037537.6457465.jpeg)\\n\\n```\\nclass Solution {\\npublic int numberOfSubarrays(int[] nums, int k) {\\nint ans=0;\\nint i=0,j=0;\\nint boundary=-1;\\nint n=0;\\nif(nums[0]%2!=0)n++;\\nwhile(j<nums.length){\\nif(n==k){\\nboundary=j+1;\\nwhile(boundary<nums.length && nums[boundary]%2==0)boundary++;\\n// System.out.println(ptr +\" : \"+j);\\nans+=(boundary-j);\\nif(nums[i]%2!=0)n--;\\ni++;\\n}else{\\nj++;\\nif(j==nums.length)break;\\nif(nums[j]%2!=0)n++;\\n}\\n}\\nreturn ans;\\n}\\n}\\n```\\n\\n**with using this prefix contribution approach u can solve this also**\\nhttps://leetcode.com/problems/vowels-of-all-substrings/\\n\\nIf i find more problems i will update here\\n\\n**I will like to know from you  in the comments if we can optimise this approach ?**\\n\\ncurrently its run time is 13 ms , it might vary for others\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int numberOfSubarrays(int[] nums, int k) {\\nint ans=0;\\nint i=0,j=0;\\nint boundary=-1;\\nint n=0;\\nif(nums[0]%2!=0)n++;\\nwhile(j<nums.length){\\nif(n==k){\\nboundary=j+1;\\nwhile(boundary<nums.length && nums[boundary]%2==0)boundary++;\\n// System.out.println(ptr +\" : \"+j);\\nans+=(boundary-j);\\nif(nums[i]%2!=0)n--;\\ni++;\\n}else{\\nj++;\\nif(j==nums.length)break;\\nif(nums[j]%2!=0)n++;\\n}\\n}\\nreturn ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219562,
                "title": "rust-implementation",
                "content": "# Approach\\r\\n- We iterate through all the numbers and increment the odd counter whenver we encounter odd number.\\r\\n- Once we encounter `k` odd numbers we incremenet the left pointer until we reach the first `odd` number during this process we subtract the odd number and count the number of even numbers.\\r\\n- Update the total with the number of even numbers. \\r\\n\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(n)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $$O(1)$$\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nimpl Solution {\\r\\n    pub fn number_of_subarrays(nums: Vec<i32>, k: i32) -> i32 {\\r\\n        let mut total = 0;\\r\\n        let mut odd = 0;\\r\\n        let mut count = 0;\\r\\n\\r\\n        let mut j = 0;\\r\\n        let is_odd = |x| x % 2 == 1;\\r\\n\\r\\n        for &num in nums.iter() {\\r\\n            if is_odd(num) {\\r\\n                odd += 1;\\r\\n                count = 0;\\r\\n            }\\r\\n\\r\\n            while odd == k {\\r\\n                if is_odd(nums[j]) {\\r\\n                    odd -= 1;\\r\\n                }\\r\\n                count += 1;\\r\\n                j += 1;\\r\\n            }\\r\\n            total += count;\\r\\n        }\\r\\n\\r\\n        total as i32\\r\\n    }\\r\\n}\\r\\n\\r\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\r\\nimpl Solution {\\r\\n    pub fn number_of_subarrays(nums: Vec<i32>, k: i32) -> i32 {\\r\\n        let mut total = 0;\\r\\n        let mut odd = 0;\\r\\n        let mut count = 0;\\r\\n\\r\\n        let mut j = 0;\\r\\n        let is_odd = |x| x % 2 == 1;\\r\\n\\r\\n        for &num in nums.iter() {\\r\\n            if is_odd(num) {\\r\\n                odd += 1;\\r\\n                count = 0;\\r\\n            }\\r\\n\\r\\n            while odd == k {\\r\\n                if is_odd(nums[j]) {\\r\\n                    odd -= 1;\\r\\n                }\\r\\n                count += 1;\\r\\n                j += 1;\\r\\n            }\\r\\n            total += count;\\r\\n        }\\r\\n\\r\\n        total as i32\\r\\n    }\\r\\n}\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3189044,
                "title": "c-and-python-90-faster-code-hash-table-and-prefix-sum",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n**C++ Solution:-**\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int count = 0;\\r\\n        int sum = 0;\\r\\n        for(int i=0; i<nums.size(); i++) {\\r\\n            if(nums[i] % 2 == 1) nums[i] = 1;\\r\\n            else nums[i] = 0;\\r\\n        }\\r\\n        map<int, int> mpp;\\r\\n        mpp[0] = 1;\\r\\n        for(int i=0; i<nums.size(); i++) {\\r\\n            sum += nums[i];\\r\\n            mpp[sum]++;\\r\\n            count += mpp[sum-k];\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n};\\r\\n```\\r\\n**Python Solution:-**\\r\\n```\\r\\nclass Solution:\\r\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\r\\n        for i in range(len(nums)):\\r\\n            if nums[i] % 2 == 1:\\r\\n                nums[i] = 1\\r\\n            else:\\r\\n                nums[i] = 0\\r\\n        hashmap = {}\\r\\n        hashmap[0] = 1\\r\\n        sums = 0\\r\\n        count = 0\\r\\n        for i in range(len(nums)):\\r\\n            sums += nums[i]\\r\\n            if sums not in hashmap.keys():\\r\\n                hashmap[sums] = 1\\r\\n            else:\\r\\n                hashmap[sums] += 1\\r\\n            if sums - k in hashmap:\\r\\n                count += hashmap[sums-k]\\r\\n        return count\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\r\\n        int count = 0;\\r\\n        int sum = 0;\\r\\n        for(int i=0; i<nums.size(); i++) {\\r\\n            if(nums[i] % 2 == 1) nums[i] = 1;\\r\\n            else nums[i] = 0;\\r\\n        }\\r\\n        map<int, int> mpp;\\r\\n        mpp[0] = 1;\\r\\n        for(int i=0; i<nums.size(); i++) {\\r\\n            sum += nums[i];\\r\\n            mpp[sum]++;\\r\\n            count += mpp[sum-k];\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n};\\r\\n```\n```\\r\\nclass Solution:\\r\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\r\\n        for i in range(len(nums)):\\r\\n            if nums[i] % 2 == 1:\\r\\n                nums[i] = 1\\r\\n            else:\\r\\n                nums[i] = 0\\r\\n        hashmap = {}\\r\\n        hashmap[0] = 1\\r\\n        sums = 0\\r\\n        count = 0\\r\\n        for i in range(len(nums)):\\r\\n            sums += nums[i]\\r\\n            if sums not in hashmap.keys():\\r\\n                hashmap[sums] = 1\\r\\n            else:\\r\\n                hashmap[sums] += 1\\r\\n            if sums - k in hashmap:\\r\\n                count += hashmap[sums-k]\\r\\n        return count\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156558,
                "title": "python-sliding-window-with-comments-for-explanation",
                "content": "```python\\nclass Solution:\\n\\tdef numberOfSubarrays(self, arr, k):\\n\\t\\t# the difference gives the exact K elements count\\n\\t\\treturn self.atMostKElements(arr, k) - self.atMostKElements(arr, k-1)\\n\\n\\tdef atMostKElements(self, arr, k):\\n\\t\\ti, j = 0, 0\\n\\t\\tres, curr_window_count = 0, 0\\n\\t\\tfor j in range(len(arr)):\\n\\t\\t\\t# the {condition} which increases the curr_window_count. Different for different problems\\n\\t\\t\\tif arr[j]%2 != 0: curr_window_count += 1\\n\\n\\t\\t\\t# check if the window is valid. If its invalid, make it valid by shortening the left pointer.\\n\\t\\t\\t# Valid is when curr_window_count <= k (at most K elements)\\n\\t\\t\\tif curr_window_count > k:\\n\\t\\t\\t\\twhile curr_window_count > k:\\n\\t\\t\\t\\t\\t# this condition will be specific to the problem\\n\\t\\t\\t\\t\\tif arr[i]%2 != 0: curr_window_count -= 1\\n\\t\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\t# total nos of elements in the valid window is added to the res. \\n\\t\\t\\t# eg: [1, 2, 3], if this is the valid window, then [3], [2,3], [1,2,3] are all valid for solving at most K elements problem.\\n\\t\\t\\tres += j-i+1\\n\\t\\t\\tj += 1\\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n\\tdef numberOfSubarrays(self, arr, k):\\n\\t\\t# the difference gives the exact K elements count\\n\\t\\treturn self.atMostKElements(arr, k) - self.atMostKElements(arr, k-1)\\n\\n\\tdef atMostKElements(self, arr, k):\\n\\t\\ti, j = 0, 0\\n\\t\\tres, curr_window_count = 0, 0\\n\\t\\tfor j in range(len(arr)):\\n\\t\\t\\t# the {condition} which increases the curr_window_count. Different for different problems\\n\\t\\t\\tif arr[j]%2 != 0: curr_window_count += 1\\n\\n\\t\\t\\t# check if the window is valid. If its invalid, make it valid by shortening the left pointer.\\n\\t\\t\\t# Valid is when curr_window_count <= k (at most K elements)\\n\\t\\t\\tif curr_window_count > k:\\n\\t\\t\\t\\twhile curr_window_count > k:\\n\\t\\t\\t\\t\\t# this condition will be specific to the problem\\n\\t\\t\\t\\t\\tif arr[i]%2 != 0: curr_window_count -= 1\\n\\t\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\t# total nos of elements in the valid window is added to the res. \\n\\t\\t\\t# eg: [1, 2, 3], if this is the valid window, then [3], [2,3], [1,2,3] are all valid for solving at most K elements problem.\\n\\t\\t\\tres += j-i+1\\n\\t\\t\\tj += 1\\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088675,
                "title": "easy-sliding-widow-beats-100",
                "content": "\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\r\\n        odd_count = 0\\r\\n        res = 0\\r\\n        i = 0\\r\\n        count = 0\\r\\n        for ele in nums:\\r\\n            if ele % 2 == 1:\\r\\n                odd_count += 1\\r\\n                count = 0\\r\\n\\r\\n            while odd_count==k:\\r\\n                if nums[i] % 2 == 1:\\r\\n                    odd_count -= 1\\r\\n                i += 1\\r\\n                count += 1\\r\\n                \\r\\n            res += count\\r\\n        return res\\r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\r\\n        odd_count = 0\\r\\n        res = 0\\r\\n        i = 0\\r\\n        count = 0\\r\\n        for ele in nums:\\r\\n            if ele % 2 == 1:\\r\\n                odd_count += 1\\r\\n                count = 0\\r\\n\\r\\n            while odd_count==k:\\r\\n                if nums[i] % 2 == 1:\\r\\n                    odd_count -= 1\\r\\n                i += 1\\r\\n                count += 1\\r\\n                \\r\\n            res += count\\r\\n        return res\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059350,
                "title": "c-sliding-window",
                "content": "\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach : Suffix sum, Sliding Window\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(n)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $$O(n)$$ \\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n- Credit : [https://leetcode.com/TusharBhart/]()\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& vec, int k) {\\r\\n        vector<int> duri(vec.size() + 1);\\r\\n        duri[duri.size() - 1] = 1;\\r\\n        int distance = 1;\\r\\n        for(int i=vec.size()-1;i>=0;i--) {\\r\\n            vec[i] % 2 ? distance = 1 : distance++;\\r\\n            duri[i] = distance;\\r\\n        }\\r\\n        int i = 0;\\r\\n        int count = 0;\\r\\n        for(int j=0;j<vec.size();j++) {\\r\\n            if(vec[j] % 2) k--;\\r\\n            while(k == 0) {\\r\\n                count += duri[j + 1];\\r\\n                if(vec[i] % 2) k++;\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window",
                    "Suffix Array"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    int numberOfSubarrays(vector<int>& vec, int k) {\\r\\n        vector<int> duri(vec.size() + 1);\\r\\n        duri[duri.size() - 1] = 1;\\r\\n        int distance = 1;\\r\\n        for(int i=vec.size()-1;i>=0;i--) {\\r\\n            vec[i] % 2 ? distance = 1 : distance++;\\r\\n            duri[i] = distance;\\r\\n        }\\r\\n        int i = 0;\\r\\n        int count = 0;\\r\\n        for(int j=0;j<vec.size();j++) {\\r\\n            if(vec[j] % 2) k--;\\r\\n            while(k == 0) {\\r\\n                count += duri[j + 1];\\r\\n                if(vec[i] % 2) k++;\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n        return count;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041835,
                "title": "prefix-sum-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        int n = a.size();\\n        int res=0;\\n        vector<int> temp(n);\\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            temp[i] = a[i]%2;\\n        }\\n        \\n        long long  sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=temp[i];\\n            int t = sum-k;\\n            if(mp.count(t))\\n            {\\n                res+=mp[t];  \\n            }\\n            mp[sum]++;\\n        }\\n       \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        int n = a.size();\\n        int res=0;\\n        vector<int> temp(n);\\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            temp[i] = a[i]%2;\\n        }\\n        \\n        long long  sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=temp[i];\\n            int t = sum-k;\\n            if(mp.count(t))\\n            {\\n                res+=mp[t];  \\n            }\\n            mp[sum]++;\\n        }\\n       \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879199,
                "title": "c-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint numberOfSubarrays(int* nums, int numsSize, int k){\\n\\n    int count[50001]={0};\\n    int i; \\n    count[0]=1;\\n    int curr=0,ans=0;\\n    for(i=0;i<numsSize; i++) {\\n        curr += nums[i]%2;\\n        if(curr-k >=0) ans += count[curr-k];\\n        count[curr]++;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numberOfSubarrays(int* nums, int numsSize, int k){\\n\\n    int count[50001]={0};\\n    int i; \\n    count[0]=1;\\n    int curr=0,ans=0;\\n    for(i=0;i<numsSize; i++) {\\n        curr += nums[i]%2;\\n        if(curr-k >=0) ans += count[curr-k];\\n        count[curr]++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2718006,
                "title": "python3-prefix-sum-with-visual-explanation-o-n-space-o-n-time-complexity",
                "content": "# Introduction\\nThe problem can be easily solved by using prefix sum. But before that lets see one test case for better understanding of what we will be doing soon.\\n\\n**Testcase1:**  `nums = [2,2,2,1,2,2,1,2,2,2]`, `k=2`\\n\\n![image](https://assets.leetcode.com/users/images/346c2863-37ed-42b9-9d7e-559ea2372f9e_1666089692.9253418.png)\\n\\nThe steps are:\\n\\n1.  Calculate `prefixSum` of the array `nums` after first replacing even numbers with zero and odd numbers with 1.\\n2.  Finding the first smallest nice sub-array (sub-array with exactly `k` odd numbers).\\n3.  Count zeroes to the left of this sub-array in the prefix sum and add one.\\n4.  Number of nice sub-arrays is to multiply the counted result with the number of 2\\'s in the sum.\\n\\n**Caution:** This is just a specific solution, not a general solution. It is only used to show the main step of solving the problem.\\n\\n# Algorithm\\nThe algorithm is as simple as devising a general procedure from the above steps. The general case can be repeating the above steps in every next smallest nice sub-arrays found with some modifications.\\n1.  Calculate `prefixSum` of the array `nums` after first replacing even numbers with zero and odd numbers with 1.\\n2.  Instantiate a hashmap or python dictionary with a default key 0 and value 1. We will use it to count the number of even numbers that can be added to the smallest sub-array in both sides the same as 0\\'s and 2\\'s that we counted in the aforementioned example.\\n3.  Instantiate a variable `result` to zero to follow the sum of the total nice sub-arrays.\\n4.  Iterate over `prefixSum` and for every number in the array:\\n\\t* Insert the number in the dictonary as a key and the number by which it exists as a value.\\n\\t* If that number minus `k` is already in the dictionary, that means we have found an even number in the original array `nums` that can be added to the smallest nice sub-array. The analogue to this is finding 0\\'s and counting them along with the the 2\\'s in the above example because `2-0 = k = 2`, in general. We will continuously register the sum of the value of this number (as a key) in the dictionary to a `result`.\\n5. Return this `result`.\\n\\n# Implementation\\nThe implementation, I think, is a piece of cake after the algorithm. I will implement it using Python 3.\\n\\n```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        prefixSum = [1 if n & 1 else 0 for n in nums]\\n        for idx in range(len(nums)):\\n            prefixSum[idx] += prefixSum[idx-1] if idx-1 >= 0 else 0\\n        result = 0\\n        dic = {0: 1}\\n        for num in prefixSum:\\n            if num - k in dic:\\n                result += dic[num-k]\\n            dic[num] = dic.get(num, 0) + 1\\n        return result\\n```\\n\\n**Explanations:**\\n* `num & 1` in the above code is a bitwise operation of checking whether a number is odd or not. Every even number ends in 0 and every odd number ends in 1, when written in binary. So what the expression basically doing is that performing a bitwise & operation on both the number at large and 1. It is faster than the usual `num % 2`. For more information please check out these links: \\n\\t[What does this boolean \"(number & 1) == 0\" mean?](https://stackoverflow.com/a/14905686/16271123)\\n\\t[Is & faster than % when checking for odd numbers?](https://stackoverflow.com/a/1089945/16271123) \\n*  `dic[num] = dic.get(num, 0) + 1` is a pythonic way of inserting a `key, value` pair in a dictionary if the `key` does not exist or adding one to the `value` if it is present.\\n\\n# Analysis\\n* **Space Complexity:** We have used `prefixSum`, `result` and `dic` variables which at most count for **O(n)** space.\\n* **Time Complexity:** We have used one list comprehension with O(n) and two for loops each with O(n) complexity, resulting in overall **O(3n)** = **O(n)** time complexity.\\n\\nThank you.\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        prefixSum = [1 if n & 1 else 0 for n in nums]\\n        for idx in range(len(nums)):\\n            prefixSum[idx] += prefixSum[idx-1] if idx-1 >= 0 else 0\\n        result = 0\\n        dic = {0: 1}\\n        for num in prefixSum:\\n            if num - k in dic:\\n                result += dic[num-k]\\n            dic[num] = dic.get(num, 0) + 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677783,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==0) nums[i]=0;\\n            else nums[i]=1;\\n        }\\n        int [] arr=new int[n+1];\\n        arr[0]=1;\\n        int sum=0;\\n        int ans=0;\\n        for(int num:nums){\\n            sum+=num;\\n            if(sum>=k)  ans+=arr[sum-k];\\n            arr[sum]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==0) nums[i]=0;\\n            else nums[i]=1;\\n        }\\n        int [] arr=new int[n+1];\\n        arr[0]=1;\\n        int sum=0;\\n        int ans=0;\\n        for(int num:nums){\\n            sum+=num;\\n            if(sum>=k)  ans+=arr[sum-k];\\n            arr[sum]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637002,
                "title": "a-python-solution-runtime-810-ms-faster-than-97-95-of-python3-online-submissions",
                "content": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n    \\n## Runtime: 810 ms, faster than 97.95% of Python3 online submissions for Count Number of Nice Subarrays.\\n## Memory Usage: 20.9 MB, less than 39.29% of Python3 online submissions for Count Number of Nice Subarrays.\\n        positions = [i for i,num in enumerate(nums) if num%2==1]\\n        posLength, numsLength, count = len(positions), len(nums), 0\\n        left, right = [], []\\n        \\n        if posLength<k:\\n            return count # 0\\n        elif posLength>k:\\n            for i in range(posLength-k):\\n                left.append(positions[i+1] - positions[i])\\n                right.append(positions[i+k] - positions[i+k-1])\\n        \\n        left = [positions[0]+1] + left\\n        right = right + [numsLength-positions[-1]] \\n        count = sum([i*j for i,j in zip(left, right)])\\n        \\n        return count\\n``` \\n## **Test cases**\\n```\\n[1,1,2,1,1]\\n3\\n[2,4,6]\\n1\\n[2,2,2,1,2,2,1,2,2,2]\\n2\\n[1,1,1,1,1]\\n1\\n[91473,45388,24720,35841,29648,77363,86290,58032,53752,87188,34428,85343,19801,73201]\\n4\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n    \\n## Runtime: 810 ms, faster than 97.95% of Python3 online submissions for Count Number of Nice Subarrays.\\n## Memory Usage: 20.9 MB, less than 39.29% of Python3 online submissions for Count Number of Nice Subarrays.\\n        positions = [i for i,num in enumerate(nums) if num%2==1]\\n        posLength, numsLength, count = len(positions), len(nums), 0\\n        left, right = [], []\\n        \\n        if posLength<k:\\n            return count # 0\\n        elif posLength>k:\\n            for i in range(posLength-k):\\n                left.append(positions[i+1] - positions[i])\\n                right.append(positions[i+k] - positions[i+k-1])\\n        \\n        left = [positions[0]+1] + left\\n        right = right + [numsLength-positions[-1]] \\n        count = sum([i*j for i,j in zip(left, right)])\\n        \\n        return count\\n```\n```\\n[1,1,2,1,1]\\n3\\n[2,4,6]\\n1\\n[2,2,2,1,2,2,1,2,2,2]\\n2\\n[1,1,1,1,1]\\n1\\n[91473,45388,24720,35841,29648,77363,86290,58032,53752,87188,34428,85343,19801,73201]\\n4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602583,
                "title": "python-simple-solution",
                "content": "\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        start=0\\n        odd_count,curr_sub_count=0,0\\n        ans=0\\n        for end in range(len(nums)):\\n            if nums[end]%2==1:\\n                odd_count+=1\\n                curr_sub_count=0\\n            while odd_count==k:\\n                curr_sub_count+=1\\n                if nums[start]%2==1:\\n                    odd_count-=1\\n                start+=1\\n            ans+=curr_sub_count\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        start=0\\n        odd_count,curr_sub_count=0,0\\n        ans=0\\n        for end in range(len(nums)):\\n            if nums[end]%2==1:\\n                odd_count+=1\\n                curr_sub_count=0\\n            while odd_count==k:\\n                curr_sub_count+=1\\n                if nums[start]%2==1:\\n                    odd_count-=1\\n                start+=1\\n            ans+=curr_sub_count\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2583542,
                "title": "c-99-faster-than-all-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int l = -1, r, pre, n = nums.size(), perms = 0;\\n\\t\\t\\n\\t\\t// double-ended queue performs better than list or hash here\\n        deque<int> odds;\\n        \\n\\t\\t// pre-load to avoid size check later\\n        for (r = 0; r < n; r++) {\\n            if (nums[r] % 2) {\\n                odds.push_back(r);\\n                if (odds.size() == k) {\\n                    perms = pre = odds.front() - l;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// only perform ops when we find odd\\n        while (++r < n) {\\n            if (nums[r] % 2) {\\n                perms += pre * (r - odds.back() - 1);\\n                odds.push_back(r);\\n                l = odds.front();\\n                odds.pop_front();\\n                pre = odds.front() - l;\\n                perms += pre;\\n            }\\n        }\\n        \\n\\t\\t// catch the trailing permutations\\n        if (perms) {\\n            perms += pre * (n - odds.back() - 1);\\n        }\\n        \\n        return perms;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int l = -1, r, pre, n = nums.size(), perms = 0;\\n\\t\\t\\n\\t\\t// double-ended queue performs better than list or hash here\\n        deque<int> odds;\\n        \\n\\t\\t// pre-load to avoid size check later\\n        for (r = 0; r < n; r++) {\\n            if (nums[r] % 2) {\\n                odds.push_back(r);\\n                if (odds.size() == k) {\\n                    perms = pre = odds.front() - l;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2567350,
                "title": "cpp-solution-variation-count-of-subarray-with-k-sum",
                "content": "\\n\\n     int numberOfSubarrays(vector<int>& nums, int k) {\\n        /*Simply Traverse through the array and check\\n           1) if nums[i] is odd or even if its odd then update nums[i] as 1 ans if its even then 0 \\n           Now the question become Count of subarray with given sum.......*/\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]%2!=0)\\n                nums[i]=1;\\n            else\\n                nums[i]=0;\\n        }\\n        // Count of subarray with given sum.\\n        unordered_map<int,int> mp;\\n        int presum=0,count=0;\\n        for(auto x: nums)\\n        {\\n            presum+=x;\\n            if(presum==k) count++;\\n            if(mp.find(presum-k)!=mp.end())\\n                count+=mp[presum-k];\\n            mp[presum]++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\n     int numberOfSubarrays(vector<int>& nums, int k) {\\n        /*Simply Traverse through the array and check\\n           1) if nums[i] is odd or even if its odd then update nums[i] as 1 ans if its even then 0 \\n           Now the question become Count of subarray with given sum.......*/\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]%2!=0)\\n                nums[i]=1;\\n            else\\n                nums[i]=0;\\n        }\\n        // Count of subarray with given sum.\\n        unordered_map<int,int> mp;\\n        int presum=0,count=0;\\n        for(auto x: nums)\\n        {\\n            presum+=x;\\n            if(presum==k) count++;\\n            if(mp.find(presum-k)!=mp.end())\\n                count+=mp[presum-k];\\n            mp[presum]++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2515043,
                "title": "c-code-using-precomputation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        int n = a.size();\\n        vector<int>left(n,0);\\n        vector<int>right(n,0);\\n        int c = 0;\\n        for(int i=0;i<n;i++) {\\n            if(a[i]%2==0) c++;\\n            else {right[i]=c; c=0;}\\n        }\\n        c = 0;\\n        for(int i=n-1;i>=0;i--) {\\n            if(a[i]%2==0) c++;\\n            else {left[i]=c; c=0;}\\n        }\\n        // for(int i=0;i<n;i++) cout<<left[i]<<\" \";\\n        // cout<<endl;\\n        // for(int i=0;i<n;i++) cout<<right[i]<<\" \";\\n        \\n        int i = 0;\\n        int j = 0;\\n        int x = 0;\\n        int ans = 0;\\n        while(j<n) {\\n            if(j<n && a[j]%2!=0) x++;\\n            if(x>k) {\\n                while(x>k) {\\n                    if(i<n && a[i]%2!=0) x--;\\n                    i++;\\n                }\\n            }\\n            else if(x==k) {\\n                while(i<n && a[i]%2==0) {\\n                    i++;\\n                }\\n                cout<<ans<<\" \";\\n                ans+=(right[i]+1)*(left[j]+1);\\n                if(a[i]%2!=0) x--;\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& a, int k) {\\n        int n = a.size();\\n        vector<int>left(n,0);\\n        vector<int>right(n,0);\\n        int c = 0;\\n        for(int i=0;i<n;i++) {\\n            if(a[i]%2==0) c++;\\n            else {right[i]=c; c=0;}\\n        }\\n        c = 0;\\n        for(int i=n-1;i>=0;i--) {\\n            if(a[i]%2==0) c++;\\n            else {left[i]=c; c=0;}\\n        }\\n        // for(int i=0;i<n;i++) cout<<left[i]<<\" \";\\n        // cout<<endl;\\n        // for(int i=0;i<n;i++) cout<<right[i]<<\" \";\\n        \\n        int i = 0;\\n        int j = 0;\\n        int x = 0;\\n        int ans = 0;\\n        while(j<n) {\\n            if(j<n && a[j]%2!=0) x++;\\n            if(x>k) {\\n                while(x>k) {\\n                    if(i<n && a[i]%2!=0) x--;\\n                    i++;\\n                }\\n            }\\n            else if(x==k) {\\n                while(i<n && a[i]%2==0) {\\n                    i++;\\n                }\\n                cout<<ans<<\" \";\\n                ans+=(right[i]+1)*(left[j]+1);\\n                if(a[i]%2!=0) x--;\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2488311,
                "title": "java-prefix-sum",
                "content": "```\\npublic int numberOfSubarrays(int[] nums, int k) {\\n        if(nums == null || nums.length == 0) return 0;\\n\\n        Map<Integer, Integer> sumFrequency = new HashMap<>();\\n        sumFrequency.put(0, 1);\\n\\n        for(int i=0; i < nums.length; i++)\\n            nums[i] = (nums[i] & 1) == 1 ? 1 : 0;\\n\\n        int prefixSum = 0, count = 0;\\n        for (int num : nums) {\\n            prefixSum += num;\\n            sumFrequency.put(prefixSum, sumFrequency.getOrDefault(prefixSum, 0) + 1);\\n\\n            if (sumFrequency.containsKey(prefixSum - k))\\n                count += sumFrequency.get(prefixSum - k);\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\npublic int numberOfSubarrays(int[] nums, int k) {\\n        if(nums == null || nums.length == 0) return 0;\\n\\n        Map<Integer, Integer> sumFrequency = new HashMap<>();\\n        sumFrequency.put(0, 1);\\n\\n        for(int i=0; i < nums.length; i++)\\n            nums[i] = (nums[i] & 1) == 1 ? 1 : 0;\\n\\n        int prefixSum = 0, count = 0;\\n        for (int num : nums) {\\n            prefixSum += num;\\n            sumFrequency.put(prefixSum, sumFrequency.getOrDefault(prefixSum, 0) + 1);\\n\\n            if (sumFrequency.containsKey(prefixSum - k))\\n                count += sumFrequency.get(prefixSum - k);\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2464243,
                "title": "c-simple-solution-o-n-no-fancy-data-structure",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int l,r,ans=0;\\n        vector<int> helper;\\n        for(int i=0;i<nums.size();i++) if(nums[i]%2!=0) helper.push_back(i);\\n        int start=0;\\n        int end=start+k-1;\\n        while(end<helper.size()) {\\n            l=helper[start]+1;\\n            r=nums.size()-helper[end];\\n            if(start>0) l=helper[start]-helper[start-1];\\n            if(end!=helper.size()-1) r=helper[end+1]-helper[end];\\n            ans+=(l)*(r);\\n            start++;\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int l,r,ans=0;\\n        vector<int> helper;\\n        for(int i=0;i<nums.size();i++) if(nums[i]%2!=0) helper.push_back(i);\\n        int start=0;\\n        int end=start+k-1;\\n        while(end<helper.size()) {\\n            l=helper[start]+1;\\n            r=nums.size()-helper[end];\\n            if(start>0) l=helper[start]-helper[start-1];\\n            if(end!=helper.size()-1) r=helper[end+1]-helper[end];\\n            ans+=(l)*(r);\\n            start++;\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426932,
                "title": "prefix-sum-python-solution",
                "content": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        # method1: prefix sum\\n        prefixCount = {0:1}\\n        res = 0\\n        oddCount = 0\\n        for i in range(len(nums)):\\n            oddCount = oddCount + (1 if nums[i]%2 == 1 else 0)\\n            residual = oddCount - k\\n            res += prefixCount.get(residual,0)\\n            prefixCount[oddCount] = 1 + prefixCount.get(oddCount,0)\\n        return res\\n```\\ngood solution by lee215:\\nhttps://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-O(1)-Space",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        # method1: prefix sum\\n        prefixCount = {0:1}\\n        res = 0\\n        oddCount = 0\\n        for i in range(len(nums)):\\n            oddCount = oddCount + (1 if nums[i]%2 == 1 else 0)\\n            residual = oddCount - k\\n            res += prefixCount.get(residual,0)\\n            prefixCount[oddCount] = 1 + prefixCount.get(oddCount,0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425883,
                "title": "sliding-window-python-explanation-o-n-tc",
                "content": "**Understanding Counting Subarrays:**\\nThe hard part of this question and with a few other sliding window questions is counting \"all\" subarrays.\\nThe easy way to do this would be to count the subarrays as you go.\\n\\nEx. [1, 2, 3, 4, 5, 6]\\nLets say we want to count all the nonempty contigous subarrays in this array.\\nLets set our start and end to 0, 0.\\nEach time we add to our total the size of the sliding window (end - start + 1), and then we increment the end and continue.\\n\\nstart = 0, end = 0, count = 0\\ncount += (0 - 0 + 1)\\nHere we added the subarray [1]\\n\\nstart = 0, end = 1, count = 1\\ncount += (1 - 0 + 1) -> 2\\nHere we added the subarray [2] and [1, 2]\\n\\nstart = 0, end = 2, count = 3\\ncount += (2 - 0 + 1) -> 3\\nHere we added the subarray [3], [3, 2], and [3, 2, 1]\\n...\\n\\nSo you can see that as we go to each element we add the subarray containing just that element, and then all the subarrays it can make with the previous elements, which is why adding the size of the window gets us the subarray count.\\n\\n**Understanding Finding the Number of Subarrays Where the Number of Odd Numbers <= K:**\\n\\n```\\ndef atMostK(nums, k):\\n            start, oddCount, subarrayCount = 0, 0, 0\\n        \\n            for i in range(len(nums)):\\n                # look at end of window and check if it is odd\\n                oddCount += (nums[i] % 2) \\n            \\n                # update the start of the window until we have <= k element again\\n                while start <= i and  oddCount > k: \\n                    oddCount -= (nums[start] % 2)\\n                    start += 1\\n                \\n                # add the number of subarrays which equals the size of the window\\n                subarrayCount += (i - start + 1)\\n            \\n            return subarrayCount\\n```\\nNow that you know how to get the number of subarrays, we can use this to calculate the number of subarrays where the total number of odd numbers is <= k.\\nLike in a standard sliding window we increment the window.\\nIf the window is still <= k then we add the number of subarrays with the same method above (add the window size).\\nIf the window is > k, we update the start of the window and then we add the number of subarrays.\\n\\n**Full Solution: Getting the Number of Subarrays with Exactly K Odd Numbers:**\\n\\n**Number of Subarrays with Exactly K = (Number of Subarrays with <= K) - (Number of Subarrays with <= K - 1)**\\n```\\nclass Solution(object):\\n    def numberOfSubarrays(self, nums, k):\\n        # helper function\\n        def atMostK(nums, k):\\n            start, oddCount, subarrayCount = 0, 0, 0\\n        \\n            for i in range(len(nums)):\\n                # look at end of window and check if it is odd\\n                oddCount += (nums[i] % 2) \\n            \\n                # update the start of the window until we have <= k element again\\n                while start <= i and  oddCount > k: \\n                    oddCount -= (nums[start] % 2)\\n                    start += 1\\n                \\n                # add the number of subarrays which equals the size of the window\\n                subarrayCount += (i - start + 1)\\n            \\n            return subarrayCount\\n            \\n        return atMostK(nums, k) - atMostK(nums, k - 1);\\n```\\n\\n**TC: O(n) as you visit each element once\\nSC: O(1) as you only use a few variables for the window**\\n\\nNote: This approach is better than trying to get exactly K because you already know how to get all subarrays <= k. Getting exactly K requires much more work as you have to backtrack and keep adjsuting your sliding window backwards which complicates things.\\n",
                "solutionTags": [],
                "code": "```\\ndef atMostK(nums, k):\\n            start, oddCount, subarrayCount = 0, 0, 0\\n        \\n            for i in range(len(nums)):\\n                # look at end of window and check if it is odd\\n                oddCount += (nums[i] % 2) \\n            \\n                # update the start of the window until we have <= k element again\\n                while start <= i and  oddCount > k: \\n                    oddCount -= (nums[start] % 2)\\n                    start += 1\\n                \\n                # add the number of subarrays which equals the size of the window\\n                subarrayCount += (i - start + 1)\\n            \\n            return subarrayCount\\n```\n```\\nclass Solution(object):\\n    def numberOfSubarrays(self, nums, k):\\n        # helper function\\n        def atMostK(nums, k):\\n            start, oddCount, subarrayCount = 0, 0, 0\\n        \\n            for i in range(len(nums)):\\n                # look at end of window and check if it is odd\\n                oddCount += (nums[i] % 2) \\n            \\n                # update the start of the window until we have <= k element again\\n                while start <= i and  oddCount > k: \\n                    oddCount -= (nums[start] % 2)\\n                    start += 1\\n                \\n                # add the number of subarrays which equals the size of the window\\n                subarrayCount += (i - start + 1)\\n            \\n            return subarrayCount\\n            \\n        return atMostK(nums, k) - atMostK(nums, k - 1);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416009,
                "title": "c-sliding-window",
                "content": "class Solution {\\n# public:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n       int i=0;\\n        int j=0;\\n        int count=0;\\n        int ans=0;\\n        vector<int>v;\\n        while(j<nums.size()){\\n            if(nums[j]%2!=0){\\n                v.push_back(j);\\n                count++;\\n            }\\n           \\n            if(count>k){\\n                int l=v[0]-i;\\n                int r=j-v[v.size()-2]-1;\\n                ans+=l+r+(l*r)+1;\\n            }\\n                while(count>k){\\n                if(nums[i]%2!=0){\\n                    count--;\\n                    v.erase(v.begin());\\n                }\\n                i++;\\n            }\\n            if(count==k && j==nums.size()-1){\\n                int l=v[0]-i;\\n                int r=j-v[v.size()-1];\\n                ans+=l+r+(l*r)+1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n# public:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n       int i=0;\\n        int j=0;\\n        int count=0;\\n        int ans=0;\\n        vector<int>v;\\n        while(j<nums.size()){\\n            if(nums[j]%2!=0){\\n                v.push_back(j);\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2317299,
                "title": "c-sliding-windwo-tc-o-n-sc-o-1-simple-and-concise",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> nums;\\n\\t\\tint solve(int k){\\n\\t\\t\\tint low = 0, high = 0, cnt = 0, res = 0;\\n\\n\\t\\t\\twhile(high < nums.size()){\\n\\t\\t\\t\\tif(nums[high] & 1){\\n\\t\\t\\t\\t\\tcnt++;\\n\\n\\t\\t\\t\\t\\twhile(cnt > k){\\n\\t\\t\\t\\t\\t\\tif(nums[low] & 1) cnt--;\\n\\t\\t\\t\\t\\t\\tlow++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\thigh++;\\n\\t\\t\\t\\tres += high - low;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tint numberOfSubarrays(vector<int>& nums, int k) {\\n\\t\\t\\tthis -> nums = nums;\\n\\t\\t\\treturn solve(k) - solve(k - 1);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> nums;\\n\\t\\tint solve(int k){\\n\\t\\t\\tint low = 0, high = 0, cnt = 0, res = 0;\\n\\n\\t\\t\\twhile(high < nums.size()){\\n\\t\\t\\t\\tif(nums[high] & 1){\\n\\t\\t\\t\\t\\tcnt++;\\n\\n\\t\\t\\t\\t\\twhile(cnt > k){\\n\\t\\t\\t\\t\\t\\tif(nums[low] & 1) cnt--;\\n\\t\\t\\t\\t\\t\\tlow++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2275363,
                "title": "c-very-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        vector<int> pos;int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {if(nums[i]%2==1)\\n            pos.push_back(i);\\n        }\\n        if(pos.size()<k)\\n            return 0;\\n        for(int i=0;i<pos.size();i++)\\n        {\\n            if(i==0)\\n            {\\n                if(i+k-1==pos.size()-1)\\n                { count+=((pos[0]+1)*(nums.size()-pos[i+k-1])); goto end;}\\n                else\\n                    count+=((pos[0]+1)*(pos[i+k]-pos[i+k-1]));\\n            }\\n            else\\n                {\\n                if(i+k-1==pos.size()-1)\\n                { count+=((pos[i]-pos[i-1])*(nums.size()-pos[i+k-1])); goto end;}\\n                else\\n                    count+=((pos[i]-pos[i-1])*(pos[i+k]-pos[i+k-1]));\\n            }       \\n        }\\n        end:return count;       \\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        vector<int> pos;int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {if(nums[i]%2==1)\\n            pos.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2263115,
                "title": "java-easy-solution-sliding-window",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int cnt=0;\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(j<nums.length){\\n            if(nums[j]%2 ==1)\\n                count++;\\n            if(count<k){\\n                j++;\\n            }\\n            else{\\n                int c1=1;\\n                while(nums[i]%2 != 1){\\n                    c1++;\\n                    i++;\\n                }\\n                cnt+=c1;\\n               // System.out.println(i+\"     \"+j+\"       \"+cnt+\"     \"+count);\\n                count--;\\n                i++;\\n                j++;\\n                while(j<nums.length &&nums[j]%2 != 1){\\n                    cnt+=c1;\\n                    j++;\\n                }\\n                // System.out.println(i+\"     \"+j+\"       \"+cnt+\"     \"+count);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int cnt=0;\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(j<nums.length){\\n            if(nums[j]%2 ==1)\\n                count++;\\n            if(count<k){\\n                j++;\\n            }\\n            else{\\n                int c1=1;\\n                while(nums[i]%2 != 1){\\n                    c1++;\\n                    i++;\\n                }\\n                cnt+=c1;\\n               // System.out.println(i+\"     \"+j+\"       \"+cnt+\"     \"+count);\\n                count--;\\n                i++;\\n                j++;\\n                while(j<nums.length &&nums[j]%2 != 1){\\n                    cnt+=c1;\\n                    j++;\\n                }\\n                // System.out.println(i+\"     \"+j+\"       \"+cnt+\"     \"+count);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219795,
                "title": "java-sliding-window-and-left-right-difference-between-odd-elemeent-math",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        ArrayList<Integer> oddIndexes = new ArrayList<>();\\n        int ans =0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2!=0)oddIndexes.add(i);\\n        }\\n        for(int i=0;i<oddIndexes.size()-k + 1;i++){\\n            int leftDiff = i!=0 ? (oddIndexes.get(i) - oddIndexes.get(i-1) - 1):oddIndexes.get(i);\\n            int rightDiff = i!=oddIndexes.size()-k?oddIndexes.get(i + k) - oddIndexes.get(i + k - 1) - 1:nums.length-oddIndexes.get(i + k - 1)-1;\\n            ans+= leftDiff + rightDiff + leftDiff*rightDiff + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        ArrayList<Integer> oddIndexes = new ArrayList<>();\\n        int ans =0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2!=0)oddIndexes.add(i);\\n        }\\n        for(int i=0;i<oddIndexes.size()-k + 1;i++){\\n            int leftDiff = i!=0 ? (oddIndexes.get(i) - oddIndexes.get(i-1) - 1):oddIndexes.get(i);\\n            int rightDiff = i!=oddIndexes.size()-k?oddIndexes.get(i + k) - oddIndexes.get(i + k - 1) - 1:nums.length-oddIndexes.get(i + k - 1)-1;\\n            ans+= leftDiff + rightDiff + leftDiff*rightDiff + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217464,
                "title": "python-o-n-time-and-space-solution",
                "content": "```\\n# O(n) time | O(n) space b/c of the hashmap\\n\\n# this is a very popular algorithm for sliding window try your best to really understand it. Comment for any help.\\n# you can find another variation of this problem here\\n# https://www.youtube.com/watch?v=fFVZt-6sgyo\\n\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        pSum = 0\\n        hashMap = defaultdict(int)\\n        hashMap[0] = 1\\n        for n in nums:\\n            pSum += 0 if n % 2 == 0 else 1\\n            diff = pSum - k\\n            ans += hashMap.get(diff, 0)\\n            hashMap[pSum] += 1\\n        return ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# O(n) time | O(n) space b/c of the hashmap\\n\\n# this is a very popular algorithm for sliding window try your best to really understand it. Comment for any help.\\n# you can find another variation of this problem here\\n# https://www.youtube.com/watch?v=fFVZt-6sgyo\\n\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        pSum = 0\\n        hashMap = defaultdict(int)\\n        hashMap[0] = 1\\n        for n in nums:\\n            pSum += 0 if n % 2 == 0 else 1\\n            diff = pSum - k\\n            ans += hashMap.get(diff, 0)\\n            hashMap[pSum] += 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210254,
                "title": "classic-sliding-window-pattern-in-python",
                "content": "```\\n\\nclass Solution(object):\\n    def numberOfSubarrays(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        amt = 0\\n        \\n        \\n        seenOddsInWindow = 0\\n        \\n        l = 0\\n        for r in range(len(nums)):\\n            \\n            seenOddsInWindow += 1 if nums[r] % 2 == 1 else 0\\n            \\n            while seenOddsInWindow > k:\\n                seenOddsInWindow -= 1 if nums[l] % 2 == 1 else 0\\n                l+=1\\n                \\n            if seenOddsInWindow == k:\\n                amt+=1\\n                \\n                \\'\\'\\'\\n                [2,2,2,1,2,2,1,2,2,2] k = 2\\n                ---------------------------\\n                first string sub array with k odd numers\\n                we can add to the total seen nice arrays\\n                each even prefix to the array till we hit an odd number\\n                \\n                [2,2,2,1,2,2,1],2,2,2\\n                2,[2,2,1,2,2,1],2,2,2\\n                2,2,[2,1,2,2,1],2,2,2\\n                2,2,2,[1,2,2,1],2,2,2\\n                \\n                [2,2,2,1,2,2,1,2],2,2\\n                2,[2,2,1,2,2,1,2],2,2\\n                2,2,[2,1,2,2,1,2],2,2\\n                2,2,2,[1,2,2,1,2],2,2\\n\\n                [2,2,2,1,2,2,1,2,2],2\\n                2,[2,2,1,2,2,1,2,2],2\\n                2,2,[2,1,2,2,1,2,2],2\\n                2,2,2,[1,2,2,1,2,2],2\\n                \\n                [2,2,2,1,2,2,1,2,2,2]\\n                2,[2,2,1,2,2,1,2,2,2]\\n                2,2,[2,1,2,2,1,2,2,2]\\n                2,2,2,[1,2,2,1,2,2,2]\\n\\n                ----------------------\\n                \\n                \\'\\'\\'\\n            \\n                tempL = l\\n                while nums[tempL] % 2 == 0:\\n                    amt+=1\\n                    tempL+=1\\n                \\n                \\n        return amt\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def numberOfSubarrays(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        amt = 0\\n        \\n        \\n        seenOddsInWindow = 0\\n        \\n        l = 0\\n        for r in range(len(nums)):\\n            \\n            seenOddsInWindow += 1 if nums[r] % 2 == 1 else 0\\n            \\n            while seenOddsInWindow > k:\\n                seenOddsInWindow -= 1 if nums[l] % 2 == 1 else 0\\n                l+=1\\n                \\n            if seenOddsInWindow == k:\\n                amt+=1\\n                \\n                \\'\\'\\'\\n                [2,2,2,1,2,2,1,2,2,2] k = 2\\n                ---------------------------\\n                first string sub array with k odd numers\\n                we can add to the total seen nice arrays\\n                each even prefix to the array till we hit an odd number\\n                \\n                [2,2,2,1,2,2,1],2,2,2\\n                2,[2,2,1,2,2,1],2,2,2\\n                2,2,[2,1,2,2,1],2,2,2\\n                2,2,2,[1,2,2,1],2,2,2\\n                \\n                [2,2,2,1,2,2,1,2],2,2\\n                2,[2,2,1,2,2,1,2],2,2\\n                2,2,[2,1,2,2,1,2],2,2\\n                2,2,2,[1,2,2,1,2],2,2\\n\\n                [2,2,2,1,2,2,1,2,2],2\\n                2,[2,2,1,2,2,1,2,2],2\\n                2,2,[2,1,2,2,1,2,2],2\\n                2,2,2,[1,2,2,1,2,2],2\\n                \\n                [2,2,2,1,2,2,1,2,2,2]\\n                2,[2,2,1,2,2,1,2,2,2]\\n                2,2,[2,1,2,2,1,2,2,2]\\n                2,2,2,[1,2,2,1,2,2,2]\\n\\n                ----------------------\\n                \\n                \\'\\'\\'\\n            \\n                tempL = l\\n                while nums[tempL] % 2 == 0:\\n                    amt+=1\\n                    tempL+=1\\n                \\n                \\n        return amt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166188,
                "title": "c-o-1-space-at-most-concept",
                "content": "```\\nint solve(vector<int> &A,int k){\\n        int res=0,cnt=0;\\n        for(int i=0,j=0;i<size(A);i++){\\n            cnt+=A[i]%2;\\n            while(cnt>k) cnt-=A[j++]%2;\\n            res+=i-j;\\n        }\\n        return res;\\n    }\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        return solve(A,k)-solve(A,k-1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint solve(vector<int> &A,int k){\\n        int res=0,cnt=0;\\n        for(int i=0,j=0;i<size(A);i++){\\n            cnt+=A[i]%2;\\n            while(cnt>k) cnt-=A[j++]%2;\\n            res+=i-j;\\n        }\\n        return res;\\n    }\\n    int numberOfSubarrays(vector<int>& A, int k) {\\n        return solve(A,k)-solve(A,k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2164505,
                "title": "java-easy-solution-presume",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int len = nums.length;\\n        int[] pre = new int[len+1];\\n        int ans = 0;\\n        \\n        for (int i = 0; i < len; i++)\\n            pre[i+1] = pre[i] + (nums[i] % 2 == 0 ? 0 : 1);\\n        \\n            \\n         Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int x : pre){\\n            ans += map.getOrDefault(x,0);\\n            map.put(x+k, map.getOrDefault(x+k,0)+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int len = nums.length;\\n        int[] pre = new int[len+1];\\n        int ans = 0;\\n        \\n        for (int i = 0; i < len; i++)\\n            pre[i+1] = pre[i] + (nums[i] % 2 == 0 ? 0 : 1);\\n        \\n            \\n         Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int x : pre){\\n            ans += map.getOrDefault(x,0);\\n            map.put(x+k, map.getOrDefault(x+k,0)+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134001,
                "title": "easy-to-understand-complexity-o-n-o-1",
                "content": "Formula:\\nExact(k) = AtMost(k) - AtMost(k-1):\\n\\n```\\nclass Solution {\\npublic:    \\n    int c(vector<int> &nums, int k){\\n        int n = nums.size();\\n        int ans = 0, count =0, i = 0, j  =0;\\n        \\n        while(j < n){            \\n            if(nums[j]%2){\\n                count++;\\n            }            \\n            while(count > k){\\n                if(nums[i]%2){\\n                    count--;\\n                }\\n                i++;\\n            }\\n            ans += j - i;\\n            j++;\\n        }\\n        return ans;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return c(nums, k) - c(nums, k-1);\\n    }\\n};\\n```\\n\\n### Please Upvote if you like this",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int c(vector<int> &nums, int k){\\n        int n = nums.size();\\n        int ans = 0, count =0, i = 0, j  =0;\\n        \\n        while(j < n){            \\n            if(nums[j]%2){\\n                count++;\\n            }            \\n            while(count > k){\\n                if(nums[i]%2){\\n                    count--;\\n                }\\n                i++;\\n            }\\n            ans += j - i;\\n            j++;\\n        }\\n        return ans;\\n    }\\n    \\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        return c(nums, k) - c(nums, k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092666,
                "title": "c-sliding-window-with-map",
                "content": "```\\n   int sum=0,ans=0;\\n     unordered_map<int,int> mp; // Map for storing previous sum value \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2 !=0)\\n                sum++;\\n            if(sum==k)\\n                ans++; // incrementing ans for each sub array with k\\n            if(mp.count(sum-k))\\n                ans+=mp[sum-k]; // addding ans to with map value so it will consider all sub array before it.\\n            mp[sum]++; // add all sum value in map.\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n   int sum=0,ans=0;\\n     unordered_map<int,int> mp; // Map for storing previous sum value \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2 !=0)\\n                sum++;\\n            if(sum==k)\\n                ans++; // incrementing ans for each sub array with k\\n            if(mp.count(sum-k))\\n                ans+=mp[sum-k]; // addding ans to with map value so it will consider all sub array before it.\\n            mp[sum]++; // add all sum value in map.\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2088766,
                "title": "cpp-o-n-space-and-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int nyc=0;\\n        int i=0,j=0,n=nums.size();\\n        int countodd=0;\\n        int nearestodd[n];\\n            nearestodd[n-1]=n;\\n        for(int p=n-2;p>=0;p--)\\n        {\\n            if(nums[p+1]%2!=0)\\n                nearestodd[p]=p+1;\\n            else\\n                nearestodd[p]=nearestodd[p+1];\\n        }\\n        for(j=0;j<n;j++)\\n        {\\n            countodd+=(nums[j]%2!=0);\\n            while(countodd==k)\\n            {\\n                nyc+=(nearestodd[j]-j);\\n                countodd-=(nums[i]%2!=0);\\n                i++;\\n            }\\n        }\\n        return nyc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        int nyc=0;\\n        int i=0,j=0,n=nums.size();\\n        int countodd=0;\\n        int nearestodd[n];\\n            nearestodd[n-1]=n;\\n        for(int p=n-2;p>=0;p--)\\n        {\\n            if(nums[p+1]%2!=0)\\n                nearestodd[p]=p+1;\\n            else\\n                nearestodd[p]=nearestodd[p+1];\\n        }\\n        for(j=0;j<n;j++)\\n        {\\n            countodd+=(nums[j]%2!=0);\\n            while(countodd==k)\\n            {\\n                nyc+=(nearestodd[j]-j);\\n                countodd-=(nums[i]%2!=0);\\n                i++;\\n            }\\n        }\\n        return nyc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052596,
                "title": "c-prefix-counting-detailed-explanation",
                "content": "# Approach\\n* Let\\'s compute the number of odds till ith index in the array using prefix technique.\\n`preSum[i] = preSum[i-1] + nums[i] % 2`\\n* Now if we iterate in the preSum array, for an element preSum[i] the number of subarrays with K odds will be number of occurance of (preSum[i] + k ) \\n* For each starting index i all the indexing where preSum is preSum[i] + k will be a subarray with K odds.\\n* The reverse is also true. That is when moving from left to right in preSum we can look for number of occuarnaces of (preSum[i] - k). Using this we can do it in one go.\\n* To implement it we also of keep count of occurances in the preSum array in a map.\\n\\n![image](https://assets.leetcode.com/users/images/4df6750a-aa70-4be3-9bab-f3c124535067_1652934194.7110145.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int i = 0, n = nums.size(), ans = 0;\\n        \\n        vector<int> preSum(n, 0);\\n        unordered_map<int, int> mp;\\n          \\n        mp[0] = 1;\\n        preSum[0] = nums[0] % 2;\\n        mp[preSum[0]] += 1;\\n        ans += mp[preSum[0] - k];\\n        \\n        for(i=1;i<n;i++)\\n        {\\n            preSum[i] = preSum[i-1] + (nums[i] % 2);\\n            mp[preSum[i]] += 1;\\n            ans += mp[preSum[i] - k]; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int i = 0, n = nums.size(), ans = 0;\\n        \\n        vector<int> preSum(n, 0);\\n        unordered_map<int, int> mp;\\n          \\n        mp[0] = 1;\\n        preSum[0] = nums[0] % 2;\\n        mp[preSum[0]] += 1;\\n        ans += mp[preSum[0] - k];\\n        \\n        for(i=1;i<n;i++)\\n        {\\n            preSum[i] = preSum[i-1] + (nums[i] % 2);\\n            mp[preSum[i]] += 1;\\n            ans += mp[preSum[i] - k]; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049094,
                "title": "c-weird-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int l = 0; //left end of sliding window\\n        int r = 0; //right end of sliding window\\n        \\n        int count = 0; //number of odd numbers in curr window\\n        \\n        int ans = 0; //number of subarrays\\n        \\n        int s = -1; //first odd number in this window\\n        int e = -1; //last odd number(after count = k) in this window\\n        \\n        while(l<nums.size() && r<nums.size()){\\n            \\n            \\n            if (nums[r]&1 == 1) {\\n                \\n                if (count == 0) s = r;\\n                count++;\\n                if (count == k) e = r;\\n            }\\n \\n            if(count > k){\\n                \\n                ans += (s-l+1)*(r-e);\\n                \\n                l = s+1;\\n                \\n                while(count > k){\\n                    \\n                    s++;\\n                    \\n                    if (nums[s]&1 == 1) count--;\\n                }\\n                \\n                if (count == k) e = r;\\n            }\\n            \\n            \\n            if (r == nums.size()-1 && count == k){\\n                \\n                ans += (s-l+1)*(r-e+1);\\n                \\n            }\\n            \\n            r++;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int l = 0; //left end of sliding window\\n        int r = 0; //right end of sliding window\\n        \\n        int count = 0; //number of odd numbers in curr window\\n        \\n        int ans = 0; //number of subarrays\\n        \\n        int s = -1; //first odd number in this window\\n        int e = -1; //last odd number(after count = k) in this window\\n        \\n        while(l<nums.size() && r<nums.size()){\\n            \\n            \\n            if (nums[r]&1 == 1) {\\n                \\n                if (count == 0) s = r;\\n                count++;\\n                if (count == k) e = r;\\n            }\\n \\n            if(count > k){\\n                \\n                ans += (s-l+1)*(r-e);\\n                \\n                l = s+1;\\n                \\n                while(count > k){\\n                    \\n                    s++;\\n                    \\n                    if (nums[s]&1 == 1) count--;\\n                }\\n                \\n                if (count == k) e = r;\\n            }\\n            \\n            \\n            if (r == nums.size()-1 && count == k){\\n                \\n                ans += (s-l+1)*(r-e+1);\\n                \\n            }\\n            \\n            r++;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039413,
                "title": "java-two-pointer",
                "content": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int left = 0;\\n        int right = 0;\\n        int odd = 0;\\n        int result = 0;\\n        \\n        while(right < nums.length){\\n            if((nums[right] & 1) == 1){\\n                odd ++;\\n                right ++;\\n            }else{\\n                right ++;\\n            }\\n            \\n            if(odd == k){\\n              //\\u5411\\u5411\\u53F3\\u79FB\\u52A8\\u53CC\\u6307\\u9488\\uFF0C\\u76F4\\u81F3\\u9047\\u5230\\u7B2C\\u4E00\\u4E2Aodd\\n                int tempRight  = right;\\n                int tempLeft = left;\\n                while(right < nums.length && (nums[right] & 1) == 0){\\n                    right ++;\\n                }\\n                \\n                while((nums[left] & 1) == 0){\\n                    left ++;\\n                }\\n                \\n                result += (left - tempLeft + 1) * (right - tempRight + 1);\\n                \\n                odd  --;\\n                left ++;\\n            }\\n            \\n          \\n\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int left = 0;\\n        int right = 0;\\n        int odd = 0;\\n        int result = 0;\\n        \\n        while(right < nums.length){\\n            if((nums[right] & 1) == 1){\\n                odd ++;\\n                right ++;\\n            }else{\\n                right ++;\\n            }\\n            \\n            if(odd == k){\\n              //\\u5411\\u5411\\u53F3\\u79FB\\u52A8\\u53CC\\u6307\\u9488\\uFF0C\\u76F4\\u81F3\\u9047\\u5230\\u7B2C\\u4E00\\u4E2Aodd\\n                int tempRight  = right;\\n                int tempLeft = left;\\n                while(right < nums.length && (nums[right] & 1) == 0){\\n                    right ++;\\n                }\\n                \\n                while((nums[left] & 1) == 0){\\n                    left ++;\\n                }\\n                \\n                result += (left - tempLeft + 1) * (right - tempRight + 1);\\n                \\n                odd  --;\\n                left ++;\\n            }\\n            \\n          \\n\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008965,
                "title": "go-prefix-sum-clear-solution",
                "content": "Explanation available here: https://www.youtube.com/watch?v=fFVZt-6sgyo\\n\\n```\\nfunc numberOfSubarrays(nums []int, k int) int {\\n    prefixSums := map[int]int{0: 1}\\n    sum, res := 0, 0\\n    for _, n := range nums {\\n        sum += n%2\\n        res += prefixSums[sum-k]\\n        prefixSums[sum]++\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Prefix Sum"
                ],
                "code": "```\\nfunc numberOfSubarrays(nums []int, k int) int {\\n    prefixSums := map[int]int{0: 1}\\n    sum, res := 0, 0\\n    for _, n := range nums {\\n        sum += n%2\\n        res += prefixSums[sum-k]\\n        prefixSums[sum]++\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1970388,
                "title": "easy-to-understand-c-code",
                "content": "* ***Approach 1 : Using Prefix Sum && Unordered Map***\\n\\n* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] % 2)\\n            {\\n                nums[i] = 1;\\n            }\\n            \\n            else\\n            {\\n                nums[i] = 0;\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        \\n        mp[0] = 1;\\n        \\n        int curr_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_sum += nums[i];\\n            \\n            int need = curr_sum - k;\\n            \\n            if(mp.count(need))\\n            {\\n                count += mp[need];\\n            }\\n            \\n            mp[curr_sum]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] % 2)\\n            {\\n                nums[i] = 1;\\n            }\\n            \\n            else\\n            {\\n                nums[i] = 0;\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        \\n        mp[0] = 1;\\n        \\n        int curr_sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_sum += nums[i];\\n            \\n            int need = curr_sum - k;\\n            \\n            if(mp.count(need))\\n            {\\n                count += mp[need];\\n            }\\n            \\n            mp[curr_sum]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956689,
                "title": "simple-and-probably-the-most-easiest-solution-out-there-o-n-prefix-hash-map",
                "content": "Just replace the odd numbers with 1 and the even numbers with 0. Then, using prefix sum find the total number of sub arrays with sum equal to K.\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int> nums, int k) {\\n       int n = nums.size(); \\n        \\n        for(int i=0; i<n ;i++)\\n        {\\n            if(nums[i]%2==0)\\n                nums[i] = 0;\\n            else\\n                nums[i] = 1;\\n        }\\n        \\n        int sum = 0, count=0, j=0;\\n        unordered_map<int, int> mp;\\n        mp[0]=  1;\\n        for(; j<n; j++)\\n        {\\n            sum += nums[j];\\n            if(mp.find(sum-k) != mp.end())\\n                count += mp[sum-k];\\n            mp[sum]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\nHope it helps :))",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int> nums, int k) {\\n       int n = nums.size(); \\n        \\n        for(int i=0; i<n ;i++)\\n        {\\n            if(nums[i]%2==0)\\n                nums[i] = 0;\\n            else\\n                nums[i] = 1;\\n        }\\n        \\n        int sum = 0, count=0, j=0;\\n        unordered_map<int, int> mp;\\n        mp[0]=  1;\\n        for(; j<n; j++)\\n        {\\n            sum += nums[j];\\n            if(mp.find(sum-k) != mp.end())\\n                count += mp[sum-k];\\n            mp[sum]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908023,
                "title": "python3-solution-subarray-sum-equals-k-time-o-n-space-o-n",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        Let\\'s mark each even number by 0 and each odd number by 1. Then the problem reduces to subarray sum\\n        equals k.\\n        Time complexity: O(N)\\n        Space complexity: O(N)\\n        \"\"\"\\n        lookup = defaultdict(int)\\n        lookup[0] = 1 # The sum of 0 exists 1 time.\\n        res = prefix_sum = 0\\n        \\n        for i in range(len(nums)):\\n            if nums[i] % 2 == 0:\\n                nums[i] = 0\\n            \\n            else:\\n                nums[i] = 1\\n                \\n            prefix_sum+=nums[i]\\n            res+=lookup[prefix_sum - k]\\n            lookup[prefix_sum]+=1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        Let\\'s mark each even number by 0 and each odd number by 1. Then the problem reduces to subarray sum\\n        equals k.\\n        Time complexity: O(N)\\n        Space complexity: O(N)\\n        \"\"\"\\n        lookup = defaultdict(int)\\n        lookup[0] = 1 # The sum of 0 exists 1 time.\\n        res = prefix_sum = 0\\n        \\n        for i in range(len(nums)):\\n            if nums[i] % 2 == 0:\\n                nums[i] = 0\\n            \\n            else:\\n                nums[i] = 1\\n                \\n            prefix_sum+=nums[i]\\n            res+=lookup[prefix_sum - k]\\n            lookup[prefix_sum]+=1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852603,
                "title": "javascript-sliding-window",
                "content": "```\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\n\\nvar numberOfSubarrays = function (nums, k) {\\n  let result = 0,\\n    windowStart = 0,\\n    windowEnd = 0,\\n    count = 0;\\n  while (windowEnd < nums.length) {\\n    //odd\\n    if (nums[windowEnd] % 2 === 1) {\\n      k -= 1;\\n      count = 0;\\n    }\\n    while (k === 0) {\\n      if (nums[windowStart] % 2 === 1) {\\n        k += 1;\\n      }\\n      // shrink the window\\n      windowStart += 1;\\n      // update count\\n      count += 1;\\n    }\\n    result += count;\\n    windowEnd += 1;\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\n\\nvar numberOfSubarrays = function (nums, k) {\\n  let result = 0,\\n    windowStart = 0,\\n    windowEnd = 0,\\n    count = 0;\\n  while (windowEnd < nums.length) {\\n    //odd\\n    if (nums[windowEnd] % 2 === 1) {\\n      k -= 1;\\n      count = 0;\\n    }\\n    while (k === 0) {\\n      if (nums[windowStart] % 2 === 1) {\\n        k += 1;\\n      }\\n      // shrink the window\\n      windowStart += 1;\\n      // update count\\n      count += 1;\\n    }\\n    result += count;\\n    windowEnd += 1;\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840870,
                "title": "java-sliding-window",
                "content": "Provide some feedback on this solution please.\\nI think it is a pretty good one using the Sliding Window technique.\\n62.45% faster and 69.41% less space used.\\n\\n\\n```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int oddLen = 0, startIndex = 0, num = 0, endIndex = 0, res = 0;\\n        boolean hasK = false;\\n        for (int i = 0; i < nums.length; i++) {\\n            hasK = false;\\n            endIndex = i;\\n            if(nums[i] % 2 == 1) oddLen++;\\n            while (oddLen >= k) {\\n                hasK = true;\\n                if(nums[startIndex++] % 2 == 1) oddLen--;\\n                num++;\\n            }\\n            res += num;\\n            while (hasK && ++endIndex < nums.length && nums[endIndex] % 2 == 0) {\\n                \\n                res += num;\\n            }\\n            num = 0;\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        int oddLen = 0, startIndex = 0, num = 0, endIndex = 0, res = 0;\\n        boolean hasK = false;\\n        for (int i = 0; i < nums.length; i++) {\\n            hasK = false;\\n            endIndex = i;\\n            if(nums[i] % 2 == 1) oddLen++;\\n            while (oddLen >= k) {\\n                hasK = true;\\n                if(nums[startIndex++] % 2 == 1) oddLen--;\\n                num++;\\n            }\\n            res += num;\\n            while (hasK && ++endIndex < nums.length && nums[endIndex] % 2 == 0) {\\n                \\n                res += num;\\n            }\\n            num = 0;\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830017,
                "title": "count-number-of-nice-subarrays",
                "content": "class Solution \\n{\\n public:\\n    int call(vector<int>&nums,int k)\\n    {\\n        int n=nums.size();\\n        int ans=0;\\n        map<int,int>sum;\\n        sum[0]=1;\\n        int total=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            total+=nums[i];\\n            ans+=sum[total-k];\\n            sum[total]++;\\n        }\\n        return ans;\\n    }\\n    int numberOfSubarrays(vector<int>& nums, int k) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n            nums[i]=nums[i]%2;\\n        return call(nums,k);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution \\n{\\n public:\\n    int call(vector<int>&nums,int k)\\n    {\\n        int n=nums.size();\\n        int ans=0;\\n        map<int,int>sum;\\n        sum[0]=1;\\n        int total=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            total+=nums[i];\\n            ans+=sum[total-k];\\n            sum[total]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1829179,
                "title": "python-easy-to-read-and-understand-subarray-sum-equals-k",
                "content": "This question can be modified to subarray sum equaks k by converting all odds to 1 and all evens to 0\\n```\\nclass Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            nums[i] = 0 if nums[i]%2 == 0 else 1\\n        \\n        d = {0:1}\\n        sums, ans = 0, 0\\n        for i in range(n):\\n            sums += nums[i]\\n            if sums-k in d:\\n                ans += d[sums-k]\\n            d[sums] = d.get(sums, 0) + 1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "class Solution:\\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        for i in range(n):\\n            nums[i] = 0 if nums[i]%2 == 0 else 1\\n        \\n        d = {0:1}",
                "codeTag": "Java"
            },
            {
                "id": 1820102,
                "title": "java-prefix-sum-hashmap-solution-based-on-problem-930-binary-subarrays-with-sum",
                "content": "```\\nclass Solution {\\n    // Gist: we have to find the number of subarrays that have \\'k\\' number of odd elements\\n    // Essentially this can be reduced to problem # 930 Binary subarrays with sum\\n    // nums[i] % 2 will either be 0 or 1\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        \\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        int sum = 0;\\n        int right = 0;\\n\\t\\t\\n        while (right < nums.length) {\\n            sum += nums[right++] % 2;\\n            if (sum == k) {\\n                res++;\\n            }\\n\\t\\t\\t\\n            if (map.containsKey(sum - k)) {\\n                res += map.get(sum - k);\\n            }\\n            \\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Gist: we have to find the number of subarrays that have \\'k\\' number of odd elements\\n    // Essentially this can be reduced to problem # 930 Binary subarrays with sum\\n    // nums[i] % 2 will either be 0 or 1\\n    public int numberOfSubarrays(int[] nums, int k) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        \\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        int sum = 0;\\n        int right = 0;\\n\\t\\t\\n        while (right < nums.length) {\\n            sum += nums[right++] % 2;\\n            if (sum == k) {\\n                res++;\\n            }\\n\\t\\t\\t\\n            if (map.containsKey(sum - k)) {\\n                res += map.get(sum - k);\\n            }\\n            \\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1758263,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1793283,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1573159,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1870128,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2067001,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2050698,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2039574,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2009498,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1994178,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1823836,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1758263,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1793283,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1573159,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1870128,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2067001,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2050698,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2039574,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 2009498,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1994178,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            },
            {
                "id": 1823836,
                "content": [
                    {
                        "username": "mhhs",
                        "content": "I don\\'t understand the last test case. Here how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "draw a picture and think it in brute force ...from index 0 to index 3 ....for each index..u can form 4 valid winows/combinations where there are 2 odd numbers....so 4(0-3) indexes are there....hence 4*4=16"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "A picture is worth a thousand words, we have four choices to place our `l` pointer, four choices to place `r` pointer, `4 * 4 = 16`, that\\'s why the expected result is 16.\\n\\n![](https://i.imgur.com/rXNsqgw.png)"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "2,2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,2,1,2,2,1], [2,2,2,1,2,2,1,2], [2,2,2,1,2,2,1,2,2], [2,2,2,1,2,2,1,2,2,2]\\n\\n2,2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,2,1,2,2,1], [2,2,1,2,2,1,2], [2,2,1,2,2,1,2,2], [2,2,1,2,2,1,2,2,2]\\n\\n2,1,2,2,1 * with every combination of next(2,2,2) = \\n[2,1,2,2,1], [2,1,2,2,1,2], [2,1,2,2,1,2,2], [2,1,2,2,1,2,2,2]\\n\\n1,2,2,1 * with every combination of next(2,2,2) = \\n[1,2,2,1], [1,2,2,1,2], [1,2,2,1,2,2], [1,2,2,1,2,2,2]\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "No. of subarrays with exactly k odd  = No. of subarrays with at most k odd - No. of subarrays with at most k-1 odd."
                    },
                    {
                        "username": "sebastiantia",
                        "content": "[@DoraBabukondala](/DoraBabukondala) what other ones are solved with this logic?\\n"
                    },
                    {
                        "username": "Navdeep_kr",
                        "content": "[@scor32k](/scor32k) Thanks a lot brother. It helped me a lot.\\n"
                    },
                    {
                        "username": "scor32k",
                        "content": "[@DoraBabukondala](/DoraBabukondala) suppose you want sub array with at most 2 odds so what this says is, get subarray with at most 2 odds (sub array with 0 odds, subarray with 1 odds, subarray with 2 odds) and subtract this with subarray with at most k-1 odds i.e at most 1 odds(subarray with 0 odds, subaaray with 1 odds) .so what we will get iss subaaray with 2 odds (subarray with 0 odds + subarray with 1 odds + subarray with 2 odds - (subarray with 0 odds + subarray with 1 odss))"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "i have seen many sliding solved with this logic but never understood how this works. Can you help me with that please."
                    },
                    {
                        "username": "tbbt1337",
                        "content": "Are they looking for sub arrays that contain *exactly* `k` odd numbers without saying so?"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "They have mentioned it :\\nA continuous subarray is called nice if there are k odd numbers on it."
                    },
                    {
                        "username": "singhanshul2807",
                        "content": "yes"
                    },
                    {
                        "username": "Thakur_2024",
                        "content": "I do not  understand the last test case. Here, how would answer become 16?\\ncan anyone help me to understand this.\\n\\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\\nOutput: 16"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the minimum length subarray with 2 odds is `1,2,2,1`. there are 3 even digits to the left of it -> means there are 4 different subarrays. Same for the right: 4 * 4 = 16 combinations in total."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Solve binary array with given target question before this. Highly recommended."
                    },
                    {
                        "username": "majestic_coder",
                        "content": "[Binary Subarrays With Sum\\n](https://leetcode.com/problems/binary-subarrays-with-sum/) Do solve this first, Then You will find it easier."
                    },
                    {
                        "username": "shubhamm_v",
                        "content": "If no. in array is odd make it 1, else make it 0. Now just relate it with one most popular questions of count subarrays."
                    },
                    {
                        "username": "Nitin_Paramkar",
                        "content": "I think the output given in example 3 is wrong. it should be 4 instead of 16"
                    },
                    {
                        "username": "vrfancy",
                        "content": "16 is correct, [2,2,2,1,2,2,1], [2,2,1,2,2,1],[2,1,2,2,1],[1,2,2,1],[2,2,2,1,2,2,1,2],[2,2,1,2,2,1,2],[2,1,2,2,1,2],[1,2,2,1,2]......."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "I dont understand the concept of atmost :\\'( \\n`help`"
                    },
                    {
                        "username": "sumj25",
                        "content": "Can anyone tell me what i\\'m doing wrong it gives runtime errror on test case 19.\\n `\\nclass Solution {\\npublic:\\n    int numberOfSubarrays(vector<int>& nums, int k) {\\n\\n       int cnt=0,i,n=nums.size(),j=0,cnt1=0;\\n       vector<int>ans;\\n       ans.push_back(0);\\n       for(i=0;i<n;i++)\\n       {\\n           if(nums[i]%2!=0)\\n           ans.push_back(i+1);\\n       }\\n       ans.push_back(n+1);\\n       i=0;\\n       for(i=1;i<(ans.size()-k);i++)\\n       {\\n            cnt+=((ans[i]-ans[i-1])*(ans[i+k]-ans[i+k-1]));\\n       }\\n       return cnt;\\n    }\\n`"
                    }
                ]
            }
        ]
    }
]