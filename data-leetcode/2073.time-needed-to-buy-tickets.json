[
    {
        "title": "The Winner University",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1576139,
                "content": [
                    {
                        "username": "xyz12345",
                        "content": "with nye as\\n(\\nselect count(student_id) as nnum\\nfrom newyork\\nwhere score >= 90)\\n\\n, cal as\\n(select count(student_id) as cnum\\nfrom california\\nwhere score >= 90)\\n\\nselect \\ncase   when  nnum > cnum then   \"New York University\"\\n          when  cnum >nnum  then   \"California University\"\\n          else    \"No Winner\"\\nend as winner\\nfrom nye, cal"
                    },
                    {
                        "username": "Paonevergivup",
                        "content": "with cte as(\\nselect \"NYU\" as School,count(student_id) as count_student\\nfrom NewYork\\nwhere score>=90\\nunion all\\nselect \"CU\" as School,count(student_id) as count_student\\nfrom California\\nwhere score>=90)\\n, cte2 as(\\nselect School, dense_rank() over(order by count_student desc) as rank_num\\nfrom cte)\\n\\nselect case when count(School)>1 then \"No Winner\" when School=\"NYU\" then \"New York University\" else \"California University\"  end as winner\\nfrom cte2\\nwhere rank_num=1"
                    }
                ]
            },
            {
                "id": 1576107,
                "content": [
                    {
                        "username": "xyz12345",
                        "content": "with nye as\\n(\\nselect count(student_id) as nnum\\nfrom newyork\\nwhere score >= 90)\\n\\n, cal as\\n(select count(student_id) as cnum\\nfrom california\\nwhere score >= 90)\\n\\nselect \\ncase   when  nnum > cnum then   \"New York University\"\\n          when  cnum >nnum  then   \"California University\"\\n          else    \"No Winner\"\\nend as winner\\nfrom nye, cal"
                    },
                    {
                        "username": "Paonevergivup",
                        "content": "with cte as(\\nselect \"NYU\" as School,count(student_id) as count_student\\nfrom NewYork\\nwhere score>=90\\nunion all\\nselect \"CU\" as School,count(student_id) as count_student\\nfrom California\\nwhere score>=90)\\n, cte2 as(\\nselect School, dense_rank() over(order by count_student desc) as rank_num\\nfrom cte)\\n\\nselect case when count(School)>1 then \"No Winner\" when School=\"NYU\" then \"New York University\" else \"California University\"  end as winner\\nfrom cte2\\nwhere rank_num=1"
                    }
                ]
            }
        ]
    },
    {
        "title": "Time Needed to Buy Tickets",
        "question_content": "<p>There are <code>n</code> people in a line queuing to buy tickets, where the <code>0<sup>th</sup></code> person is at the <strong>front</strong> of the line and the <code>(n - 1)<sup>th</sup></code> person is at the <strong>back</strong> of the line.</p>\n\n<p>You are given a <strong>0-indexed</strong> integer array <code>tickets</code> of length <code>n</code> where the number of tickets that the <code>i<sup>th</sup></code> person would like to buy is <code>tickets[i]</code>.</p>\n\n<p>Each person takes <strong>exactly 1 second</strong> to buy a ticket. A person can only buy <strong>1 ticket at a time</strong> and has to go back to <strong>the end</strong> of the line (which happens <strong>instantaneously</strong>) in order to buy more tickets. If a person does not have any tickets left to buy, the person will <strong>leave </strong>the line.</p>\n\n<p>Return <em>the <strong>time taken</strong> for the person at position </em><code>k</code><em>&nbsp;</em><strong><em>(0-indexed)</em>&nbsp;</strong><em>to finish buying tickets</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tickets = [2,3,2], k = 2\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> \n- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].\n- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].\nThe person at&nbsp;position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tickets = [5,1,1,1], k = 0\n<strong>Output:</strong> 8\n<strong>Explanation:</strong>\n- In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].\n- In the next 4 passes, only the person in position 0 is buying tickets.\nThe person at&nbsp;position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == tickets.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= tickets[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt; n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1576932,
                "title": "c-one-pass",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Brute Force Simulation\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(SUM(A))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < A.size(); ++i) {\\n                if (A[i] == 0) continue;\\n                A[i]--;\\n                ++step;\\n                if (A[k] == 0) return step;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n## Solution 2. One Pass\\n\\nFor `i <= k`, `A[i]` contributes `min(A[k], A[i])` steps.\\n\\nFor `i > k`, `A[i]` contributes `min(A[k] - 1, A[i])` steps.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            ans += min(A[k] - (i > k), A[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(SUM(A))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < A.size(); ++i) {\\n                if (A[i] == 0) continue;\\n                A[i]--;\\n                ++step;\\n                if (A[k] == 0) return step;\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            ans += min(A[k] - (i > k), A[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577093,
                "title": "o-n",
                "content": "We know the value of `k`-th element. Elements before `k` (and the element itself) will appear in the line `min(t[k], t[i])` times.\\n\\nAll elements after `k` will appear in the line  `min(t[k] - 1, t[i])` times.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def timeRequiredToBuy(self, t: List[int], k: int) -> int:\\n        return sum(min(v, t[k] if i <= k else t[k] - 1) for i, v in enumerate(t))\\n```\\n**Java**\\n```java\\npublic int timeRequiredToBuy(int[] t, int k) {\\n    return IntStream.range(0, t.length).map(i -> Math.min(t[i], i > k ? t[k] - 1 : t[k])).sum();\\n}\\n```\\n**C++**\\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    int res = 0, sz = t.size(), cap = t[k];\\n    for (int i = 0; i < sz; ++i)\\n        res += min(cap - (i > k), t[i]);\\n    return res;\\n}\\n```\\nAlso a (slightly mouthful) functional version.\\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    return accumulate(begin(t), begin(t) + k + 1, 0, [&](int s, int v){ return s + min(v, t[k]); })\\n        + accumulate(begin(t) + k + 1, end(t), 0, [&](int s, int v){ return s + min(v, t[k] - 1); });\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def timeRequiredToBuy(self, t: List[int], k: int) -> int:\\n        return sum(min(v, t[k] if i <= k else t[k] - 1) for i, v in enumerate(t))\\n```\n```java\\npublic int timeRequiredToBuy(int[] t, int k) {\\n    return IntStream.range(0, t.length).map(i -> Math.min(t[i], i > k ? t[k] - 1 : t[k])).sum();\\n}\\n```\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    int res = 0, sz = t.size(), cap = t[k];\\n    for (int i = 0; i < sz; ++i)\\n        res += min(cap - (i > k), t[i]);\\n    return res;\\n}\\n```\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    return accumulate(begin(t), begin(t) + k + 1, 0, [&](int s, int v){ return s + min(v, t[k]); })\\n        + accumulate(begin(t) + k + 1, end(t), 0, [&](int s, int v){ return s + min(v, t[k] - 1); });\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577018,
                "title": "python-bruteforce-and-o-n",
                "content": "Please upvote if you find it helpful\\n\\nBruteForce:\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        secs = 0 \\n        i = 0\\n        while tickets[k] != 0:\\n            if tickets[i] != 0: # if it is zero that means we dont have to count it anymore\\n                tickets[i] -= 1 # decrease the value by 1 everytime\\n                secs += 1 # increase secs by 1\\n\\n            i = (i + 1) % len(tickets) # since after getting to the end of the array we have to return to the first value so we use the mod operator\\n            \\n        return secs\\n```\\n\\nO(N):\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(x, tickets[k] if i <= k else tickets[k] - 1) for i, x in enumerate(tickets))\\n```\\nThe values before tickets[k] will appear min(x, t[x]) times and values after tickets[k] will appear min(x, t[x] -1) times\\nLet\\'s take an example:\\n`tickets = [5, 2, 3, 4]` and `k = 2`\\n```1st iteration: [4, 1, 2, 3]```\\n```2nd iteration: [3, 0, 1, 2]```\\n```3rd iteration: [2, 0, 0, 1]```\\nYou see `tickets[0]` appeared 3 times which is min(5, 3) and that is 3, \\n             `tickets[1]` appeared 2 times which is min(2, 3) that is 2, \\n\\t\\t\\t `tickets[2]` appeared 3 times which is min(3, 3) that is 3 and \\n\\t\\t\\t `tickets[3]` appeared 2 times which is min(4, 2) that is 2.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        secs = 0 \\n        i = 0\\n        while tickets[k] != 0:\\n            if tickets[i] != 0: # if it is zero that means we dont have to count it anymore\\n                tickets[i] -= 1 # decrease the value by 1 everytime\\n                secs += 1 # increase secs by 1\\n\\n            i = (i + 1) % len(tickets) # since after getting to the end of the array we have to return to the first value so we use the mod operator\\n            \\n        return secs\\n```\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(x, tickets[k] if i <= k else tickets[k] - 1) for i, x in enumerate(tickets))\\n```\n```1st iteration: [4, 1, 2, 3]```\n```2nd iteration: [3, 0, 1, 2]```\n```3rd iteration: [2, 0, 0, 1]```",
                "codeTag": "Java"
            },
            {
                "id": 1576926,
                "title": "java-o-n-one-pass-explained",
                "content": "**Explanation / Approach:**\\nBrute force is somewhat easy to come up with. You just need to iterate as long as tickets[k] != 0.\\n\\n**For an optimized approach :**\\n1. Add min(tickets[i],tickets[k]) upto k (inclusive).\\n2. Add min(tickets[i],tickets[k] - 1) after k.\\n3. Return the count.\\n\\nTime : O(n) , Space : O(1)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                res += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                res += Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                res += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                res += Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589830,
                "title": "c-brute-force-vs-single-pass-solution-compared-and-explained-100-time-80-space",
                "content": "Given the constraints, we can easily afford to go for a brute force-ish solution first (a fully legitimate approach during any interview, as long as you keep the computationt time reasonable - I wouldn\\'t do this if either the queue length or the amount of tickets each queuer might buy were in the order of billions!), so we will go for it first.\\n\\nIn order to solve our problem we will first of all declare an accumulator variable `res`, initially set to `0` and that will store how many turns we have to wait until the `k`th slot has bought all his tickets.\\n\\nWe will then have an outer loop just to check that - `ts[k]` still having pending tickets to buy and inside it we will run another one, using the pointer `i` to parse `ts` until `ts[k]` is not `0` and in which we will:\\n* check if the currently pointed element `ts[i]` still has elements to remove and, in case:\\n\\t* decrease `ts[i]` by `1`;\\n\\t* increase `res` by `1`.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0;\\n        // running loops until we get all our tickets\\n        while (ts[k]) {\\n            // running one loop\\n            for (int i = 0, lmt = ts.size(); i < lmt && ts[k]; i++) {\\n                // decreasing one slot and increasing res, if the slot still queues\\n                if (ts[i]) {\\n                    ts[i]--;\\n                    res++;\\n                }\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut, wait a minute \\uD83E\\uDD14 ...\\n\\nDo we really need to decrease all the cells one by one?\\n\\nWell, probably not, since we might quickly notice that the waiting time each slot to the left of `k` contributes is equal to the minimum between its current value and `ts[k]`, that we will call `target` for convenience; and it\\'s almost the same for all the elements to the right of it, being the minimum between its current value and `target - 1` (since we will go and touch them always after having decreased `ts[k]`.\\n\\nSo, we can put this into code and get much better performance with this version:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue\\n        for (int i = 0, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and what we need to get\\n            res += min(ts[i], target - (i > k));\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFinal micro-optimised version to avoid one conditional inside the loop (which probably would not even shine in terms of performance compared to allocating variables for a sole `for` loop unless we were to get really big ranges):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue up to k, included\\n        for (int i = 0; i <= k; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        // parsing the queue up from  k, excluded\\n        target--;\\n        for (int i = k + 1, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0;\\n        // running loops until we get all our tickets\\n        while (ts[k]) {\\n            // running one loop\\n            for (int i = 0, lmt = ts.size(); i < lmt && ts[k]; i++) {\\n                // decreasing one slot and increasing res, if the slot still queues\\n                if (ts[i]) {\\n                    ts[i]--;\\n                    res++;\\n                }\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue\\n        for (int i = 0, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and what we need to get\\n            res += min(ts[i], target - (i > k));\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue up to k, included\\n        for (int i = 0; i <= k; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        // parsing the queue up from  k, excluded\\n        target--;\\n        for (int i = k + 1, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577090,
                "title": "easy-to-understand",
                "content": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n     \\n    let countTime = 0;\\n\\n    while(tickets[k] !== 0){\\n\\n        for(let i = 0; i < tickets.length; i++){\\n            \\n            if(tickets[k] == 0){\\n                return countTime;\\n            }\\n            if(tickets[i] !== 0){\\n                tickets[i] = tickets[i] - 1;\\n                countTime++;\\n            }\\n        }\\n\\n    }\\n\\n    return countTime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n     \\n    let countTime = 0;\\n\\n    while(tickets[k] !== 0){\\n\\n        for(let i = 0; i < tickets.length; i++){\\n            \\n            if(tickets[k] == 0){\\n                return countTime;\\n            }\\n            if(tickets[i] !== 0){\\n                tickets[i] = tickets[i] - 1;\\n                countTime++;\\n            }\\n        }\\n\\n    }\\n\\n    return countTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778911,
                "title": "python-o-n-easy-method",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t#Loop through all elements in list only once.  \\n\\t\\t\\n        nums = tickets \\n        time_sec = 0\\n\\t\\t# save the number of tickets to be bought by person standing at k position\\n        least_tickets = nums[k]     \\n\\t\\t#(3) Any person nums[i] having tickets more than the k pos person, will buy tickets least_tickets times only.\\n\\t\\t#(2) Person nums[i] having tickets less than kth person ( nums[i] < least_tickets ), and standing before him(i<k), will be able to buy nums[i] amount.\\n\\t\\t#(1) Person nums[i] standing after kth person having more tickets than kth person, will be able to buy one less than the ticket kth person can buy(condition: least_tickets - 1).\\n        for i in range(len(nums)):                  \\n            if k < i and nums[i] >= least_tickets :         #(1)\\n                time_sec += (least_tickets - 1)\\n            elif nums[i] < least_tickets :                   #(2)\\n                time_sec += nums[i]\\n            else:                                            #(3)\\n                time_sec += least_tickets\\n\\t\\t\\t\\t\\n        return time_sec\\n        \\nPlease upvote if you find it useful and well-explained!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t#Loop through all elements in list only once.  \\n\\t\\t\\n        nums = tickets \\n        time_sec = 0\\n\\t\\t# save the number of tickets to be bought by person standing at k position\\n        least_tickets = nums[k]     \\n\\t\\t#(3) Any person nums[i] having tickets more than the k pos person, will buy tickets least_tickets times only.\\n\\t\\t#(2) Person nums[i] having tickets less than kth person ( nums[i] < least_tickets ), and standing before him(i<k), will be able to buy nums[i] amount.\\n\\t\\t#(1) Person nums[i] standing after kth person having more tickets than kth person, will be able to buy one less than the ticket kth person can buy(condition: least_tickets - 1).\\n        for i in range(len(nums)):                  \\n            if k < i and nums[i] >= least_tickets :         #(1)\\n                time_sec += (least_tickets - 1)\\n            elif nums[i] < least_tickets :                   #(2)\\n                time_sec += nums[i]\\n            else:                                            #(3)\\n                time_sec += least_tickets\\n\\t\\t\\t\\t\\n        return time_sec\\n        \\nPlease upvote if you find it useful and well-explained!",
                "codeTag": "Java"
            },
            {
                "id": 1576991,
                "title": "python-1-liner",
                "content": "```python\\nreturn sum(min(tickets[k] - (i > k), num) for i, num in enumerate(tickets))\\n```",
                "solutionTags": [],
                "code": "```python\\nreturn sum(min(tickets[k] - (i > k), num) for i, num in enumerate(tickets))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577014,
                "title": "java-easy-solution-o-n",
                "content": "**Time Needed to Buy Tickets**\\n\\nSimple and crisp Solution - \\n\\n**Input:** tickets = [2,3,2], k = 2\\n**Output:** 6\\n**Explanation:** \\n- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].\\n- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].\\nThe person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\\n\\n```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTaken = 0;\\n        while(tickets[k] > 0) {\\n        \\tfor(int i = 0; i < tickets.length; i++) {\\n        \\t\\tif(tickets[i] > 0) {\\n        \\t\\t\\ttickets[i]--;\\n        \\t\\t\\ttimeTaken++;\\n        \\t\\t}\\n                if(tickets[k] == 0)  break;\\n        \\t}\\n        }\\n        return timeTaken;\\n    }\\n```\\n\\t\\nTime Complexity - **O(n^2)**\\n\\n\\t\\n```\\n\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t      int timeTaken = 0;\\n          for(int i = 0; i < tickets.length; i++){\\n                if(tickets[i] <= tickets[k]){\\n                     timeTaken += tickets[i];\\n                }\\n                else  timeTaken += tickets[k];\\n                if(i > k && tickets[i] >= tickets[k])  timeTaken--;\\n          }\\n          return timeTaken;\\n    }\\n```\\t\\n\\t\\nTime Complexity - **O(n)**\\n\\nCredit - @yadavharsha50",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTaken = 0;\\n        while(tickets[k] > 0) {\\n        \\tfor(int i = 0; i < tickets.length; i++) {\\n        \\t\\tif(tickets[i] > 0) {\\n        \\t\\t\\ttickets[i]--;\\n        \\t\\t\\ttimeTaken++;\\n        \\t\\t}\\n                if(tickets[k] == 0)  break;\\n        \\t}\\n        }\\n        return timeTaken;\\n    }\\n```\n```\\n\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t      int timeTaken = 0;\\n          for(int i = 0; i < tickets.length; i++){\\n                if(tickets[i] <= tickets[k]){\\n                     timeTaken += tickets[i];\\n                }\\n                else  timeTaken += tickets[k];\\n                if(i > k && tickets[i] >= tickets[k])  timeTaken--;\\n          }\\n          return timeTaken;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584144,
                "title": "c-very-easy-o-n-my-thought",
                "content": "Hint :- Simple solustion is to count time for every element and return sum of it. \\n\\nJust bruthforces, Element before k index take min of element or that index value and ,after k index it take min of element-1 or that index. Here element-1 because in last round we will not go for element which index is greater then k.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int ans =0;\\n            int n = tickets.size();\\n            int ele = tickets[k];\\n            for(int i=0;i< n; i++){\\n                    if(i<=k){\\n                        ans+= min(ele, tickets[i]);\\n                    }else{\\n                        ans+= min(ele-1, tickets[i]);   \\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```\\n\\n**Upvote If like my solustion ::)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int ans =0;\\n            int n = tickets.size();\\n            int ele = tickets[k];\\n            for(int i=0;i< n; i++){\\n                    if(i<=k){\\n                        ans+= min(ele, tickets[i]);\\n                    }else{\\n                        ans+= min(ele-1, tickets[i]);   \\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189150,
                "title": "c-solution-beats-100-easy-to-understand-and-easy-solution",
                "content": "# Intuition\\nWe have to just keep decreasing 1 from each element.\\n\\n# Approach\\n1. We will traverse the array and keep decreasing 1 from every element till the element at kth position gets 0.\\n2. We will also keep a count variable to keep track of the steps required for kth element to reach 0.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0, i = 0;\\n\\n        while(tickets[k] != 0){\\n            if(i == tickets.size()){\\n                i = 0;\\n            }\\n            if(tickets[i] == 0){\\n                i++;\\n                continue;\\n            }\\n            tickets[i]--;\\n            count++;\\n            i++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0, i = 0;\\n\\n        while(tickets[k] != 0){\\n            if(i == tickets.size()){\\n                i = 0;\\n            }\\n            if(tickets[i] == 0){\\n                i++;\\n                continue;\\n            }\\n            tickets[i]--;\\n            count++;\\n            i++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582397,
                "title": "1-ms-java-solution",
                "content": "```\\n public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int seconds = 0;\\n        int i = 0;\\n        while(tickets[k] != 0)\\n        {\\n            if(tickets[i] != 0)\\n            {\\n                tickets[i] = tickets[i] -1;\\n                seconds++;\\n            }\\n            if(i == tickets.length - 1)\\n            {\\n                i = 0;\\n                continue;\\n            }\\n                i++;\\n        }\\n\\n        return seconds;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int seconds = 0;\\n        int i = 0;\\n        while(tickets[k] != 0)\\n        {\\n            if(tickets[i] != 0)\\n            {\\n                tickets[i] = tickets[i] -1;\\n                seconds++;\\n            }\\n            if(i == tickets.length - 1)\\n            {\\n                i = 0;\\n                continue;\\n            }\\n                i++;\\n        }\\n\\n        return seconds;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2037468,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<pair<int,int>>q;\\n        int time = 0;\\n        for(int i = 0; i < tickets.size(); i++)\\n        {\\n            q.push({tickets[i],i});\\n        }\\n        while(!q.empty())\\n        {\\n            pair<int,int> tmp = q.front();\\n            q.pop();\\n            --tmp.first;\\n            ++time;\\n            if(tmp.first == 0 && tmp.second == k)\\n            {\\n                break;\\n            }\\n            else if(tmp.first != 0)\\n            {\\n                q.push({tmp.first,tmp.second});\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<pair<int,int>>q;\\n        int time = 0;\\n        for(int i = 0; i < tickets.size(); i++)\\n        {\\n            q.push({tickets[i],i});\\n        }\\n        while(!q.empty())\\n        {\\n            pair<int,int> tmp = q.front();\\n            q.pop();\\n            --tmp.first;\\n            ++time;\\n            if(tmp.first == 0 && tmp.second == k)\\n            {\\n                break;\\n            }\\n            else if(tmp.first != 0)\\n            {\\n                q.push({tmp.first,tmp.second});\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577912,
                "title": "brute-deque-optimised-in-one-pass",
                "content": "1)BRUTE FORCE APPROACH -> \\nA) SIMULATE THE GIVEN PROBLEM USING DEQUE DATA STRUCTURE  \\nKEEP A COUNTER WHEN KTH ELEMENT BECOMES 0 THATS EASY :)\\n\\nTC -> O(K * ARR[K]) -> IN WORST CASE IF K IS LAST ELEMENT\\nSC -> O(2*N) -> TAKEN A PAIR\\n\\nCODE -> \\n```\\n\\t\\tdeque<pair<int,int>>dq;\\n        for(int i = 0;  i < tickets.size(); i++) {\\n            dq.push_back({tickets[i] , i});\\n        }\\n        int ans = 0;\\n        while(!dq.empty()) {\\n            int val = dq.front().first;\\n            int idx = dq.front().second;\\n            val--;\\n            ans++;\\n            if(idx == k && val == 0) {\\n                break;\\n            }\\n            if(val == 0) {\\n                dq.pop_front();\\n            } else {\\n                dq.pop_front();\\n                dq.push_back({val, idx});\\n            }\\n        }\\n        return ans;\\n```\\n\\nOPTIMISED APPROACH->\\n\\nTHINK WITH RESPECT TO K -> TAKE 2 CASES\\n1) ELEMENTS BEFORE K -> WILL TAKE MIN(ARR[I] , ARR[K]) STEPS IN TOTAL\\n2) ELEMENTS AFTER K  ->  WILL TAKE MIN(ARR[I] , ARR[K] - 1 STEPS) IN TOTAL\\n3) YOUR ANS IS (1 + 2) -> \\n\\nCODE -> \\n```\\n\\t int ans = 1;\\n        int val = tickets[k];\\n        for(int i = 0 ; i < tickets.size(); i++) {\\n            if(i < k) {\\n                //THE ELEMENTS THAT LIE BEFORE K\\n                if(tickets[i]  < val) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += val;\\n                }\\n            } else {\\n                //THE ELEMENTS THAT LIE AFTER K\\n                if(tickets[i] < val - 1) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += (val - 1);\\n                }   \\n            }   \\n        } \\n        return ans;\\n```\\n\\nTC -> O(N) SINGLE PASS\\nSC -> O(1) :)\\n\\nTHANK YOU DO SHARE AND UPVOTE IF YOU LIKED THE APPROACH\\n",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\n\\t\\tdeque<pair<int,int>>dq;\\n        for(int i = 0;  i < tickets.size(); i++) {\\n            dq.push_back({tickets[i] , i});\\n        }\\n        int ans = 0;\\n        while(!dq.empty()) {\\n            int val = dq.front().first;\\n            int idx = dq.front().second;\\n            val--;\\n            ans++;\\n            if(idx == k && val == 0) {\\n                break;\\n            }\\n            if(val == 0) {\\n                dq.pop_front();\\n            } else {\\n                dq.pop_front();\\n                dq.push_back({val, idx});\\n            }\\n        }\\n        return ans;\\n```\n```\\n\\t int ans = 1;\\n        int val = tickets[k];\\n        for(int i = 0 ; i < tickets.size(); i++) {\\n            if(i < k) {\\n                //THE ELEMENTS THAT LIE BEFORE K\\n                if(tickets[i]  < val) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += val;\\n                }\\n            } else {\\n                //THE ELEMENTS THAT LIE AFTER K\\n                if(tickets[i] < val - 1) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += (val - 1);\\n                }   \\n            }   \\n        } \\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3918164,
                "title": "brute-force-optimized-queue-interviewer-mindset",
                "content": "# Intuition\\n1. Brute force using loop iteration\\n2. optimised using one loop\\n3. Queue solution for more in depth\\n\\n# Approach\\nWe find out min of tickets[i] and tickets[k]\\n\\n\\n\\n## Brute force approach\\n- Time complexity: O(N^2)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k){\\n        int n= tickets.length;\\n        int time=0;\\n    \\n        if(tickets[k]==1) return k+1;\\n        while(tickets[k]>0){\\n            for(int i=0;i<n;i++){\\n                if(tickets[i]==0) continue;\\n                tickets[i]=tickets[i]-1;\\n                time++;\\n                if(tickets[k]==0) break;\\n            }\\n        }k--;\\n        return time;\\n    }\\n}\\n\\n```\\n## Optimized approach: without extra space\\n\\n- Time complexity: O(N)\\n- - space complexity: O(1)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                time += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                time+= Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n\\n```\\n## Queue approach : taking extra space\\n- Time complexity: O(N)\\n- space complexity: O(N)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\n            q.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```\\n![cat-upvote.jpg](https://assets.leetcode.com/users/images/7c799b02-abd9-44f8-98a2-e4830340d206_1692193011.7738297.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k){\\n        int n= tickets.length;\\n        int time=0;\\n    \\n        if(tickets[k]==1) return k+1;\\n        while(tickets[k]>0){\\n            for(int i=0;i<n;i++){\\n                if(tickets[i]==0) continue;\\n                tickets[i]=tickets[i]-1;\\n                time++;\\n                if(tickets[k]==0) break;\\n            }\\n        }k--;\\n        return time;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                time += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                time+= Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\n            q.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615121,
                "title": "100-beats-o-n-solution-without-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n       int n=tickets.size();\\n       int total=tickets[k];\\n\\n        for(int i=0;i<k;i++){\\n            total+=min(tickets[k],tickets[i]);\\n        }\\n        for(int i=k+1;i<n;i++){\\n            total+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n       int n=tickets.size();\\n       int total=tickets[k];\\n\\n        for(int i=0;i<k;i++){\\n            total+=min(tickets[k],tickets[i]);\\n        }\\n        for(int i=k+1;i<n;i++){\\n            total+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567182,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n    int count=0;\\n        while(tickets[k]>0){\\n            for(int i=0;i<tickets.length;i++){\\n                if(tickets[i]>0){\\n                    tickets[i]-=1;\\n                    count++;\\n                }\\n                if(tickets[k]==0)break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n    int count=0;\\n        while(tickets[k]>0){\\n            for(int i=0;i<tickets.length;i++){\\n                if(tickets[i]>0){\\n                    tickets[i]-=1;\\n                    count++;\\n                }\\n                if(tickets[k]==0)break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489688,
                "title": "python-simple-and-clean-beats-77-69",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n##### **Single Pass Solution**\\n1. People before *k-th* person will take mininum of reqd tickets and *k-th* person ticket\\n2. People after *k-th* person will take 1 ticket less than, because after oue person takes the ticket the objective will be completed and we do not need to count more time for people **standing after him**\\n\\n##### **Implementation**\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num = tickets[k]\\n        res = 0\\n        for i in range(k+1):\\n            res += min(tickets[i],num)\\n        for i in range(k+1,len(tickets)):\\n            res += min(tickets[i],num-1)\\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7ab4074a-00a1-49e3-a1fb-fc62d50bfe0f_1661594988.4600484.png)\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num = tickets[k]\\n        res = 0\\n        for i in range(k+1):\\n            res += min(tickets[i],num)\\n        for i in range(k+1,len(tickets)):\\n            res += min(tickets[i],num-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763737,
                "title": "java-solution-faster-than-100-of-all-submissions-o-n",
                "content": "```\\n\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n      int output = 0;\\n      int n = tickets.length;\\n      for  (int i = 0;i<n;i++){\\n          if(tickets[i] < tickets[k]){\\n              output += tickets[i];\\n          }else{\\n                if(i <= k){\\n                  output += tickets[k];\\n              }else { \\n                  output += tickets[k] - 1;\\n              } \\n          }\\n\\n      }\\n      return output;\\n    }\\n}\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n      int output = 0;\\n      int n = tickets.length;\\n      for  (int i = 0;i<n;i++){\\n          if(tickets[i] < tickets[k]){\\n              output += tickets[i];\\n          }else{\\n                if(i <= k){\\n                  output += tickets[k];\\n              }else { \\n                  output += tickets[k] - 1;\\n              } \\n          }\\n\\n      }\\n      return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577071,
                "title": "c-0ms-explained-easy-one-pass",
                "content": "Three cases possible are,\\n\\n`If` the ticket holders have less tickets to buy than our Kth ticket holder, they will have got all the tickets they wanted before kth ticket holder gets all its tickets,\\n\\n`else if` the ticket holders have more ticketsto buy than our Kth ticket holder, and they are ahead in line(position < k) then, they will have bought `tickets[k]` tickets before kth ticket holder gets all the tickets it needs,\\n\\n`else if` the ticket holders have more tickets to buy than our Kth ticket holder, and they are behind in line(position > k) then, they will have bought 1 ticket less than `tickets[k]` before kth ticket holder gets all the tickets it needs.\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int ticket = tickets[k];\\n        int res = 0;\\n        for(int i = 0; i<tickets.size(); i++){\\n          if(tickets[i] < ticket) res+=tickets[i];\\n          else if(tickets[i] >= ticket and i <= k) res+=ticket;\\n          else if(tickets[i] >= ticket and i > k) res+=ticket-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int ticket = tickets[k];\\n        int res = 0;\\n        for(int i = 0; i<tickets.size(); i++){\\n          if(tickets[i] < ticket) res+=tickets[i];\\n          else if(tickets[i] >= ticket and i <= k) res+=ticket;\\n          else if(tickets[i] >= ticket and i > k) res+=ticket-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490739,
                "title": "very-easy-java-solution-using-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        int ans = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        while(!queue.isEmpty()){\\n            int index = queue.poll();\\n            tickets[index]--;\\n            ans++;\\n            if(tickets[index] == 0 && index == k){\\n                return ans;\\n            }\\n            if(tickets[index] > 0){\\n                queue.add(index);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        int ans = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        while(!queue.isEmpty()){\\n            int index = queue.poll();\\n            tickets[index]--;\\n            ans++;\\n            if(tickets[index] == 0 && index == k){\\n                return ans;\\n            }\\n            if(tickets[index] > 0){\\n                queue.add(index);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607037,
                "title": "java-simple-code-100-faster",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int seconds = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]) seconds += tickets[i]; // only add the time needed to buy his tickets\\n            else{\\n                if(i <= k) seconds += tickets[k]; \\n                else seconds += tickets[k] - 1; \\n            }\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int seconds = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]) seconds += tickets[i]; // only add the time needed to buy his tickets\\n            else{\\n                if(i <= k) seconds += tickets[k]; \\n                else seconds += tickets[k] - 1; \\n            }\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495619,
                "title": "one-pass-c-easy-to-understand",
                "content": "People infront of our target person will get all their tickets before our target man if they want tickets less than or equal to him. If they want more tickets than him they will only get tickets equal to him till target man gets all his tickets.\\n\\nFor people behind target man, they will get all tickets if they want tickets strictly less than him. If they want more than him, they will get one less than tickets target man wants till he gets all his tickets.\\n\\'\\'\\'\\n              \\n    class Solution {\\n    public:\\n        int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int n=tickets.size();\\n            int time=tickets[k];\\n            for(int i=0;i<tickets.size();i++){\\n            //Elements infront of target\\n                  //If they are smaller or equal to target value collect them whole \\n                  //If they are greater collect target value\\n            if(i<k){\\n                if(tickets[i]<=tickets[k]){\\n                    time+=tickets[i];\\n                }\\n                else{\\n                    time+=tickets[k];\\n                }\\n            }\\n            //Elements behind target\\n                  //If they are smaller than target value collect them whole \\n                  //If they are greater collect (target-1) value\\n            else if(i>k){\\n                if(tickets[i]<tickets[k]){\\n                    time+=tickets[i];\\n                }\\n                else{\\n                    time+=(tickets[k]-1);\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\t\\t\\t        \\n\\t\\t\\t      \\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n        int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int n=tickets.size();\\n            int time=tickets[k];\\n            for(int i=0;i<tickets.size();i++){\\n            //Elements infront of target\\n                  //If they are smaller or equal to target value collect them whole \\n                  //If they are greater collect target value\\n            if(i<k){\\n                if(tickets[i]<=tickets[k]){\\n                    time+=tickets[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1642918,
                "title": "simple-c-solution-0ms",
                "content": "This is easy to understand solution..\\nDo give a like!.\\n\\n\\n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n    int n=tickets.size(),ans=0;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        if(i>k)\\n            ans+=min(tickets[i],tickets[k]-1);\\n        else if(i<k)\\n            ans+=min(tickets[i],tickets[k]);\\n        else\\n            ans+=tickets[k];\\n                \\n    }\\n        \\n    return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "This is easy to understand solution..\\nDo give a like!.\\n\\n\\n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n    int n=tickets.size(),ans=0;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        if(i>k)\\n            ans+=min(tickets[i],tickets[k]-1);\\n        else if(i<k)\\n            ans+=min(tickets[i],tickets[k]);\\n        else\\n            ans+=tickets[k];\\n                \\n    }\\n        \\n    return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3485730,
                "title": "python3-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        n=len(tickets)\\n        q=deque([i for i in range(n)])\\n        \\n        time=0\\n        \\n        while q:\\n            for i in range(len(q)):\\n\\n                node=q.popleft()\\n                tickets[node]-=1\\n                if tickets[node]>=1:\\n                    q.append(node)\\n                \\n                time+=1\\n                if tickets[k]==0:\\n                    return time\\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        n=len(tickets)\\n        q=deque([i for i in range(n)])\\n        \\n        time=0\\n        \\n        while q:\\n            for i in range(len(q)):\\n\\n                node=q.popleft()\\n                tickets[node]-=1\\n                if tickets[node]>=1:\\n                    q.append(node)\\n                \\n                time+=1\\n                if tickets[k]==0:\\n                    return time\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253744,
                "title": "c-2-ways-bruteforce-optimal",
                "content": "# Method-1 [Brute Force]\\n\\n![image](https://assets.leetcode.com/users/images/c883d3c4-59d3-430e-a16d-5e1b6532e52b_1657263680.476677.png)\\n\\n**n==t.size()\\nT->O(tickets[k] * n) && S->(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint timeRequiredToBuy(vector<int>& t, int k) {\\n\\t\\t\\tint time=0;\\n\\t\\t\\twhile(1){\\n\\t\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\t\\tif(t[i]>0){\\n\\t\\t\\t\\t\\t\\tt[i]--;\\n\\t\\t\\t\\t\\t\\ttime++;\\n\\t\\t\\t\\t\\t\\tif(t[k]==0)return time;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\n# Method-2 [Optimal solution]\\t\\n\\t\\n![image](https://assets.leetcode.com/users/images/98e24ff0-6f30-429b-8292-63a194bf3895_1657264759.6914196.png)\\n\\n**In one pass!\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint timeRequiredToBuy(vector<int>& t, int k) {\\n\\t\\t\\tint time=0;\\n\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\tif(t[i]<t[k])time+=t[i];\\n\\t\\t\\t\\telse time+=t[k];\\n\\t\\t\\t\\tif(i>k && t[i]>=t[k])time--;\\n\\t\\t\\t}\\n\\t\\t\\treturn time;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint timeRequiredToBuy(vector<int>& t, int k) {\\n\\t\\t\\tint time=0;\\n\\t\\t\\twhile(1){\\n\\t\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\t\\tif(t[i]>0){\\n\\t\\t\\t\\t\\t\\tt[i]--;\\n\\t\\t\\t\\t\\t\\ttime++;\\n\\t\\t\\t\\t\\t\\tif(t[k]==0)return time;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2147186,
                "title": "c-queue-cycle",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> q;\\n        for(int i : tickets) q.push(i);\\n        int res = 0;\\n        int p = k;\\n        \\n        while(true){\\n            res++;\\n            if(q.front()-- > 1) q.push(q.front());\\n            else if(p == 0) break;\\n            q.pop();\\n            if(--p < 0) p = q.size() - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> q;\\n        for(int i : tickets) q.push(i);\\n        int res = 0;\\n        int p = k;\\n        \\n        while(true){\\n            res++;\\n            if(q.front()-- > 1) q.push(q.front());\\n            else if(p == 0) break;\\n            q.pop();\\n            if(--p < 0) p = q.size() - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104569,
                "title": "0-ms-java-solution",
                "content": "suppose the given array is [2,3,7,5,1,2,7] and k is pointing to element = 5.\\nwe need to find that each element is reduced how many times till we get 0 at the index 3. The element before 5 will be reduced by = **minimum of (value of ith element, value of kth element)**\\n the element before 5 are [2,3,7,5] and these will be reduced to [0,0,2,0] when the kth guy get ticket \\n \\n![image](https://assets.leetcode.com/users/images/bfea9c2c-94db-4fa0-8e6b-f20bf067424a_1654226809.5009036.png)\\n\\nnow element after 5 are [1,2,7] here we have a case, the element 1,2 will be completly reduce to 0 but the element greater than k will reduce to 1 lesser than the kth element (shown below ) because the kth element guy got the ticket and we don\\'t need to worry about the leftover.\\n\\n![image](https://assets.leetcode.com/users/images/c826088c-eaf7-4d83-9543-a55494e2c89c_1654226960.949127.png)\\n\\n**please upvote my solution if u like it \\u2764\\uFE0F** \\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0 ; i < tickets.length; ++i){\\n            if(i <=k){\\n                count += Math.min(tickets[i], tickets[k]);\\n            }\\n            else\\n                count += Math.min(tickets[i], tickets[k] - 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0 ; i < tickets.length; ++i){\\n            if(i <=k){\\n                count += Math.min(tickets[i], tickets[k]);\\n            }\\n            else\\n                count += Math.min(tickets[i], tickets[k] - 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084750,
                "title": "python-simple-readable-easy-to-understand-solution-beats-69",
                "content": "The approach is as follows:\\n1. Keep track of the number of seconds (this is what will be returned)\\n2. As long as the person at k index still has tickets to buy:\\n\\t* Sell tickets to everyone in the line who still has tickets to buy\\n\\t* Add a second for each ticket sold\\n3. Return how many seconds were needed to sell the person at k index all of their tickets\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num_seconds = 0\\n        \\n        while tickets[k] > 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0 and tickets[k] > 0:\\n                    tickets[i] -= 1\\n                    num_seconds += 1\\n\\n        return num_seconds\\n```\\n![image](https://assets.leetcode.com/users/images/6c478172-bc00-416c-9d13-fbda59d8cb15_1653763898.4271393.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num_seconds = 0\\n        \\n        while tickets[k] > 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0 and tickets[k] > 0:\\n                    tickets[i] -= 1\\n                    num_seconds += 1\\n\\n        return num_seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958399,
                "title": "c-easy-o-n",
                "content": "***Upvote If you like the solution***\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int num=tickets[k],tt=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(num>tickets[i]){\\n                tt+=tickets[i];\\n            }\\n            else if(num<=tickets[i]){\\n                tt+=num;\\n            }\\n        }\\n        for(int i=k+1;i<tickets.size();i++){\\n            if(tickets[i]>=num){\\n                tt-=1;\\n            }\\n        }\\n        return tt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int num=tickets[k],tt=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(num>tickets[i]){\\n                tt+=tickets[i];\\n            }\\n            else if(num<=tickets[i]){\\n                tt+=num;\\n            }\\n        }\\n        for(int i=k+1;i<tickets.size();i++){\\n            if(tickets[i]>=num){\\n                tt-=1;\\n            }\\n        }\\n        return tt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612829,
                "title": "python-o-n-time-complexity-faster-than-97",
                "content": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        ans = 0\\n        \\n\\t\\t# people at the front will always get 1 ticket first\\n\\t\\t# get minimum to know how many times a person will queue and buy before kth person\\n        for tix in range(k+1):\\n            ans += min(tickets[tix], tickets[k])\\n\\n\\t\\t# contrary to people at the front, \\n\\t\\t# kth person will only go behind everyone *(people initially behind k)* for tickets[k]-1 times \\n        for tix in range(k+1, len(tickets)):\\n            ans += min(tickets[tix], tickets[k]-1)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        ans = 0\\n        \\n\\t\\t# people at the front will always get 1 ticket first\\n\\t\\t# get minimum to know how many times a person will queue and buy before kth person\\n        for tix in range(k+1):\\n            ans += min(tickets[tix], tickets[k])\\n\\n\\t\\t# contrary to people at the front, \\n\\t\\t# kth person will only go behind everyone *(people initially behind k)* for tickets[k]-1 times \\n        for tix in range(k+1, len(tickets)):\\n            ans += min(tickets[tix], tickets[k]-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576949,
                "title": "python3-1-line",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/8d693371fa97ea3b0717d02448c77201b15e5d12) for solutions of weekly 267.\\n\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(tickets[k]-int(i>k), x) for i, x in enumerate(tickets))\\n```\\n\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ans = behind = 0 \\n        for i, x in enumerate(tickets): \\n            if i > k: behind = 1\\n            if x < tickets[k] - behind: ans += x\\n            else: ans += tickets[k] - behind\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(tickets[k]-int(i>k), x) for i, x in enumerate(tickets))\\n```\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ans = behind = 0 \\n        for i, x in enumerate(tickets): \\n            if i > k: behind = 1\\n            if x < tickets[k] - behind: ans += x\\n            else: ans += tickets[k] - behind\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981218,
                "title": "two-simple-solutions-in-python3-queue-ds-inifinite-looping",
                "content": "# Intuition\\nFollowing to the description of the problem, the task goal is to calculate **min amount of time**, that `K`- buyer needs to spend in order to buy tickets.\\n\\nSomehow we need to iterate over all buyers, reduce the current amount of tickets they\\'re bying at the moment, shift the current buyer to **the END of a** `queue` and repeat the process.\\n\\n---\\n\\n- **Queue DS**\\n\\nIf you haven\\'t already familiar with [Queue DS](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)), just follow the link to know more!\\n\\n1. change `tickets` variable by initializing a `deque` and **map** `i` and `v` for current buyer, \\n2. initialize `ans` variable and `while` loop, that\\'ll iterate **infinitely**\\n3. pop from `tickets` current buyer\\n4. increment total amount `ans` \\n5. check, if the current buyer has bought all of the tickets, and return `ans`\\n6. otherwise, if he needs to buy **more** tickets, return him to the `tickets` queue\\n\\n```python\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        tickets = deque([[i, v] for i, v in enumerate(tickets)])\\n        ans = 0\\n\\n        while True:\\n            i, v = tickets.popleft()\\n            ans += 1\\n\\n            if i == k and v - 1 == 0:\\n                return ans\\n            \\n            if v > 1:\\n                tickets.append([i, v - 1])\\n```\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating infinitely over all `tickets` buyers\\n\\n- Space complexity: **O(n)**, to map indexes and values for `tickets`\\n\\n---\\n\\n- **Inifinite looping**\\nThe approach is the same, but we **mutate** the initial values of `tickets`.\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        if tickets[k] == 0:\\n            return 0\\n        \\n        i = 0\\n        ans = 0\\n\\n        while True:\\n            if tickets[i]:\\n                tickets[i] -= 1\\n                ans += 1\\n\\n            if i == k and tickets[i] == 0:\\n                return ans\\n            \\n            i += 1\\n            \\n            if i == len(tickets):\\n                i = 0\\n\\n```\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating infinitely over all `tickets` buyers\\n\\n- Space complexity: **O(1)**, because we don\\'t use extra space.\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        tickets = deque([[i, v] for i, v in enumerate(tickets)])\\n        ans = 0\\n\\n        while True:\\n            i, v = tickets.popleft()\\n            ans += 1\\n\\n            if i == k and v - 1 == 0:\\n                return ans\\n            \\n            if v > 1:\\n                tickets.append([i, v - 1])\\n```\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        if tickets[k] == 0:\\n            return 0\\n        \\n        i = 0\\n        ans = 0\\n\\n        while True:\\n            if tickets[i]:\\n                tickets[i] -= 1\\n                ans += 1\\n\\n            if i == k and tickets[i] == 0:\\n                return ans\\n            \\n            i += 1\\n            \\n            if i == len(tickets):\\n                i = 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367526,
                "title": "time-needed-to-buy-tickets-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int i, time=0;\\n        while(true)\\n        {\\n            for(i=0 ; i<tickets.size() ; i++)\\n            {\\n                if(tickets[k]==0)\\n                    return time;\\n                else if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    time++;\\n                }\\n            }\\n            i=0;\\n        }\\n        return time;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int i, time=0;\\n        while(true)\\n        {\\n            for(i=0 ; i<tickets.size() ; i++)\\n            {\\n                if(tickets[k]==0)\\n                    return time;\\n                else if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    time++;\\n                }\\n            }\\n            i=0;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158772,
                "title": "easy-solution-with-explanation",
                "content": "If you like it, please upvote\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    // current index\\n    let i = 0;\\n    // number of steps\\n    let steps = 0;\\n\\n    // while tickets[k] > 0\\n    while (tickets[k]) {\\n        // we do not need to reset i because it is easier to calculate index in the array\\n        const index = i % tickets.length;\\n        if (tickets[index]) {\\n            // if element is not 0 then decrement the value and increment the number of steps\\n            tickets[index]--;\\n            steps++;\\n        }\\n        // every time move to next element\\n        i++;\\n    }\\n\\n    return steps;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    // current index\\n    let i = 0;\\n    // number of steps\\n    let steps = 0;\\n\\n    // while tickets[k] > 0\\n    while (tickets[k]) {\\n        // we do not need to reset i because it is easier to calculate index in the array\\n        const index = i % tickets.length;\\n        if (tickets[index]) {\\n            // if element is not 0 then decrement the value and increment the number of steps\\n            tickets[index]--;\\n            steps++;\\n        }\\n        // every time move to next element\\n        i++;\\n    }\\n\\n    return steps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3076905,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans =0;\\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                ans+=Math.min(tickets[i],tickets[k]);\\n            }else{\\n                ans+=Math.min(tickets[k]-1,tickets[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans =0;\\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                ans+=Math.min(tickets[i],tickets[k]);\\n            }else{\\n                ans+=Math.min(tickets[k]-1,tickets[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061869,
                "title": "java-1ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i] > 0) {\\n                    count++;\\n                    tickets[i]--;\\n                }\\n                if (i == k && tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i] > 0) {\\n                    count++;\\n                    tickets[i]--;\\n                }\\n                if (i == k && tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936461,
                "title": "cpp-queue-easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        queue<int> q;\\n        int n=tickets.size();\\n        for(int i=0;i<n;i++) q.push(i);\\n\\n        while(true)\\n        {\\n            if(tickets[k]==0) break;\\n            int curr=q.front();\\n            time++;\\n            tickets[curr]--;\\n            q.pop();\\n            if(tickets[curr]!=0) \\n            {\\n                q.push(curr);\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        queue<int> q;\\n        int n=tickets.size();\\n        for(int i=0;i<n;i++) q.push(i);\\n\\n        while(true)\\n        {\\n            if(tickets[k]==0) break;\\n            int curr=q.front();\\n            time++;\\n            tickets[curr]--;\\n            q.pop();\\n            if(tickets[curr]!=0) \\n            {\\n                q.push(curr);\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919190,
                "title": "c-basic-solution-beats-100",
                "content": "# Intuition\\nBasic C++ Solution using logic\\n\\n# Approach\\nCounting tickets to be bought before and after k by taking minima.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(i<=k)\\n              time+=min(tickets[i],tickets[k]);\\n            else\\n              time+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(i<=k)\\n              time+=min(tickets[i],tickets[k]);\\n            else\\n              time+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903503,
                "title": "js-very-easy-and-fast-solution-o-n",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let output = 0;\\n    const kTickets = tickets[k];\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i !== k) {\\n            const currentTickets = tickets[i];\\n            const dif = currentTickets - kTickets;\\n            if (i < k) {\\n                output += kTickets + (dif < 0 ? dif : 0);\\n            } else {\\n                output += (dif + 1 > 0 ? kTickets - 1 : currentTickets);\\n            }\\n        }\\n    }\\n    return output + kTickets;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let output = 0;\\n    const kTickets = tickets[k];\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i !== k) {\\n            const currentTickets = tickets[i];\\n            const dif = currentTickets - kTickets;\\n            if (i < k) {\\n                output += kTickets + (dif < 0 ? dif : 0);\\n            } else {\\n                output += (dif + 1 > 0 ? kTickets - 1 : currentTickets);\\n            }\\n        }\\n    }\\n    return output + kTickets;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852598,
                "title": "java-code-without-queue-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n    int ans=0;\\n\\n    while(tickets[k]>0){\\n        \\n    int count=0;\\n\\n    for(int j=0;j<tickets.length;j++){\\n\\n        if(tickets[j]>0&&tickets[k]!=0){\\n            tickets[j]-=1;\\n            count+=1;\\n        }\\n\\n    }\\n\\n    ans=ans+count;\\n\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n    int ans=0;\\n\\n    while(tickets[k]>0){\\n        \\n    int count=0;\\n\\n    for(int j=0;j<tickets.length;j++){\\n\\n        if(tickets[j]>0&&tickets[k]!=0){\\n            tickets[j]-=1;\\n            count+=1;\\n        }\\n\\n    }\\n\\n    ans=ans+count;\\n\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724197,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=tickets[k];\\n        for(int i=0;i<tickets.size();i++){\\n        if(i<k){\\n            if(tickets[i]<=tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=tickets[k];\\n            }\\n        }\\n        else if(i>k){\\n            if(tickets[i]<tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=(tickets[k]-1);\\n            }\\n        }\\n    }\\n    return time;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=tickets[k];\\n        for(int i=0;i<tickets.size();i++){\\n        if(i<k){\\n            if(tickets[i]<=tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=tickets[k];\\n            }\\n        }\\n        else if(i>k){\\n            if(tickets[i]<tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=(tickets[k]-1);\\n            }\\n        }\\n    }\\n    return time;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596216,
                "title": "java-time-complexity-o-n-and-space-complexity-o-1-100-faster",
                "content": "Idea is quite simple\\n1. All the seconds will be consumed if tickets[i] < tickets [k].\\n2. If tickets[i] > tickets[k] then only tickets[k] will be consumed.\\n3. Just an exception to the 2nd point is that for the last iteration when all the people will consume 1 second, this will be people from 0 -> k. Hence we do tickets[k] - 1\\n\\n```\\nint minRequired = tickets[k];\\n        int output = 0;\\n\\n        for (int i = 0; i < tickets.length; i++) {\\n            if(tickets[i] < minRequired){\\n                output += tickets[i];\\n            }else {\\n\\n                if(i > k){\\n                    output--;\\n                }\\n                output += minRequired;\\n            }\\n        }\\n\\n        return output;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Idea is quite simple\\n1. All the seconds will be consumed if tickets[i] < tickets [k].\\n2. If tickets[i] > tickets[k] then only tickets[k] will be consumed.\\n3. Just an exception to the 2nd point is that for the last iteration when all the people will consume 1 second, this will be people from 0 -> k. Hence we do tickets[k] - 1\\n\\n```\\nint minRequired = tickets[k];\\n        int output = 0;\\n\\n        for (int i = 0; i < tickets.length; i++) {\\n            if(tickets[i] < minRequired){\\n                output += tickets[i];\\n            }else {\\n\\n                if(i > k){\\n                    output--;\\n                }\\n                output += minRequired;\\n            }\\n        }\\n\\n        return output;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2558725,
                "title": "java-solution-using-single-queue",
                "content": "In this solution, I multiply the target index \\'k\\' content with \\'-1\\'. to keep track of the customer.\\nAnd, I reduce the number of tickets by 1. Once the target customer\\'s tickets count reduces to zero, I return the time-taken.\\n\\n```java\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        if(tickets[k] == 0) return 0;\\n        \\n        tickets[k] = -1 * tickets[k];\\n        \\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for(int n : tickets){\\n            if(n != 0) queue.offerLast(n);\\n        }\\n        \\n        int timeTaken = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int ticket = queue.pollFirst();\\n            \\n            boolean target = ticket < 0;\\n            \\n            if(ticket < 0) ticket += 1;\\n            else ticket -= 1;\\n            \\n            ++timeTaken;\\n            \\n            if(ticket == 0 && target) break;\\n            if(ticket != 0) queue.offerLast(ticket);\\n        }\\n        \\n        return timeTaken;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Iterator"
                ],
                "code": "```java\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        if(tickets[k] == 0) return 0;\\n        \\n        tickets[k] = -1 * tickets[k];\\n        \\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for(int n : tickets){\\n            if(n != 0) queue.offerLast(n);\\n        }\\n        \\n        int timeTaken = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int ticket = queue.pollFirst();\\n            \\n            boolean target = ticket < 0;\\n            \\n            if(ticket < 0) ticket += 1;\\n            else ticket -= 1;\\n            \\n            ++timeTaken;\\n            \\n            if(ticket == 0 && target) break;\\n            if(ticket != 0) queue.offerLast(ticket);\\n        }\\n        \\n        return timeTaken;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195525,
                "title": "java-o-n-100-faster-solution",
                "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int t=tickets[k],tt=0;\\n        \\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                if(tickets[i]<=t){\\n                    tt+=tickets[i];\\n                }else{\\n                    tt+=t;\\n                }\\n            }else{\\n                if(tickets[i]<t){\\n                    tt+=tickets[i];\\n                }else{\\n                    tt+=(t-1);\\n                }\\n            }\\n        }\\n        \\n        return tt;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int t=tickets[k],tt=0;\\n        \\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                if(tickets[i]<=t){\\n                    tt+=tickets[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2126547,
                "title": "c-solution-0ms-100-faster-explained",
                "content": "**Method:**\\n\\n* There can be 3 cases:\\n* Case 1 :\\n    * If the ticket holders have less tickets to buy than our Kth ticket holder\\n    * Then, they will have got all the tickets they wanted before kth ticket holder gets all its tickets\\n* Case 2:\\n    * if the ticket holders have more tickets to buy than our Kth ticket holder and they are ahead in line(position < k) \\n    * Then, they will have bought \"tickets[k]\" tickets before kth ticket holder gets all the tickets it needs\\n* Case 3:\\n    * if the ticket holders have more tickets to buy than our Kth ticket holder, and they are behind in line(position > k) \\n    * Then, they will have bought 1 ticket less than tickets[k] before kth ticket holder gets all the tickets it needs.\\n\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int timeRequiredToBuy(vector<int> &tickets, int k)\\n    {\\n        int n = tickets.size();\\n        int t = tickets[k];\\n        int s = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (tickets[i] < t)\\n            {\\n                s += tickets[i];\\n            }\\n            else\\n            {\\n                if (i <= k)\\n                {\\n                    s += t;\\n                }\\n                else\\n                {\\n                    s += t - 1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int timeRequiredToBuy(vector<int> &tickets, int k)\\n    {\\n        int n = tickets.size();\\n        int t = tickets[k];\\n        int s = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (tickets[i] < t)\\n            {\\n                s += tickets[i];\\n            }\\n            else\\n            {\\n                if (i <= k)\\n                {\\n                    s += t;\\n                }\\n                else\\n                {\\n                    s += t - 1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903082,
                "title": "python-solution-using-list-as-queue",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        while(tickets[k]!=0):\\n            c+=1\\n\\t\\t\\t#check if kth element is now the first element of our queue.\\n            if(tickets[0]==1):\\n                tickets.pop(0)\\n                if(k==0):\\n                    return(c)\\n                else:\\n                    k-=1\\n            else:\\n\\t\\t\\t#if no of tickets of person at first position in queue are more than 1 we move to the back\\n                tickets.append(tickets[0]-1)\\n                tickets.pop(0)\\n                if(k==0):\\n                    k=len(tickets)-1\\n                else:\\n                    k-=1\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        while(tickets[k]!=0):\\n            c+=1\\n\\t\\t\\t#check if kth element is now the first element of our queue.\\n            if(tickets[0]==1):\\n                tickets.pop(0)\\n                if(k==0):\\n                    return(c)\\n                else:\\n                    k-=1\\n            else:\\n\\t\\t\\t#if no of tickets of person at first position in queue are more than 1 we move to the back\\n                tickets.append(tickets[0]-1)\\n                tickets.pop(0)\\n                if(k==0):\\n                    k=len(tickets)-1\\n                else:\\n                    k-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826842,
                "title": "c-solution-with-comments-faster-than-100-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int need = tickets[k];\\n        int wait = need; // k has to buy their own tickets.\\n        \\n        // For each person ahead of k in line, k has to wait for them\\n        // to buy up to as many tickets as k needs.\\n        for (int i = 0; i < k; ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        // For each person in line after k, k has to wait for them\\n        // to buy up to 1 fewer ticket than k needs.\\n        --need;\\n        for (int i = k + 1; i < tickets.size(); ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        return wait;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int need = tickets[k];\\n        int wait = need; // k has to buy their own tickets.\\n        \\n        // For each person ahead of k in line, k has to wait for them\\n        // to buy up to as many tickets as k needs.\\n        for (int i = 0; i < k; ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        // For each person in line after k, k has to wait for them\\n        // to buy up to 1 fewer ticket than k needs.\\n        --need;\\n        for (int i = k + 1; i < tickets.size(); ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        return wait;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726337,
                "title": "c-o-n-solution",
                "content": "eg: [84,49,5,24,70,77,87,8]\\n       k = 3\\n\\t   time added due to index 0(84) : 24\\n\\t   time added due to index 1(49) : 24\\n\\t   time added due to index 2(5) : 5\\n\\t   time added due to index 3(24) : 24\\n\\t   time added due to index 4(70) : 23 (because index 3 becomes 0 first).\\n\\t   time added due to index 5(77) : 23 (because index 3 becomes 0 first).\\n\\t   time added due to index 5(87) : 23 (because index 3 becomes 0 first).\\n\\t   time added due to index 6(8) : 8\\n     total time = 154 ans\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        for(int i = 0;i < n;i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        for(int i = 0;i < n;i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604802,
                "title": "python-one-pass-o-1-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        x=tickets[k]\\n        answer=0\\n        for i in range(0,k+1):\\n            answer+=min(x,tickets[i])\\n        \\n        for i in range(k+1,len(tickets)):\\n            answer+=min(x-1,tickets[i]) \\n        \\n        return answer",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        x=tickets[k]\\n        answer=0\\n        for i in range(0,k+1):\\n            answer+=min(x,tickets[i])\\n        \\n        for i in range(k+1,len(tickets)):\\n            answer+=min(x-1,tickets[i]) \\n        \\n        return answer",
                "codeTag": "Java"
            },
            {
                "id": 1599519,
                "title": "one-pass-100-solution-o-n",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        \\n        for(int i = 0;i<k;i++){\\n            if(tickets[i] >= tickets[k])\\n                res+= tickets[k];\\n            else\\n                res+= tickets[i];\\n        }\\n        for(int i = k+1;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]-1)\\n                res+= tickets[k]-1;\\n            else\\n                res+= tickets[i];\\n        }\\n        \\n        return res + tickets[k];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        \\n        for(int i = 0;i<k;i++){\\n            if(tickets[i] >= tickets[k])\\n                res+= tickets[k];\\n            else\\n                res+= tickets[i];\\n        }\\n        for(int i = k+1;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]-1)\\n                res+= tickets[k]-1;\\n            else\\n                res+= tickets[i];\\n        }\\n        \\n        return res + tickets[k];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577065,
                "title": "c-brute-force",
                "content": "```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    tickets[i] -= 1;\\n                    res += 1;\\n                }\\n                if(tickets[k] == 0) break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    tickets[i] -= 1;\\n                    res += 1;\\n                }\\n                if(tickets[k] == 0) break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577017,
                "title": "javascript-one-pass",
                "content": "```javascript\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let total = 0;\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i === k || tickets[i] < tickets[k]) {\\n            total += tickets[i];\\n        } else if (i > k) {\\n            total +=  tickets[k] - 1;\\n        } else {\\n            total += tickets[k];\\n        }\\n    }\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let total = 0;\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i === k || tickets[i] < tickets[k]) {\\n            total += tickets[i];\\n        } else if (i > k) {\\n            total +=  tickets[k] - 1;\\n        } else {\\n            total += tickets[k];\\n        }\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576972,
                "title": "c-2073-time-needed-to-buy-tickets",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0; \\n        for (int i = 0; i < tickets.size(); ++i) {\\n            if (i == k+1) tickets[k] -= 1; \\n            ans += min(tickets[i], tickets[k]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0; \\n        for (int i = 0; i < tickets.size(); ++i) {\\n            if (i == k+1) tickets[k] -= 1; \\n            ans += min(tickets[i], tickets[k]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576966,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ret = 0\\n        while tickets[k]:\\n            for i, t in enumerate(tickets):\\n                if t > 0:\\n                    tickets[i] = tickets[i] - 1\\n                    ret += 1\\n                if i == k:\\n                    if tickets[i] == 0:\\n                        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ret = 0\\n        while tickets[k]:\\n            for i, t in enumerate(tickets):\\n                if t > 0:\\n                    tickets[i] = tickets[i] - 1\\n                    ret += 1\\n                if i == k:\\n                    if tickets[i] == 0:\\n                        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576950,
                "title": "java-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] arr, int k) {\\n        int count = 0;\\n        while(true)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]>0)\\n                {\\n                    arr[i] = arr[i]-1;\\n                    count = count+1;\\n                }\\n                if(arr[k] == 0)\\n                {\\n                    return count;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] arr, int k) {\\n        int count = 0;\\n        while(true)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]>0)\\n                {\\n                    arr[i] = arr[i]-1;\\n                    count = count+1;\\n                }\\n                if(arr[k] == 0)\\n                {\\n                    return count;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894192,
                "title": "c-linq",
                "content": "```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k)\\n      => tickets\\n          .Select((n, i) => Math.Min(n, tickets[k]) - (i > k && n >= tickets[k] ? 1 : 0))\\n          .Sum();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k)\\n      => tickets\\n          .Select((n, i) => Math.Min(n, tickets[k]) - (i > k && n >= tickets[k] ? 1 : 0))\\n          .Sum();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668409,
                "title": "c-solution-using-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int summation(vector<int>tickets){\\n        int sum = 0 ; \\n        for(int i = 0 ; i < tickets.size() ; i++){\\n            sum += tickets[i];\\n        }\\n        return sum;\\n    }\\n    int solve(vector<int> tickets, int k,int mid){\\n        int i = 0;\\n        int n = tickets.size();\\n        while(mid != 0){\\n            if(tickets[i] != 0){\\n                mid--;\\n                tickets[i]--;\\n            }\\n            i = (i + 1) % n;;\\n            if(tickets[k] == 0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = summation(tickets);\\n        \\n        int s = 1 , e = sum , ans = 0;\\n\\n        while(s <= e){\\n            int mid = s + (e - s) / 2;\\n            int val = solve(tickets,k,mid);\\n\\n            if(val == 0){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else{\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int summation(vector<int>tickets){\\n        int sum = 0 ; \\n        for(int i = 0 ; i < tickets.size() ; i++){\\n            sum += tickets[i];\\n        }\\n        return sum;\\n    }\\n    int solve(vector<int> tickets, int k,int mid){\\n        int i = 0;\\n        int n = tickets.size();\\n        while(mid != 0){\\n            if(tickets[i] != 0){\\n                mid--;\\n                tickets[i]--;\\n            }\\n            i = (i + 1) % n;;\\n            if(tickets[k] == 0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = summation(tickets);\\n        \\n        int s = 1 , e = sum , ans = 0;\\n\\n        while(s <= e){\\n            int mid = s + (e - s) / 2;\\n            int val = solve(tickets,k,mid);\\n\\n            if(val == 0){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else{\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633906,
                "title": "time-needed-to-buy-tickets-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI will be taking the given array index in the queue array rather than the acutal stored values.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will first enqueue index of the given array in the queue array. We are queuing the array index rather than its value because we need to focus on the person for who we need to find the time taken to buy his tickets. The time will be incremented by 1s for everytime we iterate over the loop. First we will assign the first/front element of the queue to the temp variable(here in my program it is front). Then we will dequeue that first element from the <b>queue</b>. After that we will start checking with the conditions. First condition is, we will check for the value of the tickets[front] is atleast 1 if it is, then we will decrement it by 1. Second Condition, we will check if the front(temp variable) is equal to the k and if the value of the tickets[front] is 0 if it is, then we will break the loop and return the time. Third Condition, we will check if the front!=k and the tickets[front] is equal to 0 if it is, we will continue with the iteration we don\\'t enqueue that element again in the queue. If the condition 2, 3 fails then will enqueue that front(temp variable) in the queue again.\\n\\nAt last of the code I have reintialized the head and tail to -1; As sometimes there are some unexpected behavior in leetcode while executing the test cases.\\n\\n# Code\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define N 10000 \\n\\nint queue[N];\\n\\nint head=-1, tail=-1; \\n\\nint isEmpty(), isFull();\\n\\nvoid enqueue(int x), dequeue();\\nint peek();\\n\\nint isEmpty() {\\n    if(head == -1 && tail==-1) \\n        return 1;\\n    else \\n        return 0;\\n}\\n\\nint isFull() {\\n    if(tail==N-1)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nvoid enqueue(int x) {\\n    if(isFull()) { \\n        printf(\"ERROR: queue overflow\\\\n\");\\n        exit(1); //Enqueuing Failure\\n    }\\n    else if(isEmpty()) {\\n        tail++, head++;\\n        queue[tail] = x;\\n    }\\n    else {\\n        queue[++tail] = x;\\n    }\\n}\\n\\nvoid dequeue() {\\n   if(isEmpty()) {\\n    printf(\"ERROR: queue underflow\\\\n add some elements\\\\n\");\\n   }\\n   else if(head == tail) {\\n    head = -1;\\n    tail = -1;\\n   }\\n   else if(!isEmpty()) {\\n    queue[head++];\\n   }\\n}\\n\\nint peek() {\\n    if(isEmpty()) {\\n        printf(\"NO ELEMENTS\\\\n\");\\n        return;\\n    }\\n    else {\\n       return queue[head];\\n    }\\n}\\n\\n\\nint timeRequiredToBuy(int* tickets, int ticketsSize, int k){\\n    int time=0;\\n    for(int itr=0; itr<ticketsSize; itr++) {\\n        enqueue(itr);\\n    }\\n    while(1) {\\n       time++; \\n       int front=peek();\\n       dequeue();\\n       if(tickets[front]>=1) \\n\\t       tickets[front]--;\\n       if(tickets[front]==0 && front!=k)\\n\\t       continue;\\n       if(tickets[front]==0 && front==k)\\n\\t       break;\\n       enqueue(front);\\n    }\\n    head=-1;\\n    tail=-1;\\n    return time;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define N 10000 \\n\\nint queue[N];\\n\\nint head=-1, tail=-1; \\n\\nint isEmpty(), isFull();\\n\\nvoid enqueue(int x), dequeue();\\nint peek();\\n\\nint isEmpty() {\\n    if(head == -1 && tail==-1) \\n        return 1;\\n    else \\n        return 0;\\n}\\n\\nint isFull() {\\n    if(tail==N-1)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nvoid enqueue(int x) {\\n    if(isFull()) { \\n        printf(\"ERROR: queue overflow\\\\n\");\\n        exit(1); //Enqueuing Failure\\n    }\\n    else if(isEmpty()) {\\n        tail++, head++;\\n        queue[tail] = x;\\n    }\\n    else {\\n        queue[++tail] = x;\\n    }\\n}\\n\\nvoid dequeue() {\\n   if(isEmpty()) {\\n    printf(\"ERROR: queue underflow\\\\n add some elements\\\\n\");\\n   }\\n   else if(head == tail) {\\n    head = -1;\\n    tail = -1;\\n   }\\n   else if(!isEmpty()) {\\n    queue[head++];\\n   }\\n}\\n\\nint peek() {\\n    if(isEmpty()) {\\n        printf(\"NO ELEMENTS\\\\n\");\\n        return;\\n    }\\n    else {\\n       return queue[head];\\n    }\\n}\\n\\n\\nint timeRequiredToBuy(int* tickets, int ticketsSize, int k){\\n    int time=0;\\n    for(int itr=0; itr<ticketsSize; itr++) {\\n        enqueue(itr);\\n    }\\n    while(1) {\\n       time++; \\n       int front=peek();\\n       dequeue();\\n       if(tickets[front]>=1) \\n\\t       tickets[front]--;\\n       if(tickets[front]==0 && front!=k)\\n\\t       continue;\\n       if(tickets[front]==0 && front==k)\\n\\t       break;\\n       enqueue(front);\\n    }\\n    head=-1;\\n    tail=-1;\\n    return time;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3450924,
                "title": "javascript-100-o-n-time-o-1-space",
                "content": "# Approach\\n\\nTake the `tickets` array below as an example.\\n\\n`[ 8, 2, 4, 6, 1]`\\n\\nIf we wanted to compute the result for `k = 2` (`tickets[2] = 4`), we would have to consider the following scenarios:\\n\\n1. It would take 4 seconds to buy the tickets for the target person, since `tickets[k] == 4`\\n2. `tickets[0]` is 8, but we only need 4 tickets, therefore we only wait for him 4 times\\n3. `tickets[1]` is 2, which is smaller than 4. This person would leave the before we finish buying our tickets, therefore we would only wait for him 2 times\\n4. `tickets[3]` is 6, but we are initially in front of him, therefore we only wait for him after we are placed at the back of the queue, or `tickets[k] - 1` times\\n\\n```\\nfunction timeRequiredToBuy(tickets, k) {\\n    // Scenario 1\\n    let result = tickets[k];\\n\\n    // Scenario 2 and 3\\n    for (let i = 0; i < k; i++) {\\n        result += Math.min(tickets[k], tickets[i]);\\n    }\\n\\n    // Scenario 4\\n    for (let i = k + 1; i < tickets.length; i++) {\\n        result += Math.min(tickets[k] - 1, tickets[i]);\\n    }\\n\\n    return result;\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nfunction timeRequiredToBuy(tickets, k) {\\n    // Scenario 1\\n    let result = tickets[k];\\n\\n    // Scenario 2 and 3\\n    for (let i = 0; i < k; i++) {\\n        result += Math.min(tickets[k], tickets[i]);\\n    }\\n\\n    // Scenario 4\\n    for (let i = k + 1; i < tickets.length; i++) {\\n        result += Math.min(tickets[k] - 1, tickets[i]);\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3198622,
                "title": "100-easy-js-solution-explained-with-proper-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- Implemented the problem with the *greedy approach* that involves buying tickets from a queue.\\n- The *goal* of the problem is :-\\n*\"To calculate the amount of time required to buy all the tickets at position k, where each purchase takes one unit of time and the buyer moves to the next position in the queue after each purchase.\"*\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- The *tickets* array represents the number of available tickets at each *position* in the *queue*, and the function *timeRequiredToBuy* takes *two* *arguments*: *tickets* and *k*.\\n1. The approach taken in the below code is to use a *while* loop that continues until the kth element of the tickets array becomes 0. \\n2. Within the *while* loop, the code uses a *modulo operator* to wrap around the queue and ensure that it starts over at the beginning after reaching the end.\\n3. On each *iteration* of the *while* loop, the code checks if the current position has any *available tickets*.\\n4.  If it does, it *decrements* the ticket count and increments a counter for the number of tickets purchased.\\n5. Finally, the function returns the *total count of tickets* purchased, which represents the *time required to buy all the tickets at position k.*\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here N is the length of the tickets array. \\n2. This is because the while loop will continue until the kth element of the tickets array becomes 0, and each iteration of the while loop will iterate over each element of the tickets array once.\\n\\n\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Because the only additional space used is for the variables i, count, and pos, which are all constant in size and do not depend on the size of the input.\\n2.  The tickets array is modified in place, so no additional space is used for it.\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n\\n    let N = tickets.length;\\n\\n    // current index\\n    let i = 0;\\n\\n    // no. of count\\n    let count = 0;\\n\\n    while (tickets[k] > 0) {\\n\\n        let pos = i % N;\\n\\n        if (tickets[pos]) {\\n\\n            tickets[pos]--;\\n            count++;\\n        }  \\n        // moving everytime to next element\\n        i++;\\n    }\\n    return count;\\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/6f36285e-0bab-460e-9f8c-0f16bf19e852_1676657371.1775663.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Queue",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n\\n    let N = tickets.length;\\n\\n    // current index\\n    let i = 0;\\n\\n    // no. of count\\n    let count = 0;\\n\\n    while (tickets[k] > 0) {\\n\\n        let pos = i % N;\\n\\n        if (tickets[pos]) {\\n\\n            tickets[pos]--;\\n            count++;\\n        }  \\n        // moving everytime to next element\\n        i++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2847752,
                "title": "time-needed-to-buy-tickets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\nq.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\nq.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833494,
                "title": "explained-java-soln",
                "content": "\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n\\n        int time=0;\\n\\n  \\n       for(int i =0; i<tickets.length;i++){\\n// if position i<k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i].   \\n\\n           if(i<k){\\n               if(tickets[i]<=tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]\\n                else \\n                time+=tickets[k];\\n           }\\n// if position i>k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i]. \\n\\n           if(i>k){\\n               if(tickets[i]<tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]-1(cause loop will break before time hits ticket[k] for later part.),\\n                else\\n                time+=tickets[k]-1;\\n           }\\n//if i==k just add time+=tickets[k]\\n\\n                if(i==k) time+=tickets[k];\\n\\n\\n\\n           \\n           System.out.println(time);\\n           \\n\\n\\n       }\\n\\n        \\n\\n        return time;\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n\\n        int time=0;\\n\\n  \\n       for(int i =0; i<tickets.length;i++){\\n// if position i<k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i].   \\n\\n           if(i<k){\\n               if(tickets[i]<=tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]\\n                else \\n                time+=tickets[k];\\n           }\\n// if position i>k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i]. \\n\\n           if(i>k){\\n               if(tickets[i]<tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]-1(cause loop will break before time hits ticket[k] for later part.),\\n                else\\n                time+=tickets[k]-1;\\n           }\\n//if i==k just add time+=tickets[k]\\n\\n                if(i==k) time+=tickets[k];\\n\\n\\n\\n           \\n           System.out.println(time);\\n           \\n\\n\\n       }\\n\\n        \\n\\n        return time;\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557446,
                "title": "js-two-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/2073-time-needed-to-buy-tickets-queue.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n**Javascript One Liner code**\\n\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    return tickets.reduce((x, v, i)=>x + Math.min(v, tickets[k] - (i > k)), 0);\\n};\\n```\\n\\n```\\nRuntime: 96 ms, faster than 38.86% of JavaScript online submissions for Time Needed to Buy Tickets.\\nMemory Usage: 41.6 MB, less than 89.10% of JavaScript online submissions for Time Needed to Buy Tickets.\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    return tickets.reduce((x, v, i)=>x + Math.min(v, tickets[k] - (i > k)), 0);\\n};\\n```\n```\\nRuntime: 96 ms, faster than 38.86% of JavaScript online submissions for Time Needed to Buy Tickets.\\nMemory Usage: 41.6 MB, less than 89.10% of JavaScript online submissions for Time Needed to Buy Tickets.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2553069,
                "title": "python-easy-queue-and-recursion-solution",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        queue = deque(tickets)\\n        \\n        self.time_taken = 0\\n        \\n        self.rec(queue, k)\\n        \\n        return self.time_taken\\n    \\n    def rec(self, queue, k):\\n        for idx, ele in enumerate(queue):\\n            if ele:\\n                queue[idx] -= 1\\n                if idx == k and not queue[idx]:\\n                    self.time_taken += 1\\n                    return self.time_taken\\n                else:\\n                    self.time_taken += 1\\n        self.rec(queue, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        queue = deque(tickets)\\n        \\n        self.time_taken = 0\\n        \\n        self.rec(queue, k)\\n        \\n        return self.time_taken\\n    \\n    def rec(self, queue, k):\\n        for idx, ele in enumerate(queue):\\n            if ele:\\n                queue[idx] -= 1\\n                if idx == k and not queue[idx]:\\n                    self.time_taken += 1\\n                    return self.time_taken\\n                else:\\n                    self.time_taken += 1\\n        self.rec(queue, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458459,
                "title": "go-simple-solution-using-queue-60-faster-70-less-memory-needed",
                "content": "func timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tout := 0\\n\\tendMainLoop := false\\n\\n\\tfor !endMainLoop {\\n\\n\\t\\tend := len(tickets)\\n\\n\\t\\tif tickets[k] == 1 {\\n\\t\\t\\tend = k + 1\\n\\t\\t\\tendMainLoop = true\\n\\t\\t}\\n\\n\\t\\tfor i := 0; i < end; i++ {\\n\\n\\t\\t\\telem := tickets[0]\\n\\n\\t\\t\\tif elem > 0 {\\n\\t\\t\\t\\telem--\\n\\t\\t\\t\\tout++\\n\\t\\t\\t}\\n\\n\\t\\t\\ttickets = append(tickets[1:], elem)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "func timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tout := 0\\n\\tendMainLoop := false\\n\\n\\tfor !endMainLoop {\\n\\n\\t\\tend := len(tickets)\\n\\n\\t\\tif tickets[k] == 1 {\\n\\t\\t\\tend = k + 1\\n\\t\\t\\tendMainLoop = true\\n\\t\\t}\\n\\n\\t\\tfor i := 0; i < end; i++ {\\n\\n\\t\\t\\telem := tickets[0]\\n\\n\\t\\t\\tif elem > 0 {\\n\\t\\t\\t\\telem--\\n\\t\\t\\t\\tout++\\n\\t\\t\\t}\\n\\n\\t\\t\\ttickets = append(tickets[1:], elem)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2429131,
                "title": "c-simply-explained-with-steps",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < tickets.size(); ++i) {\\n                if (tickets[i] == 0) continue; // skips element, does not count if ticket is 0, like it\\'s not even there\\n                tickets[i]--; // decreases by 1 of all elements one by one\\n                ++step; // 1 second increment\\n                if (tickets[k] == 0) return step; // if target is having 0 tickets, return total time\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < tickets.size(); ++i) {\\n                if (tickets[i] == 0) continue; // skips element, does not count if ticket is 0, like it\\'s not even there\\n                tickets[i]--; // decreases by 1 of all elements one by one\\n                ++step; // 1 second increment\\n                if (tickets[k] == 0) return step; // if target is having 0 tickets, return total time\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400565,
                "title": "c-easy-approach",
                "content": "Basically we need to find the time to make tickets[k] equals to zero.\\nIn every iteration if the element is not equal to zero then decrease it by one and increase the count of time.\\nint i could be greatter than n so use i%n so that it remains in range of array given.\\n```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=0;\\n        int i=0;\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n            }\\n            i++;\\n        }\\n        return time;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=0;\\n        int i=0;\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n            }\\n            i++;\\n        }\\n        return time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2343054,
                "title": "short-javascript-solution",
                "content": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let seconds = 0;\\n\\n    while (tickets[k] > 0) {\\n        for (let i = 0; i < tickets.length; i++) {\\n            if (tickets[k] === 0) break\\n            if (tickets[i] > 0) {\\n                tickets[i]--\\n                seconds++\\n            }\\n        }\\n    }\\n\\t\\n    return seconds\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let seconds = 0;\\n\\n    while (tickets[k] > 0) {\\n        for (let i = 0; i < tickets.length; i++) {\\n            if (tickets[k] === 0) break\\n            if (tickets[i] > 0) {\\n                tickets[i]--\\n                seconds++\\n            }\\n        }\\n    }\\n\\t\\n    return seconds\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326133,
                "title": "c-all-approaches-complexity-analysis-efficient-solution",
                "content": "2 APPROACHES : \\n1. Queue\\nTC : O( t )   ->t is the time ( iterations) done to make the tickets[ k ]=0 \\nSC : O(N)  -> We store N elements in queue at first\\n\\n2. Vector :\\nTC : O( t ) \\nSC : O(1) ->no extra space required\\n\\nNOTE  :The runtime and memory usage of vector soution is less than that of Queue solution .\\n(as it can be seen clearly as well from the complexity analysis) \\n\\nUPVOTE IF YOU LIKE \\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n// USING QUEUE : \\n    int timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<nums.size();i++){\\n            q.push({nums[i],i});\\n        }\\n    \\n        while(!q.empty()){\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            p.first--;\\n            ans+=1;\\n            if(p.second==k && p.first==0)return ans;\\n            else if(p.first!=0)q.push(p);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nUSING VECTOR :\\nRuntime and memory usage of This solution is better than the queue sol.\\n*/\\nint timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        while(nums[k]!=0){\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i]==0 && i!=k)continue;\\n                nums[i]--;\\n                ans+=1;\\n                if(nums[k]==0)return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// USING QUEUE : \\n    int timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<nums.size();i++){\\n            q.push({nums[i],i});\\n        }\\n    \\n        while(!q.empty()){\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            p.first--;\\n            ans+=1;\\n            if(p.second==k && p.first==0)return ans;\\n            else if(p.first!=0)q.push(p);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nUSING VECTOR :\\nRuntime and memory usage of This solution is better than the queue sol.\\n*/\\nint timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        while(nums[k]!=0){\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i]==0 && i!=k)continue;\\n                nums[i]--;\\n                ans+=1;\\n                if(nums[k]==0)return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319753,
                "title": "o-n-python-treat-kth-and-kth-differently",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        l=len(tickets)\\n        for i in range(l):\\n            if i <= k:\\n                c+= min(tickets[k],tickets[i])\\n            else:\\n                c+= min(tickets[k]-1,tickets[i])\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        l=len(tickets)\\n        for i in range(l):\\n            if i <= k:\\n                c+= min(tickets[k],tickets[i])\\n            else:\\n                c+= min(tickets[k]-1,tickets[i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296280,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        seconds = 0\\n        while tickets[k]!=0:\\n            \\n            for i in range(len(tickets)):\\n                if tickets[i]!=0 and tickets[k]!=0:\\n                    tickets[i] = tickets[i]-1\\n                    seconds +=1\\n        return seconds\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        seconds = 0\\n        while tickets[k]!=0:\\n            \\n            for i in range(len(tickets)):\\n                if tickets[i]!=0 and tickets[k]!=0:\\n                    tickets[i] = tickets[i]-1\\n                    seconds +=1\\n        return seconds\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282082,
                "title": "java-easy-solution-o-n-2-mehods",
                "content": "#### 1) \\n```\\nclass Solution {\\n  public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < tickets.length; i++) {\\n             ans += Math.min(tickets[i], tickets[k]);\\n\\n            if (i > k && tickets[i] >= tickets[k]) {\\n                ans--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n#### 2)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[k] == 0) {\\n                    return ans;\\n                }\\n                if (tickets[i] != 0) {\\n                    tickets[i] = tickets[i] - 1;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < tickets.length; i++) {\\n             ans += Math.min(tickets[i], tickets[k]);\\n\\n            if (i > k && tickets[i] >= tickets[k]) {\\n                ans--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[k] == 0) {\\n                    return ans;\\n                }\\n                if (tickets[i] != 0) {\\n                    tickets[i] = tickets[i] - 1;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271454,
                "title": "best-solution-in-c",
                "content": "**Please upvote if you like it :)**\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count=0;\\n        while(tickets[k])\\n        {\\n            for(int i=0;i<tickets.size();i++)\\n            {\\n                if(tickets[i])\\n                {\\n                    tickets[i]=tickets[i]-1;\\n                    count++;\\n                    if(tickets[k]==0)\\n                        return count;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count=0;\\n        while(tickets[k])\\n        {\\n            for(int i=0;i<tickets.size();i++)\\n            {\\n                if(tickets[i])\\n                {\\n                    tickets[i]=tickets[i]-1;\\n                    count++;\\n                    if(tickets[k]==0)\\n                        return count;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2269001,
                "title": "use-only-one-for-loop-10-lines-of-codes-bruteforce-java-solution",
                "content": "\\n2073. Time Needed to Buy Tickets\\njava solution\\nOnly 10 lines of codes\\n```\\n\\n\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n          int time=0;\\n          for(int i=0; i<tickets.length; i++){\\n              if(tickets[i]<tickets[k]) time+=tickets[i];\\n              else if(i<=k && tickets[i]>=tickets[k])time+=tickets[k];\\n              else if(i>k && tickets[i]>=tickets[k]) time+=tickets[k]-1;   \\n          }\\n          return(time);\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue"
                ],
                "code": "```\\n\\n\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n          int time=0;\\n          for(int i=0; i<tickets.length; i++){\\n              if(tickets[i]<tickets[k]) time+=tickets[i];\\n              else if(i<=k && tickets[i]>=tickets[k])time+=tickets[k];\\n              else if(i>k && tickets[i]>=tickets[k]) time+=tickets[k]-1;   \\n          }\\n          return(time);\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235304,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        \\n        //find the kth person and find m tickets to buy \\n        int times=tickets[k];\\n        \\n        //loop the array m-1 times\\n        for(int i:tickets)\\n        {   \\n            //if i>=m-1, that means this person has enough tickets to buy\\n            if(i>=times)\\n            {\\n                ans+=times-1;\\n            }else  //if i<m-1 that means this person does not have enough tickets to buy\\n            {\\n                ans+=i;\\n            }\\n        }\\n        \\n        //last lopp and stop at the person k\\n        for(int i=0;i<k+1;i++)\\n        {   ////if i>m-1, that means this person has enough tickets to buy\\n            if(tickets[i]>times-1)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n      \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        \\n        //find the kth person and find m tickets to buy \\n        int times=tickets[k];\\n        \\n        //loop the array m-1 times\\n        for(int i:tickets)\\n        {   \\n            //if i>=m-1, that means this person has enough tickets to buy\\n            if(i>=times)\\n            {\\n                ans+=times-1;\\n            }else  //if i<m-1 that means this person does not have enough tickets to buy\\n            {\\n                ans+=i;\\n            }\\n        }\\n        \\n        //last lopp and stop at the person k\\n        for(int i=0;i<k+1;i++)\\n        {   ////if i>m-1, that means this person has enough tickets to buy\\n            if(tickets[i]>times-1)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n      \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153645,
                "title": "c-o-n-solution-0ms-100-faster",
                "content": "**Important observations**\\n* Person standing at index i, before kth index , will buy either **tickets[k]** ticket or **tickets[i]** whichever is minimum,  before kth person buys the ticket. same is applicable for kth person.\\n* Person after kth index, will buy minimum of  **tickets[k] -1** ticket or **tickets[i]** ticket, before kth person buys all the tickets.\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        for(int i = 0; i <= k; i++) {\\n            res += min(tickets[k], tickets[i]);\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++) {\\n            res += min(tickets[k] - 1 , tickets[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        for(int i = 0; i <= k; i++) {\\n            res += min(tickets[k], tickets[i]);\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++) {\\n            res += min(tickets[k] - 1 , tickets[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098427,
                "title": "c-easy-solution-brute-force-to-optimized",
                "content": "\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        \\n// <------------------------------------------------------------------->\\n     \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t // Approach - 1 TC O(N*K) and SC O(1)\\n        int n=tickets.size();\\n        int cnt=0;\\n        while(tickets[k]>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    cnt++;\\n                }\\n                if(tickets[k]==0 )\\n                {\\n                    return cnt;\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n        \\n// <------------------------------------------------------------------->\\n\\n        // Appraoch - 2 TC O(N) and SC O(1)\\n        int i=0;\\n        int n=tickets.size();\\n        int sum=0;\\n        while(i<n)\\n        {\\n            if(i<=k)\\n                sum+=min(tickets[i],tickets[k]);\\n            else\\n                sum+=min(tickets[i],tickets[k]-1);\\n            i++;\\n        }\\n        return sum;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        \\n// <------------------------------------------------------------------->\\n     \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t // Approach - 1 TC O(N*K) and SC O(1)\\n        int n=tickets.size();\\n        int cnt=0;\\n        while(tickets[k]>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    cnt++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2096061,
                "title": "c-easy-solution-and-understandable",
                "content": "Solution 1 :\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = 0, x = tickets[k];\\n        for(int i = 0; i <= k; i++){\\n            if(tickets[i] <= x)\\n                sum+=tickets[i];\\n            else\\n                sum+=x;\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++){\\n            if(tickets[i] <= (x-1))\\n                sum+=tickets[i];\\n            else\\n                sum+=(x-1);\\n        }\\n        return sum;\\n    }\\n};\\n```\\nSolution 2 :\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = 0;\\n        while(tickets[k] > 0){\\n            for(int i = 0; i < tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    t++;\\n                    tickets[i]--;\\n                }\\n                if(tickets[k]==0)\\n                    break;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = 0, x = tickets[k];\\n        for(int i = 0; i <= k; i++){\\n            if(tickets[i] <= x)\\n                sum+=tickets[i];\\n            else\\n                sum+=x;\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++){\\n            if(tickets[i] <= (x-1))\\n                sum+=tickets[i];\\n            else\\n                sum+=(x-1);\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = 0;\\n        while(tickets[k] > 0){\\n            for(int i = 0; i < tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    t++;\\n                    tickets[i]--;\\n                }\\n                if(tickets[k]==0)\\n                    break;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011975,
                "title": "simple-python-solution-with-detailed-explanation-easy-to-understand",
                "content": "iterate through tickets, if any number is bigger than ticket[k], when index <= k, nums + tickets[k] (because you can\\'t go over tickets[k] steps to finish purchasing tickets for the kth person), however, for people behind kth person, you only need to purchase ticket[k]-1 steps. if tickets[i] is smaller than ticket[k], these people will only take tickets[i] steps before they leave the queue.\\n\\nif you like my solution, please give me a thumb up!\\n\\n```\\n\\n```class Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        nums = 0        \\n        \\n        for i in range(len(tickets)):       \\n                if tickets[i] >= tickets[k]:\\n                    if i <= k:\\n                        nums += tickets[k]\\n                    else:\\n                        nums += tickets[k] - 1\\n                else:\\n                        nums += tickets[i]\\n\\n        return nums",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937637,
                "title": "faster-than-94-90-javascript-solution",
                "content": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n  let ans = 0;\\n  let i = 0;\\n  while (tickets[k] !== 0) {\\n    if (i === tickets.length) {\\n      i = 0;\\n    }\\n    if (tickets[i] != 0) {\\n      tickets[i] -= 1;\\n      ans++;\\n    }\\n    i++;\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n  let ans = 0;\\n  let i = 0;\\n  while (tickets[k] !== 0) {\\n    if (i === tickets.length) {\\n      i = 0;\\n    }\\n    if (tickets[i] != 0) {\\n      tickets[i] -= 1;\\n      ans++;\\n    }\\n    i++;\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934516,
                "title": "java-queue-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=0;i <tickets.length; i++) {\\n            queue.add(i);\\n        }\\n        int count=0;\\n        while(!queue.isEmpty()) {\\n            count++;\\n            int index = queue.poll();\\n            if(tickets[index] >= 1) {\\n                tickets[index] -= 1;\\n            }\\n            //now I will check he can go back to last of queue or not\\n            if(index != k && tickets[index] == 0) { \\n                //he is the normal guy, which means he can leave the queue\\n                continue;\\n            }\\n            //he is the Kth guy, he cannot leave the Queue instead he can BREAK the Queue :)\\n            if(index == k && tickets[index] == 0) {\\n                break;\\n            }\\n            //in all other case we need to add the guy back to Queue\\n            queue.offer(index);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=0;i <tickets.length; i++) {\\n            queue.add(i);\\n        }\\n        int count=0;\\n        while(!queue.isEmpty()) {\\n            count++;\\n            int index = queue.poll();\\n            if(tickets[index] >= 1) {\\n                tickets[index] -= 1;\\n            }\\n            //now I will check he can go back to last of queue or not\\n            if(index != k && tickets[index] == 0) { \\n                //he is the normal guy, which means he can leave the queue\\n                continue;\\n            }\\n            //he is the Kth guy, he cannot leave the Queue instead he can BREAK the Queue :)\\n            if(index == k && tickets[index] == 0) {\\n                break;\\n            }\\n            //in all other case we need to add the guy back to Queue\\n            queue.offer(index);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921486,
                "title": "c-cpp-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0,n = tickets.size();\\n        while(tickets[k] > 0){\\n            for(int i = 0;i<n && tickets[k] > 0;i++){\\n                if(tickets[i] > 0){\\n                    ans++;\\n                    tickets[i]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/06178cb3-e0a6-4b9f-add8-fd6380c82517_1649302549.1251898.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0,n = tickets.size();\\n        while(tickets[k] > 0){\\n            for(int i = 0;i<n && tickets[k] > 0;i++){\\n                if(tickets[i] > 0){\\n                    ans++;\\n                    tickets[i]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914472,
                "title": "python-easy-solution-one-pass-no-extra-memory",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        length = len(tickets)\\n        count = 0\\n        \\n        for i in range(k+1):\\n            if tickets[i] - tickets[k] < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k]\\n        \\n        for i in range(k+1, length):\\n            if tickets[i] - (tickets[k] - 1) < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k] - 1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        length = len(tickets)\\n        count = 0\\n        \\n        for i in range(k+1):\\n            if tickets[i] - tickets[k] < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k]\\n        \\n        for i in range(k+1, length):\\n            if tickets[i] - (tickets[k] - 1) < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k] - 1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904304,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        item = tickets[k]\\n        time = 0\\n        \\n        while tickets[k] != 0:\\n            for i in range(n):\\n                if tickets[i] > 0:\\n                    tickets[i] -= 1\\n                    time += 1\\n                \\n                if i == k and tickets[i] == 0:\\n                    return time\\n        \\n        return time\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        item = tickets[k]\\n        time = 0\\n        \\n        while tickets[k] != 0:\\n            for i in range(n):\\n                if tickets[i] > 0:\\n                    tickets[i] -= 1\\n                    time += 1\\n                \\n                if i == k and tickets[i] == 0:\\n                    return time\\n        \\n        return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894215,
                "title": "c-solution-o-n-time-o-1-space-just-two-loops-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n      int timeTaken = 0;\\n      int ticketsAtIndexK = tickets[k];\\n      for(int i = k+1; i < tickets.size(); i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK - 1);\\n      \\n      for(int i = 0; i <= k; i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK);\\n      \\n      return timeTaken;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n      int timeTaken = 0;\\n      int ticketsAtIndexK = tickets[k];\\n      for(int i = k+1; i < tickets.size(); i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK - 1);\\n      \\n      for(int i = 0; i <= k; i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK);\\n      \\n      return timeTaken;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888755,
                "title": "c-solution-with-queue-and-shallow-copies",
                "content": "Put references to the elements of the array in a queue. This allows you to monitor directly tickets[k], preventing you from becoming insane in keeping track of it with a variable.\\n\\n``` \\nclass Solution {\\npublic:\\n    // Time Complexity: O(n*tickets[k]), it loops for the entire queue (size = n, n times) until tickets[k] becomes 0 (k times)\\n    // Space Complexity: O(n), creates a queue of size n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        queue<int*> q;\\n        for(int i=0; i< tickets.size(); i++)\\n            q.push(&tickets[i]);                // add references of the tickets to a queue\\n        \\n        int count = 0;\\n        while(tickets[k] != 0)                  // repeat until ticket[k] is zero\\n        {\\n            int* ptr = q.front();               // get the reference at the front of the queue, namely ticket[i]\\n            q.pop();                            // remove it from the queue\\n            (*ptr)--;                           // reduce the value of ticket[i]\\n            if(*ptr != 0)                       // if it is not zero, \\n                q.push(ptr);                    // add it back to the queue\\n            count++;                            // increase counter\\n        }\\n        return count;                           // return the counter\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    // Time Complexity: O(n*tickets[k]), it loops for the entire queue (size = n, n times) until tickets[k] becomes 0 (k times)\\n    // Space Complexity: O(n), creates a queue of size n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        queue<int*> q;\\n        for(int i=0; i< tickets.size(); i++)\\n            q.push(&tickets[i]);                // add references of the tickets to a queue\\n        \\n        int count = 0;\\n        while(tickets[k] != 0)                  // repeat until ticket[k] is zero\\n        {\\n            int* ptr = q.front();               // get the reference at the front of the queue, namely ticket[i]\\n            q.pop();                            // remove it from the queue\\n            (*ptr)--;                           // reduce the value of ticket[i]\\n            if(*ptr != 0)                       // if it is not zero, \\n                q.push(ptr);                    // add it back to the queue\\n            count++;                            // increase counter\\n        }\\n        return count;                           // return the counter\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857998,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        seconds = 0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i] != 0:\\n                    seconds += 1\\n                    tickets[i] -= 1\\n                else:\\n                    continue\\n                if tickets[k] == 0:\\n                    return seconds",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        seconds = 0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i] != 0:\\n                    seconds += 1\\n                    tickets[i] -= 1\\n                else:\\n                    continue\\n                if tickets[k] == 0:\\n                    return seconds",
                "codeTag": "Java"
            },
            {
                "id": 1820628,
                "title": "o-n-long-but-understandable-code-try-this-python",
                "content": "class Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\n        second=0\\n        a=tickets[k]\\n        while a!=0:\\n            for i in range(len(tickets)):\\n                if tickets[i]!=0:\\n                    second+=1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if a==0:\\n                    return second\\n            a=tickets[k]\\n            \\n        return second",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\n        second=0\\n        a=tickets[k]\\n        while a!=0:\\n            for i in range(len(tickets)):\\n                if tickets[i]!=0:\\n                    second+=1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if a==0:\\n                    return second\\n            a=tickets[k]\\n            \\n        return second",
                "codeTag": "Java"
            },
            {
                "id": 1802939,
                "title": "python-3-easy-to-understand",
                "content": "Runtime: 64 ms, faster than 43.29% of Python3 online submissions for Time Needed to Buy Tickets.\\nMemory Usage: 13.9 MB, less than 86.76% of Python3 online submissions for Time Needed to Buy Tickets\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        p = 0                       #pointer\\n        clock = 0                   #clock\\n        while tickets[k] > 0:       #stop when person k has bought all required tickets\\n            if tickets[p] != 0:     #only buy a ticket if person p still needs to buy tickets\\n                tickets[p] -= 1     #person p buys a ticket\\n                clock += 1          #increment clock whenever a ticket is bought\\n            p += 1                  #move pointer to next person\\n            p %= len(tickets)       #loop pointer from end of list to start of list\\n        return clock\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        p = 0                       #pointer\\n        clock = 0                   #clock\\n        while tickets[k] > 0:       #stop when person k has bought all required tickets\\n            if tickets[p] != 0:     #only buy a ticket if person p still needs to buy tickets\\n                tickets[p] -= 1     #person p buys a ticket\\n                clock += 1          #increment clock whenever a ticket is bought\\n            p += 1                  #move pointer to next person\\n            p %= len(tickets)       #loop pointer from end of list to start of list\\n        return clock\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793517,
                "title": "c-tc-o-n-sc-o-1-100-faster",
                "content": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int result=0;\\n        \\n        for(int i=0;i<tickets.size();i++){\\n            \\n            result+= i<=k ?min(tickets[i],tickets[k]): min(tickets[i],tickets[k]-1);\\n            \\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int result=0;\\n        \\n        for(int i=0;i<tickets.size();i++){\\n            \\n            result+= i<=k ?min(tickets[i],tickets[k]): min(tickets[i],tickets[k]-1);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1746430,
                "title": "typescript-100",
                "content": "Your runtime beats 100 % of typescript submissions\\nYour memory usage beats 14.29 % of typescript submissions (43.5 MB)\\n```\\nfunction timeRequiredToBuy(tickets: number[], k: number): number {\\n    let result: number = 0;\\n    for (let i: number = 0; true; i = i === tickets.length ? 0 : i + 1) {\\n        if (tickets[i] > 0) {\\n            tickets[i]--;\\n            result++;\\n            if (tickets[i] === 0 && i === k) {\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction timeRequiredToBuy(tickets: number[], k: number): number {\\n    let result: number = 0;\\n    for (let i: number = 0; true; i = i === tickets.length ? 0 : i + 1) {\\n        if (tickets[i] > 0) {\\n            tickets[i]--;\\n            result++;\\n            if (tickets[i] === 0 && i === k) {\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1744017,
                "title": "c-faster-than-100-of-submissions-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<k+1; i++){\\n            if(tickets[i]<=tickets[k]){\\n                ans+=tickets[i];\\n            }\\n            else{\\n                ans+=tickets[k];\\n            }\\n        }\\n        for(int i=k+1; i<tickets.size(); i++){\\n             if(tickets[i]<tickets[k]){\\n                ans+=tickets[i];\\n            }\\n            else{\\n                ans+=tickets[k]-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<k+1; i++){\\n            if(tickets[i]<=tickets[k]){\\n                ans+=tickets[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1742844,
                "title": "java-o-n-soln-easy-for-beginners",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){\\n            if(i==tickets.length-1){\\n                if(tickets[i]==0){\\n                    i=0;\\n                continue;\\n            }\\n            else{\\n                tickets[i]=tickets[i]-1;\\n                count++;\\n                i=0;\\n                continue;\\n            }\\n            }\\n            else{\\n            if(tickets[i]==0){\\n                i++;\\n                continue;\\n            }\\n            else{\\n                tickets[i]=tickets[i]-1;\\n                count++;\\n            }\\n            i++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){\\n            if(i==tickets.length-1){\\n                if(tickets[i]==0){\\n                    i=0;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1741714,
                "title": "java-easy-solution-optimal-100-faster-o-n-tc-o-1-sc",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=k;i>=0;i--)\\n            ans+=Math.min(tickets[k],tickets[i]);\\n        for(int i=tickets.length-1;i>k;i--)\\n            ans+=Math.min(tickets[k]-1,tickets[i]);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=k;i>=0;i--)\\n            ans+=Math.min(tickets[k],tickets[i]);\\n        for(int i=tickets.length-1;i>k;i--)\\n            ans+=Math.min(tickets[k]-1,tickets[i]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715695,
                "title": "java-easy-understanding-0ms-for-loop",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int val = tickets[k];\\n        for(int i=0; i<tickets.length; i++){\\n            if(i <= k)\\n                count += (val > tickets[i]) ? tickets[i] : val;\\n            else\\n                count += (val > tickets[i]) ? tickets[i] : val-1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int val = tickets[k];\\n        for(int i=0; i<tickets.length; i++){\\n            if(i <= k)\\n                count += (val > tickets[i]) ? tickets[i] : val;\\n            else\\n                count += (val > tickets[i]) ? tickets[i] : val-1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688697,
                "title": "java-o-n-easy-to-understand-intuition",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets == null || tickets.length == 0 || k > tickets.length) \\n            return 0;\\n        \\n        /*\\n          Intuition: Since 1 ticket is bought in 1 second. Number of tickets bought will give us the total time taken. \\n          We know we have to buy \"tickets[k]\" number of tickets. 2 cases possible: \\n\\n    Case-1: Going in a loop we are purchasing tickets and until we purchase \"tickets[k]\" number of tickets the people infront(left) of us buy tickets which is equal to Math.min(tickets[i], tickets[k]) because tickets[i] can be greater/lesser than tickets[k], and we can only buy the minimum of both. \\n          Ex-1: tickets[i], tickets[k] => 2, 4 implies i\\'th person can only buy 2 tickets. \\n          Ex-2: tickets[i], tickets[k] => 5, 3 implies i\\'th person can only buy 3 tickets and he still has 2 more tickets to buy which we dont have to wait for\\n        \\n    Case-2: Once we buy all the required tickets (i.e., tickets[k] becomes 0) we no longer have to buy(count) the tickets which are behind(right) of us. That means we only have to buy tickets until the last iteration before which tickets[k] becomes 0 i.e., the previous iteration where tickets[k]-1 are the amount of tickets to be bought.\\n    \\n    Note: If above cases don\\'t make sense. Think of it this way, we have divided the cases into 2 parts. One which are on & before(to the left) of \\'k\\' and other which are to the right of \\'k\\'\\n        */\\n        \\n        \\n        int timeTaken = 0; // TimeTaken = TicketsBought\\n        \\n        \\n        // The way to calculate number of tickets bought\\n        for(int i=0; i<tickets.length; i++) {\\n            if(i <= k) {\\n                timeTaken += Math.min(tickets[i], tickets[k]);  // Case 1\\n            } else {\\n                timeTaken += Math.min(tickets[k]-1, tickets[i]); // Case 2\\n            }\\n        }\\n        \\n        return timeTaken;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets == null || tickets.length == 0 || k > tickets.length) \\n            return 0;\\n        \\n        /*\\n          Intuition: Since 1 ticket is bought in 1 second. Number of tickets bought will give us the total time taken. \\n          We know we have to buy \"tickets[k]\" number of tickets. 2 cases possible: \\n\\n    Case-1: Going in a loop we are purchasing tickets and until we purchase \"tickets[k]\" number of tickets the people infront(left) of us buy tickets which is equal to Math.min(tickets[i], tickets[k]) because tickets[i] can be greater/lesser than tickets[k], and we can only buy the minimum of both. \\n          Ex-1: tickets[i], tickets[k] => 2, 4 implies i\\'th person can only buy 2 tickets. \\n          Ex-2: tickets[i], tickets[k] => 5, 3 implies i\\'th person can only buy 3 tickets and he still has 2 more tickets to buy which we dont have to wait for\\n        \\n    Case-2: Once we buy all the required tickets (i.e., tickets[k] becomes 0) we no longer have to buy(count) the tickets which are behind(right) of us. That means we only have to buy tickets until the last iteration before which tickets[k] becomes 0 i.e., the previous iteration where tickets[k]-1 are the amount of tickets to be bought.\\n    \\n    Note: If above cases don\\'t make sense. Think of it this way, we have divided the cases into 2 parts. One which are on & before(to the left) of \\'k\\' and other which are to the right of \\'k\\'\\n        */\\n        \\n        \\n        int timeTaken = 0; // TimeTaken = TicketsBought\\n        \\n        \\n        // The way to calculate number of tickets bought\\n        for(int i=0; i<tickets.length; i++) {\\n            if(i <= k) {\\n                timeTaken += Math.min(tickets[i], tickets[k]);  // Case 1\\n            } else {\\n                timeTaken += Math.min(tickets[k]-1, tickets[i]); // Case 2\\n            }\\n        }\\n        \\n        return timeTaken;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650061,
                "title": "0-ms-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+= min(tickets[k]-(i>k),tickets[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+= min(tickets[k]-(i>k),tickets[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650041,
                "title": "c-o-n-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(tickets[i]>=tickets[k]) ans+=(i<=k?tickets[k]:tickets[k]-1);\\n            else ans+=tickets[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(tickets[i]>=tickets[k]) ans+=(i<=k?tickets[k]:tickets[k]-1);\\n            else ans+=tickets[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637234,
                "title": "java-100-faster-short-solution",
                "content": "```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTakenForK = 0;\\n       \\n        for(int i = 0; i < tickets.length; i++){\\n            if(i < k) timeTakenForK+=Math.min(tickets[k], tickets[i]);\\n            if(i > k) timeTakenForK+=Math.min(tickets[k] - 1, tickets[i]);\\n            if(i == k)timeTakenForK+=tickets[k];}\\n  \\n        return timeTakenForK;}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTakenForK = 0;\\n       \\n        for(int i = 0; i < tickets.length; i++){\\n            if(i < k) timeTakenForK+=Math.min(tickets[k], tickets[i]);\\n            if(i > k) timeTakenForK+=Math.min(tickets[k] - 1, tickets[i]);\\n            if(i == k)timeTakenForK+=tickets[k];}\\n  \\n        return timeTakenForK;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1632040,
                "title": "easy-one-pass-o-n",
                "content": "For the people ahead of the person at `idx=k` they all get down to the minimum of their value and the value of the person at position `k`, for the people behind that person, since we stop as soon as the the person at position `k` has bought all his/her tickets, they get to minimum of  their value and the value of the person at position `k` minus `1`.\\n```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        tot, idx = 0, len(tickets)-1\\n\\n        while(idx>=0):\\n            tot += min(tickets[k], tickets[idx]) if idx<=k else min(tickets[k]-1, tickets[idx])\\n            idx-=1\\n            \\n        return tot \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        tot, idx = 0, len(tickets)-1\\n\\n        while(idx>=0):\\n            tot += min(tickets[k], tickets[idx]) if idx<=k else min(tickets[k]-1, tickets[idx])\\n            idx-=1\\n            \\n        return tot \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622513,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0,n=tickets.size(),fix=tickets[k];\\n        for(int i=0;i<fix-1;i++){\\n            for(int j=0;j<n;j++){\\n                if(tickets[j]>0) ans++;\\n                tickets[j]--;\\n            }\\n        }\\n        for(int j=0;j<=k;j++){\\n            if(tickets[j]>0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0,n=tickets.size(),fix=tickets[k];\\n        for(int i=0;i<fix-1;i++){\\n            for(int j=0;j<n;j++){\\n                if(tickets[j]>0) ans++;\\n                tickets[j]--;\\n            }\\n        }\\n        for(int j=0;j<=k;j++){\\n            if(tickets[j]>0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603655,
                "title": "java-o-n-0ms-4-line-answer",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<=k; i++) ans+=Math.min(tickets[i], tickets[k]);\\n        for(int i=k+1; i<tickets.length; i++)ans+=Math.min(tickets[i], tickets[k]-1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<=k; i++) ans+=Math.min(tickets[i], tickets[k]);\\n        for(int i=k+1; i<tickets.length; i++)ans+=Math.min(tickets[i], tickets[k]-1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591130,
                "title": "java-100-easy-solution",
                "content": "Apulatjonov\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]){\\n                count += tickets[i];\\n            }else{\\n                count += tickets[k];\\n            }\\n        }\\n        for(int i = k; i < tickets.length; i++){\\n            if(tickets[i] >= tickets[k])\\n                count--;\\n        }\\n        return ++count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]){\\n                count += tickets[i];\\n            }else{\\n                count += tickets[k];\\n            }\\n        }\\n        for(int i = k; i < tickets.length; i++){\\n            if(tickets[i] >= tickets[k])\\n                count--;\\n        }\\n        return ++count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588109,
                "title": "c-simple-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = tickets[k];\\n        for(int i = 0; i < k; i++) {\\n            t += min(tickets[i], tickets[k]);\\n        }\\n        for(int i = k+1; i<tickets.size(); i++) {\\n            t += min(tickets[i], tickets[k]-1);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = tickets[k];\\n        for(int i = 0; i < k; i++) {\\n            t += min(tickets[i], tickets[k]);\\n        }\\n        for(int i = k+1; i<tickets.size(); i++) {\\n            t += min(tickets[i], tickets[k]-1);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583361,
                "title": "javascript-brute-force",
                "content": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let time = 0\\n    while(tickets[k]){\\n        for(i = 0; i < tickets.length; i++){\\n           if(tickets[i] && tickets[k]) {\\n               time+=1\\n               tickets[i]-=1\\n           } \\n        }\\n    }\\n    return time\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let time = 0\\n    while(tickets[k]){\\n        for(i = 0; i < tickets.length; i++){\\n           if(tickets[i] && tickets[k]) {\\n               time+=1\\n               tickets[i]-=1\\n           } \\n        }\\n    }\\n    return time\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582832,
                "title": "c-gcc-100-bytes-0-ms-5-9-mb",
                "content": "```\\ni,s;timeRequiredToBuy(int*a,int n,int k){i=s=0;\\nwhile(a[k])a[i]-=a[i]?s++,1:0,i=++i<n?i:0;return s;}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ni,s;timeRequiredToBuy(int*a,int n,int k){i=s=0;\\nwhile(a[k])a[i]-=a[i]?s++,1:0,i=++i<n?i:0;return s;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581974,
                "title": "python-2-line-explain",
                "content": "- For k\\'s first ticket, it\\'ll take k seconds to get the turn\\n- After that, ppl before k will need -1 tickets, after k remain same\\n- Then for the remaining rounds, each ppl will buy at most ticket[k] -1 before job done, plus ticket[k] seconds for k to buy\\n\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        remaining = [t-1 for t in tickets[:k]] + tickets[k+1:]\\n        return k + sum(min(r, tickets[k] - 1) for r in remaining) + tickets[k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        remaining = [t-1 for t in tickets[:k]] + tickets[k+1:]\\n        return k + sum(min(r, tickets[k] - 1) for r in remaining) + tickets[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581364,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        a=tickets[k]\\n        x=0\\n        while(a!=0):\\n            for i in range(len(tickets)):\\n                if(tickets[i]!=0):\\n                    x=x+1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if(a==0):\\n                    return(x)\\n\\t\\t\\t#print(tickets)\\n            a=tickets[k]\\n        return(x)\\n```\\nIf u liked the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        a=tickets[k]\\n        x=0\\n        while(a!=0):\\n            for i in range(len(tickets)):\\n                if(tickets[i]!=0):\\n                    x=x+1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if(a==0):\\n                    return(x)\\n\\t\\t\\t#print(tickets)\\n            a=tickets[k]\\n        return(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580231,
                "title": "python-o-n-faster-than-99",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        x = tickets[k]\\n        res = 0\\n        for i in range(k + 1):\\n            res += min(x, tickets[i])\\n\\n        for i in range(k + 1, len(tickets)):\\n            res += min(x - 1, tickets[i])\\n\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        x = tickets[k]\\n        res = 0\\n        for i in range(k + 1):\\n            res += min(x, tickets[i])\\n\\n        for i in range(k + 1, len(tickets)):\\n            res += min(x - 1, tickets[i])\\n\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1580050,
                "title": "c-o-n-tc-and-o-1-sc-clean",
                "content": "A simple Approch should be to traverse the array and adding elements eqaul to , or less than kth element .\\n\\n\\n\\'\\'\\'\\n\\n         int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int t = 0;  //time taken by kth person to buy the tickets\\n\\t\\t\\n        for(int i = 0; i<tickets.size(); i++){\\n\\t\\t\\n            if(i <= k){\\n\\t\\t\\t//for person is placed earliear than kth person \\n                t = t+ min(tickets[i],  tickets[k]);\\n            }\\n            if(i > k){\\n\\t\\t\\t// for persons placed after the kth person\\n                t = t+ min(tickets[i],  tickets[k]-1);\\n            }\\n        }return t;\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nDry run this code with different test cases and eventually you will know the conditions\\n\\t\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "A simple Approch should be to traverse the array and adding elements eqaul to , or less than kth element .\\n\\n\\n\\'\\'\\'\\n\\n         int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int t = 0;  //time taken by kth person to buy the tickets\\n\\t\\t\\n        for(int i = 0; i<tickets.size(); i++){\\n\\t\\t\\n            if(i <= k){\\n\\t\\t\\t//for person is placed earliear than kth person \\n                t = t+ min(tickets[i],  tickets[k]);\\n            }\\n            if(i > k){\\n\\t\\t\\t// for persons placed after the kth person\\n                t = t+ min(tickets[i],  tickets[k]-1);\\n            }\\n        }return t;\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nDry run this code with different test cases and eventually you will know the conditions\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1579383,
                "title": "python-one-pass-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        res = tickets[k] #it has to buy all at kth position\\n        \\n        for i in range(n):\\n            if i < k:\\n                res += min(tickets[i], tickets[k])  # for all pos before k it will exhaust all tickets or get till number till kth place\\n                \\n            elif i > k:\\n                res += min(tickets[i], tickets[k]-1) #for all pos after k it can exhaust all tickets or get 1 less than the kth gets finished\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        res = tickets[k] #it has to buy all at kth position\\n        \\n        for i in range(n):\\n            if i < k:\\n                res += min(tickets[i], tickets[k])  # for all pos before k it will exhaust all tickets or get till number till kth place\\n                \\n            elif i > k:\\n                res += min(tickets[i], tickets[k]-1) #for all pos after k it can exhaust all tickets or get 1 less than the kth gets finished\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578792,
                "title": "c-simple-approach-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                { if(tickets[i] > 0) \\n                {\\n                    tickets[i]--;\\n                    count++;\\n                }\\n                }\\n              if(tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                { if(tickets[i] > 0) \\n                {\\n                    tickets[i]--;\\n                    count++;\\n                }\\n                }\\n              if(tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578006,
                "title": "c-solution-beats-100-o-n-onepass",
                "content": "```\\nint timeRequiredToBuy(vector<int>& tk, int k) {\\n        int val=tk[k];\\n        int ans=0;\\n        for(int i=0;i<tk.size();i++){\\n            if(tk[i]>val)ans+=val;\\n            else ans+=tk[i];\\n            if(i>k && tk[i]>=tk[k])ans--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint timeRequiredToBuy(vector<int>& tk, int k) {\\n        int val=tk[k];\\n        int ans=0;\\n        for(int i=0;i<tk.size();i++){\\n            if(tk[i]>val)ans+=val;\\n            else ans+=tk[i];\\n            if(i>k && tk[i]>=tk[k])ans--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577999,
                "title": "c-brute-force-to-optimal-easy-to-understand",
                "content": "Time Needed to Buy Tickets - \\n\\n\\n**1) Brute Force -**\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          while(tickets[k]!=0)\\n          {\\n              for(int i=0;i<tickets.size();i++)\\n              {\\n                  if(tickets[i]>0)\\n                  {\\n                      tickets[i]-=1;\\n                      cnt++;\\n                  }\\n                 if(tickets[k]==0)\\n                  {break;}\\n              }\\n          }\\n       return cnt; \\n    }\\n};\\n```\\n\\n**2) Optimal Solution - O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          for(int i=0;i<tickets.size();i++)\\n          {\\n              cnt+=min(tickets[k] - (i>k),tickets[i]);\\n          }\\n       return cnt; \\n    }\\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          while(tickets[k]!=0)\\n          {\\n              for(int i=0;i<tickets.size();i++)\\n              {\\n                  if(tickets[i]>0)\\n                  {\\n                      tickets[i]-=1;\\n                      cnt++;\\n                  }\\n                 if(tickets[k]==0)\\n                  {break;}\\n              }\\n          }\\n       return cnt; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          for(int i=0;i<tickets.size();i++)\\n          {\\n              cnt+=min(tickets[k] - (i>k),tickets[i]);\\n          }\\n       return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577952,
                "title": "c-one-traversal-solution-one-pass-o-n-beats-100-of-c-codes",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577387,
                "title": "c-one-pass-solution",
                "content": "**Intuition**\\npeople ```k``` and people before ```k``` will need to buy ```Min(tickets[i], tickets[k])```.\\npeople after ```k``` don\\'t need to buy any tickets if people ```k``` already got all the tickets, so people after ```k``` need to buy  ```Min(tickets[i], tickets[k] - 1)```.\\n\\n**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int res  = 0;\\n        \\n        for(int i = 0; i < tickets.Length; i++)\\n        {\\n            if(i <= k)\\n                res += Math.Min(tickets[i], tickets[k]);\\n            else if(i > k)\\n                res += Math.Min(tickets[i], tickets[k] - 1);\\n        }\\n       \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```k```\n```k```\n```Min(tickets[i], tickets[k])```\n```k```\n```k```\n```k```\n```Min(tickets[i], tickets[k] - 1)```\n```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int res  = 0;\\n        \\n        for(int i = 0; i < tickets.Length; i++)\\n        {\\n            if(i <= k)\\n                res += Math.Min(tickets[i], tickets[k]);\\n            else if(i > k)\\n                res += Math.Min(tickets[i], tickets[k] - 1);\\n        }\\n       \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577113,
                "title": "c-one-pass-simulation",
                "content": "<strong>Logical Thinking</strong>\\n<p>We can easily solve this problem through <code>simulation</code>. Suppose the <code>k<sup>th</sup></code> person needs <code>target = tickets[k]</code> tickets, then when this person leaves, the people in front of him <code>i < k</code> must have bought the same number of tickets (if they need more tickets), i.e. each of them bought <code>min(target, tickets[i])</code>. Similarly, the people behind him <code>i > k</code> must have bought <code>1</code> less tickets, i.e. <code>min(target - 1, tickets[i])</code>.</p>\\n\\n\\n<strong>C++</strong>\\n\\n```\\n//  Topic   : 2073. Time Needed to Buy Tickets (https://leetcode.com/problems/time-needed-to-buy-tickets/)\\n//  Author  : YCX\\n//  Time    : O(N)\\n//  Space   : O(1)\\n\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0, target = tickets[k], n = tickets.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i <= k)\\n                ans += min<int>(tickets[i], target);\\n            else\\n                ans += min<int>(tickets[i], target - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\n//  Topic   : 2073. Time Needed to Buy Tickets (https://leetcode.com/problems/time-needed-to-buy-tickets/)\\n//  Author  : YCX\\n//  Time    : O(N)\\n//  Space   : O(1)\\n\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0, target = tickets[k], n = tickets.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i <= k)\\n                ans += min<int>(tickets[i], target);\\n            else\\n                ans += min<int>(tickets[i], target - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577096,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    void solve(vector<int> &nums, int k)\\n    {\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0)\\n                continue;\\n            nums[i] = nums[i]-1;\\n                ans++;\\n            if(nums[k] == 0)\\n                return;\\n        }\\n    }\\n    \\n    int timeRequiredToBuy(vector<int> &nums, int k) \\n    {    \\n        while(true)\\n        {\\n            if(nums[k]==0)\\n                break;\\n            solve(nums,k);    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    void solve(vector<int> &nums, int k)\\n    {\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0)\\n                continue;\\n            nums[i] = nums[i]-1;\\n                ans++;\\n            if(nums[k] == 0)\\n                return;\\n        }\\n    }\\n    \\n    int timeRequiredToBuy(vector<int> &nums, int k) \\n    {    \\n        while(true)\\n        {\\n            if(nums[k]==0)\\n                break;\\n            solve(nums,k);    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576994,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        res = i = 0\\n        \\n        while tickets[k]:\\n            try:\\n                j = tickets[i]\\n                if j:\\n                    tickets[i] = j - 1\\n                    i += 1\\n                    res += 1\\n                else:\\n                    i += 1\\n            except:\\n                i = 0\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        res = i = 0\\n        \\n        while tickets[k]:\\n            try:\\n                j = tickets[i]\\n                if j:\\n                    tickets[i] = j - 1\\n                    i += 1\\n                    res += 1\\n                else:\\n                    i += 1\\n            except:\\n                i = 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576925,
                "title": "java-brute-force-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\n    public int timeRequiredToBuy(int[] tickets, int k)\\n    {\\n        int time = 0;\\n        while(true)\\n        {\\n            for(int i = 0; i < tickets.length; i++)\\n            {\\n                if(tickets[i]-- >= 1)\\n                    time++;\\n                if(tickets[k] == 0)\\n                    return time;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int timeRequiredToBuy(int[] tickets, int k)\\n    {\\n        int time = 0;\\n        while(true)\\n        {\\n            for(int i = 0; i < tickets.length; i++)\\n            {\\n                if(tickets[i]-- >= 1)\\n                    time++;\\n                if(tickets[k] == 0)\\n                    return time;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576918,
                "title": "python-java-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, ticket in enumerate(tickets):\\n\\t\\t\\t\\tif i <= k:\\n\\t\\t\\t\\t\\tres += min(ticket, tickets[k])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif ticket < tickets[k]:\\n\\t\\t\\t\\t\\t\\tres += ticket\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres += tickets[k] - 1\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int i = 0; i < tickets.length; i ++) {\\n\\t\\t\\t\\tif (i <= k) {\\n\\t\\t\\t\\t\\tres += Math.min(tickets[i], tickets[k]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (tickets[i] < tickets[k]) {\\n\\t\\t\\t\\t\\t\\tres += tickets[i];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tres += tickets[k] - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, ticket in enumerate(tickets):\\n\\t\\t\\t\\tif i <= k:\\n\\t\\t\\t\\t\\tres += min(ticket, tickets[k])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif ticket < tickets[k]:\\n\\t\\t\\t\\t\\t\\tres += ticket\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres += tickets[k] - 1\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int i = 0; i < tickets.length; i ++) {\\n\\t\\t\\t\\tif (i <= k) {\\n\\t\\t\\t\\t\\tres += Math.min(tickets[i], tickets[k]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4077206,
                "title": "o-n-with-readable-code-simple-for-loop",
                "content": "## Approach\\n<!-- Describe your approach to solving the problem. -->\\ndeclare variable ans = 0, this variable will be the counter (and the answer).\\nthe target is tickets[k]. \\nif the index is less or equal to k (the target index):\\n- if the tickets[index] is bigger than target add ans equals target.\\n- else (tickets[index] is less than target) add ans equals tickets[index].\\n\\nelse (index is bigger than k (the target index))\\n- if the tickets[index] is bigger than target add ans equals target-1 (-1 because we assume that in the last recursion stopped in target index).\\n- else (tickets[index] is less than target) add ans equals tickets[index].\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1) (?)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0 ;\\n        for(int x = 0 ; x<tickets.length ; x++){\\n            if(x <= k){\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k];\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }else{\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k]-1;\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0 ;\\n        for(int x = 0 ; x<tickets.length ; x++){\\n            if(x <= k){\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k];\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }else{\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k]-1;\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061851,
                "title": "beats-100-cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n\\n        while(tickets[k]>0){\\n            for(int j=0;j<tickets.size();j++){\\n//decrementing ticket at j and incrementing ans only if k > 0 && j > 0\\n                if(tickets[k]!=0 && tickets[j]>0){\\n                    tickets[j]--;\\n                    ans++;\\n                }\\n        }\\n\\n        \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n\\n        while(tickets[k]>0){\\n            for(int j=0;j<tickets.size();j++){\\n//decrementing ticket at j and incrementing ans only if k > 0 && j > 0\\n                if(tickets[k]!=0 && tickets[j]>0){\\n                    tickets[j]--;\\n                    ans++;\\n                }\\n        }\\n\\n        \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059886,
                "title": "easiest-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust need to think how can we iterate the vector again and again\\nand to do this i have used the method of circular queue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(1)\\n        {\\n            if(tickets[i]!=0)\\n            {\\n                cnt++;\\n                tickets[i]--;\\n            }\\n            if(i==k&&tickets[k]==0)\\n             return cnt;\\n            i=(i+1)%n;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(1)\\n        {\\n            if(tickets[i]!=0)\\n            {\\n                cnt++;\\n                tickets[i]--;\\n            }\\n            if(i==k&&tickets[k]==0)\\n             return cnt;\\n            i=(i+1)%n;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055339,
                "title": "0-ms-solution-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, we mainly take count of contribution of every index value while a loop runs.\\n\\nIf value at any index (i) **before** given index (k) is **greater**, then **it will contribute same as tickets[k**]. Because, while running the loop the value of tickets[i] will run  for (tickets[k]) times.\\n\\nIf value at any index (i) **after** given index (k) is **greater** or equals, then **it will contribute same as (tickets[k]-1)**. Because, before reaching the loop for the last time, index at k will get the ticket. So, we won\\'t take the last count.\\n\\nIf value at any index (i) is less than value at given index (k), then the we will not change the value of it. Because, it will be 0 before tickets[k] time. It will contribute tickets[i].\\n\\nWe will update the no of contibution with value of any index.\\nThen, we will take the sum of the whole array and that\\'s the answer. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int sum=0;\\n        for (int i=0;i<tickets.length;i++){\\n            if (k>i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k];\\n            }\\n            if (k<i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k]-1;\\n            }\\n        }\\n\\n        for (int i=0;i<tickets.length;i++){\\n            sum+=tickets[i];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int sum=0;\\n        for (int i=0;i<tickets.length;i++){\\n            if (k>i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k];\\n            }\\n            if (k<i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k]-1;\\n            }\\n        }\\n\\n        for (int i=0;i<tickets.length;i++){\\n            sum+=tickets[i];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048214,
                "title": "java-simple-using-queue-t-n",
                "content": "# Intuition\\nUsed Queue\\n\\n# Approach\\n1. Number of People in queue.(count same as ticket).\\n2. remove from queue when tickets[queue.peek()] == 0,\\n3. otherwise queue.add(queue.peek()) & queue.remove(); \\n\\n# Complexity\\n- Time complexity:\\nOnly one while loop : T(n)\\nremove and add take : O(1)\\nTherfore TimeComplexity : T(n).\\n\\n- Space complexity:\\nSpace Complexity is the space taken by queue which is O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        int count = 0;\\n        while(!queue.isEmpty()){\\n            tickets[queue.peek()]--;\\n            if(tickets[queue.peek()] == 0){\\n                queue.remove();\\n            }else if(tickets[queue.peek()] != 0){\\n                queue.add(queue.peek());\\n                queue.remove();\\n            }\\n            count++;\\n            if(tickets[k] == 0){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        int count = 0;\\n        while(!queue.isEmpty()){\\n            tickets[queue.peek()]--;\\n            if(tickets[queue.peek()] == 0){\\n                queue.remove();\\n            }else if(tickets[queue.peek()] != 0){\\n                queue.add(queue.peek());\\n                queue.remove();\\n            }\\n            count++;\\n            if(tickets[k] == 0){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045024,
                "title": "time-needed-to-buy-tickets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndecreasing array values with base case condition until ticket[k] becomes zero.\\nAnd if there is only one ticket needs to buy then just do time = k+1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->2ms\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n39.80 mb\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int time=0;\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets[k]==1){\\n            return k+1;\\n        }\\n        while(tickets[k]>0){\\n            for(int i = 0;i<tickets.length;i++){\\n                if(tickets[i]==0){\\n                    continue;\\n                }\\n                time++;\\n                tickets[i] = tickets[i] - 1;\\n                if(tickets[k]==0){\\n                    break;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int time=0;\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets[k]==1){\\n            return k+1;\\n        }\\n        while(tickets[k]>0){\\n            for(int i = 0;i<tickets.length;i++){\\n                if(tickets[i]==0){\\n                    continue;\\n                }\\n                time++;\\n                tickets[i] = tickets[i] - 1;\\n                if(tickets[k]==0){\\n                    break;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037603,
                "title": "easy-solution-to-timerequiredtobuy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- I could move the elements position for each round\\n- I just need the seconds value\\n- How do I know when to stop iterating?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolution with JavaScript. Reduce each element by one until the `k`$$th$$ element is equal to cero.\\n\\n# Complexity\\n- Time complexity: ---\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let sec = 0;\\n    const ticketsLength = tickets.length;\\n    \\n    while (tickets[k]!==0) {\\n        for (let i = 0; i < ticketsLength; i++) {\\n            if (tickets[i] > 0) {\\n                tickets[i]--;\\n                sec++;\\n            }\\n            if(i===k) if(tickets[k]===0) break;\\n        }\\n    }\\n    return sec;\\n}; \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let sec = 0;\\n    const ticketsLength = tickets.length;\\n    \\n    while (tickets[k]!==0) {\\n        for (let i = 0; i < ticketsLength; i++) {\\n            if (tickets[i] > 0) {\\n                tickets[i]--;\\n                sec++;\\n            }\\n            if(i===k) if(tickets[k]===0) break;\\n        }\\n    }\\n    return sec;\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036091,
                "title": "easy-solution-100",
                "content": "# Approach\\nLinear Search\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tic, int k) {\\n        int ans=0;\\n        for(int i=0;i<tic.size();i++)\\n        {\\n            if(tic[i]>tic[k])\\n            {\\n                ans+=tic[k];\\n            }\\n            else\\n            {\\n                ans+=tic[i];\\n            }\\n            if(tic[i]>=tic[k]&&i>k)\\n            {\\n                ans--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tic, int k) {\\n        int ans=0;\\n        for(int i=0;i<tic.size();i++)\\n        {\\n            if(tic[i]>tic[k])\\n            {\\n                ans+=tic[k];\\n            }\\n            else\\n            {\\n                ans+=tic[i];\\n            }\\n            if(tic[i]>=tic[k]&&i>k)\\n            {\\n                ans--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033039,
                "title": "beats-100-runtime-and-100-memory",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n???\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# @param {Integer[]} tickets\\n# @param {Integer} k\\n# @return {Integer}\\ndef time_required_to_buy(tickets, k)\\n\\n    amount_of_tickets = tickets[k]\\n    track_location_of_k = k\\n    seconds = 0\\n    index = 0\\n    val = nil\\n    while tickets.size > 0  \\n        if 0 != k\\n            k = k - 1\\n        else\\n            if tickets[k] == 1\\n                return seconds + 1\\n            end\\n\\n            k = tickets.size - 1\\n        end\\n\\n        val = tickets.shift\\n        val = val - 1\\n\\n        if val != 0\\n            tickets << val\\n        end\\n\\n        seconds = seconds + 1\\n    end\\n\\n    seconds\\nend\\n\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} tickets\\n# @param {Integer} k\\n# @return {Integer}\\ndef time_required_to_buy(tickets, k)\\n\\n    amount_of_tickets = tickets[k]\\n    track_location_of_k = k\\n    seconds = 0\\n    index = 0\\n    val = nil\\n    while tickets.size > 0  \\n        if 0 != k\\n            k = k - 1\\n        else\\n            if tickets[k] == 1\\n                return seconds + 1\\n            end\\n\\n            k = tickets.size - 1\\n        end\\n\\n        val = tickets.shift\\n        val = val - 1\\n\\n        if val != 0\\n            tickets << val\\n        end\\n\\n        seconds = seconds + 1\\n    end\\n\\n    seconds\\nend\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4032185,
                "title": "c-o-n-deque-implementation-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n     int time=0;\\n     deque<int>dq;\\n     //storing indexes of given array of tickets\\n     for(int i=0;i<tickets.size();i++){\\n         dq.push_back(i);\\n     }\\n     //k points to original array of tickets\\n     while(tickets[k]!=0){\\n         //selling ticket 1 at a time \\n         tickets[dq.front()]=tickets[dq.front()]-1;\\n         //increasing time by 1\\n         time++;\\n         //if person completes buying popping out its index from deque\\n         if(tickets[dq.front()]==0){\\n             dq.pop_front();\\n         }\\n         //pushing back that index to end of deque\\n         else{\\n             int temp=dq.front();\\n             dq.pop_front();\\n             dq.push_back(temp);\\n         }\\n     }\\n     return time;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n     int time=0;\\n     deque<int>dq;\\n     //storing indexes of given array of tickets\\n     for(int i=0;i<tickets.size();i++){\\n         dq.push_back(i);\\n     }\\n     //k points to original array of tickets\\n     while(tickets[k]!=0){\\n         //selling ticket 1 at a time \\n         tickets[dq.front()]=tickets[dq.front()]-1;\\n         //increasing time by 1\\n         time++;\\n         //if person completes buying popping out its index from deque\\n         if(tickets[dq.front()]==0){\\n             dq.pop_front();\\n         }\\n         //pushing back that index to end of deque\\n         else{\\n             int temp=dq.front();\\n             dq.pop_front();\\n             dq.push_back(temp);\\n         }\\n     }\\n     return time;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022322,
                "title": "easy-o-n",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let max = tickets[k]\\n    let total = 0\\n    let rem = 0\\n\\n    for(let idx in tickets) {\\n        let ticket = tickets[idx]\\n        if(idx > k && ticket >= max) rem++\\n        total += Math.min(max, ticket)\\n    }\\n\\n    return total - rem\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let max = tickets[k]\\n    let total = 0\\n    let rem = 0\\n\\n    for(let idx in tickets) {\\n        let ticket = tickets[idx]\\n        if(idx > k && ticket >= max) rem++\\n        total += Math.min(max, ticket)\\n    }\\n\\n    return total - rem\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008932,
                "title": "0ms-beats-100-00-of-users-with-java",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n\\n        for(int i=0;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]){\\n                if(i>k){\\n                    count += tickets[k] - 1;\\n                }\\n                else{\\n                    count += tickets[k];\\n                }\\n            }\\n            else{\\n                count += tickets[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n\\n        for(int i=0;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]){\\n                if(i>k){\\n                    count += tickets[k] - 1;\\n                }\\n                else{\\n                    count += tickets[k];\\n                }\\n            }\\n            else{\\n                count += tickets[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008532,
                "title": "go",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tc := 0\\n\\ti := 0\\n\\n\\tfor {\\n\\n\\t\\tif tickets[i] != 0 {\\n\\t\\t\\ttickets[i] -= 1\\n\\t\\t\\tc += 1\\n\\t\\t}\\n\\t\\tfmt.Println(c, i, tickets[i])\\n\\t\\tif i == k && tickets[k] == 0 {\\n\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif len(tickets)-1 == i {\\n\\t\\t\\ti = 0\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t}\\n\\n    return c\\n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tc := 0\\n\\ti := 0\\n\\n\\tfor {\\n\\n\\t\\tif tickets[i] != 0 {\\n\\t\\t\\ttickets[i] -= 1\\n\\t\\t\\tc += 1\\n\\t\\t}\\n\\t\\tfmt.Println(c, i, tickets[i])\\n\\t\\tif i == k && tickets[k] == 0 {\\n\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif len(tickets)-1 == i {\\n\\t\\t\\ti = 0\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t}\\n\\n    return c\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002763,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n  let queue = []\\n  let totalTime = 0;\\n  for(let i = 0; i < tickets.length; i++){\\n    queue.push({pos:i, no_of_tickets_needTo_buy: tickets[i]})\\n  }\\n  while(queue.length > 0){\\n    const person = queue.shift();\\n    if(person.no_of_tickets_needTo_buy > 0){\\n      person.no_of_tickets_needTo_buy --\\n      queue.push(person)\\n      totalTime ++\\n      if(person.pos === k && person.no_of_tickets_needTo_buy === 0) return totalTime;\\n    }\\n  }\\n  return totalTime\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n  let queue = []\\n  let totalTime = 0;\\n  for(let i = 0; i < tickets.length; i++){\\n    queue.push({pos:i, no_of_tickets_needTo_buy: tickets[i]})\\n  }\\n  while(queue.length > 0){\\n    const person = queue.shift();\\n    if(person.no_of_tickets_needTo_buy > 0){\\n      person.no_of_tickets_needTo_buy --\\n      queue.push(person)\\n      totalTime ++\\n      if(person.pos === k && person.no_of_tickets_needTo_buy === 0) return totalTime;\\n    }\\n  }\\n  return totalTime\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002364,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt = 0, a = 0;\\n\\n        while(tickets[k] != 0){\\n            if(a == tickets.size()){\\n                a = 0;\\n            }\\n            if(tickets[a] == 0){\\n                a++;\\n                continue;\\n            }\\n            tickets[a]--;\\n            cnt++;\\n            a++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt = 0, a = 0;\\n\\n        while(tickets[k] != 0){\\n            if(a == tickets.size()){\\n                a = 0;\\n            }\\n            if(tickets[a] == 0){\\n                a++;\\n                continue;\\n            }\\n            tickets[a]--;\\n            cnt++;\\n            a++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001871,
                "title": "c-solution-using-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> line;\\n        int n = tickets.size();\\n        int time = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            line.push(i);\\n        }\\n\\n        while (!line.empty()) {\\n            int current = line.front(); \\n            line.pop();\\n\\n            if (tickets[current] > 0) {\\n                tickets[current]--;\\n                time++;\\n\\n                if (current == k && tickets[k] == 0) {\\n                    break;\\n                }\\n\\n                line.push(current); \\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> line;\\n        int n = tickets.size();\\n        int time = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            line.push(i);\\n        }\\n\\n        while (!line.empty()) {\\n            int current = line.front(); \\n            line.pop();\\n\\n            if (tickets[current] > 0) {\\n                tickets[current]--;\\n                time++;\\n\\n                if (current == k && tickets[k] == 0) {\\n                    break;\\n                }\\n\\n                line.push(current); \\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001811,
                "title": "c-iterative-solve",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        vector<int> remain = tickets;\\n        int time = 0;\\n\\n        while (remain[k] > 0) {\\n            for (int i = 0; i < n; i++) {\\n                if (remain[i] > 0) {\\n                    remain[i]--;\\n                    time++;\\n\\n                    if (i==k && remain[i]==0) { \\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        vector<int> remain = tickets;\\n        int time = 0;\\n\\n        while (remain[k] > 0) {\\n            for (int i = 0; i < n; i++) {\\n                if (remain[i] > 0) {\\n                    remain[i]--;\\n                    time++;\\n\\n                    if (i==k && remain[i]==0) { \\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998439,
                "title": "o-n-c-solution",
                "content": "# Complexity\\n- Time complexity:\\n***O(N)***\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        for(int i = 0;i<a.size();i++){\\n            if(i<=k)cnt+=min(a[i],a[k]);\\n            else cnt+=min(a[k]-1,a[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        for(int i = 0;i<a.size();i++){\\n            if(i<=k)cnt+=min(a[i],a[k]);\\n            else cnt+=min(a[k]-1,a[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998421,
                "title": "100-easy-c-solution-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        while(a[k]){\\n            for(int i = 0;i<a.size();i++){\\n                if(a[i])a[i]--,cnt++;\\n                if(!a[k])break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        while(a[k]){\\n            for(int i = 0;i<a.size();i++){\\n                if(a[i])a[i]--,cnt++;\\n                if(!a[k])break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995977,
                "title": "easy-o-1-solution-without-queue",
                "content": "# Intuition\\nnothing XD\\n\\n# Approach\\niterate over array and keep track \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int i=0;\\n        int sec=0;\\n        while(tickets[k]>0){\\n\\n            if(tickets[i]>0){\\n                tickets[i] = tickets[i]-1;\\n                i = (i+1)%tickets.length;\\n                sec++;\\n            }else{\\n                i = (i+1)%tickets.length;\\n            }\\n        }\\n\\n        return sec;\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int i=0;\\n        int sec=0;\\n        while(tickets[k]>0){\\n\\n            if(tickets[i]>0){\\n                tickets[i] = tickets[i]-1;\\n                i = (i+1)%tickets.length;\\n                sec++;\\n            }else{\\n                i = (i+1)%tickets.length;\\n            }\\n        }\\n\\n        return sec;\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985951,
                "title": "simple-c-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& t, int k) {\\n        int ans=0;\\n        while(t[k]!=0){\\n            for(int i=0;i<t.size();i++){\\n                if(t[i]>0){\\n                    t[i]=t[i]-1;\\n                    ans++;\\n                }\\n                if(t[k]==0)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& t, int k) {\\n        int ans=0;\\n        while(t[k]!=0){\\n            for(int i=0;i<t.size();i++){\\n                if(t[i]>0){\\n                    t[i]=t[i]-1;\\n                    ans++;\\n                }\\n                if(t[k]==0)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984228,
                "title": "simple-c-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\nLinear Time complexity\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n                i++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return time;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n                i++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return time;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980174,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int n = tickets[k];\\n        while (n > 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i]-- > 0) {\\n                    count++;\\n                    if (i == k) {\\n                        n--;\\n                    }\\n                    if (tickets[k] == 0) {\\n                        return count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int n = tickets[k];\\n        while (n > 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i]-- > 0) {\\n                    count++;\\n                    if (i == k) {\\n                        n--;\\n                    }\\n                    if (tickets[k] == 0) {\\n                        return count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980063,
                "title": "java-easy-o-n-100-beats-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s assume there are n person standing in the queue a\\na1, a2, a3, ... ak ... an\\ni\\'th person will buy ai number of tickets. \\n\\nObservations\\nFor any person standing at the j\\'th position in the queue such that \\nj <= k, \\nthe one thing is sure, that person will make the k\\'th person to wait by min(aj, ak)\\n\\nand if \\nj > k\\nthen the j\\'th person will make the k\\'th person to wait longer by min(aj, ak-1)\\n\\nUsing the above two observations, we can write an algorithm with O(N) Time Complexity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        // O(N) solution\\n        int time = 0; \\n        for ( int i=0; i < tickets.length; i++){\\n            if ( i <= k){\\n                time += ( tickets[i] <= tickets[k])?tickets[i]:tickets[k];\\n            }\\n            else{\\n                time += (tickets[i] < tickets[k])?tickets[i]: (tickets[k]-1);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        // O(N) solution\\n        int time = 0; \\n        for ( int i=0; i < tickets.length; i++){\\n            if ( i <= k){\\n                time += ( tickets[i] <= tickets[k])?tickets[i]:tickets[k];\\n            }\\n            else{\\n                time += (tickets[i] < tickets[k])?tickets[i]: (tickets[k]-1);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971374,
                "title": "js-time-o-n-space-o-1-single-for-loop",
                "content": "# Intuition & Approach\\nCycle the array, if tickets at i is greater than or equal to tickets at k you add to seconds the value of tickets at k, otherwise (if the number is smaller) you add tickets at k.\\nif the number at k is larger then the number at i and it is positioned after k so that i > k, you need to subtract 1 for each occourrence (we need to stop when tickets[k] reaches 0, so we dont need to count iterations afterwards)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let seconds = 0\\n    for(let i = 0; i < tickets.length; i++){\\n        if(tickets[i] >= tickets[k]){\\n            seconds += tickets[k]\\n            if(i > k) {\\n                seconds -= 1\\n            }\\n        } else {\\n            seconds += tickets[i]\\n        }\\n    }\\n    return seconds\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let seconds = 0\\n    for(let i = 0; i < tickets.length; i++){\\n        if(tickets[i] >= tickets[k]){\\n            seconds += tickets[k]\\n            if(i > k) {\\n                seconds -= 1\\n            }\\n        } else {\\n            seconds += tickets[i]\\n        }\\n    }\\n    return seconds\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966793,
                "title": "with-basic-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count=0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i]>0:\\n                    tickets[i]-=1\\n                    count+=1\\n                if tickets[k]==0:\\n                    return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count=0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i]>0:\\n                    tickets[i]-=1\\n                    count+=1\\n                if tickets[k]==0:\\n                    return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963719,
                "title": "easy-to-understand-python3-solution-tc-m-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count = 0\\n\\n        check = tickets[k]\\n\\n        while check != 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0:\\n                    if tickets[k] == 0:\\n                        break\\n                    count += 1\\n                    tickets[i] -= 1\\n            check = tickets[k]\\n            \\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count = 0\\n\\n        check = tickets[k]\\n\\n        while check != 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0:\\n                    if tickets[k] == 0:\\n                        break\\n                    count += 1\\n                    tickets[i] -= 1\\n            check = tickets[k]\\n            \\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956695,
                "title": "python-one-liner",
                "content": "# Approach\\n- the ticket less than the kth customer must spend all their time\\nsum(i for i in tickets if i <= tickets[k])\\n- the ticket more than the kth customer must spend the time equal to the kth customer\\nlen([i for i in tickets if i > tickets[k]])*tickets[k]\\n- the ticket more than the kth customer but after the kth customer need to minus one seconds beacuse when the kth customer finished, the program finished\\nlen([i for i in tickets[k+1:] if i >= tickets[k]])\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(i for i in tickets if i <= tickets[k]) + len([i for i in tickets if i > tickets[k]])*tickets[k] - len([i for i in tickets[k+1:] if i >= tickets[k]])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(i for i in tickets if i <= tickets[k]) + len([i for i in tickets if i > tickets[k]])*tickets[k] - len([i for i in tickets[k+1:] if i >= tickets[k]])\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1628030,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1928915,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1930154,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 2010067,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 2010064,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1969342,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1919927,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            }
        ]
    }
]