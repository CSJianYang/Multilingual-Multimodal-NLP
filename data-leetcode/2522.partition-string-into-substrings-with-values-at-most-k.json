[
    {
        "title": "Partition String Into Substrings With Values at Most K",
        "question_content": "You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\n\n\tEach digit of s is part of exactly one substring.\n\tThe value of each substring is less than or equal to k.\n\nReturn the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\n\n\tThe value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\n\tA substring is a contiguous sequence of characters within a string.\n\n&nbsp;\nExample 1:\n\nInput: s = \"165462\", k = 60\nOutput: 4\nExplanation: We can partition the string into substrings \"16\", \"54\", \"6\", and \"2\". Each substring has a value less than or equal to k = 60.\nIt can be shown that we cannot partition the string into less than 4 substrings.\n\nExample 2:\n\nInput: s = \"238182\", k = 5\nOutput: -1\nExplanation: There is no good partition for this string.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts[i] is a digit from '1' to '9'.\n\t1 <= k <= 109\n\n&nbsp;\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}",
        "solutions": [
            {
                "id": 2977270,
                "title": "greedy",
                "content": "It can take you a moment to figure out why greedy works here.\\n    \\nWe track the current number `n`, and start a new partition when `n` exceeds `k`.\\n    \\n**C++**\\n```cpp\\nint minimumPartition(string s, int k) {\\n    long long n = 0, res = 1;\\n    for (int i = 0; i < s.size(); ++i) {\\n        n = n * 10 + s[i] - \\'0\\';\\n        if (n > k) {\\n            ++res;\\n            n = s[i] - \\'0\\';\\n        }\\n        if (n > k)\\n            return -1;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minimumPartition(string s, int k) {\\n    long long n = 0, res = 1;\\n    for (int i = 0; i < s.size(); ++i) {\\n        n = n * 10 + s[i] - \\'0\\';\\n        if (n > k) {\\n            ++res;\\n            n = s[i] - \\'0\\';\\n        }\\n        if (n > k)\\n            return -1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2977281,
                "title": "java-c-python-greedy-approach-explanation",
                "content": "#### **Explanation:**\\n\\nif we want to make minimun number of partition then, what we need to do?\\nYes, we need to do partition such as each partition has a greater value as much as possible.\\n\\nWhat if we have `k` greater than or equal to 10?\\nSo it\\'s always possible to make partition. right?\\n\\nSo how greedy works here? let\\'s see the test case.\\n\\nSuppose we have a string `s = \"165462\"` and `k = 60` & we want to make minimun partition such that each partition has value less than or equal to `k`.\\n\\n`s = \"165462\" & k = 60`\\n\\nfirst we wiil take `num = 1` and we will compare that `k` is greater than `num` if yes then just maximize your `num` value.\\nAfter mathematical calculation ie. `num = (num * 10) + int(digit)` our `num` will 16.\\nhere you can see `k` is still greater than num. then again go for maximizing.\\n\\nnow `num = 165` which is greater than `k`, so it means??\\nif we add the last digit in `num` that is `5` so we are getting higher value than `k`. which is not valid partiton.\\nso now we got one partition `[16]`, then just assign last digit in `num`. now `num = 5`\\n\\nnext time `num = 54`, which is less than `k` so go for maximazing the value of `num`.\\nnow `num = 546`, which is greater than `k`, So what we can see agian? if we add last digit in `num`, we are getting higher value than `k`, so we don\\'t need to take last digit. Now our partition is `[16, 54]` and then just assign last digit in num, `num = 6`\\n\\nnow again `num` is less than `k`, so go for maximizing, after that `num` will be `62`\\n\\nnow `num = 62`, which is greater than `k`, So if we add last digit in `num`, we are getting higher value than `k`, so Now our partition is `[16, 54, 6]` and then just assign last digit in num, `num = 2`\\n\\nafter the end of loop we are stiill having last one partition that is `num = 2` then just `return count + 1`. & our partition is `[16, 54, 6, 2]`\\n\\nI hope you understood the logic of this problem.\\nTry to think for more test cases. then your doubt will be more clear.\\n\\nEg: \\n`s = 1239 & k=5`\\n`s = \"43267589\" & k = 5`\\n`s = \"43267589\" & k = 20`\\n`s = \"43267589\" & k = 100`\\n\\n\\n### **Solution:**\\n- *Time Complexity:* **O(N)**\\n- *Space Complexity:* **O(1)**\\n\\n```Java []\\nclass Solution {\\n    public int minimumPartition(final String s, final int k) {\\n        long num = 0;\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            int digit = s.charAt(i) - 48;\\n            \\n            num = (num * 10) + digit;\\n            if (num > k) {\\n                num = digit;\\n                count++;\\n            }\\n            if (digit > k) return -1;\\n        }\\n        return count + 1;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long num = 0, count = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            num = num * 10 + s[i] - \\'0\\';\\n            if (num > k) {\\n                count++;\\n                num = s[i] - \\'0\\';\\n            }\\n            if (num > k)\\n                return -1;\\n        }\\n        return count + 1;\\n    }\\n};\\n```\\n```Python []\\nclass Solution(object):\\n    def minimumPartition(self, s, k):\\n        count = num = 0\\n        for digit in s:\\n            num = (num * 10) + int(digit)\\n            if k >= num: continue\\n            else:\\n                num = int(digit)\\n                count += 1\\n            if num > k: return -1\\n        return count + 1\\n```\\n\\n**UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int minimumPartition(final String s, final int k) {\\n        long num = 0;\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            int digit = s.charAt(i) - 48;\\n            \\n            num = (num * 10) + digit;\\n            if (num > k) {\\n                num = digit;\\n                count++;\\n            }\\n            if (digit > k) return -1;\\n        }\\n        return count + 1;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long num = 0, count = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            num = num * 10 + s[i] - \\'0\\';\\n            if (num > k) {\\n                count++;\\n                num = s[i] - \\'0\\';\\n            }\\n            if (num > k)\\n                return -1;\\n        }\\n        return count + 1;\\n    }\\n};\\n```\n```Python []\\nclass Solution(object):\\n    def minimumPartition(self, s, k):\\n        count = num = 0\\n        for digit in s:\\n            num = (num * 10) + int(digit)\\n            if k >= num: continue\\n            else:\\n                num = int(digit)\\n                count += 1\\n            if num > k: return -1\\n        return count + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977442,
                "title": "java-c-python-javascript-easy-and-concise-solution-two-pointers",
                "content": "```java []\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int i=0,c=0,j=0;\\n        // i - left pointer\\n        // j - right pointer\\n        while(j<s.length())\\n        {\\n            while(j<s.length() && Long.parseLong(s.substring(i,j+1))<=k)\\n                j++;\\n            c++;\\n            if(i==j)\\n                return -1;\\n            i=j;\\n        }\\n        return c;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int i = 0, c = 0, j = 0;\\n        // i - left pointer\\n        // j - right pointer\\n        while (j < s.length()) {\\n            while (j < s.length() && stol(s.substr(i, j-i+1)) <= k) {\\n                j++;\\n            }\\n            c++;\\n            if (i == j) {\\n                return -1;\\n            }\\n            i = j;\\n        }\\n        return c;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution(object):\\n    def minimumPartition(self, s, k):\\n        i = 0\\n        c = 0\\n        j = 0\\n        # i - left pointer\\n        # j - right pointer\\n        while j < len(s):\\n            while j < len(s) and int(s[i:j + 1]) <= k:\\n                j += 1\\n            c += 1\\n            if i == j:\\n                return -1\\n            i = j\\n        return c\\n```\\n``` javascript []\\n    var minimumPartition = function(s, k) {\\n        let i = 0;\\n        let c = 0;\\n        let j = 0;\\n        // i - left pointer\\n        // j - right pointer\\n        while (j < s.length) {\\n            while (j < s.length && parseInt(s.substring(i, j + 1)) <= k) {\\n                j++;\\n            }\\n            c++;\\n            if (i === j) {\\n                return -1;\\n            }\\n            i = j;\\n        }\\n        return c;\\n    };\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int i=0,c=0,j=0;\\n        // i - left pointer\\n        // j - right pointer\\n        while(j<s.length())\\n        {\\n            while(j<s.length() && Long.parseLong(s.substring(i,j+1))<=k)\\n                j++;\\n            c++;\\n            if(i==j)\\n                return -1;\\n            i=j;\\n        }\\n        return c;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int i = 0, c = 0, j = 0;\\n        // i - left pointer\\n        // j - right pointer\\n        while (j < s.length()) {\\n            while (j < s.length() && stol(s.substr(i, j-i+1)) <= k) {\\n                j++;\\n            }\\n            c++;\\n            if (i == j) {\\n                return -1;\\n            }\\n            i = j;\\n        }\\n        return c;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution(object):\\n    def minimumPartition(self, s, k):\\n        i = 0\\n        c = 0\\n        j = 0\\n        # i - left pointer\\n        # j - right pointer\\n        while j < len(s):\\n            while j < len(s) and int(s[i:j + 1]) <= k:\\n                j += 1\\n            c += 1\\n            if i == j:\\n                return -1\\n            i = j\\n        return c\\n```\n``` javascript []\\n    var minimumPartition = function(s, k) {\\n        let i = 0;\\n        let c = 0;\\n        let j = 0;\\n        // i - left pointer\\n        // j - right pointer\\n        while (j < s.length) {\\n            while (j < s.length && parseInt(s.substring(i, j + 1)) <= k) {\\n                j++;\\n            }\\n            c++;\\n            if (i === j) {\\n                return -1;\\n            }\\n            i = j;\\n        }\\n        return c;\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977416,
                "title": "c-solution-very-simple-and-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        long long t = 0;\\n        for(auto c: s){\\n            long long r = t*10 + c-\\'0\\';\\n            if(r <= k) t = r;\\n            else{\\n                ans++;\\n                t = 0;\\n                r = c - \\'0\\';\\n                if(r <= k) t = r;\\n                else return -1;\\n            }\\n        }\\n        if(t <= k) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        long long t = 0;\\n        for(auto c: s){\\n            long long r = t*10 + c-\\'0\\';\\n            if(r <= k) t = r;\\n            else{\\n                ans++;\\n                t = 0;\\n                r = c - \\'0\\';\\n                if(r <= k) t = r;\\n                else return -1;\\n            }\\n        }\\n        if(t <= k) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999705,
                "title": "dp-knapsack-pattern",
                "content": "**DP :**\\n```\\nclass Solution {\\n    int inf = (int) 1e6;\\n    int dp[];\\n    public int minimumPartition(String s, int k) {\\n        int n = s.length();\\n        dp = new int[n];\\n        Arrays.fill(dp, -1);\\n\\t\\t//since all characters will be between 1-9 \\n\\t\\t//so we have taken 10 length visited array\\n        int ans = helper(s, k, 0, 0);  \\n        return ans >= inf ? -1 : ans;\\n    }\\n\\n    int helper(String s, int k, int idx, int start) {\\n        if (idx == s.length()) return 1;\\n        long num = Long.parseLong(s.substring(start, idx + 1));\\n        if (num > k ) return inf; //if the current value of the substring is > k  it means we have \\n\\t\\t//violated the rule of the question so we will return a big no so that this step will not be taken valid.\\n        if (dp[start] != -1) return dp[start];\\n\\t\\t//so now we have two options either start a new substring or take on the same string \\n        int part = 1 + helper(s, k, idx + 1, idx + 1);  //we have choose to cut new substring here\\n        int notyet = helper(s, k, idx + 1, start); //not yet choosen to cut \\n        return dp[start] = Math.min(part, notyet);\\n    }\\n}\\n```\\n\\n\\n**Greedy :**\\n\\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n\\t\\tint parts = 0;\\n\\t\\tint left = 0;\\n\\t\\tint right = 0;\\n\\t\\twhile (right < s.length()) {\\n\\t\\t\\twhile (right+1 - left < 10 && right < s.length() && Integer.parseInt(s.substring(left, right + 1)) <= k) {\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t}\\n\\t\\t\\tif (left == right) return -1;\\n\\t\\t\\tleft = right;\\n\\t\\t\\tparts++;\\n\\t\\t}\\n\\t\\treturn parts;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    int inf = (int) 1e6;\\n    int dp[];\\n    public int minimumPartition(String s, int k) {\\n        int n = s.length();\\n        dp = new int[n];\\n        Arrays.fill(dp, -1);\\n\\t\\t//since all characters will be between 1-9 \\n\\t\\t//so we have taken 10 length visited array\\n        int ans = helper(s, k, 0, 0);  \\n        return ans >= inf ? -1 : ans;\\n    }\\n\\n    int helper(String s, int k, int idx, int start) {\\n        if (idx == s.length()) return 1;\\n        long num = Long.parseLong(s.substring(start, idx + 1));\\n        if (num > k ) return inf; //if the current value of the substring is > k  it means we have \\n\\t\\t//violated the rule of the question so we will return a big no so that this step will not be taken valid.\\n        if (dp[start] != -1) return dp[start];\\n\\t\\t//so now we have two options either start a new substring or take on the same string \\n        int part = 1 + helper(s, k, idx + 1, idx + 1);  //we have choose to cut new substring here\\n        int notyet = helper(s, k, idx + 1, start); //not yet choosen to cut \\n        return dp[start] = Math.min(part, notyet);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n\\t\\tint parts = 0;\\n\\t\\tint left = 0;\\n\\t\\tint right = 0;\\n\\t\\twhile (right < s.length()) {\\n\\t\\t\\twhile (right+1 - left < 10 && right < s.length() && Integer.parseInt(s.substring(left, right + 1)) <= k) {\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t}\\n\\t\\t\\tif (left == right) return -1;\\n\\t\\t\\tleft = right;\\n\\t\\t\\tparts++;\\n\\t\\t}\\n\\t\\treturn parts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978884,
                "title": "python-3-7-lines-sets-t-m-88-ms-14-8-mb",
                "content": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n\\n        if k < 10: return len(s) if k >= int(max(s)) else -1\\n        \\n        k, ans = str(k), 0\\n        digits = len(k)\\n\\n        while s:\\n            s = s[digits:] if s[:digits] <= k else s[digits-1:]\\n            ans+= 1\\n\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n\\n        if k < 10: return len(s) if k >= int(max(s)) else -1\\n        \\n        k, ans = str(k), 0\\n        digits = len(k)\\n\\n        while s:\\n            s = s[digits:] if s[:digits] <= k else s[digits-1:]\\n            ans+= 1\\n\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2977833,
                "title": "c-short-and-easy-with-greedy",
                "content": "# Approach\\nAlways try to create partitions with maximum length (maximum number of digits of k). \\n\\nIf for the maximum length the value obtained is greater than k, then it is necessary to reduce the length by 1, it will always be less than k.\\n\\n# Complexity\\n- Time complexity: O(n*length)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = to_string(k).length(), res = 0;\\n        for (int i = 0; i < s.length();) {\\n            int used = stoi(s.substr(i, n)) <= k ? n : n - 1;\\n            if (used <= 0) return -1;\\n            res++, i += used;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = to_string(k).length(), res = 0;\\n        for (int i = 0; i < s.length();) {\\n            int used = stoi(s.substr(i, n)) <= k ? n : n - 1;\\n            if (used <= 0) return -1;\\n            res++, i += used;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977382,
                "title": "easy-short-efficient-clean-code",
                "content": "### My solution is based on a greedy approach.\\n### We need to partition the string such that each partition\\'s value is not more than \\'k\\' and the total number of partitions is the minimum possible.\\n### To minimise the number of partitions, we must maximise the size of all the partitions. -->> X\\n### If any character is itself greater than \\'k\\' in value, there does not exist any possible solution.\\n### Thus we iterate from left to right, while keeping track of \\'num\\', the number formed so far (initially 0).\\n### At the current iteration (\\'in\\'), we update \\'num\\'. Now one of the following two steps must be taken:\\n- The number is still less than \\'k\\': Just ignore and continue. no need to partition yet. SEE -->> X\\nO R\\n- The number thus formed exceeds \\'k\\' in its value.\\n  This has occurred at the current iteration \\'in\\'.\\n  But it\\'s safe to say that the number formed till the previous iteration \\'in-1\\' was safe.\\n  And that is exactly what we take into consideration. From the current iteration (including \\'in\\') starts a new number.\\n```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    int minimumPartition(const string&s, int k) {\\n        ll n=s.size(), ans=0, num=0;\\n        for(ll i=0;i<n;++i){\\n            if(s[i]-\\'0\\'>k){\\n                return -1;\\n            }\\n            num=(num*10)+(s[i]-\\'0\\');\\n            if(num>k){\\n                ++ans, num=s[i]-\\'0\\'; // number from prev pos to i-1 was ok, now must start a new num from i\\n            }\\n        }\\n        return 1+ans; // +1 for the remainder in \\'n\\' that was not taken care of due to the end of the loop\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    int minimumPartition(const string&s, int k) {\\n        ll n=s.size(), ans=0, num=0;\\n        for(ll i=0;i<n;++i){\\n            if(s[i]-\\'0\\'>k){\\n                return -1;\\n            }\\n            num=(num*10)+(s[i]-\\'0\\');\\n            if(num>k){\\n                ++ans, num=s[i]-\\'0\\'; // number from prev pos to i-1 was ok, now must start a new num from i\\n            }\\n        }\\n        return 1+ans; // +1 for the remainder in \\'n\\' that was not taken care of due to the end of the loop\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991131,
                "title": "c-simple-logic-comments-added-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) \\n    {\\n        int cnt=0;\\n        long long num=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit = s[i]-\\'0\\';\\n            if(digit > k) return -1;                   // if any time our single digit goes bigger then k return -1, there will no partition possible\\n            \\n            num = num*10 + digit;                      // each time compute num\\n            \\n            // if our computed num goes bigger then count it as a partition\\n            if(num>k)\\n            {\\n                cnt++;\\n                num = digit;                        // assign curr digit to num for next calls\\n             }\\n            \\n        }\\n        \\n        // if num is still less than k, then count it as a substring\\n        if(num<=k) cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) \\n    {\\n        int cnt=0;\\n        long long num=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit = s[i]-\\'0\\';\\n            if(digit > k) return -1;                   // if any time our single digit goes bigger then k return -1, there will no partition possible\\n            \\n            num = num*10 + digit;                      // each time compute num\\n            \\n            // if our computed num goes bigger then count it as a partition\\n            if(num>k)\\n            {\\n                cnt++;\\n                num = digit;                        // assign curr digit to num for next calls\\n             }\\n            \\n        }\\n        \\n        // if num is still less than k, then count it as a substring\\n        if(num<=k) cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977771,
                "title": "c-used-stol-shortest-and-simpler-solution-fully-explained-o-n-time-o-1-space",
                "content": "# Idea\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- See its a variable sliding window based problem\\n- ALGORITHMIC IDEA IS GREEDY\\n- i start pos \\n- j end pos\\n- Do j++ till the substr[i...j] is <= k\\n- Once it exceeds k, cut and make a paritition just by i=j\\n- Also increment the counter\\n- i=j means next substr start is prev end +1, how end+1 bcoz j first fail point\\n- Eg:\\n- 165462 k = 60\\n- 16|54|6|2 - 4 paritions\\n- 1, 16, 165 fails here i =0 j=2\\n- new i = 2, so starts from 5\\n- 5, 54, 546 fails\\n- This way we can get it\\n- parition is initialized with 1 bcoz we have atlesat the whole string with 0 cuts as 1 partition.\\n\\n### NOTE: Why Stol () why not stoi()\\n- Stoi() gave me out of range error.\\n- So go to long type version of same stol\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int N = s.size();\\n        \\n        int par = 1;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        \\n        while(j<N){\\n            string ss = s.substr(i, j-i+1);\\n            if(ss.size() == 1){\\n                long long val = stol(ss);\\n                if(val > k) return -1;\\n            } \\n            long long v = stol(ss);\\n            if(v <= k){\\n                j++;\\n            }\\n            else{\\n                par++;\\n                i = j;\\n            }\\n        }\\n        \\n        \\n        return par;\\n    }\\n};\\n```\\n### Upvote if u feel worth it and u understood the solution and found it insightful and unique. :) Helps me a lot to stay motivated & to post more.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int N = s.size();\\n        \\n        int par = 1;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        \\n        while(j<N){\\n            string ss = s.substr(i, j-i+1);\\n            if(ss.size() == 1){\\n                long long val = stol(ss);\\n                if(val > k) return -1;\\n            } \\n            long long v = stol(ss);\\n            if(v <= k){\\n                j++;\\n            }\\n            else{\\n                par++;\\n                i = j;\\n            }\\n        }\\n        \\n        \\n        return par;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977430,
                "title": "c-o-n-easy-to-understand",
                "content": "\\n#Keep constructing the number from **left to right**\\n#for some index if (constructed number > k), then=>\\n1. make a partition till previous index\\n1. if the [(number constructed till previous index) <= k] then  (ans++),\\n1. reset the constructed number\\n\\n//==================================================================================================\\n#For constructing the number from left to right\\n\"1567\"\\n\\n#int num = 0;\\n#idx = 0, (num * 10) + currDig => (0 * 10) + 1 => (0) + 1 => 1\\n#idx = 1, (num * 10) + currDig => (1 * 10) + 5 => (10 + 5) => 15\\n#idx = 2, (num * 10) + currDig => (15 * 10) + 6 => (150 + 6) => 156\\n#idx = 3, (num * 10) + currDig => (156 * 10) + 7 => (1560 + 7) => 1567\\n\\n//=============================================================================================================\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) \\n    {\\n        int n = s.size();\\n        long long currNum = 0;\\n        long long prevNum = -1;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            currNum = (currNum * 10) + (s[i] - \\'0\\');\\n            //=======================================================\\n            if (currNum <= k) continue;\\n            else if (currNum > k)\\n            {\\n                if (prevNum > k) return -1;\\n                ans++;\\n                currNum = (s[i] - \\'0\\');\\n            }  \\n            prevNum = currNum;\\n            //========================================================\\n        }\\n        if (prevNum > k) return -1;\\n        return (ans + 1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) \\n    {\\n        int n = s.size();\\n        long long currNum = 0;\\n        long long prevNum = -1;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            currNum = (currNum * 10) + (s[i] - \\'0\\');\\n            //=======================================================\\n            if (currNum <= k) continue;\\n            else if (currNum > k)\\n            {\\n                if (prevNum > k) return -1;\\n                ans++;\\n                currNum = (s[i] - \\'0\\');\\n            }  \\n            prevNum = currNum;\\n            //========================================================\\n        }\\n        if (prevNum > k) return -1;\\n        return (ans + 1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977426,
                "title": "easy-java-solution-sliding-window-greedy-beats-100-time-and-space",
                "content": "*We greedily choose the partitions through a sliding window*. We try to maximise the integer formed in the window going right, such that the integer formed is always less than k.\\n\\n**Point to note here** : We can partition the string to a maximum of string length - 1 times, such that each partition consist of a single digit. Thus the possibility of our window value being > k is only if k is a single digit integer ie, k<10.\\n\\nThus if at any point of time, the window value becomes>k, we check if the last digit in window is >k. If yes, we return -1 else begin a new sliding window from the last digit.\\n\\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int left = 0, right = 1, len = s.length(), count = 0;\\n        for(right=1;right<=len;right++){\\n\\t\\t//Max value of k is 10^9, thus we check if window size is greater than 9, its value \\n\\t\\t//will be surely greater than k as only digits from 1-9 are allowed.\\n            if(right-left>9 || Integer.parseInt(s.substring(left, right))>k){\\n                if(Integer.parseInt(s.substring(right-1, right))>k) return -1;\\n                else{\\n                    left = right-1; count++;\\n                }\\n            }\\n        }\\n        if(left<right) count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int left = 0, right = 1, len = s.length(), count = 0;\\n        for(right=1;right<=len;right++){\\n\\t\\t//Max value of k is 10^9, thus we check if window size is greater than 9, its value \\n\\t\\t//will be surely greater than k as only digits from 1-9 are allowed.\\n            if(right-left>9 || Integer.parseInt(s.substring(left, right))>k){\\n                if(Integer.parseInt(s.substring(right-1, right))>k) return -1;\\n                else{\\n                    left = right-1; count++;\\n                }\\n            }\\n        }\\n        if(left<right) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977243,
                "title": "c-explanation-concise",
                "content": "\\n**Happy New Year !!!**\\n\\n* **Approach** - \\n    1. only add one by one digit still `val > k` then remove last one digit and add that, this process going on i == n \\n* Time Complexity - O(N)\\n* Space Complexity - O(1)\\n    \\n**REQUEST** :\\xA0If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.\\n    \\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        for(int i = 0; i < n; i++) if(s[i] - \\'0\\' > k) return -1; \\n        \\n        int i = 0, ans = 0;\\n        while(i < n) {\\n            int j = i;\\n            while(j < n) {  // add one by one digit still val > k\\n                long int val = stol(s.substr(i, j - i + 1));\\n                if(j == n - 1 && val <= k) ans++; // this is for check val <= k so, add it into ans\\n                \\n                j++;\\n                if(val > k) {\\n                    ans++, j--;\\n                    break;\\n                }\\n            }\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        for(int i = 0; i < n; i++) if(s[i] - \\'0\\' > k) return -1; \\n        \\n        int i = 0, ans = 0;\\n        while(i < n) {\\n            int j = i;\\n            while(j < n) {  // add one by one digit still val > k\\n                long int val = stol(s.substr(i, j - i + 1));\\n                if(j == n - 1 && val <= k) ans++; // this is for check val <= k so, add it into ans\\n                \\n                j++;\\n                if(val > k) {\\n                    ans++, j--;\\n                    break;\\n                }\\n            }\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988118,
                "title": "c-6-line-code-beats-100-submissions",
                "content": "For more solution go through git repo\\nhttps://github.com/Funik69/Leetcode_Solution\\nhttps://github.com/Funik69/Leetcode-Algorithm-StudyPlan-\\nhttps://github.com/Funik69/LeetCode-75---Study-Plan\\nhttps://github.com/Funik69/Programming-Skills-1\\n# Code\\nupvote if you found it useful\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int cnt=0; string str=\"\";\\n       for(auto i:s){\\n           if(i-\\'0\\'>k)return -1;\\n           str+=i;\\n           if((long)stoll(str,nullptr,10)>k){ str=i; cnt++;} }\\n    return cnt+1;}\\n};\\n\\n```\\n![Screenshot_20230102_232045.png](https://assets.leetcode.com/users/images/1a9712e8-c2c2-47c5-875e-945acd444c22_1672682117.8275995.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int cnt=0; string str=\"\";\\n       for(auto i:s){\\n           if(i-\\'0\\'>k)return -1;\\n           str+=i;\\n           if((long)stoll(str,nullptr,10)>k){ str=i; cnt++;} }\\n    return cnt+1;}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977250,
                "title": "python3-greedy-o-n-solution-clean-concise",
                "content": "# Approach\\nWe scan all digits in `s` from left to right, and add 1 to `ans` whenever the current value of the segment exceeds `k`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curr, ans = 0, 1\\n        for d in s:\\n            if int(d) > k:\\n                return -1\\n            curr = 10 * curr + int(d)\\n            if curr > k:\\n                ans += 1\\n                curr = int(d)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curr, ans = 0, 1\\n        for d in s:\\n            if int(d) > k:\\n                return -1\\n            curr = 10 * curr + int(d)\\n            if curr > k:\\n                ans += 1\\n                curr = int(d)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832605,
                "title": "c-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int s,int &n,string &str,int k,vector<int> &dp){\\n        if(s >= n){\\n            return 0;\\n        }\\n        if(dp[s] != -1)return dp[s];\\n        long long int x = 0;\\n        int ans = n-s;\\n        for(int i = s; i < n; i++){\\n            x = x*10+str[i]-\\'0\\';\\n            if(x > k*1LL){\\n                break;\\n            }\\n            ans = min(ans,1+solve(i+1,n,str,k,dp));\\n        }\\n        return dp[s] = ans;\\n    }\\n    int minimumPartition(string s, int k) {\\n        for(auto &i: s){\\n            if(i-\\'0\\' > k)return -1;\\n        }\\n        int n = s.length();\\n        vector<int> dp(n,-1);\\n        int ans = solve(0,n,s,k,dp);\\n        for(auto &i: dp)cout<<i<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int s,int &n,string &str,int k,vector<int> &dp){\\n        if(s >= n){\\n            return 0;\\n        }\\n        if(dp[s] != -1)return dp[s];\\n        long long int x = 0;\\n        int ans = n-s;\\n        for(int i = s; i < n; i++){\\n            x = x*10+str[i]-\\'0\\';\\n            if(x > k*1LL){\\n                break;\\n            }\\n            ans = min(ans,1+solve(i+1,n,str,k,dp));\\n        }\\n        return dp[s] = ans;\\n    }\\n    int minimumPartition(string s, int k) {\\n        for(auto &i: s){\\n            if(i-\\'0\\' > k)return -1;\\n        }\\n        int n = s.length();\\n        vector<int> dp(n,-1);\\n        int ans = solve(0,n,s,k,dp);\\n        for(auto &i: dp)cout<<i<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2992580,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        string p;\\n        //\"1\" k=3\\n        long long ans=0;\\n        for(char c:s)\\n        {\\n            p+=c;\\n            long long n=0;\\n            n=stoll(p);\\n            if(n>k)\\n            {\\n                if(p.size()==1)\\n                    return -1;\\n                ans++;\\n                p=\"\";\\n                p+=c;\\n                if(stoll(p)>k)\\n                    return -1;\\n            }\\n        }\\n            if(p.size()>0)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        string p;\\n        //\"1\" k=3\\n        long long ans=0;\\n        for(char c:s)\\n        {\\n            p+=c;\\n            long long n=0;\\n            n=stoll(p);\\n            if(n>k)\\n            {\\n                if(p.size()==1)\\n                    return -1;\\n                ans++;\\n                p=\"\";\\n                p+=c;\\n                if(stoll(p)>k)\\n                    return -1;\\n            }\\n        }\\n            if(p.size()>0)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983902,
                "title": "c-greedy-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long curnum=0, cnt=1;\\n        for(int i=0;i<s.size();i++){\\n            curnum= curnum*10 + (s[i]-\\'0\\');\\n            if(curnum>k){\\n                cnt++;\\n                curnum= s[i]-\\'0\\';\\n            }\\n            if(curnum>k)return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long curnum=0, cnt=1;\\n        for(int i=0;i<s.size();i++){\\n            curnum= curnum*10 + (s[i]-\\'0\\');\\n            if(curnum>k){\\n                cnt++;\\n                curnum= s[i]-\\'0\\';\\n            }\\n            if(curnum>k)return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981317,
                "title": "simple-java-solution",
                "content": "# Approach \\nUsing sliding window concept the digits are checked\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int c=0;\\n        for(int i=0;i<s.length();)\\n        {\\n            System.out.println(i+\" \"+i);\\n            StringBuilder nm=new StringBuilder();\\n            nm.append(s.charAt(i));\\n            if(nm.length()==1)\\n            {\\n                if(nm.charAt(0)-\\'0\\'>k)\\n                {\\n                    return -1;\\n                }\\n                else\\n                {\\n                    c++;\\n                    i++;\\n                    if(i>=s.length())\\n                    {\\n                        break;\\n                    }\\n                    nm.append(s.charAt(i));\\n                    while(Long.parseLong(nm.toString())<=k)\\n                    {\\n                        i++;\\n                        if(i>=s.length())\\n                        {\\n                            break;\\n                        }\\n                        nm.append(s.charAt(i));\\n                        System.out.println(nm);\\n                    }\\n                    if(i>=s.length())\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int c=0;\\n        for(int i=0;i<s.length();)\\n        {\\n            System.out.println(i+\" \"+i);\\n            StringBuilder nm=new StringBuilder();\\n            nm.append(s.charAt(i));\\n            if(nm.length()==1)\\n            {\\n                if(nm.charAt(0)-\\'0\\'>k)\\n                {\\n                    return -1;\\n                }\\n                else\\n                {\\n                    c++;\\n                    i++;\\n                    if(i>=s.length())\\n                    {\\n                        break;\\n                    }\\n                    nm.append(s.charAt(i));\\n                    while(Long.parseLong(nm.toString())<=k)\\n                    {\\n                        i++;\\n                        if(i>=s.length())\\n                        {\\n                            break;\\n                        }\\n                        nm.append(s.charAt(i));\\n                        System.out.println(nm);\\n                    }\\n                    if(i>=s.length())\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980431,
                "title": "super-efficient-java-easy-to-understand-explanation-3",
                "content": "# Intuition\\nAt first, this seemed to me like a backtracking problem (as if we want to find a short path in a 2-min array), but after giving it a second thought it turned out to be a more specific problem type, a greedy algorithm as if we want to fill many objects in as few bags as possible, intuitively you would grab one bag and then try to fill the bag at hand as much as possible before grabbing the next empty bag, and since we only want to know the number of the bags that we need we can actually clean the bag at hand instead of actually grabbing a new one (no one will know, trust me!)\\n# Approach\\nI basically implemented the intuition above\\n- we loop and convert each digit to an int using the old and efficient way (since s is guaranteed to contain only digits)\\n- we give up if we have a digit that is too big to fit in any bag\\n- we fill our bag with the current digit\\n- if adding the current digit caused the bag to overflow we count it as a full bag and clear all bag contents except for the current digit which will be included in the next bag\\n- at the end, we also count our partially filled bag at hand (it can\\'t be empty because the min length of s is 1 and we only reset when you have at least one extra digit that won\\'t fit in our bag)\\n# Complexity\\n- Time complexity: this code has a time complexity of O(n), where n is the length of the input string s. This is because the for loop iterates through each character in the input string s once, and the rest of the operations inside the loop have a constant time complexity. This means that the time taken by the algorithm grows linearly with the size of the input.\\n- Space complexity: the space complexity of this code is O(1), because the variables used to store intermediate values have a constant size regardless of the size of the input. This means that the amount of memory used by the algorithm does not depend on the size of the input, and is considered to be constant.\\n# Code\\n```\\nclass Solution {\\n    public int minimumPartition(final String s, final int k) {\\n        int usedBags = 0;\\n        long bag = 0;\\n        for (int index = 0; index < s.length(); index++) {\\n            int digit = s.charAt(index) - 48;\\n            if (digit > k) return -1;\\n\\n            bag = bag * 10 + digit;\\n            if (bag > k) {\\n                bag = digit;\\n                usedBags++;\\n            }\\n        }\\n        return ++usedBags;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(final String s, final int k) {\\n        int usedBags = 0;\\n        long bag = 0;\\n        for (int index = 0; index < s.length(); index++) {\\n            int digit = s.charAt(index) - 48;\\n            if (digit > k) return -1;\\n\\n            bag = bag * 10 + digit;\\n            if (bag > k) {\\n                bag = digit;\\n                usedBags++;\\n            }\\n        }\\n        return ++usedBags;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977642,
                "title": "1d-dp-c",
                "content": "ok so apparently greedy works but here\\'s my 1D DP code is anyone is curious.\\n\\n# Approach\\n* At every step, we try to find a substring starting from left index that is lesser than k\\n* Now if k is 789 and the string is 123490 and l=0 i.e. we are at the leftmost position then we can take 1,12,123 (if we take 12 then l becomes 2)..so we try all possible ways and take the minimum\\n* We break if the length of substring is greater than 9 because k<=1e9 so we need to search for at most 9 digit number\\n* If we already know the minimum number of partition for a particular [l,r] we do not need to calculate that again,right? so use dp to store those values\\n* But notice that r remains constant so we can omit that and create a single dp array for l only\\n# Time Complexity\\nO(N)\\n\\n# Code\\n```\\nclass Solution {  \\n    int part(string &s,int l,int &r,int &k,vector<int> &dp){\\n        if(l==r)return 0;\\n        if(dp[l]!=-1)return dp[l];\\n        int total=1e8;\\n        for(int i=l;i<r;i++){\\n            if (i-l+1 > 9)  break;\\n            if(stoi(s.substr(l,i-l+1))<=k)\\n                total=min(total,1+part(s,i+1,r,k,dp));\\n        }\\n        return dp[l]=total;\\n    }\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n=s.length();\\n        vector <int> dp(n,-1);\\n        int ans=(part(s,0,n,k,dp)>=1e8)?-1:part(s,0,n,k,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {  \\n    int part(string &s,int l,int &r,int &k,vector<int> &dp){\\n        if(l==r)return 0;\\n        if(dp[l]!=-1)return dp[l];\\n        int total=1e8;\\n        for(int i=l;i<r;i++){\\n            if (i-l+1 > 9)  break;\\n            if(stoi(s.substr(l,i-l+1))<=k)\\n                total=min(total,1+part(s,i+1,r,k,dp));\\n        }\\n        return dp[l]=total;\\n    }\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n=s.length();\\n        vector <int> dp(n,-1);\\n        int ans=(part(s,0,n,k,dp)>=1e8)?-1:part(s,0,n,k,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408418,
                "title": "c-greedy-easy-to-understand-short-sweet-90-faster",
                "content": "````\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        if(k<=9){//CHECK FOR SINGLE DIGIT NUMBER\\n            for(auto &i: s){\\n                if(i-\\'0\\'>k){//IF INT i > K return -1. means there is no substring less & equal to k\\n                    return -1;\\n                }\\n            }\\n            return s.length();\\n        }\\n        long long int x = 0, ans = 1;//x = substring, ans = no of possible substring\\n        for(auto &i: s){\\n            x = x*1LL*10+(i-\\'0\\');\\n            if(x>k){//if substring  > k increment ans and new substring is char i\\n                ans++;\\n                x = (i-\\'0\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Iterator"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        if(k<=9){//CHECK FOR SINGLE DIGIT NUMBER\\n            for(auto &i: s){\\n                if(i-\\'0\\'>k){//IF INT i > K return -1. means there is no substring less & equal to k\\n                    return -1;\\n                }\\n            }\\n            return s.length();\\n        }\\n        long long int x = 0, ans = 1;//x = substring, ans = no of possible substring\\n        for(auto &i: s){\\n            x = x*1LL*10+(i-\\'0\\');\\n            if(x>k){//if substring  > k increment ans and new substring is char i\\n                ans++;\\n                x = (i-\\'0\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987178,
                "title": "easiest-solution-in-c-9ms-sliding-window",
                "content": "### **Logic**\\n```\\nExample : s = \"165462\", k = 60\\n\\n-> Here we are given value k = 60. The length of k is 2,\\n   which means we atmost select 2 digits from s.\\n-> We are using sliding window for it.\\n-> here it is 16 <= 60. Means we consider \"16\" as a partition.\\n-> same as for \"54\".\\n-> for \"62\" it is greater than 60 (k), so the partition will be of length(k)-1.\\n\\tso here \"6\" will be partitioned.\\n\\tnow we only have \"2\" which is less than 60 so it will be partitioned.\\n\\t\\n-> there is one edge case : suppose k is a single digit, but the digit given in s is higer than k,\\n\\tthen there is no chance we can do partition so we return -1.\\n\\t\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) \\n    {\\n        int curr = 0; // current pointer indicating the digit from which we should start\\n        int len = s.length();\\n        int sw = to_string(k).length(); // sliding window (atmost this length of digit we can consider)\\n        int count = 0; // counter of partition\\n\\t\\t\\n\\t\\t//edge case\\n        if(sw==1)\\n        {\\n            for(auto i:s)\\n            {\\n                if(i-\\'0\\'>k)return -1;\\n            }\\n        }\\n        while(curr<len)\\n        {\\n            int val = stoi(s.substr(curr,sw));\\n            if(val<=k)\\n            {\\n                count++;\\n                curr+=sw;\\n            }\\n            else\\n            {\\n                count++;\\n                curr+=sw-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nExample : s = \"165462\", k = 60\\n\\n-> Here we are given value k = 60. The length of k is 2,\\n   which means we atmost select 2 digits from s.\\n-> We are using sliding window for it.\\n-> here it is 16 <= 60. Means we consider \"16\" as a partition.\\n-> same as for \"54\".\\n-> for \"62\" it is greater than 60 (k), so the partition will be of length(k)-1.\\n\\tso here \"6\" will be partitioned.\\n\\tnow we only have \"2\" which is less than 60 so it will be partitioned.\\n\\t\\n-> there is one edge case : suppose k is a single digit, but the digit given in s is higer than k,\\n\\tthen there is no chance we can do partition so we return -1.\\n\\t\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) \\n    {\\n        int curr = 0; // current pointer indicating the digit from which we should start\\n        int len = s.length();\\n        int sw = to_string(k).length(); // sliding window (atmost this length of digit we can consider)\\n        int count = 0; // counter of partition\\n\\t\\t\\n\\t\\t//edge case\\n        if(sw==1)\\n        {\\n            for(auto i:s)\\n            {\\n                if(i-\\'0\\'>k)return -1;\\n            }\\n        }\\n        while(curr<len)\\n        {\\n            int val = stoi(s.substr(curr,sw));\\n            if(val<=k)\\n            {\\n                count++;\\n                curr+=sw;\\n            }\\n            else\\n            {\\n                count++;\\n                curr+=sw-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985314,
                "title": "c-fast-solution-string-100-time-100-space",
                "content": "**Do Upvote if the solution helps you. Thank you.**\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n      int l = 0, r = 0, ans = 0, n = s.size(), curr = 0;\\n      int lenk = 0;\\n      int temp = k;\\n      while(temp){\\n        temp /= 10;\\n        lenk++;\\n      }\\n      if(lenk == 1){\\n        for(char &i: s){\\n          if(i - \\'0\\' > k) return -1;\\n        }\\n        return n;\\n      }\\n      for(int i = 0; i < n; i++){\\n        string t = \"\", g =  to_string(k);\\n        int curr = 0;\\n        while(i < n and t.size() < g.size() and curr < k){\\n          curr = curr * 10 + s[i] - \\'0\\';\\n          t += s[i];\\n          i++;\\n        } \\n        if(curr > k) i--;\\n        ans++; i--;\\n      }\\n      return ans > 0 ? ans : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n      int l = 0, r = 0, ans = 0, n = s.size(), curr = 0;\\n      int lenk = 0;\\n      int temp = k;\\n      while(temp){\\n        temp /= 10;\\n        lenk++;\\n      }\\n      if(lenk == 1){\\n        for(char &i: s){\\n          if(i - \\'0\\' > k) return -1;\\n        }\\n        return n;\\n      }\\n      for(int i = 0; i < n; i++){\\n        string t = \"\", g =  to_string(k);\\n        int curr = 0;\\n        while(i < n and t.size() < g.size() and curr < k){\\n          curr = curr * 10 + s[i] - \\'0\\';\\n          t += s[i];\\n          i++;\\n        } \\n        if(curr > k) i--;\\n        ans++; i--;\\n      }\\n      return ans > 0 ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978327,
                "title": "c-1d-dp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int num) {\\n        int n = s.size();\\n        vector<int> dp(n+1,n+1); dp[n] = 0;\\n        for(int i = n-1;i>=0;i--){\\n            long long k = 0;\\n            for(int j = i;j<n;++j){  // this loop run At max length of num\\n                k=k*10+s[j]-\\'0\\';\\n                if(k>num) break;\\n                else dp[i] = min(dp[i],1+dp[j+1]);\\n            }\\n        }\\n        if(dp[0]==n+1) return -1;\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int num) {\\n        int n = s.size();\\n        vector<int> dp(n+1,n+1); dp[n] = 0;\\n        for(int i = n-1;i>=0;i--){\\n            long long k = 0;\\n            for(int j = i;j<n;++j){  // this loop run At max length of num\\n                k=k*10+s[j]-\\'0\\';\\n                if(k>num) break;\\n                else dp[i] = min(dp[i],1+dp[j+1]);\\n            }\\n        }\\n        if(dp[0]==n+1) return -1;\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978095,
                "title": "beats-100-explanation-o-n-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        # Initialize a temporary string to store the current substring\\n        tmp = \\'\\'\\n        \\n        # Initialize a counter for the number of substrings\\n        cnt = 0\\n        \\n        # Iterate through the characters in the string s\\n        for c in s:\\n            # Add the current character to the temporary string\\n            tmp += c\\n            \\n            # If the value of the temporary string is greater than k, reset the temporary string to the current character\\n            # and increment the counter for the number of substrings\\n            if int(tmp) > k:\\n                tmp = c\\n                \\n                # If the value of the temporary string is still greater than k, return -1\\n                if int(tmp) > k:\\n                    return -1\\n                    \\n                cnt += 1\\n        \\n        # Return the count of substrings plus one for the final substring\\n        return cnt + 1\\n\\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        # Initialize a temporary string to store the current substring\\n        tmp = \\'\\'\\n        \\n        # Initialize a counter for the number of substrings\\n        cnt = 0\\n        \\n        # Iterate through the characters in the string s\\n        for c in s:\\n            # Add the current character to the temporary string\\n            tmp += c\\n            \\n            # If the value of the temporary string is greater than k, reset the temporary string to the current character\\n            # and increment the counter for the number of substrings\\n            if int(tmp) > k:\\n                tmp = c\\n                \\n                # If the value of the temporary string is still greater than k, return -1\\n                if int(tmp) > k:\\n                    return -1\\n                    \\n                cnt += 1\\n        \\n        # Return the count of substrings plus one for the final substring\\n        return cnt + 1\\n\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977569,
                "title": "easy-solution-in-o-n-time-with-proper-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Approch is to calculate the sum of digits continuously and if sum exceeds the value of k then me make a partition and again start calculating sum and make partitions.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the lenght of the string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        chk=0 \\n        partition=1\\n        for i in range(len(s)):\\n            chk = chk * 10 + ord(s[i])-ord(\\'0\\')  #adding the new digit to the chk\\n            if chk > k:  # if chk is greater than k than we have to make a partition \\n                chk = ord(s[i])-ord(\\'0\\')  # making new chk for next iteration \\n                if chk>k:  \\n                    return -1\\n                partition+=1  # counting the partition\\n            \\n        return partition  \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        chk=0 \\n        partition=1\\n        for i in range(len(s)):\\n            chk = chk * 10 + ord(s[i])-ord(\\'0\\')  #adding the new digit to the chk\\n            if chk > k:  # if chk is greater than k than we have to make a partition \\n                chk = ord(s[i])-ord(\\'0\\')  # making new chk for next iteration \\n                if chk>k:  \\n                    return -1\\n                partition+=1  # counting the partition\\n            \\n        return partition  \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977365,
                "title": "very-readable-c-solution",
                "content": "```\\nint minimumPartition(string s, int k) {\\n        long long int currNum=0;\\n        int count=0;\\n        int i=0,j=0;\\n        while(j<s.size())\\n        {\\n            currNum=currNum * 10 + s[j]-\\'0\\';\\n            if(currNum > k)\\n            {\\n                count++;\\n                currNum=s[j]-\\'0\\';\\n                if(currNum > k)\\n                    return -1;\\n            }            \\n            j++;\\n        }\\n        if(currNum != 0)\\n            count++;\\n        return count == 0 ? -1 : count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimumPartition(string s, int k) {\\n        long long int currNum=0;\\n        int count=0;\\n        int i=0,j=0;\\n        while(j<s.size())\\n        {\\n            currNum=currNum * 10 + s[j]-\\'0\\';\\n            if(currNum > k)\\n            {\\n                count++;\\n                currNum=s[j]-\\'0\\';\\n                if(currNum > k)\\n                    return -1;\\n            }            \\n            j++;\\n        }\\n        if(currNum != 0)\\n            count++;\\n        return count == 0 ? -1 : count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830018,
                "title": "easiest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]-\\'0\\'>k)\\n            return -1;\\n        }\\n        int ans=1;\\n      long long  int res=0;\\n        for(int i=0;i<s.size();i++){\\n            res=res*10+(s[i]-\\'0\\');\\n            if(res>k)\\n            {\\n                ans++;\\n                res=s[i]-\\'0\\';\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]-\\'0\\'>k)\\n            return -1;\\n        }\\n        int ans=1;\\n      long long  int res=0;\\n        for(int i=0;i<s.size();i++){\\n            res=res*10+(s[i]-\\'0\\');\\n            if(res>k)\\n            {\\n                ans++;\\n                res=s[i]-\\'0\\';\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786376,
                "title": "c-easy-solution-o-n-greedy-approach-0ms",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int start = 0, ans = 0;\\n        long long int curr_n = 0;\\n        while (start < s.length()) {\\n            int i = start;\\n            while (i < s.length()) {\\n                curr_n = curr_n*10 + (s[i] - \\'0\\');\\n                if (curr_n <= k) \\n                    i += 1;\\n                else\\n                    break;\\n            }\\n            if (i == start) return -1;\\n            ans++;\\n            start = i;\\n            curr_n = 0;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int start = 0, ans = 0;\\n        long long int curr_n = 0;\\n        while (start < s.length()) {\\n            int i = start;\\n            while (i < s.length()) {\\n                curr_n = curr_n*10 + (s[i] - \\'0\\');\\n                if (curr_n <= k) \\n                    i += 1;\\n                else\\n                    break;\\n            }\\n            if (i == start) return -1;\\n            ans++;\\n            start = i;\\n            curr_n = 0;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604105,
                "title": "greedy-shortest-3-lines-c-solution-explanation",
                "content": "# Greedy | Shortest 3 Lines C++ Solution\\n\"  *Just Like we break in kadane\\'s when gets -ve we break here when gets greater than K. \\nAnother Corner case is when its impossible to split : Any digit in S is greate than K* \"\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k,  long long Ans = 1 ,long long CurrValue = 0 ,long long NotPossible = 0) {\\n        for(auto i:s)\\n        NotPossible = (NotPossible || ((i-\\'0\\')>k)), CurrValue = 10*CurrValue + (i-\\'0\\'), Ans+= CurrValue>k , CurrValue = CurrValue>k?(i-\\'0\\'):CurrValue;\\n        return NotPossible?-1:Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k,  long long Ans = 1 ,long long CurrValue = 0 ,long long NotPossible = 0) {\\n        for(auto i:s)\\n        NotPossible = (NotPossible || ((i-\\'0\\')>k)), CurrValue = 10*CurrValue + (i-\\'0\\'), Ans+= CurrValue>k , CurrValue = CurrValue>k?(i-\\'0\\'):CurrValue;\\n        return NotPossible?-1:Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478446,
                "title": "o-n-simple-intuitive-approach-c",
                "content": "\\n# Complexity\\n- Time complexity: O(N) where N is the length of the string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n=s.size();\\n        long long num=0,cnt=0;\\n        for(int i=0;i<n;i++){\\n            num=(s[i]-\\'0\\'); // initializing the variable num as s[i]\\n            if(num>k) return -1; // if the num is greater than k then we simply return -1\\n            // if the num variable is not less than k then we check for the next index of the current index. If it satisfies then we increment i else we break out from the loop.\\n            while((i+1)<n){\\n                num=num*10+(s[i+1]-\\'0\\');\\n                if(num>k) break;\\n                i++;\\n            }\\n            cnt++;// we will get our first substring so increment the value of cnt\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n=s.size();\\n        long long num=0,cnt=0;\\n        for(int i=0;i<n;i++){\\n            num=(s[i]-\\'0\\'); // initializing the variable num as s[i]\\n            if(num>k) return -1; // if the num is greater than k then we simply return -1\\n            // if the num variable is not less than k then we check for the next index of the current index. If it satisfies then we increment i else we break out from the loop.\\n            while((i+1)<n){\\n                num=num*10+(s[i+1]-\\'0\\');\\n                if(num>k) break;\\n                i++;\\n            }\\n            cnt++;// we will get our first substring so increment the value of cnt\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388469,
                "title": "sliding-window",
                "content": "# Approach:-Read only approach and try by yourself first\\nevery time we are just checking is the number made by current window is less then given number then we just add that number to that window and do for remaning numbers present in string.\\nEdge case:- \"888\" ,k=1\\nin this even if we take single integer still we can\\'t make a number less then k so return -1 in this case.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        \\n        int i=0,j=0;\\n        int n=s.size();\\n\\n        int cnt=0;\\n\\n        long long v=0;\\n\\n        while(j<n)\\n        {\\n            if(v*10+(s[j]-\\'0\\')<=k)\\n            {\\n                v=v*10+(s[j]-\\'0\\');\\n            }\\n            else\\n            {\\n                cnt++;\\n                v=s[j]-\\'0\\';\\n                if(v>k)return -1;\\n            }\\n\\n            j++;\\n\\n        }\\n        if(v<=k)cnt++;\\n\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        \\n        int i=0,j=0;\\n        int n=s.size();\\n\\n        int cnt=0;\\n\\n        long long v=0;\\n\\n        while(j<n)\\n        {\\n            if(v*10+(s[j]-\\'0\\')<=k)\\n            {\\n                v=v*10+(s[j]-\\'0\\');\\n            }\\n            else\\n            {\\n                cnt++;\\n                v=s[j]-\\'0\\';\\n                if(v>k)return -1;\\n            }\\n\\n            j++;\\n\\n        }\\n        if(v<=k)cnt++;\\n\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021876,
                "title": "c-solution-easy-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        string str;\\n        int ans = 1, n = s.size();\\n        for(int j=0; j<n; j++){\\n            if(s[j]-\\'0\\' > k) return -1;\\n            str += s[j];\\n            if(stol(str) > k) str = s[j], ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        string str;\\n        int ans = 1, n = s.size();\\n        for(int j=0; j<n; j++){\\n            if(s[j]-\\'0\\' > k) return -1;\\n            str += s[j];\\n            if(stol(str) > k) str = s[j], ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997269,
                "title": "two-pointers-explanation",
                "content": "# Intuition\\n\\n1. Calculate the length of number `k` - > `l`\\n2. Go though `s` from end to start\\n    a. `k` can be bigger then a number with the same length and 100% bigger then a number with `l-1` length\\n    b. Convert last `l` symbols to number and compare to `k`\\n    c. `l-1` can be equal to `0` which means no good partition\\n    d. Select the next last `l` symbols\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        n = len(s)\\n        l = self.getIntLen(k)\\n        if l > n:\\n            return -1\\n        result = 0\\n        j = n\\n        i = n - l\\n        while i >= 0 and j > 0:\\n            if int(s[i:j]) <= k:\\n                result += 1\\n                i -= l\\n                j -= l\\n            elif j - i - 1 > 0:\\n                result += 1\\n                i -= l - 1\\n                j -= l - 1\\n            else:\\n                return -1\\n            i = max(i, 0)\\n        return result\\n\\n    def getIntLen(self, n: int):\\n        result = 0\\n        while n > 0:\\n            n //= 10\\n            result += 1\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        n = len(s)\\n        l = self.getIntLen(k)\\n        if l > n:\\n            return -1\\n        result = 0\\n        j = n\\n        i = n - l\\n        while i >= 0 and j > 0:\\n            if int(s[i:j]) <= k:\\n                result += 1\\n                i -= l\\n                j -= l\\n            elif j - i - 1 > 0:\\n                result += 1\\n                i -= l - 1\\n                j -= l - 1\\n            else:\\n                return -1\\n            i = max(i, 0)\\n        return result\\n\\n    def getIntLen(self, n: int):\\n        result = 0\\n        while n > 0:\\n            n //= 10\\n            result += 1\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993328,
                "title": "c-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTake until exceeding `k`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuild `n` until `n > k` with `n = n*10 + s[i]`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int answer = 0;\\n        size_t len = s.size();\\n        uint64_t n = 0;\\n        for (size_t i = 0; i < len; i++) {\\n            if (s[i] - \\'0\\' > k) {\\n                return -1;\\n            }\\n            n *= 10;\\n            n += s[i] - \\'0\\';\\n            if (n > k) {\\n                answer++;\\n                n = s[i] - \\'0\\';\\n            }\\n        }\\n        if (n) {\\n            answer++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int answer = 0;\\n        size_t len = s.size();\\n        uint64_t n = 0;\\n        for (size_t i = 0; i < len; i++) {\\n            if (s[i] - \\'0\\' > k) {\\n                return -1;\\n            }\\n            n *= 10;\\n            n += s[i] - \\'0\\';\\n            if (n > k) {\\n                answer++;\\n                n = s[i] - \\'0\\';\\n            }\\n        }\\n        if (n) {\\n            answer++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990964,
                "title": "simple-dp-using-memoization-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndp[i]=minimum number of strings in which substring s[i] to s[n-1] can be partitioned obeying the given condition.\\ndp[0]=required answer\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tint solve(int i, string &s, int k, vector<int> &dp)\\n\\t{\\n\\t\\tint n = s.length();\\n\\t\\tif (i >= n)\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[i] != -1)\\n\\t\\t\\treturn dp[i];\\n\\t\\tlong long ct = 0ll;\\n\\t\\tdp[i] = n + 1;\\n\\t\\tfor (int j = i; j < n; j++)\\n\\t\\t{\\n            //Trying different numbers(<=k) and calculating value for that\\n\\t\\t\\tct = 1ll * ct * 10 + (long long)(s[j] - \\'0\\');\\n\\t\\t\\tif (ct <= k)\\n\\t\\t\\t\\tdp[i] = min(dp[i], 1 + solve(j + 1, s, k, dp));\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\treturn dp[i];\\n\\t}\\n\\tint minimumPartition(string s, int k)\\n\\t{\\n\\t\\tint n = s.length();\\n\\t\\tvector<int> dp(n, -1);\\n\\t\\tsolve(0, s, k, dp);\\n\\t\\tif (dp[0] == n + 1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn dp[0];\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint solve(int i, string &s, int k, vector<int> &dp)\\n\\t{\\n\\t\\tint n = s.length();\\n\\t\\tif (i >= n)\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[i] != -1)\\n\\t\\t\\treturn dp[i];\\n\\t\\tlong long ct = 0ll;\\n\\t\\tdp[i] = n + 1;\\n\\t\\tfor (int j = i; j < n; j++)\\n\\t\\t{\\n            //Trying different numbers(<=k) and calculating value for that\\n\\t\\t\\tct = 1ll * ct * 10 + (long long)(s[j] - \\'0\\');\\n\\t\\t\\tif (ct <= k)\\n\\t\\t\\t\\tdp[i] = min(dp[i], 1 + solve(j + 1, s, k, dp));\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\treturn dp[i];\\n\\t}\\n\\tint minimumPartition(string s, int k)\\n\\t{\\n\\t\\tint n = s.length();\\n\\t\\tvector<int> dp(n, -1);\\n\\t\\tsolve(0, s, k, dp);\\n\\t\\tif (dp[0] == n + 1)\\n\\t\\t\\treturn -1;\\n\\t\\treturn dp[0];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988019,
                "title": "python-bottom-up-dp",
                "content": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        n=len(s)\\n        dp=[sys.maxsize]*(n+1)\\n        dp[0]=0\\n        for idx in range(n+1):\\n            val=sys.maxsize\\n            for l in range(1,10):\\n                if idx-l<0: continue\\n                num=int(s[idx-l:idx])\\n                if num<=k:\\n                    dp[idx]=min(dp[idx],dp[idx-l]+1)\\n        return dp[-1] if dp[-1]<sys.maxsize else -1\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        n=len(s)\\n        dp=[sys.maxsize]*(n+1)\\n        dp[0]=0\\n        for idx in range(n+1):\\n            val=sys.maxsize\\n            for l in range(1,10):\\n                if idx-l<0: continue\\n                num=int(s[idx-l:idx])\\n                if num<=k:\\n                    dp[idx]=min(dp[idx],dp[idx-l]+1)\\n        return dp[-1] if dp[-1]<sys.maxsize else -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986727,
                "title": "c-easy-solution",
                "content": "# Intuition\\ncreate number from substring of string and check if it is less then add next character else continue for further string same procedure\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int string_to_integer(string s){\\n        long long int num = 0;\\n        for(int i=0;i<s.length();i++){\\n            num = num*10;\\n            num+=s[i]-\\'0\\';\\n        }\\n        return num;\\n    }\\n    int minimumPartition(string s, int k) {\\n        int i=0,n=s.length(), cnt = 0;\\n        string str=\"\";\\n        while(i<n){\\n            str=\"\";\\n            while(i<n){\\n                str+=s[i];\\n                if(string_to_integer(str)>k){\\n                    str.pop_back();\\n                    break;\\n                }\\n                i++;\\n            }\\n            if(str.length()==0) return -1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int string_to_integer(string s){\\n        long long int num = 0;\\n        for(int i=0;i<s.length();i++){\\n            num = num*10;\\n            num+=s[i]-\\'0\\';\\n        }\\n        return num;\\n    }\\n    int minimumPartition(string s, int k) {\\n        int i=0,n=s.length(), cnt = 0;\\n        string str=\"\";\\n        while(i<n){\\n            str=\"\";\\n            while(i<n){\\n                str+=s[i];\\n                if(string_to_integer(str)>k){\\n                    str.pop_back();\\n                    break;\\n                }\\n                i++;\\n            }\\n            if(str.length()==0) return -1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985557,
                "title": "crisp-c-solution-faster-than-100-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int tar) {\\n        long long num = 0;\\n        int n = s.length();\\n        int k;\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n             k = s[i]-\\'0\\';\\n            num*=10;\\n            num+=k;\\n            if(num > tar)\\n            {\\n                if(k>tar)\\n                    return -1;\\n                num = k;\\n                ans++;\\n            }\\n        }\\n        \\n        \\n        if(num  <= tar)\\n        {\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int tar) {\\n        long long num = 0;\\n        int n = s.length();\\n        int k;\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n             k = s[i]-\\'0\\';\\n            num*=10;\\n            num+=k;\\n            if(num > tar)\\n            {\\n                if(k>tar)\\n                    return -1;\\n                num = k;\\n                ans++;\\n            }\\n        }\\n        \\n        \\n        if(num  <= tar)\\n        {\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985534,
                "title": "c-simple-greedy-approach-t-c-o-n-s-c-o-1",
                "content": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\tT.C. : O(N)\\n\\t\\tS.C. : O(1)\\n\\t*/\\n\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        string temp = \"\";\\n        \\n        for(int i=0; i<s.length(); i++){\\n            temp.push_back(s[i]);\\n            if(stol(temp) > k){\\n                temp = \"\";\\n                temp.push_back(s[i]);\\n                \\n                //If still one digit is greater than k then it is not possible\\n                if(stol(temp) > k){\\n                    return -1;\\n                }\\n                \\n                ans++;\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\tT.C. : O(N)\\n\\t\\tS.C. : O(1)\\n\\t*/\\n\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        string temp = \"\";\\n        \\n        for(int i=0; i<s.length(); i++){\\n            temp.push_back(s[i]);\\n            if(stol(temp) > k){\\n                temp = \"\";\\n                temp.push_back(s[i]);\\n                \\n                //If still one digit is greater than k then it is not possible\\n                if(stol(temp) > k){\\n                    return -1;\\n                }\\n                \\n                ans++;\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984981,
                "title": "beats-100-both-in-speed-and-memory-usage-easy-two-pointer-approach",
                "content": "# Intuition\\nAs the minimum partitions are asked each time i will take the maximum length of substring lessed than k and increase my count.\\n\\n# Approach\\nTwo Pointers will be used.\\nPointer 1: i\\nPointer 2: j\\n- i will travel over the string and increments by i+=j\\n- j will get initailized to 1 each time and will travel for length of integer k;\\n- j will travel till it does not find a substring greater than k or until it is equal to length of integer k and then it will stop.\\n- we will maintain a bool variable which gets true if we find a substring else the loop will break.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n**Plzz Upvote If You Like It**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int t = to_string(k).size();\\n        int i = 0, j= 1;\\n        int n = s.size();\\n        int count = 0;\\n        while(i<n&&j<=n) {\\n            j=1;\\n            bool ok = false;\\n            while(j<=t&&i<n) {\\n                if(stoi(s.substr(i,j))<=k) {\\n                    ok = true;\\n                    j++;\\n                }\\n                else { \\n                    break;\\n                }\\n            }\\n            i+=(j-1);\\n            if(ok)\\n                count++;\\n            if(!ok)\\n                return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int t = to_string(k).size();\\n        int i = 0, j= 1;\\n        int n = s.size();\\n        int count = 0;\\n        while(i<n&&j<=n) {\\n            j=1;\\n            bool ok = false;\\n            while(j<=t&&i<n) {\\n                if(stoi(s.substr(i,j))<=k) {\\n                    ok = true;\\n                    j++;\\n                }\\n                else { \\n                    break;\\n                }\\n            }\\n            i+=(j-1);\\n            if(ok)\\n                count++;\\n            if(!ok)\\n                return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984259,
                "title": "python-greedy-and-dp-approach",
                "content": "# DP approach\\n\\n# Code\\n```\\ndef minimumPartition(self, s: str, k: int) -> int:\\n        n = len(s)\\n        dp = [-1] * n\\n\\n        def dfs(ind):\\n            if ind >=n :\\n                return 0\\n            if dp[ind]!=-1:\\n                return dp[ind]\\n\\n            partitions = math.inf\\n            curr = 0\\n            for i in range(ind, n):\\n                curr = int(s[ind:i+1])\\n                if curr <= k:\\n                    partitions = min(1 + dfs(i+1), partitions)\\n\\n            dp[ind] =  partitions\\n            return partitions\\n\\n        \\n        ans = dfs(0)\\n\\n        return ans if ans != math.inf else -1\\n```\\nThe DP solution gets timed oput\\n\\n# Better Approach\\nGreedy\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        n = len(s)\\n        partitions = 0\\n        i = 0\\n\\n        while i<n:\\n            j = i\\n            while j<n and int(s[i:j+1])<=k:\\n                j+=1\\n            \\n            if i == j and int(s[i]) > k:\\n                return -1\\n            i = j\\n            partitions+=1\\n        \\n        return partitions\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\ndef minimumPartition(self, s: str, k: int) -> int:\\n        n = len(s)\\n        dp = [-1] * n\\n\\n        def dfs(ind):\\n            if ind >=n :\\n                return 0\\n            if dp[ind]!=-1:\\n                return dp[ind]\\n\\n            partitions = math.inf\\n            curr = 0\\n            for i in range(ind, n):\\n                curr = int(s[ind:i+1])\\n                if curr <= k:\\n                    partitions = min(1 + dfs(i+1), partitions)\\n\\n            dp[ind] =  partitions\\n            return partitions\\n\\n        \\n        ans = dfs(0)\\n\\n        return ans if ans != math.inf else -1\\n```\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        n = len(s)\\n        partitions = 0\\n        i = 0\\n\\n        while i<n:\\n            j = i\\n            while j<n and int(s[i:j+1])<=k:\\n                j+=1\\n            \\n            if i == j and int(s[i]) > k:\\n                return -1\\n            i = j\\n            partitions+=1\\n        \\n        return partitions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981535,
                "title": "simple-python-code",
                "content": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        string = \\'\\'\\n        count = 0\\n        for i in s:\\n            string += i\\n            if (int(string) > k):\\n                string = i\\n                if (int(string) > k):\\n                    return -1 \\n                count += 1\\n        return count + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        string = \\'\\'\\n        count = 0\\n        for i in s:\\n            string += i\\n            if (int(string) > k):\\n                string = i\\n                if (int(string) > k):\\n                    return -1 \\n                count += 1\\n        return count + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981424,
                "title": "c-simple-greedy-approach",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n=s.size();\\n        int j=0,i=0;\\n        string s1=\"\";\\n        ll cnt=1;//for counting no of partitions\\n        if(s.size()==1)\\n        {\\n            if(stoll(s)<=k)\\n                return cnt;\\n        }\\n        while(j<n)\\n        {\\n            s1+=s[j];\\n            ll x=stoll(s1);\\n            if(x<=k)\\n            {\\n            }\\n            else\\n            {\\n                i=j;\\n                s1=s.substr(i,j-i+1);\\n                if(stoll(s1)>k)\\n                return -1;\\n                cnt++;\\n            }\\n            j++;\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n=s.size();\\n        int j=0,i=0;\\n        string s1=\"\";\\n        ll cnt=1;//for counting no of partitions\\n        if(s.size()==1)\\n        {\\n            if(stoll(s)<=k)\\n                return cnt;\\n        }\\n        while(j<n)\\n        {\\n            s1+=s[j];\\n            ll x=stoll(s1);\\n            if(x<=k)\\n            {\\n            }\\n            else\\n            {\\n                i=j;\\n                s1=s.substr(i,j-i+1);\\n                if(stoll(s1)>k)\\n                return -1;\\n                cnt++;\\n            }\\n            j++;\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981049,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        \\n       long long int i=0,x=0,ans=0;\\n        while(i<s.size()){\\n            if((int)(s[i])-\\'0\\' >k) return -1;\\n             x=x*10+(int)(s[i])-\\'0\\';\\n             \\n           if(x>k){\\n                 ans++;\\n                 x=(int)(s[i])-\\'0\\';\\n                 \\n             }\\n             i++;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        \\n       long long int i=0,x=0,ans=0;\\n        while(i<s.size()){\\n            if((int)(s[i])-\\'0\\' >k) return -1;\\n             x=x*10+(int)(s[i])-\\'0\\';\\n             \\n           if(x>k){\\n                 ans++;\\n                 x=(int)(s[i])-\\'0\\';\\n                 \\n             }\\n             i++;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980243,
                "title": "c-traversal-simple-solution",
                "content": "Runtime : 9ms\\nTC : O(n) \\nSC : O(1) \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumPartition(string s, int k) {\\n\\t\\t\\tfor( auto i : s ){ \\n\\t\\t\\t\\tif( i - \\'0\\' > k ) return -1;    \\n\\t\\t\\t}\\n\\t\\t\\tint i = 0, c = 0;\\n\\t\\t\\tlong long tmp = 0;\\n\\t\\t\\twhile( i < s.size() ){\\n\\t\\t\\t\\ttmp = tmp * 10 + s[i]-\\'0\\';\\n\\t\\t\\t\\tif( tmp > k ){\\n\\t\\t\\t\\t\\ttmp = tmp % 10; \\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tc++;\\n\\t\\t\\treturn c;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumPartition(string s, int k) {\\n\\t\\t\\tfor( auto i : s ){ \\n\\t\\t\\t\\tif( i - \\'0\\' > k ) return -1;    \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2979358,
                "title": "c-easy-solution",
                "content": "# Intuition\\nIt straight forwar problem to check when a number become greater than k iterate the string for any ith if the substring become greater than k\\nremove the ith element check the remaing part and update the answer\\n\\n# Approach\\ntake a string t \\nIterate over the string and concatenate elements a check function monitors the subtring till i\\nif substring starting last position to i if greater than k remove the ith element if substring size is zero return -1  if still t is bigger than return -1 else update ans new substring as ith element and contine to concatenate\\n\\n\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    bool check(string s,int k){\\n        ll ans=0; \\n        ll ct=s.size()-1;\\n        for(int i=0;i<s.size();i++){\\n            ll z=1; ll r=ct;\\n            while(r--){z*=10;}\\n              ans+=(z*(s[i]-\\'0\\')); ct--;\\n        }\\n        if(ans>k){return true;}\\n        \\n        return false;\\n    }\\n    int minimumPartition(string s, int k) {\\n        \\n        int n=s.size();\\n        string t=\"\";\\n          int ans=0;\\n        for(int i=0;i<n;i++){\\n            t+=s[i];\\n            if(check(t,k)){\\n                 char c=t[t.size()-1];\\n                t=t.substr(0,t.size()-1);\\n                if(t.size()==0){return -1;}\\n                if(check(t,k)){return -1;}\\n                ans++; t=c;\\n            }\\n        }\\n         if(check(t,k)){\\n                 if(t.size()==1){return -1;}\\n            }\\n        else{ans++;}\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    bool check(string s,int k){\\n        ll ans=0; \\n        ll ct=s.size()-1;\\n        for(int i=0;i<s.size();i++){\\n            ll z=1; ll r=ct;\\n            while(r--){z*=10;}\\n              ans+=(z*(s[i]-\\'0\\')); ct--;\\n        }\\n        if(ans>k){return true;}\\n        \\n        return false;\\n    }\\n    int minimumPartition(string s, int k) {\\n        \\n        int n=s.size();\\n        string t=\"\";\\n          int ans=0;\\n        for(int i=0;i<n;i++){\\n            t+=s[i];\\n            if(check(t,k)){\\n                 char c=t[t.size()-1];\\n                t=t.substr(0,t.size()-1);\\n                if(t.size()==0){return -1;}\\n                if(check(t,k)){return -1;}\\n                ans++; t=c;\\n            }\\n        }\\n         if(check(t,k)){\\n                 if(t.size()==1){return -1;}\\n            }\\n        else{ans++;}\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979203,
                "title": "greedy-algorithm-easy-sliding-window-approach-understandable-solution-runtime-12ms-o-n-space-o-1",
                "content": "# Intuition\\nSliding Window -Approach \\nBut Why ?\\nWe have to check each substring until it\\'s greater than K\\nThat intuites us to use sliding window Aprroach\\n# Approach\\nWe will maintain a currdig variable\\nWe will add one digit to currdig each time until it\\'s less than k,to do that we will multiply with 10 ->Extend the window to the right side\\nOnce it\\'s Greater than given k immediately shrink the left side window to this digit and eventually increase count vairbale\\n\\n# Complexity\\n- Time complexity:\\nO(n) ->n=size(string)\\n\\n- Space complexity:\\nO(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*\\nA partition of a string s is called good if:\\n1.Each digit of s is part of exactly one substring.\\n2.The value of each substring is less than or equal to k.\\n*/\\n    int minimumPartition(string s, int k) {\\n\\n        int parmin=0;\\n\\n        int n=s.size();\\n\\n        int r=0;\\n\\n       long long int currdig=0;\\n\\n        while(r<n)\\n        {\\n            currdig=currdig*10+(s[r]-\\'0\\');//We will add one digit each time ,to do that we will multiply with 10\\n            if(currdig>k)//When this if pass -> value of the currdig greater than given \\'k\\' so we have to shrink our window to this digit \\n                        //Again we have to check wether this curdig(single dig ) greater than k or not if yes return -1\\n            {\\n                parmin++;//We will increase each time when the curdig is greater than k and shrink our window to here \\n                currdig=s[r]-\\'0\\';\\n                if(currdig>k)\\n                {\\n                    return -1;\\n                }\\n            }\\n            r++;\\n            //Extend the right window for every iteration\\n        }\\n\\n        if(currdig!=0)parmin++;\\n            return (parmin==0) ? -1 : parmin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\nA partition of a string s is called good if:\\n1.Each digit of s is part of exactly one substring.\\n2.The value of each substring is less than or equal to k.\\n*/\\n    int minimumPartition(string s, int k) {\\n\\n        int parmin=0;\\n\\n        int n=s.size();\\n\\n        int r=0;\\n\\n       long long int currdig=0;\\n\\n        while(r<n)\\n        {\\n            currdig=currdig*10+(s[r]-\\'0\\');//We will add one digit each time ,to do that we will multiply with 10\\n            if(currdig>k)//When this if pass -> value of the currdig greater than given \\'k\\' so we have to shrink our window to this digit \\n                        //Again we have to check wether this curdig(single dig ) greater than k or not if yes return -1\\n            {\\n                parmin++;//We will increase each time when the curdig is greater than k and shrink our window to here \\n                currdig=s[r]-\\'0\\';\\n                if(currdig>k)\\n                {\\n                    return -1;\\n                }\\n            }\\n            r++;\\n            //Extend the right window for every iteration\\n        }\\n\\n        if(currdig!=0)parmin++;\\n            return (parmin==0) ? -1 : parmin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978945,
                "title": "diferent-approach-easy-understanding-java",
                "content": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) \\n    {\\n     int count=0;\\n        String val=\"\";\\n        int i=0;\\n        int j=0;\\n     while(i<s.length())\\n     {\\n         val=\"\";\\n         for( j=i;j<s.length();j++)\\n         {\\n             val+=s.charAt(j);\\n             if(Long.parseLong(val)<=k)\\n             {\\n                 // i++;\\n             }\\n             else\\n             {\\n                 if(i==j)\\n                 {\\n                     return -1;\\n                 }\\n                 i=j;\\n                 count++;\\n                 // System.out.println(count);\\n                 break;\\n             }\\n         }\\n         if(j==s.length())\\n         {\\n             count++;\\n             break;\\n         }\\n         \\n     }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) \\n    {\\n     int count=0;\\n        String val=\"\";\\n        int i=0;\\n        int j=0;\\n     while(i<s.length())\\n     {\\n         val=\"\";\\n         for( j=i;j<s.length();j++)\\n         {\\n             val+=s.charAt(j);\\n             if(Long.parseLong(val)<=k)\\n             {\\n                 // i++;\\n             }\\n             else\\n             {\\n                 if(i==j)\\n                 {\\n                     return -1;\\n                 }\\n                 i=j;\\n                 count++;\\n                 // System.out.println(count);\\n                 break;\\n             }\\n         }\\n         if(j==s.length())\\n         {\\n             count++;\\n             break;\\n         }\\n         \\n     }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978514,
                "title": "basic-python3-solution",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/b01d4755-1ca7-4eda-9f25-5bb260281e8c_1672558463.755114.png)\\n\\n# Approach\\n- If there exists a digit in $$s$$ that is greater than $$k$$, return -1. (This is useful in the case of single-digit $$k$$). \\n- Else, iterate through the string keeping a window size of $$nd$$ which is equal to number of digits in $$k$$.\\nIf the number formed in the window is less than $$k$$, then $$ans$$ will be incremented by 1, and window shifted by $$nd$$.\\nOtherwise the last digit will be taken in the next window.\\n- If we have digits less than $$nd$$ remaining to iterate/check, then it is understood that the number formed will be less than $$k$$ anyways.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        \\n        for i in s:\\n            if int(i)>k:\\n                return -1\\n            \\n        nd = len(str(k))\\n            \\n        ans = 0\\n        i = 0\\n        \\n        while i<len(s):\\n            if i+nd-1<len(s):\\n                obj = int(s[i:i+nd])\\n                if obj<=k:\\n                    ans+=1\\n                    i+=nd\\n                else:\\n                    ans+=1\\n                    i+=nd-1\\n            else:\\n                ans+=1\\n                break\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        \\n        for i in s:\\n            if int(i)>k:\\n                return -1\\n            \\n        nd = len(str(k))\\n            \\n        ans = 0\\n        i = 0\\n        \\n        while i<len(s):\\n            if i+nd-1<len(s):\\n                obj = int(s[i:i+nd])\\n                if obj<=k:\\n                    ans+=1\\n                    i+=nd\\n                else:\\n                    ans+=1\\n                    i+=nd-1\\n            else:\\n                ans+=1\\n                break\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978309,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint minimumPartition(string s, int k) {\\n\\t\\tint n = s.size(), res = 1;\\n        string ans = \"\";\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n            ans.push_back(s[i]);\\n            if (stol(ans) > k) {\\n                res++;\\n                ans.clear();\\n                ans.push_back(s[i]);\\n            }\\n            if (stol(ans) > k) return -1;\\n        }\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumPartition(string s, int k) {\\n\\t\\tint n = s.size(), res = 1;\\n        string ans = \"\";\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n            ans.push_back(s[i]);\\n            if (stol(ans) > k) {\\n                res++;\\n                ans.clear();\\n                ans.push_back(s[i]);\\n            }\\n            if (stol(ans) > k) return -1;\\n        }\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978259,
                "title": "c-simple-traversing-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N) for traverse\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            int t=s[i]-\\'0\\';\\n            if(t>k){\\n                return -1;\\n            }\\n        }\\n        int cnt=0;\\n        long long int t=0;\\n        for(int i=0;i<n;i++){\\n            long long int temp=t*10+s[i]-\\'0\\';\\n            if(temp<=k){\\n                t=temp;\\n            }else{\\n                t=s[i]-\\'0\\';\\n                cnt++;\\n                \\n            }\\n        }\\n        if(t<=k)cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            int t=s[i]-\\'0\\';\\n            if(t>k){\\n                return -1;\\n            }\\n        }\\n        int cnt=0;\\n        long long int t=0;\\n        for(int i=0;i<n;i++){\\n            long long int temp=t*10+s[i]-\\'0\\';\\n            if(temp<=k){\\n                t=temp;\\n            }else{\\n                t=s[i]-\\'0\\';\\n                cnt++;\\n                \\n            }\\n        }\\n        if(t<=k)cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978119,
                "title": "java-in-3-lines-shortest-possible-java-solution-line-wise",
                "content": "Solution originated from my base greedy solution of looping from back to front, creating new groups when the current number exceeds the limit.\\n\\nThe main loop was simplified to only one line using a temporary variable and for loop incrementor statements.\\n\\nNote that I consider a single line as where a part of code is terminated by a semicolon. This doesn\\'t include the semicolons in for loops.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int total = 0;\\n        for(int i = s.length() - 1, end = s.length(), temp = Long.parseLong(s.substring(i, end)) <= k ? 1 : 0; i >= 0; end = (temp == 0 ? i + 1 : end), temp = Long.parseLong(s.substring(i, end)) <= k ? 1 : 0, i -= temp, total += 1 - temp)if(i + 1 == end && temp == 0)return -1;\\n        return total + 1;\\n    }\\n}\\n```\\n\\nThis solution DEFINITLY can be shortened in terms of overall length. I already have an idea that instead of using parseLong(), you could instead:\\n1) Track the current sum\\n2) Increase the sum by the current digit times 10^(end - i)\\n3) Reset sum when you create a new group\\n\\nI am fairly sure the math of step 2 is incorrect, but it should be possible with some modifications. I\\'m not going to fully work this out now, but if somebody does create a significantly shorter solution, comment and I\\'ll rename this solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int total = 0;\\n        for(int i = s.length() - 1, end = s.length(), temp = Long.parseLong(s.substring(i, end)) <= k ? 1 : 0; i >= 0; end = (temp == 0 ? i + 1 : end), temp = Long.parseLong(s.substring(i, end)) <= k ? 1 : 0, i -= temp, total += 1 - temp)if(i + 1 == end && temp == 0)return -1;\\n        return total + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978056,
                "title": "c-easy-to-understand-greedy-c-solution",
                "content": "# Intuition\\nIntuition of greedy comes as soon as we look at the problem\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCan be thought of the problem as a greedy way to iterate through the string and check if it becomes greater than k or not. If it becomes greater than k we can restart the process again after making the cur_num to 0;\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(length of the string) = O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: constant space time\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        if(*max_element(s.begin(), s.end()) - \\'0\\' > k) // not possible\\n            return -1;\\n        int res = 0;\\n        long long cur_num = 0; // to track current total sum of a sub string\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            int _cur = s[i] - \\'0\\';\\n            if ((cur_num * 10) + _cur <= k)\\n            {\\n                cur_num *= 10;\\n                cur_num += _cur;\\n            }\\n            else\\n            {\\n                res += 1;\\n                cur_num = _cur;\\n            }\\n        }\\n        if (cur_num > 0)\\n            res += 1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        if(*max_element(s.begin(), s.end()) - \\'0\\' > k) // not possible\\n            return -1;\\n        int res = 0;\\n        long long cur_num = 0; // to track current total sum of a sub string\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            int _cur = s[i] - \\'0\\';\\n            if ((cur_num * 10) + _cur <= k)\\n            {\\n                cur_num *= 10;\\n                cur_num += _cur;\\n            }\\n            else\\n            {\\n                res += 1;\\n                cur_num = _cur;\\n            }\\n        }\\n        if (cur_num > 0)\\n            res += 1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977819,
                "title": "java-one-pass-easy",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int ans = 1;\\n        long num = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            int digit = s.charAt(i) - \\'0\\';\\n            long newNum = num * 10 + digit;\\n            if (newNum <= k) {\\n                num = newNum;\\n            } else {\\n                if (digit > k) {\\n                    return -1;\\n                }\\n                ans++;\\n                num = digit;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int ans = 1;\\n        long num = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            int digit = s.charAt(i) - \\'0\\';\\n            long newNum = num * 10 + digit;\\n            if (newNum <= k) {\\n                num = newNum;\\n            } else {\\n                if (digit > k) {\\n                    return -1;\\n                }\\n                ans++;\\n                num = digit;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977697,
                "title": "recursive-iterative",
                "content": "# Code\\n```\\nclass Solution {\\n    int[] dp;\\n    public int minimumPartition(String s, int k) {\\n        for ( int i = 0 ; i < s.length() ; i++ ) {\\n            int x = s.charAt(i)-\\'0\\';\\n            if ( x > k ) return -1;\\n        }\\n        int temp = k;\\n        int g = 0;\\n        while(temp!=0){\\n            g++;\\n            temp/=10;\\n        }\\n        if ( s.length()==1  ) return 1;\\n        dp = new int[s.length()+1];\\n        Arrays.fill(dp,-1);\\n        return help(s,k,g,0);\\n    }\\n    int help(String s, int k , int g, int j){\\n        if ( j >= s.length() ) return 0;\\n        if ( dp[j] !=-1 ) return dp[j];\\n        int mx = Integer.MAX_VALUE;\\n        int i = 1 ;\\n        while ( i <= g && j+i<=s.length() ) {\\n            String x = \"\";\\n            if(j!=s.length()-1) x = s.substring(j,j+i);\\n            else x = s.charAt(j)+\"\";\\n            if ( Integer.parseInt(x) <= k ) {\\n                mx = Math.min(mx , 1 + help(s , k , g , j + i));\\n            }\\n            i++;\\n        }\\n        return dp[j] = mx;\\n    }\\n}\\n```\\n\\n# Approach\\ndp[i] = minimum partition required for i length string\\n# Code\\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int temp = k;\\n        int g = 0;\\n        while(temp!=0){\\n            g++;\\n            temp/=10;\\n        }\\n        int[] dp = new int[s.length()+1];\\n        Arrays.fill(dp,2147480000);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for ( int i = 2 ; i < dp.length ; i++ ) {\\n            for ( int j = g ; j > 0  ; j-- ) {\\n                if ( i-j >= 0 ){\\n                    String x = s.substring(i-j,i);\\n                    if( Integer.parseInt(x) <= k ) dp[i] = Math.min(dp[i], 1+dp[i-j] );\\n                }\\n            }\\n        }\\n        if(dp[s.length()] == 2147480000) return -1;\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[] dp;\\n    public int minimumPartition(String s, int k) {\\n        for ( int i = 0 ; i < s.length() ; i++ ) {\\n            int x = s.charAt(i)-\\'0\\';\\n            if ( x > k ) return -1;\\n        }\\n        int temp = k;\\n        int g = 0;\\n        while(temp!=0){\\n            g++;\\n            temp/=10;\\n        }\\n        if ( s.length()==1  ) return 1;\\n        dp = new int[s.length()+1];\\n        Arrays.fill(dp,-1);\\n        return help(s,k,g,0);\\n    }\\n    int help(String s, int k , int g, int j){\\n        if ( j >= s.length() ) return 0;\\n        if ( dp[j] !=-1 ) return dp[j];\\n        int mx = Integer.MAX_VALUE;\\n        int i = 1 ;\\n        while ( i <= g && j+i<=s.length() ) {\\n            String x = \"\";\\n            if(j!=s.length()-1) x = s.substring(j,j+i);\\n            else x = s.charAt(j)+\"\";\\n            if ( Integer.parseInt(x) <= k ) {\\n                mx = Math.min(mx , 1 + help(s , k , g , j + i));\\n            }\\n            i++;\\n        }\\n        return dp[j] = mx;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int temp = k;\\n        int g = 0;\\n        while(temp!=0){\\n            g++;\\n            temp/=10;\\n        }\\n        int[] dp = new int[s.length()+1];\\n        Arrays.fill(dp,2147480000);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for ( int i = 2 ; i < dp.length ; i++ ) {\\n            for ( int j = g ; j > 0  ; j-- ) {\\n                if ( i-j >= 0 ){\\n                    String x = s.substring(i-j,i);\\n                    if( Integer.parseInt(x) <= k ) dp[i] = Math.min(dp[i], 1+dp[i-j] );\\n                }\\n            }\\n        }\\n        if(dp[s.length()] == 2147480000) return -1;\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977600,
                "title": "greedy-solution-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy.\\nKeep increasing the current substring, until its value becomes greater than k.\\nWhenever substring value becomes greater than k, increase ans by 1 and create a new substring with value = current char.\\n\\n# Complexity\\n- Time complexity: O(len(s))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(len(s))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        a = [int(i) for i in s]\\n        if max(a)>k:\\n            return -1\\n        ans = 1\\n        c = 0\\n        for i in a:\\n            if c*10+i<=k:\\n                c = c*10+i\\n            else:\\n                ans += 1\\n                c = i\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        a = [int(i) for i in s]\\n        if max(a)>k:\\n            return -1\\n        ans = 1\\n        c = 0\\n        for i in a:\\n            if c*10+i<=k:\\n                c = c*10+i\\n            else:\\n                ans += 1\\n                c = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977552,
                "title": "python3-greedy-solution-for-ref",
                "content": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        rolling = \"\"\\n        ans = 0\\n        \\n        for i in s:            \\n            if int(rolling + i) > k and (rolling and int(rolling) <= k):\\n                rolling = i\\n                ans += 1\\n            else: \\n                rolling += i\\n        \\n        return (ans+1) if int(rolling) <= k else -1",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        rolling = \"\"\\n        ans = 0\\n        \\n        for i in s:            \\n            if int(rolling + i) > k and (rolling and int(rolling) <= k):\\n                rolling = i\\n                ans += 1\\n            else: \\n                rolling += i\\n        \\n        return (ans+1) if int(rolling) <= k else -1",
                "codeTag": "Java"
            },
            {
                "id": 2977550,
                "title": "brute-force-easy-to-understand-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.length();\\n        \\n        bool flag = false;\\n        // if k < 10 check if every char is greater than k or not, if not return -1\\n        if(k < 10){\\n            for(int i = 0; i < n; i++){\\n                if(s[i]-\\'0\\' >k) \\n                    flag = true;    \\n            }\\n            if(flag) return -1;\\n            else return n==1 ? 1 : n; \\n        }\\n        \\n        \\n        \\n        int ans = 0 ;\\n        long long m = 0;\\n        for(int i = 0; i < n; i++){\\n            int temp = s[i] - \\'0\\';\\n            \\n            m = m*10 + temp;\\n            if(m > k){\\n                ans++;\\n                m = temp;\\n            }\\n            \\n        }\\n        \\n        if(m > 0) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.length();\\n        \\n        bool flag = false;\\n        // if k < 10 check if every char is greater than k or not, if not return -1\\n        if(k < 10){\\n            for(int i = 0; i < n; i++){\\n                if(s[i]-\\'0\\' >k) \\n                    flag = true;    \\n            }\\n            if(flag) return -1;\\n            else return n==1 ? 1 : n; \\n        }\\n        \\n        \\n        \\n        int ans = 0 ;\\n        long long m = 0;\\n        for(int i = 0; i < n; i++){\\n            int temp = s[i] - \\'0\\';\\n            \\n            m = m*10 + temp;\\n            if(m > k){\\n                ans++;\\n                m = temp;\\n            }\\n            \\n        }\\n        \\n        if(m > 0) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977459,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJAVA Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        String temp=\"\";\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            temp+=s.charAt(i);\\n            long a=Long.parseLong(temp);\\n            if(a>k){\\n                if((a/10)>k){\\n                    return -1;\\n                }\\n                else{\\n                    ans++;\\n                    temp=\"\";\\n                    temp+=s.charAt(i);\\n                }\\n            }\\n        }\\n        return Integer.parseInt(temp)>k?-1:ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        String temp=\"\";\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            temp+=s.charAt(i);\\n            long a=Long.parseLong(temp);\\n            if(a>k){\\n                if((a/10)>k){\\n                    return -1;\\n                }\\n                else{\\n                    ans++;\\n                    temp=\"\";\\n                    temp+=s.charAt(i);\\n                }\\n            }\\n        }\\n        return Integer.parseInt(temp)>k?-1:ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977402,
                "title": "python-greedy-100",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        if k < 10 and int(max(s)) > k: return -1\\n        j = 0\\n        n = len(s)\\n        cur = 0\\n        res = 1\\n        while j < n:\\n            cur = 10*cur + int(s[j])\\n            if cur > k:\\n                cur = int(s[j])\\n                res += 1\\n            j += 1\\n        return res\\n            \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        if k < 10 and int(max(s)) > k: return -1\\n        j = 0\\n        n = len(s)\\n        cur = 0\\n        res = 1\\n        while j < n:\\n            cur = 10*cur + int(s[j])\\n            if cur > k:\\n                cur = int(s[j])\\n                res += 1\\n            j += 1\\n        return res\\n            \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977366,
                "title": "o-n-time-complexity-and-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedily keep forming substring until the integer value formed is greater than k. \\n\\n# Approach\\nKeep forming the integer from left to right until you can\\'t no more. One edge case is checking if k < 10 and checking if current digit is not greater than k. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long val=0;\\n        int cnt=1, d;\\n        for (auto &c : s){\\n            d = c-\\'0\\';\\n            if (d > k) return -1;\\n            if (val*10 + d > k){\\n                cnt++;\\n                val = d;\\n            }\\n            else val = val*10 + d;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long val=0;\\n        int cnt=1, d;\\n        for (auto &c : s){\\n            d = c-\\'0\\';\\n            if (d > k) return -1;\\n            if (val*10 + d > k){\\n                cnt++;\\n                val = d;\\n            }\\n            else val = val*10 + d;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977337,
                "title": "greedy-sliding-window-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k,long int curr = 0,long int mx = 0) {\\n        vector<long int> nums;\\n        for (int i = 0; i < s.size(); i++) {\\n            curr = curr * 10 + (s[i] - \\'0\\');\\n            if (curr > k)nums.push_back(curr / 10),curr = s[i] - \\'0\\';\\n        }\\n        nums.push_back(curr);\\n        for(auto ele:nums)mx = max(mx,ele);\\n        return mx > k ? -1 : nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k,long int curr = 0,long int mx = 0) {\\n        vector<long int> nums;\\n        for (int i = 0; i < s.size(); i++) {\\n            curr = curr * 10 + (s[i] - \\'0\\');\\n            if (curr > k)nums.push_back(curr / 10),curr = s[i] - \\'0\\';\\n        }\\n        nums.push_back(curr);\\n        for(auto ele:nums)mx = max(mx,ele);\\n        return mx > k ? -1 : nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977309,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 1, n = s.size();\\n        string str;\\n        for(int j=0; j<n; j++) {\\n            if(s[j] - \\'0\\' > k) return -1;\\n            str += s[j];\\n            if(stol(str) > k) str = s[j], ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 1, n = s.size();\\n        string str;\\n        for(int j=0; j<n; j++) {\\n            if(s[j] - \\'0\\' > k) return -1;\\n            str += s[j];\\n            if(stol(str) > k) str = s[j], ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977289,
                "title": "c-greedy-works",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans=1;\\n        string a = \"\";\\n        for(int i=0;i<s.size();i++){\\n            if((s[i]-\\'0\\')>k) return -1;\\n            a += s[i];\\n            long long  x = stoll(a);\\n            if(x>k){\\n                ans += 1;\\n                a=\"\";\\n                a+=s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans=1;\\n        string a = \"\";\\n        for(int i=0;i<s.size();i++){\\n            if((s[i]-\\'0\\')>k) return -1;\\n            a += s[i];\\n            long long  x = stoll(a);\\n            if(x>k){\\n                ans += 1;\\n                a=\"\";\\n                a+=s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977273,
                "title": "simple-solution-using-recursion-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        return part(s,k,0,0);\\n    }\\n    \\n    public int part(String s,int k,int idx,int count){\\n        //if we reached till end return the count\\n        if(idx==s.length()) return count;\\n        \\n        int i=idx;\\n        \\n        //increase i till the number is less than k\\n        while(i<s.length()&&Long.parseLong(s.substring(idx,i+1))<=k) i++;\\n        \\n         // if i and idx are same it means first number is greater than k i.e. ans is not possible so return -1\\n        if(i==idx) return -1;\\n        \\n        return part(s,k,i,count+1);\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        return part(s,k,0,0);\\n    }\\n    \\n    public int part(String s,int k,int idx,int count){\\n        //if we reached till end return the count\\n        if(idx==s.length()) return count;\\n        \\n        int i=idx;\\n        \\n        //increase i till the number is less than k\\n        while(i<s.length()&&Long.parseLong(s.substring(idx,i+1))<=k) i++;\\n        \\n         // if i and idx are same it means first number is greater than k i.e. ans is not possible so return -1\\n        if(i==idx) return -1;\\n        \\n        return part(s,k,i,count+1);\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090477,
                "title": "python-greedy",
                "content": "Keep traversing through, append if less than k, else reset.\\n\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        res,start,end=[],0,1\\n        while end <= len(s):\\n            if int(s[start:end])>k and start== end-1:\\n                return (-1)\\n            elif int(s[start:end])>k:\\n                res.append(s[start:end-1])\\n                start= end-1\\n                end= start+1\\n            elif int(s[start:end]) <=k:\\n                end=end+1\\n\\n        res.append(s[start:end])\\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        res,start,end=[],0,1\\n        while end <= len(s):\\n            if int(s[start:end])>k and start== end-1:\\n                return (-1)\\n            elif int(s[start:end])>k:\\n                res.append(s[start:end-1])\\n                start= end-1\\n                end= start+1\\n            elif int(s[start:end]) <=k:\\n                end=end+1\\n\\n        res.append(s[start:end])\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056327,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        string ss=\"\";\\n        for(int i=0; i<s.length(); i++)\\n        {\\n           if(s[i]-\\'0\\'>k)\\n           return -1;\\n        }\\n        long long sum=0;\\n        int c=0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            int d=s[i]-\\'0\\';\\n            if(sum*10+d<=k)\\n            {\\n                sum=sum*10+d;\\n            }\\n            else\\n            {\\n                c++;\\n                cout<<sum<<endl;\\n                sum=d;\\n            }\\n\\n        }\\n\\n        if(sum)\\n        c++;\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        string ss=\"\";\\n        for(int i=0; i<s.length(); i++)\\n        {\\n           if(s[i]-\\'0\\'>k)\\n           return -1;\\n        }\\n        long long sum=0;\\n        int c=0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            int d=s[i]-\\'0\\';\\n            if(sum*10+d<=k)\\n            {\\n                sum=sum*10+d;\\n            }\\n            else\\n            {\\n                c++;\\n                cout<<sum<<endl;\\n                sum=d;\\n            }\\n\\n        }\\n\\n        if(sum)\\n        c++;\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4038870,
                "title": "c-clean-code-easy-greedy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n       string a;\\n       int c=0;\\n       for(int i=0;i<s.size();i++)\\n       {\\n          a+=s[i];\\n          if(stoll(a)>=k)\\n          {\\n              c++;\\n              if(stoll(a)!=k)\\n              {a.clear();\\n              a+=s[i];}\\n              else\\n              a.clear();\\n\\n              if(a.size() && stoll(a)>k) return -1;\\n          }\\n       }\\n       if(a.size())\\n       c++;\\n\\n       return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n       string a;\\n       int c=0;\\n       for(int i=0;i<s.size();i++)\\n       {\\n          a+=s[i];\\n          if(stoll(a)>=k)\\n          {\\n              c++;\\n              if(stoll(a)!=k)\\n              {a.clear();\\n              a+=s[i];}\\n              else\\n              a.clear();\\n\\n              if(a.size() && stoll(a)>k) return -1;\\n          }\\n       }\\n       if(a.size())\\n       c++;\\n\\n       return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032481,
                "title": "python3-dp-knapsack-memoization-comments-added",
                "content": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        dp = [-1] * len(s)  # Initialize a memoization array with -1 for each index\\n\\n        def solve(i, c):\\n            if len(s) == i:  # Base case: If we have processed the entire string\\n                return 1\\n\\n            num = int(s[c:i+1])  # Convert the substring into an integer\\n            if num > k:  # Check if the substring value is greater than k\\n                return float(\\'inf\\')  # Return infinity to indicate this is not a valid partition\\n\\n            if dp[c] != -1:  # If we have already computed the result for this index\\n                return dp[c]\\n\\n            # Recursive cases\\n            take = 1 + solve(i + 1, i + 1)  # If we take the current substring as a partition\\n            not_take = solve(i + 1, c)  # If we don\\'t take the current substring as a partition\\n\\n            dp[c] = min(take, not_take)  # Store the minimum of the two results in the memoization array\\n            return dp[c]\\n\\n        ans = solve(0, 0)  # Start the recursion from the beginning of the string\\n        return ans if ans != float(\\'inf\\') else -1  # Check if a valid partition exists and return the result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        dp = [-1] * len(s)  # Initialize a memoization array with -1 for each index\\n\\n        def solve(i, c):\\n            if len(s) == i:  # Base case: If we have processed the entire string\\n                return 1\\n\\n            num = int(s[c:i+1])  # Convert the substring into an integer\\n            if num > k:  # Check if the substring value is greater than k\\n                return float(\\'inf\\')  # Return infinity to indicate this is not a valid partition\\n\\n            if dp[c] != -1:  # If we have already computed the result for this index\\n                return dp[c]\\n\\n            # Recursive cases\\n            take = 1 + solve(i + 1, i + 1)  # If we take the current substring as a partition\\n            not_take = solve(i + 1, c)  # If we don\\'t take the current substring as a partition\\n\\n            dp[c] = min(take, not_take)  # Store the minimum of the two results in the memoization array\\n            return dp[c]\\n\\n        ans = solve(0, 0)  # Start the recursion from the beginning of the string\\n        return ans if ans != float(\\'inf\\') else -1  # Check if a valid partition exists and return the result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028659,
                "title": "100-solution-with-explanation-sliding-window-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a sliding window approach with 2 pointers p1 and p2\\nwe keep sliding p2 to the right and comparing the newly formed integer if it is less than the comparision k\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Example**: s = \"165426\", k = 60\\n\\n**Iteration 1:**\\n\\ns = [1][6][5][4][2][6]\\n- Set **p1 = 0** and **p2 = 1**\\n- s[p1..p2] = 16 < 60 \\u2705\\n  - update **p2 = p2 + 1**\\n- s[p1..p2] = 165 < 60 \\u274C\\n  - add `s[p1..(p2-1)]` to list of solutions\\n  - update **p1 = p2 - 1**\\n  - update **p2 = p2 + 1**\\n- s[p1..p2] = 54 < 60 \\u2705\\n - update **p2 = p2 + 1**\\n- s[p1..p2] = 542 < 60  \\u274C\\n  - add `s[p1..(p2-1)]` to list of solutions\\n  - update **p1 = p2 - 1**\\n  - update **p2 = p2 + 1**\\n... \\n\\nAt the end we\\'re left with a solution list, whose lenth is the length of out solution\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n In worst case, we have to take our pointer to the end of the string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIn the worst case we have an array of length n with every element from the list, so the whole size of the list\\n\\n# Code\\n```\\n# @param {String} s\\n# @param {Integer} k\\n# @return {Integer}\\ndef minimum_partition(s, k)\\n  if k < 10\\n    s.each_char { |c| return -1 if c.to_i > k }\\n    return s.length\\n  end\\n\\n  found_nums, s, p1, p2 = [], s.chars, 0, 1\\n\\n  length = s.length\\n\\n  while p2 <= length\\n    p2 += 1 while s[p1..p2].join.to_i < k && p2 < length\\n    \\n    found_nums.append(s[p1..(p2 - 1)].join)\\n\\n    p1, p2 = p2, p2 + 1\\n  end\\n\\n  found_nums.any? ? found_nums.count : -1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s\\n# @param {Integer} k\\n# @return {Integer}\\ndef minimum_partition(s, k)\\n  if k < 10\\n    s.each_char { |c| return -1 if c.to_i > k }\\n    return s.length\\n  end\\n\\n  found_nums, s, p1, p2 = [], s.chars, 0, 1\\n\\n  length = s.length\\n\\n  while p2 <= length\\n    p2 += 1 while s[p1..p2].join.to_i < k && p2 < length\\n    \\n    found_nums.append(s[p1..(p2 - 1)].join)\\n\\n    p1, p2 = p2, p2 + 1\\n  end\\n\\n  found_nums.any? ? found_nums.count : -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3989011,
                "title": "python-memoization-tabulation-and-greedy-solutions-beginner-friendly",
                "content": "MEMOIZATION : \\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        dp=[-1]*(len(s))\\n        def dfs(i):\\n            if i>=len(s):\\n                return 0\\n            if dp[i]!=-1:\\n                return dp[i]\\n            ans=len(s)+1\\n            for j in range(i,len(s)):\\n                if int(s[i:j+1])<=k:\\n                    ans=min(ans,1+dfs(j+1))\\n                else:\\n                    break\\n            dp[i]=ans\\n            return ans\\n        ans=dfs(0)\\n        return -1 if ans==(len(s)+1) else ans\\n```\\nTABULATION :\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        n=len(s)+1\\n        dp=[float(\\'inf\\')]*n\\n        dp[len(s)]=0\\n        for i in range(n-2,-1,-1):\\n            for j in range(i,len(s)):\\n                if int(s[i:j+1])<=k:\\n                    dp[i]=min(dp[i],1+dp[j+1])\\n                else:\\n                    break\\n        return -1 if dp[0]==float(\\'inf\\') else dp[0]\\n```\\nGREEDY :\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curVal=0\\n        ans=0\\n        for num in s:\\n            curVal=curVal*10+int(num)\\n            if curVal<=k:\\n                continue\\n            else:\\n                ans+=1\\n                curVal=int(num)\\n                if curVal>k:\\n                    return -1\\n        return ans+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        dp=[-1]*(len(s))\\n        def dfs(i):\\n            if i>=len(s):\\n                return 0\\n            if dp[i]!=-1:\\n                return dp[i]\\n            ans=len(s)+1\\n            for j in range(i,len(s)):\\n                if int(s[i:j+1])<=k:\\n                    ans=min(ans,1+dfs(j+1))\\n                else:\\n                    break\\n            dp[i]=ans\\n            return ans\\n        ans=dfs(0)\\n        return -1 if ans==(len(s)+1) else ans\\n```\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        n=len(s)+1\\n        dp=[float(\\'inf\\')]*n\\n        dp[len(s)]=0\\n        for i in range(n-2,-1,-1):\\n            for j in range(i,len(s)):\\n                if int(s[i:j+1])<=k:\\n                    dp[i]=min(dp[i],1+dp[j+1])\\n                else:\\n                    break\\n        return -1 if dp[0]==float(\\'inf\\') else dp[0]\\n```\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curVal=0\\n        ans=0\\n        for num in s:\\n            curVal=curVal*10+int(num)\\n            if curVal<=k:\\n                continue\\n            else:\\n                ans+=1\\n                curVal=int(num)\\n                if curVal>k:\\n                    return -1\\n        return ans+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970636,
                "title": "greedy-sliding-window-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe term substring (contiguous) should make us think of sliding window. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince we need to find the minimum number of partitions possible, we will greedily take the greatest number possible which would be just smaller or equal to k.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int i=0, j=0, count=0;\\n        while(j<s.size()){\\n            string temp = s.substr(i, j-i+1);\\n            long long int num = stoll(temp);\\n            if(i==j && num>k) return -1;\\n            while(j<s.size() && num<=k){\\n                j++;\\n                temp = s.substr(i, j-i+1);\\n                num = stoll(temp);\\n            }\\n            count++;\\n            i=j;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int i=0, j=0, count=0;\\n        while(j<s.size()){\\n            string temp = s.substr(i, j-i+1);\\n            long long int num = stoll(temp);\\n            if(i==j && num>k) return -1;\\n            while(j<s.size() && num<=k){\\n                j++;\\n                temp = s.substr(i, j-i+1);\\n                num = stoll(temp);\\n            }\\n            count++;\\n            i=j;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954855,
                "title": "simple-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimple Iteration\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        string p = \"\";\\n        string kk = to_string(k);\\n        if(kk.size() == 1)\\n        {\\n           \\n            for(int i= 0 ;i<s.size() ;i++)\\n            {\\n                string p =\"\";\\n                p+= s[i];\\n                int num = stoi(p);\\n                if(num > k)\\n                {\\n                   return -1;\\n                }\\n                \\n            }\\n            return s.size();\\n        }\\n        for(int i=0 ;i<s.size() ;i++)\\n        {\\n            p += s[i];\\n            int num = stoi(p);\\n            if(p.size() == kk.size() and num <= k)\\n            {\\n                ans++;\\n                p = \"\";\\n            }\\n            if(p.size() == kk.size() and num > k)\\n            {\\n                ans++;\\n                char l = p[p.size()-1];\\n                p = \"\";\\n                p = p + l;\\n            }\\n        }\\n        if(p.size() ==0)\\n        {\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        string p = \"\";\\n        string kk = to_string(k);\\n        if(kk.size() == 1)\\n        {\\n           \\n            for(int i= 0 ;i<s.size() ;i++)\\n            {\\n                string p =\"\";\\n                p+= s[i];\\n                int num = stoi(p);\\n                if(num > k)\\n                {\\n                   return -1;\\n                }\\n                \\n            }\\n            return s.size();\\n        }\\n        for(int i=0 ;i<s.size() ;i++)\\n        {\\n            p += s[i];\\n            int num = stoi(p);\\n            if(p.size() == kk.size() and num <= k)\\n            {\\n                ans++;\\n                p = \"\";\\n            }\\n            if(p.size() == kk.size() and num > k)\\n            {\\n                ans++;\\n                char l = p[p.size()-1];\\n                p = \"\";\\n                p = p + l;\\n            }\\n        }\\n        if(p.size() ==0)\\n        {\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954854,
                "title": "simple-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimple Iteration\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        string p = \"\";\\n        string kk = to_string(k);\\n        if(kk.size() == 1)\\n        {\\n           \\n            for(int i= 0 ;i<s.size() ;i++)\\n            {\\n                string p =\"\";\\n                p+= s[i];\\n                int num = stoi(p);\\n                if(num > k)\\n                {\\n                   return -1;\\n                }\\n                \\n            }\\n            return s.size();\\n        }\\n        for(int i=0 ;i<s.size() ;i++)\\n        {\\n            p += s[i];\\n            int num = stoi(p);\\n            if(p.size() == kk.size() and num <= k)\\n            {\\n                ans++;\\n                p = \"\";\\n            }\\n            if(p.size() == kk.size() and num > k)\\n            {\\n                ans++;\\n                char l = p[p.size()-1];\\n                p = \"\";\\n                p = p + l;\\n            }\\n        }\\n        if(p.size() ==0)\\n        {\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        string p = \"\";\\n        string kk = to_string(k);\\n        if(kk.size() == 1)\\n        {\\n           \\n            for(int i= 0 ;i<s.size() ;i++)\\n            {\\n                string p =\"\";\\n                p+= s[i];\\n                int num = stoi(p);\\n                if(num > k)\\n                {\\n                   return -1;\\n                }\\n                \\n            }\\n            return s.size();\\n        }\\n        for(int i=0 ;i<s.size() ;i++)\\n        {\\n            p += s[i];\\n            int num = stoi(p);\\n            if(p.size() == kk.size() and num <= k)\\n            {\\n                ans++;\\n                p = \"\";\\n            }\\n            if(p.size() == kk.size() and num > k)\\n            {\\n                ans++;\\n                char l = p[p.size()-1];\\n                p = \"\";\\n                p = p + l;\\n            }\\n        }\\n        if(p.size() ==0)\\n        {\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944594,
                "title": "c-greedy-short-and-simple",
                "content": "Please upvote if you find the solution clean and concise.\\n***Thank You!!***\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    int minimumPartition(string s, int k) {\\n        int res = 0, n = s.size();\\n        ll curr_val = 0; int idx = 0;\\n        while(idx < n) {\\n            curr_val = s[idx] - \\'0\\'; int idx1 = idx;\\n            while(idx1 < n-1 and curr_val*10 + s[idx1 + 1] - \\'0\\' <= (ll)k) {\\n                curr_val = (curr_val)*10 + s[idx1 + 1] - \\'0\\';\\n                idx1++;\\n            }\\n            if(curr_val > k) return -1;\\n            res++; idx = idx1 + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    int minimumPartition(string s, int k) {\\n        int res = 0, n = s.size();\\n        ll curr_val = 0; int idx = 0;\\n        while(idx < n) {\\n            curr_val = s[idx] - \\'0\\'; int idx1 = idx;\\n            while(idx1 < n-1 and curr_val*10 + s[idx1 + 1] - \\'0\\' <= (ll)k) {\\n                curr_val = (curr_val)*10 + s[idx1 + 1] - \\'0\\';\\n                idx1++;\\n            }\\n            if(curr_val > k) return -1;\\n            res++; idx = idx1 + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932592,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumPartition(string s, int k) {\\n        long num = 0;\\n        var partitions = 1;\\n  \\n        foreach(var chr in s) {\\n            var digit = chr - \\'0\\';\\n            if(digit > k)\\n                return -1;\\n            \\n            num = num * 10 + digit;\\n            if(num > k) {\\n                partitions++;\\n                num = digit;\\n            }\\n        }\\n\\n        return partitions;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumPartition(string s, int k) {\\n        long num = 0;\\n        var partitions = 1;\\n  \\n        foreach(var chr in s) {\\n            var digit = chr - \\'0\\';\\n            if(digit > k)\\n                return -1;\\n            \\n            num = num * 10 + digit;\\n            if(num > k) {\\n                partitions++;\\n                num = digit;\\n            }\\n        }\\n\\n        return partitions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907712,
                "title": "simple-solution-in-python",
                "content": "# EASY SOLUTION IN PYTHON \\n# HAPPY LEETOCDING :)\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        count=0\\n        sumi=\"\"\\n        for i in s:\\n            if int(sumi+i)<=k:\\n                sumi=sumi+i\\n            else:\\n                count+=1\\n                if int(i)>k:\\n                    return -1\\n                sumi=i\\n        if sumi:\\n            if int(sumi)<=k:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        count=0\\n        sumi=\"\"\\n        for i in s:\\n            if int(sumi+i)<=k:\\n                sumi=sumi+i\\n            else:\\n                count+=1\\n                if int(i)>k:\\n                    return -1\\n                sumi=i\\n        if sumi:\\n            if int(sumi)<=k:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893680,
                "title": "recursion-memoization-hard-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,string &s,int k,vector<int>&dp){\\n        if(i>=s.length()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1)return dp[i];\\n        int ans=1e6;\\n        string temp;\\n        for(int j=i;j<s.length();j++){\\n            temp+=s[j];\\n            if(temp.size()>9)break;\\n            int a=stoi(temp);\\n            if(a<=k){\\n                int temp2=1+solve(j+1,s,k,dp);\\n                ans=min(ans,temp2);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n    int minimumPartition(string s, int k) {\\n        vector<int>dp(s.length()+1,-1);\\n        int ans=solve(0,s,k,dp);\\n        if(ans==1e6)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,string &s,int k,vector<int>&dp){\\n        if(i>=s.length()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1)return dp[i];\\n        int ans=1e6;\\n        string temp;\\n        for(int j=i;j<s.length();j++){\\n            temp+=s[j];\\n            if(temp.size()>9)break;\\n            int a=stoi(temp);\\n            if(a<=k){\\n                int temp2=1+solve(j+1,s,k,dp);\\n                ans=min(ans,temp2);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return dp[i]=ans;\\n    }\\n    int minimumPartition(string s, int k) {\\n        vector<int>dp(s.length()+1,-1);\\n        int ans=solve(0,s,k,dp);\\n        if(ans==1e6)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879310,
                "title": "greedy",
                "content": "**time: `O(N)`; space: `O(1)`**\\n```\\nint minimumPartition(string s, int k) \\n{\\n\\tint out{1};\\n\\tlong long t{};\\n\\tfor(int i{}; i<size(s); ++i)\\n\\t{\\n\\t\\tt = t*10+s[i]-\\'0\\';\\n\\t\\tif(t>k) \\n\\t\\t{\\n\\t\\t\\t++out;\\n\\t\\t\\tt=s[i]-\\'0\\';\\n\\t\\t\\tif(t>k) return -1;\\n\\t\\t}\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minimumPartition(string s, int k) \\n{\\n\\tint out{1};\\n\\tlong long t{};\\n\\tfor(int i{}; i<size(s); ++i)\\n\\t{\\n\\t\\tt = t*10+s[i]-\\'0\\';\\n\\t\\tif(t>k) \\n\\t\\t{\\n\\t\\t\\t++out;\\n\\t\\t\\tt=s[i]-\\'0\\';\\n\\t\\t\\tif(t>k) return -1;\\n\\t\\t}\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3848246,
                "title": "python3-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        n = len(s);l = len(str(k))\\n        if l==1:\\n            for ch in s:\\n                if int(ch)>k:\\n                    return -1\\n            return n\\n        i = 0;j = 1;ans = 0\\n        while i<n:\\n            if int(s[i:i+l])<=k:\\n                i = i+l\\n                ans+=1\\n            else:\\n                i = i+l-1\\n                ans+=1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        n = len(s);l = len(str(k))\\n        if l==1:\\n            for ch in s:\\n                if int(ch)>k:\\n                    return -1\\n            return n\\n        i = 0;j = 1;ans = 0\\n        while i<n:\\n            if int(s[i:i+l])<=k:\\n                i = i+l\\n                ans+=1\\n            else:\\n                i = i+l-1\\n                ans+=1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803139,
                "title": "ruby-inject-in-5-lines",
                "content": "```\\n# @param {String} s\\n# @param {Integer} k\\n# @return {Integer}\\ndef minimum_partition(s, k)\\n  s.chars.map(&:to_i).inject([0, 1]) { | windowNres, digit |\\n    return -1 if digit > k\\n    window = 10 * windowNres[0] + digit\\n    window > k ? [digit, windowNres[1] + 1] : [window, windowNres[1]]\\n  }[1]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s\\n# @param {Integer} k\\n# @return {Integer}\\ndef minimum_partition(s, k)\\n  s.chars.map(&:to_i).inject([0, 1]) { | windowNres, digit |\\n    return -1 if digit > k\\n    window = 10 * windowNres[0] + digit\\n    window > k ? [digit, windowNres[1] + 1] : [window, windowNres[1]]\\n  }[1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3761905,
                "title": "c-simple-easy-to-understand-approach",
                "content": "# Intuition\\n    String comparisons\\n    \"666\"<\"933\"\\n    if we compare numeric strings of same length then their comparison yeilds the same result as comparing numbers.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n   First :- I converted the num k into a string sk , \\n  So that it could be compared with the substrings of string s\\n  len is length of sk.\\n  Now Run a loop on s and for every substring of lenght len\\n  check if it is less than sk or not , if yes increment count by 1 and increment loop iterator by len\\n  else if No then increment count by 1 and iterator by len-1\\n  No case discussed\\n  when substr is greater  than sk it means a substr of len-1 will be less than sk so incremented count and iterator by len-1\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n     \\n        int count=0;\\n        int n = s.length();\\n        string sk =\"\";\\n        while(k)\\n        {\\n           string c = to_string(k%10);\\n            sk+=c;\\n            k/=10;\\n          \\n        }\\n        reverse(sk.begin(),sk.end());\\n        int len = sk.length();\\n        int i = 0;\\n        while(i<n)\\n        {\\n          int check = i;\\n          if(i+len-1<n)\\n          {\\n            string ch = s.substr(i,len); \\n              if(ch<=sk)\\n              {\\n                i+=len;\\n              }else{\\n                i+=len-1;\\n              }\\n          }else{\\n              count++;\\n              break;\\n          }\\n            count++;\\n            if(i==check) return -1;/*if i value does not change it means in case of single digit k then return -1 as a char in s is greater than k*/\\n       \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n     \\n        int count=0;\\n        int n = s.length();\\n        string sk =\"\";\\n        while(k)\\n        {\\n           string c = to_string(k%10);\\n            sk+=c;\\n            k/=10;\\n          \\n        }\\n        reverse(sk.begin(),sk.end());\\n        int len = sk.length();\\n        int i = 0;\\n        while(i<n)\\n        {\\n          int check = i;\\n          if(i+len-1<n)\\n          {\\n            string ch = s.substr(i,len); \\n              if(ch<=sk)\\n              {\\n                i+=len;\\n              }else{\\n                i+=len-1;\\n              }\\n          }else{\\n              count++;\\n              break;\\n          }\\n            count++;\\n            if(i==check) return -1;/*if i value does not change it means in case of single digit k then return -1 as a char in s is greater than k*/\\n       \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739726,
                "title": "window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        res = 0\\n        if k <=9:\\n            if int(max(s)) <= k:\\n                return len(s)\\n            else: \\n                return -1\\n        else:\\n            win = len(str(k))\\n            #print(\"win: \", win)\\n            i = 0\\n            while i < len(s)-1:\\n                #print(\"i= \", i, \",  s[i:win]: \", s[i:i+win])\\n                #print(\"int(s[i:win]): \", int(s[i:i+win]))\\n                if int(s[i:i+win]) <= k:\\n                    res += 1\\n                    i += win\\n\\n                else:\\n                    res += 1\\n                    i += win -1\\n\\n            if i < len(s) :\\n                res += 1\\n            return res if res > 0 else -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        res = 0\\n        if k <=9:\\n            if int(max(s)) <= k:\\n                return len(s)\\n            else: \\n                return -1\\n        else:\\n            win = len(str(k))\\n            #print(\"win: \", win)\\n            i = 0\\n            while i < len(s)-1:\\n                #print(\"i= \", i, \",  s[i:win]: \", s[i:i+win])\\n                #print(\"int(s[i:win]): \", int(s[i:i+win]))\\n                if int(s[i:i+win]) <= k:\\n                    res += 1\\n                    i += win\\n\\n                else:\\n                    res += 1\\n                    i += win -1\\n\\n            if i < len(s) :\\n                res += 1\\n            return res if res > 0 else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730952,
                "title": "python-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        for i in range(len(s)):\\n            if k<int(s[i]):\\n                return -1\\n\\n        i=0\\n        count=0\\n        while i<len(s):\\n            temp=\\'\\'\\n            while (temp==\\'\\' or int(temp)<k) and i <len(s):\\n                temp=temp+s[i]\\n                if int(temp)>k:\\n                    break\\n                i+=1\\n            count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        for i in range(len(s)):\\n            if k<int(s[i]):\\n                return -1\\n\\n        i=0\\n        count=0\\n        while i<len(s):\\n            temp=\\'\\'\\n            while (temp==\\'\\' or int(temp)<k) and i <len(s):\\n                temp=temp+s[i]\\n                if int(temp)>k:\\n                    break\\n                i+=1\\n            count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719423,
                "title": "bottom-up",
                "content": "# Code\\n```dart\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int minimumPartition(String s, int k) {\\n    final memo = List.filled(s.length + 1, 0);\\n    \\n    // We use MAX to denote impossible.\\n    final MAX = 1 << 30;\\n    \\n    for (int i = s.length - 1; i >= 0; i--) {\\n      var tmp = MAX;\\n\\n      var my = 0;\\n      for (int j = i; j < s.length; j++) {\\n        my = my * 10 + s[j].codeUnitAt(0) - \\'0\\'.codeUnitAt(0);\\n        if (my <= k)\\n          tmp = min(tmp, 1 + memo[j + 1]);\\n        else\\n          break;\\n      }\\n\\n      memo[i] = tmp;\\n    }\\n\\n    return memo[0] == MAX ? -1 : memo[0];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```dart\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int minimumPartition(String s, int k) {\\n    final memo = List.filled(s.length + 1, 0);\\n    \\n    // We use MAX to denote impossible.\\n    final MAX = 1 << 30;\\n    \\n    for (int i = s.length - 1; i >= 0; i--) {\\n      var tmp = MAX;\\n\\n      var my = 0;\\n      for (int j = i; j < s.length; j++) {\\n        my = my * 10 + s[j].codeUnitAt(0) - \\'0\\'.codeUnitAt(0);\\n        if (my <= k)\\n          tmp = min(tmp, 1 + memo[j + 1]);\\n        else\\n          break;\\n      }\\n\\n      memo[i] = tmp;\\n    }\\n\\n    return memo[0] == MAX ? -1 : memo[0];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701696,
                "title": "c-solution-without-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        if(k < 10){\\n            for(const auto& ch:s){\\n                if(ch - \\'0\\' > k)\\n                    return -1;\\n            }\\n            return s.size();\\n        }\\n        int cnt = 1;\\n        long long curr = 0;\\n        for(const auto& ch:s){\\n            curr = curr * 10 + ch - \\'0\\';            \\n            if(curr > k){\\n                cnt++;\\n                curr = ch - \\'0\\';\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        if(k < 10){\\n            for(const auto& ch:s){\\n                if(ch - \\'0\\' > k)\\n                    return -1;\\n            }\\n            return s.size();\\n        }\\n        int cnt = 1;\\n        long long curr = 0;\\n        for(const auto& ch:s){\\n            curr = curr * 10 + ch - \\'0\\';            \\n            if(curr > k){\\n                cnt++;\\n                curr = ch - \\'0\\';\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699143,
                "title": "python-easy-logical-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink of using if conditions to get to the solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf current value>k, count+=1, set current value to the digit we are on in the for loop.\\nif that single digit is also >k, return -1\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        c=0\\n        num=0\\n        for ele in s:\\n            num=num*10+int(ele)\\n            if num>k:\\n                num=int(ele)\\n                c+=1\\n            if num>k:\\n                return -1\\n        return c+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        c=0\\n        num=0\\n        for ele in s:\\n            num=num*10+int(ele)\\n            if num>k:\\n                num=int(ele)\\n                c+=1\\n            if num>k:\\n                return -1\\n        return c+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674269,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) ..in worst case\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long stringToInt(string number){\\n            long long i = 0;\\n \\n    // Traversing string\\n    for (char c : number) {\\n        // Checking if the element is number\\n        if (c >= \\'0\\' && c <= \\'9\\') \\n            i = i * 10 + (c - \\'0\\');\\n    }\\n        return i;\\n   }\\n    \\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        int i = 0;\\n        int n = s.size();\\n        while(i < n){\\n            string str = \"\";\\n            str+= s[i];\\n            i++;\\n            if(stringToInt(str) > k)\\n                return -1;\\n            if(i == n && stringToInt(str) <= k){\\n                ans++;\\n                break;\\n            }\\n            while(i < n){\\n                str+= s[i];\\n                if(stringToInt(str) > k){\\n                    ans++;\\n                    break;\\n                }\\n                i++;\\n                if(i == n && stringToInt(str) <= k){\\n                ans++;\\n                return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long stringToInt(string number){\\n            long long i = 0;\\n \\n    // Traversing string\\n    for (char c : number) {\\n        // Checking if the element is number\\n        if (c >= \\'0\\' && c <= \\'9\\') \\n            i = i * 10 + (c - \\'0\\');\\n    }\\n        return i;\\n   }\\n    \\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        int i = 0;\\n        int n = s.size();\\n        while(i < n){\\n            string str = \"\";\\n            str+= s[i];\\n            i++;\\n            if(stringToInt(str) > k)\\n                return -1;\\n            if(i == n && stringToInt(str) <= k){\\n                ans++;\\n                break;\\n            }\\n            while(i < n){\\n                str+= s[i];\\n                if(stringToInt(str) > k){\\n                    ans++;\\n                    break;\\n                }\\n                i++;\\n                if(i == n && stringToInt(str) <= k){\\n                ans++;\\n                return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576634,
                "title": "golang-greedy",
                "content": "# Intuition\\nGreedily split substring by calculating current substring number, if number > k means we need to split.\\n\\n# Approach\\nIterate string from left to right, use num to calculate the current num\\ncaes1: if current digit > k, return -1.\\ncase2: if num > k, reset num to current digit and increment 1, means the next substring start with current digit.\\ncase3: if num < k, keep expanding num.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc minimumPartition(s string, k int) int {\\n    var num int64\\n    res := 1\\n    for i := 0; i < len(s); i++ {\\n        d := int(s[i] - \\'0\\')\\n        if d > k {\\n            return -1\\n        }\\n        num = num * 10 + int64(d)\\n        if num > int64(k) {\\n            num = int64(d)\\n            res++\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumPartition(s string, k int) int {\\n    var num int64\\n    res := 1\\n    for i := 0; i < len(s); i++ {\\n        d := int(s[i] - \\'0\\')\\n        if d > k {\\n            return -1\\n        }\\n        num = num * 10 + int64(d)\\n        if num > int64(k) {\\n            num = int64(d)\\n            res++\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569772,
                "title": "c-recursion-memoization-greedy-dp",
                "content": "[https://www.youtube.com/watch?v=WsujSuLhsDQ]()\\n\\nDO WATCH MY VIDEO EXPLAINATION IN ENGLISH !\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int parts =0;\\n        int left =0;\\n        int right =0;\\n\\n        while(right < s.length()){\\n            while(right+1-left<10 && right<s.length() && stoll(s.substr(left,right-left+1))<=k){\\n                right++;\\n            }\\n            if(left==right) return -1;\\n            left =right;\\n            parts++;\\n        }\\n        return parts;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int parts =0;\\n        int left =0;\\n        int right =0;\\n\\n        while(right < s.length()){\\n            while(right+1-left<10 && right<s.length() && stoll(s.substr(left,right-left+1))<=k){\\n                right++;\\n            }\\n            if(left==right) return -1;\\n            left =right;\\n            parts++;\\n        }\\n        return parts;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550328,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply put the integer into a bag untill it gets overflowed.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int minimumPartition(final String s, final int k) {\\n        int usedBags = 0;\\n        long bag = 0;\\n        for (int index = 0; index < s.length(); index++) {\\n            int digit = s.charAt(index) - 48;\\n            if (digit > k) return -1;\\n\\n            bag = bag * 10 + digit;\\n            if (bag > k) {\\n                bag = digit;\\n                usedBags++;\\n            }\\n        }\\n        return ++usedBags;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(final String s, final int k) {\\n        int usedBags = 0;\\n        long bag = 0;\\n        for (int index = 0; index < s.length(); index++) {\\n            int digit = s.charAt(index) - 48;\\n            if (digit > k) return -1;\\n\\n            bag = bag * 10 + digit;\\n            if (bag > k) {\\n                bag = digit;\\n                usedBags++;\\n            }\\n        }\\n        return ++usedBags;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549134,
                "title": "rust-greedy-solution",
                "content": "This is a greedy alogrithm implementation as the choice of early substring ending does not affect the total number of substrings.\\n\\nNote: Use 64-bit integers to store the intermediate results; otherwise, the test cases will fail silently given a large `k`, without warning of overflow.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_partition(s: String, k: i32) -> i32 {\\n        let k = k as u64;\\n        let mut counter = 0;\\n        let mut substring_value = 0;\\n\\n        for char in s.chars() {\\n            let digit = char.to_digit(10).unwrap() as u64;\\n            if digit > k {\\n                return -1;\\n            }\\n            let peeped_value = substring_value * 10 + digit;\\n\\n            if peeped_value <= k {\\n                substring_value = peeped_value;\\n            } else {\\n                counter += 1;\\n                substring_value = digit;\\n            }\\n        }\\n        if substring_value != 0 {\\n            counter += 1;\\n        }\\n        counter\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_partition(s: String, k: i32) -> i32 {\\n        let k = k as u64;\\n        let mut counter = 0;\\n        let mut substring_value = 0;\\n\\n        for char in s.chars() {\\n            let digit = char.to_digit(10).unwrap() as u64;\\n            if digit > k {\\n                return -1;\\n            }\\n            let peeped_value = substring_value * 10 + digit;\\n\\n            if peeped_value <= k {\\n                substring_value = peeped_value;\\n            } else {\\n                counter += 1;\\n                substring_value = digit;\\n            }\\n        }\\n        if substring_value != 0 {\\n            counter += 1;\\n        }\\n        counter\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533361,
                "title": "javascript-solution-beats-100",
                "content": "To find the minimum partition, we need to find every longest good substrings in `s`.\\nJust make sure even the single digit is `<=` k, then you are good to go.\\n\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimumPartition = function(s, k) {\\n    let right = 0\\n    let left = 0\\n    let res = 0\\n    let cur = 0\\n    \\n    while(right < s.length) {\\n        if(right === left && parseInt(s[right]) > k) return -1\\n        \\n        cur = cur * 10 + parseInt(s[right])\\n\\t\\t\\n        if(cur > k) {\\n            cur = 0\\n            left = right\\n            res++\\n        } else {\\n            right++\\n        }\\n    }\\n    \\n    return res + 1 // plus the last part of substring\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimumPartition = function(s, k) {\\n    let right = 0\\n    let left = 0\\n    let res = 0\\n    let cur = 0\\n    \\n    while(right < s.length) {\\n        if(right === left && parseInt(s[right]) > k) return -1\\n        \\n        cur = cur * 10 + parseInt(s[right])\\n\\t\\t\\n        if(cur > k) {\\n            cur = 0\\n            left = right\\n            res++\\n        } else {\\n            right++\\n        }\\n    }\\n    \\n    return res + 1 // plus the last part of substring\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490603,
                "title": "java-memoisation",
                "content": "```\\nclass Solution {\\n    private int infi = Integer.MAX_VALUE/2;\\n    public int minimumPartition(String s, int k) {\\n        int ans =  parition(s, 0, k, new Integer[s.length()]);\\n        return ans >= infi ? -1 : ans;\\n    }\\n\\n    private int parition(String str, int idx, int k, Integer[] dp){\\n        if(idx >= str.length())\\n            return 0;\\n        String strTemp = \"\";\\n        int opts = infi;\\n        if(dp[idx] != null)\\n            return dp[idx];\\n        for (int j = idx; j < str.length(); j++){\\n            char ch = str.charAt(j);\\n            strTemp += ch;\\n            if(Long.valueOf(strTemp) <= k){\\n                opts = Math.min(opts, 1 + parition(str, j+1, k, dp));\\n            }else\\n                break;\\n        }\\n        return dp[idx] = opts;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int infi = Integer.MAX_VALUE/2;\\n    public int minimumPartition(String s, int k) {\\n        int ans =  parition(s, 0, k, new Integer[s.length()]);\\n        return ans >= infi ? -1 : ans;\\n    }\\n\\n    private int parition(String str, int idx, int k, Integer[] dp){\\n        if(idx >= str.length())\\n            return 0;\\n        String strTemp = \"\";\\n        int opts = infi;\\n        if(dp[idx] != null)\\n            return dp[idx];\\n        for (int j = idx; j < str.length(); j++){\\n            char ch = str.charAt(j);\\n            strTemp += ch;\\n            if(Long.valueOf(strTemp) <= k){\\n                opts = Math.min(opts, 1 + parition(str, j+1, k, dp));\\n            }else\\n                break;\\n        }\\n        return dp[idx] = opts;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488642,
                "title": "partition-string-into-substrings-with-values-at-most-k",
                "content": "---------------- Easy C++ Solution -------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string str, int k) {\\n    int ans = 1;\\n    long ct = 0;\\n\\n    for (char c : str) {\\n      ct = ct * 10 + c - \\'0\\';\\n      if (ct > k) {\\n        ct = c - \\'0\\';\\n        ++ans;\\n      }\\n      if(ct > k)\\n        return -1;\\n    }\\n    return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string str, int k) {\\n    int ans = 1;\\n    long ct = 0;\\n\\n    for (char c : str) {\\n      ct = ct * 10 + c - \\'0\\';\\n      if (ct > k) {\\n        ct = c - \\'0\\';\\n        ++ans;\\n      }\\n      if(ct > k)\\n        return -1;\\n    }\\n    return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461707,
                "title": "simple-4-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    int minimumPartition(string s, int k) {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]-\\'0\\'>k)\\n            return -1;\\n        }\\n    \\n        long long num=0;\\n        int count=0;\\n       for(int i=0;i<s.size();i++){\\n         num=(num*10)+(s[i]-\\'0\\');\\n         if(num>k){\\n             num=s[i]-\\'0\\';\\n             count++;\\n         }\\n       }\\n       return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    int minimumPartition(string s, int k) {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]-\\'0\\'>k)\\n            return -1;\\n        }\\n    \\n        long long num=0;\\n        int count=0;\\n       for(int i=0;i<s.size();i++){\\n         num=(num*10)+(s[i]-\\'0\\');\\n         if(num>k){\\n             num=s[i]-\\'0\\';\\n             count++;\\n         }\\n       }\\n       return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440048,
                "title": "c-simple-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is length of the string s\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) \\n    {\\n        if(k>=1 and k<9) // base check\\n        {\\n// if k is between 1 to 8 and there exist a digit greater than it \\n// then there does not exist a valid partition\\n// example : s=\"945\" k=6 \\n// even if we break s into 9,4 and 5 as 9 is greater than k ans=-1\\n            for(auto it:s)\\n            {\\n                int curr=it-\\'0\\';\\n                if(curr>k)\\n                {\\n                    return -1;  //not possible \\n                }\\n            }\\n        }\\n        int ans=1;\\n        long long curr_num=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            curr_num*=10;\\n            curr_num+=(s[i]-\\'0\\');\\n            if(curr_num>k) // if curr_num becomes greater than k\\n            {\\n                ++ans;  // increase ans \\n                curr_num=s[i]-\\'0\\'; // curr_num equals s[i]-\\'0\\'\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) \\n    {\\n        if(k>=1 and k<9) // base check\\n        {\\n// if k is between 1 to 8 and there exist a digit greater than it \\n// then there does not exist a valid partition\\n// example : s=\"945\" k=6 \\n// even if we break s into 9,4 and 5 as 9 is greater than k ans=-1\\n            for(auto it:s)\\n            {\\n                int curr=it-\\'0\\';\\n                if(curr>k)\\n                {\\n                    return -1;  //not possible \\n                }\\n            }\\n        }\\n        int ans=1;\\n        long long curr_num=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            curr_num*=10;\\n            curr_num+=(s[i]-\\'0\\');\\n            if(curr_num>k) // if curr_num becomes greater than k\\n            {\\n                ++ans;  // increase ans \\n                curr_num=s[i]-\\'0\\'; // curr_num equals s[i]-\\'0\\'\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432310,
                "title": "swift-beats-100-greedy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumPartition(_ s: String, _ k: Int) -> Int {\\n        let nums = Array(s).map { return Int(String($0)) ?? 0 }\\n        var i = 0\\n        var count = 0\\n\\n        while i < nums.count {\\n            var j = i\\n            if nums[j] > k { return -1 }\\n\\n            var temp = 0\\n            while j < nums.count {\\n                if temp * 10 + nums[j] <= k {\\n                    temp = temp * 10 + nums[j]\\n                    j = j + 1\\n                } else {\\n                    break\\n                }  \\n            }\\n            count = count + 1\\n            i = j\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    func minimumPartition(_ s: String, _ k: Int) -> Int {\\n        let nums = Array(s).map { return Int(String($0)) ?? 0 }\\n        var i = 0\\n        var count = 0\\n\\n        while i < nums.count {\\n            var j = i\\n            if nums[j] > k { return -1 }\\n\\n            var temp = 0\\n            while j < nums.count {\\n                if temp * 10 + nums[j] <= k {\\n                    temp = temp * 10 + nums[j]\\n                    j = j + 1\\n                } else {\\n                    break\\n                }  \\n            }\\n            count = count + 1\\n            i = j\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416458,
                "title": "simple-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        for(int i = 0; i < s.size(); i++) \\n        {\\n            if((s[i] - \\'0\\') > k ) return -1;\\n        }\\n        long long curr_num = 0;\\n        int i=0, ans = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            curr_num = curr_num * 10 + (s[i] - \\'0\\');\\n            if(curr_num <= k) continue;\\n            ans++;\\n            curr_num %= 10;\\n        }\\n        if(curr_num <= k) return ans + 1; \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        for(int i = 0; i < s.size(); i++) \\n        {\\n            if((s[i] - \\'0\\') > k ) return -1;\\n        }\\n        long long curr_num = 0;\\n        int i=0, ans = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            curr_num = curr_num * 10 + (s[i] - \\'0\\');\\n            if(curr_num <= k) continue;\\n            ans++;\\n            curr_num %= 10;\\n        }\\n        if(curr_num <= k) return ans + 1; \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390293,
                "title": "easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) \\n    {\\n         for(int i=0;i<s.length();i++)\\n         {\\n             int digit = s[i] - \\'0\\';\\n             if(digit > k) return -1;\\n         }\\n         int idx = 0;\\n         int count = 0;\\n\\n         while(idx < s.length())\\n         {\\n             long long int sum = 0;\\n             while(idx < s.length())\\n             {\\n                 int digit = s[idx] - \\'0\\';\\n                 long long int temp = (0LL) + ((sum*10) + (digit));\\n\\n                 if(temp > k)\\n                 {\\n                     break;\\n                 }\\n                 if((sum == 0) and (temp > k))\\n                 {\\n                     return -1;\\n                 }\\n\\n                 sum = temp;\\n                 idx++;\\n             }\\n             count++;\\n         }    \\n         return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) \\n    {\\n         for(int i=0;i<s.length();i++)\\n         {\\n             int digit = s[i] - \\'0\\';\\n             if(digit > k) return -1;\\n         }\\n         int idx = 0;\\n         int count = 0;\\n\\n         while(idx < s.length())\\n         {\\n             long long int sum = 0;\\n             while(idx < s.length())\\n             {\\n                 int digit = s[idx] - \\'0\\';\\n                 long long int temp = (0LL) + ((sum*10) + (digit));\\n\\n                 if(temp > k)\\n                 {\\n                     break;\\n                 }\\n                 if((sum == 0) and (temp > k))\\n                 {\\n                     return -1;\\n                 }\\n\\n                 sum = temp;\\n                 idx++;\\n             }\\n             count++;\\n         }    \\n         return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385168,
                "title": "why-greedy-works-intuitive-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif $k < 10$, either number patition == n or -1.\\nif $k > 10$, consider this case:\\ncurrent string value $\\'abc\\' <= k$, and next $\\'abcd\\' > k$.\\nThe greedy solution will treat {$\\'abc\\'$ and $\\'d\\'$} as the best partition.\\n**Assume there is a solution better than greedy**:\\nIt must further separate $\\'abc\\'$ , such as {$\\'a\\'$, $\\'bcd\\'$} or {$\\'ab\\'$, $\\'cd\\'$}, that is, other substrings take at least one digit from $\\'abc\\'$. \\nWe know that for threshold $k$, all substrings except the last one with greedy has reach threashold, any more digit will overflow (**Note: \\'0\\' is not a valid digit**). So other solutions that without greedy take one digit from exisited substring will add one digit to other substrings, which will overflow, require further separate, and the best case is pile up to the last substring. \\nHence greedy is the optimal solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        res = 0\\n        i = 0\\n        while i < len(s):\\n            cur = \"\"\\n            if int(s[i]) > k:\\n                return -1\\n            while i < len(s) and int(cur + s[i]) <= k:\\n                cur = cur + s[i]\\n                i += 1\\n            res += 1\\n            # print(res, cur, i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        res = 0\\n        i = 0\\n        while i < len(s):\\n            cur = \"\"\\n            if int(s[i]) > k:\\n                return -1\\n            while i < len(s) and int(cur + s[i]) <= k:\\n                cur = cur + s[i]\\n                i += 1\\n            res += 1\\n            # print(res, cur, i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356973,
                "title": "sliding-window-greedy-c-very-fast-approach",
                "content": "# Intuition\\nSimply using sliding window because we have to count minimum substrings.\\n\\n# Complexity\\n- Time complexity: O(N)  As we are using sliding window approach\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) As we are not using any extra space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code : Sliding Window\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.length();\\n        int i=0, j=0;\\n        int ans = 0;\\n        long long temp = 0;\\n        while(j < n){\\n            temp = temp*10 + (long long)(s[j]-\\'0\\');\\n            if(temp > (long long)k){\\n                if(temp/10 == 0) return -1; //partition not possible specially when k < 10\\n                ans++;\\n                i = j;\\n                j--; //decrease j by one because at last j is increasing by one at every step\\n                temp = 0;\\n            }\\n            if(j == n-1 && temp <= (long long)k){ //if we reach at last index\\n                ans++;\\n            }\\n            j++;\\n        }\\n        return ans;   \\n    }\\n};\\n```\\n\\n# Code : Greedy\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.length();\\n        int ans = 0;\\n        int i = 0;\\n        string temp = \"0\";//initialize with \\'0\\', esay for comparasion\\n        while(i < n){\\n            bool flag = false;\\n            while(i < n && stol(temp) <= (long long)k){\\n                if(temp == \"0\") temp.pop_back();\\n                temp += s[i];\\n                if(stol(temp) > (long long)k){\\n                    temp.pop_back();\\n                    break;\\n                }\\n                i++;\\n                flag = true;\\n            }\\n            if(flag) ans++;\\n            else if(!flag) return -1;\\n            temp = \"0\";\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.length();\\n        int i=0, j=0;\\n        int ans = 0;\\n        long long temp = 0;\\n        while(j < n){\\n            temp = temp*10 + (long long)(s[j]-\\'0\\');\\n            if(temp > (long long)k){\\n                if(temp/10 == 0) return -1; //partition not possible specially when k < 10\\n                ans++;\\n                i = j;\\n                j--; //decrease j by one because at last j is increasing by one at every step\\n                temp = 0;\\n            }\\n            if(j == n-1 && temp <= (long long)k){ //if we reach at last index\\n                ans++;\\n            }\\n            j++;\\n        }\\n        return ans;   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.length();\\n        int ans = 0;\\n        int i = 0;\\n        string temp = \"0\";//initialize with \\'0\\', esay for comparasion\\n        while(i < n){\\n            bool flag = false;\\n            while(i < n && stol(temp) <= (long long)k){\\n                if(temp == \"0\") temp.pop_back();\\n                temp += s[i];\\n                if(stol(temp) > (long long)k){\\n                    temp.pop_back();\\n                    break;\\n                }\\n                i++;\\n                flag = true;\\n            }\\n            if(flag) ans++;\\n            else if(!flag) return -1;\\n            temp = \"0\";\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341291,
                "title": "python3-greedy-approach",
                "content": "# Intuition\\nWe can use greedy approach to traverse the string and maintaining current digit group value. If this value becomes more than ``k`` we perform split, and current digit becomes the first one in the next group. If current digit itself is greater than ``k``, then we can\\'t do anything with that and we need to return ``-1``.\\n\\n# Approach\\n1. Initialize result with ``1`` and current group value with ``0``\\n2. For each digit ``d`` we check if it is greater than ``k`` and if it is, then return ``-1``\\n3. Otherwise we check if ``current`` with appended ``d`` is greater than ``k`` - if yes, then perform the split, increment the ``result`` and set ``current=d``\\n4. If it is less than ``k``, then we append it: ``current = 10 * current + d``\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        result = 0\\n        current = 0\\n        for c in s:\\n            d = int(c)\\n            if d > k:\\n                return -1\\n            value = 10 * current + d\\n            if value > k:\\n                current = d\\n                result += 1\\n            else:\\n                current = value\\n        result += 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        result = 0\\n        current = 0\\n        for c in s:\\n            d = int(c)\\n            if d > k:\\n                return -1\\n            value = 10 * current + d\\n            if value > k:\\n                current = d\\n                result += 1\\n            else:\\n                current = value\\n        result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340457,
                "title": "easy-python-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumPartition(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        \\n        \\n\\n\\n        window = \"\"\\n        parts = 0\\n        for i in range(len(s)):\\n\\n            ch = s[i]\\n\\n            if int(ch) > k:\\n                return -1\\n\\n            if int(window+ch)>k:\\n                parts+=1\\n                window = \"\"\\n            window+=ch\\n\\n        return parts+1\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumPartition(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        \\n        \\n\\n\\n        window = \"\"\\n        parts = 0\\n        for i in range(len(s)):\\n\\n            ch = s[i]\\n\\n            if int(ch) > k:\\n                return -1\\n\\n            if int(window+ch)>k:\\n                parts+=1\\n                window = \"\"\\n            window+=ch\\n\\n        return parts+1\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335010,
                "title": "c-greedy",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    int minimumPartition(string s, int k) \\n    {\\n        if (k <= 9)\\n        {\\n            for (auto c : s)\\n            {\\n                if (c - \\'0\\' > k)\\n                {\\n                    return -1;\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        long long val = 0LL;\\n        for (int i = 0; i < s.size(); ++i)\\n        {\\n            val = val * 10 + (s[i] - \\'0\\');\\n            if (val > k)\\n            {\\n                ++ans;\\n                val = s[i] - \\'0\\';\\n            }\\n        }\\n\\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimumPartition(string s, int k) \\n    {\\n        if (k <= 9)\\n        {\\n            for (auto c : s)\\n            {\\n                if (c - \\'0\\' > k)\\n                {\\n                    return -1;\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        long long val = 0LL;\\n        for (int i = 0; i < s.size(); ++i)\\n        {\\n            val = val * 10 + (s[i] - \\'0\\');\\n            if (val > k)\\n            {\\n                ++ans;\\n                val = s[i] - \\'0\\';\\n            }\\n        }\\n\\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317856,
                "title": "python-dfs-and-greedy-explained",
                "content": "We always try to find the longest substring that has value smaller or equal to the `k`.  Once we find the substring, we can split the string with the substring and repeat the process to find the next split.\\n\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        self.len_s = len(s)\\n        self.s = s\\n        self.k = k\\n        self.mins = -1\\n        \\n        self.dfsFindSubs(0, 0)\\n        return self.mins\\n    \\n        \\n    def dfsFindSubs(self, sidx, scnt):\\n        if sidx == self.len_s:\\n            if self.mins == -1 or scnt < self.mins:\\n                self.mins = scnt\\n            return\\n        \\n        nidx = sidx + 1\\n        found_sub = False\\n        while nidx <= self.len_s and int(self.s[sidx:nidx]) <= self.k:\\n            found_sub = True\\n            nidx += 1\\n            \\n        if found_sub:\\n            scnt += 1\\n            self.dfsFindSubs(nidx - 1, scnt)\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        self.len_s = len(s)\\n        self.s = s\\n        self.k = k\\n        self.mins = -1\\n        \\n        self.dfsFindSubs(0, 0)\\n        return self.mins\\n    \\n        \\n    def dfsFindSubs(self, sidx, scnt):\\n        if sidx == self.len_s:\\n            if self.mins == -1 or scnt < self.mins:\\n                self.mins = scnt\\n            return\\n        \\n        nidx = sidx + 1\\n        found_sub = False\\n        while nidx <= self.len_s and int(self.s[sidx:nidx]) <= self.k:\\n            found_sub = True\\n            nidx += 1\\n            \\n        if found_sub:\\n            scnt += 1\\n            self.dfsFindSubs(nidx - 1, scnt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279599,
                "title": "easy-greedy-approach-solution-no-dp-cpp",
                "content": "# Intuition and Approach\\n* we will traverse through string and create our temp no.\\n* if temp no. is greater then k then we will increase counter and restart temp.\\n* at the end return counter.\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    int minimumPartition(string s, int k){\\n        int n=s.length();\\n        int cnt=0;\\n        for(int i=0;i<n;){\\n            long long temp=0;\\n            while(1){\\n                if(i==n){\\n                    cnt++;\\n                    return cnt;\\n                }\\n                temp=temp*10+(s[i]-\\'0\\');\\n                if(temp<=k)i++;\\n                else break;\\n            }\\n            if(temp<=9)return -1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    int minimumPartition(string s, int k){\\n        int n=s.length();\\n        int cnt=0;\\n        for(int i=0;i<n;){\\n            long long temp=0;\\n            while(1){\\n                if(i==n){\\n                    cnt++;\\n                    return cnt;\\n                }\\n                temp=temp*10+(s[i]-\\'0\\');\\n                if(temp<=k)i++;\\n                else break;\\n            }\\n            if(temp<=9)return -1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250298,
                "title": "greedy-algorithm-that-beats-99-8",
                "content": "# Approach\\n1. convert k into a string\\n2. if k is a single digit number, we can compare each char in s with k. if any char is greater than k return -1. Otherwise, return len(s)\\n3. let the length of k be the loop step size while iterating s, compare each sub string with k, if greater than k backoff by one.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        limit = str(k)\\n        step = len(limit)\\n        if step == 1:\\n            for d in s:\\n                if d > limit:\\n                    return -1\\n            return len(s)\\n        i, r = 0, 0\\n        while i < len(s):\\n            sub = s[i:i+step]\\n            if sub > limit:\\n                i -= 1\\n            i += step\\n            r += 1\\n        return r\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        limit = str(k)\\n        step = len(limit)\\n        if step == 1:\\n            for d in s:\\n                if d > limit:\\n                    return -1\\n            return len(s)\\n        i, r = 0, 0\\n        while i < len(s):\\n            sub = s[i:i+step]\\n            if sub > limit:\\n                i -= 1\\n            i += step\\n            r += 1\\n        return r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250199,
                "title": "strings-simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long x=0,ans=1,n=s.size(),i;\\n        for(i=0;i<n;i++){\\n            if(s[i]-\\'0\\'>k) return -1;\\n            x=1LL*x*10+s[i]-\\'0\\';\\n            if(x<=k) continue;\\n            else{\\n                x=s[i]-\\'0\\';\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long x=0,ans=1,n=s.size(),i;\\n        for(i=0;i<n;i++){\\n            if(s[i]-\\'0\\'>k) return -1;\\n            x=1LL*x*10+s[i]-\\'0\\';\\n            if(x<=k) continue;\\n            else{\\n                x=s[i]-\\'0\\';\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249271,
                "title": "java-simple-fast-and-clean-code",
                "content": "# Approach\\n1. If k == 9, return s.length() as partitions can be max 1 digit\\n2. Iterate over s and add each char/digit to a partitionValue: partitionValue * 10 + digit.\\n3. Fail fast: if current digit > k, return -1\\n4. If partitionValue > k, increment the number of partitions and set partitionValue = current digit.\\n5. Return the number of partitions\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        if (k == 9) {\\n            return s.length();\\n        }\\n        int partitions = 1;\\n        long partitionValue = 0, digit;\\n        for(int i = 0; i < s.length(); i++) {\\n            digit = s.charAt(i) - \\'0\\';\\n            if (digit > k) {\\n                return -1;\\n            }\\n            partitionValue = partitionValue * 10 + digit;\\n            if (partitionValue > k) {\\n                partitionValue = digit;\\n                partitions++;\\n            }\\n        }\\n        return partitions;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        if (k == 9) {\\n            return s.length();\\n        }\\n        int partitions = 1;\\n        long partitionValue = 0, digit;\\n        for(int i = 0; i < s.length(); i++) {\\n            digit = s.charAt(i) - \\'0\\';\\n            if (digit > k) {\\n                return -1;\\n            }\\n            partitionValue = partitionValue * 10 + digit;\\n            if (partitionValue > k) {\\n                partitionValue = digit;\\n                partitions++;\\n            }\\n        }\\n        return partitions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244554,
                "title": "c-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n\\n        int n=s.size();\\n        int res=0;\\n        long long int temp=0;\\n        for(int i=0;i<n;i++)\\n        {  \\n            temp=temp*10+s[i]-48;\\n            if(temp>(long long)k)\\n            {\\n                res++;\\n                temp=s[i]-48;\\n                if(temp>(long long)k)\\n                return -1;\\n            }\\n        }\\n        return res+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n\\n        int n=s.size();\\n        int res=0;\\n        long long int temp=0;\\n        for(int i=0;i<n;i++)\\n        {  \\n            temp=temp*10+s[i]-48;\\n            if(temp>(long long)k)\\n            {\\n                res++;\\n                temp=s[i]-48;\\n                if(temp>(long long)k)\\n                return -1;\\n            }\\n        }\\n        return res+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242470,
                "title": "all-leetcode-solutions",
                "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2522.%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K..cpp\\n\\nPLEASE LEAVE A STAR\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        long long t = 0;\\n        for(auto c: s){\\n            long long r = t*10 + c-\\'0\\';\\n            if(r <= k) t = r;\\n            else{\\n                ans++;\\n                t = 0;\\n                r = c - \\'0\\';\\n                if(r <= k) t = r;\\n                else return -1;\\n            }\\n        }\\n        if(t <= k) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        long long t = 0;\\n        for(auto c: s){\\n            long long r = t*10 + c-\\'0\\';\\n            if(r <= k) t = r;\\n            else{\\n                ans++;\\n                t = 0;\\n                r = c - \\'0\\';\\n                if(r <= k) t = r;\\n                else return -1;\\n            }\\n        }\\n        if(t <= k) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237387,
                "title": "typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction minimumPartition(s: string, k: number): number {\\n    let count = 0;\\n    let substr = \\'\\';\\n    for (let i = 0; i < s.length; i++) {\\n        const currentSymbol = s[i];\\n        const nextSymbol = s[i + 1];\\n        if (Number(currentSymbol) > k) {\\n            return -1\\n        }\\n        if (nextSymbol) {\\n            if (Number(substr + currentSymbol) <= k) {\\n                substr += currentSymbol;\\n            } else {\\n                count++;\\n                substr = currentSymbol;\\n            }\\n        } else {\\n            if (Number(substr + currentSymbol) <= k) {\\n                count++;\\n            } else {\\n                // The substring is guaranteed to have a number less than or equal to k, and there is also a current    character that is also less than or equal to k.\\n                count += 2;\\n            }\\n        }\\n    }\\n    return count || -1;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minimumPartition(s: string, k: number): number {\\n    let count = 0;\\n    let substr = \\'\\';\\n    for (let i = 0; i < s.length; i++) {\\n        const currentSymbol = s[i];\\n        const nextSymbol = s[i + 1];\\n        if (Number(currentSymbol) > k) {\\n            return -1\\n        }\\n        if (nextSymbol) {\\n            if (Number(substr + currentSymbol) <= k) {\\n                substr += currentSymbol;\\n            } else {\\n                count++;\\n                substr = currentSymbol;\\n            }\\n        } else {\\n            if (Number(substr + currentSymbol) <= k) {\\n                count++;\\n            } else {\\n                // The substring is guaranteed to have a number less than or equal to k, and there is also a current    character that is also less than or equal to k.\\n                count += 2;\\n            }\\n        }\\n    }\\n    return count || -1;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3233894,
                "title": "python-recursive-dp",
                "content": "# Intuition\\nLinear DP brute-forcing all substrings, carefully stopping when needed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA simple recursion that solves the problem starting from index `i`. The recursive function tries all substrings that start from `i` and that are smaller or equal than `k`, and recursively solves for the remaining of the string. Crucially, it stops at the first character for which the partition is > `k`, this avoids wasting compute on iterations that will not be accepted anyway.\\n\\n$log_{10}$ refers to the number of digits of k, which is the maximum number of iterations on each recursive call.\\n\\n# Complexity\\n- Time complexity: $O(log_{10}(k) * n)$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport functools\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        inf = int(1e9)\\n        @functools.cache\\n        def solve(i):\\n            if i >= len(s):\\n                return 0\\n\\n            answer = inf\\n            for j in range(i, len(s)):\\n                number = int(s[i:j+1])\\n                if number > k:\\n                    break # Not breaking here causes TLE!\\n\\n                answer = min(answer, 1 + solve(j + 1))\\n          \\n            return answer\\n        \\n        answer = solve(0)\\n        answer = -1 if answer >= inf else answer\\n        return answer\\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport functools\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        inf = int(1e9)\\n        @functools.cache\\n        def solve(i):\\n            if i >= len(s):\\n                return 0\\n\\n            answer = inf\\n            for j in range(i, len(s)):\\n                number = int(s[i:j+1])\\n                if number > k:\\n                    break # Not breaking here causes TLE!\\n\\n                answer = min(answer, 1 + solve(j + 1))\\n          \\n            return answer\\n        \\n        answer = solve(0)\\n        answer = -1 if answer >= inf else answer\\n        return answer\\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233002,
                "title": "c-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        ll sum=0;\\n        int ans=1;\\n        for(int i=0;i<s.size();++i){\\n            sum=(0ll+sum*10+s[i]-\\'0\\');\\n            if(sum>k){\\n                ans++;\\n                sum=s[i]-\\'0\\';\\n                if(sum>k) return -1;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        ll sum=0;\\n        int ans=1;\\n        for(int i=0;i<s.size();++i){\\n            sum=(0ll+sum*10+s[i]-\\'0\\');\\n            if(sum>k){\\n                ans++;\\n                sum=s[i]-\\'0\\';\\n                if(sum>k) return -1;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231877,
                "title": "simple-greedy-o-n-8ms-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        if(!valid(s,k))   return -1;\\n        int ans=0,i=0,n=s.length();\\n        long curr=0;\\n        while(i<n){\\n            int d=s.charAt(i++)-\\'0\\';\\n            if(curr*10+d>=k){\\n                curr=0;ans++;\\n            }\\n            curr=curr*10+d;\\n        }\\n        return ans+(curr<k?1:0);\\n    }\\n    private boolean valid(String s,int k){\\n        if(k>8) return true;\\n        for(int i=0;i<s.length();i++)   if(s.charAt(i)-\\'0\\'>k)   return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        if(!valid(s,k))   return -1;\\n        int ans=0,i=0,n=s.length();\\n        long curr=0;\\n        while(i<n){\\n            int d=s.charAt(i++)-\\'0\\';\\n            if(curr*10+d>=k){\\n                curr=0;ans++;\\n            }\\n            curr=curr*10+d;\\n        }\\n        return ans+(curr<k?1:0);\\n    }\\n    private boolean valid(String s,int k){\\n        if(k>8) return true;\\n        for(int i=0;i<s.length();i++)   if(s.charAt(i)-\\'0\\'>k)   return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223048,
                "title": "simple-approach-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long ans = 0, curr = 0, l = s.length(), digit = 0;\\n        for(int i = 0; i < l; i++ ){\\n            digit =  s[i] - \\'0\\' ;\\n            if(curr * 10 + digit > k){\\n                ans++;\\n                curr = digit;\\n                if(digit > k)\\n                    return -1;\\n            }else{\\n                curr *= 10;\\n                curr += digit;\\n            }\\n        }\\n        if(curr > 0) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long ans = 0, curr = 0, l = s.length(), digit = 0;\\n        for(int i = 0; i < l; i++ ){\\n            digit =  s[i] - \\'0\\' ;\\n            if(curr * 10 + digit > k){\\n                ans++;\\n                curr = digit;\\n                if(digit > k)\\n                    return -1;\\n            }else{\\n                curr *= 10;\\n                curr += digit;\\n            }\\n        }\\n        if(curr > 0) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201522,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n=s.length();\\n        long long i=0,cnt=0,num=0;\\n        string out=\"\"; \\n       \\n        while(i<n){\\n           num=num*10+s[i]-\\'0\\';\\n\\n           if(num>k){\\n               if(num<10){\\n                   return -1;\\n               }\\n               cnt++;\\n               num=0;\\n           }\\n           else{\\n             i++;\\n           }\\n\\n        }\\n        \\n        return cnt+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n=s.length();\\n        long long i=0,cnt=0,num=0;\\n        string out=\"\"; \\n       \\n        while(i<n){\\n           num=num*10+s[i]-\\'0\\';\\n\\n           if(num>k){\\n               if(num<10){\\n                   return -1;\\n               }\\n               cnt++;\\n               num=0;\\n           }\\n           else{\\n             i++;\\n           }\\n\\n        }\\n        \\n        return cnt+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194269,
                "title": "c-solution-partition-string-into-substrings-with-values-at-most-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncheck every character and every character also cosidering their previous indexd char.\\n\\n# Approach\\nfirstly take a for traversing all character of string \\nthen convert a char in number and check for greater than k if  it is less than k traverse next char.if number is greater than k increse ans,now again check for ith position char it is greater than k or not if it is greater than k then return -1.because this question also considering a single character also should not be greater than k.\\n\\n\\n# Code\\n\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k){\\n        long long num=0,ans=1;\\n        for(int i=0;i<s.length(); i++)\\n        {\\n            num=num*10+s[i]-\\'0\\';\\n            \\n            if(num>k)\\n            {\\n                ans++;\\n                num=s[i]-\\'0\\';\\n            }\\n            if(num>k)\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumPartition(string s, int k){\\n        long long num=0,ans=1;\\n        for(int i=0;i<s.length(); i++)\\n        {\\n            num=num*10+s[i]-\\'0\\';\\n            \\n            if(num>k)\\n            {\\n                ans++;\\n                num=s[i]-\\'0\\';\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3147038,
                "title": "c-golang-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        long long num = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(num * 10 + (s[i] - \\'0\\') > k) {\\n                if(num > k) return -1;\\n                ans++;\\n                num = s[i] - \\'0\\';\\n            } else {\\n                num = num * 10 + (s[i] - \\'0\\');\\n            }\\n        }\\n        if(num > k) return -1;\\n        if(num > 0 && num <= k) ans++;\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumPartition(s string, k int) int {\\n    var ans int = 0\\n    var num int64 = 0\\n    for i := 0; i < len(s); i++ {\\n        if num * 10 + int64(s[i] - \\'0\\') > int64(k) {\\n            if num > int64(k) {return -1}\\n            ans++\\n            num = int64(s[i] - \\'0\\')\\n        } else {\\n            num = num * 10 + int64(s[i] - \\'0\\')\\n        }\\n    }\\n    if num > int64(k) {return -1}\\n    if num > 0 && num <= int64(k) {ans++}\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "String",
                    "Greedy"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        long long num = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(num * 10 + (s[i] - \\'0\\') > k) {\\n                if(num > k) return -1;\\n                ans++;\\n                num = s[i] - \\'0\\';\\n            } else {\\n                num = num * 10 + (s[i] - \\'0\\');\\n            }\\n        }\\n        if(num > k) return -1;\\n        if(num > 0 && num <= k) ans++;\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumPartition(s string, k int) int {\\n    var ans int = 0\\n    var num int64 = 0\\n    for i := 0; i < len(s); i++ {\\n        if num * 10 + int64(s[i] - \\'0\\') > int64(k) {\\n            if num > int64(k) {return -1}\\n            ans++\\n            num = int64(s[i] - \\'0\\')\\n        } else {\\n            num = num * 10 + int64(s[i] - \\'0\\')\\n        }\\n    }\\n    if num > int64(k) {return -1}\\n    if num > 0 && num <= int64(k) {ans++}\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143002,
                "title": "simple-greedy-approach-begg-friendly-o-n",
                "content": "# Intuition  Think Brute Force\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Greedy\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(j<s.length()){\\n            if(s.charAt(j)-\\'0\\'>k){\\n                return -1;\\n            }\\n            while(j<s.length() && Long.parseLong(s.substring(i,j+1))<=k){\\n                j++;\\n            }\\n            count++;\\n            if(i==j){\\n                return -1;\\n            }\\n            i=j;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(j<s.length()){\\n            if(s.charAt(j)-\\'0\\'>k){\\n                return -1;\\n            }\\n            while(j<s.length() && Long.parseLong(s.substring(i,j+1))<=k){\\n                j++;\\n            }\\n            count++;\\n            if(i==j){\\n                return -1;\\n            }\\n            i=j;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126092,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def minimumPartition(s: String, k: Int): Int = {\\n        s.map(_.asDigit).foldLeft((0L,1))((ans, cur) =>{\\n        if(cur > k) return -1\\n        val next = ans._1 * 10 + cur\\n        if(next > k) (cur, ans._2 + 1) else (next, ans._2) \\n        })._2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def minimumPartition(s: String, k: Int): Int = {\\n        s.map(_.asDigit).foldLeft((0L,1))((ans, cur) =>{\\n        if(cur > k) return -1\\n        val next = ans._1 * 10 + cur\\n        if(next > k) (cur, ans._2 + 1) else (next, ans._2) \\n        })._2\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3110274,
                "title": "easy-c-code-by-comparing-string-literals-of-substrings",
                "content": "# Intuition\\nThe idea would be to iterate over the string and slice out the valid intervals\\n# Approach\\nCreating a utility function to compare correctly between the `string s` and the string formed by `int k` and iterating\\n\\n# Complexity\\n- Time complexity: Since the iteration takes over the entire array (Times n) and in each iteration we check using the `.compare()` function which is of O(m,n) where m,n are the sizes of the strings being used. Here `ks = to_sting(k)` and the length of ks will be constant and between `[1..len(pow(10,9))] = [1..10]` \\nHence, the time complexity is $$O(n)$$\\n\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    bool validInterval(string _s, string ks){\\n        \\n        if(_s.size() == ks.size()){\\n            return _s.compare(ks) <= 0;\\n        }\\n        return _s.size() < ks.size();\\n    }\\n    \\n    int minimumPartition(string s, int k) {\\n        \\n        \\n        string ks = to_string(k), _s = \"\";\\n        \\n        int n = s.size(), left = 0, cnt = 0, idx = 0;\\n\\n        //Checking for single characters\\n        if(ks.size () == 1){\\n\\n            string check = \"\";\\n            for(auto it : s){\\n                check.append(1, it);\\n                if(!validInterval(check, ks)){\\n                    return -1;\\n                }\\n                check.pop_back();\\n            }\\n\\n            return s.size();\\n        }\\n        \\n        while(idx  < n){\\n            _s.append(1, s[idx]);\\n            if(!validInterval(_s, ks)){\\n                \\n                    cnt++;\\n                    _s = \"\";\\n                    _s.append(1, s[idx]);\\n            }\\n\\n            idx++;\\n        }\\n        \\n        if(!validInterval(_s, ks)){\\n            return -1;\\n        }\\n        \\n        if(_s.size() > 0){\\n            cnt++;\\n        }\\n\\n        return cnt;\\n        \\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    bool validInterval(string _s, string ks){\\n        \\n        if(_s.size() == ks.size()){\\n            return _s.compare(ks) <= 0;\\n        }\\n        return _s.size() < ks.size();\\n    }\\n    \\n    int minimumPartition(string s, int k) {\\n        \\n        \\n        string ks = to_string(k), _s = \"\";\\n        \\n        int n = s.size(), left = 0, cnt = 0, idx = 0;\\n\\n        //Checking for single characters\\n        if(ks.size () == 1){\\n\\n            string check = \"\";\\n            for(auto it : s){\\n                check.append(1, it);\\n                if(!validInterval(check, ks)){\\n                    return -1;\\n                }\\n                check.pop_back();\\n            }\\n\\n            return s.size();\\n        }\\n        \\n        while(idx  < n){\\n            _s.append(1, s[idx]);\\n            if(!validInterval(_s, ks)){\\n                \\n                    cnt++;\\n                    _s = \"\";\\n                    _s.append(1, s[idx]);\\n            }\\n\\n            idx++;\\n        }\\n        \\n        if(!validInterval(_s, ks)){\\n            return -1;\\n        }\\n        \\n        if(_s.size() > 0){\\n            cnt++;\\n        }\\n\\n        return cnt;\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101586,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        for i in range(len(s)):\\n            if int(s[i]) > k: return -1\\n        cur = \"\"\\n        res = 0\\n        for i in range(len(s)):\\n            cur += s[i]\\n            \\n            if int(cur) > k:\\n                res += 1\\n                cur = cur[-1]\\n        \\n        return res + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        for i in range(len(s)):\\n            if int(s[i]) > k: return -1\\n        cur = \"\"\\n        res = 0\\n        for i in range(len(s)):\\n            cur += s[i]\\n            \\n            if int(cur) > k:\\n                res += 1\\n                cur = cur[-1]\\n        \\n        return res + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088187,
                "title": "c-easy-short-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        long long t = 0;\\n        for(auto c: s){\\n            long long r = t*10 + c-\\'0\\';\\n            if(r <= k) t = r;\\n            else{\\n                ans++;\\n                t = 0;\\n                r = c - \\'0\\';\\n                if(r <= k) t = r;\\n                else return -1;\\n            }\\n        }\\n        if(t <= k) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        long long t = 0;\\n        for(auto c: s){\\n            long long r = t*10 + c-\\'0\\';\\n            if(r <= k) t = r;\\n            else{\\n                ans++;\\n                t = 0;\\n                r = c - \\'0\\';\\n                if(r <= k) t = r;\\n                else return -1;\\n            }\\n        }\\n        if(t <= k) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087536,
                "title": "easy-c-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea here is to keep partitioning the number till it exceeds the given k and then start another partition.\\nSo, in a sense, greedy approach is used to solve the problem.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long num=0,ans=1;\\n        for(int i=0;i<s.length(); i++)\\n        {\\n            num=num*10+s[i]-\\'0\\';\\n            \\n            if(num>k)\\n            {\\n                ans++;\\n                num=s[i]-\\'0\\';\\n            }\\n            if(num>k)\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long num=0,ans=1;\\n        for(int i=0;i<s.length(); i++)\\n        {\\n            num=num*10+s[i]-\\'0\\';\\n            \\n            if(num>k)\\n            {\\n                ans++;\\n                num=s[i]-\\'0\\';\\n            }\\n            if(num>k)\\n            {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083616,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n       \\tint result = 0;\\n\\t\\tchar[] crs = s.toCharArray();\\n\\n\\t\\tfor (int i = 0; i < crs.length; i++) {\\n\\t\\t\\tint index = i;\\n\\t\\t\\tString str = \"\";\\n\\t\\t\\tlong val = 0;\\n\\t\\t\\twhile (index < crs.length) {\\n\\t\\t\\t\\tstr = str + crs[index];\\n\\t\\t\\t\\tval = Long.parseLong(str);\\n\\t\\t\\t\\tif (val <= k) {\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (i == index) {\\n\\t\\t\\t\\tresult = -1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\ti = index - 1;\\n\\t\\t\\tresult++;\\n\\t\\t}\\n\\n\\t\\treturn result == 0 ? -1 : result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n       \\tint result = 0;\\n\\t\\tchar[] crs = s.toCharArray();\\n\\n\\t\\tfor (int i = 0; i < crs.length; i++) {\\n\\t\\t\\tint index = i;\\n\\t\\t\\tString str = \"\";\\n\\t\\t\\tlong val = 0;\\n\\t\\t\\twhile (index < crs.length) {\\n\\t\\t\\t\\tstr = str + crs[index];\\n\\t\\t\\t\\tval = Long.parseLong(str);\\n\\t\\t\\t\\tif (val <= k) {\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (i == index) {\\n\\t\\t\\t\\tresult = -1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\ti = index - 1;\\n\\t\\t\\tresult++;\\n\\t\\t}\\n\\n\\t\\treturn result == 0 ? -1 : result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080512,
                "title": "clean-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int count=0;\\n        int i=0;\\n        string temp=\"\";\\n        while(i<s.size()){\\n            if(s[i]-\\'0\\'>k){\\n                return -1;\\n            }\\n            \\n            if(stoll(temp+s[i])>k){\\n                cout<<temp<<endl;\\n                temp=\"\";\\n                count++;\\n                i--;\\n            }\\n            else{\\n                temp+=s[i];\\n            }\\n            i++;\\n        }\\n        cout<<i<<endl;\\n        return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int count=0;\\n        int i=0;\\n        string temp=\"\";\\n        while(i<s.size()){\\n            if(s[i]-\\'0\\'>k){\\n                return -1;\\n            }\\n            \\n            if(stoll(temp+s[i])>k){\\n                cout<<temp<<endl;\\n                temp=\"\";\\n                count++;\\n                i--;\\n            }\\n            else{\\n                temp+=s[i];\\n            }\\n            i++;\\n        }\\n        cout<<i<<endl;\\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3077088,
                "title": "c-solution-greedy-method",
                "content": "\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n          long long c=1,sum=0,res=0;    \\n          for(int i=s.length()-1;i>=0;i--){\\n              int n=s[i]-48;\\n              sum+=c*n;\\n              if(sum>k){\\n                 res++;\\n                 sum=n;\\n                 c=10;\\n                 if(sum>k){return -1;}\\n              }\\n              else{\\n                  c*=10;\\n              }\\n          }  \\n          if(sum<=k&&sum>0){res++;}\\n          return res;\\n    }\\n    \\n    \\n    \\n   \\n    \\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n          long long c=1,sum=0,res=0;    \\n          for(int i=s.length()-1;i>=0;i--){\\n              int n=s[i]-48;\\n              sum+=c*n;\\n              if(sum>k){\\n                 res++;\\n                 sum=n;\\n                 c=10;\\n                 if(sum>k){return -1;}",
                "codeTag": "Java"
            },
            {
                "id": 3065893,
                "title": "c-greedy",
                "content": "# Intuition\\nWhy not try a greedy approach.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int count = 1;\\n        int i = 0;\\n        string t = \"\";\\n        while(i < s.size()){\\n            t.push_back(s[i]);\\n            long long val = stol(t);\\n            if(val > k){\\n                if(t.size() == 1) return -1;\\n                count++;\\n                t = \"\";\\n            }\\n            else i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int count = 1;\\n        int i = 0;\\n        string t = \"\";\\n        while(i < s.size()){\\n            t.push_back(s[i]);\\n            long long val = stol(t);\\n            if(val > k){\\n                if(t.size() == 1) return -1;\\n                count++;\\n                t = \"\";\\n            }\\n            else i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061025,
                "title": "c-greedy",
                "content": "# Intuition\\nGreedy seeking for the longest num $num$ starting from current position that has $num <= k$.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int len = s.length();\\n        string cur = \"0\";\\n        int cnt = 0;\\n        for (int i = 0; i < len; ++i) {\\n            int num = stoi(cur);\\n            cur.push_back(s[i]);\\n            if (stoll(cur) > k && num <= k) {\\n                ++cnt;\\n                cur = string(1, s[i]);\\n            } else if (num > k) {\\n                return -1;\\n            }\\n        }\\n        if (cur.length() > 0 && stoll(cur) > k) {\\n            return -1;\\n        }\\n        // cout << cnt << endl;\\n        return cnt + (cur.length() > 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int len = s.length();\\n        string cur = \"0\";\\n        int cnt = 0;\\n        for (int i = 0; i < len; ++i) {\\n            int num = stoi(cur);\\n            cur.push_back(s[i]);\\n            if (stoll(cur) > k && num <= k) {\\n                ++cnt;\\n                cur = string(1, s[i]);\\n            } else if (num > k) {\\n                return -1;\\n            }\\n        }\\n        if (cur.length() > 0 && stoll(cur) > k) {\\n            return -1;\\n        }\\n        // cout << cnt << endl;\\n        return cnt + (cur.length() > 0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3058277,
                "title": "easiest-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse the string and add in curr.\\nIf Curr becomes greater than K than divide the curr by 10. It means if we divide the Curr by 10 if we get number smaller than K then we will just Increase the count by 1. Otherwise we will return minus 1. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int count=0;\\n        long long int curr=0;\\n        for(auto it : s)\\n        {\\n           int d = it - \\'0\\';\\n           curr = curr*10 + d;\\n           if(curr>k)\\n           {\\n               curr /= 10; \\n               if(curr<=k) count++;\\n               else return -1;\\n               curr=d;\\n           }\\n        }\\n        if(curr>k) return -1;\\n        if(curr>0) count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int count=0;\\n        long long int curr=0;\\n        for(auto it : s)\\n        {\\n           int d = it - \\'0\\';\\n           curr = curr*10 + d;\\n           if(curr>k)\\n           {\\n               curr /= 10; \\n               if(curr<=k) count++;\\n               else return -1;\\n               curr=d;\\n           }\\n        }\\n        if(curr>k) return -1;\\n        if(curr>0) count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049706,
                "title": "short-easy-to-understand-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int c = 0;\\n        for(int i=0;i<s.length();i++){\\n            if((s[i]-\\'0\\')<=k){\\n                string s1=\"\";\\n                s1 += s[i];\\n                while(k >= stoll(s1) && i<s.length()){\\n                    i++;\\n                    s1 += s[i];\\n                }\\n                c++;\\n                i--;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int c = 0;\\n        for(int i=0;i<s.length();i++){\\n            if((s[i]-\\'0\\')<=k){\\n                string s1=\"\";\\n                s1 += s[i];\\n                while(k >= stoll(s1) && i<s.length()){\\n                    i++;\\n                    s1 += s[i];\\n                }\\n                c++;\\n                i--;\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042201,
                "title": "beginner-friendly-python-greedy-o-n",
                "content": "# Intuition\\nTwo pointer greedy solution\\n\\n# Approach\\n- L points to first char\\n- R points to second char which we keep on expanding (being greedy) \\n- We keep on expanding while the integer formed by substring of L and R is smaller than K, when it becomes larger we know the substring between L and R - 1 is the maximal good partition before we break the rule 2 of good partition\\n- We can instantly return -1 if at any point we run into a char/int which is greater than K, Example: \"189\" and K = 5, as soon as we see 8 we know no good partitions can be made and return -1\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the length of the string \"s\"\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        \\n        count = 0\\n        l, r = 0, 1\\n        \\n        while r <= len(s):\\n            if int(s[l]) <= k:\\n                while r <= len(s) and int(s[l:r + 1]) <= k:\\n                    r += 1\\n            else:\\n                return - 1\\n            count += 1\\n            l = r\\n            r += 1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        \\n        count = 0\\n        l, r = 0, 1\\n        \\n        while r <= len(s):\\n            if int(s[l]) <= k:\\n                while r <= len(s) and int(s[l:r + 1]) <= k:\\n                    r += 1\\n            else:\\n                return - 1\\n            count += 1\\n            l = r\\n            r += 1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041532,
                "title": "accepted-c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Since we have to minimize the number of substrings we will try to form the largest number smaller than or equal to k.\\n- If the number formed is equal to k, we will create a partition and start forming a new number.\\n- If the number formed is less than k, we will keep on adding the digits to the number.\\n- If the number formed is greater than k, we will create a partition and start forming a new number equal to the current digit. If the number formed is less than k, we return -1 else we move to the next digit.\\n- After traversing through all the digits, if the number is positive we increase our answer by 1.\\n\\n# Complexity\\n- Time complexity: O(length of the string)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int l) {\\n\\n        long long k = l;\\n        long long num=0, ans=0, n = s.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            num=num*10+(s[i]-\\'0\\');\\n            if(num==k){\\n                ans++;\\n                num=0;\\n            }\\n            else if(num>k){\\n                ans++;\\n                num=(s[i]-\\'0\\');\\n                if(num>k)\\n                    return -1;\\n            }\\n        }\\n        if(num)\\n            ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int l) {\\n\\n        long long k = l;\\n        long long num=0, ans=0, n = s.size();\\n\\n        for(int i=0;i<n;i++){\\n\\n            num=num*10+(s[i]-\\'0\\');\\n            if(num==k){\\n                ans++;\\n                num=0;\\n            }\\n            else if(num>k){\\n                ans++;\\n                num=(s[i]-\\'0\\');\\n                if(num>k)\\n                    return -1;\\n            }\\n        }\\n        if(num)\\n            ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036542,
                "title": "python-two-pointer",
                "content": "```\\ndef minimumPartition(self, s: str, k: int) -> int:\\n        l,r,re = len(s)-1,len(s),0\\n        while l>=0:\\n            while l >=0 and int(s[l:r]) <= k:\\n                l-=1\\n            if l < 0:\\n                break\\n            re+=1\\n            r=l+1\\n            if int(s[l:r]) > k:\\n                return -1\\n        return re+1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minimumPartition(self, s: str, k: int) -> int:\\n        l,r,re = len(s)-1,len(s),0\\n        while l>=0:\\n            while l >=0 and int(s[l:r]) <= k:\\n                l-=1\\n            if l < 0:\\n                break\\n            re+=1\\n            r=l+1\\n            if int(s[l:r]) > k:\\n                return -1\\n        return re+1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3033601,
                "title": "faster-than-90",
                "content": "```\\nimport java.util.*;\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        long num=0;\\n        int c=0;\\n        int i=0,j=0;\\n        while(j<s.length()){\\n            long xx=(long)s.charAt(j)-48;\\n            if(xx>k)return -1;\\n            num=num*10+xx;\\n            if(num<=k)j++;\\n            else{\\n                num=0;\\n                i=j;\\n                c++;\\n            }\\n        }\\n        if(j>=s.length() && Long.parseLong(s.substring(i,j))>k)return -1;\\n        else if(j>=s.length() && Long.parseLong(s.substring(i,j))<=k)c++;\\n        return c;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        long num=0;\\n        int c=0;\\n        int i=0,j=0;\\n        while(j<s.length()){\\n            long xx=(long)s.charAt(j)-48;\\n            if(xx>k)return -1;\\n            num=num*10+xx;\\n            if(num<=k)j++;\\n            else{\\n                num=0;\\n                i=j;\\n                c++;\\n            }\\n        }\\n        if(j>=s.length() && Long.parseLong(s.substring(i,j))>k)return -1;\\n        else if(j>=s.length() && Long.parseLong(s.substring(i,j))<=k)c++;\\n        return c;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3033433,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            if (s.charAt(i - 1) - \\'0\\' > k) {\\n                return -1;\\n            }\\n            dp[i] = Integer.MAX_VALUE;\\n            StringBuilder sb = new StringBuilder();\\n            for (int j = i - 1; j >= 0; j--) {\\n                sb.append(s.charAt(j));\\n                if (Long.valueOf(sb.reverse().toString()) > k) break;\\n                sb.reverse();\\n                 dp[i] = Math.min(dp[i], dp[j] + 1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            if (s.charAt(i - 1) - \\'0\\' > k) {\\n                return -1;\\n            }\\n            dp[i] = Integer.MAX_VALUE;\\n            StringBuilder sb = new StringBuilder();\\n            for (int j = i - 1; j >= 0; j--) {\\n                sb.append(s.charAt(j));\\n                if (Long.valueOf(sb.reverse().toString()) > k) break;\\n                sb.reverse();\\n                 dp[i] = Math.min(dp[i], dp[j] + 1);\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033148,
                "title": "easy-solution-basic-string-comparison-o-n-time-o-1-space",
                "content": "# Intuition\\nEasy problem using strings comparison\\n\\n# Approach\\nGenerated strings of size len(k) and len(k-1) as our partitions can only have these two lengths to get optimal answer. Perform string comparision and check wether to partition it or not \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n// Brute force check for single digits \\n        if(k<10){\\n          for(int i=0 ; i<s.size(); i++){\\n            if(s[i]-\\'0\\' > k) return -1; \\n          }\\n          return s.size(); \\n        }\\n      \\n      int n = s.size() ;\\n      int cnt = 0 ; \\n\\n      // Convert k to string(kk) for comparision\\n      string kk = to_string(k);\\n      int l = kk.size(); \\n      \\n      int i =0 ; \\n      int j=0 ; \\n      // x will contain the substrings \\n      string x = \"\";\\n\\n      // Start the while loop\\n      while(i<n){\\n        // j will track the curr length\\n        j++;\\n        // When j==l(k.size()), then we will compare it\\n        if(j==l){\\n          // Generate substring of length l from index i-l+1\\n          x = s.substr(i-l+1,l);\\n          // If x is bigger then we just have to go one index behind\\n          if(x>kk){\\n             i--;\\n          }\\n          // Keep j as 0 to resize it \\n          j=0;\\n          // increment cnt or partition\\n          cnt++; \\n          x = \"\";\\n        }\\n        i++;\\n      }\\n      // Edge case if any numbers are left or not traversed\\n      if(j!=0){\\n        cnt++; \\n      }\\n      \\n      return cnt; \\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n// Brute force check for single digits \\n        if(k<10){\\n          for(int i=0 ; i<s.size(); i++){\\n            if(s[i]-\\'0\\' > k) return -1; \\n          }\\n          return s.size(); \\n        }\\n      \\n      int n = s.size() ;\\n      int cnt = 0 ; \\n\\n      // Convert k to string(kk) for comparision\\n      string kk = to_string(k);\\n      int l = kk.size(); \\n      \\n      int i =0 ; \\n      int j=0 ; \\n      // x will contain the substrings \\n      string x = \"\";\\n\\n      // Start the while loop\\n      while(i<n){\\n        // j will track the curr length\\n        j++;\\n        // When j==l(k.size()), then we will compare it\\n        if(j==l){\\n          // Generate substring of length l from index i-l+1\\n          x = s.substr(i-l+1,l);\\n          // If x is bigger then we just have to go one index behind\\n          if(x>kk){\\n             i--;\\n          }\\n          // Keep j as 0 to resize it \\n          j=0;\\n          // increment cnt or partition\\n          cnt++; \\n          x = \"\";\\n        }\\n        i++;\\n      }\\n      // Edge case if any numbers are left or not traversed\\n      if(j!=0){\\n        cnt++; \\n      }\\n      \\n      return cnt; \\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030562,
                "title": "gridy-one-pass-93-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/8e62ef76-2e19-4cda-ad2c-b7e0c0f9830b_1673357765.5192747.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        digits = list(map(int, s))\\n        if max(digits) > k:\\n            return -1\\n        count = val = 0\\n        for d in digits:\\n            if (new_val := val * 10 + d) < k:\\n                val = new_val\\n            elif new_val == k:\\n                count += 1\\n                val = 0\\n            else:\\n                count += 1\\n                val = d\\n        return count + (val > 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        digits = list(map(int, s))\\n        if max(digits) > k:\\n            return -1\\n        count = val = 0\\n        for d in digits:\\n            if (new_val := val * 10 + d) < k:\\n                val = new_val\\n            elif new_val == k:\\n                count += 1\\n                val = 0\\n            else:\\n                count += 1\\n                val = d\\n        return count + (val > 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026644,
                "title": "python-video-walkthrough-time-o-n-space-o-1-6-line-solution",
                "content": "[Click Here For Video Walkthrough](    https://youtu.be/1AIvKJy80To)\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        c, p = 0, 1\\n        for x in map(int, s):\\n            if x > k: return -1\\n            c = 10 * c + x\\n            if c > k: p, c = p + 1, x \\n        return p\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        c, p = 0, 1\\n        for x in map(int, s):\\n            if x > k: return -1\\n            c = 10 * c + x\\n            if c > k: p, c = p + 1, x \\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025848,
                "title": "simple-easy-logic",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumPartition(string s, int k) {\\n        \\n        long value=0;\\n        int patition=0;\\n        for(int i=0;i<s.Length;i++)\\n        {\\n            value=value*10+s[i]-\\'0\\';\\n            if(s[i]-\\'0\\'>k) return -1;\\n            if(value>k)\\n            {\\n                patition++;\\n                value=s[i]-\\'0\\';\\n            } \\n        }\\n        if(value<=k) patition++;\\n        return patition;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumPartition(string s, int k) {\\n        \\n        long value=0;\\n        int patition=0;\\n        for(int i=0;i<s.Length;i++)\\n        {\\n            value=value*10+s[i]-\\'0\\';\\n            if(s[i]-\\'0\\'>k) return -1;\\n            if(value>k)\\n            {\\n                patition++;\\n                value=s[i]-\\'0\\';\\n            } \\n        }\\n        if(value<=k) patition++;\\n        return patition;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023072,
                "title": "greedy-2-ponter-approach-fast-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nobviously we can\\'t go over the length of k for a single partition .\\nso a single partition can be between length of 1 and log10(k)+1.\\nif length of a partion is 0 then we must return -1\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind function finds max partition length we can achieve from a given starting point considering that number formed in the partition is not grater than k.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) auxilary space.\\n# Code\\n```\\nclass Solution {\\npublic:\\nint find(string &s,int &k , int j){\\n    int count=0;\\n    long long num=s[j]-\\'0\\';\\n    j++;\\n    while(j<=s.size() && num<=k){\\n        if(j<s.size())\\n        num= num*10 + (s[j]-\\'0\\');\\n        count++;\\n        j++;\\n    }\\n    return count;\\n}\\n    int minimumPartition(string s, int k) {\\n       int i=0;\\n  int ans=0;\\n       while(i<s.size()){\\nint x=find(s,k,i);\\nif(x==0)\\nreturn -1;\\nans++;\\ni+=x;\\n       }\\n\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint find(string &s,int &k , int j){\\n    int count=0;\\n    long long num=s[j]-\\'0\\';\\n    j++;\\n    while(j<=s.size() && num<=k){\\n        if(j<s.size())\\n        num= num*10 + (s[j]-\\'0\\');\\n        count++;\\n        j++;\\n    }\\n    return count;\\n}\\n    int minimumPartition(string s, int k) {\\n       int i=0;\\n  int ans=0;\\n       while(i<s.size()){\\nint x=find(s,k,i);\\nif(x==0)\\nreturn -1;\\nans++;\\ni+=x;\\n       }\\n\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020898,
                "title": "python-greedy",
                "content": "```\\nclass Solution(object):\\n    def minimumPartition(self, s, k):\\n        max_num = 0\\n        ans = 0\\n        for num in s:\\n            max_num = max_num * 10 + int(num)\\n            if max_num > k:\\n                ans += 1\\n                max_num = 0\\n                max_num = max_num * 10 + int(num)\\n                if max_num > k:\\n                    return -1\\n        if max_num > 0: \\n            ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumPartition(self, s, k):\\n        max_num = 0\\n        ans = 0\\n        for num in s:\\n            max_num = max_num * 10 + int(num)\\n            if max_num > k:\\n                ans += 1\\n                max_num = 0\\n                max_num = max_num * 10 + int(num)\\n                if max_num > k:\\n                    return -1\\n        if max_num > 0: \\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016312,
                "title": "c-greedy-parsing-100-time-4ms-80-space-8-9mb",
                "content": "This problem has two base scenarios:\\n* if `k` is only one digit, then we will either fail as soon as we find a digit `> k` or `return` the length of `s` if all digits in it are `<= k`;\\n* if `k > 9`, then we know we can always get a valid number (ie: using at least one digit) and so we will have to proceed with a greedy approach and keep growing a number until it is `<= k`, bumping a counter and resetting the number we are growing as soon as we grow too big.\\n\\nThe first case is trivial to code, parsing every character `c` in `s` and:\\n* turning it into a digit subtracting `\\'0\\'` from it;\\n* checking if said digit is `> k`, in which case we `return` `-1`.\\n\\nIf we reach the end of the loop, we know that it takes `s.size()` characters to match the requirements of the problem, so we can stop right there. \\n\\nTo solve the second case, we will first need a few support variables:\\n* `res` is our usual accumulator variable, initially set to `1` (we will always have at least one valid number);\\n* `i` will be our parsing pointer, initially set to `0` (first character);\\n* `len` will store the length of `s`;\\n* `c` will store the current digit;\\n* `n` and `nxt` will respectively store the current and next number we are growing, with the first preset to `0`.\\n\\nWe will then go on parsing `s` `while` `i < len` and:\\n* assign the value of the current digit (ie: `s[i] - \\'0\\'`) to `c`;\\n* advance `i` by `1` position;\\n* compute `nxt` as `n` attaching `c` as its next digit (ie: `n * 10 + c`);\\n* then we will face two case:\\n    * if `nxt > k`, we will:\\n        * increase `res` by `1` (note that we are just counting how many substrings with value `< k` we started, so we will never have to do extra check when `i` reaches the end of the line);\\n        * reset `n` to be just `c`;\\n    * otherwise, we will just set `n` to the value of `n` and get ready to iterate again.\\n\\nOnce done, we can just `return` `res`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        // edge case, single digit k\\n        if (k < 10) {\\n            // parsing s to find a digit > k\\n            for (char c: s) {\\n                c -= \\'0\\';\\n                if (c > k) return -1; \\n            }\\n            return s.size();\\n        }\\n        // support variables\\n        int res = 1, i = 0, len = s.size();\\n        long c, n = 0, nxt;\\n        // parsing s\\n        while (i < len) {\\n            c = s[i++] - \\'0\\', nxt = n * 10 + c;\\n            // first case: nxt > k\\n            if (nxt > k) res++, n = c;\\n            // second case: nxt still <= k\\n            else n = nxt;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image.png](https://assets.leetcode.com/users/images/adfec345-5efa-4c76-a777-8c815f969af8_1673139043.2438595.png)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        // edge case, single digit k\\n        if (k < 10) {\\n            // parsing s to find a digit > k\\n            for (char c: s) {\\n                c -= \\'0\\';\\n                if (c > k) return -1; \\n            }\\n            return s.size();\\n        }\\n        // support variables\\n        int res = 1, i = 0, len = s.size();\\n        long c, n = 0, nxt;\\n        // parsing s\\n        while (i < len) {\\n            c = s[i++] - \\'0\\', nxt = n * 10 + c;\\n            // first case: nxt > k\\n            if (nxt > k) res++, n = c;\\n            // second case: nxt still <= k\\n            else n = nxt;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014333,
                "title": "simple-greedy-approach",
                "content": "Logic-> We need minimum partition so always create maximum length partition.\\nCase -> 1 If digit is greater than k then there is no valid partition.\\nCase -> 2 If current substring value exeeds k then increment res by one. else add this digit in current\\n\\t\\t\\t\\t  substring\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        \\n        int res=1;\\n        long cur =0;\\n        for(int i=0;i<s.length();i++){\\n            \\n            cur = cur*10+(long)(s[i]-\\'0\\');\\n            // case 1\\n            if((int(s[i]-\\'0\\'))>k)return -1;\\n            else if(cur>k){\\n                \\n                cur = s[i]-\\'0\\';\\n                res++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        \\n        int res=1;\\n        long cur =0;\\n        for(int i=0;i<s.length();i++){\\n            \\n            cur = cur*10+(long)(s[i]-\\'0\\');\\n            // case 1\\n            if((int(s[i]-\\'0\\'))>k)return -1;\\n            else if(cur>k){\\n                \\n                cur = s[i]-\\'0\\';\\n                res++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013802,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long n=s.size(),ref=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            ref=ref*10+(s[i]-\\'0\\');\\n            if(ref>k || i==n-1){\\n                if(i==n-1) {\\n                    if(ref<=k)  ans++;\\n                    else if(s[i]-\\'0\\'<=k) ans+=2;\\n                    else return -1;\\n                    break;\\n                }\\n                ans++;\\n                ref=s[i]-\\'0\\';\\n                if(ref>k) return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        long long n=s.size(),ref=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            ref=ref*10+(s[i]-\\'0\\');\\n            if(ref>k || i==n-1){\\n                if(i==n-1) {\\n                    if(ref<=k)  ans++;\\n                    else if(s[i]-\\'0\\'<=k) ans+=2;\\n                    else return -1;\\n                    break;\\n                }\\n                ans++;\\n                ref=s[i]-\\'0\\';\\n                if(ref>k) return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011251,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        \\n        long temp=0;\\n        int tempans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int x=Character.getNumericValue(s.charAt(i));\\n            if(x>k)\\n            {\\n                return -1;\\n            }\\n            temp=temp*10+x;\\n            if(temp>(long)k)\\n            {\\n                tempans++;\\n                temp=x;\\n            }\\n        }\\n        return tempans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumPartition(String s, int k) {\\n        \\n        long temp=0;\\n        int tempans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int x=Character.getNumericValue(s.charAt(i));\\n            if(x>k)\\n            {\\n                return -1;\\n            }\\n            temp=temp*10+x;\\n            if(temp>(long)k)\\n            {\\n                tempans++;\\n                temp=x;\\n            }\\n        }\\n        return tempans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1737943,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1736260,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1736145,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1740613,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 2066200,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1965903,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1803506,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1759678,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1748682,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1738850,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1737943,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1736260,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1736145,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1740613,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 2066200,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1965903,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1803506,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1759678,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1748682,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            },
            {
                "id": 1738850,
                "content": [
                    {
                        "username": "yash_vish87",
                        "content": "I think, In the question, it didn't explained better the meaning of good string. For example - take example number 2. It is difficult to understand the reason. At least for me it is. There must be explanation that we cannot skip any character to make the partitions as a good string. \n"
                    },
                    {
                        "username": "xyhlinx",
                        "content": "I think the difficult part is to prove why greedy can work"
                    },
                    {
                        "username": "user2171GQ",
                        "content": "Imagine a recurrence like in dynamic programming.\n```py\n# dp(i) is the answer for substring s[i:]\ndp(i) = 1 + dp(i+len(first_partition))\n```\nWe need to minimize the answer which is dp(0). But dp(0) is just 1 + dp(start_of_second_partition). dp(start_of_second_partition) is the answer for some suffix substring. We prove that minimizing the length of the suffix substring is optimal by contradiction.\n\nSuppose we have a longer suffix substring which can be broken into fewer partitions than a shorter suffix substring. The partitions from the longer suffix substring could then be applied to the shorter suffix substring and then the number of partitions in the shorter substring is less than or equal the partitions in the larger, contradicting that it was greater.\n\nAnd so a shorter suffix substring is always optimal. Always take as many characters as you can on the first move, and any move after that too.\n\nDuring the contest I thought like this - you take as many characters as you can, because if you didn't, you would eventually end up in the same place as if you did, just with more moves."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just found out its GREEDY \\uD83D\\uDE05\\nI\\'ve been trying to do it using DP this whole time."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@user0098an](/user0098an) I believe you designed an exceptionally well dp solution for this problem. For me my DP solutions were getting failed for some test cases, no matter how much I modify it. "
                    },
                    {
                        "username": "user0098an",
                        "content": "[@user0098an](/user0098an) wait TLE goes away when i added a check on the length of the substring, if >10, then can break out of loop coz the max k is 10**9 which is 10 digits "
                    },
                    {
                        "username": "user0098an",
                        "content": "DP also works and will guarantee optimality unlike greedy that needs proof, but my DP ( in Python) is TLE tho..."
                    },
                    {
                        "username": "lucky9174",
                        "content": "My solution was accepted at the time of contest but why now it is showing as wrong answer\\n ```class Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int n = s.size();\\n        int res = 1;\\n        string temp = \"\";\\n        temp += s[0];\\n        for(int i=1; i<n; i++){\\n            if(stoi(temp) <= k && stoll(temp+s[i]) > k){\\n                res++;\\n                temp = \"\";\\n                temp += s[i];\\n                continue;\\n            }\\n            if(stoll(temp) > k && temp.size() == 1){\\n                return -1;\\n            }\\n            if(stoll(temp+s[i]) <= k){\\n                temp += s[i];\\n                continue;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};```"
                    },
                    {
                        "username": "yash_vish87",
                        "content": "You have used stoll, thats causing the issue for the test case that you are talking about. Even I did the same mistake when I have written the code in c++. \\n"
                    },
                    {
                        "username": "xyqfountain",
                        "content": "\"Each digit of s is part of exactly one substring.\" This is misleading.  My understanding is: (1) you cannot skip any digit; and (2) a digit can appear in only one substring, i.e., a substring cannot have duplicated digits."
                    },
                    {
                        "username": "madpoly",
                        "content": "dont understand one thing. Ex one, it takes the last 2 digits seperately. Why cant we then say every single character in s which is <= k is a valid condition then? So we could say every character in s in example 1 is  also a valid substring since for some reason 6 and 2 were used individually in the final one..."
                    },
                    {
                        "username": "mahi_5902",
                        "content": "anyone can tell other than greedy??"
                    },
                    {
                        "username": "minhbear",
                        "content": "Hello everyone, I want to update my solution for help another people to understand how to solve this problem but I can not :((. So I will give you kink github that is direct you into folder we I solve this problem, I have txt file to describe why and how to solve this probelm, I you feel good please give me a star :>>\n\nLink: https://github.com/ResupFPT/leetcode---Algorithm/tree/main/Dynamic%20Progamming/2522%20Partition%20String%20Into%20Substrings%20With%20Values%20at%20Most%20K\n\n#c++, #dp"
                    },
                    {
                        "username": "dutchsplit88",
                        "content": "How does the first example satisfy the condition  `Each digit of s is part of exactly one substring.`?"
                    },
                    {
                        "username": "charonme",
                        "content": "this condition means you have to partition the whole string, you can\\'t leave any part of the string unpartitioned, for example partitioning \"12345\" into \"12\",\"45\" breaks this condition because the \"3\" is left out unpartitioned."
                    },
                    {
                        "username": "SUMITZET",
                        "content": "The problem description is ambiguous as it says -\\n\\n\"Each digit of s is part of exactly one substring.\"\\nI should be what you said."
                    },
                    {
                        "username": "spewmaker",
                        "content": "each character in the string can only be a part of one substring, -> \"16\", \"54\", \"6\", and \"2\"\\nincorrect example -> \"165\", \"546\", \"6\", and \"2\", here the \"5\", \"6\" are occurring in 2 substrings.\\nhope that made sense"
                    },
                    {
                        "username": "close27",
                        "content": "Solved after I realized that the max size of substring is the number of digits in k."
                    }
                ]
            }
        ]
    }
]