[
    {
        "title": "Push Dominoes",
        "question_content": "There are n dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\nFor the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\nYou are given a string dominoes representing the initial state where:\n\n\tdominoes[i] = 'L', if the ith domino has been pushed to the left,\n\tdominoes[i] = 'R', if the ith domino has been pushed to the right, and\n\tdominoes[i] = '.', if the ith domino has not been pushed.\n\nReturn a string representing the final state.\n&nbsp;\nExample 1:\n\nInput: dominoes = \"RR.L\"\nOutput: \"RR.L\"\nExplanation: The first domino expends no additional force on the second domino.\n\nExample 2:\n\nInput: dominoes = \".L.R...LR..L..\"\nOutput: \"LL.RR.LLRRLL..\"\n\n&nbsp;\nConstraints:\n\n\tn == dominoes.length\n\t1 <= n <= 105\n\tdominoes[i] is either 'L', 'R', or '.'.",
        "solutions": [
            {
                "id": 132332,
                "title": "java-c-python-two-pointers",
                "content": "# **Intuition**:\\nWhether be pushed or not, depend on the shortest distance to \\'L\\' and \\'R\\'.\\nAlso the direction matters.\\nBase on this idea, you can do the same thing inspired by this problem.\\nhttps://leetcode.com/problems/shortest-distance-to-a-character/discuss/125788/\\n\\nHere is another idea is focus on only \\'L\\' and \\'R\\'.\\n<br>\\n\\n# **Complexity**:\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public String pushDominoes(String d) {\\n        d = \\'L\\' + d + \\'R\\';\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0, j = 1; j < d.length(); ++j) {\\n            if (d.charAt(j) == \\'.\\') continue;\\n            int middle = j - i - 1;\\n            if (i > 0)\\n                res.append(d.charAt(i));\\n            if (d.charAt(i) == d.charAt(j))\\n                for (int k = 0; k < middle; k++)\\n                    res.append(d.charAt(i));\\n            else if (d.charAt(i) == \\'L\\' && d.charAt(j) == \\'R\\')\\n                for (int k = 0; k < middle; k++)\\n                    res.append(\\'.\\');\\n            else {\\n                for (int k = 0; k < middle / 2; k++)\\n                    res.append(\\'R\\');\\n                if (middle % 2 == 1)\\n                    res.append(\\'.\\');\\n                for (int k = 0; k < middle / 2; k++)\\n                    res.append(\\'L\\');\\n            }\\n            i = j;\\n        }\\n        return res.toString();\\n    }\\n```\\n**C++:**\\n```cpp\\n    string pushDominoes(string d) {\\n        d = \\'L\\' + d + \\'R\\';\\n        string res = \"\";\\n        for (int i = 0, j = 1; j < d.length(); ++j) {\\n            if (d[j] == \\'.\\') continue;\\n            int middle = j - i - 1;\\n            if (i > 0)\\n                res += d[i];\\n            if (d[i] == d[j])\\n                res += string(middle, d[i]);\\n            else if (d[i] == \\'L\\' && d[j] == \\'R\\')\\n                res += string(middle, \\'.\\');\\n            else\\n                res += string(middle / 2, \\'R\\') + string(middle % 2, \\'.\\') + string(middle / 2, \\'L\\');\\n            i = j;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def pushDominoes(self, d):\\n        d = \\'L\\' + d + \\'R\\'\\n        res = \"\"\\n        i = 0\\n        for j in range(1, len(d)):\\n            if d[j] == \\'.\\':\\n                continue\\n            middle = j - i - 1\\n            if i:\\n                res += d[i]\\n            if d[i] == d[j]:\\n                res += d[i] * middle\\n            elif d[i] == \\'L\\' and d[j] == \\'R\\':\\n                res += \\'.\\' * middle\\n            else:\\n                res += \\'R\\' * (middle / 2) + \\'.\\' * (middle % 2) + \\'L\\' * (middle / 2)\\n            i = j\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public String pushDominoes(String d) {\\n        d = \\'L\\' + d + \\'R\\';\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0, j = 1; j < d.length(); ++j) {\\n            if (d.charAt(j) == \\'.\\') continue;\\n            int middle = j - i - 1;\\n            if (i > 0)\\n                res.append(d.charAt(i));\\n            if (d.charAt(i) == d.charAt(j))\\n                for (int k = 0; k < middle; k++)\\n                    res.append(d.charAt(i));\\n            else if (d.charAt(i) == \\'L\\' && d.charAt(j) == \\'R\\')\\n                for (int k = 0; k < middle; k++)\\n                    res.append(\\'.\\');\\n            else {\\n                for (int k = 0; k < middle / 2; k++)\\n                    res.append(\\'R\\');\\n                if (middle % 2 == 1)\\n                    res.append(\\'.\\');\\n                for (int k = 0; k < middle / 2; k++)\\n                    res.append(\\'L\\');\\n            }\\n            i = j;\\n        }\\n        return res.toString();\\n    }\\n```\n```cpp\\n    string pushDominoes(string d) {\\n        d = \\'L\\' + d + \\'R\\';\\n        string res = \"\";\\n        for (int i = 0, j = 1; j < d.length(); ++j) {\\n            if (d[j] == \\'.\\') continue;\\n            int middle = j - i - 1;\\n            if (i > 0)\\n                res += d[i];\\n            if (d[i] == d[j])\\n                res += string(middle, d[i]);\\n            else if (d[i] == \\'L\\' && d[j] == \\'R\\')\\n                res += string(middle, \\'.\\');\\n            else\\n                res += string(middle / 2, \\'R\\') + string(middle % 2, \\'.\\') + string(middle / 2, \\'L\\');\\n            i = j;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def pushDominoes(self, d):\\n        d = \\'L\\' + d + \\'R\\'\\n        res = \"\"\\n        i = 0\\n        for j in range(1, len(d)):\\n            if d[j] == \\'.\\':\\n                continue\\n            middle = j - i - 1\\n            if i:\\n                res += d[i]\\n            if d[i] == d[j]:\\n                res += d[i] * middle\\n            elif d[i] == \\'L\\' and d[j] == \\'R\\':\\n                res += \\'.\\' * middle\\n            else:\\n                res += \\'R\\' * (middle / 2) + \\'.\\' * (middle % 2) + \\'L\\' * (middle / 2)\\n            i = j\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2628923,
                "title": "c-two-pointer-diagram-related-problems",
                "content": "**Approach**\\n1. If we encounter `.` in string, we move forward to next index.\\n2. If we encounter `L` in string, we see if index of right is -1, we make all the left index `L` until we see any other `L`.\\n2. If we encounter `L` in string and there is some previous `R` index, then we simultaneously change string from left and right side till two pointers reach each other. After that `right` moves back to `-1`.\\n3. If we encounter `R` in string, we see if the index of `R` is not -1, we make all the indices upto that index `R`.\\n\\n**Diagram Explanation**\\n\\n![image](https://assets.leetcode.com/users/images/ffb493fa-7b64-4859-8aa0-e2cf78d5a2bf_1664247243.6077156.png)\\n\\n![image](https://assets.leetcode.com/users/images/11608e78-545d-435f-afb1-d824948f13d9_1664247249.2657273.png)\\n\\n**Explanation of steps** \\nIn **step 8**, we encountered `L`, so first thing we check if index of previous `right` is not `-1`. Here `right` is `3`, so we started making `R` from index 4 onwards  and simultaneously started making `L` from index `7` in backward direction. We will stop if left and right pointer arrives at same point. After than, we send right to -1 until we find another `R` in string.\\n\\n**C++ Code**\\n\\n```cpp\\nstring pushDominoes(string s) {\\n    int N = s.size(), right = -1;\\n    for (int i = 0; i < N; ++i) {\\n        if (s[i] == \\'L\\') {\\n            if (right == -1) { \\n                // Step 2\\n                for (int j = i - 1; j >= 0 && s[j] == \\'.\\'; --j) {\\n                  s[j] = \\'L\\';  \\n                } \\n            } else {\\n                // Step 8\\n                for (int j = right + 1, k = i - 1; j < k; ++j, --k) {\\n                    s[j] = \\'R\\';\\n                    s[k] = \\'L\\';\\n                } \\n                right = -1;\\n            }\\n        } else if (s[i] == \\'R\\') {\\n            if (right != -1) {\\n                for (int j = right + 1; j < i; ++j) s[j] = \\'R\\';\\n            }\\n            right = i;\\n        }\\n    }\\n    if (right != -1) {\\n        for (int j = right + 1; j < N; ++j) s[j] = \\'R\\';\\n    }\\n    return s;\\n}\\n```\\n\\n**Related Problems - Two Pointer**\\n[1. Two Sum ](https://leetcode.com/problems/two-sum/)\\n[2. Container With Most Water ](https://leetcode.com/problems/container-with-most-water/)\\n[3. 3Sum ](https://leetcode.com/problems/3sum/)\\n[4. Minimum Window Substring ](https://leetcode.com/problems/minimum-window-substring/)\\n[5. Remove Duplicates from Sorted List ](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)\\n[6. Reorder List ](https://leetcode.com/problems/reorder-list/)\\n[7. Maximum Product Subarray ](https://leetcode.com/problems/maximum-product-subarray/)\\n[8. Palindrome Linked List ](https://leetcode.com/problems/palindrome-linked-list/)\\n[9. Subarray Product Less Than K ](https://leetcode.com/problems/subarray-product-less-than-k/)\\n[10. Backspace String Compare ](https://leetcode.com/problems/backspace-string-compare/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nstring pushDominoes(string s) {\\n    int N = s.size(), right = -1;\\n    for (int i = 0; i < N; ++i) {\\n        if (s[i] == \\'L\\') {\\n            if (right == -1) { \\n                // Step 2\\n                for (int j = i - 1; j >= 0 && s[j] == \\'.\\'; --j) {\\n                  s[j] = \\'L\\';  \\n                } \\n            } else {\\n                // Step 8\\n                for (int j = right + 1, k = i - 1; j < k; ++j, --k) {\\n                    s[j] = \\'R\\';\\n                    s[k] = \\'L\\';\\n                } \\n                right = -1;\\n            }\\n        } else if (s[i] == \\'R\\') {\\n            if (right != -1) {\\n                for (int j = right + 1; j < i; ++j) s[j] = \\'R\\';\\n            }\\n            right = i;\\n        }\\n    }\\n    if (right != -1) {\\n        for (int j = right + 1; j < N; ++j) s[j] = \\'R\\';\\n    }\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352339,
                "title": "c-simple-and-clean-easy-to-understand-o-n-solution-with-detailed-explanation",
                "content": "**Explanation:**\\nFirst, we iterate the dominoes twice.\\n1. From left to right, we want to check which dominoes might be falling to the right side.\\n\\tSo every time we see a \\'R\\' we know that the next dominoes will maybe fall right, so we save in the \\'right\\' vector the distance from the previous \\'R\\'. (Until we reach a \\'L\\').\\n2. From right to left, we do the same for the left side.\\nExample:\\nLet\\'s use the second example from the question - \".L.R...LR..L..\".\\nThe \\'right\\' array will look like this: [0,0,0,0,1,2,3,0,0,1,2,0,0,0]\\nThe \\'left\\' array will look like this: [1,0,0,0,3,2,1,0,0,2,1,0,0,0]\\n\\nNext step is to compare \\'right and \\'left\\'.\\nFor each i:\\n1. If both are 0 - we just copy what we had in dominoes.\\n2. If right[i] is 0 but left[i] is not, it means this domino falls to the left, and vice versa.\\n3. if they are both equal, which means that we have balance of the forces and we stay vertical.\\n4. If we have to different values in right[i] and left[i], we find the minimum which means that it\\'s closer.\\n\\n**If you like it, please upvote!\\nHave any comments? I\\'d love to hear!**\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        #define SET(ch, arr) \\\\\\n                    if (dominoes[i] == ch) { count = 1; prev = ch; } \\\\\\n                    else if (dominoes[i] != \\'.\\') prev = dominoes[i]; \\\\\\n                    if (prev == ch && dominoes[i] == \\'.\\') arr[i] = count++;\\n        \\n        string res = \"\";\\n        char prev;\\n        int n = dominoes.size(), count = 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            SET(\\'R\\', right);\\n        }\\n        \\n        prev = \\'.\\';\\n        for (int i = n-1; i >= 0; i--) {\\n            SET(\\'L\\', left);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!left[i] && !right[i]) res += dominoes[i];\\n            else if (!left[i]) res += \\'R\\';\\n            else if (!right[i]) res += \\'L\\';\\n            else if (left[i] == right[i]) res += \\'.\\';\\n            else if (left[i] < right[i]) res += \\'L\\';\\n            else res += \\'R\\';\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        #define SET(ch, arr) \\\\\\n                    if (dominoes[i] == ch) { count = 1; prev = ch; } \\\\\\n                    else if (dominoes[i] != \\'.\\') prev = dominoes[i]; \\\\\\n                    if (prev == ch && dominoes[i] == \\'.\\') arr[i] = count++;\\n        \\n        string res = \"\";\\n        char prev;\\n        int n = dominoes.size(), count = 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            SET(\\'R\\', right);\\n        }\\n        \\n        prev = \\'.\\';\\n        for (int i = n-1; i >= 0; i--) {\\n            SET(\\'L\\', left);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!left[i] && !right[i]) res += dominoes[i];\\n            else if (!left[i]) res += \\'R\\';\\n            else if (!right[i]) res += \\'L\\';\\n            else if (left[i] == right[i]) res += \\'.\\';\\n            else if (left[i] < right[i]) res += \\'L\\';\\n            else res += \\'R\\';\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132482,
                "title": "java-one-pass-in-place-13ms",
                "content": "Keep track of last seen \\'L\\' and \\'R\\' as indices (variables L and R).\\n1. If you see \\'R\\' and R > L, you have R....R, turn everything to \\'R\\'.\\n2. If you see \\'R\\' and R < L, you have L...R and you don\\'t need to do anything.\\n3. If you see \\'L\\' and L > R, you have L....L, turn everything to \\'L\\'.\\n4. if you see \\'L\\' and L < R, you have R....L, have to pointers from both sides, lo and hi, turn a[lo]=\\'R\\' and a[hi] = \\'L\\', increment lo, decrement hi, make sure you do nothing when lo=hi\\n5. Watch out for edge cases. Note i<=dominoes.length(), this is to deal with L.. Also note L and R are initialized to -1, not 0.\\n```java\\npublic String pushDominoes(String dominoes) {\\n        char[] a = dominoes.toCharArray();\\n        for (int i = 0, L = -1, R = -1; i <= dominoes.length(); i++)\\n            if (i == a.length || a[i] == \\'R\\') {\\n                if (R > L)//R..R, turn all to R\\n                    while (R < i)\\n                        a[R++] = \\'R\\';\\n                R = i;\\n            } else if (a[i] == \\'L\\')\\n                if (L > R || R == -1)//L..L, turn all to L\\n                    while (++L < i)\\n                        a[L] = \\'L\\';\\n                else { //R...L\\n                    L = i;\\n                    for (int lo = R + 1, hi = L - 1; lo < hi; ) {//one in the middle stays \\'.\\'\\n                        a[lo++] = \\'R\\';\\n                        a[hi--] = \\'L\\';\\n                    }\\n                }\\n        return new String(a);\\n    }",
                "solutionTags": [],
                "code": "Keep track of last seen \\'L\\' and \\'R\\' as indices (variables L and R).\\n1. If you see \\'R\\' and R > L, you have R....R, turn everything to \\'R\\'.\\n2. If you see \\'R\\' and R < L, you have L...R and you don\\'t need to do anything.\\n3. If you see \\'L\\' and L > R, you have L....L, turn everything to \\'L\\'.\\n4. if you see \\'L\\' and L < R, you have R....L, have to pointers from both sides, lo and hi, turn a[lo]=\\'R\\' and a[hi] = \\'L\\', increment lo, decrement hi, make sure you do nothing when lo=hi\\n5. Watch out for edge cases. Note i<=dominoes.length(), this is to deal with L.. Also note L and R are initialized to -1, not 0.\\n```java\\npublic String pushDominoes(String dominoes) {\\n        char[] a = dominoes.toCharArray();\\n        for (int i = 0, L = -1, R = -1; i <= dominoes.length(); i++)\\n            if (i == a.length || a[i] == \\'R\\') {\\n                if (R > L)//R..R, turn all to R\\n                    while (R < i)\\n                        a[R++] = \\'R\\';\\n                R = i;\\n            } else if (a[i] == \\'L\\')\\n                if (L > R || R == -1)//L..L, turn all to L\\n                    while (++L < i)\\n                        a[L] = \\'L\\';\\n                else { //R...L\\n                    L = i;\\n                    for (int lo = R + 1, hi = L - 1; lo < hi; ) {//one in the middle stays \\'.\\'\\n                        a[lo++] = \\'R\\';\\n                        a[hi--] = \\'L\\';\\n                    }\\n                }\\n        return new String(a);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2628891,
                "title": "python3-7-lines-with-explanation-t-m-100-98",
                "content": "```\\nclass Solution:         # States for the dominoes:\\n                        #   \\u2022 Any triplet that reaches the state \\'R.L\\' remains\\n                        #     that state permanently.\\n                        #  \\n                        #   \\u2022 These changes occur to pairs that are not part of an \\'R.L\\':\\n                        #     \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\'\\n\\n                        #  Here\\'s the plan:\\n                        #    1) To avoid the problem with the \\'R.L\\' state when we  address the \\n\\t\\t\\t\\t\\t\\t#       \\'R.\\' --> \\'RR\\' and  \\'.L\\' --> \\'LL\\' changes, we replace each \\'R.L\\' \\n\\t\\t\\t\\t\\t\\t#.       with a dummy string (say, \\'xxx\\').\\n                        #       \\n                        #    2) We perform the \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\' replacements.\\n\\n                        #    3) Once the actions described in 1) and 2) are completed, we repeat \\n                        #       until no changes occur. We replace the dummy string with \\'R.L\\'. \\n    def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       # <-- 1)\\n            dominoes = dominoes.replace(\\'R.\\', \\'RR\\')         # <-- 2)\\n            dominoes = dominoes.replace(\\'.L\\', \\'LL\\')         # <-- 2)\\n\\n        return  dominoes.replace(\\'xxx\\', \\'R.L\\')              # <-- 3)\\n```\\n\\n[https://leetcode.com/submissions/detail/664004716/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:         # States for the dominoes:\\n                        #   \\u2022 Any triplet that reaches the state \\'R.L\\' remains\\n                        #     that state permanently.\\n                        #  \\n                        #   \\u2022 These changes occur to pairs that are not part of an \\'R.L\\':\\n                        #     \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\'\\n\\n                        #  Here\\'s the plan:\\n                        #    1) To avoid the problem with the \\'R.L\\' state when we  address the \\n\\t\\t\\t\\t\\t\\t#       \\'R.\\' --> \\'RR\\' and  \\'.L\\' --> \\'LL\\' changes, we replace each \\'R.L\\' \\n\\t\\t\\t\\t\\t\\t#.       with a dummy string (say, \\'xxx\\').\\n                        #       \\n                        #    2) We perform the \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\' replacements.\\n\\n                        #    3) Once the actions described in 1) and 2) are completed, we repeat \\n                        #       until no changes occur. We replace the dummy string with \\'R.L\\'. \\n    def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       # <-- 1)\\n            dominoes = dominoes.replace(\\'R.\\', \\'RR\\')         # <-- 2)\\n            dominoes = dominoes.replace(\\'.L\\', \\'LL\\')         # <-- 2)\\n\\n        return  dominoes.replace(\\'xxx\\', \\'R.L\\')              # <-- 3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132330,
                "title": "funny-idea-but-passed-within-time-limit-python",
                "content": "I think the code is self-explanatory: just imaging what would happen in each turn.\\n```\\nclass Solution(object):\\n    def pushDominoes(self, dominoes):\\n        \"\"\"\\n        :type dominoes: str\\n        :rtype: str\\n        \"\"\"\\n        while(True):\\n            new = dominoes.replace(\\'R.L\\', \\'S\\')\\n            new = new.replace(\\'.L\\',\\'LL\\').replace(\\'R.\\',\\'RR\\')\\n            if new == dominoes:\\n                break\\n            else:\\n                dominoes = new\\n        return dominoes.replace(\\'S\\', \\'R.L\\')\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pushDominoes(self, dominoes):\\n        \"\"\"\\n        :type dominoes: str\\n        :rtype: str\\n        \"\"\"\\n        while(True):\\n            new = dominoes.replace(\\'R.L\\', \\'S\\')\\n            new = new.replace(\\'.L\\',\\'LL\\').replace(\\'R.\\',\\'RR\\')\\n            if new == dominoes:\\n                break\\n            else:\\n                dominoes = new\\n        return dominoes.replace(\\'S\\', \\'R.L\\')\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 787845,
                "title": "o-n-c-easy-solution-90",
                "content": "This is a beautiful solution, which took me some time to think. This solution is very easy to understand with the O(N) solution. \\nI have used the 2-pointer technique to solve this question.\\n**Code Implementation:**\\nLet us consider the Eg. \" . L . R . . . L R . . L . . \"\\nSo, we will iterate the string twice,\\nIn first iteration, we iterate from left to right, Therefore, when we encounter \\'R\\',  that means it will make the next domino fall towards right (If it was a \\' . \\').\\nLet us use an array to store the count of dominoes which may fall towards right,\\nAfter first Iteration, the \\'r\\' array will be \\n .  L  .  R  .  .  .  L R  .  .  L  .  . \\n0  0 0 0  1 2 3 0 0  1 2 0  0 0\\n\\nNow, in our second iteration, we travel the string from right to left, therefore, we mark all the \\' . \\'s if they have a tendency to fall towards left\\n .  L  .  R  .  .  .  L R  .  .  L  .  . \\n1  0 0 0  3 2 1 0 0  2 1 0  0 0\\n\\nSo, now, we have 2 arrays and we can compare them to get the effective direction of fall.\\nThe conditions are, \\n* If a domino doesnt fall towards Left (l[i] == 0), but falls towards Right (r[i] > 0) then it has only one direction hence it will fall towards Right, and vice versa.\\n* If we notice that both l[i] && r[i] are zero then that means it was already assigned a direction which we can get from the input string.\\n* If l[i] && r[i] have same non zero value for L and R, that means it has it its neighbouring domino falling towards it, that means it won\\'t fall, hence we will assign \\' . \\' to this.\\n* And the last case is, if l[i] > r[i] and both are non zero, then we assign the direction R(minimum value of l[i] and r[i] get the direction.)\\n\\nHappy Coding!\\n\\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); cout.tie(NULL);\\n    }\\n    string pushDominoes(string s){\\n        int n = s.length();\\n        vector<int> l(n, 0), r(n, 0);\\n        char prev = \\'.\\';\\n        int count = 1;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'R\\'){\\n                prev = \\'R\\';\\n                count = 1;\\n                continue;\\n            }\\n            else if(s[i] == \\'L\\') prev = \\'L\\';\\n            if(prev == \\'R\\' && s[i] == \\'.\\') r[i] = count++;\\n        }\\n        prev = \\'.\\';\\n        count = 1;\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i] == \\'L\\'){\\n                prev = \\'L\\';\\n                count = 1;\\n                continue;\\n            }\\n            else if(s[i] == \\'R\\') prev = \\'R\\';\\n            if(prev == \\'L\\' && s[i] == \\'.\\') l[i] = count++;\\n        }\\n        string ans = \"\";\\n        for(int i=0; i<n; i++){\\n            if(!l[i] && !r[i]) ans += s[i];\\n            else if(!l[i]) ans += \\'R\\';\\n            else if(!r[i]) ans += \\'L\\';\\n            else if(l[i] == r[i]) ans += \\'.\\';\\n            else if(l[i] > r[i]) ans += \\'R\\';\\n            else ans += \\'L\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); cout.tie(NULL);\\n    }\\n    string pushDominoes(string s){\\n        int n = s.length();\\n        vector<int> l(n, 0), r(n, 0);\\n        char prev = \\'.\\';\\n        int count = 1;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'R\\'){\\n                prev = \\'R\\';\\n                count = 1;\\n                continue;\\n            }\\n            else if(s[i] == \\'L\\') prev = \\'L\\';\\n            if(prev == \\'R\\' && s[i] == \\'.\\') r[i] = count++;\\n        }\\n        prev = \\'.\\';\\n        count = 1;\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i] == \\'L\\'){\\n                prev = \\'L\\';\\n                count = 1;\\n                continue;\\n            }\\n            else if(s[i] == \\'R\\') prev = \\'R\\';\\n            if(prev == \\'L\\' && s[i] == \\'.\\') l[i] = count++;\\n        }\\n        string ans = \"\";\\n        for(int i=0; i<n; i++){\\n            if(!l[i] && !r[i]) ans += s[i];\\n            else if(!l[i]) ans += \\'R\\';\\n            else if(!r[i]) ans += \\'L\\';\\n            else if(l[i] == r[i]) ans += \\'.\\';\\n            else if(l[i] > r[i]) ans += \\'R\\';\\n            else ans += \\'L\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 132682,
                "title": "python-o-n-solution-go-through-array-twice",
                "content": "First pass, from left to right, only count distance of current index to previous \\'R\\'. Save all distance in dist array\\nSecond pass, from right to left, count distance of current index to previous \\'L\\'. If lDist < rDist (dist[i]), current cell should be \\'L\\', if lDist == rDist, current cell should be \\'.\\' \\n```\\nclass Solution(object):\\n    def pushDominoes(self, dominoes):\\n        \"\"\"\\n        :type dominoes: str\\n        :rtype: str\\n        \"\"\"\\n        lst = list(dominoes)\\n        dist = [0] * len(dominoes)\\n        rDist = None\\n        for i, val in enumerate(lst):\\n            if val == \\'R\\':\\n                rDist = 0\\n            elif val == \\'L\\':\\n                rDist = None\\n            elif rDist != None:\\n                rDist += 1\\n                dist[i] = rDist\\n                lst[i] = \\'R\\'\\n        lDist = None\\n        for i in range(len(lst) - 1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                lDist = 0\\n            elif dominoes[i] == \\'R\\':\\n                lDist = None\\n            elif lDist != None:\\n                lDist += 1\\n                if lDist < dist[i] or lst[i] == \\'.\\':\\n                    lst[i] = \\'L\\'\\n                elif lDist == dist[i]:\\n                    lst[i] = \\'.\\'\\n        return \\'\\'.join(lst)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pushDominoes(self, dominoes):\\n        \"\"\"\\n        :type dominoes: str\\n        :rtype: str\\n        \"\"\"\\n        lst = list(dominoes)\\n        dist = [0] * len(dominoes)\\n        rDist = None\\n        for i, val in enumerate(lst):\\n            if val == \\'R\\':\\n                rDist = 0\\n            elif val == \\'L\\':\\n                rDist = None\\n            elif rDist != None:\\n                rDist += 1\\n                dist[i] = rDist\\n                lst[i] = \\'R\\'\\n        lDist = None\\n        for i in range(len(lst) - 1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                lDist = 0\\n            elif dominoes[i] == \\'R\\':\\n                lDist = None\\n            elif lDist != None:\\n                lDist += 1\\n                if lDist < dist[i] or lst[i] == \\'.\\':\\n                    lst[i] = \\'L\\'\\n                elif lDist == dist[i]:\\n                    lst[i] = \\'.\\'\\n        return \\'\\'.join(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352252,
                "title": "python-simulate-process-explained",
                "content": "Let us iterate through our string and keep two pointers: for positions where values not equal to `.` and the go one after another. Pointers `prev, i` can point to symbols `L` or `R` and we can have `4` different options:\\n\\n1. `L...L`, in this case, we need to fill everything with `L`\\n2. `R...R`, in this case, we need to fill everything with `R`\\n3. `L...R`, we need to keep it as it is\\n4. `R...L`, then we need to fill first half with `R` and second with `L`, handling odd and even cases.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space is `O(n)` as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def pushDominoes(self, D):\\n        D = \"L\" + D + \"R\"\\n        n, prev, ans = len(D), 0, \"\"\\n        for i in range(1, n):\\n            diff = i - prev - 1\\n            if D[i] == \".\": continue\\n            \\n            if D[i] == D[prev]:\\n                ans += D[i]*diff     \\n            elif D[i] == \"L\" and D[prev] == \"R\":\\n                m, d = divmod(diff, 2)\\n                ans += \"R\"*m + \".\"*d + \"L\"*m\\n            else:\\n                ans += \".\"*diff\\n                \\n            ans += D[i]\\n            prev = i\\n        \\n        return ans[:-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def pushDominoes(self, D):\\n        D = \"L\" + D + \"R\"\\n        n, prev, ans = len(D), 0, \"\"\\n        for i in range(1, n):\\n            diff = i - prev - 1\\n            if D[i] == \".\": continue\\n            \\n            if D[i] == D[prev]:\\n                ans += D[i]*diff     \\n            elif D[i] == \"L\" and D[prev] == \"R\":\\n                m, d = divmod(diff, 2)\\n                ans += \"R\"*m + \".\"*d + \"L\"*m\\n            else:\\n                ans += \".\"*diff\\n                \\n            ans += D[i]\\n            prev = i\\n        \\n        return ans[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347029,
                "title": "c-o-n-easy-to-write-may-the-force-be-with-you",
                "content": "We just need to consider the two closest non-period characters. \\n`left_r_dis[i]` is the smallest distance between `dominoes[i]` and its left `R`.\\n`right_l_dis[i]` is the smallest distance between `dominoes[i]` and its right `L`.\\n```cpp\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left_r_dis(n + 1, 0);\\n        vector<int> right_l_dis(n + 1, 0);\\n        int r_pos = n + 1;\\n        for (int i = 0; i < n; ++i) {\\n            if (dominoes[i] == \\'R\\') {\\n                r_pos = i;\\n            }\\n            else if (dominoes[i] == \\'L\\') {\\n                r_pos = n + 1;\\n            }\\n            left_r_dis[i] = r_pos == n + 1 ? n + 1 : i - r_pos;\\n        }\\n        int l_pos = -1;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (dominoes[i] == \\'L\\') {\\n                l_pos = i;\\n            }\\n            else if (dominoes[i] == \\'R\\') {\\n                l_pos = -1;\\n            }\\n            right_l_dis[i] = l_pos == -1 ? n + 1 : l_pos - i;\\n        }\\n        \\n        string result = dominoes;\\n        for (int i = 0; i < n; ++i) {\\n            if (left_r_dis[i] < right_l_dis[i]) result[i] = \\'R\\';\\n            else if (left_r_dis[i] > right_l_dis[i]) result[i] = \\'L\\';\\n            //else\\n        }\\n\\n        return result;\\n    } \\n};\\n```\\n\\n// It is quite like the problem [Leetcode] container with most water.\\nThey are all first consider one element in the array.",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left_r_dis(n + 1, 0);\\n        vector<int> right_l_dis(n + 1, 0);\\n        int r_pos = n + 1;\\n        for (int i = 0; i < n; ++i) {\\n            if (dominoes[i] == \\'R\\') {\\n                r_pos = i;\\n            }\\n            else if (dominoes[i] == \\'L\\') {\\n                r_pos = n + 1;\\n            }\\n            left_r_dis[i] = r_pos == n + 1 ? n + 1 : i - r_pos;\\n        }\\n        int l_pos = -1;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (dominoes[i] == \\'L\\') {\\n                l_pos = i;\\n            }\\n            else if (dominoes[i] == \\'R\\') {\\n                l_pos = -1;\\n            }\\n            right_l_dis[i] = l_pos == -1 ? n + 1 : l_pos - i;\\n        }\\n        \\n        string result = dominoes;\\n        for (int i = 0; i < n; ++i) {\\n            if (left_r_dis[i] < right_l_dis[i]) result[i] = \\'R\\';\\n            else if (left_r_dis[i] > right_l_dis[i]) result[i] = \\'L\\';\\n            //else\\n        }\\n\\n        return result;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630335,
                "title": "4-cases-stupidly-simple",
                "content": "**So, there are 4 cases:**\\n* **LL:** everything in between will be \\'L\\' |  **<-L . . . <-L**\\n* **RR:** everything in between will be \\'R\\' |  **R-> . . . R->** \\n* **LR:** everything in between will be \\'.\\' | **<-L . . . R->**\\n* **RL:**  they will `meet in the middle` |  **R-> . . . <-L**\\n*[ in case of RL, if the count of \\'.\\'s was odd, the middle element will be `\\'.\\'` ]*\\n\\n**Code:**\\n\\n    StringBuilder sb = new StringBuilder();\\n    public String pushDominoes(String dominoes) {\\n        int count = 0; char last = \\'L\\';\\n        for(char ch : dominoes.toCharArray()){\\n            if(ch!=\\'.\\'){\\n\\t\\t\\t\\tif(ch==last) add(count, last);             // case LL & RR\\n\\t\\t\\t\\telse if(last==\\'L\\') add(count, \\'.\\');  // case LR\\n\\t\\t\\t\\telse {                                     // case RL\\n\\t\\t\\t\\t\\tadd(count/2, \\'R\\');\\n\\t\\t\\t\\t\\tif(count%2!=0) sb.append(\\'.\\');\\n\\t\\t\\t\\t\\tadd(count/2, \\'L\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t\\tlast = ch; count = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse count++;\\n        }\\n        add(count, last==\\'R\\'?\\'R\\':\\'.\\');  // for trailing \\'.\\'s\\n        return sb.toString();\\n    }\\n    \\n    void add(int count, char ch){  // append \\'ch\\' to sb \\'count\\' times\\n        for(int i=0; i<count; i++) sb.append(ch);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "**So, there are 4 cases:**\\n* **LL:** everything in between will be \\'L\\' |  **<-L . . . <-L**\\n* **RR:** everything in between will be \\'R\\' |  **R-> . . . R->** \\n* **LR:** everything in between will be \\'.\\' | **<-L . . . R->**\\n* **RL:**  they will `meet in the middle` |  **R-> . . . <-L**\\n*[ in case of RL, if the count of \\'.\\'s was odd, the middle element will be `\\'.\\'` ]*\\n\\n**Code:**\\n\\n    StringBuilder sb = new StringBuilder();\\n    public String pushDominoes(String dominoes) {\\n        int count = 0; char last = \\'L\\';\\n        for(char ch : dominoes.toCharArray()){\\n            if(ch!=\\'.\\'){\\n\\t\\t\\t\\tif(ch==last) add(count, last);             // case LL & RR\\n\\t\\t\\t\\telse if(last==\\'L\\') add(count, \\'.\\');  // case LR\\n\\t\\t\\t\\telse {                                     // case RL\\n\\t\\t\\t\\t\\tadd(count/2, \\'R\\');\\n\\t\\t\\t\\t\\tif(count%2!=0) sb.append(\\'.\\');\\n\\t\\t\\t\\t\\tadd(count/2, \\'L\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t\\tlast = ch; count = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse count++;\\n        }\\n        add(count, last==\\'R\\'?\\'R\\':\\'.\\');  // for trailing \\'.\\'s\\n        return sb.toString();\\n    }\\n    \\n    void add(int count, char ch){  // append \\'ch\\' to sb \\'count\\' times\\n        for(int i=0; i<count; i++) sb.append(ch);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1352325,
                "title": "push-dominoes-2-approaches-easy-understanding",
                "content": "# Approach #1: Adjacent Symbols\\nBetween *every group* of vertical dominoes ( `\\'.\\'` ), we have up to two non-vertical dominoes bordering this group. Since additional dominoes outside this group do not affect the outcome, we can analyze these situations individually: *there are 9 of them* (as the border could be empty). \\nAnd, if we border the dominoes by `\\'L\\'` and `\\'R\\'`, there are only 4 cases. \\nWe\\'ll write new letters between these symbols depending on each case.\\n\\n**Algorithm**\\n* If we have say `\"A....B\"`, where A = B, then we should write `\"AAAAAA\"`.\\n* If we have `\"R....L\"`, then we will write `\"RRRLLL\"`, or `\"RRR.LLL\"` if we have an odd number of dots. If the initial symbols are at positions `i` and `j`, we can check our distance `k-i` and `j-k` to decide at position k whether to write `\\'L\\'`, `\\'R\\'`, or `\\'.\\'`.\\n* If we have `\"L....R\"` we don\\'t do anything. We can `skip` this case.\\n\\n**Solution In Java** *(Let Me Know in the comments if you want the code in C++)*\\n```\\n public String pushDominoes(String dominoes) {\\n        int N = dominoes.length();\\n        int[] indexes = new int[N+2];\\n        char[] symbols = new char[N+2];\\n        int len = 1;\\n        indexes[0] = -1;\\n        symbols[0] = \\'L\\';\\n\\n        for (int i = 0; i < N; ++i)\\n            if (dominoes.charAt(i) != \\'.\\') {\\n                indexes[len] = i;\\n                symbols[len++] = dominoes.charAt(i);\\n            }\\n\\n        indexes[len] = N;\\n        symbols[len++] = \\'R\\';\\n\\n        char[] ans = dominoes.toCharArray();\\n        for (int index = 0; index < len - 1; ++index) {\\n            int i = indexes[index], j = indexes[index+1];\\n            char x = symbols[index], y = symbols[index+1];\\n            char write;\\n            if (x == y) {\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = x;\\n            } else if (x > y) { // RL\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = k-i == j-k ? \\'.\\' : k-i < j-k ? \\'R\\' : \\'L\\';\\n            }\\n        }\\n\\n        return String.valueOf(ans);\\n    }\\n```\\n\\n# Approach #2: Calculate Force\\nWe can calculate the net force applied on every domino. The forces we care about are how close a domino is to a leftward `R\\'`, and to a rightward `\\'L\\'`: the closer we are, the stronger the force.\\n\\n**Algorithm**\\n1. Scanning from left to right, our force decays by 1 every iteration, and resets to `N` if we meet an `\\'R\\'`, so that `force[i]` is *higher* (than `force[j]`) if and only if `dominoes[i]` is closer (looking leftward) to `\\'R\\'` (than `dominoes[j]`).\\n2. Similarly, scanning from right to left, we can find the force going rightward (closeness to `\\'L\\'`).\\n3. For some domino `answer[i]`, if the forces are equal, then the answer is `\\'.\\'`. Otherwise, the answer is implied by whichever force is stronger.\\n\\n**Solution In Java** *(Let Me Know in the comments if you want the code in C++)*\\n```\\npublic String pushDominoes(String S) {\\n        char[] A = S.toCharArray();\\n        int N = A.length;\\n        int[] forces = new int[N];\\n\\n        int force = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (A[i] == \\'R\\') force = N;\\n            else if (A[i] == \\'L\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n\\n        force = 0;\\n        for (int i = N-1; i >= 0; --i) {\\n            if (A[i] == \\'L\\') force = N;\\n            else if (A[i] == \\'R\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int f: forces)\\n            ans.append(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        return ans.toString();\\n    }\\n```\\n\\n**Solution In C++**\\n```\\nclass Solution {\\n\\tpublic: \\n\\t\\tString pushDominoes(String S) {\\n\\t\\tstring res = \"\" ;\\n\\t\\tint n = S.length( ) , f = 0 ;\\n\\t\\tint ans[n] ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            ans[i] = 0 ;\\n        }\\n\\t\\tfor(int i=0;i < n;i++)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = n ;\\n\\t\\t\\telse if(S[i]==\\'L\\') \\n\\t\\t\\t\\tf = 0 ;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1)>0 ? (f - 1) : 0 ;\\n\\t\\t\\tans[i] += f ;\\n\\t\\t}\\n\\t\\tf = 0 ;\\n\\t\\tfor(int i = n - 1 ; i >= 0 ; i--)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'L\\')\\n\\t\\t\\t\\tf = n;\\n\\t\\t\\telse if(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = 0;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1) > 0 ? (f-1) : 0 ;\\n\\t\\t\\tans[i] -= f ;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0 ; i < n ; i++) \\n\\t\\t\\tres += ans[i] < 0 ? \"L\" : ans[i] > 0 ?\"R\":\".\";\\n\\t\\treturn res ;\\n}\\n```\\nDo let me know any other approaches that come to your mind!",
                "solutionTags": [],
                "code": "```\\n public String pushDominoes(String dominoes) {\\n        int N = dominoes.length();\\n        int[] indexes = new int[N+2];\\n        char[] symbols = new char[N+2];\\n        int len = 1;\\n        indexes[0] = -1;\\n        symbols[0] = \\'L\\';\\n\\n        for (int i = 0; i < N; ++i)\\n            if (dominoes.charAt(i) != \\'.\\') {\\n                indexes[len] = i;\\n                symbols[len++] = dominoes.charAt(i);\\n            }\\n\\n        indexes[len] = N;\\n        symbols[len++] = \\'R\\';\\n\\n        char[] ans = dominoes.toCharArray();\\n        for (int index = 0; index < len - 1; ++index) {\\n            int i = indexes[index], j = indexes[index+1];\\n            char x = symbols[index], y = symbols[index+1];\\n            char write;\\n            if (x == y) {\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = x;\\n            } else if (x > y) { // RL\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = k-i == j-k ? \\'.\\' : k-i < j-k ? \\'R\\' : \\'L\\';\\n            }\\n        }\\n\\n        return String.valueOf(ans);\\n    }\\n```\n```\\npublic String pushDominoes(String S) {\\n        char[] A = S.toCharArray();\\n        int N = A.length;\\n        int[] forces = new int[N];\\n\\n        int force = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (A[i] == \\'R\\') force = N;\\n            else if (A[i] == \\'L\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n\\n        force = 0;\\n        for (int i = N-1; i >= 0; --i) {\\n            if (A[i] == \\'L\\') force = N;\\n            else if (A[i] == \\'R\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int f: forces)\\n            ans.append(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        return ans.toString();\\n    }\\n```\n```\\nclass Solution {\\n\\tpublic: \\n\\t\\tString pushDominoes(String S) {\\n\\t\\tstring res = \"\" ;\\n\\t\\tint n = S.length( ) , f = 0 ;\\n\\t\\tint ans[n] ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            ans[i] = 0 ;\\n        }\\n\\t\\tfor(int i=0;i < n;i++)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = n ;\\n\\t\\t\\telse if(S[i]==\\'L\\') \\n\\t\\t\\t\\tf = 0 ;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1)>0 ? (f - 1) : 0 ;\\n\\t\\t\\tans[i] += f ;\\n\\t\\t}\\n\\t\\tf = 0 ;\\n\\t\\tfor(int i = n - 1 ; i >= 0 ; i--)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'L\\')\\n\\t\\t\\t\\tf = n;\\n\\t\\t\\telse if(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = 0;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1) > 0 ? (f-1) : 0 ;\\n\\t\\t\\tans[i] -= f ;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0 ; i < n ; i++) \\n\\t\\t\\tres += ans[i] < 0 ? \"L\" : ans[i] > 0 ?\"R\":\".\";\\n\\t\\treturn res ;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119158,
                "title": "java-easy-solution",
                "content": "**Idea:**\\nusing two pointer left and right\\nthere are **4 Possible Cases** that left and right are Pointing to : \\n1.  **L  and. L** (all in between dominos will fall on left side) So mark all dominos to L from left to right \\n2. **L and R** (left pointer will fall to left and right to right so dominos in between will be as they were before) \\n3.  **R and L** (from left side dominos will start falling to right and from right side dominos will fall down to left )\\n4.  **R and R** (all in b/w dominos will fall in right side) So mark all dominos to R from left to right\\n\\nyou have someIdea now . Code will give you more clearity.\\n\\n**Complexity :**\\n```\\nTime : O(n)\\nSpace: O(n)\\n```\\n\\n```\\n    public String pushDominoes(String dominoes) {\\n        \\n        char[] arr=new char[dominoes.length()+2];\\n        arr[0]=\\'L\\';\\n        arr[arr.length-1]=\\'R\\';\\n        for(int i=1;i<arr.length-1;i++){\\n            arr[i]=dominoes.charAt(i-1);\\n        }\\n        \\n        int i=0;\\n        int j=1;\\n        \\n        while(j!=arr.length){\\n            while(arr[j]==\\'.\\') j++;\\n            \\n            if(arr[i]==\\'L\\' && arr[j]==\\'L\\'){\\n                while(i!=j){\\n                    arr[i]=\\'L\\';\\n                    i++;\\n                }\\n                j++;\\n            }else if(arr[i]==\\'L\\' && arr[j]==\\'R\\'){\\n                 i=j;\\n                 j++;\\n            }else if(arr[i]==\\'R\\' && arr[j]==\\'R\\'){\\n                while(i!=j){\\n                    arr[i]=\\'R\\';\\n                    i++;\\n                }\\n                j++;\\n            }else if(arr[i]==\\'R\\' && arr[j]==\\'L\\'){\\n                 int temp1=i+1;\\n                 int temp2=j-1;\\n                 while(temp1<temp2){\\n                     arr[temp1]=\\'R\\';\\n                     arr[temp2]=\\'L\\';\\n                     temp1++;\\n                     temp2--;\\n                 }\\n                i=j;\\n                j++;\\n            }\\n        }\\n        \\n        StringBuilder sb=new StringBuilder(\"\");\\n        for(i=1;i<arr.length-1;i++){\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n    }\\n```\\nPlease **UPVOTE** if found it helpful:)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nTime : O(n)\\nSpace: O(n)\\n```\n```\\n    public String pushDominoes(String dominoes) {\\n        \\n        char[] arr=new char[dominoes.length()+2];\\n        arr[0]=\\'L\\';\\n        arr[arr.length-1]=\\'R\\';\\n        for(int i=1;i<arr.length-1;i++){\\n            arr[i]=dominoes.charAt(i-1);\\n        }\\n        \\n        int i=0;\\n        int j=1;\\n        \\n        while(j!=arr.length){\\n            while(arr[j]==\\'.\\') j++;\\n            \\n            if(arr[i]==\\'L\\' && arr[j]==\\'L\\'){\\n                while(i!=j){\\n                    arr[i]=\\'L\\';\\n                    i++;\\n                }\\n                j++;\\n            }else if(arr[i]==\\'L\\' && arr[j]==\\'R\\'){\\n                 i=j;\\n                 j++;\\n            }else if(arr[i]==\\'R\\' && arr[j]==\\'R\\'){\\n                while(i!=j){\\n                    arr[i]=\\'R\\';\\n                    i++;\\n                }\\n                j++;\\n            }else if(arr[i]==\\'R\\' && arr[j]==\\'L\\'){\\n                 int temp1=i+1;\\n                 int temp2=j-1;\\n                 while(temp1<temp2){\\n                     arr[temp1]=\\'R\\';\\n                     arr[temp2]=\\'L\\';\\n                     temp1++;\\n                     temp2--;\\n                 }\\n                i=j;\\n                j++;\\n            }\\n        }\\n        \\n        StringBuilder sb=new StringBuilder(\"\");\\n        for(i=1;i<arr.length-1;i++){\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132520,
                "title": "java-one-pass-no-extra-storage-detailed-explanation",
                "content": "    class Solution {\\n        public String pushDominoes(String dominoes) {\\n            // algorithm 2018/05/20: playing with a few samples, it is easy to find the rule\\n            // if there is NO dot (meaning every domino is pushed), then the final state is the initial state\\n            //   for example, all \"LLL\" => \"LLL\", all \"RRR\" => \"RRR\",\\n            //                mixed \"LLLRR\" => \"LLLRR\" (falling domino having no effect on already-fallen domino)\\n            // if there is only ONE dot, we have a few possibilities:\\n            //   \"L.R\" => \"L.R\", \"R.L\" => \"R.L\" (center-one standing), \"L.L\" => \"LLL\", \"R.R\" => \"RRR\"\\n            // if there are TWO dots, we have the following possibilities:\\n            //   \"L..R\" => \"L..R\", \"R..L\" => \"RRLL\" (center-one standing), \"L..L\" => \"LLLL\", \"R..R\" => \"RRRR\"\\n            // if there are TWO dots, we have the following possibilities:\\n            //   \"L...R\" => \"L...R\", \"R...L\" => \"RR.LL\" (center-one standing), \"L...L\" => \"LLLLL\", \"R...R\" => \"RRRRR\"\\n            // Therefore the rule is:\\n            // for each region of dots (a substring \"P....Q\"), check its left and right\\n            //   if left is \"L\" and right is \"R\", the substring remains as is;\\n            //   if left is \"R\" and right is \"L\", the substring is converted into either \"RRRLLL\" or \"RR.LL\"\\n            //   if left and right are the same, the substring is converted into either \"RRRRR\" or \"LLLLL\"\\n\\n            assert (null != dominoes);\\n            // place a sentinel \"L\" + dominoes + \"R\", as this does not impact the final outcome\\n            dominoes = \"L\" + dominoes + \"R\";\\n\\n            // stringbuilder to hold the result\\n            StringBuilder builder = new StringBuilder();\\n\\n            // scan the string and split it into multiple groups, |groupStart, groupEnd| ... |groupStart, groupEnd| ...\\n            // \\'groupStart\\' and \\'groupEnd\\' designates a number of chars solely with \\'L\\' or \\'R\\'\\n            int strLen = dominoes.length();\\n            int groupStart = 0;\\n            int index = 0;      //\\n            while (index < strLen) {\\n                while (index < strLen && \\'.\\' != dominoes.charAt(index)) {\\n                    index++;\\n                }\\n                int groupEnd = index - 1;\\n                char leftCharForDotRegion = dominoes.charAt(groupEnd);\\n\\n                // copy this part of susbtring as is (no DOT in the middle)\\n                builder.append(dominoes.substring(groupStart, groupEnd + 1));\\n\\n                // either we reach the end of the string or we find a dot\\n                if (index == strLen) {\\n                    // final section with only \\'L\\'s and \\'R\\'s\\n                    break;\\n                }\\n\\n                // now we meet a DOT; scan until we meet the next \"L\" or \"R\"\\n                while (\\'.\\' == dominoes.charAt(index)) {\\n                    index++;        // we have the sentinel \"R\", so this will not reach the end of string\\n                }\\n                char rightCharForDotRegion = dominoes.charAt(index);\\n\\n                if (leftCharForDotRegion == rightCharForDotRegion) {\\n                    // replace dot with the same char\\n                    for (int count = 0; count < index - groupEnd - 1; count++) {\\n                        builder.append(leftCharForDotRegion);\\n                    }\\n                } else if (\\'L\\' == leftCharForDotRegion) {\\n                    // rightChar is \\'R\\', then keep the dots as it\\n                    for (int count = 0; count < index - groupEnd - 1; count++) {\\n                        builder.append(\\'.\\');\\n                    }\\n                } else {\\n                    // leftChar is \\'R\\' and right char is \\'L\\', we either have a SINGLE dot in the middle, or not dot\\n                    int countDots = index - groupEnd - 1;\\n                    // half R\\n                    for (int count = 0; count < countDots / 2; count++) {\\n                        builder.append(\\'R\\');\\n                    }\\n                    if (1 == countDots % 2) {\\n                        // center dot\\n                        builder.append(\\'.\\');\\n                    }\\n                    // half L\\n                    for (int count = 0; count < countDots / 2; count++) {\\n                        builder.append(\\'L\\');\\n                    }\\n                }\\n\\n                // now scan next group\\n                groupStart = index;\\n\\n            }\\n\\n            String result = builder.toString();\\n            return result.substring(1, strLen - 1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String pushDominoes(String dominoes) {\\n            // algorithm 2018/05/20: playing with a few samples, it is easy to find the rule\\n            // if there is NO dot (meaning every domino is pushed), then the final state is the initial state\\n            //   for example, all \"LLL\" => \"LLL\", all \"RRR\" => \"RRR\",\\n            //                mixed \"LLLRR\" => \"LLLRR\" (falling domino having no effect on already-fallen domino)\\n            // if there is only ONE dot, we have a few possibilities:\\n            //   \"L.R\" => \"L.R\", \"R.L\" => \"R.L\" (center-one standing), \"L.L\" => \"LLL\", \"R.R\" => \"RRR\"\\n            // if there are TWO dots, we have the following possibilities:\\n            //   \"L..R\" => \"L..R\", \"R..L\" => \"RRLL\" (center-one standing), \"L..L\" => \"LLLL\", \"R..R\" => \"RRRR\"\\n            // if there are TWO dots, we have the following possibilities:\\n            //   \"L...R\" => \"L...R\", \"R...L\" => \"RR.LL\" (center-one standing), \"L...L\" => \"LLLLL\", \"R...R\" => \"RRRRR\"\\n            // Therefore the rule is:\\n            // for each region of dots (a substring \"P....Q\"), check its left and right\\n            //   if left is \"L\" and right is \"R\", the substring remains as is;\\n            //   if left is \"R\" and right is \"L\", the substring is converted into either \"RRRLLL\" or \"RR.LL\"\\n            //   if left and right are the same, the substring is converted into either \"RRRRR\" or \"LLLLL\"\\n\\n            assert (null != dominoes);\\n            // place a sentinel \"L\" + dominoes + \"R\", as this does not impact the final outcome\\n            dominoes = \"L\" + dominoes + \"R\";\\n\\n            // stringbuilder to hold the result\\n            StringBuilder builder = new StringBuilder();\\n\\n            // scan the string and split it into multiple groups, |groupStart, groupEnd| ... |groupStart, groupEnd| ...\\n            // \\'groupStart\\' and \\'groupEnd\\' designates a number of chars solely with \\'L\\' or \\'R\\'\\n            int strLen = dominoes.length();\\n            int groupStart = 0;\\n            int index = 0;      //\\n            while (index < strLen) {\\n                while (index < strLen && \\'.\\' != dominoes.charAt(index)) {\\n                    index++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2628946,
                "title": "java-easy-solution-with-comments-89-faster-code-stringbuilder",
                "content": "\\t\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        \\n        StringBuilder sb = new StringBuilder(dominoes);\\n        \\n        int n = sb.length();\\n        \\n        \\n        //mark true for all the unpushed block, after pushing a bloch in right direction\\n        char prev = \\'.\\';\\n        boolean[] forward = new boolean[n];\\n        for(int i = 0; i < n; i++){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'R\\') forward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        //mark true for all the unpushed block, after pushing a block in left direction\\n        prev = \\'.\\';\\n        boolean[] backward  = new boolean[n];\\n        for(int i = n - 1; i >= 0; i--){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'L\\') backward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while(i < n){\\n            if(backward[i] && !forward[i]){\\n                //fall block as there is force in left direction\\n                sb.setCharAt(i++, \\'L\\');\\n                \\n            }else if(!backward[i] && forward[i]){\\n                //fall block as there is force in right direction\\n                sb.setCharAt(i++, \\'R\\');\\n                \\n            }else if(backward[i] && forward[i]){\\n                //fall block as there is force in both  direction\\n                int j = (i + 1);\\n                while(j < n && backward[j] && forward[j]){\\n                    j++;\\n                }\\n                pushDominoesInBetween(sb, i, j - 1);\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    \\n    private void pushDominoesInBetween(StringBuilder sb, int l, int r){\\n        while(l < r){\\n            sb.setCharAt(l++, \\'R\\');\\n            sb.setCharAt(r--, \\'L\\');\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        \\n        StringBuilder sb = new StringBuilder(dominoes);\\n        \\n        int n = sb.length();\\n        \\n        \\n        //mark true for all the unpushed block, after pushing a bloch in right direction\\n        char prev = \\'.\\';\\n        boolean[] forward = new boolean[n];\\n        for(int i = 0; i < n; i++){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'R\\') forward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        //mark true for all the unpushed block, after pushing a block in left direction\\n        prev = \\'.\\';\\n        boolean[] backward  = new boolean[n];\\n        for(int i = n - 1; i >= 0; i--){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'L\\') backward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while(i < n){\\n            if(backward[i] && !forward[i]){\\n                //fall block as there is force in left direction\\n                sb.setCharAt(i++, \\'L\\');\\n                \\n            }else if(!backward[i] && forward[i]){\\n                //fall block as there is force in right direction\\n                sb.setCharAt(i++, \\'R\\');\\n                \\n            }else if(backward[i] && forward[i]){\\n                //fall block as there is force in both  direction\\n                int j = (i + 1);\\n                while(j < n && backward[j] && forward[j]){\\n                    j++;\\n                }\\n                pushDominoesInBetween(sb, i, j - 1);\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    \\n    private void pushDominoesInBetween(StringBuilder sb, int l, int r){\\n        while(l < r){\\n            sb.setCharAt(l++, \\'R\\');\\n            sb.setCharAt(r--, \\'L\\');\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629157,
                "title": "c-2-pointers-short-simple",
                "content": "***DO UPVOTE IF IT HELPS !!!!!!***\\t\\n\\n\\t\\n\\tstring pushDominoes(string s) {\\n        \\n        int n = s.size();\\n        int r=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'L\\'){                                 \\n                if(r==-1){                                  //s[i]==\\'L\\' && r==-1\\n                    for(int j=i-1;j>=0 && s[j]==\\'.\\';j--){   //update all dominoes to left beginning from j=i-1 to j>=0\\n                        s[j]=\\'L\\';\\n                    }\\n                }\\n                else{                                      //s[i]==\\'L\\' && r!=-1\\n                    for(int j=r+1,k=i-1;j<k;j++,k--){      //update all dominoes lying between k=r+1 and j=i-1\\n                        s[j]=\\'R\\';\\n                        s[k]=\\'L\\';\\n                    }\\n                    r=-1;        //important step update r = -1\\n                }\\n            }\\n            else if(s[i]==\\'R\\'){                            //s[i]==\\'R\\' && r!=-1\\n                if(r!=-1){                                 //update all dominoes lying right to j=r+1 till i\\n                    for(int j=r+1;j<i;j++){\\n                        s[j]=\\'R\\';\\n                    }\\n                }\\n                r=i;             //update r since r is found\\n            }\\n        }\\n        \\n        if(r!=-1){                     //if you have traversed complete string and r!=-1, then update all dominoes\\n            for(int j=r+1;j<n;j++) {   //beginning from r+1 to n to \\'R\\'\\n                s[j]=\\'R\\';\\n            }\\n        }\\n        \\n        return s;   \\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!!***\\t\\n\\n\\t\\n\\tstring pushDominoes(string s) {\\n        \\n        int n = s.size();\\n        int r=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'L\\'){                                 \\n                if(r==-1){                                  //s[i]==\\'L\\' && r==-1\\n                    for(int j=i-1;j>=0 && s[j]==\\'.\\';j--){   //update all dominoes to left beginning from j=i-1 to j>=0\\n                        s[j]=\\'L\\';\\n                    }\\n                }\\n                else{                                      //s[i]==\\'L\\' && r!=-1\\n                    for(int j=r+1,k=i-1;j<k;j++,k--){      //update all dominoes lying between k=r+1 and j=i-1\\n                        s[j]=\\'R\\';\\n                        s[k]=\\'L\\';\\n                    }\\n                    r=-1;        //important step update r = -1\\n                }\\n            }\\n            else if(s[i]==\\'R\\'){                            //s[i]==\\'R\\' && r!=-1\\n                if(r!=-1){                                 //update all dominoes lying right to j=r+1 till i\\n                    for(int j=r+1;j<i;j++){\\n                        s[j]=\\'R\\';\\n                    }\\n                }\\n                r=i;             //update r since r is found\\n            }\\n        }\\n        \\n        if(r!=-1){                     //if you have traversed complete string and r!=-1, then update all dominoes\\n            for(int j=r+1;j<n;j++) {   //beginning from r+1 to n to \\'R\\'\\n                s[j]=\\'R\\';\\n            }\\n        }\\n        \\n        return s;   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1352251,
                "title": "python-java-one-pass-time-complexity-of-o-n-in-constant-space",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        res = \"\" #Used to store final result.\\n        i=0\\n        while(i<len(dominoes)):\\n            #if charAt(i) is \\'L\\' or \\'R\\', just place append the same in res.\\n            if dominoes[i]==\\'L\\' or dominoes[i]==\\'R\\':\\n                res+=dominoes[i]\\n                i+=1\\n            else:# dominoes[i]==\\'.\\':\\n                #if charAt(i) is \\'.\\' and previous is Right pushed then, we have to count the\\n\\t\\t\\t\\t#number of \\'.\\' (dots) and see what is at the other end of dot. \\n                if i>0 and dominoes[i-1]==\\'R\\':\\n                    j=i\\n                    while(j<len(dominoes) and dominoes[j]==\\'.\\'):\\n                        j+=1\\n                    countDots = (j-i) #count of number of \\'.\\'(dots)\\n                    #if the other end is last index or if dominoe at other end is right pushed then\\n\\t\\t\\t\\t\\t#there is nothing to cancel the right pushed force of first dominoes and so all\\n\\t\\t\\t\\t\\t#\\'.\\'(dots) will be rightly pushed\\n                    if j==len(dominoes) or dominoes[j]==\\'R\\':\\n                        res+=\\'R\\'*countDots\\n                    else:#if other end is \\'L\\' i.e, left pushed\\n                    #first half will be rightly pushed and second half is leftly pushed and\\n\\t\\t\\t\\t\\t#if count is odd, then force on middle one gets cancelled\\n                        res+=\\'R\\'*(countDots//2) + \\'.\\'*(countDots-2*(countDots//2)) + \\'L\\'*(countDots//2)\\n                    i=j\\n                else: #if the start of string is \\'.\\'(dot) or previous is not rightly pushed\\n                    j=i\\n                    while(j<len(dominoes) and dominoes[j]==\\'.\\'):\\n                        j+=1\\n                    countDots = (j-i) #count the number of dots\\n                    \\n                    #if the other end is last index or if dominoe at other end is right pushed\\n\\t\\t\\t\\t\\t#then there is no force at all on stating indexes. So, all will remains \\'.\\'\\n                    if j==len(dominoes) or dominoes[j]==\\'R\\':\\n                        res+=\\'.\\'*countDots\\n                    #if other end is left pushed, the all the starting will be pushed left\\n                    else:\\n                        res+=\\'L\\'*countDots\\n                    i=j\\n        \\n        return res\\n```\\n\\n\\n\\nJava solution of above Code:\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        String res = \"\", intermediate=\"\", intermediateDots=\"\";\\n        int i = 0, j;\\n        int length = dominoes.length();\\n        while(i<length){\\n            char ch = dominoes.charAt(i);\\n            if (ch==\\'L\\' || ch==\\'R\\')\\n            {   res += Character.toString(ch);\\n                i++;}\\n            else{\\n                if(i>0 && dominoes.charAt(i-1)==\\'R\\'){\\n                    j=i;\\n                    intermediate=\"\";\\n                    while(j<length && dominoes.charAt(j)==\\'.\\'){\\n                        intermediate+=\"R\";\\n                        j+=1;\\n                    }\\n                    int count = j-i;\\n                    if (j==length || dominoes.charAt(j)==\\'R\\')\\n                        res += intermediate;\\n                    else\\n                        res += \"R\".repeat(count/2) + \".\".repeat(count-2*(count/2)) + \"L\".repeat(count/2);\\n                    i=j;\\n                }\\n                else{\\n                    j=i;\\n                    intermediateDots=\"\";\\n                    intermediate=\"\";\\n                    while(j<length && dominoes.charAt(j)==\\'.\\'){\\n                        intermediateDots+=\".\";\\n                        intermediate+=\"L\";\\n                        j+=1;\\n                    }\\n                    int count = j-i;\\n                    if (j==length || dominoes.charAt(j)==\\'R\\')\\n                        res += intermediateDots;\\n                    else\\n                        res += intermediate;\\n                    i=j;\\n                }\\n            }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        res = \"\" #Used to store final result.\\n        i=0\\n        while(i<len(dominoes)):\\n            #if charAt(i) is \\'L\\' or \\'R\\', just place append the same in res.\\n            if dominoes[i]==\\'L\\' or dominoes[i]==\\'R\\':\\n                res+=dominoes[i]\\n                i+=1\\n            else:# dominoes[i]==\\'.\\':\\n                #if charAt(i) is \\'.\\' and previous is Right pushed then, we have to count the\\n\\t\\t\\t\\t#number of \\'.\\' (dots) and see what is at the other end of dot. \\n                if i>0 and dominoes[i-1]==\\'R\\':\\n                    j=i\\n                    while(j<len(dominoes) and dominoes[j]==\\'.\\'):\\n                        j+=1\\n                    countDots = (j-i) #count of number of \\'.\\'(dots)\\n                    #if the other end is last index or if dominoe at other end is right pushed then\\n\\t\\t\\t\\t\\t#there is nothing to cancel the right pushed force of first dominoes and so all\\n\\t\\t\\t\\t\\t#\\'.\\'(dots) will be rightly pushed\\n                    if j==len(dominoes) or dominoes[j]==\\'R\\':\\n                        res+=\\'R\\'*countDots\\n                    else:#if other end is \\'L\\' i.e, left pushed\\n                    #first half will be rightly pushed and second half is leftly pushed and\\n\\t\\t\\t\\t\\t#if count is odd, then force on middle one gets cancelled\\n                        res+=\\'R\\'*(countDots//2) + \\'.\\'*(countDots-2*(countDots//2)) + \\'L\\'*(countDots//2)\\n                    i=j\\n                else: #if the start of string is \\'.\\'(dot) or previous is not rightly pushed\\n                    j=i\\n                    while(j<len(dominoes) and dominoes[j]==\\'.\\'):\\n                        j+=1\\n                    countDots = (j-i) #count the number of dots\\n                    \\n                    #if the other end is last index or if dominoe at other end is right pushed\\n\\t\\t\\t\\t\\t#then there is no force at all on stating indexes. So, all will remains \\'.\\'\\n                    if j==len(dominoes) or dominoes[j]==\\'R\\':\\n                        res+=\\'.\\'*countDots\\n                    #if other end is left pushed, the all the starting will be pushed left\\n                    else:\\n                        res+=\\'L\\'*countDots\\n                    i=j\\n        \\n        return res\\n```\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        String res = \"\", intermediate=\"\", intermediateDots=\"\";\\n        int i = 0, j;\\n        int length = dominoes.length();\\n        while(i<length){\\n            char ch = dominoes.charAt(i);\\n            if (ch==\\'L\\' || ch==\\'R\\')\\n            {   res += Character.toString(ch);\\n                i++;}\\n            else{\\n                if(i>0 && dominoes.charAt(i-1)==\\'R\\'){\\n                    j=i;\\n                    intermediate=\"\";\\n                    while(j<length && dominoes.charAt(j)==\\'.\\'){\\n                        intermediate+=\"R\";\\n                        j+=1;\\n                    }\\n                    int count = j-i;\\n                    if (j==length || dominoes.charAt(j)==\\'R\\')\\n                        res += intermediate;\\n                    else\\n                        res += \"R\".repeat(count/2) + \".\".repeat(count-2*(count/2)) + \"L\".repeat(count/2);\\n                    i=j;\\n                }\\n                else{\\n                    j=i;\\n                    intermediateDots=\"\";\\n                    intermediate=\"\";\\n                    while(j<length && dominoes.charAt(j)==\\'.\\'){\\n                        intermediateDots+=\".\";\\n                        intermediate+=\"L\";\\n                        j+=1;\\n                    }\\n                    int count = j-i;\\n                    if (j==length || dominoes.charAt(j)==\\'R\\')\\n                        res += intermediateDots;\\n                    else\\n                        res += intermediate;\\n                    i=j;\\n                }\\n            }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858300,
                "title": "javascript-2-pointers",
                "content": "```\\nvar pushDominoes = function(dominoes) {\\n    let l=0, r=1;\\n    const arr = (\"L\"+dominoes+\"R\").split(\"\");\\n    while(l<arr.length-1){\\n        while(arr[r]==\\'.\\') \\n            r++;\\n        if(arr[l]==arr[r]) \\n            for(let i=l+1; i<r; i++) \\n                arr[i]=arr[l];\\n        if(arr[l]>arr[r]) \\n            for(let i=1; i<=(r-l-1)/2; i++){\\n                arr[l+i] = \\'R\\';\\n                arr[r-i] = \\'L\\';\\n            }   \\n        l=r++;\\n    }\\n    return arr.slice(1,arr.length-1).join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pushDominoes = function(dominoes) {\\n    let l=0, r=1;\\n    const arr = (\"L\"+dominoes+\"R\").split(\"\");\\n    while(l<arr.length-1){\\n        while(arr[r]==\\'.\\') \\n            r++;\\n        if(arr[l]==arr[r]) \\n            for(let i=l+1; i<r; i++) \\n                arr[i]=arr[l];\\n        if(arr[l]>arr[r]) \\n            for(let i=1; i<=(r-l-1)/2; i++){\\n                arr[l+i] = \\'R\\';\\n                arr[r-i] = \\'L\\';\\n            }   \\n        l=r++;\\n    }\\n    return arr.slice(1,arr.length-1).join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466596,
                "title": "intuitive-python-solution-sliding-window-0-n",
                "content": "A lot of the other python solutions are a bit hard to wrap your mind around. This one felt fairly intuitive, it has a few parts:\\n\\nwe will use a sliding window approach, where we attempt to create a window that needs to be \"filled\" with appropriate values. Some examples of these windows are:\\n\"L...R\" -> \"L...R\"\\n\"R...L\" -> \"RR.LL\"\\n\"....L\" -> \"LLLLL\"\\n\"R....\" -> \"RRRRR\"\\n\\nWith those examples in mind, there are really only a few cases we need to deal with. They are:\\n\\n\\t1. we create a window that needs to be filled. If this is the case, there are a few things to consider:\\n\\t\\t- the window is of the form \"R...L\" -> fill while LO and HI pointers move toward each other\\n\\t\\t- the window is of the form \"....L\" -> fill totally with L\\n\\t\\t- the window is of the form \"R....\" -> fill totally with R\\n\\n\\t2. we create a window that has no change. (EX. \"L....R\", or \"....R\", or \"L....\")\\n\\n\\ndefining a do_fill function to fill our dominoes array keeps the main method concise. Also, LO and HI values are copied into the do_fill function, so we don\\'t have to reset them in our main while loop.\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        lo, hi = 0, 0\\n        d = list(dominoes)\\n        chk = {\"L\", \"R\"}\\n        while hi < len(d):\\n\\t\\t   #window needs to be filled or we might have a postfix like \"R....\", so fill it\\n            if d[hi] in chk or hi == len(d)-1:\\n                self.do_fill(lo, hi, d)\\n                lo=hi\\n            hi+=1\\n            \\n        return \"\".join(d)\\n    \\n    def do_fill(self, lo, hi, d):\\n        if d[hi] == \"L\":\\n            if d[lo] == \"R\":\\n\\t\\t\\t    #window is Rs from the left and Ls from the right\\n                while lo < hi:\\n                    d[lo] = \"R\"\\n                    d[hi] = \"L\"\\n                    lo+=1\\n                    hi-=1\\n            else:\\n\\t\\t\\t   #window is completely L\\n                while lo <= hi:\\n                    d[lo] = \"L\"\\n                    lo+=1                 \\n        elif d[lo] == \"R\":\\n\\t\\t\\t\\t#window is completely R\\n                while lo <= hi:\\n                    d[lo] = \"R\"\\n                    lo+=1  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        lo, hi = 0, 0\\n        d = list(dominoes)\\n        chk = {\"L\", \"R\"}\\n        while hi < len(d):\\n\\t\\t   #window needs to be filled or we might have a postfix like \"R....\", so fill it\\n            if d[hi] in chk or hi == len(d)-1:\\n                self.do_fill(lo, hi, d)\\n                lo=hi\\n            hi+=1\\n            \\n        return \"\".join(d)\\n    \\n    def do_fill(self, lo, hi, d):\\n        if d[hi] == \"L\":\\n            if d[lo] == \"R\":\\n\\t\\t\\t    #window is Rs from the left and Ls from the right\\n                while lo < hi:\\n                    d[lo] = \"R\"\\n                    d[hi] = \"L\"\\n                    lo+=1\\n                    hi-=1\\n            else:\\n\\t\\t\\t   #window is completely L\\n                while lo <= hi:\\n                    d[lo] = \"L\"\\n                    lo+=1                 \\n        elif d[lo] == \"R\":\\n\\t\\t\\t\\t#window is completely R\\n                while lo <= hi:\\n                    d[lo] = \"R\"\\n                    lo+=1  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352147,
                "title": "fastest-o-n-solution-c-well-explained",
                "content": "1. Just keep a track of nearest left in left array and nearest right in right array\\n2. The one which is smaller will have more influence on that point \\n3. If both are equal it implies no  change to that domino\\n```\\nstring pushDominoes(string dominoes) {\\n\\n\\tint n=dominoes.size();\\n\\tvector<int> left(n);\\n\\tvector<int> right(n);\\n\\n\\tint k=-1;\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tif(dominoes[i]==\\'R\\')\\n\\t\\t\\tk=0;\\n\\t\\telse if(dominoes[i]==\\'.\\' && k>=0)\\n\\t\\t\\tk++;\\n\\t\\telse\\n\\t\\t\\tk=-1;\\n\\n\\t\\tright[i]=k;\\n\\t}\\n\\n\\t for(int i=n-1;i>=0;i--){\\n\\t\\tif(dominoes[i]==\\'L\\')\\n\\t\\t\\tk=0;\\n\\t\\telse if(dominoes[i]==\\'.\\' && k>=0)\\n\\t\\t\\tk++;\\n\\t\\telse\\n\\t\\t\\tk=-1;\\n\\n\\t\\tleft[i]=k;\\n\\t}\\n\\tstring ans=\"\";\\n\\n\\tfor(int i=0;i<n;i++){\\n\\t  if(left[i]==-1 && right[i]==-1)\\n\\t\\t  ans.push_back(\\'.\\');\\n\\t  else if(left[i]==-1)  \\n\\t\\t  ans.push_back(\\'R\\');\\n\\t  else if(right[i]==-1)  \\n\\t\\t  ans.push_back(\\'L\\');\\n\\t  else if(right[i]<left[i])\\n\\t\\t  ans.push_back(\\'R\\');\\n\\t  else if(right[i]>left[i])\\n\\t\\t  ans.push_back(\\'L\\');\\n\\t  else if(right[i]==left[i])\\n\\t\\t  ans.push_back(\\'.\\');  \\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\nIf this solution helps, Do Upvote !",
                "solutionTags": [],
                "code": "```\\nstring pushDominoes(string dominoes) {\\n\\n\\tint n=dominoes.size();\\n\\tvector<int> left(n);\\n\\tvector<int> right(n);\\n\\n\\tint k=-1;\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tif(dominoes[i]==\\'R\\')\\n\\t\\t\\tk=0;\\n\\t\\telse if(dominoes[i]==\\'.\\' && k>=0)\\n\\t\\t\\tk++;\\n\\t\\telse\\n\\t\\t\\tk=-1;\\n\\n\\t\\tright[i]=k;\\n\\t}\\n\\n\\t for(int i=n-1;i>=0;i--){\\n\\t\\tif(dominoes[i]==\\'L\\')\\n\\t\\t\\tk=0;\\n\\t\\telse if(dominoes[i]==\\'.\\' && k>=0)\\n\\t\\t\\tk++;\\n\\t\\telse\\n\\t\\t\\tk=-1;\\n\\n\\t\\tleft[i]=k;\\n\\t}\\n\\tstring ans=\"\";\\n\\n\\tfor(int i=0;i<n;i++){\\n\\t  if(left[i]==-1 && right[i]==-1)\\n\\t\\t  ans.push_back(\\'.\\');\\n\\t  else if(left[i]==-1)  \\n\\t\\t  ans.push_back(\\'R\\');\\n\\t  else if(right[i]==-1)  \\n\\t\\t  ans.push_back(\\'L\\');\\n\\t  else if(right[i]<left[i])\\n\\t\\t  ans.push_back(\\'R\\');\\n\\t  else if(right[i]>left[i])\\n\\t\\t  ans.push_back(\\'L\\');\\n\\t  else if(right[i]==left[i])\\n\\t\\t  ans.push_back(\\'.\\');  \\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1562258,
                "title": "simple-java-soltuion-using-bfs",
                "content": "class Solution {\\n    \\n\\tpublic String pushDominoes(String dominoes) {\\n        char[] res = new char[dominoes.length()];\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        for(int i = 0 ; i < dominoes.length() ; i++){\\n            if(dominoes.charAt(i) != \\'.\\') \\n                queue.add(i);\\n            res[i] = dominoes.charAt(i);\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            \\n            Map<Integer , Character> map = new HashMap<>();\\n            \\n            while(size-- > 0){\\n                int index = queue.poll();\\n                if(res[index] != \\'.\\'){\\n                    if(res[index] == \\'L\\'){\\n                        if(index - 1 >= 0 && res[index - 1] == \\'.\\'){\\n                            if(map.containsKey(index - 1)) \\n                                map.remove(index - 1);\\n                            else{\\n                                map.put(index - 1 , \\'L\\');\\n                                queue.add(index - 1);\\n                            }\\n                        }\\n                    }else{\\n                        if(index + 1 < res.length && res[index + 1] == \\'.\\'){\\n                            if(map.containsKey(index + 1)) \\n                                map.remove(index + 1);\\n                            else{\\n                                map.put(index + 1 , \\'R\\');\\n                                queue.add(index + 1);\\n                            } \\n                        }\\n                    }\\n                }\\n            }\\n            \\n            for(int key : map.keySet())\\n                res[key] = map.get(key); \\n            \\n        }\\n        \\n        return String.valueOf(res);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    \\n\\tpublic String pushDominoes(String dominoes) {\\n        char[] res = new char[dominoes.length()];\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        for(int i = 0 ; i < dominoes.length() ; i++){\\n            if(dominoes.charAt(i) != \\'.\\') \\n                queue.add(i);\\n            res[i] = dominoes.charAt(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 132929,
                "title": "naive-bfs-easy-to-understand-and-could-be-used-as-first-solution",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] arr = new char[dominoes.length()];\\n        int[] left = new int[dominoes.length()];\\n        int[] right = new int[dominoes.length()];\\n        Queue<Integer> leftQ = new LinkedList<>();\\n        Queue<Integer> rightQ = new LinkedList<>();\\n        Arrays.fill(left, Integer.MAX_VALUE);\\n        Arrays.fill(right, Integer.MAX_VALUE);\\n        for (int i = 0; i < dominoes.length(); i++) {\\n            if (dominoes.charAt(i) == \\'L\\') {\\n                leftQ.offer(i);\\n                left[i] = 0;\\n            }\\n            if (dominoes.charAt(i) == \\'R\\') {\\n                rightQ.offer(i);\\n                right[i] = 0;\\n            }\\n        }\\n        int step = 0;\\n        while (leftQ.size() > 0 || rightQ.size() > 0) {\\n            step++;\\n            int leftSize = leftQ.size();\\n            while (leftSize > 0) {\\n                leftSize--;\\n                int pos = leftQ.poll();\\n                if (pos > 0 && left[pos - 1] == Integer.MAX_VALUE && dominoes.charAt(pos - 1) != \\'R\\') {\\n                    leftQ.offer(pos - 1);\\n                    left[pos - 1] = step;\\n                }\\n            }\\n            int rightSize = rightQ.size();\\n            while (rightSize > 0) {\\n                rightSize--;\\n                int pos = rightQ.poll();\\n                if (pos + 1< dominoes.length() && right[pos + 1] == Integer.MAX_VALUE && dominoes.charAt(pos + 1) != \\'L\\') {\\n                    rightQ.offer(pos + 1);\\n                    right[pos + 1] = step;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < dominoes.length(); i++) {\\n            if (left[i] - right[i] == 0) {\\n                arr[i] = \\'.\\';\\n            }\\n            else if (left[i] - right[i] > 0) {\\n                arr[i] = \\'R\\';\\n            }\\n            else {\\n                arr[i] = \\'L\\';\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] arr = new char[dominoes.length()];\\n        int[] left = new int[dominoes.length()];\\n        int[] right = new int[dominoes.length()];\\n        Queue<Integer> leftQ = new LinkedList<>();\\n        Queue<Integer> rightQ = new LinkedList<>();\\n        Arrays.fill(left, Integer.MAX_VALUE);\\n        Arrays.fill(right, Integer.MAX_VALUE);\\n        for (int i = 0; i < dominoes.length(); i++) {\\n            if (dominoes.charAt(i) == \\'L\\') {\\n                leftQ.offer(i);\\n                left[i] = 0;\\n            }\\n            if (dominoes.charAt(i) == \\'R\\') {\\n                rightQ.offer(i);\\n                right[i] = 0;\\n            }\\n        }\\n        int step = 0;\\n        while (leftQ.size() > 0 || rightQ.size() > 0) {\\n            step++;\\n            int leftSize = leftQ.size();\\n            while (leftSize > 0) {\\n                leftSize--;\\n                int pos = leftQ.poll();\\n                if (pos > 0 && left[pos - 1] == Integer.MAX_VALUE && dominoes.charAt(pos - 1) != \\'R\\') {\\n                    leftQ.offer(pos - 1);\\n                    left[pos - 1] = step;\\n                }\\n            }\\n            int rightSize = rightQ.size();\\n            while (rightSize > 0) {\\n                rightSize--;\\n                int pos = rightQ.poll();\\n                if (pos + 1< dominoes.length() && right[pos + 1] == Integer.MAX_VALUE && dominoes.charAt(pos + 1) != \\'L\\') {\\n                    rightQ.offer(pos + 1);\\n                    right[pos + 1] = step;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < dominoes.length(); i++) {\\n            if (left[i] - right[i] == 0) {\\n                arr[i] = \\'.\\';\\n            }\\n            else if (left[i] - right[i] > 0) {\\n                arr[i] = \\'R\\';\\n            }\\n            else {\\n                arr[i] = \\'L\\';\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629708,
                "title": "simple-python3-solution-99-faster-using-stringreplacement-explained",
                "content": "## ***UPVOTE*** if it is helpful\\n``` \\nclass Solution:         # States for the dominoes:\\n                        #   \\u2022 Any triplet that reaches the state \\'R.L\\' remains\\n                        #     that state permanently.\\n                        #  \\n                        #   \\u2022 These changes occur to pairs that are not part of an \\'R.L\\':\\n                        #     \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\'\\n\\n                        #  Here\\'s the plan:\\n                        #    1) To avoid the problem with the \\'R.L\\' state when we  address the \\n\\t\\t\\t\\t\\t\\t#       \\'R.\\' --> \\'RR\\' and  \\'.L\\' --> \\'LL\\' changes, we replace each \\'R.L\\' \\n\\t\\t\\t\\t\\t\\t#.       with a dummy string (say, \\'xxx\\').\\n                        #       \\n                        #    2) We perform the \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\' replacements.\\n\\n                        #    3) Once the actions described in 1) and 2) are completed, we repeat \\n                        #       until no changes occur. We replace the dummy string with \\'R.L\\'. \\n    def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       # <-- 1)\\n            dominoes = dominoes.replace(\\'R.\\', \\'RR\\')         # <-- 2)\\n            dominoes = dominoes.replace(\\'.L\\', \\'LL\\')         # <-- 2)\\n\\n        return  dominoes.replace(\\'xxx\\', \\'R.L\\')              # <-- 3)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:         # States for the dominoes:\\n                        #   \\u2022 Any triplet that reaches the state \\'R.L\\' remains\\n                        #     that state permanently.\\n                        #  \\n                        #   \\u2022 These changes occur to pairs that are not part of an \\'R.L\\':\\n                        #     \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\'\\n\\n                        #  Here\\'s the plan:\\n                        #    1) To avoid the problem with the \\'R.L\\' state when we  address the \\n\\t\\t\\t\\t\\t\\t#       \\'R.\\' --> \\'RR\\' and  \\'.L\\' --> \\'LL\\' changes, we replace each \\'R.L\\' \\n\\t\\t\\t\\t\\t\\t#.       with a dummy string (say, \\'xxx\\').\\n                        #       \\n                        #    2) We perform the \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\' replacements.\\n\\n                        #    3) Once the actions described in 1) and 2) are completed, we repeat \\n                        #       until no changes occur. We replace the dummy string with \\'R.L\\'. \\n    def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       # <-- 1)\\n            dominoes = dominoes.replace(\\'R.\\', \\'RR\\')         # <-- 2)\\n            dominoes = dominoes.replace(\\'.L\\', \\'LL\\')         # <-- 2)\\n\\n        return  dominoes.replace(\\'xxx\\', \\'R.L\\')              # <-- 3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628701,
                "title": "easy-to-understand-dp-solution-explained-line-by-line-o-n",
                "content": "The problem becomes very easy to understand once we look from the point of view of any dominoe. Consider any stable dominoe at time 0. If there exists a dominoe to its right that has been tilted to the left at time 0- let\\'s say at a distance of A, our current dominoe will be tilted to the left at time A in absence of any other force from the left. Now suppose, if there exists a dominoe to the left that has been tilted to the right at time 0- let\\'s say at a distance of B, our current dominoe will be tilted to the right at time B. Now the dominoe faces 2 opposing forces at time A & time B. There are 3 scenarios:-\\n\\n- **A==B :** In this case the dominoe will face opposing forces exactly at same time and hence won\\'t move in either direction.\\n- **A < B :** The dominoe will face a force from the right pushing it to the left much before any force comes from the left pushing it to the right. Hence it will tilt to the left.\\n- **A > B :** By similar reasoning as above the dominoe will tilt to the right.\\n\\nSo during the implementation, we just need to maintain two vectors - L & R, denoting the earliest time at which any i\\'th dominoe will face a force to the left and right respectively. If a dominoe will never face a force to the left, L[i] = INT_MAX (denoting infinity) and similarly if the dominoe never faces a force to the right, R[i] = INT_MAX.\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tvector<int> L(n,INT_MAX);\\n\\t\\t\\tvector<int> R(n,INT_MAX);\\n\\t\\t\\t\\n\\t\\t\\t//Initialize L vector\\n\\t\\t\\tif(s[n-1]==\\'L\\')\\n\\t\\t\\t\\tL[n-1]=0;\\n\\t\\t\\tfor(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'R\\')\\n\\t\\t\\t\\t\\tcontinue;    // This is because if there exists any dominoe to the right pushing to the left,\\n\\t\\t\\t\\t\\t\\t      \\t// our current (i\\'th) dominoe cancels it with a right force of its own\\n\\t\\t\\t\\tif(s[i]==\\'L\\')\\n\\t\\t\\t\\t\\tL[i]=0;\\n\\t\\t\\t\\telse if(L[i+1]!=INT_MAX)\\n\\t\\t\\t\\t\\tL[i]=1+L[i+1];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t//Initialize R vector\\n\\t\\t\\tif(s[0]==\\'R\\')\\n\\t\\t\\t\\tR[0]=0;\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'L\\')\\n\\t\\t\\t\\t\\tcontinue;   // This is because if there exists any dominoe to the left pushing to the right,\\n\\t\\t\\t\\t\\t      \\t  // our current (i\\'th) dominoe cancels it with a left force of its own\\n\\t\\t\\t\\tif(s[i]==\\'R\\')\\n\\t\\t\\t\\t\\tR[i]=0;\\n\\t\\t\\t\\telse if(R[i-1]!=INT_MAX)\\n\\t\\t\\t\\t\\tR[i]=1+R[i-1];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// Now start looking from the point of view of every dominoe\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(L[i]==R[i])    // The dominoe faces both forces at equal times, or never faces a force from either side (i.e. L[i]=R[i]=INT_MAX)\\n\\t\\t\\t\\t\\tans+=\".\";\\n\\t\\t\\t\\telse if(L[i]<R[i])  // Left force reaches the dominoe earlier\\n\\t\\t\\t\\t\\tans+=\"L\";\\n\\t\\t\\t\\telse              // Right force reaches the dominoe earlier\\n\\t\\t\\t\\t\\tans+=\"R\";\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tvector<int> L(n,INT_MAX);\\n\\t\\t\\tvector<int> R(n,INT_MAX);\\n\\t\\t\\t\\n\\t\\t\\t//Initialize L vector\\n\\t\\t\\tif(s[n-1]==\\'L\\')\\n\\t\\t\\t\\tL[n-1]=0;\\n\\t\\t\\tfor(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'R\\')\\n\\t\\t\\t\\t\\tcontinue;    // This is because if there exists any dominoe to the right pushing to the left,\\n\\t\\t\\t\\t\\t\\t      \\t// our current (i\\'th) dominoe cancels it with a right force of its own\\n\\t\\t\\t\\tif(s[i]==\\'L\\')\\n\\t\\t\\t\\t\\tL[i]=0;\\n\\t\\t\\t\\telse if(L[i+1]!=INT_MAX)\\n\\t\\t\\t\\t\\tL[i]=1+L[i+1];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 753346,
                "title": "c-o-n-solution-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        int n = d.size();\\n        d=\"L\"+d+\"R\";\\n        int l=0,r=1,p1,p2;\\n        while(l<=(n+1) && r<=(n+1)){\\n            while(d[r]==\\'.\\'){\\n                r++;\\n            }\\n            if(d[l]==\\'R\\' && d[r]==\\'L\\'){\\n                p1=l+1,p2=r-1;\\n                while(p1<p2){\\n                    d[p1]=\\'R\\'; d[p2]=\\'L\\'; p1++; p2--;\\n                }\\n            }else if(d[l]==\\'L\\' && d[r]==\\'L\\'){\\n                p2=r-1;\\n                while(p2>l){\\n                    d[p2]=\\'L\\'; p2--;\\n                }\\n            }else if(d[l]==\\'R\\' && d[r]==\\'R\\'){\\n                p1=l+1;\\n                while(p1<r){\\n                    d[p1]=\\'R\\'; p1++;\\n                }\\n            }\\n            l=r;\\n            r++;\\n        }\\n        return d.substr(1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        int n = d.size();\\n        d=\"L\"+d+\"R\";\\n        int l=0,r=1,p1,p2;\\n        while(l<=(n+1) && r<=(n+1)){\\n            while(d[r]==\\'.\\'){\\n                r++;\\n            }\\n            if(d[l]==\\'R\\' && d[r]==\\'L\\'){\\n                p1=l+1,p2=r-1;\\n                while(p1<p2){\\n                    d[p1]=\\'R\\'; d[p2]=\\'L\\'; p1++; p2--;\\n                }\\n            }else if(d[l]==\\'L\\' && d[r]==\\'L\\'){\\n                p2=r-1;\\n                while(p2>l){\\n                    d[p2]=\\'L\\'; p2--;\\n                }\\n            }else if(d[l]==\\'R\\' && d[r]==\\'R\\'){\\n                p1=l+1;\\n                while(p1<r){\\n                    d[p1]=\\'R\\'; p1++;\\n                }\\n            }\\n            l=r;\\n            r++;\\n        }\\n        return d.substr(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628679,
                "title": "daily-leetcoding-challenge-september-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/push-dominoes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Adjacent Symbols [Accepted]\n\n  \n**Approach 2:** Calculate Force [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/push-dominoes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1884399,
                "title": "c-87-faster-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int binarysearch(vector<int>&l,int pos)\\n    {\\n        int e=l.size()-1,s=0,index=-1;\\n        while(s<=e)\\n        {\\n            int mid=s+(e-s)/2;\\n            if(l[mid]>pos)\\n            {\\n                index=mid;\\n                e=mid-1;\\n            }else s=mid+1;\\n        }\\n        return index;\\n    }\\n    string pushDominoes(string s) \\n    {\\n        vector<int>l,r;\\n        int n=s.size(),i=0;\\n        bool ch=false;\\n\\t\\t//storing positions of l and r\\n        for(int i=0;i<n;i++)\\n        {     \\n            if(s[i]==\\'R\\')\\n            {\\n                if(ch)r[r.size()-1]=i;\\n                else r.push_back(i);\\n                ch=true;\\n            }else if(s[i]==\\'L\\')\\n            {\\n                l.push_back(i);\\n                ch=false;\\n            }\\n        }\\n        \\n        for(i=0;i<r.size();i++)\\n        {\\n            int index=binarysearch(l,r[i]);\\n            if(index==-1)break;\\n            // cout<<r[i]<<\" \"<<l[index]<<endl;\\n            int mid=l[index]-r[i]-1;\\n            mid/=2;\\n            if(mid==0)continue;\\n            int ss=r[i]+1,e=l[index]-1,c=mid;\\n            \\n            while(c--)\\n            {\\n                s[ss++]=\\'R\\';\\n            }\\n            \\n            c=mid;\\n            while(c--)\\n            {\\n                s[e--]=\\'L\\';\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'.\\' )\\n            {\\n                while(i-1>=0 && i+1<=n && s[i-1]==\\'R\\' && (s[i+1]==\\'R\\' || s[i+1]==\\'.\\'))   {\\n                    s[i++]=\\'R\\';\\n                }\\n                // cout<<i<<endl;\\n                if(i-1>=0 && i==n-1 && s[i-1]==\\'R\\')s[i]=\\'R\\';\\n                int j=i;\\n                while(i-1>=0 && i+1<=n && s[i+1]==\\'L\\' && s[i-1]!=\\'R\\')\\n                {\\n                    s[i--]=\\'L\\';\\n                }\\n                while(i-1>=0 && i+1<=n && s[i-1]==\\'L\\' && s[i+1]==\\'L\\')\\n                {\\n                    s[i--]=\\'L\\';\\n                }\\n                if(i==0 && s[i+1]==\\'L\\')s[i]=\\'L\\';\\n                i=j;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binarysearch(vector<int>&l,int pos)\\n    {\\n        int e=l.size()-1,s=0,index=-1;\\n        while(s<=e)\\n        {\\n            int mid=s+(e-s)/2;\\n            if(l[mid]>pos)\\n            {\\n                index=mid;\\n                e=mid-1;\\n            }else s=mid+1;\\n        }\\n        return index;\\n    }\\n    string pushDominoes(string s) \\n    {\\n        vector<int>l,r;\\n        int n=s.size(),i=0;\\n        bool ch=false;\\n\\t\\t//storing positions of l and r\\n        for(int i=0;i<n;i++)\\n        {     \\n            if(s[i]==\\'R\\')\\n            {\\n                if(ch)r[r.size()-1]=i;\\n                else r.push_back(i);\\n                ch=true;\\n            }else if(s[i]==\\'L\\')\\n            {\\n                l.push_back(i);\\n                ch=false;\\n            }\\n        }\\n        \\n        for(i=0;i<r.size();i++)\\n        {\\n            int index=binarysearch(l,r[i]);\\n            if(index==-1)break;\\n            // cout<<r[i]<<\" \"<<l[index]<<endl;\\n            int mid=l[index]-r[i]-1;\\n            mid/=2;\\n            if(mid==0)continue;\\n            int ss=r[i]+1,e=l[index]-1,c=mid;\\n            \\n            while(c--)\\n            {\\n                s[ss++]=\\'R\\';\\n            }\\n            \\n            c=mid;\\n            while(c--)\\n            {\\n                s[e--]=\\'L\\';\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'.\\' )\\n            {\\n                while(i-1>=0 && i+1<=n && s[i-1]==\\'R\\' && (s[i+1]==\\'R\\' || s[i+1]==\\'.\\'))   {\\n                    s[i++]=\\'R\\';\\n                }\\n                // cout<<i<<endl;\\n                if(i-1>=0 && i==n-1 && s[i-1]==\\'R\\')s[i]=\\'R\\';\\n                int j=i;\\n                while(i-1>=0 && i+1<=n && s[i+1]==\\'L\\' && s[i-1]!=\\'R\\')\\n                {\\n                    s[i--]=\\'L\\';\\n                }\\n                while(i-1>=0 && i+1<=n && s[i-1]==\\'L\\' && s[i+1]==\\'L\\')\\n                {\\n                    s[i--]=\\'L\\';\\n                }\\n                if(i==0 && s[i+1]==\\'L\\')s[i]=\\'L\\';\\n                i=j;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2632337,
                "title": "c-simulate-each-second",
                "content": "Busy day, didn\\'t have time to think of more than one approach of solving this problem.\\n\\n### Approach 1: simulate each second (78ms ~40%)\\n\\nThe intiution is the simulate second after second of the falling dominos. We start out with the dominios that are not standing straight and then we use the current state to compute the next state. This needs to happen in one go. Only at the end of a second we make the current state equal to the newly computed state. For long strings copying the state feels expensive. A variation might be to keep track in a vector which dominos we need to change and modify them before the next round.\\n\\n```cpp\\n    string pushDominoes(string ds) {\\n        const int n = size(ds);\\n        queue<int> q;\\n        // Add all \\'L\\'s and \\'R\\'s to be processed.\\n        for (int i = 0; i < n; ++i) {\\n            if (ds[i] != \\'.\\') q.push(i);\\n        }\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            // Process each second on it\\'s own. We need to make a decision\\n            // based on the current state for computing the next state, because\\n            // all dominos fall simultaneously.\\n            string next = ds;\\n            while (q_size--) {\\n                const int i = q.front(); q.pop();\\n                if (ds[i] == \\'R\\') {\\n                    // If the domino is leaning right and can push the next one over ...\\n                    if (i < n - 1 && ds[i + 1] == \\'.\\') {\\n                        // ... are we pushing the last one or isn\\'t the next one over leaning against it?\\n                        if (i == n - 2 || i < n - 2 && ds[i + 2] != \\'L\\') {\\n                            next[i + 1] = \\'R\\';\\n                            q.push(i + 1);\\n                        }\\n                    }\\n                } else {\\n                    // Same for a left leaning domino ...\\n                    if (i > 0 && ds[i - 1] == \\'.\\') {\\n                        if (i == 1 || i > 1 && ds[i - 2] != \\'R\\') {\\n                            next[i - 1] = \\'L\\';\\n                            q.push(i - 1);\\n                        }\\n                    }\\n                }\\n            }\\n            // Take over the state for the next second.\\n            swap(ds, next);\\n        }\\n        return ds;\\n    }\\n```\\n\\nKeep track of the modifications in a extra vector only seems to make it slightly faster (72ms):\\n\\n```cpp\\n    string pushDominoes(string ds) {\\n        const int n = size(ds);\\n        queue<int> q;\\n        // Add all \\'L\\'s and \\'R\\'s to be processed.\\n        for (int i = 0; i < n; ++i) {\\n            if (ds[i] != \\'.\\') q.push(i);\\n        }\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            // Process each second on it\\'s own. We need to make a decision\\n            // based on the current state for computing the next state, because\\n            // all dominos fall simultaneously.\\n            vector<pair<int, char>> mod;\\n            while (q_size--) {\\n                const int i = q.front(); q.pop();\\n                if (ds[i] == \\'R\\') {\\n                    // If the domino is leaning right and can push the next one over ...\\n                    if (i < n - 1 && ds[i + 1] == \\'.\\') {\\n                        if (i == n - 2 || i < n - 2 && ds[i + 2] != \\'L\\') {\\n                            mod.push_back({i + 1, \\'R\\'});\\n                        }\\n                    }\\n                } else {\\n                    // Same for a left leaning domino ...\\n                    if (i > 0 && ds[i - 1] == \\'.\\') {\\n                        if (i == 1 || i > 1 && ds[i - 2] != \\'R\\') {\\n                            mod.push_back({i - 1, \\'L\\'});\\n                        }\\n                    }\\n                }\\n            }\\n            // Apply the change for the next round.\\n            for (auto [i, ch] : mod) {\\n                ds[i] = ch;\\n                q.push(i);\\n            }\\n        }\\n        return ds;\\n    }\\n```\\n\\n\\n**Complexity Analysis**\\n  * Ain\\'t no time for that. :)\\n\\n_As always: Feedback, questions, and comments are welcome, and consider leaving a like (aka upvote) before you leave._\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**\\n",
                "solutionTags": [],
                "code": "```cpp\\n    string pushDominoes(string ds) {\\n        const int n = size(ds);\\n        queue<int> q;\\n        // Add all \\'L\\'s and \\'R\\'s to be processed.\\n        for (int i = 0; i < n; ++i) {\\n            if (ds[i] != \\'.\\') q.push(i);\\n        }\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            // Process each second on it\\'s own. We need to make a decision\\n            // based on the current state for computing the next state, because\\n            // all dominos fall simultaneously.\\n            string next = ds;\\n            while (q_size--) {\\n                const int i = q.front(); q.pop();\\n                if (ds[i] == \\'R\\') {\\n                    // If the domino is leaning right and can push the next one over ...\\n                    if (i < n - 1 && ds[i + 1] == \\'.\\') {\\n                        // ... are we pushing the last one or isn\\'t the next one over leaning against it?\\n                        if (i == n - 2 || i < n - 2 && ds[i + 2] != \\'L\\') {\\n                            next[i + 1] = \\'R\\';\\n                            q.push(i + 1);\\n                        }\\n                    }\\n                } else {\\n                    // Same for a left leaning domino ...\\n                    if (i > 0 && ds[i - 1] == \\'.\\') {\\n                        if (i == 1 || i > 1 && ds[i - 2] != \\'R\\') {\\n                            next[i - 1] = \\'L\\';\\n                            q.push(i - 1);\\n                        }\\n                    }\\n                }\\n            }\\n            // Take over the state for the next second.\\n            swap(ds, next);\\n        }\\n        return ds;\\n    }\\n```\n```cpp\\n    string pushDominoes(string ds) {\\n        const int n = size(ds);\\n        queue<int> q;\\n        // Add all \\'L\\'s and \\'R\\'s to be processed.\\n        for (int i = 0; i < n; ++i) {\\n            if (ds[i] != \\'.\\') q.push(i);\\n        }\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            // Process each second on it\\'s own. We need to make a decision\\n            // based on the current state for computing the next state, because\\n            // all dominos fall simultaneously.\\n            vector<pair<int, char>> mod;\\n            while (q_size--) {\\n                const int i = q.front(); q.pop();\\n                if (ds[i] == \\'R\\') {\\n                    // If the domino is leaning right and can push the next one over ...\\n                    if (i < n - 1 && ds[i + 1] == \\'.\\') {\\n                        if (i == n - 2 || i < n - 2 && ds[i + 2] != \\'L\\') {\\n                            mod.push_back({i + 1, \\'R\\'});\\n                        }\\n                    }\\n                } else {\\n                    // Same for a left leaning domino ...\\n                    if (i > 0 && ds[i - 1] == \\'.\\') {\\n                        if (i == 1 || i > 1 && ds[i - 2] != \\'R\\') {\\n                            mod.push_back({i - 1, \\'L\\'});\\n                        }\\n                    }\\n                }\\n            }\\n            // Apply the change for the next round.\\n            for (auto [i, ch] : mod) {\\n                ds[i] = ch;\\n                q.push(i);\\n            }\\n        }\\n        return ds;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631190,
                "title": "java-commented-all-cases",
                "content": "```\\n/*\\n\\n    \"L.L.R...LR..L..R\"\\n    four orientations possible\\n      (1)      [L...L] -> all [LLLLL]\\n      \\n      (2)      [R...L] -> two cases even or odd numbers of spaces between them\\n               case I  (even)  -> first half [RRR]\\n                                  second half [LLL]\\n               case II  (odd)  -> first half [RR] \\n                                  middle piece will stand [.] \\n                                  second half [LL]\\n      (3)      [L...R] -> no change between [L...R]\\n      (4)      [R...R] -> all [RRRRR]\\n\\t  \\n*/\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        //  adding \"L\" and \"R\" on left and right (respectively) will not cause any change\\n        dominoes = \"L\" + dominoes + \"R\";\\n        char[] a = dominoes.toCharArray();\\n        int l = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            while (a[i] == \\'.\\') {\\n                //  skip all the dominoes that are not initially pushed\\n                i++;\\n            }\\n            //  four cases possible\\n            if (a[l] == \\'L\\' && a[i] == \\'L\\') {\\n                while (l != i) a[l++] = \\'L\\';\\n            } else if(a[l] == \\'R\\' && a[i] == \\'L\\') {\\n                //  two cases of even number of non pushed dominoes or odd \\n                //  both cases are handled in the while loop\\n                int oi = i;    //  saving original i\\n\\t\\t\\t\\twhile (l < i) {\\n                    a[l++] = \\'R\\';\\n                    a[i--] = \\'L\\';\\n                }\\n                i = oi;\\n            } else if(a[l] == \\'L\\' && a[i] == \\'R\\') {\\n                //  no change inside the [L...R] pair\\n            } else if(a[l] == \\'R\\' && a[i] == \\'R\\') {\\n                while (l != i) a[l++] = \\'R\\';\\n            }\\n            l = i;\\n        }\\n\\t\\t// removing the initial changes we made\\n        return (new String(a)).substring(1, a.length - 1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String pushDominoes(String dominoes) {\\n        //  adding \"L\" and \"R\" on left and right (respectively) will not cause any change\\n        dominoes = \"L\" + dominoes + \"R\";\\n        char[] a = dominoes.toCharArray();\\n        int l = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            while (a[i] == \\'.\\') {\\n                //  skip all the dominoes that are not initially pushed\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2356371,
                "title": "easy-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n=size(s);\\n        queue<pair<int,char>>q;//queue to store the index and character at that index\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'L\\' or s[i]==\\'R\\') //pushing all the L and R into our queue\\n                q.push({i,s[i]});\\n        }\\n        vector<pair<int,char>>temp;//a temp vector \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto top=q.front();\\n                q.pop();\\n                int index=top.first;\\n                char ch=top.second;\\n                \\n                if(ch==\\'L\\')//if we encounter an L from queue\\n                {\\n                    if(index-2>=0 and s[index-2]==\\'R\\') continue;//to chck for condition .R.LL\\n                    if(index-1>=0 and s[index-1]==\\'.\\'){\\n                        q.push({index-1,\\'L\\'});\\n                        temp.push_back({index-1,\\'L\\'});\\n                    }\\n                }\\n                else if(ch==\\'R\\')\\n                {\\n                    if(index+2<n and s[index+2]==\\'L\\') continue;//to chck for condition .R.L...\\n                    if(index+1<n and s[index+1]==\\'.\\'){\\n                        q.push({index+1,\\'R\\'});\\n                        temp.push_back({index+1,\\'R\\'});\\n                    }\\n                }\\n            }\\n            for( auto i:temp)//after a level of BFS is done update the original string \\n            {\\n                pair<int,char>&p=i;\\n                s[p.first]=p.second;\\n            }\\n        }\\n        return s;//return the new string\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n=size(s);\\n        queue<pair<int,char>>q;//queue to store the index and character at that index\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'L\\' or s[i]==\\'R\\') //pushing all the L and R into our queue\\n                q.push({i,s[i]});\\n        }\\n        vector<pair<int,char>>temp;//a temp vector \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto top=q.front();\\n                q.pop();\\n                int index=top.first;\\n                char ch=top.second;\\n                \\n                if(ch==\\'L\\')//if we encounter an L from queue\\n                {\\n                    if(index-2>=0 and s[index-2]==\\'R\\') continue;//to chck for condition .R.LL\\n                    if(index-1>=0 and s[index-1]==\\'.\\'){\\n                        q.push({index-1,\\'L\\'});\\n                        temp.push_back({index-1,\\'L\\'});\\n                    }\\n                }\\n                else if(ch==\\'R\\')\\n                {\\n                    if(index+2<n and s[index+2]==\\'L\\') continue;//to chck for condition .R.L...\\n                    if(index+1<n and s[index+1]==\\'.\\'){\\n                        q.push({index+1,\\'R\\'});\\n                        temp.push_back({index+1,\\'R\\'});\\n                    }\\n                }\\n            }\\n            for( auto i:temp)//after a level of BFS is done update the original string \\n            {\\n                pair<int,char>&p=i;\\n                s[p.first]=p.second;\\n            }\\n        }\\n        return s;//return the new string\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630271,
                "title": "c-o-n-time-and-space-solution-commented-code-for-more-understanding",
                "content": "We just need to check the distance of L from the right side of current dominoes[i] and distance of R from the left side of current dominoes[i] and take the minimum of the two. \\nCommented Code for better Understanding. Please Upvote if it helped! \\uD83D\\uDE03\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int>distanceOfL(n, 0), distanceofR(n, 0);\\n    // we traverse from left to right as only the R which are in the left position will affect any dominoes[i] == \\'.\\'\\n        for(int i = 0; i < n; i++){\\n            if(dominoes[i] == \\'R\\'){\\n                distanceofR[i] = 0;\\n            }\\n            // we are checking this because if dominoes[i] == \\'L\\', then we need to cut off the affect of the R \\n\\t\\t\\t//which was present on the left side of the current dominoes[i]\\n            else if(dominoes[i] == \\'L\\'){\\n                distanceofR[i] = 1e9;\\n            }\\n            else{\\n                if(i > 0 && distanceofR[i - 1] != 1e9){\\n                    distanceofR[i] = distanceofR[i - 1] + 1;\\n                }\\n                else{\\n                     distanceofR[i] = 1e9;\\n                }\\n            }\\n        }\\n        // we are traversing from right as only the L which are in right position will affect any dominoes[i] == \\'.\\'\\n        for(int i = n - 1; i >= 0; i--){\\n            if(dominoes[i] == \\'L\\'){\\n                distanceOfL[i] = 0;\\n            }\\n             // we are checking this because if dominoes[i] == R\\', then we need to cut off the affect of the L\\n\\t\\t\\t //which was present on the right side of the current dominoes[i]\\n            else if(dominoes[i] == \\'R\\'){\\n                distanceOfL[i] = 1e9;\\n            }\\n            else{\\n                if(i < n - 1 && distanceOfL[i + 1] != 1e9){\\n                    distanceOfL[i] = distanceOfL[i + 1] + 1;\\n                }\\n                else{\\n                    distanceOfL[i] = 1e9;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(distanceOfL[i] < distanceofR[i]){\\n                dominoes[i] = \\'L\\';\\n            }\\n            else if(distanceofR[i] < distanceOfL[i]){\\n                dominoes[i] = \\'R\\';\\n            }\\n           // When distanceofR[i] == distanceOfL[i], dominoes[i] will be \\'.\\' \\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int>distanceOfL(n, 0), distanceofR(n, 0);\\n    // we traverse from left to right as only the R which are in the left position will affect any dominoes[i] == \\'.\\'\\n        for(int i = 0; i < n; i++){\\n            if(dominoes[i] == \\'R\\'){\\n                distanceofR[i] = 0;\\n            }\\n            // we are checking this because if dominoes[i] == \\'L\\', then we need to cut off the affect of the R \\n\\t\\t\\t//which was present on the left side of the current dominoes[i]\\n            else if(dominoes[i] == \\'L\\'){\\n                distanceofR[i] = 1e9;\\n            }\\n            else{\\n                if(i > 0 && distanceofR[i - 1] != 1e9){\\n                    distanceofR[i] = distanceofR[i - 1] + 1;\\n                }\\n                else{\\n                     distanceofR[i] = 1e9;\\n                }\\n            }\\n        }\\n        // we are traversing from right as only the L which are in right position will affect any dominoes[i] == \\'.\\'\\n        for(int i = n - 1; i >= 0; i--){\\n            if(dominoes[i] == \\'L\\'){\\n                distanceOfL[i] = 0;\\n            }\\n             // we are checking this because if dominoes[i] == R\\', then we need to cut off the affect of the L\\n\\t\\t\\t //which was present on the right side of the current dominoes[i]\\n            else if(dominoes[i] == \\'R\\'){\\n                distanceOfL[i] = 1e9;\\n            }\\n            else{\\n                if(i < n - 1 && distanceOfL[i + 1] != 1e9){\\n                    distanceOfL[i] = distanceOfL[i + 1] + 1;\\n                }\\n                else{\\n                    distanceOfL[i] = 1e9;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(distanceOfL[i] < distanceofR[i]){\\n                dominoes[i] = \\'L\\';\\n            }\\n            else if(distanceofR[i] < distanceOfL[i]){\\n                dominoes[i] = \\'R\\';\\n            }\\n           // When distanceofR[i] == distanceOfL[i], dominoes[i] will be \\'.\\' \\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630182,
                "title": "c-easy-solution-using-if-else",
                "content": "* Make a vector of pair (V) of char and int which **contains** the **characters L and R** with respective indices\\n* make two variables previdx and prevchar ans assign them the first occourence of L or R i.e. **prevchar=v[0].first  , previdx=v[0].second**\\n* traverse in v from index 1\\n* Now Total there are **4 conditions** \\n1.  **prevchar==\\'L\\' and currchar==\\'L\\'** \\n2.  **prevchar==\\'L\\' and currchar==\\'R\\'**\\n3.  **prevchar==\\'R\\' and currchar==\\'R\\'**\\n4.  **prevchar==\\'R\\' and currchar==\\'L\\'**\\n\\n* **Case 1: prevchar==\\'L\\' and currchar==\\'L\\'**\\n Do ans+=\\'L\\' from previdx+1 to curridx\\n* **Case 2: prevchar==\\'L\\' and currchar==\\'R\\'**\\n Do ans+=dominoes[i] from previdx+1 to curridx \\n * **Case 3: prevchar==\\'R\\' and currchar==\\'R\\'**\\n Do ans+=\\'R\\' from previdx+1 to curridx \\n  * **Case 4: prevchar==\\'R\\' and currchar==\\'L\\'**\\n Now in this case find the length of string from previdx to curridx i.e.**len=(curridx-previdx+1)**\\n**If len is odd** \\n  do **ans+=\\'R\\'** from previdx to mid-1 \\n ans+=\\'.\\'\\n and do **ans+=\\'L\\'** from mid+1 to curridx\\n else \\n  do **ans+=\\'R\\'** from previdx to mid\\n and do **ans+=\\'L\\'** from mid+1 to curridx\\n \\n Lastly check if curr idx is less than n-1 then check the prevchar if it is L then append **\\'.\\'** upto n-1 \\n and if it is R then append **\\'R\\'** upto n-1\\n\\n**Time Complexity: O(N)\\nSpace Complexity: O(N)\\nCode**\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        vector<pair<char,int>>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]!=\\'.\\')\\n                v.push_back({dominoes[i],i});\\n        }\\n        if(v.size()==0) return dominoes;\\n        string ans=\"\";\\n        int tmp=v[0].second;\\n            tmp++;\\n        char prevchar;\\n        int previdx=v[0].second;\\n        if(v[0].first==\\'L\\')\\n        {\\n            while(tmp--)\\n            ans+=\\'L\\';\\n            prevchar=\\'L\\';\\n        }\\n        else\\n        {\\n            tmp--;\\n            while(tmp--)\\n            ans+=\\'.\\';\\n            ans+=\\'R\\';\\n            prevchar=\\'R\\';\\n        }\\n        for(int i=1;i<v.size();i++)\\n        {\\n            char currchar=v[i].first;\\n            int curridx=v[i].second;\\n            \\n            if(prevchar==\\'L\\' && currchar==\\'L\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=\\'L\\';\\n                }\\n            }\\n            else if(prevchar==\\'L\\' && currchar==\\'R\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=dominoes[j];\\n                }\\n            }\\n            else if(prevchar==\\'R\\' && currchar==\\'R\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n            }\\n            else if(prevchar==\\'R\\' && currchar==\\'L\\')\\n            {\\n                int len=curridx-previdx+1;\\n                int mid=(previdx+curridx)/2;\\n                if(len&1)\\n                {\\n                    for(int j=previdx+1;j<mid;j++)\\n                    {\\n                        ans+=\\'R\\';\\n                    }\\n                    ans+=\\'.\\';\\n                    for(int j=mid+1;j<=curridx;j++)\\n                    {\\n                        ans+=\\'L\\';\\n                    }\\n                }\\n                else \\n                {\\n                    \\n                    for(int j=previdx+1;j<=mid;j++)\\n                    {\\n                        ans+=\\'R\\';\\n                    }\\n                    // ans+=\\'.\\';\\n                    for(int j=mid+1;j<=curridx;j++)\\n                    {\\n                        ans+=\\'L\\';\\n                    }\\n                }\\n                \\n            }\\n            \\n            previdx=curridx;\\n            prevchar=currchar;\\n        }\\n        if(previdx<n-1)\\n        {\\n            if(prevchar==\\'L\\')\\n            {\\n                for(int i=previdx+1;i<n;i++)\\n                {\\n                    ans+=\\'.\\';\\n                }\\n            }\\n            else {\\n                for(int i=previdx+1;i<n;i++)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        vector<pair<char,int>>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]!=\\'.\\')\\n                v.push_back({dominoes[i],i});\\n        }\\n        if(v.size()==0) return dominoes;\\n        string ans=\"\";\\n        int tmp=v[0].second;\\n            tmp++;\\n        char prevchar;\\n        int previdx=v[0].second;\\n        if(v[0].first==\\'L\\')\\n        {\\n            while(tmp--)\\n            ans+=\\'L\\';\\n            prevchar=\\'L\\';\\n        }\\n        else\\n        {\\n            tmp--;\\n            while(tmp--)\\n            ans+=\\'.\\';\\n            ans+=\\'R\\';\\n            prevchar=\\'R\\';\\n        }\\n        for(int i=1;i<v.size();i++)\\n        {\\n            char currchar=v[i].first;\\n            int curridx=v[i].second;\\n            \\n            if(prevchar==\\'L\\' && currchar==\\'L\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=\\'L\\';\\n                }\\n            }\\n            else if(prevchar==\\'L\\' && currchar==\\'R\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=dominoes[j];\\n                }\\n            }\\n            else if(prevchar==\\'R\\' && currchar==\\'R\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n            }\\n            else if(prevchar==\\'R\\' && currchar==\\'L\\')\\n            {\\n                int len=curridx-previdx+1;\\n                int mid=(previdx+curridx)/2;\\n                if(len&1)\\n                {\\n                    for(int j=previdx+1;j<mid;j++)\\n                    {\\n                        ans+=\\'R\\';\\n                    }\\n                    ans+=\\'.\\';\\n                    for(int j=mid+1;j<=curridx;j++)\\n                    {\\n                        ans+=\\'L\\';\\n                    }\\n                }\\n                else \\n                {\\n                    \\n                    for(int j=previdx+1;j<=mid;j++)\\n                    {\\n                        ans+=\\'R\\';\\n                    }\\n                    // ans+=\\'.\\';\\n                    for(int j=mid+1;j<=curridx;j++)\\n                    {\\n                        ans+=\\'L\\';\\n                    }\\n                }\\n                \\n            }\\n            \\n            previdx=curridx;\\n            prevchar=currchar;\\n        }\\n        if(previdx<n-1)\\n        {\\n            if(prevchar==\\'L\\')\\n            {\\n                for(int i=previdx+1;i<n;i++)\\n                {\\n                    ans+=\\'.\\';\\n                }\\n            }\\n            else {\\n                for(int i=previdx+1;i<n;i++)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629832,
                "title": "easy-python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes = \\'L\\' + dominoes + \\'R\\'\\n        res = []\\n        left = 0\\n        \\n        for right in range(1, len(dominoes)):\\n            if dominoes[right] == \\'.\\': \\n                continue\\n                \\n            middle = right - left - 1\\n            if left: \\n                res.append(dominoes[left])\\n            if dominoes[left] == dominoes[right]: \\n                res.append(dominoes[left] * middle)\\n            elif dominoes[left] == \\'L\\' and dominoes[right] == \\'R\\':\\n                res.append(\\'.\\' * middle)\\n            else: \\n                res.append(\\'R\\' * (middle // 2) + \\'.\\' * (middle % 2) + \\'L\\' * (middle // 2))\\n            left = right\\n            \\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes = \\'L\\' + dominoes + \\'R\\'\\n        res = []\\n        left = 0\\n        \\n        for right in range(1, len(dominoes)):\\n            if dominoes[right] == \\'.\\': \\n                continue\\n                \\n            middle = right - left - 1\\n            if left: \\n                res.append(dominoes[left])\\n            if dominoes[left] == dominoes[right]: \\n                res.append(dominoes[left] * middle)\\n            elif dominoes[left] == \\'L\\' and dominoes[right] == \\'R\\':\\n                res.append(\\'.\\' * middle)\\n            else: \\n                res.append(\\'R\\' * (middle // 2) + \\'.\\' * (middle % 2) + \\'L\\' * (middle // 2))\\n            left = right\\n            \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629079,
                "title": "javascript-easy-solution-with-explanation-two-pointers-dynamic-programming",
                "content": "We are going to approach this problem by using dp Array \\n\\nLets take example \\nFrom the left of dominoes we are pushing towards Right and we are storing the index of the last right push if the left push is on the particular point we are putting the index as -1 and also if there are no right push as of now and we have \".\" means also we are considering -1.\\nGiven Input =>  \".L.R...LR..L..\"\\nAfter the left-side right push dpL => [ -1,-1,-1,3,3,3,3,-1,8,8,8,-1,-1,-1]\\n\\nAfter that we have to take the right-side left push we are keeping the \\'R\\' and \".\" as -1 and storing the index of the left push from the right side.\\nAfter the right-side-left-push dpR =>[1,1,-1,-1,7,7,7,7,-1,11,11,11,-1,-1]\\n\\nThen For finalizing result string we are doing followin checks\\n 1. if both the dp consist of -1 that means no push occured on the particular domino so we are adding \".\"\\n 2. Then are checking is any one of the dp having the push like its having any index other than -1. If dpR consist means that is left push vice versa for the dp L.\\n 3. Then if the both contains index we are calculating the nearest index and putting their value if both are equal we are adding \".\" \\n\\nPlease upvote this solution if you like this \\n\\n\\n```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(d) {\\n    let dpL = [];\\n    let dpR = [];\\n    for(let i =0;i<d.length;i++){\\n        if(d[i]===\\'R\\'){\\n            dpL[i] = i;\\n        } else if(d[i]===\\'L\\'){\\n            dpL[i] = -1;\\n        } else if(dpL[i]!=-1){\\n            dpL[i] = dpL[i-1]===undefined ? -1:dpL[i-1];\\n        }\\n        let j = d.length-i-1;\\n        if(d[j]===\\'L\\'){\\n            dpR[j] = j;\\n        } else if(d[j]===\\'R\\'){\\n            dpR[j] = -1;\\n        } else if(dpR[j]!=-1){\\n            dpR[j] = dpR[j+1]===undefined ? -1:dpR[j+1];\\n        }\\n    }\\n    let res = \\'\\';\\n    for(let i=0;i<d.length;i++){\\n\\t\\t// check 1\\n        if(dpR[i]==-1&dpL[i]==-1){\\n            res+=\".\"\\n            }\\n        else if(dpL[i]!==-1 && dpR[i]!==-1){\\n\\t\\t\\t//  check 3\\n            if(Math.abs(dpL[i]-i)===Math.abs(dpR[i]-i)){\\n                res+=\".\";\\n            }\\n            else if(Math.abs(dpL[i]-i)<Math.abs(dpR[i]-i)){\\n                res+=\\'R\\';\\n            }\\n            else{\\n                res+=\\'L\\';\\n            }\\n        }\\n        else{\\n\\t\\t\\t// check 2\\n            res+=dpL[i]===-1?\\'L\\':\\'R\\'\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(d) {\\n    let dpL = [];\\n    let dpR = [];\\n    for(let i =0;i<d.length;i++){\\n        if(d[i]===\\'R\\'){\\n            dpL[i] = i;\\n        } else if(d[i]===\\'L\\'){\\n            dpL[i] = -1;\\n        } else if(dpL[i]!=-1){\\n            dpL[i] = dpL[i-1]===undefined ? -1:dpL[i-1];\\n        }\\n        let j = d.length-i-1;\\n        if(d[j]===\\'L\\'){\\n            dpR[j] = j;\\n        } else if(d[j]===\\'R\\'){\\n            dpR[j] = -1;\\n        } else if(dpR[j]!=-1){\\n            dpR[j] = dpR[j+1]===undefined ? -1:dpR[j+1];\\n        }\\n    }\\n    let res = \\'\\';\\n    for(let i=0;i<d.length;i++){\\n\\t\\t// check 1\\n        if(dpR[i]==-1&dpL[i]==-1){\\n            res+=\".\"\\n            }\\n        else if(dpL[i]!==-1 && dpR[i]!==-1){\\n\\t\\t\\t//  check 3\\n            if(Math.abs(dpL[i]-i)===Math.abs(dpR[i]-i)){\\n                res+=\".\";\\n            }\\n            else if(Math.abs(dpL[i]-i)<Math.abs(dpR[i]-i)){\\n                res+=\\'R\\';\\n            }\\n            else{\\n                res+=\\'L\\';\\n            }\\n        }\\n        else{\\n\\t\\t\\t// check 2\\n            res+=dpL[i]===-1?\\'L\\':\\'R\\'\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629066,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Two Pointers***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string str) {\\n        \\n        int n = str.size();\\n        \\n        int left = 0;\\n        \\n        int right = 0;\\n        \\n        while(right < n)\\n        {\\n            if(str[right] == \\'.\\')\\n            {\\n                right++;\\n                \\n                continue;\\n            }\\n            \\n            if(str[right] == str[left] || (str[left] == \\'.\\' && str[right] == \\'L\\'))\\n            {\\n                int i = left;\\n                \\n                while(i < right)\\n                {\\n                    str[i] = str[right];\\n                    \\n                    i++;\\n                }\\n            }\\n            else if(str[left] == \\'R\\' && str[right] == \\'L\\')\\n            {\\n                int i = left;\\n                \\n                int j = right;\\n                \\n                while(i < j)\\n                {\\n                    str[i] = \\'R\\';\\n                    \\n                    str[j] = \\'L\\';\\n                    \\n                    i++;\\n                    \\n                    j--;\\n                }\\n            }\\n            \\n            // update pointers\\n            \\n            left = right;\\n            \\n            right++;\\n        }\\n        \\n        // if the last push is \\'R\\' then replace all the characters right to it with \\'R\\'\\n        \\n        if(str[left] == \\'R\\')\\n        {\\n            int i = left;\\n            \\n            while(i < n)\\n            {\\n                str[i] = \\'R\\';\\n                \\n                i++;\\n            }\\n        }\\n        \\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string str) {\\n        \\n        int n = str.size();\\n        \\n        int left = 0;\\n        \\n        int right = 0;\\n        \\n        while(right < n)\\n        {\\n            if(str[right] == \\'.\\')\\n            {\\n                right++;\\n                \\n                continue;\\n            }\\n            \\n            if(str[right] == str[left] || (str[left] == \\'.\\' && str[right] == \\'L\\'))\\n            {\\n                int i = left;\\n                \\n                while(i < right)\\n                {\\n                    str[i] = str[right];\\n                    \\n                    i++;\\n                }\\n            }\\n            else if(str[left] == \\'R\\' && str[right] == \\'L\\')\\n            {\\n                int i = left;\\n                \\n                int j = right;\\n                \\n                while(i < j)\\n                {\\n                    str[i] = \\'R\\';\\n                    \\n                    str[j] = \\'L\\';\\n                    \\n                    i++;\\n                    \\n                    j--;\\n                }\\n            }\\n            \\n            // update pointers\\n            \\n            left = right;\\n            \\n            right++;\\n        }\\n        \\n        // if the last push is \\'R\\' then replace all the characters right to it with \\'R\\'\\n        \\n        if(str[left] == \\'R\\')\\n        {\\n            int i = left;\\n            \\n            while(i < n)\\n            {\\n                str[i] = \\'R\\';\\n                \\n                i++;\\n            }\\n        }\\n        \\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629055,
                "title": "easy-to-understand-javascript-solution-using-two-pointers",
                "content": "\\n&emsp;The problem requires us to see how it will end up if we let all the dominoes fall into the direction they are set, all at the same time. This may be doable in real life but computers can\\'t do this. We should come up of a solution that computers can execute... a methodological one.\\n<br />\\n**Using 2-Pointers:**\\n\\n&emsp;If we think about it, we only really care about how the dominoes standing vertically that\\'s sandwiched between the falling dominoes will react. To do this, we just need to see what will happen between the window of dominoes converging from left to right `\"R\"` and right to left `\"L\"`.\\n\\n&emsp;The code loops through the array of dominoes, checking the window requirement. Once it reaches there, it simulates what happens to the dominoes in the middle of falling dominoes. If it reaches a common point, it will ignored since force falling from the opposite direction will cancel out each other. Once it\\'s done, it will move on to another window until all of them have been checked. \\n\\n**Handling Corner Cases:**\\n\\n&emsp;Corner case happens when the first index has a vertical domino `\".\"` and one of the succeeding domino is falling from the left `\"L\"` or vice versa for the last index but the predecessor is falling from the right `\"R\"` \\n&emsp;*eg.* `\"(..L).RR...LL(R...)\"`\\n\\n&emsp;we temporarily append `\"L\"` to the first index and `\"R\"` to the last index to  handle the corner cases. This doesn\\'t change anything but it allows us to handle both cases in a single for loop.\\n<br>\\nTime Complexity: **O(n)**\\nSpace Compelxity: **O(n)**\\n\\n```javascript\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    dominoes = \"L\" + dominoes + \"R\"; \\n    const arr = dominoes.split(\\'\\'), n = dominoes.length;\\n\\n    for (let l = 0, r = 1; r < n; r++) {\\n        if (arr[r] === \".\") continue;\\n\\n        if (arr[r] === \"L\" && arr[l] === \"R\")\\n            for (let i = l+1, j = r-1; j-i && i < j; i++, j--)\\n                arr[i] = \"R\", arr[j] = \"L\";\\n\\n        // handle both corner cases\\n        if (arr[l] === arr[r])\\n            for (let i = l; i < r; i++)\\n                arr[i] = arr[r];\\n\\n        l = r;\\n    }\\n\\n    return arr.slice(1, n-1).join(\\'\\');\\n};```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```javascript\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    dominoes = \"L\" + dominoes + \"R\"; \\n    const arr = dominoes.split(\\'\\'), n = dominoes.length;\\n\\n    for (let l = 0, r = 1; r < n; r++) {\\n        if (arr[r] === \".\") continue;\\n\\n        if (arr[r] === \"L\" && arr[l] === \"R\")\\n            for (let i = l+1, j = r-1; j-i && i < j; i++, j--)\\n                arr[i] = \"R\", arr[j] = \"L\";\\n\\n        // handle both corner cases\\n        if (arr[l] === arr[r])\\n            for (let i = l; i < r; i++)\\n                arr[i] = arr[r];\\n\\n        l = r;\\n    }\\n\\n    return arr.slice(1, n-1).join(\\'\\');\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 348579,
                "title": "python-force-caculate",
                "content": "O(N)\\n```\\n    def pushDominoes(self, dominoes: str) -> str:\\n        force = N = len(dominoes)\\n        tmp = 0\\n        ans = [0] * N\\n        for i in range(N):\\n            if dominoes[i] == \\'R\\':\\n                tmp = force\\n            if dominoes[i] == \\'L\\':\\n                tmp = 0\\n            ans[i] += max(tmp, 0)\\n            tmp -= 1\\n        tmp = 0\\n        for i in range(N-1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                tmp = -force\\n            if dominoes[i] == \\'R\\':\\n                tmp = 0\\n            ans[i] += min(tmp, 0)\\n            tmp += 1\\n        return \\'\\'.join([ \\'R\\' if n>0 else \\'L\\' if n<0 else \\'.\\' for n in ans])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def pushDominoes(self, dominoes: str) -> str:\\n        force = N = len(dominoes)\\n        tmp = 0\\n        ans = [0] * N\\n        for i in range(N):\\n            if dominoes[i] == \\'R\\':\\n                tmp = force\\n            if dominoes[i] == \\'L\\':\\n                tmp = 0\\n            ans[i] += max(tmp, 0)\\n            tmp -= 1\\n        tmp = 0\\n        for i in range(N-1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                tmp = -force\\n            if dominoes[i] == \\'R\\':\\n                tmp = 0\\n            ans[i] += min(tmp, 0)\\n            tmp += 1\\n        return \\'\\'.join([ \\'R\\' if n>0 else \\'L\\' if n<0 else \\'.\\' for n in ans])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2631203,
                "title": "python-iterative-bfs-solution-o-n-time-o-n-space",
                "content": "```\\n# * Iterative BFS Solution | O(n) Time | O(n) Space\\n# * n -> The length of dominoes string\\n\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes_list = list(dominoes)\\n        # * Start the BFS traversal.\\n        # * Push all the `L` and `R` into the queue for processing.\\n        queue = collections.deque(\\n            [(idx, d) for idx, d in enumerate(dominoes_list) if d != \".\"]\\n        )\\n\\n        while queue:\\n            cur_idx, cur_dominoe = queue.popleft()\\n            if cur_dominoe == \"L\" and cur_idx > 0 and dominoes_list[cur_idx - 1] == \".\":\\n                queue.append((cur_idx - 1, \"L\"))\\n                dominoes_list[cur_idx - 1] = \"L\"\\n\\n            elif (\\n                cur_dominoe == \"R\"\\n                and cur_idx + 1 < len(dominoes_list)\\n                and dominoes_list[cur_idx + 1] == \".\"\\n            ):\\n                if (\\n                    cur_idx + 2 < len(dominoes_list)\\n                    and dominoes_list[cur_idx + 2] == \"L\"\\n                ):\\n                    queue.popleft()\\n\\n                else:\\n                    queue.append((cur_idx + 1, \"R\"))\\n                    dominoes_list[cur_idx + 1] = \"R\"\\n\\n        return \"\".join(dominoes_list)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n# * Iterative BFS Solution | O(n) Time | O(n) Space\\n# * n -> The length of dominoes string\\n\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes_list = list(dominoes)\\n        # * Start the BFS traversal.\\n        # * Push all the `L` and `R` into the queue for processing.\\n        queue = collections.deque(\\n            [(idx, d) for idx, d in enumerate(dominoes_list) if d != \".\"]\\n        )\\n\\n        while queue:\\n            cur_idx, cur_dominoe = queue.popleft()\\n            if cur_dominoe == \"L\" and cur_idx > 0 and dominoes_list[cur_idx - 1] == \".\":\\n                queue.append((cur_idx - 1, \"L\"))\\n                dominoes_list[cur_idx - 1] = \"L\"\\n\\n            elif (\\n                cur_dominoe == \"R\"\\n                and cur_idx + 1 < len(dominoes_list)\\n                and dominoes_list[cur_idx + 1] == \".\"\\n            ):\\n                if (\\n                    cur_idx + 2 < len(dominoes_list)\\n                    and dominoes_list[cur_idx + 2] == \"L\"\\n                ):\\n                    queue.popleft()\\n\\n                else:\\n                    queue.append((cur_idx + 1, \"R\"))\\n                    dominoes_list[cur_idx + 1] = \"R\"\\n\\n        return \"\".join(dominoes_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630107,
                "title": "using-two-pointer-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        string str=\"\";\\n        int i=0,j=n-1;\\n        //to strore the time duration when left effect will occur to that dominoe box\\n        vector<int> l(n,0);  \\n        //to strore the time duration when right effect will occur to that dominoe box\\n        vector<int> r(n,0);\\n        int prev=0,cnt=0;\\n        while(i<n)\\n        {\\n            if(dominoes[prev]==\\'R\\' && dominoes[i]==\\'.\\'){\\n                cnt++;\\n            }\\n            else {\\n                prev=i;\\n                cnt=0;\\n            }\\n            r[i]=cnt;\\n            i++;\\n        }\\n      \\n        cnt =0;\\n        prev=j;\\n        while(j>=0)\\n        {\\n            if(dominoes[prev]==\\'L\\' && dominoes[j]==\\'.\\'){\\n                cnt++;\\n            }\\n            else {\\n                prev=j;\\n                cnt=0;\\n            }\\n            l[j]=cnt;\\n            j--;\\n        }\\n           \\n        for(int i=0;i<n;i++)\\n        {\\n            if(l[i] < r[i] && dominoes[i]==\\'.\\' && l[i]!=0){  \\n                dominoes[i]=\\'L\\';\\n            }\\n            if(l[i] > r[i] && dominoes[i]==\\'.\\' && r[i]==0){\\n                dominoes[i]=\\'L\\';\\n            }\\n            if(l[i] > r[i] && dominoes[i]==\\'.\\' && r[i]!=0){\\n                dominoes[i]=\\'R\\';\\n            }\\n            if(l[i] < r[i] && dominoes[i]==\\'.\\' && l[i]==0){\\n                dominoes[i]=\\'R\\';\\n            }\\n            if(l[i] == r[i] && dominoes[i]==\\'.\\'){\\n                dominoes[i]=\\'.\\';\\n            }\\n           \\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        string str=\"\";\\n        int i=0,j=n-1;\\n        //to strore the time duration when left effect will occur to that dominoe box\\n        vector<int> l(n,0);  \\n        //to strore the time duration when right effect will occur to that dominoe box\\n        vector<int> r(n,0);\\n        int prev=0,cnt=0;\\n        while(i<n)\\n        {\\n            if(dominoes[prev]==\\'R\\' && dominoes[i]==\\'.\\'){\\n                cnt++;\\n            }\\n            else {\\n                prev=i;\\n                cnt=0;\\n            }\\n            r[i]=cnt;\\n            i++;\\n        }\\n      \\n        cnt =0;\\n        prev=j;\\n        while(j>=0)\\n        {\\n            if(dominoes[prev]==\\'L\\' && dominoes[j]==\\'.\\'){\\n                cnt++;\\n            }\\n            else {\\n                prev=j;\\n                cnt=0;\\n            }\\n            l[j]=cnt;\\n            j--;\\n        }\\n           \\n        for(int i=0;i<n;i++)\\n        {\\n            if(l[i] < r[i] && dominoes[i]==\\'.\\' && l[i]!=0){  \\n                dominoes[i]=\\'L\\';\\n            }\\n            if(l[i] > r[i] && dominoes[i]==\\'.\\' && r[i]==0){\\n                dominoes[i]=\\'L\\';\\n            }\\n            if(l[i] > r[i] && dominoes[i]==\\'.\\' && r[i]!=0){\\n                dominoes[i]=\\'R\\';\\n            }\\n            if(l[i] < r[i] && dominoes[i]==\\'.\\' && l[i]==0){\\n                dominoes[i]=\\'R\\';\\n            }\\n            if(l[i] == r[i] && dominoes[i]==\\'.\\'){\\n                dominoes[i]=\\'.\\';\\n            }\\n           \\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629684,
                "title": "c-2-pointer-simple-and-concise-code-commented",
                "content": "```\\nstring pushDominoes(string d) {\\n        int n = d.size(), i = 0, prev = 0;\\n        string ans(n, \\'.\\');//initialize ans with \\'.\\'s\\n        while(i<n){\\n            while(i<n && d[i] == \\'.\\')i++;\\n            if(i<n && d[i] == \\'L\\'){\\n                //if encountered an L first, then update from prev to this position all as \\'L\\'\\n                while(prev <= i)\\n                    ans[prev++] = \\'L\\';\\n                i++;\\n            }\\n            else if(i<n && d[i] == \\'R\\'){\\n                //if encountered an \\'R\\', then search for \\'L\\' on the right side\\n                while(i<n && d[i] == \\'R\\'){//to reduce redundancy, just traverse all the run of \\'R\\'s.\\n                    ans[i] = \\'R\\';//also keep on updating the \\'R\\' given in the original string\\n                    i++;\\n                }\\n                prev = i;\\n                while(i<n && d[i] == \\'.\\')i++;\\n                if((i<n && d[i] == \\'R\\') || i == n){\\n                    //we encountered another \\'R\\', or reached the end, so update all the \\'.\\'s to \\'R\\' as no collision\\n                    while(prev < i)\\n                        ans[prev++] = \\'R\\';\\n                }\\n                else if(i<n && d[i] == \\'L\\'){\\n                    int p1 = i-1;\\n                    //we encountered an \\'L\\', so using two pointers, update R and L, as long as the pointers don\\'t collide\\n                    while(prev < p1){\\n                        ans[prev++] = \\'R\\';\\n                        ans[p1--] = \\'L\\';\\n                    }\\n                }\\n            }\\n            prev = i;\\n        }\\n        return  ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nstring pushDominoes(string d) {\\n        int n = d.size(), i = 0, prev = 0;\\n        string ans(n, \\'.\\');//initialize ans with \\'.\\'s\\n        while(i<n){\\n            while(i<n && d[i] == \\'.\\')i++;\\n            if(i<n && d[i] == \\'L\\'){\\n                //if encountered an L first, then update from prev to this position all as \\'L\\'\\n                while(prev <= i)\\n                    ans[prev++] = \\'L\\';\\n                i++;\\n            }\\n            else if(i<n && d[i] == \\'R\\'){\\n                //if encountered an \\'R\\', then search for \\'L\\' on the right side\\n                while(i<n && d[i] == \\'R\\'){//to reduce redundancy, just traverse all the run of \\'R\\'s.\\n                    ans[i] = \\'R\\';//also keep on updating the \\'R\\' given in the original string\\n                    i++;\\n                }\\n                prev = i;\\n                while(i<n && d[i] == \\'.\\')i++;\\n                if((i<n && d[i] == \\'R\\') || i == n){\\n                    //we encountered another \\'R\\', or reached the end, so update all the \\'.\\'s to \\'R\\' as no collision\\n                    while(prev < i)\\n                        ans[prev++] = \\'R\\';\\n                }\\n                else if(i<n && d[i] == \\'L\\'){\\n                    int p1 = i-1;\\n                    //we encountered an \\'L\\', so using two pointers, update R and L, as long as the pointers don\\'t collide\\n                    while(prev < p1){\\n                        ans[prev++] = \\'R\\';\\n                        ans[p1--] = \\'L\\';\\n                    }\\n                }\\n            }\\n            prev = i;\\n        }\\n        return  ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629342,
                "title": "python-solution-o-n-comments",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n=len(dominoes)\\n        left=[0]*n\\n        right=[0]*n\\n        \\n        # traverse from left side \\n        # keep count of \\'R\\' occurennces\\n        count=0\\n        for i in range(n):\\n            if dominoes[i]==\\'L\\' or dominoes[i]==\\'R\\':\\n                count=0\\n            left[i]=count\\n            if dominoes[i]==\\'R\\' or count!=0:\\n                count+=1\\n        \\n        # traverse from right side \\n        # keep count of \\'L\\' occurennces\\n        count=0\\n        for i in range(n-1, -1, -1):\\n            if dominoes[i]==\\'R\\' or dominoes[i]==\\'L\\':\\n                count=0\\n            right[i]=count\\n            if dominoes[i]==\\'L\\' or count!=0:\\n                count+=1\\n            \\n        # print(left)\\n        # print(right)\\n        \\n        # formulate ans based on occurence count of \\'L\\' and \\'R\\'\\n        ans=\\'\\'\\n        for i in range(n):\\n            if left[i]==right[i]:\\n                ans+=dominoes[i]\\n            else:\\n                if left[i]==0 and right[i]!=0:\\n                    ans+=\\'L\\'\\n                elif right[i]==0 and left[i]!=0:\\n                    ans+=\\'R\\'\\n                elif left[i]>right[i]:\\n                    ans+=\\'L\\'\\n                else:\\n                    ans+=\\'R\\'\\n        \\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n=len(dominoes)\\n        left=[0]*n\\n        right=[0]*n\\n        \\n        # traverse from left side \\n        # keep count of \\'R\\' occurennces\\n        count=0\\n        for i in range(n):\\n            if dominoes[i]==\\'L\\' or dominoes[i]==\\'R\\':\\n                count=0\\n            left[i]=count\\n            if dominoes[i]==\\'R\\' or count!=0:\\n                count+=1\\n        \\n        # traverse from right side \\n        # keep count of \\'L\\' occurennces\\n        count=0\\n        for i in range(n-1, -1, -1):\\n            if dominoes[i]==\\'R\\' or dominoes[i]==\\'L\\':\\n                count=0\\n            right[i]=count\\n            if dominoes[i]==\\'L\\' or count!=0:\\n                count+=1\\n            \\n        # print(left)\\n        # print(right)\\n        \\n        # formulate ans based on occurence count of \\'L\\' and \\'R\\'\\n        ans=\\'\\'\\n        for i in range(n):\\n            if left[i]==right[i]:\\n                ans+=dominoes[i]\\n            else:\\n                if left[i]==0 and right[i]!=0:\\n                    ans+=\\'L\\'\\n                elif right[i]==0 and left[i]!=0:\\n                    ans+=\\'R\\'\\n                elif left[i]>right[i]:\\n                    ans+=\\'L\\'\\n                else:\\n                    ans+=\\'R\\'\\n        \\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629115,
                "title": "cpp-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n        \\n        string ans = dom;\\n        queue<pair<int,char>>dq;\\n        \\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i] != \\'.\\')\\n            {\\n                dq.push({i,ans[i]});\\n            }\\n        }\\n        \\n        while(!dq.empty())\\n        {\\n            int i = dq.front().first;\\n            int d = dq.front().second;\\n            dq.pop();\\n            if(d == \\'L\\' and i > 0 and ans[i-1] == \\'.\\')\\n            {\\n                dq.push({i-1,\\'L\\'});\\n                ans[i-1] = \\'L\\';\\n            }\\n            else if(d == \\'R\\')\\n            {\\n                if(i+1 < ans.length() and ans[i+1] == \\'.\\')\\n                {\\n                    if(i+2 < ans.length() and ans[i+2] == \\'L\\')\\n                    {\\n                        dq.pop();\\n                    }\\n                    else{\\n                        dq.push({i+1,\\'R\\'});\\n                        ans[i+1] = \\'R\\';\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n        \\n        string ans = dom;\\n        queue<pair<int,char>>dq;\\n        \\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i] != \\'.\\')\\n            {\\n                dq.push({i,ans[i]});\\n            }\\n        }\\n        \\n        while(!dq.empty())\\n        {\\n            int i = dq.front().first;\\n            int d = dq.front().second;\\n            dq.pop();\\n            if(d == \\'L\\' and i > 0 and ans[i-1] == \\'.\\')\\n            {\\n                dq.push({i-1,\\'L\\'});\\n                ans[i-1] = \\'L\\';\\n            }\\n            else if(d == \\'R\\')\\n            {\\n                if(i+1 < ans.length() and ans[i+1] == \\'.\\')\\n                {\\n                    if(i+2 < ans.length() and ans[i+2] == \\'L\\')\\n                    {\\n                        dq.pop();\\n                    }\\n                    else{\\n                        dq.push({i+1,\\'R\\'});\\n                        ans[i+1] = \\'R\\';\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628823,
                "title": "c-explaination-concise-code",
                "content": "**Observations**:\\nThe observations are for indices with **dominoes[i]==\\'.\\'**\\n1. the nearest dominoes on left and right determines the direction of fall\\n2. on the left side , if nearest domino is a \\'R\\' , then it is valid\\n3. On the right side , if nearest domino is a \\'L\\', then it  is valid\\n4.  If both sides have valid and different distance dominoes , min-dist domino decides the direction\\n5.  Else if a single side contains a valid domino , that directon decides\\n6.  In all other case the dominos[i] is unchanged\\n\\n**Time:O(n)**\\n**Space:O(n)**\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n       int n=dominoes.size();\\n        \\n       vector<int> left(n,-1) , right(n);\\n       for(int i=0;i<n;i++){\\n           //nearest left domino\\n           if(dominoes[i] != \\'.\\') left[i] = i;\\n           else left[i] = (i-1 >= 0)?left[i-1]:-1;\\n           \\n           //nearest right domino\\n           if(dominoes[n-i-1] !=\\'.\\') right[n-i-1]=n-i-1;\\n           else right[n-i-1] = (n-i < n)?right[n-i]:n;\\n       }\\n        \\n        \\n       for(int i=0;i<n;i++){\\n           if(dominoes[i]!=\\'.\\') continue;\\n           \\n\\t\\t  //for invalid domino we use INT_MAX , so we can disacrd it while taking min\\n           int left_power = (left[i]==-1 or dominoes[left[i]]==\\'L\\')?INT_MAX:i-left[i];\\n           int right_power = (right[i]==n or dominoes[right[i]]==\\'R\\')?INT_MAX:right[i]-i;\\n           \\n           if(left_power != right_power){\\n               dominoes[i] = (left_power < right_power)?\\'R\\':\\'L\\';\\n           }\\n           \\n       }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n       int n=dominoes.size();\\n        \\n       vector<int> left(n,-1) , right(n);\\n       for(int i=0;i<n;i++){\\n           //nearest left domino\\n           if(dominoes[i] != \\'.\\') left[i] = i;\\n           else left[i] = (i-1 >= 0)?left[i-1]:-1;\\n           \\n           //nearest right domino\\n           if(dominoes[n-i-1] !=\\'.\\') right[n-i-1]=n-i-1;\\n           else right[n-i-1] = (n-i < n)?right[n-i]:n;\\n       }\\n        \\n        \\n       for(int i=0;i<n;i++){\\n           if(dominoes[i]!=\\'.\\') continue;\\n           \\n\\t\\t  //for invalid domino we use INT_MAX , so we can disacrd it while taking min\\n           int left_power = (left[i]==-1 or dominoes[left[i]]==\\'L\\')?INT_MAX:i-left[i];\\n           int right_power = (right[i]==n or dominoes[right[i]]==\\'R\\')?INT_MAX:right[i]-i;\\n           \\n           if(left_power != right_power){\\n               dominoes[i] = (left_power < right_power)?\\'R\\':\\'L\\';\\n           }\\n           \\n       }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628799,
                "title": "java-solution-easy-understanding-comments",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n      \\n        // ex: .L.R...LR..L..\\n        // create two arrays: one corresponding to left to right momentum and one for right to left momentum\\n        // left to right: if we are on a \\'.\\' and we see a \\'R\\' to the left of us, we need to add 1 to our current momentum\\n        // right to left: if we are on a \\'.\\' and we see a \\'L\\' to the right of us, we need to add 1 to our current momentum\\n\\t\\t// note:  array values are initially 0 at each index and the current momentum can be found by looking at the previous index\\n        // 0, 0, 0, 0, 1, 2, 3, 0, 0, 1, 2, 0, 0, 0 -> left to right (loop the dominoes string from left to right)\\n        // 1, 0, 0, 0, 3, 2, 1, 0, 0, 2, 1, 0, 0, 0 -> right to left (loop the dominoes string from right to left)\\n        \\n        // finally loop over the length of the arrays: \\n\\t\\t// if both arrays contain the same momentum value, keep the original character found in dominoes string\\n        // if one of the arrays contains a momentum of 0, choose the letter corresponding to the other array\\n        // both momentums are non zero values, choose the letter corresponding to the array of the smallest value\\n\\t\\t// note:  left to right array corresponds to setting the \\'R\\' character, the opposite is true for the right to left array\\n        \\n        StringBuilder result = new StringBuilder();\\n        int[] ltr = new int[dominoes.length()]; // momentum going from left to right\\n        int[] rtl = new int[dominoes.length()]; // momentum going from right to left\\n        \\n        // left to right momentum \\n        for (int i = 1; i < dominoes.length(); i++) {\\n            if (dominoes.charAt(i) == \\'.\\' \\n                && (dominoes.charAt(i - 1) == \\'R\\' || ltr[i - 1] > 0)) {\\n                \\n                ltr[i] = ltr[i - 1] + 1;\\n            }\\n            \\n        }\\n        \\n        // right to left momentum\\n        for (int i = dominoes.length() - 2; i >= 0; i--) {\\n            if (dominoes.charAt(i) == \\'.\\' \\n                && (dominoes.charAt(i + 1) == \\'L\\' || rtl[i + 1] > 0)) {\\n                \\n                rtl[i] = rtl[i + 1] + 1;\\n            }\\n        }\\n        \\n        \\n        // compute the result by looking at both arrays and taking the smallest momentum value that is non zero\\n        // note:  original value from dominoes will remain for equal momentums\\n        for(int i = 0; i < dominoes.length(); i++) {\\n            if (ltr[i] == rtl[i]) {\\n                result.append(dominoes.charAt(i));\\n            } else if (ltr[i] == 0 || rtl[i] == 0) {\\n                // take the non zero\\n                if (ltr[i] == 0) {\\n                    result.append(\"L\");\\n                } else {\\n                    result.append(\"R\");\\n                }\\n            } else {\\n                // take the smallest value\\n                if (ltr[i] < rtl[i]) {\\n                    result.append(\"R\");\\n                } else {\\n                    result.append(\"L\");\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n      \\n        // ex: .L.R...LR..L..\\n        // create two arrays: one corresponding to left to right momentum and one for right to left momentum\\n        // left to right: if we are on a \\'.\\' and we see a \\'R\\' to the left of us, we need to add 1 to our current momentum\\n        // right to left: if we are on a \\'.\\' and we see a \\'L\\' to the right of us, we need to add 1 to our current momentum\\n\\t\\t// note:  array values are initially 0 at each index and the current momentum can be found by looking at the previous index\\n        // 0, 0, 0, 0, 1, 2, 3, 0, 0, 1, 2, 0, 0, 0 -> left to right (loop the dominoes string from left to right)\\n        // 1, 0, 0, 0, 3, 2, 1, 0, 0, 2, 1, 0, 0, 0 -> right to left (loop the dominoes string from right to left)\\n        \\n        // finally loop over the length of the arrays: \\n\\t\\t// if both arrays contain the same momentum value, keep the original character found in dominoes string\\n        // if one of the arrays contains a momentum of 0, choose the letter corresponding to the other array\\n        // both momentums are non zero values, choose the letter corresponding to the array of the smallest value\\n\\t\\t// note:  left to right array corresponds to setting the \\'R\\' character, the opposite is true for the right to left array\\n        \\n        StringBuilder result = new StringBuilder();\\n        int[] ltr = new int[dominoes.length()]; // momentum going from left to right\\n        int[] rtl = new int[dominoes.length()]; // momentum going from right to left\\n        \\n        // left to right momentum \\n        for (int i = 1; i < dominoes.length(); i++) {\\n            if (dominoes.charAt(i) == \\'.\\' \\n                && (dominoes.charAt(i - 1) == \\'R\\' || ltr[i - 1] > 0)) {\\n                \\n                ltr[i] = ltr[i - 1] + 1;\\n            }\\n            \\n        }\\n        \\n        // right to left momentum\\n        for (int i = dominoes.length() - 2; i >= 0; i--) {\\n            if (dominoes.charAt(i) == \\'.\\' \\n                && (dominoes.charAt(i + 1) == \\'L\\' || rtl[i + 1] > 0)) {\\n                \\n                rtl[i] = rtl[i + 1] + 1;\\n            }\\n        }\\n        \\n        \\n        // compute the result by looking at both arrays and taking the smallest momentum value that is non zero\\n        // note:  original value from dominoes will remain for equal momentums\\n        for(int i = 0; i < dominoes.length(); i++) {\\n            if (ltr[i] == rtl[i]) {\\n                result.append(dominoes.charAt(i));\\n            } else if (ltr[i] == 0 || rtl[i] == 0) {\\n                // take the non zero\\n                if (ltr[i] == 0) {\\n                    result.append(\"L\");\\n                } else {\\n                    result.append(\"R\");\\n                }\\n            } else {\\n                // take the smallest value\\n                if (ltr[i] < rtl[i]) {\\n                    result.append(\"R\");\\n                } else {\\n                    result.append(\"L\");\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108778,
                "title": "c-simple-clean-and-well-commented-easy-to-understand-two-pointers",
                "content": "I have explained the code in the comments, easy to understand.\\n``` \\nclass Solution {\\npublic:\\n    //adding L and R at ends do not change the configuration\\n    //we have to divide the total string into parts, thats why adding L and R at ends for cases like ...L..R...\\n    //parts can be : L...L , R...R, L...R, R...L\\n    //L...L->all dots inside it will become L\\n    //R...R-> all dots inside it  will become R\\n    //L...R-> all dots remains unchanged\\n    //R...L->if dots are even then half R half L\\n    //else mid remains unchanged and one half R and other half L\\n    void solvefor(vector<char>&arr,int i,int j)\\n    {\\n        // i and j are pointer pointing to L or R in the parititon L/R...R/L\\n        //now check for all the 4 conditions\\n        \\n        //case 1 L....L , convert all to L \\n        if(arr[i]==\\'L\\' && arr[j]==\\'L\\')\\n        {\\n            for(int k=i+1;k<j;k++)\\n            {\\n                arr[k]=\\'L\\';\\n            }\\n        }\\n        //case 2 R....R, convert all to R\\n        else if(arr[i]==\\'R\\' && arr[j]==\\'R\\')\\n        {\\n            for(int k=i+1;k<j;k++)\\n            {\\n                arr[k]=\\'R\\';\\n            }\\n        }\\n        \\n        //case 3 L...R, no change in middle;\\n        else if(arr[i]==\\'L\\' && arr[j]==\\'R\\')\\n        {\\n            //nothing to do\\n        }\\n        \\n        //case 4 R...L,check . are even or odd and do accordingly\\n        else if(arr[i]==\\'R\\' && arr[j]==\\'L\\')\\n        {\\n            int diff=j-i;\\n            int mid=(j+i)/2;\\n            //case of odd dots, as positions are shifted\\n            if(diff%2==0)\\n            {\\n               for(int k=i+1;k<mid;k++)\\n               {\\n                   arr[k]=\\'R\\';\\n               }\\n                for(int k=mid+1;k<j;k++)  \\n                {\\n                   arr[k]=\\'L\\'; \\n                }\\n            }\\n            //case of even number of . so R....L converts to RRRLLL\\n            else\\n            {\\n                for(int k=i+1;k<=mid;k++)\\n               {\\n                   arr[k]=\\'R\\';\\n               }\\n                for(int k=mid+1;k<j;k++)  \\n                {\\n                   arr[k]=\\'L\\'; \\n                }\\n            }\\n        }\\n        \\n    }\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        vector<char>arr(n+2);\\n        arr[0]=\\'L\\';\\n        arr[n+1]=\\'R\\';\\n        //L 1-String-n-2 R\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            arr[i]=dominoes[i-1];\\n            // cout<<arr[i];\\n        }\\n        \\n        int j=0;\\n        int k =1;\\n        //j->Lk->...L...R..LR..R -> K counts number of \\'.\\' and stops on L or R\\n        //in above case j will be at L and K will be at L so solve for L...L\\n        while(k<arr.size())\\n        {\\n            while(arr[k]==\\'.\\')\\n            {\\n                k++;\\n            }\\n            //solve only for cases like L...L , not for LL\\n            if(k-j>1)\\n            {\\n                solvefor(arr,j,k);\\n            }\\n            j=k;\\n            k++;\\n        }\\n        string ans=\"\";\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n}; \\n```\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    //adding L and R at ends do not change the configuration\\n    //we have to divide the total string into parts, thats why adding L and R at ends for cases like ...L..R...\\n    //parts can be : L...L , R...R, L...R, R...L\\n    //L...L->all dots inside it will become L\\n    //R...R-> all dots inside it  will become R\\n    //L...R-> all dots remains unchanged\\n    //R...L->if dots are even then half R half L\\n    //else mid remains unchanged and one half R and other half L\\n    void solvefor(vector<char>&arr,int i,int j)\\n    {\\n        // i and j are pointer pointing to L or R in the parititon L/R...R/L\\n        //now check for all the 4 conditions\\n        \\n        //case 1 L....L , convert all to L \\n        if(arr[i]==\\'L\\' && arr[j]==\\'L\\')\\n        {\\n            for(int k=i+1;k<j;k++)\\n            {\\n                arr[k]=\\'L\\';\\n            }\\n        }\\n        //case 2 R....R, convert all to R\\n        else if(arr[i]==\\'R\\' && arr[j]==\\'R\\')\\n        {\\n            for(int k=i+1;k<j;k++)\\n            {\\n                arr[k]=\\'R\\';\\n            }\\n        }\\n        \\n        //case 3 L...R, no change in middle;\\n        else if(arr[i]==\\'L\\' && arr[j]==\\'R\\')\\n        {\\n            //nothing to do\\n        }\\n        \\n        //case 4 R...L,check . are even or odd and do accordingly\\n        else if(arr[i]==\\'R\\' && arr[j]==\\'L\\')\\n        {\\n            int diff=j-i;\\n            int mid=(j+i)/2;\\n            //case of odd dots, as positions are shifted\\n            if(diff%2==0)\\n            {\\n               for(int k=i+1;k<mid;k++)\\n               {\\n                   arr[k]=\\'R\\';\\n               }\\n                for(int k=mid+1;k<j;k++)  \\n                {\\n                   arr[k]=\\'L\\'; \\n                }\\n            }\\n            //case of even number of . so R....L converts to RRRLLL\\n            else\\n            {\\n                for(int k=i+1;k<=mid;k++)\\n               {\\n                   arr[k]=\\'R\\';\\n               }\\n                for(int k=mid+1;k<j;k++)  \\n                {\\n                   arr[k]=\\'L\\'; \\n                }\\n            }\\n        }\\n        \\n    }\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        vector<char>arr(n+2);\\n        arr[0]=\\'L\\';\\n        arr[n+1]=\\'R\\';\\n        //L 1-String-n-2 R\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            arr[i]=dominoes[i-1];\\n            // cout<<arr[i];\\n        }\\n        \\n        int j=0;\\n        int k =1;\\n        //j->Lk->...L...R..LR..R -> K counts number of \\'.\\' and stops on L or R\\n        //in above case j will be at L and K will be at L so solve for L...L\\n        while(k<arr.size())\\n        {\\n            while(arr[k]==\\'.\\')\\n            {\\n                k++;\\n            }\\n            //solve only for cases like L...L , not for LL\\n            if(k-j>1)\\n            {\\n                solvefor(arr,j,k);\\n            }\\n            j=k;\\n            k++;\\n        }\\n        string ans=\"\";\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "C++"
            },
            {
                "id": 1354390,
                "title": "c-3-approaches-commented-like-a-story-line-by-line-for-easy-understanding",
                "content": "```\\n//Approach-1 (O(n) time : Two Pointer Technique)\\n/*\\n\\tIn this approach, you just need to find sections like this\\n\\tX .   .   .   . X\\n\\ti                j\\n\\tWhere X can be \\'R\\' or \\'L\\' and in between there can be as many dots\\n\\tNow,\\n\\t- you know the length of mid part\\n\\t- If char[i] == char[j] == \\'R\\', means all go towards right (R)\\n\\t-  char[i]  == char[j] == \\'L\\', means all go towards Left (L)\\n\\t-  If char[i] = \\'L\\' and char[j] = \\'R\\', means middle part is not affected so the remain \\'.\\'\\n\\t-  If char[i] = \\'R\\' and char[j] = \\'L\\', then it will affect the middle part.\\n\\t   The middle_part/2 close to i will be affected by \\'R\\' and middle_part/2 close to j will be   \\n\\t   effected by \\'L\\'  and the last mid point (middle_part%2) will be unaffected due to equal  \\n\\t   force from left and right so it remains \\'.\\'\\n*/\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        string s = \"L\" + dominoes + \"R\";\\n        int n    = s.length();\\n        string result = \"\";\\n        for(int i = 0, j = 1; j<n; j++) {\\n            if(s[j] == \\'.\\') continue;\\n            \\n            int midPartLength = j-i-1;\\n            if(i > 0)\\n                result.push_back(s[i]);\\n            \\n            if(s[i] == s[j])\\n                result += string(midPartLength, s[i]);\\n            else if(s[i] == \\'L\\' && s[j] == \\'R\\')\\n                result += string(midPartLength, \\'.\\');\\n            else\\n                result += string(midPartLength/2, \\'R\\') + string(midPartLength%2, \\'.\\') + string(midPartLength/2, \\'L\\');\\n            i = j;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (O(n) time : Finding closest \\'L\\' and closest \\'R\\')\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        \\n        vector<int> rightClosestL(n);\\n        vector<int> leftClosestR(n);\\n        \\n        //Moving right to left to find rightClosestL\\n        for(int i = n-1; i>=0; i--) {\\n            if(dominoes[i] == \\'L\\')\\n                rightClosestL[i] = i; //L starts from me\\n            else if(dominoes[i] == \\'.\\')\\n                rightClosestL[i] = i < n-1 ? rightClosestL[i+1] : -1;\\n            else\\n                rightClosestL[i] = -1;\\n        }\\n        \\n        //Moving left to right to find leftClosestR\\n        for(int i = 0; i<n; i++) {\\n            if(dominoes[i] == \\'R\\')\\n                leftClosestR[i] = i; //R starts from me\\n            else if(dominoes[i] == \\'.\\')\\n                leftClosestR[i] = i > 0 ? leftClosestR[i-1] : -1;\\n            else\\n                leftClosestR[i] = -1;\\n        }\\n        \\n        string result(n, \\' \\');\\n        \\n        for(int i = 0; i<n; i++) {\\n            int distRightL = abs(i-rightClosestL[i]); //distance from \\'R\\' towards my left direction\\n            int distLeftR  = abs(i-leftClosestR[i]);  //distance from \\'L\\' towards my right direction\\n            \\n            if(rightClosestL[i] == leftClosestR[i])\\n                result[i] = \\'.\\';\\n            else if(rightClosestL[i] == -1)  //No force from right direction towards left, so move R\\n                result[i] = \\'R\\';\\n            else if(leftClosestR[i] == -1)   //No force from left direction towards right, so move L\\n                result[i] = \\'L\\';\\n            else if(distLeftR == distRightL) //Equal force from left and right\\n                result[i] = \\'.\\';\\n            else\\n                result[i] = distRightL < distLeftR ? \\'L\\': \\'R\\'; //which ever force is greater (either from left by \\'R\\' or from right by \\'L\\') i.e. whichever is closer wins\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (O(n) time : Using Force Simulation)\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        \\n        vector<int> forces(n);\\n        \\n        //Move from left to right and look for right force \\'R\\'\\n        int force = 0; //initially\\n        for(int i = 0; i<n; i++) {\\n            if(dominoes[i] == \\'R\\')\\n                force = n; //My max power towards Right starts from here and it will decrease as I progress\\n            else if(dominoes[i] == \\'L\\')\\n                force = 0; //I can\\'t give force towards Right :-(\\n            else\\n                force = max(force-1, 0); //I told ya, my power decreases as I progress and hit a \\'.\\'\\n            \\n            forces[i] = force;\\n        }\\n        \\n        //Move from right to left and look for left force \\'L\\'\\n        force = 0; //initially\\n        for(int i = n-1; i>=0; i--) {\\n            if(dominoes[i] == \\'L\\')\\n                force = n; //My max power towards Left starts from here and it will decrease as I progress\\n            else if(dominoes[i] == \\'R\\')\\n                force = 0; //I can\\'t give force towards Left :-(\\n            else\\n                force = max(force-1, 0); //I told ya, my power decreases as I progress and hit a \\'.\\'\\n            \\n            forces[i] -= force; //resultant force (that\\'s why I am subtracting)\\n        }\\n        \\n        //Now I will find resultant direction on each domino basis of resultant force on them\\n        string result(n ,\\' \\');\\n        for(int i = 0; i<n; i++) {\\n            if(forces[i] < 0)\\n                result[i] = \\'L\\';\\n            else if(forces[i] > 0)\\n                result[i] = \\'R\\';\\n            else\\n                result[i] = \\'.\\';\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (O(n) time : Two Pointer Technique)\\n/*\\n\\tIn this approach, you just need to find sections like this\\n\\tX .   .   .   . X\\n\\ti                j\\n\\tWhere X can be \\'R\\' or \\'L\\' and in between there can be as many dots\\n\\tNow,\\n\\t- you know the length of mid part\\n\\t- If char[i] == char[j] == \\'R\\', means all go towards right (R)\\n\\t-  char[i]  == char[j] == \\'L\\', means all go towards Left (L)\\n\\t-  If char[i] = \\'L\\' and char[j] = \\'R\\', means middle part is not affected so the remain \\'.\\'\\n\\t-  If char[i] = \\'R\\' and char[j] = \\'L\\', then it will affect the middle part.\\n\\t   The middle_part/2 close to i will be affected by \\'R\\' and middle_part/2 close to j will be   \\n\\t   effected by \\'L\\'  and the last mid point (middle_part%2) will be unaffected due to equal  \\n\\t   force from left and right so it remains \\'.\\'\\n*/\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        string s = \"L\" + dominoes + \"R\";\\n        int n    = s.length();\\n        string result = \"\";\\n        for(int i = 0, j = 1; j<n; j++) {\\n            if(s[j] == \\'.\\') continue;\\n            \\n            int midPartLength = j-i-1;\\n            if(i > 0)\\n                result.push_back(s[i]);\\n            \\n            if(s[i] == s[j])\\n                result += string(midPartLength, s[i]);\\n            else if(s[i] == \\'L\\' && s[j] == \\'R\\')\\n                result += string(midPartLength, \\'.\\');\\n            else\\n                result += string(midPartLength/2, \\'R\\') + string(midPartLength%2, \\'.\\') + string(midPartLength/2, \\'L\\');\\n            i = j;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (O(n) time : Finding closest \\'L\\' and closest \\'R\\')\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        \\n        vector<int> rightClosestL(n);\\n        vector<int> leftClosestR(n);\\n        \\n        //Moving right to left to find rightClosestL\\n        for(int i = n-1; i>=0; i--) {\\n            if(dominoes[i] == \\'L\\')\\n                rightClosestL[i] = i; //L starts from me\\n            else if(dominoes[i] == \\'.\\')\\n                rightClosestL[i] = i < n-1 ? rightClosestL[i+1] : -1;\\n            else\\n                rightClosestL[i] = -1;\\n        }\\n        \\n        //Moving left to right to find leftClosestR\\n        for(int i = 0; i<n; i++) {\\n            if(dominoes[i] == \\'R\\')\\n                leftClosestR[i] = i; //R starts from me\\n            else if(dominoes[i] == \\'.\\')\\n                leftClosestR[i] = i > 0 ? leftClosestR[i-1] : -1;\\n            else\\n                leftClosestR[i] = -1;\\n        }\\n        \\n        string result(n, \\' \\');\\n        \\n        for(int i = 0; i<n; i++) {\\n            int distRightL = abs(i-rightClosestL[i]); //distance from \\'R\\' towards my left direction\\n            int distLeftR  = abs(i-leftClosestR[i]);  //distance from \\'L\\' towards my right direction\\n            \\n            if(rightClosestL[i] == leftClosestR[i])\\n                result[i] = \\'.\\';\\n            else if(rightClosestL[i] == -1)  //No force from right direction towards left, so move R\\n                result[i] = \\'R\\';\\n            else if(leftClosestR[i] == -1)   //No force from left direction towards right, so move L\\n                result[i] = \\'L\\';\\n            else if(distLeftR == distRightL) //Equal force from left and right\\n                result[i] = \\'.\\';\\n            else\\n                result[i] = distRightL < distLeftR ? \\'L\\': \\'R\\'; //which ever force is greater (either from left by \\'R\\' or from right by \\'L\\') i.e. whichever is closer wins\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-3 (O(n) time : Using Force Simulation)\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        \\n        vector<int> forces(n);\\n        \\n        //Move from left to right and look for right force \\'R\\'\\n        int force = 0; //initially\\n        for(int i = 0; i<n; i++) {\\n            if(dominoes[i] == \\'R\\')\\n                force = n; //My max power towards Right starts from here and it will decrease as I progress\\n            else if(dominoes[i] == \\'L\\')\\n                force = 0; //I can\\'t give force towards Right :-(\\n            else\\n                force = max(force-1, 0); //I told ya, my power decreases as I progress and hit a \\'.\\'\\n            \\n            forces[i] = force;\\n        }\\n        \\n        //Move from right to left and look for left force \\'L\\'\\n        force = 0; //initially\\n        for(int i = n-1; i>=0; i--) {\\n            if(dominoes[i] == \\'L\\')\\n                force = n; //My max power towards Left starts from here and it will decrease as I progress\\n            else if(dominoes[i] == \\'R\\')\\n                force = 0; //I can\\'t give force towards Left :-(\\n            else\\n                force = max(force-1, 0); //I told ya, my power decreases as I progress and hit a \\'.\\'\\n            \\n            forces[i] -= force; //resultant force (that\\'s why I am subtracting)\\n        }\\n        \\n        //Now I will find resultant direction on each domino basis of resultant force on them\\n        string result(n ,\\' \\');\\n        for(int i = 0; i<n; i++) {\\n            if(forces[i] < 0)\\n                result[i] = \\'L\\';\\n            else if(forces[i] > 0)\\n                result[i] = \\'R\\';\\n            else\\n                result[i] = \\'.\\';\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352428,
                "title": "python-push-dominoes-really-simple-solution-o-n",
                "content": "Fully annotated code below but the idea behind it is:\\n - if we have no \\'collisions\\' then the dots in the middle will all be the same e.g. \\'L.....L\\' - all the dots will be \\'L\\', and vice versa for \\'R......R\\' all being \\'R\\'\\n - if we have a collision, then we attribute the dots in the middle evenly between \\'R\\' and \\'L\\' i.e. \\'R....L\\' becomes \\'RRRLLL\\'\\n - if we have a collision with an odd number of \\'.\\' then the middle element remains a \\'.\\'\\n - if we never have a collision e.g. \\'L....R\\' then we keep all the dots\\n\\nThe above allows us to walk through the array just once and add on what we need as we go.\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n\\t\\n        # init ans\\n        answer = \\'\\'\\n        # set up so we don\\'t need to worry about ends of loop\\n        dom = \\'L\\' + dominoes + \\'R\\'\\n        # trailing var of last non dot, to help us populate large swathes\\n        prev = 0\\n        for i in range(1, len(dom)):\\n            # if this element is a \\'.\\', then we don\\'t know what to do with it yet\\n            # so let\\'s just continue iterating on to the next element\\n            if dom[i] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\n            # if we are here then the current element is not a \\'.\\'\\n            # let\\'s update a var j to keep track of how many \\'.\\' we have passed\\n            j = i - prev - 1\\n\\t\\t\\t\\n            # now we add on the previous element to the answer\\n            # if still zero then we don\\'t add\\n            # this prevents adding on the \\'L\\' we added to dom\\n            # also this won\\'t get called for the final \\'R\\' we added as only prev\\n            if prev:\\n                answer += dom[prev]\\n\\t\\t\\t\\t\\n            # now let\\'s check if we have no conflict\\n            # e.g. if we had \\'L.....L\\' then we need to add on 5 L\\'s (also same for \\'R.....R\\')\\n            # the first \\'L\\' got appended in the above step of adding prev\\n            # and the next \\'L\\' will get appended in the next step\\n            if dom[prev] == dom[i]:\\n                answer += dom[prev]*j\\n\\t\\t\\t\\t\\n            # now what about the opposite\\n            # e.g. we have \\'L.....R\\' then we would never populate the middle\\n            # so we need to add on 5 \\'.\\'\\n            elif dom[prev] == \\'L\\' and dom[i] == \\'R\\':\\n                answer += \\'.\\'*j\\n\\t\\t\\t\\t\\n            # else we must be in a sitch where we have:\\n            # e.g. \\'R....L\\' and they collide\\n            # if we have an even number then we add on m/2 R then m/2 L\\n            # if we have an odd number then the middle element must be a \\'.\\'\\n            else:\\n                answer += \\'R\\'*(j//2) + \\'.\\'*(j%2) + \\'L\\'*(j//2)\\n\\t\\t\\t\\t\\n            # update our trailing var as this iteration the element was not \\'.\\'\\n            prev=i\\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n\\t\\n        # init ans\\n        answer = \\'\\'\\n        # set up so we don\\'t need to worry about ends of loop\\n        dom = \\'L\\' + dominoes + \\'R\\'\\n        # trailing var of last non dot, to help us populate large swathes\\n        prev = 0\\n        for i in range(1, len(dom)):\\n            # if this element is a \\'.\\', then we don\\'t know what to do with it yet\\n            # so let\\'s just continue iterating on to the next element\\n            if dom[i] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\n            # if we are here then the current element is not a \\'.\\'\\n            # let\\'s update a var j to keep track of how many \\'.\\' we have passed\\n            j = i - prev - 1\\n\\t\\t\\t\\n            # now we add on the previous element to the answer\\n            # if still zero then we don\\'t add\\n            # this prevents adding on the \\'L\\' we added to dom\\n            # also this won\\'t get called for the final \\'R\\' we added as only prev\\n            if prev:\\n                answer += dom[prev]\\n\\t\\t\\t\\t\\n            # now let\\'s check if we have no conflict\\n            # e.g. if we had \\'L.....L\\' then we need to add on 5 L\\'s (also same for \\'R.....R\\')\\n            # the first \\'L\\' got appended in the above step of adding prev\\n            # and the next \\'L\\' will get appended in the next step\\n            if dom[prev] == dom[i]:\\n                answer += dom[prev]*j\\n\\t\\t\\t\\t\\n            # now what about the opposite\\n            # e.g. we have \\'L.....R\\' then we would never populate the middle\\n            # so we need to add on 5 \\'.\\'\\n            elif dom[prev] == \\'L\\' and dom[i] == \\'R\\':\\n                answer += \\'.\\'*j\\n\\t\\t\\t\\t\\n            # else we must be in a sitch where we have:\\n            # e.g. \\'R....L\\' and they collide\\n            # if we have an even number then we add on m/2 R then m/2 L\\n            # if we have an odd number then the middle element must be a \\'.\\'\\n            else:\\n                answer += \\'R\\'*(j//2) + \\'.\\'*(j%2) + \\'L\\'*(j//2)\\n\\t\\t\\t\\t\\n            # update our trailing var as this iteration the element was not \\'.\\'\\n            prev=i\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083991,
                "title": "java-solution-two-pointers-beat-99",
                "content": "```\\n// Time complexity: O(N)\\n// Space complexity: O(N), where N is the length of input string\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        // ask whether dominoes could be null\\n        final int N = dominoes.length();\\n        if (N <= 1) return dominoes;\\n        char[] res = dominoes.toCharArray();\\n        int i = 0;\\n        while (i < N) {\\n            if (res[i] == \\'.\\') {\\n                i++;\\n            } else if (res[i] == \\'L\\') {  // push left\\n                int j = i-1;\\n                while (j >= 0 && res[j] == \\'.\\') {\\n                    res[j--] = \\'L\\';\\n                }\\n                i++;\\n            } else { // res[i] == \\'R\\'\\n                int j = i+1;\\n                while (j < N && res[j] == \\'.\\') { // try to find \\'R\\' or \\'L\\' in the right side\\n                    j++;\\n                }\\n                if (j < N && res[j] == \\'L\\') { // if found \\'L\\', push left and right\\n                    for (int l = i+1, r = j-1; l < r; l++, r--) {\\n                        res[l] = \\'R\\';\\n                        res[r] = \\'L\\';\\n                    }\\n                    i = j + 1;\\n                } else {  // if no \\'L\\', push right\\n                    while (i < j) {\\n                        res[i++] = \\'R\\';\\n                    }\\n                }\\n            }\\n        }\\n        return String.valueOf(res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity: O(N)\\n// Space complexity: O(N), where N is the length of input string\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        // ask whether dominoes could be null\\n        final int N = dominoes.length();\\n        if (N <= 1) return dominoes;\\n        char[] res = dominoes.toCharArray();\\n        int i = 0;\\n        while (i < N) {\\n            if (res[i] == \\'.\\') {\\n                i++;\\n            } else if (res[i] == \\'L\\') {  // push left\\n                int j = i-1;\\n                while (j >= 0 && res[j] == \\'.\\') {\\n                    res[j--] = \\'L\\';\\n                }\\n                i++;\\n            } else { // res[i] == \\'R\\'\\n                int j = i+1;\\n                while (j < N && res[j] == \\'.\\') { // try to find \\'R\\' or \\'L\\' in the right side\\n                    j++;\\n                }\\n                if (j < N && res[j] == \\'L\\') { // if found \\'L\\', push left and right\\n                    for (int l = i+1, r = j-1; l < r; l++, r--) {\\n                        res[l] = \\'R\\';\\n                        res[r] = \\'L\\';\\n                    }\\n                    i = j + 1;\\n                } else {  // if no \\'L\\', push right\\n                    while (i < j) {\\n                        res[i++] = \\'R\\';\\n                    }\\n                }\\n            }\\n        }\\n        return String.valueOf(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767282,
                "title": "c-brutally-nested-o-n-solution-98",
                "content": "This is essentially solution 1 of the editorial, just written in C++\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int start = 0;\\n        int l = 0;\\n        string ans = s;\\n        for(int i=0; i<s.size(); i++) {\\n            if (l == 0 && s[i] == \\'.\\') {\\n                start = i;\\n                l++;\\n            } else if ( l > 0 && s[i] == \\'.\\') {\\n                l++;\\n            } else if (s[i] != \\'.\\' && l > 0) {\\n                if (start == 0) {\\n                    if (s[start+l] == \\'L\\') for(int i=start; i<start+l; i++) s[i] = \\'L\\';\\n                } else {\\n                    if (s[start-1] == s[start+l]) {\\n                        for(int i=start; i<start+l; i++) s[i] = s[start-1];\\n                    }\\n                    else {\\n                        if (l&1 && s[start-1] == \\'R\\' && s[start + l] == \\'L\\') {\\n                            for(int i=start; i<start + l/2; i++) s[i] = \\'R\\';\\n                            for(int i=start + l; i>start + l/2; i--) s[i] =\\'L\\';\\n                        }else if ((l&1)^1 && s[start-1] == \\'R\\' && s[start + l] == \\'L\\') {\\n                            for(int i=start; i<=start + l/2; i++) s[i] = \\'R\\';\\n                            for(int i=start + l; i>=start + l/2; i--) s[i] =\\'L\\';\\n                        }\\n                    }\\n                }\\n                l = 0;\\n                start = -1;\\n            }\\n        }\\n        // last part\\n        if (l > 0) {\\n            if (start != 0 && s[start-1] == \\'R\\') {\\n                for(int i=start; i<start + l; i++) {\\n                    s[i] = \\'R\\';\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int start = 0;\\n        int l = 0;\\n        string ans = s;\\n        for(int i=0; i<s.size(); i++) {\\n            if (l == 0 && s[i] == \\'.\\') {\\n                start = i;\\n                l++;\\n            } else if ( l > 0 && s[i] == \\'.\\') {\\n                l++;\\n            } else if (s[i] != \\'.\\' && l > 0) {\\n                if (start == 0) {\\n                    if (s[start+l] == \\'L\\') for(int i=start; i<start+l; i++) s[i] = \\'L\\';\\n                } else {\\n                    if (s[start-1] == s[start+l]) {\\n                        for(int i=start; i<start+l; i++) s[i] = s[start-1];\\n                    }\\n                    else {\\n                        if (l&1 && s[start-1] == \\'R\\' && s[start + l] == \\'L\\') {\\n                            for(int i=start; i<start + l/2; i++) s[i] = \\'R\\';\\n                            for(int i=start + l; i>start + l/2; i--) s[i] =\\'L\\';\\n                        }else if ((l&1)^1 && s[start-1] == \\'R\\' && s[start + l] == \\'L\\') {\\n                            for(int i=start; i<=start + l/2; i++) s[i] = \\'R\\';\\n                            for(int i=start + l; i>=start + l/2; i--) s[i] =\\'L\\';\\n                        }\\n                    }\\n                }\\n                l = 0;\\n                start = -1;\\n            }\\n        }\\n        // last part\\n        if (l > 0) {\\n            if (start != 0 && s[start-1] == \\'R\\') {\\n                for(int i=start; i<start + l; i++) {\\n                    s[i] = \\'R\\';\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558273,
                "title": "two-pointers-c-30ms-solution",
                "content": "# Intuition\\n1) Can not use stack considering the testcase when one Domino is falling towards **Right** and one Domino is falling towards **Left**. Here we need to move half of the dominos fall Right and half fall Left in between these two dominos.\\n2) Whereas, rest of the dominos either continously fall Left or Right.\\n3) Using two pointers can handle all type of testcases\\n\\n\\n# Approach\\n1) The dominos group can be divided as:\\n   a) **. L**\\n   b) **. R**\\n   c) **L .**\\n   d) **R .**\\n   e) **L R**\\n   f) **R L**\\n   g) **L L**\\n   h) **R R**\\n2) The case where half of the in-between dominos fall left and half right comes under -> **R L** group.\\n3) Other groups can be handled in a **monotonous** way.\\n4) By using **two pointers**, we observe if the **current index** (j) is R or L, if it is R then we observe the **previous index** (i) which shows the group(from the above group table) the pointers i & j refer to.\\n5) So, if the pair **{ i, j }** belongs to:\\n a) **. L** - run a loop from i to j and fill with \\'L\\'\\n b) **. R** - do nothing ( even if vertical dominos are in-between)\\n c) **L .** - do nothing ( even if vertical dominos are in-between)\\n d) **R .** - run a loop from i to j and fill with \\'R\\'\\n e) **L R** - do nothing ( even if vertical dominos are in-between)\\n f) **R L** - calculate the distance between i and j to first distribute half indices to \\'R\\' and then half indices to \\'L\\'. If there is odd no. of spaces available, we need to skip the middle domino as it is self-balanced.\\n g) **L L** - run a loop from i to j and fill with \\'L\\'\\n h) **R R** - run a loop from i to j and fill with \\'R\\'\\n\\n# Complexity\\n- Time complexity:\\n **O(n+k) ~ O(n)**\\n where **n** is for traversing the string and **k** is for traversing to fill substrings with \\'L\\' and \\'R\\'\\n\\n- Space complexity:\\n**O(1)** - Since no additional space is required to store\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n        int i=0,j=0,n=dom.size();\\n        while(i<n){\\n            int j=i;\\n            int solA = -1, solB = -1, solC = -1, solD = -1;\\n            while(j<n){\\n                if(dom[j]==\\'L\\'){\\n                    if(i==j){\\n                        j++;\\n                        continue;\\n                    }\\n                    if(dom[i]==\\'.\\' || dom[i]==\\'L\\'){\\n                        // L to be inserted to the left till i\\n                        solA = 1;\\n                        break;\\n                    }\\n                    else{\\n                        // half R and half L to be inserted\\n                        solC = 1;\\n                        break;\\n                    }\\n                }\\n                else if(dom[j]==\\'R\\'){\\n                     if(i==j){\\n                        j++;\\n                        continue;\\n                    }\\n                    if(dom[i]==\\'R\\'){\\n                        // fill R from i to j\\n                        solB = 1;\\n                        // cout<<i<<\" \"<<j<<endl;\\n                        break;\\n                    }\\n                    // move i to curr pos of j\\n                    i=j;\\n                    break;\\n                }\\n                else if(j==n-1 && dom[j]==\\'.\\'){\\n                    if(dom[i]==\\'R\\'){\\n                        solD=1;\\n                        break;\\n                    }\\n                }\\n                j++;\\n            }\\n            // cout<<endl;\\n            if(solA==1){\\n                // inserting L\\n                for(int k=i;k<j && k<n;k++) dom[k]=\\'L\\';\\n            }\\n            if(solB==1){\\n                // inserting R\\n                for(int k=i;k<j && k<n;k++) dom[k]=\\'R\\';\\n            }\\n            if(solC==1){\\n                int k=i+(j-i-1)/2;\\n                for(int z=i;z<=k && z<n;z++) dom[z]=\\'R\\';\\n                for(int z=j;z>=(j-k+i) && z>0;z--) dom[z]=\\'L\\';\\n            }\\n            if(solD==1){\\n                for(int z=i;z<n;z++) dom[z]=\\'R\\';\\n            }\\n            i=j;\\n        }\\n        return dom;\\n    }\\n};\\n```\\n\\nDo upvote the solution, if understood the solution \\uD83D\\uDE0A\\nDo comment if finding difficult to understand any step.",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n        int i=0,j=0,n=dom.size();\\n        while(i<n){\\n            int j=i;\\n            int solA = -1, solB = -1, solC = -1, solD = -1;\\n            while(j<n){\\n                if(dom[j]==\\'L\\'){\\n                    if(i==j){\\n                        j++;\\n                        continue;\\n                    }\\n                    if(dom[i]==\\'.\\' || dom[i]==\\'L\\'){\\n                        // L to be inserted to the left till i\\n                        solA = 1;\\n                        break;\\n                    }\\n                    else{\\n                        // half R and half L to be inserted\\n                        solC = 1;\\n                        break;\\n                    }\\n                }\\n                else if(dom[j]==\\'R\\'){\\n                     if(i==j){\\n                        j++;\\n                        continue;\\n                    }\\n                    if(dom[i]==\\'R\\'){\\n                        // fill R from i to j\\n                        solB = 1;\\n                        // cout<<i<<\" \"<<j<<endl;\\n                        break;\\n                    }\\n                    // move i to curr pos of j\\n                    i=j;\\n                    break;\\n                }\\n                else if(j==n-1 && dom[j]==\\'.\\'){\\n                    if(dom[i]==\\'R\\'){\\n                        solD=1;\\n                        break;\\n                    }\\n                }\\n                j++;\\n            }\\n            // cout<<endl;\\n            if(solA==1){\\n                // inserting L\\n                for(int k=i;k<j && k<n;k++) dom[k]=\\'L\\';\\n            }\\n            if(solB==1){\\n                // inserting R\\n                for(int k=i;k<j && k<n;k++) dom[k]=\\'R\\';\\n            }\\n            if(solC==1){\\n                int k=i+(j-i-1)/2;\\n                for(int z=i;z<=k && z<n;z++) dom[z]=\\'R\\';\\n                for(int z=j;z>=(j-k+i) && z>0;z--) dom[z]=\\'L\\';\\n            }\\n            if(solD==1){\\n                for(int z=i;z<n;z++) dom[z]=\\'R\\';\\n            }\\n            i=j;\\n        }\\n        return dom;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2795580,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        #define SET(ch, arr) \\\\\\n                    if (dominoes[i] == ch) { count = 1; prev = ch; } \\\\\\n                    else if (dominoes[i] != \\'.\\') prev = dominoes[i]; \\\\\\n                    if (prev == ch && dominoes[i] == \\'.\\') arr[i] = count++;\\n        \\n        string res = \"\";\\n        char prev;\\n        int n = dominoes.size(), count = 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            SET(\\'R\\', right);\\n        }\\n        \\n        prev = \\'.\\';\\n        for (int i = n-1; i >= 0; i--) {\\n            SET(\\'L\\', left);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!left[i] && !right[i]) res += dominoes[i];\\n            else if (!left[i]) res += \\'R\\';\\n            else if (!right[i]) res += \\'L\\';\\n            else if (left[i] == right[i]) res += \\'.\\';\\n            else if (left[i] < right[i]) res += \\'L\\';\\n            else res += \\'R\\';\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        #define SET(ch, arr) \\\\\\n                    if (dominoes[i] == ch) { count = 1; prev = ch; } \\\\\\n                    else if (dominoes[i] != \\'.\\') prev = dominoes[i]; \\\\\\n                    if (prev == ch && dominoes[i] == \\'.\\') arr[i] = count++;\\n        \\n        string res = \"\";\\n        char prev;\\n        int n = dominoes.size(), count = 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            SET(\\'R\\', right);\\n        }\\n        \\n        prev = \\'.\\';\\n        for (int i = n-1; i >= 0; i--) {\\n            SET(\\'L\\', left);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!left[i] && !right[i]) res += dominoes[i];\\n            else if (!left[i]) res += \\'R\\';\\n            else if (!right[i]) res += \\'L\\';\\n            else if (left[i] == right[i]) res += \\'.\\';\\n            else if (left[i] < right[i]) res += \\'L\\';\\n            else res += \\'R\\';\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630796,
                "title": "easy-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<dominoes.size();i++) {\\n            if(dominoes[i]==\\'L\\')\\n                q.push({0,i});\\n            else if(dominoes[i]==\\'R\\')\\n                q.push({2,i});\\n        }\\n        while(!q.empty()) {\\n            int size=q.size();\\n            unordered_map<int,char> um;\\n            for(int i=0;i<size;i++) {\\n                int side=q.front().first;\\n                int idx=q.front().second;\\n                q.pop();\\n                if(side==0 && idx-1>=0) {\\n                    if(dominoes[idx-1]==\\'.\\') {\\n                        if(um.find(idx-1)!=um.end())\\n                            um[idx-1]=\\'.\\';\\n                        else {\\n                            um[idx-1]=\\'L\\';\\n                            q.push({0,idx-1});\\n                        }\\n                    }\\n                } else if(side==2 && idx+1<=dominoes.size()-1) {\\n                    if(dominoes[idx+1]==\\'.\\') {\\n                        if(um.find(idx+1)!=um.end())\\n                            um[idx+1]=\\'.\\';\\n                        else {\\n                            um[idx+1]=\\'R\\';\\n                            q.push({2,idx+1});\\n                        }\\n                    }\\n                }\\n            }\\n            for(auto x:um)\\n                dominoes[x.first]=x.second;\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<dominoes.size();i++) {\\n            if(dominoes[i]==\\'L\\')\\n                q.push({0,i});\\n            else if(dominoes[i]==\\'R\\')\\n                q.push({2,i});\\n        }\\n        while(!q.empty()) {\\n            int size=q.size();\\n            unordered_map<int,char> um;\\n            for(int i=0;i<size;i++) {\\n                int side=q.front().first;\\n                int idx=q.front().second;\\n                q.pop();\\n                if(side==0 && idx-1>=0) {\\n                    if(dominoes[idx-1]==\\'.\\') {\\n                        if(um.find(idx-1)!=um.end())\\n                            um[idx-1]=\\'.\\';\\n                        else {\\n                            um[idx-1]=\\'L\\';\\n                            q.push({0,idx-1});\\n                        }\\n                    }\\n                } else if(side==2 && idx+1<=dominoes.size()-1) {\\n                    if(dominoes[idx+1]==\\'.\\') {\\n                        if(um.find(idx+1)!=um.end())\\n                            um[idx+1]=\\'.\\';\\n                        else {\\n                            um[idx+1]=\\'R\\';\\n                            q.push({2,idx+1});\\n                        }\\n                    }\\n                }\\n            }\\n            for(auto x:um)\\n                dominoes[x.first]=x.second;\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630519,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size();\\n        vector<int>time(n, 0);\\n        bool prev{false};\\n        for(int i = n - 1; i >= 0; i--){\\n            if(prev){\\n                if(s[i] == \\'.\\'){\\n                    time[i] = time[i+1] + 1;\\n                    s[i] = \\'L\\';\\n                }\\n                else if(s[i] == \\'R\\'){\\n                    prev = false;\\n                }\\n            }\\n            else{\\n                if(s[i] == \\'L\\'){\\n                    prev = true;\\n                }\\n            }\\n        }\\n        prev = false;\\n        for(int i = 0; i < n; i++){\\n            if(prev){\\n                if(s[i] == \\'.\\'){\\n                    s[i] = \\'R\\';\\n                    time[i] = time[i-1] + 1;\\n                }\\n                else if(s[i] == \\'L\\'){\\n                    if(time[i-1] + 1 == time[i]){\\n                        s[i] = \\'.\\';\\n                        prev = false;\\n                    }\\n                    else{\\n                        if(time[i-1] + 1 < time[i]){\\n                            s[i] = \\'R\\';\\n                            time[i] = time[i-1] + 1;\\n                        }\\n                        else{\\n                            prev = false;\\n                        }\\n                    }\\n                }\\n            }\\n            else{\\n                if(s[i] == \\'R\\'){\\n                    prev = true;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size();\\n        vector<int>time(n, 0);\\n        bool prev{false}",
                "codeTag": "Java"
            },
            {
                "id": 2630428,
                "title": "easy-to-understand-o-n-o-n-solution-very-intuitive-solution",
                "content": "**Approach:**\\nSo what we need to do is just focus on the dominoes which are standing upright i.e. \\' . \\' Now if we are at a upright domino we need to know how far is a domino towards left which was pushed right and how far is a domnio which was pushed to the left. We can do this for every domino but this makes our work easier as we can just store the required distances in two arrays.\\n\\nLet\\'s see how the algorithm works\\n\\nFirst we walk from left to right\\n* If we find a domino which is pushed towards Left \\' L \\' we know this can never affect the dominoes on right so we mark our flag as false\\n* If we find a domino which is pushed towards right \\'R\\' we know this can affect the dominoes on the right side and thus we start a fresh count from zero.\\n* If we find a domino which is upright we change its value to count only if there was a Right earlier to it which is indicated by flag variable.\\n\\nSimilarly we walk from right to left and make a similar array.\\n\\nFinally we move from left to right and if we find an upright domino we check the distance of left and right domino and which ever is less we change our values accordingly.\\n\\nThe key point to note here is that only the values of the upright dominoes will change and thus we update our left and right arrays only at those positions.\\n\\n\\n\\nThe left and right are initialised with INT_MAX so as to account for unavalaibitiy of the required push.\\n\\nC++ code:\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left(n,INT_MAX);\\n        int count = 0;\\n        bool flag = false;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                flag = false;\\n            }    \\n            else if(dominoes[i]==\\'R\\')\\n            {\\n                count=0;\\n                flag = true;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    count++;\\n                    left[i]=count;\\n                }\\n            }\\n        }\\n        vector<int> right(n,INT_MAX);\\n        flag = false;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                flag = false;\\n            }    \\n            else if(dominoes[i]==\\'L\\')\\n            {\\n                count=0;\\n                flag = true;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    count++;\\n                    right[i]=count;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                if(left[i]<right[i])\\n                    dominoes[i]=\\'R\\';\\n                else if(left[i]>right[i])\\n                    dominoes[i]=\\'L\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```\\n\\nIf you reached till here please upvote this solution",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left(n,INT_MAX);\\n        int count = 0;\\n        bool flag = false;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                flag = false;\\n            }    \\n            else if(dominoes[i]==\\'R\\')\\n            {\\n                count=0;\\n                flag = true;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    count++;\\n                    left[i]=count;\\n                }\\n            }\\n        }\\n        vector<int> right(n,INT_MAX);\\n        flag = false;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                flag = false;\\n            }    \\n            else if(dominoes[i]==\\'L\\')\\n            {\\n                count=0;\\n                flag = true;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    count++;\\n                    right[i]=count;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                if(left[i]<right[i])\\n                    dominoes[i]=\\'R\\';\\n                else if(left[i]>right[i])\\n                    dominoes[i]=\\'L\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630312,
                "title": "tc-sc-o-n-c-easy-solution",
                "content": "```\\n//TC=O(N)\\n//SC=O(N)\\n\\nclass Solution {\\npublic:\\n    void helper(vector<char> &arr, int j, int k){ // there are 4 conditions as follows\\n        if(arr[j]==\\'L\\' && arr[k]==\\'L\\') \\n            for(int i=j; i<k; i++)\\n                arr[i]=\\'L\\';\\n        \\n        else if(arr[j]==\\'R\\' && arr[k]==\\'R\\')\\n            for(int i=j; i<k; i++)\\n                arr[i]=\\'R\\';\\n        \\n        else if(arr[j]==\\'R\\' && arr[k]==\\'L\\')\\n            while(j!=k && j<k){\\n                arr[j++]=\\'R\\', arr[k--]=\\'L\\';\\n            }\\n        else j=k++;\\n    }\\n\\t\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        \\n\\t\\tvector<char> arr(n+2); //create a vector of size n+2 and make the 1st and last element \\'L\\' and \\'R\\' respectively\\n        arr[0] = \\'L\\';\\n        arr[n+1] = \\'R\\';\\n        \\n        for (int i=1; i < arr.size()-1; i++) //make elements from index 1 to second last index of vector as string characters \\n            arr[i]=dominoes[i - 1];\\n        \\n        int j=0;// keep 2 pointers j and k to find \\'L\\' and \\'R\\' in the vector\\n        int k=1;\\n        \\n        while (k < arr.size()){\\n            while(arr[k] == \\'.\\')\\n                k++;\\n            helper(arr, j, k);// call the helper function to modify the vector\\n            j=k++;\\n        }\\n\\t\\t\\n        string str=\"\";// after the vector is modified add indexes 1 to second last element of vector in a string and return it\\n        for(int i=1; i<arr.size()-1; i++){\\n            str+=arr[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//TC=O(N)\\n//SC=O(N)\\n\\nclass Solution {\\npublic:\\n    void helper(vector<char> &arr, int j, int k){ // there are 4 conditions as follows\\n        if(arr[j]==\\'L\\' && arr[k]==\\'L\\') \\n            for(int i=j; i<k; i++)\\n                arr[i]=\\'L\\';\\n        \\n        else if(arr[j]==\\'R\\' && arr[k]==\\'R\\')\\n            for(int i=j; i<k; i++)\\n                arr[i]=\\'R\\';\\n        \\n        else if(arr[j]==\\'R\\' && arr[k]==\\'L\\')\\n            while(j!=k && j<k){\\n                arr[j++]=\\'R\\', arr[k--]=\\'L\\';\\n            }\\n        else j=k++;\\n    }\\n\\t\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        \\n\\t\\tvector<char> arr(n+2); //create a vector of size n+2 and make the 1st and last element \\'L\\' and \\'R\\' respectively\\n        arr[0] = \\'L\\';\\n        arr[n+1] = \\'R\\';\\n        \\n        for (int i=1; i < arr.size()-1; i++) //make elements from index 1 to second last index of vector as string characters \\n            arr[i]=dominoes[i - 1];\\n        \\n        int j=0;// keep 2 pointers j and k to find \\'L\\' and \\'R\\' in the vector\\n        int k=1;\\n        \\n        while (k < arr.size()){\\n            while(arr[k] == \\'.\\')\\n                k++;\\n            helper(arr, j, k);// call the helper function to modify the vector\\n            j=k++;\\n        }\\n\\t\\t\\n        string str=\"\";// after the vector is modified add indexes 1 to second last element of vector in a string and return it\\n        for(int i=1; i<arr.size()-1; i++){\\n            str+=arr[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630169,
                "title": "may-the-force-be-with-you-easy-short-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size(); \\n        vector<pair<int,int>> dp(n,{0,0});\\n        // first domino to be dropped towards right , will be from left start!\\n       // beacuse all other dominoes next inline would depend on it!\\n        for(int i=0; i<n; i++) {\\n             if(s[i] == \\'R\\') {\\n                  dp[i].second = 1;\\n             }else if(s[i] == \\'.\\' && i) {\\n                  dp[i].second = dp[i-1].second ? 1 + dp[i-1].second : 0;\\n             }\\n        }\\n        // first domino to be dropped towards left , will be from far right!\\n       // because all other dominoes next inline would depend on it!\\n        for(int i=n-1; i>=0; i--) {\\n              if(s[i] == \\'L\\') {\\n                   dp[i].first = 1;\\n              }else if(s[i] == \\'.\\' && i+1<n) {\\n                   dp[i].first = dp[i+1].first ? 1 + dp[i+1].first : 0;\\n              }\\n        }\\n        for(int i=0; i<n; i++) {\\n             if(dp[i].second == 0 || dp[i].first == 0) {\\n                  s[i] = dp[i].second ? \\'R\\' : dp[i].first ? \\'L\\' : \\'.\\';  // current force direction!\\n             }else if(dp[i].first < dp[i].second) {\\n                  s[i] = \\'L\\';   // if left has a force near than right direction!\\n             }else if(dp[i].second < dp[i].first) {\\n                  s[i] = \\'R\\';  // if right has a force near than left direction!\\n             }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size(); \\n        vector<pair<int,int>> dp(n,{0,0});\\n        // first domino to be dropped towards right , will be from left start!\\n       // beacuse all other dominoes next inline would depend on it!\\n        for(int i=0; i<n; i++) {\\n             if(s[i] == \\'R\\') {\\n                  dp[i].second = 1;\\n             }else if(s[i] == \\'.\\' && i) {\\n                  dp[i].second = dp[i-1].second ? 1 + dp[i-1].second : 0;\\n             }\\n        }\\n        // first domino to be dropped towards left , will be from far right!\\n       // because all other dominoes next inline would depend on it!\\n        for(int i=n-1; i>=0; i--) {\\n              if(s[i] == \\'L\\') {\\n                   dp[i].first = 1;\\n              }else if(s[i] == \\'.\\' && i+1<n) {\\n                   dp[i].first = dp[i+1].first ? 1 + dp[i+1].first : 0;\\n              }\\n        }\\n        for(int i=0; i<n; i++) {\\n             if(dp[i].second == 0 || dp[i].first == 0) {\\n                  s[i] = dp[i].second ? \\'R\\' : dp[i].first ? \\'L\\' : \\'.\\';  // current force direction!\\n             }else if(dp[i].first < dp[i].second) {\\n                  s[i] = \\'L\\';   // if left has a force near than right direction!\\n             }else if(dp[i].second < dp[i].first) {\\n                  s[i] = \\'R\\';  // if right has a force near than left direction!\\n             }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629854,
                "title": "o-n-easy-solution-to-be-noted",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n=dominoes.length(),i,j=Integer.MIN_VALUE;\\n        char dom[]=dominoes.toCharArray(), res[]=new char[n];\\n        boolean r = false,l=true;\\n        for(i=0;i<n;i++){\\n            res[i]=dom[i];\\n            if(dom[i]==\\'L\\'){\\n                if(l){ \\n                    fill(j,i,res,0,-1);\\n                    if(j>=0) res[j]=\\'L\\';\\n                }\\n                else fill(j,i,res,1,-1);\\n                l=true;\\n                j=i;\\n            }else if(dom[i]==\\'R\\' || i==n-1){\\n                if(!l){\\n                    fill(j,i,res,1,0);\\n                    res[i]=\\'R\\';\\n                }\\n                j=i;\\n                l=false;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    void fill(int j, int i, char[] res, int incrj, int incri){\\n        for(;j<i && i>=0;j+=incrj,i+=incri){\\n            if(j>=0) res[j]=\\'R\\';\\n            res[i]=\\'L\\';\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n=dominoes.length(),i,j=Integer.MIN_VALUE;\\n        char dom[]=dominoes.toCharArray(), res[]=new char[n];\\n        boolean r = false,l=true;\\n        for(i=0;i<n;i++){\\n            res[i]=dom[i];\\n            if(dom[i]==\\'L\\'){\\n                if(l){ \\n                    fill(j,i,res,0,-1);\\n                    if(j>=0) res[j]=\\'L\\';\\n                }\\n                else fill(j,i,res,1,-1);\\n                l=true;\\n                j=i;\\n            }else if(dom[i]==\\'R\\' || i==n-1){\\n                if(!l){\\n                    fill(j,i,res,1,0);\\n                    res[i]=\\'R\\';\\n                }\\n                j=i;\\n                l=false;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    void fill(int j, int i, char[] res, int incrj, int incri){\\n        for(;j<i && i>=0;j+=incrj,i+=incri){\\n            if(j>=0) res[j]=\\'R\\';\\n            res[i]=\\'L\\';\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629294,
                "title": "python3-multi-source-bfs",
                "content": "I know that a lot of great solutions have been discussed in the discussion, but I want to share mine as well -- a multi-source BFS solution.\\n\\nThe idea is pretty straightforward, we first add all position where the initial forces happen (i.e. add all \"L\" and \"R\"), and then does BFS.\\n\\nNotice that we need to take special care of collisions, so we need to modify BFS a littile bit. Here is my solution.\\n\\nSpace Complexity: O(N) because each position will only be added to the queue or to the collision dictionary once.\\nTime Complexity: O(N) because we loop through each element once.\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        ans = [\\'.\\' for _ in range(len(dominoes))]\\n\\n        queue = deque()\\n        for i, d in enumerate(dominoes):\\n            if d == \\'L\\' or d == \\'R\\':\\n                queue.append((i, d))\\n            ans[i] = d\\n        \\n        while queue:\\n            size = len(queue)\\n            collision = defaultdict(list)\\n            for _ in range(size):\\n                i, d = queue.popleft()\\n                if d == \\'L\\' and i - 1 >= 0 and ans[i - 1] == \\'.\\':\\n                    collision[i - 1].append(\\'L\\')\\n                elif d == \\'R\\' and i + 1 < len(ans) and ans[i + 1] == \\'.\\':\\n                    collision[i + 1].append(\\'R\\')\\n            for pos in collision:\\n                if len(collision[pos]) == 2:\\n                    ans[pos] = \\'.\\'\\n                else:\\n                    ans[pos] = collision[pos][0]\\n                    queue.append((pos, collision[pos][0]))\\n                \\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        ans = [\\'.\\' for _ in range(len(dominoes))]\\n\\n        queue = deque()\\n        for i, d in enumerate(dominoes):\\n            if d == \\'L\\' or d == \\'R\\':\\n                queue.append((i, d))\\n            ans[i] = d\\n        \\n        while queue:\\n            size = len(queue)\\n            collision = defaultdict(list)\\n            for _ in range(size):\\n                i, d = queue.popleft()\\n                if d == \\'L\\' and i - 1 >= 0 and ans[i - 1] == \\'.\\':\\n                    collision[i - 1].append(\\'L\\')\\n                elif d == \\'R\\' and i + 1 < len(ans) and ans[i + 1] == \\'.\\':\\n                    collision[i + 1].append(\\'R\\')\\n            for pos in collision:\\n                if len(collision[pos]) == 2:\\n                    ans[pos] = \\'.\\'\\n                else:\\n                    ans[pos] = collision[pos][0]\\n                    queue.append((pos, collision[pos][0]))\\n                \\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629285,
                "title": "java-using-two-dp-array",
                "content": "DP solution is not best for this question but i just want to share my idea\\nFirst we creat two dp array, in the right dp ,\\nIf at Index i we have \\'L\\' then dp[i] = 0;\\nIf at Index i we have \\'R\\' then dp[i] = 1;\\nIf at Index i we have \\'.\\' then if dp[i - 1] is postive , dp[i] = dp[i - 1] + 1, else dp[i] = 0;\\nwe do the same thing with the left dp\\nnow we have two dp array, so we can get the answer we want.\\n```\\n.   L .  R  .  .  .  L  R  .  .  L  .  .\\n0  0  0  1  2  3  4  0  1  2  3  0  0  0             right\\n-2 -1 0  0 -4 -3 -2 -1  0 -3 -2 -1  0  0             left\\n```\\nbut we still have two case here.\\ncase 1 Either left or right is 0\\n\\t\\tso, if left[i] + right[i] < 0 is left, > 0 is right\\ncase 2 Neither left nor right is 0\\n\\t\\tin this case, if left[i] + right[i] < 0 means close to right beacse we start from 1 and we have 2 3 4 5 6 the smaller the number, the closer the distance. so it is R\\n\\t\\t if left[i] + right[i] > 0 it is L\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int[] left = new int[dominoes.length()];\\n        int[] right = new int[dominoes.length()];\\n        for (int i = 0; i < left.length; i++) {\\n            if (dominoes.charAt(i) == \\'R\\'){\\n                right[i] = 1;\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'L\\'){\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'.\\'){\\n                if (i == 0) continue;\\n                if (right[i - 1] > 0) {\\n                    right[i] = right[i - 1] + 1;\\n                }\\n                continue;\\n            }\\n        }\\n        for (int i = right.length - 1; i >= 0; i--) {\\n            if (dominoes.charAt(i) == \\'L\\'){\\n                left[i] = -1;\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'R\\'){\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'.\\'){\\n                if (i == right.length - 1) continue;\\n                if (left[i + 1] < 0) {\\n                    left[i] = left[i + 1] - 1;\\n                }\\n                continue;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < left.length; i++) {\\n            if (left[i] + right[i] == 0) {\\n                sb.append(\\'.\\');\\n            }else if (left[i] == 0 || right[i] == 0){\\n                if (left[i] + right[i] < 0) {\\n                    sb.append(\\'L\\');\\n                }else {\\n                    sb.append(\\'R\\');\\n                }\\n            }else if (left[i] + right[i] < 0) {\\n                sb.append(\\'R\\');\\n            }else {\\n                sb.append(\\'L\\');\\n            }\\n            System.out.print(left[i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n.   L .  R  .  .  .  L  R  .  .  L  .  .\\n0  0  0  1  2  3  4  0  1  2  3  0  0  0             right\\n-2 -1 0  0 -4 -3 -2 -1  0 -3 -2 -1  0  0             left\\n```\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int[] left = new int[dominoes.length()];\\n        int[] right = new int[dominoes.length()];\\n        for (int i = 0; i < left.length; i++) {\\n            if (dominoes.charAt(i) == \\'R\\'){\\n                right[i] = 1;\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'L\\'){\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'.\\'){\\n                if (i == 0) continue;\\n                if (right[i - 1] > 0) {\\n                    right[i] = right[i - 1] + 1;\\n                }\\n                continue;\\n            }\\n        }\\n        for (int i = right.length - 1; i >= 0; i--) {\\n            if (dominoes.charAt(i) == \\'L\\'){\\n                left[i] = -1;\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'R\\'){\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'.\\'){\\n                if (i == right.length - 1) continue;\\n                if (left[i + 1] < 0) {\\n                    left[i] = left[i + 1] - 1;\\n                }\\n                continue;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < left.length; i++) {\\n            if (left[i] + right[i] == 0) {\\n                sb.append(\\'.\\');\\n            }else if (left[i] == 0 || right[i] == 0){\\n                if (left[i] + right[i] < 0) {\\n                    sb.append(\\'L\\');\\n                }else {\\n                    sb.append(\\'R\\');\\n                }\\n            }else if (left[i] + right[i] < 0) {\\n                sb.append(\\'R\\');\\n            }else {\\n                sb.append(\\'L\\');\\n            }\\n            System.out.print(left[i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629222,
                "title": "two-pointers-approach-c-space-less-than-80-submission",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Divided into following cases\\n    // L..R -> Stable\\n    // R..L -> Compart (equal no of rights and lefts)\\n    // L..L -> Leftwards\\n    // R..R -> Rightwards\\n    // ..R  -> Left part stable\\n    // ..L  -> Leftwards\\n    // L..  -> Right part stable\\n    // R..  -> Rightwards\\n    \\n    string pushDominoes(string dominoes) {\\n        string res;\\n        \\n        int l = 0;\\n        int r;\\n        \\n        int n = dominoes.size();\\n        \\n        int len;\\n        \\n        // Left is initiated with 0\\n        // Traversing the string with r\\n        \\n        for(r=0; r<n; r++){\\n            char curr = dominoes[r];\\n            \\n            if(curr == \\'L\\'){\\n                // can be a compart, left\\n                \\n                if(dominoes[l] == \\'R\\'){\\n                    // compart\\n                    res.push_back(\\'R\\');\\n                    len = r-l-1;\\n                    \\n                    int adds = len/2;\\n                    while(adds--)\\n                        res.push_back(\\'R\\');\\n\\n                    if(len%2 == 1)\\n                        res.push_back(\\'.\\');\\n                    \\n                    adds = len/2;\\n                    while(adds--)\\n                        res.push_back(\\'L\\');\\n                }else{\\n                    // left side\\n                    // both LL and .L\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'L\\');\\n                }\\n                \\n                l = r;\\n            }else if(curr == \\'R\\'){\\n                if(dominoes[l] == \\'L\\'){\\n                    // stable\\n                    res.push_back(\\'L\\');\\n                    len = r-l-1;\\n                    \\n                    while(len--)\\n                        res.push_back(\\'.\\');\\n                }else if(dominoes[l] == \\'R\\'){\\n                    // right side\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'R\\');\\n                }else{\\n                    // . and R\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'.\\');\\n                }\\n                \\n                l = r;\\n            }else\\n                continue;\\n        }\\n        \\n        \\n        // considering the last pair of l and r\\n        char curr = dominoes[l];\\n        r = n-1;\\n        \\n        len = r-l+1;\\n        \\n        if(curr == \\'R\\'){\\n            // Rightwards\\n            while(len--)\\n                res.push_back(\\'R\\');\\n        }else{ // L and . case\\n            for(int i=l; i<n; i++)\\n                res.push_back(dominoes[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Divided into following cases\\n    // L..R -> Stable\\n    // R..L -> Compart (equal no of rights and lefts)\\n    // L..L -> Leftwards\\n    // R..R -> Rightwards\\n    // ..R  -> Left part stable\\n    // ..L  -> Leftwards\\n    // L..  -> Right part stable\\n    // R..  -> Rightwards\\n    \\n    string pushDominoes(string dominoes) {\\n        string res;\\n        \\n        int l = 0;\\n        int r;\\n        \\n        int n = dominoes.size();\\n        \\n        int len;\\n        \\n        // Left is initiated with 0\\n        // Traversing the string with r\\n        \\n        for(r=0; r<n; r++){\\n            char curr = dominoes[r];\\n            \\n            if(curr == \\'L\\'){\\n                // can be a compart, left\\n                \\n                if(dominoes[l] == \\'R\\'){\\n                    // compart\\n                    res.push_back(\\'R\\');\\n                    len = r-l-1;\\n                    \\n                    int adds = len/2;\\n                    while(adds--)\\n                        res.push_back(\\'R\\');\\n\\n                    if(len%2 == 1)\\n                        res.push_back(\\'.\\');\\n                    \\n                    adds = len/2;\\n                    while(adds--)\\n                        res.push_back(\\'L\\');\\n                }else{\\n                    // left side\\n                    // both LL and .L\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'L\\');\\n                }\\n                \\n                l = r;\\n            }else if(curr == \\'R\\'){\\n                if(dominoes[l] == \\'L\\'){\\n                    // stable\\n                    res.push_back(\\'L\\');\\n                    len = r-l-1;\\n                    \\n                    while(len--)\\n                        res.push_back(\\'.\\');\\n                }else if(dominoes[l] == \\'R\\'){\\n                    // right side\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'R\\');\\n                }else{\\n                    // . and R\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'.\\');\\n                }\\n                \\n                l = r;\\n            }else\\n                continue;\\n        }\\n        \\n        \\n        // considering the last pair of l and r\\n        char curr = dominoes[l];\\n        r = n-1;\\n        \\n        len = r-l+1;\\n        \\n        if(curr == \\'R\\'){\\n            // Rightwards\\n            while(len--)\\n                res.push_back(\\'R\\');\\n        }else{ // L and . case\\n            for(int i=l; i<n; i++)\\n                res.push_back(dominoes[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628809,
                "title": "javascript-solution",
                "content": "```\\nvar pushDominoes = function(dominoes) {\\n    let start=0; \\n    let end=1;\\n    const arr = (\"L\"+ dominoes +\"R\").split(\"\");\\n    while(start < arr.length-1){\\n        while(arr[end]==\\'.\\') \\n            end++;\\n        if(arr[start] == arr[end]) \\n            for(let i= start+1; i<end; i++) {\\n                arr[i]=arr[start];   \\n            }\\n        if(arr[start]>arr[end]) \\n            for(let i=1; i<=(end-start-1)/2; i++){\\n                arr[start+i] = \\'R\\';\\n                arr[end-i] = \\'L\\';\\n            }   \\n        start=end++;\\n    }\\n    return arr.slice(1,arr.length-1).join(\"\");\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar pushDominoes = function(dominoes) {\\n    let start=0; \\n    let end=1;\\n    const arr = (\"L\"+ dominoes +\"R\").split(\"\");\\n    while(start < arr.length-1){\\n        while(arr[end]==\\'.\\') \\n            end++;\\n        if(arr[start] == arr[end]) \\n            for(let i= start+1; i<end; i++) {\\n                arr[i]=arr[start];   \\n            }\\n        if(arr[start]>arr[end]) \\n            for(let i=1; i<=(end-start-1)/2; i++){\\n                arr[start+i] = \\'R\\';\\n                arr[end-i] = \\'L\\';\\n            }   \\n        start=end++;\\n    }\\n    return arr.slice(1,arr.length-1).join(\"\");\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2628772,
                "title": "java-simple-easy-to-understand-using-array-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String s) {\\n        int n = s.length();\\n        char[] arr = s.toCharArray();\\n        char start = \\'.\\';\\n        char last = \\'.\\';\\n        int stidx = 0;\\n        int i = 0;\\n        while(i<n){\\n            stidx = i;\\n            while(i<n && arr[i]==\\'.\\'){\\n                i++;\\n            }\\n            if(i<n){\\n                last = arr[i];\\n            }\\n            if(i-stidx>0){\\n                if(start==\\'R\\' && last==\\'L\\'){\\n                    int l = stidx;\\n                    int r = i-1;\\n                    while(l<r){\\n                        arr[l]=\\'R\\';\\n                        arr[r]=\\'L\\';\\n                        l++;\\n                        r--;\\n                        \\n                    }\\n                   \\n                }\\n                else if(last==\\'L\\'){\\n                    int l = i-1;\\n                    while(l>=stidx){\\n                        arr[l]=\\'L\\';\\n                        l--;\\n                    }\\n                }\\n                else if(start==\\'R\\'){\\n                    int r = stidx;\\n                    while(r<i){\\n                        arr[r]=\\'R\\';\\n                        r++;\\n                    }   \\n                }\\n            }\\n            \\n            start = last;\\n            i++;\\n            last = \\'.\\';\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String s) {\\n        int n = s.length();\\n        char[] arr = s.toCharArray();\\n        char start = \\'.\\';\\n        char last = \\'.\\';\\n        int stidx = 0;\\n        int i = 0;\\n        while(i<n){\\n            stidx = i;\\n            while(i<n && arr[i]==\\'.\\'){\\n                i++;\\n            }\\n            if(i<n){\\n                last = arr[i];\\n            }\\n            if(i-stidx>0){\\n                if(start==\\'R\\' && last==\\'L\\'){\\n                    int l = stidx;\\n                    int r = i-1;\\n                    while(l<r){\\n                        arr[l]=\\'R\\';\\n                        arr[r]=\\'L\\';\\n                        l++;\\n                        r--;\\n                        \\n                    }\\n                   \\n                }\\n                else if(last==\\'L\\'){\\n                    int l = i-1;\\n                    while(l>=stidx){\\n                        arr[l]=\\'L\\';\\n                        l--;\\n                    }\\n                }\\n                else if(start==\\'R\\'){\\n                    int r = stidx;\\n                    while(r<i){\\n                        arr[r]=\\'R\\';\\n                        r++;\\n                    }   \\n                }\\n            }\\n            \\n            start = last;\\n            i++;\\n            last = \\'.\\';\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053804,
                "title": "simple-ruby-string-replace-in-one-line",
                "content": "One line solution:\\n```\\ndef push_dominoes(dominoes)\\n    loop { return dominoes if dominoes == dominoes = dominoes.gsub(\\'R.L\\', \\'|\\').gsub(\\'.L\\', \\'LL\\').gsub(\\'R.\\', \\'RR\\').gsub(\\'|\\', \\'R.L\\') }\\nend\\n```\\n\\nCan also write in much more readable form:\\n```\\ndef push_dominoes(dominoes)\\n    loop { return dominoes if dominoes == dominoes = execute(dominoes) }\\nend\\n\\ndef execute(dominoes)\\n    dominoes\\n    .gsub(\\'R.L\\', \\'|\\')\\n    .gsub(\\'.L\\', \\'LL\\')\\n    .gsub(\\'R.\\', \\'RR\\')\\n    .gsub(\\'|\\', \\'R.L\\')\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef push_dominoes(dominoes)\\n    loop { return dominoes if dominoes == dominoes = dominoes.gsub(\\'R.L\\', \\'|\\').gsub(\\'.L\\', \\'LL\\').gsub(\\'R.\\', \\'RR\\').gsub(\\'|\\', \\'R.L\\') }\\nend\\n```\n```\\ndef push_dominoes(dominoes)\\n    loop { return dominoes if dominoes == dominoes = execute(dominoes) }\\nend\\n\\ndef execute(dominoes)\\n    dominoes\\n    .gsub(\\'R.L\\', \\'|\\')\\n    .gsub(\\'.L\\', \\'LL\\')\\n    .gsub(\\'R.\\', \\'RR\\')\\n    .gsub(\\'|\\', \\'R.L\\')\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2012322,
                "title": "simple-replace-function-python",
                "content": "```\\n    def pushDominoes(self, dominoes: str) -> str:\\n        while True:\\n            new= dominoes.replace(\\'R.L\\',\\'S\\').replace(\\'.L\\',\\'LL\\').replace(\\'R.\\',\\'RR\\')\\n            \\n            if new==dominoes:\\n                break\\n            else:\\n                dominoes=new\\n        return dominoes.replace(\\'S\\',\\'R.L\\')\\n```",
                "solutionTags": [],
                "code": "```\\n    def pushDominoes(self, dominoes: str) -> str:\\n        while True:\\n            new= dominoes.replace(\\'R.L\\',\\'S\\').replace(\\'.L\\',\\'LL\\').replace(\\'R.\\',\\'RR\\')\\n            \\n            if new==dominoes:\\n                break\\n            else:\\n                dominoes=new\\n        return dominoes.replace(\\'S\\',\\'R.L\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2001558,
                "title": "simple-c-solution-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n       int n = dom.length(); \\n       queue<pair<char,int>> q;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(dom[i]!=\\'.\\')q.push({dom[i],i});\\n       }\\n       while(q.empty()==false)\\n       {\\n           char ch = q.front().first;\\n           int ind = q.front().second;\\n           q.pop();\\n           if(ch==\\'L\\')\\n           {\\n               if(ind-1>=0 && dom[ind-1]==\\'.\\')\\n               {\\n                  dom[ind-1] = \\'L\\';\\n                  q.push({\\'L\\',ind-1}); \\n               }\\n           }\\n           else if(ch==\\'R\\')\\n           {\\n               if(ind+1<n && dom[ind+1]==\\'.\\')\\n               {\\n                   if(ind+2<n && dom[ind+2]==\\'L\\')\\n                       q.pop();\\n                   else{\\n                       dom[ind+1]=\\'R\\';\\n                       q.push({\\'R\\',ind+1});\\n                   }\\n               }\\n           }\\n       }\\n       return dom; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n       int n = dom.length(); \\n       queue<pair<char,int>> q;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(dom[i]!=\\'.\\')q.push({dom[i],i});\\n       }\\n       while(q.empty()==false)\\n       {\\n           char ch = q.front().first;\\n           int ind = q.front().second;\\n           q.pop();\\n           if(ch==\\'L\\')\\n           {\\n               if(ind-1>=0 && dom[ind-1]==\\'.\\')\\n               {\\n                  dom[ind-1] = \\'L\\';\\n                  q.push({\\'L\\',ind-1}); \\n               }\\n           }\\n           else if(ch==\\'R\\')\\n           {\\n               if(ind+1<n && dom[ind+1]==\\'.\\')\\n               {\\n                   if(ind+2<n && dom[ind+2]==\\'L\\')\\n                       q.pop();\\n                   else{\\n                       dom[ind+1]=\\'R\\';\\n                       q.push({\\'R\\',ind+1});\\n                   }\\n               }\\n           }\\n       }\\n       return dom; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905096,
                "title": "weeb-explains-python-c-2-pointers-solution",
                "content": "![image](https://assets.leetcode.com/users/images/60c692dc-d9bc-4592-bbb6-98c134b94042_1648868037.2552137.png)\\n\\nWe have 2 edge cases\\n**1st edge case**\\nif the first char is a \".\\', i.e dominoes[i] == \\'.\\', then its either :\\nAll the \\'.\\' becomes \\'L\\' **if our second pointer is \\'L\\'**\\n**or**\\nAll the \\'.\\' remain as \\'.\\' **if our second pointer is \\'R\\'**\\ni.e. lets say we have dominoes = \\'.....L\\'\\nresult = \\'LLLLLL\\'\\n**or**\\ni.e. lets say we have dominoes= \\'.....R\\'\\nresult = \\'.....R\\'\\n\\n**2nd edge case**\\nif the last char is a \".\\', i.e dominoes[len(arr)-1] == \\'.\\', then its either :\\nAll the \\'.\\' becomes \\'R\\' **if our second pointer is \\'R\\'**\\n**or**\\nAll the \\'.\\' remain as \\'.\\' **if our second pointer is \\'L\\'**\\ni.e. lets say we have dominoes = \\'R.....\\'\\nresult = \\'RRRRRR\\'\\n**or**\\ni.e. lets say we have dominoes= \\'L.....\\'\\nresult = \\'L.....\\'\\n\\nNow that the 2 edge cases are handled, it is **guaranteed** that our pointer will start and end with either an \\'L\\' or \\'R\\'\\nWith that, there are another **4 more possibilities of arrangements** which are **RR, LL, RL, LR**\\n**1st arragement : RR**\\n-All elements within RR will become \\'R\\'\\ni.e. dominoes = \"R.....R\"\\nresult = \"RRRRRR\"\\n**2nd arragement : LL**\\n-All elements within LL will become \\'L\\'\\ni.e. dominoes = \"L.....L\"\\nresult = \"LLLLLL\"\\n**3rd arragement : RL**\\n-half of the elements within RL will become \\'R\\', another half will become \\'L\\'\\nhowever, there are **2 cases to handle within this subproblem**, if we have **even** number of \\'.\\' within RL\\ni.e dominoes = \"R....L\"\\nresult = \"RRRLLL\"\\nelse, if we have **odd** number of \\'.\\' within RL\\ni.e. dominoes = \"R.....L\"\\nresult = \"RRR.LLL\" (the midpoint should remain as a \\'.\\')\\n**4th arragement : LR**\\nNo change within the elements of LR\\ni.e. dominoes = \"L.....R\"\\nresult = \"L.....R\"\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string dominoes) {\\n\\t\\t\\tvector<char> arr(dominoes.begin(), dominoes.end());\\n\\t\\t\\tint low = 0, high = arr.size()-1;\\n\\n\\t\\t\\tif (arr[low] == \\'.\\'){\\n\\t\\t\\t\\tfor (int i = 0; i < arr.size(); i++){\\n\\t\\t\\t\\t\\tif (arr[i] == \\'R\\'){\\n\\t\\t\\t\\t\\t\\tlow = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (arr[i] == \\'L\\'){\\n\\t\\t\\t\\t\\t\\tfor (int j = 0; j < i; j++) arr[j] = \\'L\\';\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}      \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (arr[high] == \\'.\\')\\n\\t\\t\\t\\tfor (int i = arr.size()-1; i > -1; i--){\\n\\t\\t\\t\\t\\tif (arr[i] == \\'L\\'){\\n\\t\\t\\t\\t\\t\\thigh = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (arr[i] == \\'R\\'){\\n\\t\\t\\t\\t\\t\\tfor (int j=i; j<arr.size();j++) arr[j] = \\'R\\';\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tint i = low;\\n\\t\\t\\tfor (int j = low+1; j<high+1; j++){\\n\\t\\t\\t\\tif (arr[i] == \\'R\\' && arr[j] == \\'L\\'){\\n\\t\\t\\t\\t\\tint mid = (i+j)/2;\\n\\t\\t\\t\\t\\tint temp = j;\\n\\t\\t\\t\\t\\twhile (i != j){\\n\\t\\t\\t\\t\\t\\tif (i >= temp){\\n\\t\\t\\t\\t\\t\\t\\ti = j;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tarr[i] = \\'R\\';\\n\\t\\t\\t\\t\\t\\tarr[temp] = \\'L\\';\\n\\n\\t\\t\\t\\t\\t\\ttemp--;\\n\\t\\t\\t\\t\\t\\ti++;   \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (arr[i] == \\'R\\' && arr[j] == \\'R\\'){\\n\\t\\t\\t\\t\\twhile (i != j){\\n\\t\\t\\t\\t\\t\\tarr[i] = \\'R\\';\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (arr[i] == \\'L\\' && arr[j] == \\'L\\'){\\n\\t\\t\\t\\t\\twhile (i != j){\\n\\t\\t\\t\\t\\t\\tarr[i] = \\'L\\';\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (arr[i] == \\'L\\' && arr[j] == \\'R\\') i = j;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring result = \"\";\\n\\n\\t\\t\\tfor (int i = 0; i < arr.size(); i++) result += arr[i];\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t};\\n\\n**Python** \\n\\t\\n\\tclass Solution:\\n    def pushDominoes(self, string: str) -> str:\\n        low, high = 0, len(string) - 1\\n        string = list(string)\\n        \\n        if string[low] == \".\":\\n            for i in range(len(string)):\\n                if string[i] == \"R\": \\n                    low = i\\n                    break\\n                \\n                if string[i] == \"L\":\\n                    for j in range(i):\\n                        string[j] = \"L\"\\n                    break\\n                    \\n        if string[high] == \".\":\\n            for i in range(len(string)-1,-1,-1):\\n                if string[i] == \"L\": \\n                    high = i\\n                    break\\n                \\n                if string[i] == \"R\":\\n                    for j in range(i, len(string)):\\n                        string[j] = \"R\"\\n                    break\\n        \\n        i = low\\n        for j in range(low+1, high+1):\\n            if string[i] == \"R\" and string[j] == \"L\":\\n                mid = (i+j) //2 \\n                temp = j\\n                while i != j:\\n                    if i >= temp:\\n                        i = j\\n                        break\\n                    \\n                    string[i] = \"R\"\\n                    string[temp] = \"L\"\\n                    \\n                    temp-=1\\n                    i+=1\\n            \\n            if string[i] == \"R\" and string[j] == \"R\":\\n                while i != j:\\n                    string[i] = \"R\"\\n                    i+=1\\n            \\n            if string[i] == \"L\" and string[j] == \"L\":\\n                while i != j:\\n                    string[i] = \"L\"\\n                    i+=1\\n                \\n            if string[i] == \"L\" and string[j] == \"R\":\\n                i = j\\n    \\n        return \"\".join(string)\\n\\nBruh, take a break, watch some anime instead\\nCheck out **\\u738B\\u69D8\\u30E9\\u30F3\\u30AD\\u30F3\\u30B0 (Ranking of Kings)**\\n\\n# Episodes: 23\\n# Genres: Adventure, Fantasy\\n\\nThis anime is amazing, watch it.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string dominoes) {\\n\\t\\t\\tvector<char> arr(dominoes.begin(), dominoes.end());\\n\\t\\t\\tint low = 0, high = arr.size()-1;\\n\\n\\t\\t\\tif (arr[low] == \\'.\\'){\\n\\t\\t\\t\\tfor (int i = 0; i < arr.size(); i++){\\n\\t\\t\\t\\t\\tif (arr[i] == \\'R\\'){\\n\\t\\t\\t\\t\\t\\tlow = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1667195,
                "title": "6-lines-c-linq-o-n",
                "content": "It isn\\'t a good code. But it\\'s quite short.\\n\\n```\\npublic class Solution \\n{\\n    private IEnumerable<int> DistTo(IEnumerable<char> dominoes, char R, char L) \\n    {\\n        int dist = Int32.MaxValue / 2;\\n        return dominoes\\n                .Select(domino => domino == R ? dist = 0 : (domino == L ? dist = Int32.MaxValue / 2 : ++dist))\\n                .Select(x => x < Int32.MaxValue / 2 ? x : Int32.MaxValue / 2);\\n    }\\n    \\n    public string PushDominoes(string dominoes)\\n        => String.Concat(DistTo(dominoes, \\'R\\', \\'L\\').Zip(DistTo(dominoes.Reverse(), \\'L\\', \\'R\\').Reverse(),\\n                                                        (r, l) => r < l ? \\'R\\' : (r > l ? \\'L\\' : \\'.\\')));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    private IEnumerable<int> DistTo(IEnumerable<char> dominoes, char R, char L) \\n    {\\n        int dist = Int32.MaxValue / 2;\\n        return dominoes\\n                .Select(domino => domino == R ? dist = 0 : (domino == L ? dist = Int32.MaxValue / 2 : ++dist))\\n                .Select(x => x < Int32.MaxValue / 2 ? x : Int32.MaxValue / 2);\\n    }\\n    \\n    public string PushDominoes(string dominoes)\\n        => String.Concat(DistTo(dominoes, \\'R\\', \\'L\\').Zip(DistTo(dominoes.Reverse(), \\'L\\', \\'R\\').Reverse(),\\n                                                        (r, l) => r < l ? \\'R\\' : (r > l ? \\'L\\' : \\'.\\')));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354237,
                "title": "c-easy-two-pointers-explained",
                "content": "The idea here is to use two pointer approach.\\nWe need to insert \\'L\\' in the beginning to make the process easier.\\ninitially i is pointing to beginning \\'L\\'. \\nj = i+1, continue incrementing j as long as dominoes[i]=\\'.\\' \\nAs soon we encounter \\'L\\' or \\'R\\', we stop.\\nHere are 4 possibilities:\\n1. i=\\'L\\' and j=\\'L\\' --> we fill all the characters between i and j with \\'L\\'\\n2. i=\\'R\\' and j=\\'R\\' --> we fill all the characters between i and j with \\'R\\'.\\n3. i=\\'L\\' and j=\\'R\\' --> we don\\'t do anything. All characters remain as it is.\\n4. i=\\'R\\' and j=\\'L\\' --> Here we need to fill the characters with \\'R\\' and \\'L\\' both. We calculate mid point between j-1 and i index and fill the characters as shown below.\\n\\nLastly, if j==size, that means we reached end, then check if dominoes[i]==\\'R\\' --> fill all characters till end with \\'R\\'.\\nAdjust pointers i and j. We already processed characters till j. so now i=j.\\n```\\n string pushDominoes(string dominoes) {\\n        int i, j,k, size, mid, count=0;\\n        string result;\\n        result = dominoes;\\n        dominoes.insert(dominoes.begin()+0, \\'L\\');\\n        size = dominoes.size();\\n        for(i=0; i<size-1; )\\n        {\\n           j=i+1;\\n            while(j<size && dominoes[j]==\\'.\\')\\n                j++;\\n            if(j<size)\\n            {\\n                if(dominoes[i]==\\'R\\' && dominoes[j]==\\'L\\')\\n                {\\n                    mid = ((j-1)-i)/2;\\n                    for(k=1; k<=mid; k++)\\n                    {\\n                        dominoes[i+k] = dominoes[i];\\n                        dominoes[j-k] = dominoes[j];\\n                    }\\n                }\\n                else if(dominoes[i]==\\'L\\' && dominoes[j]==\\'L\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k]=\\'L\\';\\n                }\\n                else if(dominoes[i]==\\'R\\' && dominoes[j]==\\'R\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k] = \\'R\\';\\n                }\\n            }\\n            else\\n            {\\n                if(dominoes[i]==\\'R\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k] = \\'R\\';\\n                }\\n            }\\n            i=j;\\n        }\\n        dominoes.erase(dominoes.begin()+0);\\n        return dominoes;\\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n string pushDominoes(string dominoes) {\\n        int i, j,k, size, mid, count=0;\\n        string result;\\n        result = dominoes;\\n        dominoes.insert(dominoes.begin()+0, \\'L\\');\\n        size = dominoes.size();\\n        for(i=0; i<size-1; )\\n        {\\n           j=i+1;\\n            while(j<size && dominoes[j]==\\'.\\')\\n                j++;\\n            if(j<size)\\n            {\\n                if(dominoes[i]==\\'R\\' && dominoes[j]==\\'L\\')\\n                {\\n                    mid = ((j-1)-i)/2;\\n                    for(k=1; k<=mid; k++)\\n                    {\\n                        dominoes[i+k] = dominoes[i];\\n                        dominoes[j-k] = dominoes[j];\\n                    }\\n                }\\n                else if(dominoes[i]==\\'L\\' && dominoes[j]==\\'L\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k]=\\'L\\';\\n                }\\n                else if(dominoes[i]==\\'R\\' && dominoes[j]==\\'R\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k] = \\'R\\';\\n                }\\n            }\\n            else\\n            {\\n                if(dominoes[i]==\\'R\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k] = \\'R\\';\\n                }\\n            }\\n            i=j;\\n        }\\n        dominoes.erase(dominoes.begin()+0);\\n        return dominoes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1353683,
                "title": "c-easy-clean-solution",
                "content": "**Solution I:**\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        if(s.size() == 1)\\n            return s;\\n        string fans = \"\";\\n        while(1){\\n            string ans = \"\";\\n            for(int i = 0; i < s.size(); i++){\\n                if(i == 0){\\n                    if(s[i] == \\'.\\' and s[i + 1] == \\'L\\') ans += s[i + 1];\\n                    else ans += s[i];\\n                }\\n                else if(i == s.size() - 1){\\n                    if(s[i] == \\'.\\' and s[i - 1] == \\'R\\') ans += s[i - 1];\\n                    else ans += s[i];\\n                }\\n                else{\\n                    if(s[i] == \\'.\\' and s[i - 1] == \\'R\\' and s[i + 1] != \\'L\\') ans += s[i - 1];\\n                    else if(s[i] == \\'.\\' and s[i + 1] == \\'L\\' and s[i - 1] != \\'R\\') ans += s[i + 1];\\n                    else ans += s[i];\\n                }\\n            }\\n            s = ans;\\n            if(s == fans) break;\\n            else fans = s; \\n        }\\n        return fans;\\n    }\\n};\\n```\\n\\n**Solution II:**\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        ll n = s.size();\\n        if(n == 1)\\n            return s;\\n        vector<ll> r(n), l(n);\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'R\\') r[i] = 1;\\n            else if(s[i] == \\'.\\' and i > 0){\\n                if(r[i - 1] != INT_MAX) r[i] = r[i - 1] + 1;\\n                else r[i] = INT_MAX;\\n            }\\n            else r[i] = INT_MAX;     \\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            if(s[i] == \\'L\\') l[i] = 1;\\n            else if(s[i] == \\'.\\' and i < n - 1){\\n                if(l[i + 1] != INT_MAX) l[i] = l[i + 1] + 1;\\n                else l[i] = INT_MAX;\\n            }\\n            else l[i] = INT_MAX;\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'.\\'){\\n                if(l[i] == r[i]) ans += \\'.\\';\\n                else if(l[i] < r[i]) ans += \\'L\\';\\n                else if(l[i] > r[i]) ans += \\'R\\';\\n            }\\n            else ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        if(s.size() == 1)\\n            return s;\\n        string fans = \"\";\\n        while(1){\\n            string ans = \"\";\\n            for(int i = 0; i < s.size(); i++){\\n                if(i == 0){\\n                    if(s[i] == \\'.\\' and s[i + 1] == \\'L\\') ans += s[i + 1];\\n                    else ans += s[i];\\n                }\\n                else if(i == s.size() - 1){\\n                    if(s[i] == \\'.\\' and s[i - 1] == \\'R\\') ans += s[i - 1];\\n                    else ans += s[i];\\n                }\\n                else{\\n                    if(s[i] == \\'.\\' and s[i - 1] == \\'R\\' and s[i + 1] != \\'L\\') ans += s[i - 1];\\n                    else if(s[i] == \\'.\\' and s[i + 1] == \\'L\\' and s[i - 1] != \\'R\\') ans += s[i + 1];\\n                    else ans += s[i];\\n                }\\n            }\\n            s = ans;\\n            if(s == fans) break;\\n            else fans = s; \\n        }\\n        return fans;\\n    }\\n};\\n```\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        ll n = s.size();\\n        if(n == 1)\\n            return s;\\n        vector<ll> r(n), l(n);\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'R\\') r[i] = 1;\\n            else if(s[i] == \\'.\\' and i > 0){\\n                if(r[i - 1] != INT_MAX) r[i] = r[i - 1] + 1;\\n                else r[i] = INT_MAX;\\n            }\\n            else r[i] = INT_MAX;     \\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            if(s[i] == \\'L\\') l[i] = 1;\\n            else if(s[i] == \\'.\\' and i < n - 1){\\n                if(l[i + 1] != INT_MAX) l[i] = l[i + 1] + 1;\\n                else l[i] = INT_MAX;\\n            }\\n            else l[i] = INT_MAX;\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'.\\'){\\n                if(l[i] == r[i]) ans += \\'.\\';\\n                else if(l[i] < r[i]) ans += \\'L\\';\\n                else if(l[i] > r[i]) ans += \\'R\\';\\n            }\\n            else ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352429,
                "title": "simple-bfs-solution-c",
                "content": "**if you don\\'t like my solution please comment ,, do not downvote**\\n```\\n\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n     \\n        queue<int> q; //for storing the indexes\\n        \\n        for(int i=0;i<dominoes.size();i++){\\n            if(dominoes[i]==\\'L\\' || dominoes[i]==\\'R\\'){\\n                q.push(i);\\n            }\\n        }\\n        \\n        string ans = dominoes; // for keeping track of the changes\\n        \\n        while(!q.empty()){\\n            \\n            int s = q.size();\\n            \\n            for(int i=0;i<s;i++){\\n                \\n                auto p = q.front();\\n                q.pop();\\n                \\n                if(p-1>=0 && dominoes[p]==\\'L\\' && dominoes[p-1]==\\'.\\'){\\n                    \\n                    if(p-2>=0 && (dominoes[p-2]==\\'.\\' || dominoes[p-2]==\\'L\\')){\\n                        ans[p-1] = \\'L\\';\\n                        q.push(p-1);    \\n                    }\\n                    \\n                    if(p-2<0){\\n                        ans[p-1] = \\'L\\';\\n                    }\\n                    \\n                }\\n                \\n                if(p+1<dominoes.size() && dominoes[p]==\\'R\\' && dominoes[p+1]==\\'.\\'){\\n                    \\n                    if(p+2<dominoes.size() && (dominoes[p+2]==\\'.\\' || dominoes[p+2]==\\'R\\'))\\n                    {\\n                      ans[p+1] = \\'R\\';\\n                    q.push(p+1);\\n  \\n                    }         \\n                    if(p+2>=dominoes.size()){\\n                        ans[p+1] = \\'R\\';\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            dominoes = ans; // after t = 1 in the next time stamp we will have the updated string\\n        }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n     \\n        queue<int> q; //for storing the indexes\\n        \\n        for(int i=0;i<dominoes.size();i++){\\n            if(dominoes[i]==\\'L\\' || dominoes[i]==\\'R\\'){\\n                q.push(i);\\n            }\\n        }\\n        \\n        string ans = dominoes; // for keeping track of the changes\\n        \\n        while(!q.empty()){\\n            \\n            int s = q.size();\\n            \\n            for(int i=0;i<s;i++){\\n                \\n                auto p = q.front();\\n                q.pop();\\n                \\n                if(p-1>=0 && dominoes[p]==\\'L\\' && dominoes[p-1]==\\'.\\'){\\n                    \\n                    if(p-2>=0 && (dominoes[p-2]==\\'.\\' || dominoes[p-2]==\\'L\\')){\\n                        ans[p-1] = \\'L\\';\\n                        q.push(p-1);    \\n                    }\\n                    \\n                    if(p-2<0){\\n                        ans[p-1] = \\'L\\';\\n                    }\\n                    \\n                }\\n                \\n                if(p+1<dominoes.size() && dominoes[p]==\\'R\\' && dominoes[p+1]==\\'.\\'){\\n                    \\n                    if(p+2<dominoes.size() && (dominoes[p+2]==\\'.\\' || dominoes[p+2]==\\'R\\'))\\n                    {\\n                      ans[p+1] = \\'R\\';\\n                    q.push(p+1);\\n  \\n                    }         \\n                    if(p+2>=dominoes.size()){\\n                        ans[p+1] = \\'R\\';\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            dominoes = ans; // after t = 1 in the next time stamp we will have the updated string\\n        }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201805,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        if(n <= 1)return dominoes;\\n        /* index is storing the index of every l and r\\n        we are making it of n+2 size beacuse we can have all char as r and L in dominoes and +2 becuase we are\\n        inserting L in front and R in end of string, they won\\'t make any difference but they can b used to\\n        handel these cases\\n       \\n       case:1 - (<-) L......L(<-) or (->)R....R(->) when the exert force on only on same side then all the  standing\\n\\t                  dominoes will fall in the direction same as we are exerting force. so it can be written  as LLLLL or   RRRRR.    \\n        case:2 - (<-)L.....R(->) can be neglected beacuse they won\\'t make any chang in dominoes between them.\\n        \\n        case:3 - (->)R......L(<-) so this is the case we need to care about, so in this we can further have two \\n                    two cases i). even number of (.) so first half dominoes will fall in right and second half \\n                    will fall in left and when they both meet they will be like //\\\\\\\\\\n                    second case ii). odd number of dots .  so, the mid will stand tall as both from left and \\n                    right we are exerting force and due to that it will stand tall ex, //|\\\\\\\\ */\\n        \\n        int[] index = new int[n+2];\\n        char[] symbol = new char[n+2];\\n        int len = 1;\\n        index[0] = -1;\\n        symbol[0] = \\'L\\';\\n        \\n        for(int i = 0 ; i < n; i++){\\n            if(dominoes.charAt(i) != \\'.\\'){\\n                index[len] = i;\\n                symbol[len++] = dominoes.charAt(i);\\n            }\\n        }\\n        index[len] = n;\\n        symbol[len++] = \\'R\\';\\n        \\n        char[] ans = dominoes.toCharArray();\\n        for(int k = 0; k < len-1; k++){\\n            int i = index[k] , j = index[k+1];\\n            char x = symbol[k] , y = symbol[k+1];\\n            \\n            if(x == y){\\n                // case 1\\n                for(int a = i+1; a<j; a++){\\n                    ans[a] = x;\\n                }  //case 2 will be ignored as it can\\'t make any change in stability of dominoes.\\n            }else if(x > y){\\n                //case 3\\n                for(int a = i+1; a < j ; a++){\\n                    ans[a] = a-i == j-a ? \\'.\\' : a-i < j-a ? \\'R\\' : \\'L\\';\\n                }\\n            }\\n        }\\n        return String.valueOf(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        if(n <= 1)return dominoes;\\n        /* index is storing the index of every l and r\\n        we are making it of n+2 size beacuse we can have all char as r and L in dominoes and +2 becuase we are\\n        inserting L in front and R in end of string, they won\\'t make any difference but they can b used to\\n        handel these cases\\n       \\n       case:1 - (<-) L......L(<-) or (->)R....R(->) when the exert force on only on same side then all the  standing\\n\\t                  dominoes will fall in the direction same as we are exerting force. so it can be written  as LLLLL or   RRRRR.    \\n        case:2 - (<-)L.....R(->) can be neglected beacuse they won\\'t make any chang in dominoes between them.\\n        \\n        case:3 - (->)R......L(<-) so this is the case we need to care about, so in this we can further have two \\n                    two cases i). even number of (.) so first half dominoes will fall in right and second half \\n                    will fall in left and when they both meet they will be like //\\\\\\\\\\n                    second case ii). odd number of dots .  so, the mid will stand tall as both from left and \\n                    right we are exerting force and due to that it will stand tall ex, //|\\\\\\\\ */\\n        \\n        int[] index = new int[n+2];\\n        char[] symbol = new char[n+2];\\n        int len = 1;\\n        index[0] = -1;\\n        symbol[0] = \\'L\\';\\n        \\n        for(int i = 0 ; i < n; i++){\\n            if(dominoes.charAt(i) != \\'.\\'){\\n                index[len] = i;\\n                symbol[len++] = dominoes.charAt(i);\\n            }\\n        }\\n        index[len] = n;\\n        symbol[len++] = \\'R\\';\\n        \\n        char[] ans = dominoes.toCharArray();\\n        for(int k = 0; k < len-1; k++){\\n            int i = index[k] , j = index[k+1];\\n            char x = symbol[k] , y = symbol[k+1];\\n            \\n            if(x == y){\\n                // case 1\\n                for(int a = i+1; a<j; a++){\\n                    ans[a] = x;\\n                }  //case 2 will be ignored as it can\\'t make any change in stability of dominoes.\\n            }else if(x > y){\\n                //case 3\\n                for(int a = i+1; a < j ; a++){\\n                    ans[a] = a-i == j-a ? \\'.\\' : a-i < j-a ? \\'R\\' : \\'L\\';\\n                }\\n            }\\n        }\\n        return String.valueOf(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201268,
                "title": "c-easy-one-pass-solution-using-stack",
                "content": "First of all, we see that the their are four possible combinatoins with L and R.\\n1) We encounter a L after another L\\n2) We encounter a R after an L\\n3) We encounter a L after an R\\n4) We encounter a R after another R.\\n\\nNow, of these four case, only case where there is chance of a middle element is case 3.\\nBut let me break it down case by case for you.\\n\\ncase 1 : ...L...L \\n\\tIn such case we can easily say that while going left from current point we can simply mark everthing as L until we reach the start of string or encounter the other L. whichever occurs first.\\n\\ncase 2: ....L...R... \\n\\tIn such case, we don\\'t need to do anything and simply update the values in L and R var that we use to store the position of last encounter L or R. As case 1 will make everything before L as L and case 4 will handle the dots after R. \\n\\ncase 3: ...R...L.. \\n\\tNow this one requires us to do a bit. We use a two pointer approach and take i=postion of last encounterd R and j= position of current L and do a loop while(i<j) with incrementing i and making the dots R and decrementing J and making the dots L.\\n\\nCase 4: \\n\\tA bit similar to case 1, the only catch is unlike L, since we don\\'t directly start updating all the values to \\'R\\' as soon as we encounter R, we start from the previous positon of R and make everything \\'R\\' between the two Rs. Then update the value of positon of last encountered R. \\nFor this reason, once we have iterated everything, we need to check if the top element in the stack is R, if yes, run a loop to make everything after that a R until the end of the string.\\n\\nIn all these cases, we push the encountered L or R into the stack after doing the operation.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int l=-1;//to strore the position of last encountered L\\n        int r=-1;// to store the position of last encountered R\\n        int n= dominoes.size();\\n   \\n       \\n        stack<char> s;\\n        for(int i=0; i<n;i++)\\n        {  \\n            if(dominoes[i]==\\'L\\')\\n            {\\n                 l=i;\\n\\n                if(s.empty()||s.top()!=\\'R\\')//case 1 (and case 3 since there is nothing to be done in case 3)\\n                {\\n                   i--;//so that the next loop runs as dominoes[i] is \\'L\\'\\n                    while(i>=0&&dominoes[i]!=\\'L\\')\\n                    {\\n                        dominoes[i]=\\'L\\';i--;\\n                    }\\n                }\\n                else \\n                { \\n                    for(int i=r,j=l;i<j;i++,j--)//case 3\\n                    {\\n                        dominoes[i]=\\'R\\';\\n                        dominoes[j]=\\'L\\';\\n                    }\\n                }\\n                s.push(\\'L\\');\\n                i=l;\\n            }\\n            else if(dominoes[i]==\\'R\\')\\n            { \\n                if(!s.empty()&&s.top()==\\'R\\')\\n                    while(r<=i)\\n                    {\\n                        dominoes[r]=\\'R\\';\\n                        r++;\\n                    }\\n                r=i;\\n                s.push(\\'R\\');\\n            } \\n                \\n            \\n        }\\n        if(!s.empty()&&s.top()==\\'R\\')\\n            while(r<n)\\n                {  \\n                dominoes[r]=\\'R\\';\\n                    r++;\\n                }\\n        \\n        return dominoes;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int l=-1;//to strore the position of last encountered L\\n        int r=-1;// to store the position of last encountered R\\n        int n= dominoes.size();\\n   \\n       \\n        stack<char> s;\\n        for(int i=0; i<n;i++)\\n        {  \\n            if(dominoes[i]==\\'L\\')\\n            {\\n                 l=i;\\n\\n                if(s.empty()||s.top()!=\\'R\\')//case 1 (and case 3 since there is nothing to be done in case 3)\\n                {\\n                   i--;//so that the next loop runs as dominoes[i] is \\'L\\'\\n                    while(i>=0&&dominoes[i]!=\\'L\\')\\n                    {\\n                        dominoes[i]=\\'L\\';i--;\\n                    }\\n                }\\n                else \\n                { \\n                    for(int i=r,j=l;i<j;i++,j--)//case 3\\n                    {\\n                        dominoes[i]=\\'R\\';\\n                        dominoes[j]=\\'L\\';\\n                    }\\n                }\\n                s.push(\\'L\\');\\n                i=l;\\n            }\\n            else if(dominoes[i]==\\'R\\')\\n            { \\n                if(!s.empty()&&s.top()==\\'R\\')\\n                    while(r<=i)\\n                    {\\n                        dominoes[r]=\\'R\\';\\n                        r++;\\n                    }\\n                r=i;\\n                s.push(\\'R\\');\\n            } \\n                \\n            \\n        }\\n        if(!s.empty()&&s.top()==\\'R\\')\\n            while(r<n)\\n                {  \\n                dominoes[r]=\\'R\\';\\n                    r++;\\n                }\\n        \\n        return dominoes;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004197,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        s = \"L\" + dominoes + \"R\"\\n\\n        p, q = 0, 1\\n        res = \"\"\\n        \\n        while q < len(s):\\n            if s[q] != \".\":\\n                if s[p] == s[q]:\\n                    res += s[p] * (q - p )\\n                    \\n                elif s[p] == \\'R\\' and s[q] == \\'L\\':\\n                    m = (p + q) // 2\\n                    if (p + q) % 2 == 0: \\n                        res += s[p] * (m - p)  + \\'.\\' +  s[q] * ( q - m - 1)\\n                    else:\\n                        res += s[p] * (m - p + 1) + s[q] * (q - m - 1)\\n                else:\\n                    res += s[p] + \\'.\\' * (q - p - 1)\\n                \\n                p = q \\n                \\n            q += 1\\n        \\n        return res[1:]\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        s = \"L\" + dominoes + \"R\"\\n\\n        p, q = 0, 1\\n        res = \"\"\\n        \\n        while q < len(s):\\n            if s[q] != \".\":\\n                if s[p] == s[q]:\\n                    res += s[p] * (q - p )\\n                    \\n                elif s[p] == \\'R\\' and s[q] == \\'L\\':\\n                    m = (p + q) // 2\\n                    if (p + q) % 2 == 0: \\n                        res += s[p] * (m - p)  + \\'.\\' +  s[q] * ( q - m - 1)\\n                    else:\\n                        res += s[p] * (m - p + 1) + s[q] * (q - m - 1)\\n                else:\\n                    res += s[p] + \\'.\\' * (q - p - 1)\\n                \\n                p = q \\n                \\n            q += 1\\n        \\n        return res[1:]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 993392,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left(n, INT_MAX), right(n, INT_MAX);\\n        \\n        for (int i = 0, r = -1, l = -1; i < n; ++i) {\\n            // Right fall\\n            if (dominoes[i] == \\'R\\') r = i;\\n            if (dominoes[i] == \\'L\\') r = -1;\\n            if (dominoes[i] == \\'.\\' && r != -1) right[i] = i - r;\\n            \\n            // Left fall\\n            if (dominoes[n-i-1] == \\'L\\') l = n-i-1;\\n            if (dominoes[n-i-1] == \\'R\\') l = -1;\\n            if (dominoes[n-i-1] == \\'.\\' && l != -1) left[n-i-1] = l-n+i+1;\\n        }\\n        \\n        for (int i = 0; i < n; ++i)\\n            if (left[i] != right[i] && dominoes[i] == \\'.\\')\\n                dominoes[i] = left[i] < right[i] ? \\'L\\' : \\'R\\';\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left(n, INT_MAX), right(n, INT_MAX);\\n        \\n        for (int i = 0, r = -1, l = -1; i < n; ++i) {\\n            // Right fall\\n            if (dominoes[i] == \\'R\\') r = i;\\n            if (dominoes[i] == \\'L\\') r = -1;\\n            if (dominoes[i] == \\'.\\' && r != -1) right[i] = i - r;\\n            \\n            // Left fall\\n            if (dominoes[n-i-1] == \\'L\\') l = n-i-1;\\n            if (dominoes[n-i-1] == \\'R\\') l = -1;\\n            if (dominoes[n-i-1] == \\'.\\' && l != -1) left[n-i-1] = l-n+i+1;\\n        }\\n        \\n        for (int i = 0; i < n; ++i)\\n            if (left[i] != right[i] && dominoes[i] == \\'.\\')\\n                dominoes[i] = left[i] < right[i] ? \\'L\\' : \\'R\\';\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833768,
                "title": "c-two-passes-o-n",
                "content": "```\\nclass Solution {\\npublic:\\nstring pushDominoes(string dominoes) \\n    {\\n        vector<int> nums(dominoes.size());\\n        for(int i = 1; i < dominoes.size(); i++) \\n        {\\n            if(dominoes[i] == \\'.\\' && dominoes[i - 1] == \\'R\\')\\n            {\\n                nums[i] = nums[i - 1] + 1;\\n                dominoes[i] = \\'R\\';\\n            }\\n        }\\n\\n        for(int i  = dominoes.size() - 2; i >= 0; i--)\\n        {\\n            if(dominoes[i + 1] == \\'L\\')\\n            {\\n                if(dominoes[i] != \\'R\\')\\n                    dominoes[i] = \\'L\\';\\n                else\\n                {\\n                    int cnt = 1;\\n                    while(cnt < nums[i])\\n                    {\\n                        cnt++;\\n                        dominoes[i] = \\'L\\';\\n                        i--;\\n                    }\\n\\n                    if(nums[i] == cnt)\\n                        dominoes[i] = \\'.\\';\\n\\n                    while(nums[i]) i--;\\n                }\\n            }\\n            \\n        }\\n\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nstring pushDominoes(string dominoes) \\n    {\\n        vector<int> nums(dominoes.size());\\n        for(int i = 1; i < dominoes.size(); i++) \\n        {\\n            if(dominoes[i] == \\'.\\' && dominoes[i - 1] == \\'R\\')\\n            {\\n                nums[i] = nums[i - 1] + 1;\\n                dominoes[i] = \\'R\\';\\n            }\\n        }\\n\\n        for(int i  = dominoes.size() - 2; i >= 0; i--)\\n        {\\n            if(dominoes[i + 1] == \\'L\\')\\n            {\\n                if(dominoes[i] != \\'R\\')\\n                    dominoes[i] = \\'L\\';\\n                else\\n                {\\n                    int cnt = 1;\\n                    while(cnt < nums[i])\\n                    {\\n                        cnt++;\\n                        dominoes[i] = \\'L\\';\\n                        i--;\\n                    }\\n\\n                    if(nums[i] == cnt)\\n                        dominoes[i] = \\'.\\';\\n\\n                    while(nums[i]) i--;\\n                }\\n            }\\n            \\n        }\\n\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473226,
                "title": "go-o-n-4ms100",
                "content": "```go\\nfunc pushDominoes(dominoes string) string {\\n\\tdominoesInByteSlice := []byte(dominoes)\\n\\tlastIsRight := false\\n\\tlastIndex := 0\\n\\tfor i := 0; i < len(dominoesInByteSlice); i++ {\\n\\t\\tswitch dominoesInByteSlice[i] {\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tif lastIsRight {\\n\\t\\t\\t\\tcount := (i - lastIndex + 1) / 2 - 1\\n\\t\\t\\t\\tfor m := lastIndex+1; m < lastIndex+1+count; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor m := i-1; m > i-1-count; m-- {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'L\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor m := lastIndex; m < i; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'L\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIsRight = false\\n\\t\\t\\tlastIndex = i+1\\n\\t\\tcase \\'R\\':\\n\\t\\t\\tif lastIsRight {\\n\\t\\t\\t\\tfor m := lastIndex; m < i; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIsRight = true\\n\\t\\t\\tlastIndex = i\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif lastIsRight {\\n\\t\\tfor m := lastIndex; m < len(dominoesInByteSlice); m++ {\\n\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn string(dominoesInByteSlice)\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc pushDominoes(dominoes string) string {\\n\\tdominoesInByteSlice := []byte(dominoes)\\n\\tlastIsRight := false\\n\\tlastIndex := 0\\n\\tfor i := 0; i < len(dominoesInByteSlice); i++ {\\n\\t\\tswitch dominoesInByteSlice[i] {\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tif lastIsRight {\\n\\t\\t\\t\\tcount := (i - lastIndex + 1) / 2 - 1\\n\\t\\t\\t\\tfor m := lastIndex+1; m < lastIndex+1+count; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor m := i-1; m > i-1-count; m-- {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'L\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor m := lastIndex; m < i; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'L\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIsRight = false\\n\\t\\t\\tlastIndex = i+1\\n\\t\\tcase \\'R\\':\\n\\t\\t\\tif lastIsRight {\\n\\t\\t\\t\\tfor m := lastIndex; m < i; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIsRight = true\\n\\t\\t\\tlastIndex = i\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif lastIsRight {\\n\\t\\tfor m := lastIndex; m < len(dominoesInByteSlice); m++ {\\n\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn string(dominoesInByteSlice)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132932,
                "title": "c-2-pass-scan-o-2n-13ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        const int n = dominoes.size();\\n        vector<int> vt(n);\\n        for(int i = 1; i < n; ++i){\\n            if(dominoes[i-1] == \\'R\\' && dominoes[i] == \\'.\\'){\\n                dominoes[i] = \\'R\\';\\n                vt[i] = vt[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i = n-2, nt; i >= 0; --i){\\n            if(dominoes[i+1] == \\'L\\'){\\n                nt = vt[i+1] + 1;\\n                if(dominoes[i] == \\'.\\' || vt[i] > nt){\\n                    dominoes[i] = \\'L\\';\\n                    vt[i] = nt;\\n                }\\n                else if(dominoes[i] == \\'R\\' && vt[i] == nt){ // recover\\n                    dominoes[i] = \\'.\\';\\n                }\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n\\nint iobooster = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        const int n = dominoes.size();\\n        vector<int> vt(n);\\n        for(int i = 1; i < n; ++i){\\n            if(dominoes[i-1] == \\'R\\' && dominoes[i] == \\'.\\'){\\n                dominoes[i] = \\'R\\';\\n                vt[i] = vt[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i = n-2, nt; i >= 0; --i){\\n            if(dominoes[i+1] == \\'L\\'){\\n                nt = vt[i+1] + 1;\\n                if(dominoes[i] == \\'.\\' || vt[i] > nt){\\n                    dominoes[i] = \\'L\\';\\n                    vt[i] = nt;\\n                }\\n                else if(dominoes[i] == \\'R\\' && vt[i] == nt){ // recover\\n                    dominoes[i] = \\'.\\';\\n                }\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n\\nint iobooster = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132499,
                "title": "c-4-lines-o-n-n-simulation",
                "content": "We simulate falling dominos turn-by-turn. We need a copy of the string (```s```) to make modifications so all dominos are pushed \"simultaneously\". At the end of each turn, we return the result if there are no more changes (```s == ds```).\\n\\nEach turn we run through all dominos. The ```if``` statement checks if the previous (```i - 1``` for L) or next (```i + 1``` for R) domino can be pushed: it\\'s standing and there is no domino before/after it pushing in the opposite direction.\\n```\\nstring pushDominoes(string ds) {\\n  for (string s = ds; ; s = ds) {\\n    for (auto i = 0, d = s[i] == \\'L\\' ? -1 : 1; i < s.size(); d = s[++i] == \\'L\\' ? -1 : 1)\\n      if (s[i] != \\'.\\' && i + d >= 0 && i + d < s.size() && s[i + d] == \\'.\\' &&\\n        (i + d * 2 < 0 || i + d * 2 >= s.size() || s[i + d * 2] != (s[i] == \\'L\\' ? \\'R\\' : \\'L\\'))) ds[i + d] = s[i];\\n    if (s == ds) return s;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```s```\n```s == ds```\n```if```\n```i - 1```\n```i + 1```\n```\\nstring pushDominoes(string ds) {\\n  for (string s = ds; ; s = ds) {\\n    for (auto i = 0, d = s[i] == \\'L\\' ? -1 : 1; i < s.size(); d = s[++i] == \\'L\\' ? -1 : 1)\\n      if (s[i] != \\'.\\' && i + d >= 0 && i + d < s.size() && s[i + d] == \\'.\\' &&\\n        (i + d * 2 < 0 || i + d * 2 >= s.size() || s[i + d * 2] != (s[i] == \\'L\\' ? \\'R\\' : \\'L\\'))) ds[i + d] = s[i];\\n    if (s == ds) return s;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132371,
                "title": "python-3-passes-simple-solution-using-dictionaries-228-ms",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes):\\n        res, l, r , pre_l, pre_r = \"\", {}, {}, None, None,\\n        for i, s in enumerate(dominoes):\\n            if s == \".\" and pre_r != None: r[i] = i - pre_r\\n            elif s == \"R\": pre_r = i\\n            elif s == \"L\": pre_r = None\\n        for i in range(len(dominoes) - 1, -1, -1):\\n            if dominoes[i] == \".\" and pre_l != None: l[i] = pre_l - i\\n            elif dominoes[i] == \"L\": pre_l = i\\n            elif dominoes[i] == \"R\": pre_l = None\\n        for i, s in enumerate(dominoes):\\n            if s == \"L\" or s == \"R\": res += s\\n            elif i in l and i in r:\\n                if l[i] < r[i]: res += \"L\"\\n                elif r[i] < l[i]: res += \"R\"\\n                else: res += s\\n            elif i in l: res += \"L\"\\n            elif i in r: res += \"R\"\\n            else: res += s\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes):\\n        res, l, r , pre_l, pre_r = \"\", {}, {}, None, None,\\n        for i, s in enumerate(dominoes):\\n            if s == \".\" and pre_r != None: r[i] = i - pre_r\\n            elif s == \"R\": pre_r = i\\n            elif s == \"L\": pre_r = None\\n        for i in range(len(dominoes) - 1, -1, -1):\\n            if dominoes[i] == \".\" and pre_l != None: l[i] = pre_l - i\\n            elif dominoes[i] == \"L\": pre_l = i\\n            elif dominoes[i] == \"R\": pre_l = None\\n        for i, s in enumerate(dominoes):\\n            if s == \"L\" or s == \"R\": res += s\\n            elif i in l and i in r:\\n                if l[i] < r[i]: res += \"L\"\\n                elif r[i] < l[i]: res += \"R\"\\n                else: res += s\\n            elif i in l: res += \"L\"\\n            elif i in r: res += \"R\"\\n            else: res += s\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820586,
                "title": "brute-force-with-storing-critical-points-with-indexes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n         int n  = dominoes.size();\\n         vector<pair<char,int>> v;\\n            for(int i=0;i<n;i++){\\n                    if(dominoes[i] == \\'R\\') v.push_back({\\'R\\',i});\\n                    else if(dominoes[i] == \\'L\\') v.push_back({\\'L\\',i});\\n            }\\n           if(v.size() == 0) return dominoes;\\n             if(v[0].first == \\'L\\'){\\n                     for(int j = 0;j<=v[0].second;j++) dominoes[j] = \\'L\\';\\n                 }\\n            for(int i=0;i<v.size()-1;i++){\\n                 if(v[i].first == \\'R\\' && v[i+1].first == \\'L\\'){\\n                        int k = v[i+1].second - v[i].second-1;\\n                        for(int j=0;j<k/2;j++){\\n                            dominoes[v[i].second + j + 1] = \\'R\\';\\n                        } \\n                        for(int j = k/2+1;j<=k;j++){\\n                            dominoes[v[i].second + j] = \\'L\\';\\n                        }\\n                       \\n                        if(k%2!=0) dominoes[v[i].second + (k+1)/2] = \\'.\\';\\n                 }\\n                 if(v[i].first == \\'R\\' && v[i+1].first == \\'R\\'){\\n                     for(int j=v[i].second;j<=v[i+1].second;j++) dominoes[j] = \\'R\\';\\n                 }\\n                 if(v[i].first == \\'L\\' && v[i+1].first == \\'L\\'){\\n                     for(int j=v[i].second;j<=v[i+1].second;j++) dominoes[j] = \\'L\\';\\n                 }\\n                 \\n            }\\n            if(v[v.size() - 1].first == \\'R\\'){\\n                for(int j=v[v.size()-1].second;j<n;j++) dominoes[j] = \\'R\\';\\n            }\\n            return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n         int n  = dominoes.size();\\n         vector<pair<char,int>> v;\\n            for(int i=0;i<n;i++){\\n                    if(dominoes[i] == \\'R\\') v.push_back({\\'R\\',i});\\n                    else if(dominoes[i] == \\'L\\') v.push_back({\\'L\\',i});\\n            }\\n           if(v.size() == 0) return dominoes;\\n             if(v[0].first == \\'L\\'){\\n                     for(int j = 0;j<=v[0].second;j++) dominoes[j] = \\'L\\';\\n                 }\\n            for(int i=0;i<v.size()-1;i++){\\n                 if(v[i].first == \\'R\\' && v[i+1].first == \\'L\\'){\\n                        int k = v[i+1].second - v[i].second-1;\\n                        for(int j=0;j<k/2;j++){\\n                            dominoes[v[i].second + j + 1] = \\'R\\';\\n                        } \\n                        for(int j = k/2+1;j<=k;j++){\\n                            dominoes[v[i].second + j] = \\'L\\';\\n                        }\\n                       \\n                        if(k%2!=0) dominoes[v[i].second + (k+1)/2] = \\'.\\';\\n                 }\\n                 if(v[i].first == \\'R\\' && v[i+1].first == \\'R\\'){\\n                     for(int j=v[i].second;j<=v[i+1].second;j++) dominoes[j] = \\'R\\';\\n                 }\\n                 if(v[i].first == \\'L\\' && v[i+1].first == \\'L\\'){\\n                     for(int j=v[i].second;j<=v[i+1].second;j++) dominoes[j] = \\'L\\';\\n                 }\\n                 \\n            }\\n            if(v[v.size() - 1].first == \\'R\\'){\\n                for(int j=v[v.size()-1].second;j<n;j++) dominoes[j] = \\'R\\';\\n            }\\n            return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489355,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        string ans=s;\\n        int n=ans.size(),r=-1;\\n        for(int i=0; i<n; i++) {\\n            if(s[i]==\\'L\\' && r==-1) {\\n                for(int l=i-1; l>=0 && s[l]==\\'.\\'; l--) {\\n                    ans[l]=\\'L\\';\\n                }\\n            }\\n            else if(s[i]==\\'R\\') {\\n                while(r!=-1 && r<i)\\n                    ans[r++]=\\'R\\';\\n                r=i;\\n            }\\n            else if(s[i]==\\'L\\') {\\n                int l=i;\\n                while(r<l) {\\n                    ans[r++]=\\'R\\';\\n                    ans[l--]=\\'L\\';\\n                }\\n                r=-1;\\n            }\\n        }\\n        while(r!=-1 && r<n)\\n            ans[r++]=\\'R\\';\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        arr = list(dominoes)\\n        n = len(arr)\\n        l = r = -1\\n        for i, c in enumerate(arr):\\n            if c is \\'.\\':\\n                continue\\n            if c is \\'L\\':\\n                if l >= r:\\n                    while l < i:\\n                        l += 1\\n                        arr[l] = \\'L\\'\\n                else:\\n                    l = i\\n                    lo, hi = r + 1, l - 1\\n                    while lo < hi:\\n                        arr[lo] = \\'R\\'\\n                        arr[hi] = \\'L\\'\\n                        lo += 1\\n                        hi -= 1\\n            else:\\n                if r > l:\\n                    while r < i:\\n                        arr[r] = \\'R\\'\\n                        r += 1\\n                else:\\n                    r = i\\n        if r > l:\\n            while r < n:\\n                arr[r] = \\'R\\'\\n                r += 1\\n        \\n        return \\'\\'.join(arr)\\n```\\n\\n```Java []\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] dos = dominoes.toCharArray();\\n        int left = \\'L\\';\\n        int i = 0;\\n        while(i<dos.length){\\n            if(dos[i] == \\'.\\'){\\n                int j = i;\\n                while(j<dos.length && dos[j] == \\'.\\'){\\n                    j++;\\n                }\\n                int right = j>=dos.length? \\'R\\': dos[j];\\n                if(right == left){\\n                    while(i < j){\\n                        dos[i++] = (char)right;\\n                    }\\n                }else if(right == \\'R\\'){\\n                    i = j-1;\\n                }else{\\n                    j--;\\n                    while(i < j){\\n                        dos[i++] = (char)left;\\n                        dos[j--] = (char)right;\\n                    }\\n                }\\n                left = right;\\n            }else{\\n                left = dos[i];\\n            }\\n            i++;\\n        }\\n        return new String(dos);\\n    }\\n    public String pushDominoes1(String dominoes) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] dos = dominoes.toCharArray();\\n        Stack<Character> stack = new Stack<>();\\n        int lastRight = -1;\\n        int lastLeft = -1;\\n\\n        for(int i = 0; i<dos.length;){\\n            if(dos[i] == \\'R\\'){\\n                while(i<dos.length && dos[i] != \\'L\\'){\\n                    stack.push(\\'R\\');\\n                    if(dos[i] == \\'R\\'){\\n                        lastRight = i;\\n                    }\\n                    i++;\\n                }\\n            }else if(dos[i] == \\'L\\'){\\n                int numOfPop = 0;\\n                if(lastLeft == -1 && lastRight == -1){\\n                    numOfPop = i;\\n                }else{\\n                    numOfPop = lastLeft > lastRight? (i- lastLeft):(i-lastRight)/2;\\n                }\\n                int count = numOfPop;\\n                while(count > 0){\\n                    stack.pop();\\n                    count--;\\n                }\\n                if(lastRight != -1 && lastRight > lastLeft && (i-lastRight)%2 == 0 && numOfPop >= 1) {\\n                    stack.push(\\'.\\');\\n                    numOfPop--;\\n                }\\n                while(count < numOfPop){\\n                    stack.push(\\'L\\');\\n                    count++;\\n                }\\n                stack.push(\\'L\\');\\n                lastLeft = i;\\n                i++;\\n            }else{\\n                stack.push(dos[i]);\\n                i++;\\n            }\\n        }\\n        while(!stack.isEmpty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        string ans=s;\\n        int n=ans.size(),r=-1;\\n        for(int i=0; i<n; i++) {\\n            if(s[i]==\\'L\\' && r==-1) {\\n                for(int l=i-1; l>=0 && s[l]==\\'.\\'; l--) {\\n                    ans[l]=\\'L\\';\\n                }\\n            }\\n            else if(s[i]==\\'R\\') {\\n                while(r!=-1 && r<i)\\n                    ans[r++]=\\'R\\';\\n                r=i;\\n            }\\n            else if(s[i]==\\'L\\') {\\n                int l=i;\\n                while(r<l) {\\n                    ans[r++]=\\'R\\';\\n                    ans[l--]=\\'L\\';\\n                }\\n                r=-1;\\n            }\\n        }\\n        while(r!=-1 && r<n)\\n            ans[r++]=\\'R\\';\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        arr = list(dominoes)\\n        n = len(arr)\\n        l = r = -1\\n        for i, c in enumerate(arr):\\n            if c is \\'.\\':\\n                continue\\n            if c is \\'L\\':\\n                if l >= r:\\n                    while l < i:\\n                        l += 1\\n                        arr[l] = \\'L\\'\\n                else:\\n                    l = i\\n                    lo, hi = r + 1, l - 1\\n                    while lo < hi:\\n                        arr[lo] = \\'R\\'\\n                        arr[hi] = \\'L\\'\\n                        lo += 1\\n                        hi -= 1\\n            else:\\n                if r > l:\\n                    while r < i:\\n                        arr[r] = \\'R\\'\\n                        r += 1\\n                else:\\n                    r = i\\n        if r > l:\\n            while r < n:\\n                arr[r] = \\'R\\'\\n                r += 1\\n        \\n        return \\'\\'.join(arr)\\n```\n```Java []\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] dos = dominoes.toCharArray();\\n        int left = \\'L\\';\\n        int i = 0;\\n        while(i<dos.length){\\n            if(dos[i] == \\'.\\'){\\n                int j = i;\\n                while(j<dos.length && dos[j] == \\'.\\'){\\n                    j++;\\n                }\\n                int right = j>=dos.length? \\'R\\': dos[j];\\n                if(right == left){\\n                    while(i < j){\\n                        dos[i++] = (char)right;\\n                    }\\n                }else if(right == \\'R\\'){\\n                    i = j-1;\\n                }else{\\n                    j--;\\n                    while(i < j){\\n                        dos[i++] = (char)left;\\n                        dos[j--] = (char)right;\\n                    }\\n                }\\n                left = right;\\n            }else{\\n                left = dos[i];\\n            }\\n            i++;\\n        }\\n        return new String(dos);\\n    }\\n    public String pushDominoes1(String dominoes) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] dos = dominoes.toCharArray();\\n        Stack<Character> stack = new Stack<>();\\n        int lastRight = -1;\\n        int lastLeft = -1;\\n\\n        for(int i = 0; i<dos.length;){\\n            if(dos[i] == \\'R\\'){\\n                while(i<dos.length && dos[i] != \\'L\\'){\\n                    stack.push(\\'R\\');\\n                    if(dos[i] == \\'R\\'){\\n                        lastRight = i;\\n                    }\\n                    i++;\\n                }\\n            }else if(dos[i] == \\'L\\'){\\n                int numOfPop = 0;\\n                if(lastLeft == -1 && lastRight == -1){\\n                    numOfPop = i;\\n                }else{\\n                    numOfPop = lastLeft > lastRight? (i- lastLeft):(i-lastRight)/2;\\n                }\\n                int count = numOfPop;\\n                while(count > 0){\\n                    stack.pop();\\n                    count--;\\n                }\\n                if(lastRight != -1 && lastRight > lastLeft && (i-lastRight)%2 == 0 && numOfPop >= 1) {\\n                    stack.push(\\'.\\');\\n                    numOfPop--;\\n                }\\n                while(count < numOfPop){\\n                    stack.push(\\'L\\');\\n                    count++;\\n                }\\n                stack.push(\\'L\\');\\n                lastLeft = i;\\n                i++;\\n            }else{\\n                stack.push(dos[i]);\\n                i++;\\n            }\\n        }\\n        while(!stack.isEmpty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184854,
                "title": "java-o-n-time",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private void replace(char[] d, char c, int a, int b){\\n        while(a < b){\\n            d[a++] = c;\\n        }\\n    }\\n    public String pushDominoes(String dominoes) {\\n        char[] d = dominoes.toCharArray();\\n        int prev = -1;\\n        for(int a = 0; a < d.length; a++){\\n            if(d[a] == \\'L\\'){\\n                if(prev == -1 || d[prev] == \\'L\\'){\\n                    replace(d, \\'L\\', prev + 1, a);\\n                }else{\\n                    int diff = a - prev;\\n                    int mid = prev + diff / 2;\\n                    replace(d, \\'R\\', prev + 1, mid + (diff % 2 == 1 ? 1 : 0));\\n                    replace(d, \\'L\\', mid + 1, a);\\n                }\\n                prev = a;\\n            }else if(d[a] == \\'R\\'){\\n                if(prev != -1 && d[prev] == \\'R\\'){\\n                   replace(d, \\'R\\', prev, a);\\n                }\\n                prev = a;\\n            }\\n        }\\n        if(prev != -1 && d[prev] == \\'R\\') replace(d, \\'R\\', prev + 1, d.length);\\n        return String.valueOf(d);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    private void replace(char[] d, char c, int a, int b){\\n        while(a < b){\\n            d[a++] = c;\\n        }\\n    }\\n    public String pushDominoes(String dominoes) {\\n        char[] d = dominoes.toCharArray();\\n        int prev = -1;\\n        for(int a = 0; a < d.length; a++){\\n            if(d[a] == \\'L\\'){\\n                if(prev == -1 || d[prev] == \\'L\\'){\\n                    replace(d, \\'L\\', prev + 1, a);\\n                }else{\\n                    int diff = a - prev;\\n                    int mid = prev + diff / 2;\\n                    replace(d, \\'R\\', prev + 1, mid + (diff % 2 == 1 ? 1 : 0));\\n                    replace(d, \\'L\\', mid + 1, a);\\n                }\\n                prev = a;\\n            }else if(d[a] == \\'R\\'){\\n                if(prev != -1 && d[prev] == \\'R\\'){\\n                   replace(d, \\'R\\', prev, a);\\n                }\\n                prev = a;\\n            }\\n        }\\n        if(prev != -1 && d[prev] == \\'R\\') replace(d, \\'R\\', prev + 1, d.length);\\n        return String.valueOf(d);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973911,
                "title": "my-2-pointers-java-code",
                "content": "The code surely looks big but if you do a dry run on the example test case 2, you\\'ll realize that the logic is actually quite simple and easy to understand\\n\\n```\\nclass Solution {\\n    public String pushDominoes(String s) {\\n        int n = s.length(), start=0, end=0;\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        while(end<n && s.charAt(end) == \\'.\\') end++;\\n        \\n\\t\\t/// to take care of inputs starting with \\'.\\', like \"...LRRL.LLRRL\"\\n        if(end<n && s.charAt(start)==\\'.\\'){\\n            if(s.charAt(end) == \\'L\\'){\\n                for(int i=start; i<end; i++) sb.setCharAt(i, \\'L\\');\\n            }\\n            start = end;\\n        }\\n        \\n        while(end<n){\\n            if(s.charAt(end)==\\'.\\'){\\n                end++;\\n                continue;\\n            }\\n            \\n            else if(s.charAt(start) == \\'L\\' && s.charAt(end) == \\'R\\') start = end;\\n            \\n            else if(s.charAt(start) == \\'R\\' && s.charAt(end) == \\'L\\'){\\n                int len = (end-start-1);\\n                int size = len;\\n                size /= 2;\\n                \\n                for(int i=start; i<=(start+size); i++){\\n                    sb.setCharAt(i, \\'R\\');\\n                }\\n                if(len % 2 == 0) for(int i=(start+size+1); i<end; i++) sb.setCharAt(i, \\'L\\'); /// \"R..L\" -> \"RRLL\"\\n                else for(int i=(start+size+2); i<end; i++) sb.setCharAt(i, \\'L\\'); /// \"R...L\" -> \"RR.LL\",\\n                \\n                start = end;\\n            }\\n            \\n            else if(s.charAt(start) == s.charAt(end)){\\n                for(int i=start+1; i<end; i++) sb.setCharAt(i, sb.charAt(start));\\n                start = end;\\n            }\\n            \\n            end++;\\n        }\\n        \\n\\t\\t/// to take care of inputs ending with \\'.\\', like \"LRRL..RR..R...\"\\n        if(end == n && s.charAt(end-1)==\\'.\\'){\\n            if(s.charAt(start) == \\'R\\'){\\n                for(int i=start+1; i<end; i++) sb.setCharAt(i, \\'R\\');\\n                start = end;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String pushDominoes(String s) {\\n        int n = s.length(), start=0, end=0;\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        while(end<n && s.charAt(end) == \\'.\\') end++;\\n        \\n\\t\\t/// to take care of inputs starting with \\'.\\', like \"...LRRL.LLRRL\"\\n        if(end<n && s.charAt(start)==\\'.\\'){\\n            if(s.charAt(end) == \\'L\\'){\\n                for(int i=start; i<end; i++) sb.setCharAt(i, \\'L\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2930080,
                "title": "swift-fast-solution-o-n-o-1",
                "content": "# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\n    func pushDominoes(_ dominoes: String) -> String {\\n        var dominoes = Array(dominoes)\\n        var L = 0\\n        var R = 0\\n        \\n        for i in 0..<dominoes.count where dominoes[i] == \".\" {\\n            L = i - 1\\n            R = i + 1\\n            \\n            while L >= 0 && dominoes[L] == \".\" {\\n                L -= 1\\n            }\\n            \\n            while R < dominoes.count && dominoes[R] == \".\" {\\n                R += 1\\n            }\\n            \\n            if L == -1 {\\n                L = 0\\n            }\\n            \\n            if R == dominoes.count {\\n                R = dominoes.count - 1\\n            }\\n            \\n            switch (dominoes[L], dominoes[R]) {\\n            case (\".\", \"L\"), (\"L\", \"L\"):\\n                while L < R {\\n                    dominoes[L] = \"L\"\\n                    L += 1\\n                }\\n            case (\"R\", \"R\"), (\"R\", \".\"):\\n                while L < R {\\n                    dominoes[R] = \"R\"\\n                    R -= 1\\n                }\\n            case (\"R\", \"L\"):\\n                while L < R {\\n                    dominoes[L] = \"R\"\\n                    L += 1\\n                    dominoes[R] = \"L\"\\n                    R -= 1\\n                }\\n            default:\\n                break\\n            }\\n        }\\n        return String(dominoes)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func pushDominoes(_ dominoes: String) -> String {\\n        var dominoes = Array(dominoes)\\n        var L = 0\\n        var R = 0\\n        \\n        for i in 0..<dominoes.count where dominoes[i] == \".\" {\\n            L = i - 1\\n            R = i + 1\\n            \\n            while L >= 0 && dominoes[L] == \".\" {\\n                L -= 1\\n            }\\n            \\n            while R < dominoes.count && dominoes[R] == \".\" {\\n                R += 1\\n            }\\n            \\n            if L == -1 {\\n                L = 0\\n            }\\n            \\n            if R == dominoes.count {\\n                R = dominoes.count - 1\\n            }\\n            \\n            switch (dominoes[L], dominoes[R]) {\\n            case (\".\", \"L\"), (\"L\", \"L\"):\\n                while L < R {\\n                    dominoes[L] = \"L\"\\n                    L += 1\\n                }\\n            case (\"R\", \"R\"), (\"R\", \".\"):\\n                while L < R {\\n                    dominoes[R] = \"R\"\\n                    R -= 1\\n                }\\n            case (\"R\", \"L\"):\\n                while L < R {\\n                    dominoes[L] = \"R\"\\n                    L += 1\\n                    dominoes[R] = \"L\"\\n                    R -= 1\\n                }\\n            default:\\n                break\\n            }\\n        }\\n        return String(dominoes)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707417,
                "title": "c-o-n-space-o-n-time-complexity",
                "content": "Just Kep track of where the nearest Left and Right domino was. If left was near then it will fall towards left. Similarly for right. If both are equally near then it will be balanced condition.\\n\\n\\n```\\n string pushDominoes(string dominoes) \\n    {\\n        int sl=dominoes.length();\\n        string ans=dominoes;\\n        int left[sl];\\n        int right[sl];\\n        int r=INT_MIN,l=INT_MIN;\\n        for(int i=0;i<sl;i++)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                right[i]=r;\\n                if(r!=INT_MIN){r--;}\\n            }\\n            else if(dominoes[i]==\\'R\\')\\n            {\\n                right[i]=1e5;\\n                r=1e5-1;\\n            }\\n            else\\n            {\\n                r=INT_MIN;\\n                right[i]=INT_MIN;\\n            }\\n        }\\n        for(int i=sl-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                left[i]=l;\\n                if(l!=INT_MIN){l--;}\\n            }\\n            else if(dominoes[i]==\\'L\\')\\n            {\\n                left[i]=1e5;\\n                l=1e5-1;\\n            }\\n            else\\n            {\\n                l=INT_MIN;\\n                left[i]=INT_MIN;\\n            }\\n        }\\n        for(int i=0;i<sl;i++)\\n        {\\n            if(left[i]>right[i]){ans[i]=\\'L\\';}\\n            else if(left[i]<right[i]){ans[i]=\\'R\\';}\\n            else{ans[i]=\\'.\\';}\\n        }\\n        return ans;  \\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "Just Kep track of where the nearest Left and Right domino was. If left was near then it will fall towards left. Similarly for right. If both are equally near then it will be balanced condition.\\n\\n\\n```\\n string pushDominoes(string dominoes) \\n    {\\n        int sl=dominoes.length();\\n        string ans=dominoes;\\n        int left[sl];\\n        int right[sl];\\n        int r=INT_MIN,l=INT_MIN;\\n        for(int i=0;i<sl;i++)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                right[i]=r;\\n                if(r!=INT_MIN){r--;}\\n            }\\n            else if(dominoes[i]==\\'R\\')\\n            {\\n                right[i]=1e5;\\n                r=1e5-1;\\n            }\\n            else\\n            {\\n                r=INT_MIN;\\n                right[i]=INT_MIN;\\n            }\\n        }\\n        for(int i=sl-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                left[i]=l;\\n                if(l!=INT_MIN){l--;}\\n            }\\n            else if(dominoes[i]==\\'L\\')\\n            {\\n                left[i]=1e5;\\n                l=1e5-1;\\n            }\\n            else\\n            {\\n                l=INT_MIN;\\n                left[i]=INT_MIN;\\n            }\\n        }\\n        for(int i=0;i<sl;i++)\\n        {\\n            if(left[i]>right[i]){ans[i]=\\'L\\';}\\n            else if(left[i]<right[i]){ans[i]=\\'R\\';}\\n            else{ans[i]=\\'.\\';}\\n        }\\n        return ans;  \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2633178,
                "title": "simple-do-as-said-brute-force-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        vector<pair<int, int>> vec;\\n        bool r = false;\\n        int l = -1;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            if(r==true && l!=-1 && dominoes[i]==\\'L\\')\\n            {\\n                vec.push_back({l, i});\\n                r = false;\\n                l=-1;\\n            }\\n            \\n            if(dominoes[i]==\\'R\\')\\n            {\\n                if(r==true && l!=-1)\\n                {\\n                    while(l<i)\\n                    {\\n                        dominoes[l]=\\'R\\';\\n                        l++;\\n                    }\\n                }\\n                r = true;\\n                l = i;\\n            }\\n        }\\n        \\n        bool rr= false;\\n        int ll = -1;\\n        for(int i=dominoes.size()-1;i>=0;i--)\\n        {\\n            if(rr==true && ll!=-1 && dominoes[i]==\\'R\\')\\n            {\\n                //vec.push_back({l, i});\\n                rr = false;\\n                ll = -1;\\n            }\\n            \\n            if(dominoes[i]==\\'L\\')\\n            {\\n                if(rr==true && ll!=-1)\\n                {\\n                    while(ll>i)\\n                    {\\n                        dominoes[ll]=\\'L\\';\\n                        ll--;\\n                    }\\n                }\\n                rr = true;\\n                ll = i;\\n            }\\n        }\\n        \\n        for(auto i:vec)\\n        {\\n            while(i.first<i.second)\\n            {\\n                dominoes[i.first]=\\'R\\';\\n                dominoes[i.second]=\\'L\\';\\n                i.first++;\\n                i.second--;\\n            }\\n        }\\n        \\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                break;\\n            }\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                int k=i;\\n                while(k>=0)\\n                {\\n                    dominoes[k]=\\'L\\';\\n                    k--;\\n                }\\n                break;\\n            }\\n        }\\n        \\n        for(int i=dominoes.size()-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                break;\\n            }\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                int k=i;\\n                while(k<dominoes.size())\\n                {\\n                    dominoes[k]=\\'R\\';\\n                    k++;\\n                }\\n                break;\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        vector<pair<int, int>> vec;\\n        bool r = false;\\n        int l = -1;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            if(r==true && l!=-1 && dominoes[i]==\\'L\\')\\n            {\\n                vec.push_back({l, i});\\n                r = false;\\n                l=-1;\\n            }\\n            \\n            if(dominoes[i]==\\'R\\')\\n            {\\n                if(r==true && l!=-1)\\n                {\\n                    while(l<i)\\n                    {\\n                        dominoes[l]=\\'R\\';\\n                        l++;\\n                    }\\n                }\\n                r = true;\\n                l = i;\\n            }\\n        }\\n        \\n        bool rr= false;\\n        int ll = -1;\\n        for(int i=dominoes.size()-1;i>=0;i--)\\n        {\\n            if(rr==true && ll!=-1 && dominoes[i]==\\'R\\')\\n            {\\n                //vec.push_back({l, i});\\n                rr = false;\\n                ll = -1;\\n            }\\n            \\n            if(dominoes[i]==\\'L\\')\\n            {\\n                if(rr==true && ll!=-1)\\n                {\\n                    while(ll>i)\\n                    {\\n                        dominoes[ll]=\\'L\\';\\n                        ll--;\\n                    }\\n                }\\n                rr = true;\\n                ll = i;\\n            }\\n        }\\n        \\n        for(auto i:vec)\\n        {\\n            while(i.first<i.second)\\n            {\\n                dominoes[i.first]=\\'R\\';\\n                dominoes[i.second]=\\'L\\';\\n                i.first++;\\n                i.second--;\\n            }\\n        }\\n        \\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                break;\\n            }\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                int k=i;\\n                while(k>=0)\\n                {\\n                    dominoes[k]=\\'L\\';\\n                    k--;\\n                }\\n                break;\\n            }\\n        }\\n        \\n        for(int i=dominoes.size()-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                break;\\n            }\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                int k=i;\\n                while(k<dominoes.size())\\n                {\\n                    dominoes[k]=\\'R\\';\\n                    k++;\\n                }\\n                break;\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632491,
                "title": "time-based-simulation-queue",
                "content": "```\\nclass Solution {\\n\\t//just for debugging\\n    void  print(unordered_map<int,char> &mp) {\\n        if (mp.size() < 1) {\\n            return;\\n        }\\n        cout<<\"\\\\n\";\\n        unordered_map<int, char>:: iterator it;\\n        for(it = mp.begin(); it != mp.end(); it++) {\\n            cout<<\"[\"<<it->first<<\" \"<<it->second<<\"],\";\\n        }\\n        \\n    }\\npublic:\\n    \\n    string pushDominoes(string dominoes) {\\n        queue<int> q;\\n        for(int i = 0; i < dominoes.size(); i++) {\\n            if (dominoes[i] == \\'R\\' || dominoes[i] == \\'L\\') {\\n                q.push(i);\\n            }\\n        }\\n        /*\\n\\t\\t* every iteration of while loop is one second simulated. In that one second we will exert force on neighbour dominoe\\n\\t\\t* A Map is used to track what force is exerted on a specific neigbour\\n\\t\\t* if in that particular second we have opposing force acting on the neigbour then object would remain stand still \\n\\t\\t*/\\n\\t\\twhile (q.size() > 0) {\\n            int curSize = q.size();\\n            unordered_map<int, char> mp;    \\n            unordered_map<int, char>:: iterator it;   //int represent index of neigbour and char represent force acting on it in next second\\n            \\n            for (int i = 0; i < curSize; i++) {\\n                int pos = q.front(); q.pop();\\n               \\n      \\n                if (dominoes[pos] == \\'R\\' && (pos < dominoes.size() - 1) && dominoes[pos+1] == \\'.\\') {\\n                    it = mp.find(pos + 1);\\n\\t\\t\\t\\t\\t// here we evalute if there is already a force acting on the neigbour. If opposing force is present we remove it from the map\\n                    if (it != mp.end() && it->second ==\\'L\\') {\\n                        mp.erase(it);\\n                    } else {\\n                        mp[pos+1] = \\'R\\';\\n                    }\\n                    \\n                }\\n                if (dominoes[pos] == \\'L\\' && pos > 0 && dominoes[pos - 1] == \\'.\\') {\\n                    it = mp.find(pos - 1);\\n\\t\\t\\t\\t\\t// here we evalute if there is already a force acting on the neigbour. If opposing force is present we remove it from the map\\n                    if (it != mp.end() && it->second ==\\'R\\') {\\n                        mp.erase(it);\\n                    } else {\\n                        mp[pos-1] = \\'L\\';\\n                    }\\n                }\\n            }\\n            //print(mp);\\n\\t\\t\\t// This step we will setup for simulating the next second;\\n            for (it = mp.begin(); it != mp.end(); it++) {\\n                    dominoes[it->first] = it->second;\\n                    q.push(it->first);\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n\\t//just for debugging\\n    void  print(unordered_map<int,char> &mp) {\\n        if (mp.size() < 1) {\\n            return;\\n        }\\n        cout<<\"\\\\n\";\\n        unordered_map<int, char>:: iterator it;\\n        for(it = mp.begin(); it != mp.end(); it++) {\\n            cout<<\"[\"<<it->first<<\" \"<<it->second<<\"],\";\\n        }\\n        \\n    }\\npublic:\\n    \\n    string pushDominoes(string dominoes) {\\n        queue<int> q;\\n        for(int i = 0; i < dominoes.size(); i++) {\\n            if (dominoes[i] == \\'R\\' || dominoes[i] == \\'L\\') {\\n                q.push(i);\\n            }\\n        }\\n        /*\\n\\t\\t* every iteration of while loop is one second simulated. In that one second we will exert force on neighbour dominoe\\n\\t\\t* A Map is used to track what force is exerted on a specific neigbour\\n\\t\\t* if in that particular second we have opposing force acting on the neigbour then object would remain stand still \\n\\t\\t*/\\n\\t\\twhile (q.size() > 0) {\\n            int curSize = q.size();\\n            unordered_map<int, char> mp;    \\n            unordered_map<int, char>:: iterator it;   //int represent index of neigbour and char represent force acting on it in next second\\n            \\n            for (int i = 0; i < curSize; i++) {\\n                int pos = q.front(); q.pop();\\n               \\n      \\n                if (dominoes[pos] == \\'R\\' && (pos < dominoes.size() - 1) && dominoes[pos+1] == \\'.\\') {\\n                    it = mp.find(pos + 1);\\n\\t\\t\\t\\t\\t// here we evalute if there is already a force acting on the neigbour. If opposing force is present we remove it from the map\\n                    if (it != mp.end() && it->second ==\\'L\\') {\\n                        mp.erase(it);\\n                    } else {\\n                        mp[pos+1] = \\'R\\';\\n                    }\\n                    \\n                }\\n                if (dominoes[pos] == \\'L\\' && pos > 0 && dominoes[pos - 1] == \\'.\\') {\\n                    it = mp.find(pos - 1);\\n\\t\\t\\t\\t\\t// here we evalute if there is already a force acting on the neigbour. If opposing force is present we remove it from the map\\n                    if (it != mp.end() && it->second ==\\'R\\') {\\n                        mp.erase(it);\\n                    } else {\\n                        mp[pos-1] = \\'L\\';\\n                    }\\n                }\\n            }\\n            //print(mp);\\n\\t\\t\\t// This step we will setup for simulating the next second;\\n            for (it = mp.begin(); it != mp.end(); it++) {\\n                    dominoes[it->first] = it->second;\\n                    q.push(it->first);\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2632464,
                "title": "faster-than-85-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/1ccbc1d8-c069-4b46-8e49-90a26f47424f_1664316389.9166017.png)\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes = list(dominoes) #convert string to list\\n        i = last_point = 0 #set start point and last point which ready to being \\'L\\'\\n            \\n        while i < len(dominoes): #start cycle\\n            if dominoes[i] == \\'.\\': #go next if . in place\\n                i += 1\\n            elif dominoes[i] == \\'L\\': #if this, fill all \\'.\\' between last_point and i-1 and go next (last_point <= i forever)\\n                for j in range(last_point, i):\\n                    dominoes[j] = \\'L\\'\\n                i += 1\\n                last_point = i\\n            else: #if we in \\'R\\', check two ways: 1. it\\'s to (end or next \\'R\\') or (next \\'L\\')\\n                j = i + 1\\n                while j < len(dominoes) and dominoes[j] == \\'.\\': #check ways there\\n                    j += 1\\n                    \\n                if j == len(dominoes) or dominoes[j] == \\'R\\': #first way: fill all \\'.\\' the \\'R\\' and set next last_point after end this way\\n                    last_r = j\\n                    last_point = j + 1\\n                else: #second way: fill only half of all \\'.\\' and if count \\'.\\' is odd save 1 \\'.\\' for latter\\n                    last_r = i + 1 + (j - i - 1) // 2\\n                    last_point = j - (j - i - 1) // 2\\n                    \\n                for k in range(i+1, last_r): #filling \\'R\\' there\\n                        dominoes[k] = \\'R\\'\\n\\n                i = j #jump to next step\\n                \\n        return \\'\\'.join(dominoes) #return answer\\n\\n```\\n\\nP.S. Sry for my eng. It\\'s my first solution with comments)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes = list(dominoes) #convert string to list\\n        i = last_point = 0 #set start point and last point which ready to being \\'L\\'\\n            \\n        while i < len(dominoes): #start cycle\\n            if dominoes[i] == \\'.\\': #go next if . in place\\n                i += 1\\n            elif dominoes[i] == \\'L\\': #if this, fill all \\'.\\' between last_point and i-1 and go next (last_point <= i forever)\\n                for j in range(last_point, i):\\n                    dominoes[j] = \\'L\\'\\n                i += 1\\n                last_point = i\\n            else: #if we in \\'R\\', check two ways: 1. it\\'s to (end or next \\'R\\') or (next \\'L\\')\\n                j = i + 1\\n                while j < len(dominoes) and dominoes[j] == \\'.\\': #check ways there\\n                    j += 1\\n                    \\n                if j == len(dominoes) or dominoes[j] == \\'R\\': #first way: fill all \\'.\\' the \\'R\\' and set next last_point after end this way\\n                    last_r = j\\n                    last_point = j + 1\\n                else: #second way: fill only half of all \\'.\\' and if count \\'.\\' is odd save 1 \\'.\\' for latter\\n                    last_r = i + 1 + (j - i - 1) // 2\\n                    last_point = j - (j - i - 1) // 2\\n                    \\n                for k in range(i+1, last_r): #filling \\'R\\' there\\n                        dominoes[k] = \\'R\\'\\n\\n                i = j #jump to next step\\n                \\n        return \\'\\'.join(dominoes) #return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632350,
                "title": "c-o-n-best-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n=s.size();\\n        vector<int> right(n),left(n);\\n        int r=-1,l=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'R\\')r=i;\\n            else if(s[i]==\\'L\\')r=-1;\\n            right[i]=r;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'L\\')l=i;\\n            else if(s[i]==\\'R\\')l=-1;\\n            left[i]=l;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'.\\')\\n            {\\n                if(right[i]==-1 && left[i]==-1)\\n                    continue;\\n                if(right[i]==-1 && left[i]!=-1)s[i]=\\'L\\';\\n                else if(left[i]==-1 && right[i]!=-1)s[i]=\\'R\\';\\n                else\\n                {\\n                    if(left[i]-i<i-right[i]) s[i]=\\'L\\';\\n                    else if(i-right[i]<left[i]-i)s[i]=\\'R\\';\\n                    \\n                }\\n               \\n            }\\n        }\\n        return s;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n=s.size();\\n        vector<int> right(n),left(n);\\n        int r=-1,l=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'R\\')r=i;\\n            else if(s[i]==\\'L\\')r=-1;\\n            right[i]=r;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'L\\')l=i;\\n            else if(s[i]==\\'R\\')l=-1;\\n            left[i]=l;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'.\\')\\n            {\\n                if(right[i]==-1 && left[i]==-1)\\n                    continue;\\n                if(right[i]==-1 && left[i]!=-1)s[i]=\\'L\\';\\n                else if(left[i]==-1 && right[i]!=-1)s[i]=\\'R\\';\\n                else\\n                {\\n                    if(left[i]-i<i-right[i]) s[i]=\\'L\\';\\n                    else if(i-right[i]<left[i]-i)s[i]=\\'R\\';\\n                    \\n                }\\n               \\n            }\\n        }\\n        return s;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632144,
                "title": "o-1-space-o-n-time-c-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    void cg(string& s,char c,int st,int ed){\\n        for(int i=st;i<=ed;i++)\\n            s[i] = c;\\n    }\\n    \\n    string pushDominoes(string dm) {\\n        int n = dm.size();\\n        int st = 0;\\n        char a,b;\\n        int ok = 0;\\n        while(ok<n && dm[ok]==\\'.\\')\\n            ok++;\\n        \\n        if(ok==n)\\n            return dm;\\n            \\n        if(dm[ok]==\\'L\\'){\\n            for(int i=0;i<=ok;i++)\\n                dm[i]=\\'L\\';\\n        }\\n        \\n        \\n        a = dm[ok];\\n        st = ok;\\n        for(int i=ok+1;i<n;i++){\\n            \\n            while(i<n && dm[i]==\\'.\\')\\n                i++;\\n            \\n            if(i==n)\\n                i = n - 1;\\n            \\n            b = dm[i];\\n                \\n            if(a==\\'L\\' && b==\\'L\\')\\n                cg(dm,\\'L\\',st,i);\\n            else if(a==\\'R\\' && b==\\'R\\')\\n                cg(dm,\\'R\\',st,i);\\n            else if(a==\\'R\\' && b==\\'L\\'){\\n                int u = st,v =i;\\n                while(u<v)\\n                    dm[v--] = \\'L\\',dm[u++] = \\'R\\';\\n                \\n            }\\n            \\n            st = i;\\n            a = b;\\n        }\\n        \\n        int lst = n-1;\\n        char k;\\n        while(lst>=0){\\n            if(dm[lst]==\\'L\\' || dm[lst]==\\'R\\'){\\n                k = dm[lst];break;\\n            }\\n            lst--;\\n        }\\n        if(lst>=0 && k==\\'R\\')\\n            while(lst<n)\\n                dm[lst++] = k; \\n            \\n        return dm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void cg(string& s,char c,int st,int ed){\\n        for(int i=st;i<=ed;i++)\\n            s[i] = c;\\n    }\\n    \\n    string pushDominoes(string dm) {\\n        int n = dm.size();\\n        int st = 0;\\n        char a,b;\\n        int ok = 0;\\n        while(ok<n && dm[ok]==\\'.\\')\\n            ok++;\\n        \\n        if(ok==n)\\n            return dm;\\n            \\n        if(dm[ok]==\\'L\\'){\\n            for(int i=0;i<=ok;i++)\\n                dm[i]=\\'L\\';\\n        }\\n        \\n        \\n        a = dm[ok];\\n        st = ok;\\n        for(int i=ok+1;i<n;i++){\\n            \\n            while(i<n && dm[i]==\\'.\\')\\n                i++;\\n            \\n            if(i==n)\\n                i = n - 1;\\n            \\n            b = dm[i];\\n                \\n            if(a==\\'L\\' && b==\\'L\\')\\n                cg(dm,\\'L\\',st,i);\\n            else if(a==\\'R\\' && b==\\'R\\')\\n                cg(dm,\\'R\\',st,i);\\n            else if(a==\\'R\\' && b==\\'L\\'){\\n                int u = st,v =i;\\n                while(u<v)\\n                    dm[v--] = \\'L\\',dm[u++] = \\'R\\';\\n                \\n            }\\n            \\n            st = i;\\n            a = b;\\n        }\\n        \\n        int lst = n-1;\\n        char k;\\n        while(lst>=0){\\n            if(dm[lst]==\\'L\\' || dm[lst]==\\'R\\'){\\n                k = dm[lst];break;\\n            }\\n            lst--;\\n        }\\n        if(lst>=0 && k==\\'R\\')\\n            while(lst<n)\\n                dm[lst++] = k; \\n            \\n        return dm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632054,
                "title": "javascript-solution-sc-o-1-two-pointers",
                "content": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    dominoes = dominoes.split(\\'\\');\\n    let l = 0, r = 0;\\n    while(r < dominoes.length){\\n        if(dominoes[r] === \\'L\\') while(l <= r) dominoes[l++] = \\'L\\';\\n        else if(dominoes[r] === \\'R\\'){\\n            l = r;\\n            let f = 0;\\n            r++;\\n            while(r < dominoes.length) {\\n                if(dominoes[r] === \\'R\\') {\\n                    f = 1;\\n                    break;\\n                }\\n                if(dominoes[r] === \\'L\\') break;\\n                r++;\\n            }\\n            if(r === dominoes.length || f === 1) {\\n                while(l < r) dominoes[l++] = \\'R\\';\\n                r--;\\n            }\\n            else {\\n                let dif = (r - l - 1) / 2 | 0;\\n                for(let i = 1; i <= dif; i++){\\n                    dominoes[l + i] = \\'R\\';\\n                    dominoes[r - i] = \\'L\\';\\n                }\\n                l = r + 1;\\n            }\\n        }\\n        r++;\\n    }\\n    return dominoes.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    dominoes = dominoes.split(\\'\\');\\n    let l = 0, r = 0;\\n    while(r < dominoes.length){\\n        if(dominoes[r] === \\'L\\') while(l <= r) dominoes[l++] = \\'L\\';\\n        else if(dominoes[r] === \\'R\\'){\\n            l = r;\\n            let f = 0;\\n            r++;\\n            while(r < dominoes.length) {\\n                if(dominoes[r] === \\'R\\') {\\n                    f = 1;\\n                    break;\\n                }\\n                if(dominoes[r] === \\'L\\') break;\\n                r++;\\n            }\\n            if(r === dominoes.length || f === 1) {\\n                while(l < r) dominoes[l++] = \\'R\\';\\n                r--;\\n            }\\n            else {\\n                let dif = (r - l - 1) / 2 | 0;\\n                for(let i = 1; i <= dif; i++){\\n                    dominoes[l + i] = \\'R\\';\\n                    dominoes[r - i] = \\'L\\';\\n                }\\n                l = r + 1;\\n            }\\n        }\\n        r++;\\n    }\\n    return dominoes.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631948,
                "title": "javascript-solution-use-string-prototype-replaceall",
                "content": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nfunction pushDominoes(dominoes) {\\n    while (true) {\\n        const newDominoes = dominoes.replaceAll(`R.L`, `_`).replaceAll(`.L`, `LL`).replaceAll(`R.`, `RR`).replaceAll(`_`, `R.L`);\\n        if (newDominoes === dominoes)\\n            return newDominoes;\\n        else dominoes = newDominoes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nfunction pushDominoes(dominoes) {\\n    while (true) {\\n        const newDominoes = dominoes.replaceAll(`R.L`, `_`).replaceAll(`.L`, `LL`).replaceAll(`R.`, `RR`).replaceAll(`_`, `R.L`);\\n        if (newDominoes === dominoes)\\n            return newDominoes;\\n        else dominoes = newDominoes;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631874,
                "title": "c-naive-approach-multiple-passes",
                "content": "Easy to understand, must upvote!\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        string finalDominoes(n, \\'#\\'), leftApplied = dominoes, rightApplied = dominoes;\\n        for(int i = n-1; i > 0; i--) {\\n            if(leftApplied[i] == \\'L\\' and leftApplied[i-1] == \\'.\\')\\n                leftApplied[i-1] = \\'L\\';\\n        }\\n        for(int i = 0; i < n-1; i++) {\\n            if(rightApplied[i] == \\'R\\' and rightApplied[i+1] == \\'.\\')\\n                rightApplied[i+1] = \\'R\\';\\n        }\\n        queue<int> windows; int windowCount = 0; \\n        for(int i = 0; i < n; i++) {\\n            if(leftApplied[i] == rightApplied[i])\\n                finalDominoes[i] = leftApplied[i];\\n            else if(leftApplied[i] == \\'.\\')\\n                finalDominoes[i] = rightApplied[i];\\n            else if(rightApplied[i] == \\'.\\')\\n                finalDominoes[i] = leftApplied[i];\\n            else {\\n                windowCount += 1; continue;\\n            }\\n            if(windowCount)\\n                windows.push(windowCount); \\n            windowCount = 0;\\n        }\\n        char prev = \\'\\\\0\\';\\n        for(int i = 0; i < n; i++) {\\n            if(finalDominoes[i] == \\'#\\') {\\n                int len = windows.front(); windows.pop();\\n                if(len == 1) {\\n                    finalDominoes[i] = \\'.\\';\\n                } else {\\n                    int j = i;\\n                    while(j < i + (len/2)) {    \\n                        finalDominoes[j] = prev;\\n                        j += 1;\\n                    }\\n                    if(len & 1) {\\n                        finalDominoes[j] = \\'.\\'; j += 1;\\n                    }\\n                    char remaining = (prev == \\'L\\')? \\'R\\': \\'L\\';\\n                    while(finalDominoes[j] == \\'#\\') {\\n                        finalDominoes[j] = remaining;\\n                        j += 1;\\n                    }\\n                    i = j-1;\\n                }\\n            }\\n            prev = finalDominoes[i];\\n        }\\n        return finalDominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        string finalDominoes(n, \\'#\\'), leftApplied = dominoes, rightApplied = dominoes;\\n        for(int i = n-1; i > 0; i--) {\\n            if(leftApplied[i] == \\'L\\' and leftApplied[i-1] == \\'.\\')\\n                leftApplied[i-1] = \\'L\\';\\n        }\\n        for(int i = 0; i < n-1; i++) {\\n            if(rightApplied[i] == \\'R\\' and rightApplied[i+1] == \\'.\\')\\n                rightApplied[i+1] = \\'R\\';\\n        }\\n        queue<int> windows; int windowCount = 0; \\n        for(int i = 0; i < n; i++) {\\n            if(leftApplied[i] == rightApplied[i])\\n                finalDominoes[i] = leftApplied[i];\\n            else if(leftApplied[i] == \\'.\\')\\n                finalDominoes[i] = rightApplied[i];\\n            else if(rightApplied[i] == \\'.\\')\\n                finalDominoes[i] = leftApplied[i];\\n            else {\\n                windowCount += 1; continue;\\n            }\\n            if(windowCount)\\n                windows.push(windowCount); \\n            windowCount = 0;\\n        }\\n        char prev = \\'\\\\0\\';\\n        for(int i = 0; i < n; i++) {\\n            if(finalDominoes[i] == \\'#\\') {\\n                int len = windows.front(); windows.pop();\\n                if(len == 1) {\\n                    finalDominoes[i] = \\'.\\';\\n                } else {\\n                    int j = i;\\n                    while(j < i + (len/2)) {    \\n                        finalDominoes[j] = prev;\\n                        j += 1;\\n                    }\\n                    if(len & 1) {\\n                        finalDominoes[j] = \\'.\\'; j += 1;\\n                    }\\n                    char remaining = (prev == \\'L\\')? \\'R\\': \\'L\\';\\n                    while(finalDominoes[j] == \\'#\\') {\\n                        finalDominoes[j] = remaining;\\n                        j += 1;\\n                    }\\n                    i = j-1;\\n                }\\n            }\\n            prev = finalDominoes[i];\\n        }\\n        return finalDominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631842,
                "title": "simple-java-solution-greedy-single-pass-solution",
                "content": "```\\n//if you found my solution usefull please upvote it\\nclass Solution \\n{\\n    public String pushDominoes(String dominoes) \\n    {\\n        StringBuilder ans=new StringBuilder(\"\");\\n        int i=0;\\n        while(i<dominoes.length())\\n        {\\n            char ch=dominoes.charAt(i);\\n            if(ch==\\'.\\')\\n            {\\n                int j=i+1;\\n                while(j<dominoes.length() && dominoes.charAt(j)!=\\'L\\' && dominoes.charAt(j)!=\\'R\\') j++;\\n                if(j<dominoes.length() && dominoes.charAt(j)==\\'L\\' )\\n                {\\n                    for(int k=i;k<=j;k++)  ans.append(\"L\");\\n                    i=j+1;\\n                }\\n                else if(j<dominoes.length() && dominoes.charAt(j)==\\'R\\')\\n                {\\n                    for(int k=i;k<j;k++)  ans.append(\".\");\\n                    i=j;\\n                }\\n                else if(j>=dominoes.length())\\n                {\\n                    for(int k=i;k<j;k++)  ans.append(\".\");\\n                    i=j;\\n                }\\n            }\\n            else if(ch==\\'R\\')\\n            {\\n                int j=i+1;\\n                while(j<dominoes.length() && dominoes.charAt(j)!=\\'L\\' && dominoes.charAt(j)!=\\'R\\') j++;\\n                if(j<dominoes.length() && dominoes.charAt(j)==\\'R\\')\\n                {\\n                    for(int k=i;k<j;k++)  ans.append(\"R\");\\n                    i=j;\\n                }\\n                else if(j<dominoes.length() && dominoes.charAt(j)==\\'L\\')\\n                {\\n                    int len=j-i+1;\\n                if(len%2==0)\\n                {\\n                    int half=len/2;\\n                    for(int k=0;k<half;k++)  ans.append(\"R\");\\n                    for(int k=0;k<half;k++)  ans.append(\"L\");\\n                }\\n                else\\n                {\\n                    int half=((len+1)/2)-1;\\n                    for(int k=0;k<half;k++)  ans.append(\"R\");\\n                    ans.append(\".\");\\n                    for(int k=0;k<half;k++)  ans.append(\"L\");\\n                }\\n                i=j+1;\\n                }\\n                else if(j>=dominoes.length())\\n                {\\n                    for(int k=i;k<j;k++)  ans.append(\"R\");\\n                    i=j;\\n                }\\n            }\\n            else if(ch==\\'L\\') \\n            {\\n                ans.append(\"L\");\\n                i++;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public String pushDominoes(String dominoes) \\n    {\\n        StringBuilder ans=new StringBuilder(\"\");\\n        int i=0;\\n        while(i<dominoes.length())\\n        {\\n            char ch=dominoes.charAt(i);\\n            if(ch==\\'.\\')\\n            {\\n                int j=i+1;\\n                while(j<dominoes.length() && dominoes.charAt(j)!=\\'L\\' && dominoes.charAt(j)!=\\'R\\') j++;\\n                if(j<dominoes.length() && dominoes.charAt(j)==\\'L\\' )\\n                {\\n                    for(int k=i;k<=j;k++)  ans.append(\"L\");\\n                    i=j+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2631809,
                "title": "python-one-liner",
                "content": "```\\n# 47.90% 30.84% (53.51% 30.84%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\'))\\n\\n```\\n\\n**Upd:**\\nTranslating \\'X\\' back to \\'R.L\\' only at last step - when no moves left.\\n\\n```\\n# 78.84% 36.51% (77.67% 33.26%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes.replace(\\'X\\', \\'R.L\\') if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\'))\\n\\n```\\n\\n**Details:**\\n```\\n# 94.42% 34.42% (95.58% 34.42%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\ttest = dominoes.replace(\\'R.L\\', \\'X\\') # hiding edge case \\'R.L\\' with \\'X\\'\\n\\ttest = test.replace(\\'.L\\', \\'LL\\')     # falling left\\n\\ttest = test.replace(\\'R.\\', \\'RR\\')     # falling right\\n\\tif test != dominoes:                # falls happened\\n\\t\\treturn self.pushDominoes(test)  # continue pushing dominoes\\n\\treturn dominoes.replace(\\'X\\', \\'R.L\\') # no falls - translating \\'X\\' back and returning final result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# 47.90% 30.84% (53.51% 30.84%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\'))\\n\\n```\n```\\n# 78.84% 36.51% (77.67% 33.26%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes.replace(\\'X\\', \\'R.L\\') if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\'))\\n\\n```\n```\\n# 94.42% 34.42% (95.58% 34.42%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\ttest = dominoes.replace(\\'R.L\\', \\'X\\') # hiding edge case \\'R.L\\' with \\'X\\'\\n\\ttest = test.replace(\\'.L\\', \\'LL\\')     # falling left\\n\\ttest = test.replace(\\'R.\\', \\'RR\\')     # falling right\\n\\tif test != dominoes:                # falls happened\\n\\t\\treturn self.pushDominoes(test)  # continue pushing dominoes\\n\\treturn dominoes.replace(\\'X\\', \\'R.L\\') # no falls - translating \\'X\\' back and returning final result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2631620,
                "title": "92-faster-89-less-memory-c-o-1-space-o-n-time",
                "content": "We only have to consider the interval with all ```\\'.\\'```, and handle all the cases for the same.\\nBranching in the helper function, can be evidently, a bit more clean, but the algorithm works just fine.\\nPlease upvote if you find the solution helpful.\\n***Thank You!!***\\n```\\nclass Solution {\\npublic:\\n    void func(string& s, int &last, int &idx, int &n) {\\n        if(last == -1 and idx == n) return;\\n        else if(last == -1) {\\n            if(s[idx] == \\'L\\') {\\n                for(int i=0;i<idx;i++) s[i] = \\'L\\';\\n            }\\n        }\\n        else if(idx == n) {\\n            if(s[last] == \\'R\\') {\\n                for(int i = last +1;i<n;i++) s[i] =\\'R\\';\\n            }\\n        }\\n        else {\\n            if(s[last] == \\'R\\' and s[idx] == \\'L\\') {\\n                int no_dom = idx - last - 1;\\n                for(int len = 1, i = last + 1; len <= (no_dom>>1);len++, i++)\\n                    s[i] = \\'R\\';\\n                for(int len = 1, i = idx - 1; len <= (no_dom>>1);len++, i--)\\n                    s[i] = \\'L\\';\\n            }\\n            else if(s[last] == \\'R\\' and s[idx] == \\'R\\') {\\n                for(int i=last + 1;i<idx;i++) s[i] = \\'R\\';\\n            }\\n            else if(s[last] == \\'L\\' and s[idx] == \\'L\\') {\\n                for(int i=last + 1;i<idx;i++) s[i] = \\'L\\';\\n            }\\n            else if(s[last] == \\'L\\' and s[idx] == \\'R\\') {\\n                return;\\n            }\\n        }\\n    }\\n    string pushDominoes(string s) {\\n        int n = s.size(), idx = 0, last_left = -1;\\n        while(idx < n and s[idx] == \\'.\\') idx++;\\n        while(idx < n) {\\n            func(s, last_left, idx, n);\\n            while(idx < n and s[idx] - \\'.\\') idx++;\\n            last_left = idx - 1;\\n            while(idx < n and s[idx] == \\'.\\') idx++;\\n        }\\n        func(s, last_left, idx, n);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\'.\\'```\n```\\nclass Solution {\\npublic:\\n    void func(string& s, int &last, int &idx, int &n) {\\n        if(last == -1 and idx == n) return;\\n        else if(last == -1) {\\n            if(s[idx] == \\'L\\') {\\n                for(int i=0;i<idx;i++) s[i] = \\'L\\';\\n            }\\n        }\\n        else if(idx == n) {\\n            if(s[last] == \\'R\\') {\\n                for(int i = last +1;i<n;i++) s[i] =\\'R\\';\\n            }\\n        }\\n        else {\\n            if(s[last] == \\'R\\' and s[idx] == \\'L\\') {\\n                int no_dom = idx - last - 1;\\n                for(int len = 1, i = last + 1; len <= (no_dom>>1);len++, i++)\\n                    s[i] = \\'R\\';\\n                for(int len = 1, i = idx - 1; len <= (no_dom>>1);len++, i--)\\n                    s[i] = \\'L\\';\\n            }\\n            else if(s[last] == \\'R\\' and s[idx] == \\'R\\') {\\n                for(int i=last + 1;i<idx;i++) s[i] = \\'R\\';\\n            }\\n            else if(s[last] == \\'L\\' and s[idx] == \\'L\\') {\\n                for(int i=last + 1;i<idx;i++) s[i] = \\'L\\';\\n            }\\n            else if(s[last] == \\'L\\' and s[idx] == \\'R\\') {\\n                return;\\n            }\\n        }\\n    }\\n    string pushDominoes(string s) {\\n        int n = s.size(), idx = 0, last_left = -1;\\n        while(idx < n and s[idx] == \\'.\\') idx++;\\n        while(idx < n) {\\n            func(s, last_left, idx, n);\\n            while(idx < n and s[idx] - \\'.\\') idx++;\\n            last_left = idx - 1;\\n            while(idx < n and s[idx] == \\'.\\') idx++;\\n        }\\n        func(s, last_left, idx, n);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631314,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n = len(dominoes)\\n        \\n        right_force = [0] * n\\n        \\n        for i in range(n):\\n            if dominoes[i] == \\'R\\':\\n                right_force[i] = n\\n            elif dominoes[i] == \\'L\\':\\n                right_force[i] = 0\\n            else:\\n                if(i-1 >= 0):\\n                    right_force[i] = max(right_force[i-1]-1, 0)\\n\\n        left_force = [0] * n\\n        \\n        for i in range(n-1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                left_force[i] = n\\n            elif dominoes[i] == \\'R\\':\\n                left_force[i] = 0\\n            else:\\n                if(i+1 < n):\\n                    left_force[i] = max(left_force[i+1]-1, 0)\\n    \\n        return \\'\\'.join(\\'.\\' if right_force[i] == left_force[i] else \\'R\\' if right_force[i] > left_force[i] else \\'L\\' for i in range(n))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n = len(dominoes)\\n        \\n        right_force = [0] * n\\n        \\n        for i in range(n):\\n            if dominoes[i] == \\'R\\':\\n                right_force[i] = n\\n            elif dominoes[i] == \\'L\\':\\n                right_force[i] = 0\\n            else:\\n                if(i-1 >= 0):\\n                    right_force[i] = max(right_force[i-1]-1, 0)\\n\\n        left_force = [0] * n\\n        \\n        for i in range(n-1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                left_force[i] = n\\n            elif dominoes[i] == \\'R\\':\\n                left_force[i] = 0\\n            else:\\n                if(i+1 < n):\\n                    left_force[i] = max(left_force[i+1]-1, 0)\\n    \\n        return \\'\\'.join(\\'.\\' if right_force[i] == left_force[i] else \\'R\\' if right_force[i] > left_force[i] else \\'L\\' for i in range(n))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631291,
                "title": "c-fastest-submission-crisp-and-clear-dp",
                "content": "TC: O(N + N) -->~ = O(N)\\nSC: O(N)\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string str) {\\n        int n=str.size();\\n        vector<int>arr(n);\\n        string ans=str;\\n        \\n        int right_force=0;\\n        for(int i=0;i<n;i++){\\n            if(str[i]==\\'L\\')\\n                right_force=0;\\n            if(str[i]==\\'R\\')\\n                right_force=1;\\n            if(str[i]==\\'.\\' && right_force>0)\\n                right_force++;\\n            arr[i]=right_force;\\n        }\\n       \\n        int left_force=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(str[i]==\\'R\\') left_force=0;\\n            if(str[i]==\\'L\\') left_force=1;\\n            if(str[i]==\\'.\\')\\n            {\\n                if(left_force>0)\\n                    left_force++;\\n                \\n                if(arr[i]==0 && left_force>0)\\n                    ans[i]=\\'L\\';\\n                else if(arr[i]>0 && left_force==0)\\n                    ans[i]=\\'R\\';\\n                \\n                //force from both direction\\n                else if(arr[i]<left_force)\\n                    ans[i]=\\'R\\';\\n                else if(arr[i]>left_force) \\n                    ans[i]=\\'L\\';\\n                \\n                // equilibrium condition arr[i] == left_force \\n                else\\n                    ans[i]=\\'.\\';  // no change\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string str) {\\n        int n=str.size();\\n        vector<int>arr(n);\\n        string ans=str;\\n        \\n        int right_force=0;\\n        for(int i=0;i<n;i++){\\n            if(str[i]==\\'L\\')\\n                right_force=0;\\n            if(str[i]==\\'R\\')\\n                right_force=1;\\n            if(str[i]==\\'.\\' && right_force>0)\\n                right_force++;\\n            arr[i]=right_force;\\n        }\\n       \\n        int left_force=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(str[i]==\\'R\\') left_force=0;\\n            if(str[i]==\\'L\\') left_force=1;\\n            if(str[i]==\\'.\\')\\n            {\\n                if(left_force>0)\\n                    left_force++;\\n                \\n                if(arr[i]==0 && left_force>0)\\n                    ans[i]=\\'L\\';\\n                else if(arr[i]>0 && left_force==0)\\n                    ans[i]=\\'R\\';\\n                \\n                //force from both direction\\n                else if(arr[i]<left_force)\\n                    ans[i]=\\'R\\';\\n                else if(arr[i]>left_force) \\n                    ans[i]=\\'L\\';\\n                \\n                // equilibrium condition arr[i] == left_force \\n                else\\n                    ans[i]=\\'.\\';  // no change\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631285,
                "title": "58ms-cpp-fast-code",
                "content": "Calculating time to fall and returning net fall time.\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        vector<int> l(d.size(),-1);\\n        vector<int> r(d.size(),-1);\\n        int set = 0;\\n        int lset = 0;\\n        for(int i=0,j=d.size()-1;i<d.size();i++,j--) {\\n            if(d[i] == \\'.\\') {\\n                if(set == 0) l[i] = 0;\\n                else {\\n                    l[i] = set;\\n                    set++;\\n                }\\n            } else if(d[i] == \\'R\\') {\\n                set = 1;\\n                l[i] = INT_MAX;\\n            } else if(d[i] == \\'L\\') {\\n                set = 0;\\n                l[i] = INT_MAX;\\n            }\\n            if(d[j] == \\'.\\') {\\n                if(lset == 0) r[j] = 0;\\n                else {\\n                    r[j] = lset;\\n                    lset--;\\n                }\\n            } else if(d[j] == \\'R\\') {\\n                lset = 0;\\n                r[j] = INT_MAX;\\n            } else if(d[j] == \\'L\\') {\\n                lset = -1;\\n                r[j] = INT_MAX;\\n            }\\n        }\\n        string temp=\"\";\\n        for(int i=0;i<d.size();i++) {\\n            if(l[i] == 0 || r[i] == 0) {\\n                int res = (l[i]+r[i])*(-1);\\n                if(res<0) temp+=\\'R\\';\\n                else if(res>0) temp+=\\'L\\';\\n                else temp+=\\'.\\';\\n            } else if(l[i] == INT_MAX || r[i]==INT_MAX) {\\n                temp+=d[i];\\n            } else {\\n                int res = l[i]+r[i];\\n                if(res<0) temp+=\\'R\\';\\n                else if(res>0) temp+=\\'L\\';\\n                else temp+=\\'.\\';\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        vector<int> l(d.size(),-1);\\n        vector<int> r(d.size(),-1);\\n        int set = 0;\\n        int lset = 0;\\n        for(int i=0,j=d.size()-1;i<d.size();i++,j--) {\\n            if(d[i] == \\'.\\') {\\n                if(set == 0) l[i] = 0;\\n                else {\\n                    l[i] = set;\\n                    set++;\\n                }\\n            } else if(d[i] == \\'R\\') {\\n                set = 1;\\n                l[i] = INT_MAX;\\n            } else if(d[i] == \\'L\\') {\\n                set = 0;\\n                l[i] = INT_MAX;\\n            }\\n            if(d[j] == \\'.\\') {\\n                if(lset == 0) r[j] = 0;\\n                else {\\n                    r[j] = lset;\\n                    lset--;\\n                }\\n            } else if(d[j] == \\'R\\') {\\n                lset = 0;\\n                r[j] = INT_MAX;\\n            } else if(d[j] == \\'L\\') {\\n                lset = -1;\\n                r[j] = INT_MAX;\\n            }\\n        }\\n        string temp=\"\";\\n        for(int i=0;i<d.size();i++) {\\n            if(l[i] == 0 || r[i] == 0) {\\n                int res = (l[i]+r[i])*(-1);\\n                if(res<0) temp+=\\'R\\';\\n                else if(res>0) temp+=\\'L\\';\\n                else temp+=\\'.\\';\\n            } else if(l[i] == INT_MAX || r[i]==INT_MAX) {\\n                temp+=d[i];\\n            } else {\\n                int res = l[i]+r[i];\\n                if(res<0) temp+=\\'R\\';\\n                else if(res>0) temp+=\\'L\\';\\n                else temp+=\\'.\\';\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631133,
                "title": "c-solution-using-pointer",
                "content": "\\t\\t*********please upvote if you like **********\\n\\t\\t\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n   \\n    static void solve(vector<char> &v,int j,int k){\\n       if(v[j]==\\'L\\'&&v[k]==\\'L\\'){\\n           for(int i=j+1;i<k;i++){\\n               v[i]=\\'L\\';\\n           }\\n           \\n       }else if(v[j]==\\'R\\'&&v[k]==\\'R\\'){\\n            for(int i=j+1;i<k;i++){\\n               v[i]=\\'R\\';\\n           }\\n           \\n       }\\n        else if(v[j]==\\'L\\'&&v[k]==\\'R\\'){\\n\\t\\t\\t//                  do nothing\\n        }\\n        else{\\n            int diff=k-j;\\n            int mid=(j+k)/2;\\n            if(diff%2!=0){\\n               for(int i=j+1;i<=mid;i++){\\n                  v[i]=\\'R\\'; \\n               }\\n                for(int i=mid+1;i<k;i++){\\n                  v[i]=\\'L\\'; \\n               }\\n                \\n                \\n            }\\n            else{\\n                 for(int i=j+1;i<mid;i++){\\n                  v[i]=\\'R\\'; \\n               }\\n                 for(int i=mid+1;i<k;i++){\\n                  v[i]=\\'L\\'; \\n               }    \\n            }\\n            \\n        }\\n    }\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n     vector<char>v(n+2);\\n        v[0]=\\'L\\';\\n        v[n+1]=\\'R\\';\\n        for(int i=1;i<v.size()-1;i++){\\n            v[i]=dominoes[i-1]; \\n        }\\n        int j=0,k=1;\\n        while(k<v.size()){\\n            while(v[k]==\\'.\\'){\\n                k++;\\n            }\\n            if(k-j>1)\\n            solve(v,j,k);\\n            j=k;\\n            k++;\\n        }\\n        string ans=\"\";\\n        for(int i=1;i<v.size()-1;i++){\\n            ans+=v[i];\\n        }\\n        \\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n   \\n    static void solve(vector<char> &v,int j,int k){\\n       if(v[j]==\\'L\\'&&v[k]==\\'L\\'){\\n           for(int i=j+1;i<k;i++){\\n               v[i]=\\'L\\';\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2630914,
                "title": "cpp-easy-to-understand",
                "content": "# \\t*please upvote if  this solution helped you*\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string dominoes) {\\n\\t\\t\\tstring ans = \"\";\\n\\t\\t\\tans += dominoes[0];\\n\\t\\t\\tint n = dominoes.size();\\n\\t\\t\\tpair<char,int>prev = {dominoes[0],0};\\n\\t\\t\\tfor(int i =1;i<n;i++){\\n\\t\\t\\t\\tans += dominoes[i]; \\n\\t\\t\\t\\tif(prev.first == \\'.\\' && dominoes[i] == \\'.\\') continue;\\n\\n\\t\\t\\t\\tif(prev.first == dominoes[i] ){\\n\\t\\t\\t\\t\\tfor(int j = prev.second+1;j<i;j++){\\n\\t\\t\\t\\t\\t\\tans[j] = dominoes[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\telse if(prev.first == \\'.\\' && dominoes[i] == \\'L\\'){\\n\\t\\t\\t\\t\\tfor(int j = prev.second;j<i;j++){\\n\\t\\t\\t\\t\\t\\tans[j] = \\'L\\';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t else if(prev.first == \\'R\\' && dominoes[i] == \\'L\\'){\\n\\t\\t\\t\\t\\tint prev_idx = prev.second;\\n\\t\\t\\t\\t\\tprev_idx++;\\n\\t\\t\\t\\t\\tint curr_idx = i;\\n\\t\\t\\t\\t\\tcurr_idx--;\\n\\t\\t\\t\\t\\twhile(prev_idx < curr_idx){\\n\\t\\t\\t\\t\\t\\tans[prev_idx] = \\'R\\';\\n\\t\\t\\t\\t\\t\\tans[curr_idx] = \\'L\\';\\n\\t\\t\\t\\t\\t\\tprev_idx++;\\n\\t\\t\\t\\t\\t\\tcurr_idx--;\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\t\\tif(dominoes[i] != \\'.\\') prev = {dominoes[i],i};\\n\\n\\t\\t\\t}\\n\\t\\t\\tif(prev.first == \\'R\\'){\\n\\t\\t\\t\\tfor(int i = prev.second;i<n;i++){\\n\\t\\t\\t\\t\\tans[i] = \\'R\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string dominoes) {\\n\\t\\t\\tstring ans = \"\";\\n\\t\\t\\tans += dominoes[0];\\n\\t\\t\\tint n = dominoes.size();\\n\\t\\t\\tpair<char,int>prev = {dominoes[0],0}",
                "codeTag": "Java"
            },
            {
                "id": 2630889,
                "title": "easy",
                "content": "```\\nclass Solution {\\n    public:\\n    string pushDominoes(string s){\\n        int n = s.length();\\n        vector<int>L(n,INT_MAX);\\n        vector<int>R(n,INT_MAX);\\n        if(s[n-1]==\\'L\\')L[n-1]=0;\\n        for (int i = n-2; i >=0; i--)\\n        {\\n            if(s[i]==\\'R\\')\\n            continue;\\n            if(s[i]==\\'L\\')L[i]=0;\\n            else if(s[i]==\\'R\\')L[i]=INT_MAX;\\n            else L[i]=L[i+1]+1;\\n        }\\n\\n        if (s[0]==\\'R\\')R[0]=0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            if(s[i]==\\'L\\')\\n            continue;\\n            if(s[i]==\\'R\\')R[i]=0;\\n            else if(s[i]==\\'L\\')R[i]=INT_MAX;\\n            else R[i]=R[i-1]+1;\\n        }\\n\\n        string ans=\"\";\\n        for (int i = 0; i < n; i++)\\n        {\\n            if(L[i]==R[i])ans+=\\'.\\';\\n            else if(L[i]<R[i])ans+=\\'L\\';\\n            else ans+=\\'R\\';\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    string pushDominoes(string s){\\n        int n = s.length();\\n        vector<int>L(n,INT_MAX);\\n        vector<int>R(n,INT_MAX);\\n        if(s[n-1]==\\'L\\')L[n-1]=0;\\n        for (int i = n-2; i >=0; i--)\\n        {\\n            if(s[i]==\\'R\\')\\n            continue;\\n            if(s[i]==\\'L\\')L[i]=0;\\n            else if(s[i]==\\'R\\')L[i]=INT_MAX;\\n            else L[i]=L[i+1]+1;\\n        }\\n\\n        if (s[0]==\\'R\\')R[0]=0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            if(s[i]==\\'L\\')\\n            continue;\\n            if(s[i]==\\'R\\')R[i]=0;\\n            else if(s[i]==\\'L\\')R[i]=INT_MAX;\\n            else R[i]=R[i-1]+1;\\n        }\\n\\n        string ans=\"\";\\n        for (int i = 0; i < n; i++)\\n        {\\n            if(L[i]==R[i])ans+=\\'.\\';\\n            else if(L[i]<R[i])ans+=\\'L\\';\\n            else ans+=\\'R\\';\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630840,
                "title": "java-two-approaches",
                "content": "### Please Upvote !!! **(\\u25E0\\u203F\\u25E0)**\\n##### Approach 1:\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        char[] arr = new char[n + 2];\\n        arr[0] = \\'L\\'; arr[n + 1] = \\'R\\';\\n\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            arr[i] = dominoes.charAt(i - 1);\\n        }\\n\\n        int i = 0, j = 1;\\n\\n        while (j < arr.length) {\\n            while (arr[j] == \\'.\\') j++;\\n            if (j - i > 1) helper(arr, i, j);\\n            i = j++;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int idx = 1; idx < arr.length - 1; idx++) {\\n            ans.append(arr[idx]);\\n        }\\n\\n        return ans.toString();\\n    }\\n\\n    public void helper(char[] arr, int i, int j) {\\n        // case 1\\n        if (arr[i] == \\'L\\' && arr[j] == \\'L\\') {\\n            for (int a = i + 1; a < j; a++) {\\n                arr[a] = \\'L\\';\\n            }\\n        }\\n\\n        // case 2\\n        else if (arr[i] == \\'R\\' && arr[j] == \\'R\\') {\\n            for (int a = i + 1; a < j; a++) {\\n                arr[a] = \\'R\\';\\n            }\\n        }\\n\\n        // case 3\\n        else if (arr[i] == \\'L\\' && arr[j] == \\'R\\') {\\n            // do nothing\\n        }\\n\\n        // case 4\\n        // arr[i] == \\'R\\' && arr[j] == \\'L\\'\\n        else {\\n            int l = i + 1, r = j - 1;\\n            while (l < r) {\\n                arr[l++] = \\'R\\';\\n                arr[r--] = \\'L\\';\\n            }\\n        }\\n    }\\n}\\n\\n// TC: O(n) + O(n * n) + O(n);\\n// SC: O(n)\\n```\\n\\n##### Approach 2:\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n\\n        int[] left = new int[n];\\n        int nearestLeftIdx = -1;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            char c = dominoes.charAt(i);\\n            if (c == \\'L\\') nearestLeftIdx = i;\\n            else if (c == \\'R\\') nearestLeftIdx = -1;\\n            left[i] = nearestLeftIdx;\\n        }\\n\\n        int[] right = new int[n];\\n        int nearestRightIdx = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = dominoes.charAt(i);\\n            if (c == \\'R\\') nearestRightIdx = i;\\n            else if (c == \\'L\\') nearestRightIdx = -1;\\n            right[i] = nearestRightIdx;\\n        }\\n\\n        char[] ans = new char[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (dominoes.charAt(i) == \\'.\\') {\\n                int nearestLeft = left[i];\\n                int nearestRight = right[i];\\n\\n                int leftDiff = (nearestLeft == -1) ? Integer.MAX_VALUE : Math.abs(nearestLeft - i);\\n                int rightDiff = (nearestRight == -1) ? Integer.MAX_VALUE : Math.abs(nearestRight - i);\\n\\n                if (leftDiff == rightDiff) ans[i] = \\'.\\';\\n                else if (leftDiff < rightDiff) ans[i] = \\'L\\';\\n                else ans[i] = \\'R\\';  // leftDiff > rightDiff\\n            }\\n\\n            else ans[i] = dominoes.charAt(i);\\n        }\\n\\n        return new String(ans);\\n    }\\n}\\n\\n// TC: O(n + O(n) + O(n) => O(n)\\n// SC: O(n) + O(n) => O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        char[] arr = new char[n + 2];\\n        arr[0] = \\'L\\'; arr[n + 1] = \\'R\\';\\n\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            arr[i] = dominoes.charAt(i - 1);\\n        }\\n\\n        int i = 0, j = 1;\\n\\n        while (j < arr.length) {\\n            while (arr[j] == \\'.\\') j++;\\n            if (j - i > 1) helper(arr, i, j);\\n            i = j++;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int idx = 1; idx < arr.length - 1; idx++) {\\n            ans.append(arr[idx]);\\n        }\\n\\n        return ans.toString();\\n    }\\n\\n    public void helper(char[] arr, int i, int j) {\\n        // case 1\\n        if (arr[i] == \\'L\\' && arr[j] == \\'L\\') {\\n            for (int a = i + 1; a < j; a++) {\\n                arr[a] = \\'L\\';\\n            }\\n        }\\n\\n        // case 2\\n        else if (arr[i] == \\'R\\' && arr[j] == \\'R\\') {\\n            for (int a = i + 1; a < j; a++) {\\n                arr[a] = \\'R\\';\\n            }\\n        }\\n\\n        // case 3\\n        else if (arr[i] == \\'L\\' && arr[j] == \\'R\\') {\\n            // do nothing\\n        }\\n\\n        // case 4\\n        // arr[i] == \\'R\\' && arr[j] == \\'L\\'\\n        else {\\n            int l = i + 1, r = j - 1;\\n            while (l < r) {\\n                arr[l++] = \\'R\\';\\n                arr[r--] = \\'L\\';\\n            }\\n        }\\n    }\\n}\\n\\n// TC: O(n) + O(n * n) + O(n);\\n// SC: O(n)\\n```\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n\\n        int[] left = new int[n];\\n        int nearestLeftIdx = -1;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            char c = dominoes.charAt(i);\\n            if (c == \\'L\\') nearestLeftIdx = i;\\n            else if (c == \\'R\\') nearestLeftIdx = -1;\\n            left[i] = nearestLeftIdx;\\n        }\\n\\n        int[] right = new int[n];\\n        int nearestRightIdx = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = dominoes.charAt(i);\\n            if (c == \\'R\\') nearestRightIdx = i;\\n            else if (c == \\'L\\') nearestRightIdx = -1;\\n            right[i] = nearestRightIdx;\\n        }\\n\\n        char[] ans = new char[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (dominoes.charAt(i) == \\'.\\') {\\n                int nearestLeft = left[i];\\n                int nearestRight = right[i];\\n\\n                int leftDiff = (nearestLeft == -1) ? Integer.MAX_VALUE : Math.abs(nearestLeft - i);\\n                int rightDiff = (nearestRight == -1) ? Integer.MAX_VALUE : Math.abs(nearestRight - i);\\n\\n                if (leftDiff == rightDiff) ans[i] = \\'.\\';\\n                else if (leftDiff < rightDiff) ans[i] = \\'L\\';\\n                else ans[i] = \\'R\\';  // leftDiff > rightDiff\\n            }\\n\\n            else ans[i] = dominoes.charAt(i);\\n        }\\n\\n        return new String(ans);\\n    }\\n}\\n\\n// TC: O(n + O(n) + O(n) => O(n)\\n// SC: O(n) + O(n) => O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630601,
                "title": "this-java-solution-beats-90-96-of-java-submissions",
                "content": "**Upvote if you\\'re not greedy)))**\\n```\\nclass Solution {\\n    private char[] result;\\n\\n    public String pushDominoes(String dominoes) {\\n        int len = dominoes.length();\\n        result = dominoes.toCharArray();\\n        for (int i = 0; i < len; i++) {\\n            char temp = dominoes.charAt(i);\\n            if (temp == \\'.\\') {\\n                int left = i;\\n                while (i < len && dominoes.charAt(i) == \\'.\\') {\\n                    i++;\\n                }\\n                int right = i - 1;\\n                char rChar = right == len - 1 ? \\'.\\' : dominoes.charAt(right + 1);\\n                char lChar = left == 0 ? \\'.\\' : dominoes.charAt(left - 1);\\n                if (lChar != \\'R\\' && rChar == \\'L\\') {\\n                    fillSubstringBy(left, right, \\'L\\');\\n                } else if (rChar != \\'L\\' && lChar == \\'R\\') {\\n                    fillSubstringBy(left, right, \\'R\\');\\n                } else if (lChar == \\'R\\') {\\n                    fillSubstring(left, right);\\n                }\\n            }\\n        }\\n        return new String(result);\\n    }\\n\\n    private void fillSubstring(int left, int right) {\\n        while (right > left) {\\n            result[right--] = \\'L\\';\\n            result[left++] = \\'R\\';\\n        }\\n    }\\n\\n    private void fillSubstringBy(int left, int right, char c) {\\n        for (int i = left; i <= right; i++) {\\n            result[i] = c;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    private char[] result;\\n\\n    public String pushDominoes(String dominoes) {\\n        int len = dominoes.length();\\n        result = dominoes.toCharArray();\\n        for (int i = 0; i < len; i++) {\\n            char temp = dominoes.charAt(i);\\n            if (temp == \\'.\\') {\\n                int left = i;\\n                while (i < len && dominoes.charAt(i) == \\'.\\') {\\n                    i++;\\n                }\\n                int right = i - 1;\\n                char rChar = right == len - 1 ? \\'.\\' : dominoes.charAt(right + 1);\\n                char lChar = left == 0 ? \\'.\\' : dominoes.charAt(left - 1);\\n                if (lChar != \\'R\\' && rChar == \\'L\\') {\\n                    fillSubstringBy(left, right, \\'L\\');\\n                } else if (rChar != \\'L\\' && lChar == \\'R\\') {\\n                    fillSubstringBy(left, right, \\'R\\');\\n                } else if (lChar == \\'R\\') {\\n                    fillSubstring(left, right);\\n                }\\n            }\\n        }\\n        return new String(result);\\n    }\\n\\n    private void fillSubstring(int left, int right) {\\n        while (right > left) {\\n            result[right--] = \\'L\\';\\n            result[left++] = \\'R\\';\\n        }\\n    }\\n\\n    private void fillSubstringBy(int left, int right, char c) {\\n        for (int i = left; i <= right; i++) {\\n            result[i] = c;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630599,
                "title": "c-efficent-o-n-time-o-1-space-solution-18ms",
                "content": "Testing the various corner cases is a challenge, but a essentially I grouped the string into substrings [left, right] where _right_ is the index of the next action (\\'R\\' or \\'L\\') and _left_ maybe an action.\\n\\nDepending on the which state, the return can be `memset` for quick performance;\\n|dominoes[left]|dominoes[right]|result|\\n|---|---|---|\\n|`R`|`R`|Everything between _left_ and _right_ gets filled with `R` and _left_ is set to _right_|\\n|`.`|`R`|Everything upto _right_ gets filled with `.` and _left_ is set to _right_|\\n|`L`|`R`|Everything after _left_ upto _right_ gets filled with `.` and _left_ is set to _right_|\\n|`R`|`L`|They will meet in the middle. Fill first half with `R` then add a `.` if the gap between them is odd, before filling the rest with `L`|\\n|`.` or `L`|`L`|Fill _left_ to _right_ with `L` and set _left_ to just after _right_|\\n\\nThere is some bonus, corner cases to do with the start and end, but not too much trouble. The resulting code is not a pretty as I would like, but runs fast;\\n\\n```c\\nchar * pushDominoes(char * dominoes) {\\n\\tsize_t len = strlen(dominoes);\\n\\tchar* const ret = malloc(len + 1);\\n\\tret[len] = \\'\\\\0\\';\\n\\n\\tint left = 0;\\n\\twhile (left < len) {\\n\\t\\t/* Find the next interesting action */\\n\\t\\tint right = left + 1;\\n\\t\\twhile (right < len && \\'.\\' == dominoes[right]) {\\n\\t\\t\\t++right;\\n\\t\\t}\\n\\t\\tif (right == len) { /* No other movements found before the end */\\n\\t\\t\\tret[left] = dominoes[left];\\n\\t\\t\\tmemset(&ret[left + 1], (\\'R\\' == dominoes[left]) ? \\'R\\' : \\'.\\', right - left - 1);\\n\\t\\t\\tbreak;\\n\\t\\t} else if (\\'R\\' == dominoes[right]) {\\n\\t\\t\\tret[left] = dominoes[left];\\n\\t\\t\\tmemset(&ret[left + 1], (\\'R\\' == dominoes[left]) ? \\'R\\' : \\'.\\', right - left - 1);\\n\\t\\t\\tleft = right;\\n\\t\\t} else if (\\'L\\' == dominoes[right]) { /* Dominoes will be toppling left */\\n\\t\\t\\tint pos = left;\\n\\t\\t\\tif (\\'R\\' == dominoes[left]) { /* Dominoes will be toppling right too */\\n\\t\\t\\t\\tint half = (right - left + 1) / 2;\\n\\t\\t\\t\\tmemset(&ret[pos], \\'R\\', half);\\n\\t\\t\\t\\tpos += half;\\n\\t\\t\\t\\tif (0 == (right - left) % 2) { /* Is there a domino in the middle */\\n\\t\\t\\t\\t\\tret[pos++] = \\'.\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmemset(&ret[pos], \\'L\\', right - pos + 1);\\n\\t\\t\\tleft = right + 1;    \\n\\t  }\\n  }\\n  return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\nchar * pushDominoes(char * dominoes) {\\n\\tsize_t len = strlen(dominoes);\\n\\tchar* const ret = malloc(len + 1);\\n\\tret[len] = \\'\\\\0\\';\\n\\n\\tint left = 0;\\n\\twhile (left < len) {\\n\\t\\t/* Find the next interesting action */\\n\\t\\tint right = left + 1;\\n\\t\\twhile (right < len && \\'.\\' == dominoes[right]) {\\n\\t\\t\\t++right;\\n\\t\\t}\\n\\t\\tif (right == len) { /* No other movements found before the end */\\n\\t\\t\\tret[left] = dominoes[left];\\n\\t\\t\\tmemset(&ret[left + 1], (\\'R\\' == dominoes[left]) ? \\'R\\' : \\'.\\', right - left - 1);\\n\\t\\t\\tbreak;\\n\\t\\t} else if (\\'R\\' == dominoes[right]) {\\n\\t\\t\\tret[left] = dominoes[left];\\n\\t\\t\\tmemset(&ret[left + 1], (\\'R\\' == dominoes[left]) ? \\'R\\' : \\'.\\', right - left - 1);\\n\\t\\t\\tleft = right;\\n\\t\\t} else if (\\'L\\' == dominoes[right]) { /* Dominoes will be toppling left */\\n\\t\\t\\tint pos = left;\\n\\t\\t\\tif (\\'R\\' == dominoes[left]) { /* Dominoes will be toppling right too */\\n\\t\\t\\t\\tint half = (right - left + 1) / 2;\\n\\t\\t\\t\\tmemset(&ret[pos], \\'R\\', half);\\n\\t\\t\\t\\tpos += half;\\n\\t\\t\\t\\tif (0 == (right - left) % 2) { /* Is there a domino in the middle */\\n\\t\\t\\t\\t\\tret[pos++] = \\'.\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmemset(&ret[pos], \\'L\\', right - pos + 1);\\n\\t\\t\\tleft = right + 1;    \\n\\t  }\\n  }\\n  return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630536,
                "title": "javascript-queue-tc-o-n-sc-o-n",
                "content": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    const dom = dominoes.split(\\'\\');\\n    const n = dom.length;\\n    let queue = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (dom[i] !== \\'.\\') {\\n            queue.push([i, dom[i]]);\\n        }\\n    }\\n    \\n    while (queue.length) {\\n        const next = [];\\n        \\n        for (let idx = 0; idx < queue.length; idx++) {\\n            const [i, d] = queue[idx];\\n            if (d === \\'L\\' && i > 0 && dom[i - 1] === \\'.\\') {\\n                next.push([i - 1, \\'L\\']);\\n                dom[i - 1] = \\'L\\';\\n            } else if (d === \\'R\\' && i + 1 < n && dom[i + 1] === \\'.\\') {\\n                if (i + 2 < n && dom[i + 2] === \\'L\\') {\\n                    idx++;\\n                } else {\\n                    next.push([i + 1, \\'R\\']);\\n                    dom[i + 1] = \\'R\\';\\n                }\\n            }\\n        }\\n        \\n        queue = next;\\n    }\\n    \\n    return dom.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    const dom = dominoes.split(\\'\\');\\n    const n = dom.length;\\n    let queue = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (dom[i] !== \\'.\\') {\\n            queue.push([i, dom[i]]);\\n        }\\n    }\\n    \\n    while (queue.length) {\\n        const next = [];\\n        \\n        for (let idx = 0; idx < queue.length; idx++) {\\n            const [i, d] = queue[idx];\\n            if (d === \\'L\\' && i > 0 && dom[i - 1] === \\'.\\') {\\n                next.push([i - 1, \\'L\\']);\\n                dom[i - 1] = \\'L\\';\\n            } else if (d === \\'R\\' && i + 1 < n && dom[i + 1] === \\'.\\') {\\n                if (i + 2 < n && dom[i + 2] === \\'L\\') {\\n                    idx++;\\n                } else {\\n                    next.push([i + 1, \\'R\\']);\\n                    dom[i + 1] = \\'R\\';\\n                }\\n            }\\n        }\\n        \\n        queue = next;\\n    }\\n    \\n    return dom.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630439,
                "title": "python-neetcode-queue-traversal",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        \\n        q=deque()\\n        dominoes=list(dominoes)\\n        for a,i in enumerate(dominoes):\\n            if i==\"L\"or i==\"R\":\\n                q.append((i,a))\\n                \\n        # print(q)\\n                \\n        while(q):\\n            val,ind=q.popleft()\\n            \\n            if val==\"R\" and ind+1<len(dominoes) and dominoes[ind+1]==\".\":\\n                if q and q[0][0]==\"L\" and ind+2==q[0][1]:\\n                    q.popleft()\\n                else:\\n                    dominoes[ind+1]=\"R\"\\n                    q.append((\"R\",ind+1))\\n                    \\n                    \\n            elif val==\"L\" and ind>0 and dominoes[ind-1]==\".\":\\n                dominoes[ind-1]=\"L\"\\n                q.append((\"L\",ind-1))\\n                \\n        return \"\".join(dominoes)\\n                \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        \\n        q=deque()\\n        dominoes=list(dominoes)\\n        for a,i in enumerate(dominoes):\\n            if i==\"L\"or i==\"R\":\\n                q.append((i,a))\\n                \\n        # print(q)\\n                \\n        while(q):\\n            val,ind=q.popleft()\\n            \\n            if val==\"R\" and ind+1<len(dominoes) and dominoes[ind+1]==\".\":\\n                if q and q[0][0]==\"L\" and ind+2==q[0][1]:\\n                    q.popleft()\\n                else:\\n                    dominoes[ind+1]=\"R\"\\n                    q.append((\"R\",ind+1))\\n                    \\n                    \\n            elif val==\"L\" and ind>0 and dominoes[ind-1]==\".\":\\n                dominoes[ind-1]=\"L\"\\n                q.append((\"L\",ind-1))\\n                \\n        return \"\".join(dominoes)\\n                \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630357,
                "title": "c-very-easy-solution-tc-o-n",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string d) {\\n\\t\\t\\tint right=-1;\\n\\t\\t\\tstring s=\"\";\\n\\t\\t\\tvector<pair<int,int>>v;\\n\\t\\t\\tfor(int i=0;i<d.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ts+=\\'.\\';\\n\\t\\t\\t\\tif(d[i]==\\'R\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tright=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(right!=-1 && d[i]==\\'L\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back({right,i});\\n\\t\\t\\t\\t\\tfor(int j=right;j<=i;j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\td[j]=\\'-\\';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tright=-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// In vector of pair we store the indexes which are right and immediate left after right \\n\\t\\t\\t// we store vector members and in between them with \\'-\\' sign to differentiate them \\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint a=v[i].first,b=v[i].second;\\n\\t\\t\\t\\t//cout<<a<<\" \"<<b<<endl;\\n\\t\\t\\t\\twhile(a<b)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts[a]=\\'R\\';\\n\\t\\t\\t\\t\\ts[b]=\\'L\\';\\n\\t\\t\\t\\t\\ta++;\\n\\t\\t\\t\\t\\tb--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// we store the positions of vector members in the another string\\n\\t\\t\\tfor(int i=0;i<d.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(d[i]==\\'R\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint x=i;\\n\\t\\t\\t\\t\\twhile(x<d.size() && d[x]!=\\'-\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts[x]=\\'R\\';\\n\\t\\t\\t\\t\\t\\tx++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ti=x;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// traverse from right whichever comes right goes to right before the vector members\\n\\t\\t\\tfor(int i=d.size()-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(d[i]==\\'L\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint x=i;\\n\\t\\t\\t\\t\\twhile(x>=0 && d[x]!=\\'-\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts[x]=\\'L\\';\\n\\t\\t\\t\\t\\t\\tx--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ti=x;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t    // traverse from left whichever comes left goes to left before the vector members\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string d) {\\n\\t\\t\\tint right=-1;\\n\\t\\t\\tstring s=\"\";\\n\\t\\t\\tvector<pair<int,int>>v;\\n\\t\\t\\tfor(int i=0;i<d.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ts+=\\'.\\';\\n\\t\\t\\t\\tif(d[i]==\\'R\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tright=i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2630300,
                "title": "c-simple-array-question",
                "content": "\"\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        \\n        string ans;\\n        int n=dominoes.size();\\n        int left[n],right[n];\\n        int cnt=1;\\n        int i=0;\\n        while(i<n){\\n            if(cnt==1 && dominoes[i]==\\'.\\')left[i]=0;\\n            else{\\n                if(dominoes[i]==\\'R\\'){\\n                    left[i]=cnt;\\n                    cnt=2;\\n                }else if(dominoes[i]==\\'.\\'){\\n                    left[i]=cnt;\\n                    cnt++;\\n                }else{\\n                    left[i]=0;\\n                    cnt=1;\\n                }\\n            }\\n            i++;\\n        }\\n        i=n-1;\\n        cnt=1;\\n        while(i>=0){\\n            if(cnt==1 && dominoes[i]==\\'.\\')right[i]=0;\\n            else{\\n               if(dominoes[i]==\\'L\\'){\\n                    right[i]=cnt;\\n                    cnt=2;\\n                }else if(dominoes[i]==\\'.\\'){\\n                    right[i]=cnt;\\n                    cnt++;\\n                }else{\\n                    right[i]=0;\\n                    cnt=1;\\n                }\\n            }\\n            i--;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(left[i]==0 && right[i]!=0)ans+=\\'L\\';\\n            else if(left[i]!=0 && right[i]==0)ans+=\\'R\\';\\n            else if(left[i]==0 && right[i]==0 || (left[i]==right[i]))ans+=dominoes[i];\\n            else if(left[i]!=0 && right[i]!=0 && (left[i]!=right[i])){\\n                if(left[i]>right[i])ans+=\\'L\\';\\n                else ans+=\\'R\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\"",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        \\n        string ans;\\n        int n=dominoes.size();\\n        int left[n],right[n];\\n        int cnt=1;\\n        int i=0;\\n        while(i<n){\\n            if(cnt==1 && dominoes[i]==\\'.\\')left[i]=0;\\n            else{\\n                if(dominoes[i]==\\'R\\'){\\n                    left[i]=cnt;\\n                    cnt=2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2630288,
                "title": "c-faster-than-99-31-two-pointer-detailed-explanation",
                "content": "Maintain two pointers **start** and **end**, and there are four cases:\\n**1. start = \\'L\\' & end = \\'R\\':** \\n* In this case, the dominoes in between these will not fall\\n* Ex: **L....R** , ans = **L....R**\\n\\n**2. start = \\'R\\' & end = \\'L\\'**\\n* In this case, the dominoes in between will fall in such a way that:\\n\\t* Dominoes near \\'R\\' will fall toward right\\n\\t* Dominoes near \\'L\\' will fall toward left\\n\\t* If there is a middle domino, it doesn\\'t fall as the forces are balanced\\n\\t* Ex1: **R..L**, ans = **RRLL**\\n\\t* Ex2: **R...L**, ans = **RR.LL**\\n\\n**3. start = \\'L & end = \\'L\\'**\\n* In this case, all the dominoes in between will fall toward left, due to the force from end domino\\n* Ex: **L...L**, ans = **LLLLL**\\n\\t\\n**4. start = \\'R\\' & end = \\'R\\'**\\n* In this case, all the dominoes in between will fall toward right, due to the force from start domino\\n* Ex: **R...R**, ans = **RRRRR**\\n\\n**Note:** Consider there is a \\'L\\' domino in the beginning and a \\'R\\' domino in the ending (adding these will not affect the answer, and it is easy for maintaining pointers. Take a few examples and you\\'ll understand this)\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n\\t\\t// Adding a domino at the end\\n        dominoes.push_back(\\'R\\');\\n\\t\\t\\n\\t\\t// Consider, there is a \\'L\\' domino at the begin\\n        int startInd = -1;\\n        char start = \\'L\\';\\n            \\n        for(int i=0; i<dominoes.size(); i++){\\n            int endInd = i;\\n            char end = dominoes[i];\\n\\t\\t\\t\\n            if(end == \\'.\\'){\\n                continue;\\n            }\\n            \\n            if(start == \\'L\\' && end == \\'R\\'){\\n                // Do nothing\\n            }\\n            else if(start == \\'R\\' && end == \\'L\\'){\\n                int len = endInd-startInd+1;\\n                int l = startInd+1, r = endInd-1;\\n                while(l<=r){\\n\\t\\t\\t\\t\\t// Middle domino\\n                    if(l == r){\\n                        dominoes[l++] = \\'.\\';\\n                    }\\n                    else{\\n                        dominoes[l++] = \\'R\\';\\n                        dominoes[r--] = \\'L\\';\\n                    }\\n                }\\n            }\\n            else if(start == \\'L\\' && end == \\'L\\'){\\n                int ind = endInd-1;\\n                while(ind > startInd){\\n                    dominoes[ind--] = \\'L\\';\\n                }\\n            }\\n            else{\\n                int ind = startInd+1;\\n                while(ind < endInd){\\n                    dominoes[ind++] = \\'R\\';\\n                }\\n            }\\n            start = end;\\n            startInd = endInd;\\n        }\\n        \\n\\t\\t// Removing the domino added at the end\\n        dominoes.pop_back();\\n        return dominoes;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n\\t\\t// Adding a domino at the end\\n        dominoes.push_back(\\'R\\');\\n\\t\\t\\n\\t\\t// Consider, there is a \\'L\\' domino at the begin\\n        int startInd = -1;\\n        char start = \\'L\\';\\n            \\n        for(int i=0; i<dominoes.size(); i++){\\n            int endInd = i;\\n            char end = dominoes[i];\\n\\t\\t\\t\\n            if(end == \\'.\\'){\\n                continue;\\n            }\\n            \\n            if(start == \\'L\\' && end == \\'R\\'){\\n                // Do nothing\\n            }\\n            else if(start == \\'R\\' && end == \\'L\\'){\\n                int len = endInd-startInd+1;\\n                int l = startInd+1, r = endInd-1;\\n                while(l<=r){\\n\\t\\t\\t\\t\\t// Middle domino\\n                    if(l == r){\\n                        dominoes[l++] = \\'.\\';\\n                    }\\n                    else{\\n                        dominoes[l++] = \\'R\\';\\n                        dominoes[r--] = \\'L\\';\\n                    }\\n                }\\n            }\\n            else if(start == \\'L\\' && end == \\'L\\'){\\n                int ind = endInd-1;\\n                while(ind > startInd){\\n                    dominoes[ind--] = \\'L\\';\\n                }\\n            }\\n            else{\\n                int ind = startInd+1;\\n                while(ind < endInd){\\n                    dominoes[ind++] = \\'R\\';\\n                }\\n            }\\n            start = end;\\n            startInd = endInd;\\n        }\\n        \\n\\t\\t// Removing the domino added at the end\\n        dominoes.pop_back();\\n        return dominoes;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2630188,
                "title": "golang-with-two-pointers-and-comments-description",
                "content": "![image](https://assets.leetcode.com/users/images/a7d8cda3-80ac-441e-9f9a-3f5d5e8b6501_1664273362.031908.png)\\nthough it meets timelimit often, but still can pass\\nfailing testcase:\\nhttps://leetcode.com/submissions/detail/809710021/testcase/\\n\\n```\\nfunc pushDominoes(dominoes string) string {\\n    // if len is 0 or 1 nothing can be changed, return input\\n    if len(dominoes) <= 1 || !strings.ContainsRune(dominoes, \\'.\\'){\\n        return dominoes\\n    }\\n    \\n    left := 0\\n    // looking for first non-\".\" character\\n    right, lc := nextChar(dominoes)\\n    if right < 0 { // if not found, return input\\n        return dominoes\\n    }\\n    \\n    if lc == \"L\" { // if first \"L\", all on the left should be \"L\"\\n        dominoes = strings.Replace(dominoes, \".\", \"L\", right)\\n    } \\n    \\n    res := dominoes[:right+1] // copy part till first non-\".\" with needed replacement\\n    // fmt.Println(\"res before = \", res)\\n\\n    rc := lc\\n    finish := true // flag to understand if we still have what to repeat, can be replaced with check of \"res\" length\\n    for finish{\\n        finish = false\\n        lc = rc\\n        left += right+1\\n        // fmt.Println(\"dominoes[left:] = \", dominoes[left:])\\n        right, rc = nextChar(dominoes[left:])\\n        if right < 0 && lc == \"L\" { // if last char was \"L\" the rest is \".\" without changes\\n            res += strings.Repeat(\".\", len(dominoes) - left)\\n            // fmt.Println(\"break L\")\\n            break\\n        } else if right < 0 && lc == \"R\" { // if last char was \"R\" the rest is \"R\" \\n            // fmt.Println(\"break R\")\\n            res += strings.Repeat(\"R\", len(dominoes) - left)\\n            break\\n        } else if rc == lc { // if same like \"L..L\" or \"R..R\", all between should be same\\n            // fmt.Println(\"replaced same\")\\n            res += strings.Repeat(rc, right+1)\\n            // fmt.Println(\"res after replaced same = \", res)\\n            finish = true\\n        } else if lc == \"R\" && rc == \"L\"  { // if kind of \"R..L\", then half \"R\" and half \"L\" => \"RRLL\"\\n            half := right / 2\\n            res += strings.Repeat(lc, half)\\n            if right % 2 == 1 { // if odd, then middle isn\\'t changed: \"R...L\" => \"RR.LL\"\\n                res += \".\"\\n            }\\n            res += strings.Repeat(rc, half+1) // additionally copy right \"L\"\\n            // fmt.Println(\"replaced halfs\")\\n            finish = true\\n        } else { //in case of \"L..R\" copy with no changes\\n            res += dominoes[left:left+right+1]\\n            // fmt.Println(\"copy with no changes between L and R\")\\n            // fmt.Println(\"res after copy with no changes = \", res)\\n            finish = true\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc nextChar(s string)(int, string){\\n    leftL := strings.IndexByte(s,\\'L\\')\\n    leftR := strings.IndexByte(s,\\'R\\')\\n    if leftL>=0 && leftL < leftR || leftL>=0 && leftR<0{\\n        // fmt.Println(\"next = \", leftL,string(s[leftL]))\\n        return leftL,string(s[leftL])\\n    } else if leftR>=0 {\\n        // fmt.Println(\"next = \", leftR,string(s[leftR]))\\n            return leftR,string(s[leftR])\\n    } else {\\n        // fmt.Println(\"next = \", -1, \"\")\\n        return -1,\"\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pushDominoes(dominoes string) string {\\n    // if len is 0 or 1 nothing can be changed, return input\\n    if len(dominoes) <= 1 || !strings.ContainsRune(dominoes, \\'.\\'){\\n        return dominoes\\n    }\\n    \\n    left := 0\\n    // looking for first non-\".\" character\\n    right, lc := nextChar(dominoes)\\n    if right < 0 { // if not found, return input\\n        return dominoes\\n    }\\n    \\n    if lc == \"L\" { // if first \"L\", all on the left should be \"L\"\\n        dominoes = strings.Replace(dominoes, \".\", \"L\", right)\\n    } \\n    \\n    res := dominoes[:right+1] // copy part till first non-\".\" with needed replacement\\n    // fmt.Println(\"res before = \", res)\\n\\n    rc := lc\\n    finish := true // flag to understand if we still have what to repeat, can be replaced with check of \"res\" length\\n    for finish{\\n        finish = false\\n        lc = rc\\n        left += right+1\\n        // fmt.Println(\"dominoes[left:] = \", dominoes[left:])\\n        right, rc = nextChar(dominoes[left:])\\n        if right < 0 && lc == \"L\" { // if last char was \"L\" the rest is \".\" without changes\\n            res += strings.Repeat(\".\", len(dominoes) - left)\\n            // fmt.Println(\"break L\")\\n            break\\n        } else if right < 0 && lc == \"R\" { // if last char was \"R\" the rest is \"R\" \\n            // fmt.Println(\"break R\")\\n            res += strings.Repeat(\"R\", len(dominoes) - left)\\n            break\\n        } else if rc == lc { // if same like \"L..L\" or \"R..R\", all between should be same\\n            // fmt.Println(\"replaced same\")\\n            res += strings.Repeat(rc, right+1)\\n            // fmt.Println(\"res after replaced same = \", res)\\n            finish = true\\n        } else if lc == \"R\" && rc == \"L\"  { // if kind of \"R..L\", then half \"R\" and half \"L\" => \"RRLL\"\\n            half := right / 2\\n            res += strings.Repeat(lc, half)\\n            if right % 2 == 1 { // if odd, then middle isn\\'t changed: \"R...L\" => \"RR.LL\"\\n                res += \".\"\\n            }\\n            res += strings.Repeat(rc, half+1) // additionally copy right \"L\"\\n            // fmt.Println(\"replaced halfs\")\\n            finish = true\\n        } else { //in case of \"L..R\" copy with no changes\\n            res += dominoes[left:left+right+1]\\n            // fmt.Println(\"copy with no changes between L and R\")\\n            // fmt.Println(\"res after copy with no changes = \", res)\\n            finish = true\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc nextChar(s string)(int, string){\\n    leftL := strings.IndexByte(s,\\'L\\')\\n    leftR := strings.IndexByte(s,\\'R\\')\\n    if leftL>=0 && leftL < leftR || leftL>=0 && leftR<0{\\n        // fmt.Println(\"next = \", leftL,string(s[leftL]))\\n        return leftL,string(s[leftL])\\n    } else if leftR>=0 {\\n        // fmt.Println(\"next = \", leftR,string(s[leftR]))\\n            return leftR,string(s[leftR])\\n    } else {\\n        // fmt.Println(\"next = \", -1, \"\")\\n        return -1,\"\"\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630158,
                "title": "golang-two-pointers",
                "content": "```\\nfunc pushDominoes(dominoes string) string {\\n    arr := make([]byte, len(dominoes)+2)\\n    N := len(arr)\\n    arr[0] = \\'L\\'\\n    arr[N-1] = \\'R\\'\\n    for i := 0; i < len(dominoes); i++ {\\n        arr[i+1] = dominoes[i]\\n    }\\n    \\n    start := 0\\n    for end := 0; end < N; end++ {\\n        if arr[end] != \\'.\\' {\\n            convert(arr, start, end)\\n            start = end\\n        }\\n    }\\n    \\n    return string(arr[1:N-1])\\n}\\n\\nfunc convert(arr []byte, start, end int) {\\n    if arr[start] == arr[end] {\\n        // Case of L...L or R....R\\n        for i := start+1; i < end; i++ {\\n            arr[i] = arr[start]\\n        }\\n    } else if arr[start] == \\'R\\' && arr[end] == \\'L\\' {\\n        // Case of R...L\\n        for i := start+1; i < end; i++ {\\n            if i-start < end-i {\\n                arr[i] = arr[start]\\n            } else if i-start > end-i {\\n                arr[i] = arr[end]\\n            } /* else {\\n                // If i is equal distance from start and end, leave it \\'.\\'\\n            } */\\n        }\\n    } /* else {\\n        // Case of L...R\\n        // Nothing needs to be done\\n    } */\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pushDominoes(dominoes string) string {\\n    arr := make([]byte, len(dominoes)+2)\\n    N := len(arr)\\n    arr[0] = \\'L\\'\\n    arr[N-1] = \\'R\\'\\n    for i := 0; i < len(dominoes); i++ {\\n        arr[i+1] = dominoes[i]\\n    }\\n    \\n    start := 0\\n    for end := 0; end < N; end++ {\\n        if arr[end] != \\'.\\' {\\n            convert(arr, start, end)\\n            start = end\\n        }\\n    }\\n    \\n    return string(arr[1:N-1])\\n}\\n\\nfunc convert(arr []byte, start, end int) {\\n    if arr[start] == arr[end] {\\n        // Case of L...L or R....R\\n        for i := start+1; i < end; i++ {\\n            arr[i] = arr[start]\\n        }\\n    } else if arr[start] == \\'R\\' && arr[end] == \\'L\\' {\\n        // Case of R...L\\n        for i := start+1; i < end; i++ {\\n            if i-start < end-i {\\n                arr[i] = arr[start]\\n            } else if i-start > end-i {\\n                arr[i] = arr[end]\\n            } /* else {\\n                // If i is equal distance from start and end, leave it \\'.\\'\\n            } */\\n        }\\n    } /* else {\\n        // Case of L...R\\n        // Nothing needs to be done\\n    } */\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630084,
                "title": "topic-just-for-creating-link-for-my-friend",
                "content": "```\\nvar pushDominoes = function(dominoes) {\\n  const arr = dominoes.split(\"\");\\n  \\n  let currStart = 0;\\n  let pushedToRight = false;\\n  \\n  for (let i=0; i < arr.length; i++) {\\n    if (arr[i] === \"L\" && !pushedToRight) {\\n      for (let j = currStart; j < i; j++) {\\n        arr[j] = \"L\";\\n      }\\n      currStart = i + 1;\\n    } else if (arr[i] === \"L\" && pushedToRight) {\\n      const qnty = i - currStart - 1;\\n      if (qnty % 2 ) {\\n        for (let j=currStart+1; j<currStart+Math.round(qnty/2); j++) {\\n          arr[j] = \"R\";\\n        }\\n        for (let j=i-1; j>i-Math.round(qnty/2); j--) {\\n          arr[j] = \"L\";\\n        }\\n      } else {\\n        for (let j=currStart+1; j<currStart+qnty/2+1; j++) {\\n          arr[j] = \"R\";\\n        }\\n        for (let j=i-1; j>i-qnty/2-1; j--) {\\n          arr[j] = \"L\";\\n        }\\n      }\\n      currStart = i + 1;\\n      pushedToRight = false;\\n    } else if (arr[i] === \"R\") {\\n      if (pushedToRight) {\\n        for (let j=currStart; j<i; j++) {\\n          arr[j] = \"R\";\\n        }\\n      }\\n      pushedToRight = true;\\n      currStart = i;\\n    } else {\\n      if (i === arr.length-1 && pushedToRight) {\\n        for (let j=currStart+1; j<arr.length; j++) {\\n          arr[j] = \"R\"\\n        }\\n      }\\n    }\\n  }\\n  return arr.join(\"\");\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar pushDominoes = function(dominoes) {\\n  const arr = dominoes.split(\"\");\\n  \\n  let currStart = 0;\\n  let pushedToRight = false;\\n  \\n  for (let i=0; i < arr.length; i++) {\\n    if (arr[i] === \"L\" && !pushedToRight) {\\n      for (let j = currStart; j < i; j++) {\\n        arr[j] = \"L\";\\n      }\\n      currStart = i + 1;\\n    } else if (arr[i] === \"L\" && pushedToRight) {\\n      const qnty = i - currStart - 1;\\n      if (qnty % 2 ) {\\n        for (let j=currStart+1; j<currStart+Math.round(qnty/2); j++) {\\n          arr[j] = \"R\";\\n        }\\n        for (let j=i-1; j>i-Math.round(qnty/2); j--) {\\n          arr[j] = \"L\";\\n        }\\n      } else {\\n        for (let j=currStart+1; j<currStart+qnty/2+1; j++) {\\n          arr[j] = \"R\";\\n        }\\n        for (let j=i-1; j>i-qnty/2-1; j--) {\\n          arr[j] = \"L\";\\n        }\\n      }\\n      currStart = i + 1;\\n      pushedToRight = false;\\n    } else if (arr[i] === \"R\") {\\n      if (pushedToRight) {\\n        for (let j=currStart; j<i; j++) {\\n          arr[j] = \"R\";\\n        }\\n      }\\n      pushedToRight = true;\\n      currStart = i;\\n    } else {\\n      if (i === arr.length-1 && pushedToRight) {\\n        for (let j=currStart+1; j<arr.length; j++) {\\n          arr[j] = \"R\"\\n        }\\n      }\\n    }\\n  }\\n  return arr.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629925,
                "title": "easy-to-understand-beginners-approach",
                "content": "Check the commented example inside code for better understanding. 1st iteration from left to right is for right push only and 2nd iteration from right to left is for left push only.\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        vector<int> t1;\\n        vector<int> t2;\\n        int c1=1;\\n        int c2=1;\\n        int n = d.length();\\n        int i=0;\\n        while(i<n)\\n        {\\n            c1=1;\\n            if(d[i]==\\'R\\')\\n            {\\n                t1.push_back(0);\\n                while(i+1<n && d[i+1]==\\'.\\'){\\n                    t1.push_back(c1);\\n                    c1++;\\n                    i++;\\n                }\\n            }\\n            else{\\n                t1.push_back(0);\\n            }\\n            i++;\\n        }\\n        i = n-1;\\n        while(i>=0)\\n        {\\n            c2= 1;\\n            if(d[i]==\\'L\\')\\n            {\\n                t2.push_back(0);\\n                while(i-1>=0 && d[i-1]==\\'.\\'){\\n                    t2.push_back(c2);\\n                    c2++;\\n                    i--;\\n                }\\n            }\\n            else{\\n                t2.push_back(0);\\n            }\\n            i--;\\n        }\\n        reverse(t2.begin(),t2.end());\\n        string ans = \"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(t1[i]==t2[i] && t1[i]!=0){\\n                ans+=\\'.\\';\\n            }\\n            else if(t1[i]<t2[i]){\\n                if(t1[i]==0)\\n                {\\n                    ans+=\\'L\\';\\n                }\\n                else{\\n                    ans+=\\'R\\';\\n                }\\n            }\\n            else if(t1[i]>t2[i]){\\n                if(t2[i]==0)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n                else{\\n                    ans+=\\'L\\';\\n                }\\n            }\\n            else{\\n                ans+=d[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// . L . R 1R 2R 3R L R 1R 2R L . .\\n// L L . R 3L 2L 1L L R 2L 1L L . . \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        vector<int> t1;\\n        vector<int> t2;\\n        int c1=1;\\n        int c2=1;\\n        int n = d.length();\\n        int i=0;\\n        while(i<n)\\n        {\\n            c1=1;\\n            if(d[i]==\\'R\\')\\n            {\\n                t1.push_back(0);\\n                while(i+1<n && d[i+1]==\\'.\\'){\\n                    t1.push_back(c1);\\n                    c1++;\\n                    i++;\\n                }\\n            }\\n            else{\\n                t1.push_back(0);\\n            }\\n            i++;\\n        }\\n        i = n-1;\\n        while(i>=0)\\n        {\\n            c2= 1;\\n            if(d[i]==\\'L\\')\\n            {\\n                t2.push_back(0);\\n                while(i-1>=0 && d[i-1]==\\'.\\'){\\n                    t2.push_back(c2);\\n                    c2++;\\n                    i--;\\n                }\\n            }\\n            else{\\n                t2.push_back(0);\\n            }\\n            i--;\\n        }\\n        reverse(t2.begin(),t2.end());\\n        string ans = \"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(t1[i]==t2[i] && t1[i]!=0){\\n                ans+=\\'.\\';\\n            }\\n            else if(t1[i]<t2[i]){\\n                if(t1[i]==0)\\n                {\\n                    ans+=\\'L\\';\\n                }\\n                else{\\n                    ans+=\\'R\\';\\n                }\\n            }\\n            else if(t1[i]>t2[i]){\\n                if(t2[i]==0)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n                else{\\n                    ans+=\\'L\\';\\n                }\\n            }\\n            else{\\n                ans+=d[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// . L . R 1R 2R 3R L R 1R 2R L . .\\n// L L . R 3L 2L 1L L R 2L 1L L . . \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629886,
                "title": "go-dynamic-programming",
                "content": "```\\nfunc fall(l, c, r rune) rune {\\n\\tif c == \\'.\\' {\\n\\t\\tif l == \\'R\\' && r == \\'L\\' {\\n\\t\\t\\treturn \\'.\\'\\n\\t\\t}\\n\\t\\tif l == \\'R\\' {\\n\\t\\t\\treturn \\'R\\'\\n\\t\\t}\\n\\t\\tif r == \\'L\\' {\\n\\t\\t\\treturn \\'L\\'\\n\\t\\t}\\n\\t}\\n\\treturn c\\n}\\n\\nfunc pushIteration(dominoes string) string {\\n\\tresult := make([]rune, len(dominoes))\\n\\tif len(dominoes) == 1 {\\n\\t\\treturn dominoes\\n\\t}\\n\\tdominoesR := []rune(dominoes)\\n\\tfor i := 0; i < len(dominoesR); i++ {\\n\\t\\tswitch i {\\n\\t\\tcase 0:\\n\\t\\t\\tresult[i] = fall(\\'.\\', dominoesR[i], dominoesR[i+1])\\n\\t\\tcase len(dominoes) - 1:\\n\\t\\t\\tresult[i] = fall(dominoesR[i-1], dominoesR[i], \\'.\\')\\n\\t\\tdefault:\\n\\t\\t\\tresult[i] = fall(dominoesR[i-1], dominoesR[i], dominoesR[i+1])\\n\\t\\t}\\n\\t}\\n\\treturn string(result)\\n}\\n\\nfunc pushDominoes(dominoes string) string {\\n\\tpreviousIteration := pushIteration(dominoes)\\n\\tfor previousIteration != dominoes {\\n\\t\\tpreviousIteration = dominoes\\n\\t\\tdominoes = pushIteration(dominoes)\\n\\t}\\n\\treturn dominoes\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc fall(l, c, r rune) rune {\\n\\tif c == \\'.\\' {\\n\\t\\tif l == \\'R\\' && r == \\'L\\' {\\n\\t\\t\\treturn \\'.\\'\\n\\t\\t}\\n\\t\\tif l == \\'R\\' {\\n\\t\\t\\treturn \\'R\\'\\n\\t\\t}\\n\\t\\tif r == \\'L\\' {\\n\\t\\t\\treturn \\'L\\'\\n\\t\\t}\\n\\t}\\n\\treturn c\\n}\\n\\nfunc pushIteration(dominoes string) string {\\n\\tresult := make([]rune, len(dominoes))\\n\\tif len(dominoes) == 1 {\\n\\t\\treturn dominoes\\n\\t}\\n\\tdominoesR := []rune(dominoes)\\n\\tfor i := 0; i < len(dominoesR); i++ {\\n\\t\\tswitch i {\\n\\t\\tcase 0:\\n\\t\\t\\tresult[i] = fall(\\'.\\', dominoesR[i], dominoesR[i+1])\\n\\t\\tcase len(dominoes) - 1:\\n\\t\\t\\tresult[i] = fall(dominoesR[i-1], dominoesR[i], \\'.\\')\\n\\t\\tdefault:\\n\\t\\t\\tresult[i] = fall(dominoesR[i-1], dominoesR[i], dominoesR[i+1])\\n\\t\\t}\\n\\t}\\n\\treturn string(result)\\n}\\n\\nfunc pushDominoes(dominoes string) string {\\n\\tpreviousIteration := pushIteration(dominoes)\\n\\tfor previousIteration != dominoes {\\n\\t\\tpreviousIteration = dominoes\\n\\t\\tdominoes = pushIteration(dominoes)\\n\\t}\\n\\treturn dominoes\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629872,
                "title": "o-n-time",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        st=\".\"\\n        ct=0\\n        arr=[]\\n        for a in dominoes:\\n            if(a==\".\"):\\n                ct+=1\\n            elif(a==\"R\"):\\n                arr.append(st+str(ct))\\n                st=\"R\"\\n                ct=1\\n            elif(a==\"L\"):\\n                if(st==\"R\"):\\n                    ct+=1\\n                    arr.append(\"R\"+str(ct//2))\\n                    arr.append(\".\"+str(ct%2))\\n                    arr.append(\"L\"+str(ct//2))\\n                elif(st==\".\"):\\n                    arr.append(\"L\"+str(ct+1))\\n                ct=0\\n                st=\".\"\\n        arr.append(st+str(ct))\\n        # print(arr)\\n        ans=\"\"\\n        for a in arr:\\n            ans+=a[0]*int(a[1:])\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        st=\".\"\\n        ct=0\\n        arr=[]\\n        for a in dominoes:\\n            if(a==\".\"):\\n                ct+=1\\n            elif(a==\"R\"):\\n                arr.append(st+str(ct))\\n                st=\"R\"\\n                ct=1\\n            elif(a==\"L\"):\\n                if(st==\"R\"):\\n                    ct+=1\\n                    arr.append(\"R\"+str(ct//2))\\n                    arr.append(\".\"+str(ct%2))\\n                    arr.append(\"L\"+str(ct//2))\\n                elif(st==\".\"):\\n                    arr.append(\"L\"+str(ct+1))\\n                ct=0\\n                st=\".\"\\n        arr.append(st+str(ct))\\n        # print(arr)\\n        ans=\"\"\\n        for a in arr:\\n            ans+=a[0]*int(a[1:])\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629585,
                "title": "c-easy-momentum-physics-solution-o-n",
                "content": "**basically we give each domino a force vector which show how much force is applied in which direction. if value its negative its falling left and vice versa**\\n**its like equating all forces in mechanism**\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        \\n        vector<int> values(d.size(),0);\\n        for(int i=0;i<d.size();i++){\\n           if (d[i] == \\'R\\')\\n        {\\n           \\n            int val = d.size();\\n            values[i]=d.size()+1;\\n            int j = i + 1;\\n            while (j<d.size() && d[j] == \\'.\\')\\n            {\\n\\n                values[j] += val;\\n                val--;\\n                j++;\\n            }\\n        }\\n        if (d[i] == \\'L\\')\\n        {\\n            int val = -d.size();\\n            values[i] += (val-1);\\n            int j = i - 1;\\n\\n            while (j>=0 && d[j] == \\'.\\')\\n            {\\n\\n                values[j] += val;\\n                val++;\\n                j--;\\n            }\\n        }\\n        }\\n        for(int i=0;i<d.size();i++){\\n            if(values[i]<0){\\n                d[i]=\\'L\\';\\n            }\\n            else if(values[i]>0){\\n                d[i]=\\'R\\';\\n            }\\n            else{\\n                d[i]=\\'.\\';\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        \\n        vector<int> values(d.size(),0);\\n        for(int i=0;i<d.size();i++){\\n           if (d[i] == \\'R\\')\\n        {\\n           \\n            int val = d.size();\\n            values[i]=d.size()+1;\\n            int j = i + 1;\\n            while (j<d.size() && d[j] == \\'.\\')\\n            {\\n\\n                values[j] += val;\\n                val--;\\n                j++;\\n            }\\n        }\\n        if (d[i] == \\'L\\')\\n        {\\n            int val = -d.size();\\n            values[i] += (val-1);\\n            int j = i - 1;\\n\\n            while (j>=0 && d[j] == \\'.\\')\\n            {\\n\\n                values[j] += val;\\n                val++;\\n                j--;\\n            }\\n        }\\n        }\\n        for(int i=0;i<d.size();i++){\\n            if(values[i]<0){\\n                d[i]=\\'L\\';\\n            }\\n            else if(values[i]>0){\\n                d[i]=\\'R\\';\\n            }\\n            else{\\n                d[i]=\\'.\\';\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629493,
                "title": "c-easy-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> forces(n, 0);\\n        int force = 0;\\n        for(int i = 0; i < n; i++){\\n            if(dominoes[i] == \\'R\\') force = n;\\n            else if(dominoes[i] == \\'L\\') force = 0;\\n            else force = max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n        force = 0;\\n        for(int i = n-1; i >= 0; i--){\\n            if(dominoes[i] == \\'L\\') force = n;\\n            else if(dominoes[i] == \\'R\\') force = 0;\\n            else force = max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n        string ans;\\n        for(auto f : forces){\\n            ans.push_back(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> forces(n, 0);\\n        int force = 0;\\n        for(int i = 0; i < n; i++){\\n            if(dominoes[i] == \\'R\\') force = n;\\n            else if(dominoes[i] == \\'L\\') force = 0;\\n            else force = max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n        force = 0;\\n        for(int i = n-1; i >= 0; i--){\\n            if(dominoes[i] == \\'L\\') force = n;\\n            else if(dominoes[i] == \\'R\\') force = 0;\\n            else force = max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n        string ans;\\n        for(auto f : forces){\\n            ans.push_back(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629448,
                "title": "simple-c-solution-force-calculation-clean-code-o-n-2-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size();\\n        vector<int> force(n,0);\\n        \\n        int f=0;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'R\\') f = n;\\n            else if(s[i] == \\'L\\') f = 0;\\n            else f = max(f-1, 0);\\n            force[i] += f;\\n        }\\n        \\n        f=0;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(s[i] == \\'L\\') f = n;\\n            else if(s[i] == \\'R\\') f = 0;\\n            else f = max(f-1, 0);\\n            force[i] -= f;\\n        }\\n        \\n        s = \"\";\\n        for(int f : force) {\\n            if(f == 0) s+=\\'.\\';\\n            else if(f > 0) s+=\\'R\\';\\n            else s+=\\'L\\';\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size();\\n        vector<int> force(n,0);\\n        \\n        int f=0;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'R\\') f = n;\\n            else if(s[i] == \\'L\\') f = 0;\\n            else f = max(f-1, 0);\\n            force[i] += f;\\n        }\\n        \\n        f=0;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(s[i] == \\'L\\') f = n;\\n            else if(s[i] == \\'R\\') f = 0;\\n            else f = max(f-1, 0);\\n            force[i] -= f;\\n        }\\n        \\n        s = \"\";\\n        for(int f : force) {\\n            if(f == 0) s+=\\'.\\';\\n            else if(f > 0) s+=\\'R\\';\\n            else s+=\\'L\\';\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629446,
                "title": "2-way-traversal-solution-in-tc-o-n",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n=len(dominoes)\\n        dominoes=list(dominoes)\\n        flag=0\\n        for i in range(n-1,-1,-1):\\n            if dominoes[i]==\"L\":\\n                ct=1\\n                flag=1\\n            elif dominoes[i]==\".\" and flag==1:\\n                dominoes[i]=ct\\n                ct+=1\\n            elif dominoes[i]==\"R\":\\n                flag=0\\n            else:\\n                dominoes[i]=0\\n        flagr=0\\n        for i in range(n):\\n            if dominoes[i]==\"R\":\\n                ctr=1\\n                flagr=1\\n            elif str(dominoes[i]).isdigit() and flagr==1 and abs(ctr)<abs(dominoes[i]) or dominoes[i]==\".\":\\n                dominoes[i]=\"R\"\\n                ctr+=1\\n            elif str(dominoes[i]).isdigit() and flagr==1 and abs(ctr)==abs(dominoes[i]):\\n                dominoes[i]=\".\"\\n            elif flagr==1 and dominoes[i]==0:\\n                dominoes[i]=\"R\"\\n            elif dominoes[i]==\"L\":\\n                flagr=0\\n            elif dominoes[i]==0:\\n                dominoes[i]=\".\"\\n            else:\\n                dominoes[i]=\"L\"\\n        return \"\".join(dominoes)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n=len(dominoes)\\n        dominoes=list(dominoes)\\n        flag=0\\n        for i in range(n-1,-1,-1):\\n            if dominoes[i]==\"L\":\\n                ct=1\\n                flag=1\\n            elif dominoes[i]==\".\" and flag==1:\\n                dominoes[i]=ct\\n                ct+=1\\n            elif dominoes[i]==\"R\":\\n                flag=0\\n            else:\\n                dominoes[i]=0\\n        flagr=0\\n        for i in range(n):\\n            if dominoes[i]==\"R\":\\n                ctr=1\\n                flagr=1\\n            elif str(dominoes[i]).isdigit() and flagr==1 and abs(ctr)<abs(dominoes[i]) or dominoes[i]==\".\":\\n                dominoes[i]=\"R\"\\n                ctr+=1\\n            elif str(dominoes[i]).isdigit() and flagr==1 and abs(ctr)==abs(dominoes[i]):\\n                dominoes[i]=\".\"\\n            elif flagr==1 and dominoes[i]==0:\\n                dominoes[i]=\"R\"\\n            elif dominoes[i]==\"L\":\\n                flagr=0\\n            elif dominoes[i]==0:\\n                dominoes[i]=\".\"\\n            else:\\n                dominoes[i]=\"L\"\\n        return \"\".join(dominoes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629354,
                "title": "c-2-pointer-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> forces(n, 0);\\n        int temp = 0;\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            if(dominoes[i] == \\'R\\')\\n                temp = n;\\n            else if(dominoes[i] == \\'L\\')\\n                temp = 0;\\n            else\\n                temp = max(temp - 1, 0);\\n            forces[i] += temp;\\n        }\\n        temp = 0;\\n        for(int i = n - 1;i >= 0; i--)\\n        {\\n            if(dominoes[i] == \\'L\\')\\n                temp = n;\\n            else if(dominoes[i] == \\'R\\')\\n                temp = 0;\\n            else \\n                temp = max(temp - 1, 0);\\n            forces[i] -= temp;\\n        }\\n        string ans = \"\";\\n        for(int i = 0 ; i < forces.size(); i++)\\n        {\\n            if(forces[i] > 0)\\n                ans += \\'R\\';\\n            else if(forces[i] < 0)\\n                ans += \\'L\\';\\n            else \\n                ans += \\'.\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> forces(n, 0);\\n        int temp = 0;\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            if(dominoes[i] == \\'R\\')\\n                temp = n;\\n            else if(dominoes[i] == \\'L\\')\\n                temp = 0;\\n            else\\n                temp = max(temp - 1, 0);\\n            forces[i] += temp;\\n        }\\n        temp = 0;\\n        for(int i = n - 1;i >= 0; i--)\\n        {\\n            if(dominoes[i] == \\'L\\')\\n                temp = n;\\n            else if(dominoes[i] == \\'R\\')\\n                temp = 0;\\n            else \\n                temp = max(temp - 1, 0);\\n            forces[i] -= temp;\\n        }\\n        string ans = \"\";\\n        for(int i = 0 ; i < forces.size(); i++)\\n        {\\n            if(forces[i] > 0)\\n                ans += \\'R\\';\\n            else if(forces[i] < 0)\\n                ans += \\'L\\';\\n            else \\n                ans += \\'.\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629351,
                "title": "find-positions-of-r-l-easy-explanation",
                "content": "considerd the string \\n\\n\".L.R...LR..L..\"\\n\\nIf an R is followed by L then they will fall toward themselve\\nif an R is not followed by L then it will fall toward right (all domino after that index)\\nif an L is not backed by R then it wall fall toward left  (all domino before that index)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        string ans = \"\";\\n        vector<int> left; // store \\'L\\' index \\n        vector<int> right; // store \\'R\\' index\\n        vector<pair<int,int>> lr; // store R....L type index\\n         \\n        for(int i = 0;i<s.length();i++)\\n        {\\n                if(s[i] == \\'L\\') // L is not backed by and R\\n                        left.push_back(i);\\n                else if(s[i] == \\'R\\') // Here two condition exist, may be L is present after this or not present\\n                {\\n                   int x = i;    \\n                   int j = i;    \\n                   bool flag = false;     \\n                   for( j = i+1;j<s.length();j++)\\n                     if(s[j] ==\\'L\\') // If L is present then a pair is found\\n                     {\\n                             flag = true;\\n                             lr.push_back({x,j});\\n                             break;\\n                     }\\n                     else if(s[j] == \\'R\\') // If R is present after R then store in right index\\n                     {\\n                             right.push_back(x);\\n                             x = j;\\n                     }\\n                     if(!flag) right.push_back(x);  \\n                     i = j;       \\n                }\\n        }\\n        \\n        \\n        for(auto &[a,b] : lr) // Fire deal with R.....L type substring\\n        {\\n                int x = (a+b)/2;\\n                if((b-a+1)%2 != 0){\\n                for(int i = a;i<x;i++)\\n                        s[i] = \\'R\\';\\n                for(int i= x+1;i<b;i++)\\n                        s[i] = \\'L\\';\\n                }\\n                else\\n                {\\n                for(int i = a;i<=x;i++)\\n                        s[i] = \\'R\\';\\n                for(int i= x+1;i<b;i++)\\n                        s[i] = \\'L\\';        \\n                }\\n        }\\n     \\n        \\n        for(int i = 0;i<left.size();i++) // Dealing with \\'L\\' type substring\\n        {\\n                int j = left[i]-1;\\n                while(j >= 0 && s[j] == \\'.\\')\\n                        s[j--] = \\'L\\';\\n        }\\n         \\n        for(int i = right.size()-1;i>=0;i--) // Dealing with \\'R\\' type substring\\n        {\\n               int j = right[i]+1;\\n               while(j <s.size() && s[j] == \\'.\\')\\n                        s[j++] = \\'R\\'; \\n        }\\n        \\n\\n            \\n            \\n            \\n            return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        string ans = \"\";\\n        vector<int> left; // store \\'L\\' index \\n        vector<int> right; // store \\'R\\' index\\n        vector<pair<int,int>> lr; // store R....L type index\\n         \\n        for(int i = 0;i<s.length();i++)\\n        {\\n                if(s[i] == \\'L\\') // L is not backed by and R\\n                        left.push_back(i);\\n                else if(s[i] == \\'R\\') // Here two condition exist, may be L is present after this or not present\\n                {\\n                   int x = i;    \\n                   int j = i;    \\n                   bool flag = false;     \\n                   for( j = i+1;j<s.length();j++)\\n                     if(s[j] ==\\'L\\') // If L is present then a pair is found\\n                     {\\n                             flag = true;\\n                             lr.push_back({x,j});\\n                             break;\\n                     }\\n                     else if(s[j] == \\'R\\') // If R is present after R then store in right index\\n                     {\\n                             right.push_back(x);\\n                             x = j;\\n                     }\\n                     if(!flag) right.push_back(x);  \\n                     i = j;       \\n                }\\n        }\\n        \\n        \\n        for(auto &[a,b] : lr) // Fire deal with R.....L type substring\\n        {\\n                int x = (a+b)/2;\\n                if((b-a+1)%2 != 0){\\n                for(int i = a;i<x;i++)\\n                        s[i] = \\'R\\';\\n                for(int i= x+1;i<b;i++)\\n                        s[i] = \\'L\\';\\n                }\\n                else\\n                {\\n                for(int i = a;i<=x;i++)\\n                        s[i] = \\'R\\';\\n                for(int i= x+1;i<b;i++)\\n                        s[i] = \\'L\\';        \\n                }\\n        }\\n     \\n        \\n        for(int i = 0;i<left.size();i++) // Dealing with \\'L\\' type substring\\n        {\\n                int j = left[i]-1;\\n                while(j >= 0 && s[j] == \\'.\\')\\n                        s[j--] = \\'L\\';\\n        }\\n         \\n        for(int i = right.size()-1;i>=0;i--) // Dealing with \\'R\\' type substring\\n        {\\n               int j = right[i]+1;\\n               while(j <s.size() && s[j] == \\'.\\')\\n                        s[j++] = \\'R\\'; \\n        }\\n        \\n\\n            \\n            \\n            \\n            return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629263,
                "title": "java-easy-to-understand-well-commented-left-and-right-array-calculating-force",
                "content": "\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        // will calculate the force on every domino in this \\n        //+ve force means domino would fall right and -ve force means domino would fall left\\n        \\n        int n = dominoes.length(); //length of dominoes array and max. force that can be applied on any domino\\n        //calculate right force | +Ve force\\n        int force = 0;\\n        int[] forces = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(dominoes.charAt(i) == \\'R\\'){\\n                force = n;\\n            } else if(dominoes.charAt(i) == \\'L\\'){\\n                force = 0;\\n            }\\n            forces[i] = force;\\n            if(force == 0) continue;\\n            force--;\\n        }\\n        \\n        //calculate left force | -Ve force\\n        force = 0;  // starting force would be zero\\n        for(int i = n-1; i >= 0; i--){\\n            if(dominoes.charAt(i) == \\'L\\'){\\n                force = n;\\n            } else if(dominoes.charAt(i) == \\'R\\'){\\n                force = 0;\\n            }\\n            forces[i] -= force; \\n            if(force == 0) continue;\\n            force--; //less neg force overtime\\n        }\\n        \\n        //calculating total force and making answer acc. to that\\n        //if total force is +ve then domino will fall right => \\'R\\'\\n        //if total force is -ve then domino will fall left => \\'L\\'\\n        //else it will stand still => \\'.\\'\\n        char[] ans = new char[n];\\n        int index = 0;\\n        \\n        for(int totalForce: forces){\\n            char current = \\'.\\';\\n            if(totalForce > 0){\\n                current = \\'R\\';\\n            } else if(totalForce < 0){\\n                current = \\'L\\';\\n            }\\n            \\n            ans[index] = current;\\n            index++;\\n        }\\n        \\n        \\n        return new String(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        // will calculate the force on every domino in this \\n        //+ve force means domino would fall right and -ve force means domino would fall left\\n        \\n        int n = dominoes.length(); //length of dominoes array and max. force that can be applied on any domino\\n        //calculate right force | +Ve force\\n        int force = 0;\\n        int[] forces = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(dominoes.charAt(i) == \\'R\\'){\\n                force = n;\\n            } else if(dominoes.charAt(i) == \\'L\\'){\\n                force = 0;\\n            }\\n            forces[i] = force;\\n            if(force == 0) continue;\\n            force--;\\n        }\\n        \\n        //calculate left force | -Ve force\\n        force = 0;  // starting force would be zero\\n        for(int i = n-1; i >= 0; i--){\\n            if(dominoes.charAt(i) == \\'L\\'){\\n                force = n;\\n            } else if(dominoes.charAt(i) == \\'R\\'){\\n                force = 0;\\n            }\\n            forces[i] -= force; \\n            if(force == 0) continue;\\n            force--; //less neg force overtime\\n        }\\n        \\n        //calculating total force and making answer acc. to that\\n        //if total force is +ve then domino will fall right => \\'R\\'\\n        //if total force is -ve then domino will fall left => \\'L\\'\\n        //else it will stand still => \\'.\\'\\n        char[] ans = new char[n];\\n        int index = 0;\\n        \\n        for(int totalForce: forces){\\n            char current = \\'.\\';\\n            if(totalForce > 0){\\n                current = \\'R\\';\\n            } else if(totalForce < 0){\\n                current = \\'L\\';\\n            }\\n            \\n            ans[index] = current;\\n            index++;\\n        }\\n        \\n        \\n        return new String(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629224,
                "title": "using-two-pointer",
                "content": "\\n```\\nstring pushDominoes(string s) {\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'R\\')\\n            {\\n                int j=i+1;\\n                while(j<n && s[j]==\\'.\\')\\n                    j++;\\n                //if(j==i+1) continue;\\n                if(j==n)\\n                {\\n                    i++;\\n                    while(i<n){\\n                        s[i]=\\'R\\';\\n                        i++;\\n                    }\\n                }\\n                else if(s[j]==\\'L\\')\\n                {\\n                    int k=j;\\n                    i++;k--;\\n                    while(i<k)\\n                    {\\n                        s[i]=\\'R\\';\\n                        s[k]=\\'L\\';\\n                        i++;\\n                        k--;\\n                    }\\n                    i=j;\\n                }\\n                else\\n                {\\n                    while(i<j){\\n                        s[i]=\\'R\\';\\n                        i++;\\n                    }\\n                    i--;\\n                }\\n                    \\n            }\\n            else if(s[i]==\\'L\\')\\n            {\\n\\n                int j=i;\\n                while(j-1>0 && s[j-1]==\\'.\\' && s[j-2]!=\\'R\\')\\n                {\\n                    s[j-1]=\\'L\\';\\n                    j--;\\n                }\\n                 if(j-1==0 && s[j-1]==\\'.\\')\\n                  s[j-1]=\\'L\\';\\n                    \\n            }\\n        }\\n        return s;\\n    }",
                "solutionTags": [
                    "Two Pointers",
                    "String"
                ],
                "code": "\\n```\\nstring pushDominoes(string s) {\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'R\\')\\n            {\\n                int j=i+1;\\n                while(j<n && s[j]==\\'.\\')\\n                    j++;\\n                //if(j==i+1) continue;\\n                if(j==n)\\n                {\\n                    i++;\\n                    while(i<n){\\n                        s[i]=\\'R\\';\\n                        i++;\\n                    }\\n                }\\n                else if(s[j]==\\'L\\')\\n                {\\n                    int k=j;\\n                    i++;k--;\\n                    while(i<k)\\n                    {\\n                        s[i]=\\'R\\';\\n                        s[k]=\\'L\\';\\n                        i++;\\n                        k--;\\n                    }\\n                    i=j;\\n                }\\n                else\\n                {\\n                    while(i<j){\\n                        s[i]=\\'R\\';\\n                        i++;\\n                    }\\n                    i--;\\n                }\\n                    \\n            }\\n            else if(s[i]==\\'L\\')\\n            {\\n\\n                int j=i;\\n                while(j-1>0 && s[j-1]==\\'.\\' && s[j-2]!=\\'R\\')\\n                {\\n                    s[j-1]=\\'L\\';\\n                    j--;\\n                }\\n                 if(j-1==0 && s[j-1]==\\'.\\')\\n                  s[j-1]=\\'L\\';\\n                    \\n            }\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2629148,
                "title": "simple-python-solution-using-queue",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        domino=list(dominoes)\\n        q=deque()\\n        for i,d in enumerate(domino):\\n            if d!=\".\":\\n                q.append((i,d))\\n        while q:\\n            i,d=q.popleft()\\n            if d==\"L\" and i>0 and domino[i-1]==\".\":\\n                q.append((i-1,\"L\"))\\n                domino[i-1]=\"L\"\\n            elif d==\"R\":\\n                if i+1<len(domino) and domino[i+1]==\".\":\\n                    if i+2<len(domino) and domino[i+2]==\"L\":\\n                        q.popleft()\\n                    else:\\n                        q.append((i+1,\"R\"))\\n                        domino[i+1]=\"R\"\\n        return \\'\\'.join(map(str,domino))\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        domino=list(dominoes)\\n        q=deque()\\n        for i,d in enumerate(domino):\\n            if d!=\".\":\\n                q.append((i,d))\\n        while q:\\n            i,d=q.popleft()\\n            if d==\"L\" and i>0 and domino[i-1]==\".\":\\n                q.append((i-1,\"L\"))\\n                domino[i-1]=\"L\"\\n            elif d==\"R\":\\n                if i+1<len(domino) and domino[i+1]==\".\":\\n                    if i+2<len(domino) and domino[i+2]==\"L\":\\n                        q.popleft()\\n                    else:\\n                        q.append((i+1,\"R\"))\\n                        domino[i+1]=\"R\"\\n        return \\'\\'.join(map(str,domino))\\n",
                "codeTag": "Java"
            },
            {
                "id": 2629088,
                "title": "c-o-n-complexity-explained-using-comments",
                "content": "```\\n/* Lets take example2 to understand the concept\\n                             \". L . R . . . L R . . L . .\"\\n\\t\\tFirstly we\\'ll do prefix count of how many will fall towards right and left.\\n\\t\\tWe\\'ll maintain 2 vectors right and left.\\n\\t\\t\\n\\t\\tFor right vector before that there are few considerations we need to keep in mind\\n\\t\\t1) We\\'ll traverse dominoes string from left to right\\n\\t\\t2) If dominoes[i] == \\'L\\' then it won\\'t fall towards right so count=0 at ith index.\\n\\t\\t3) If dominoes[i] == \\'R\\' then it will fall towards right only so **count=1** at every ith index.\\n\\t\\t    For example - dominoes string = \"R R . R\"\\n\\t\\t\\t                        count =  1 1 2 1\\n\\t\\t\\tHere, As we are considering every \\'R\\' as a starting point of dominoes which will fall towards right\\n\\t\\t\\tAnd for now you can ignore how does 2 comes at 2nd index (We\\'ll discuss this in next point).\\n\\t\\t\\t*I hope I made myself clear about this particular case*\\n\\t\\t4) If dominoes[i] == \\'.\\' then we have to check if last index is non-zero or not. As In case 2) we have\\n\\t\\t    non-zero value at 1st index so we\\'ll increment value by 1. As this will also fall on right only. Otherwise\\n\\t\\t\\tit\\'ll be 0 only.\\n\\t\\t\\tNote - Yah, there maybe case arising in your mind what if it falls on left as some dominoes maybe\\n\\t\\t\\tfalling on left. That we\\'ll consider once we find all the indexes with respect to \\'R\\' dominoes.\\n\\t\\t\\t\\n\\t\\tSimilarly, For left vector before that there are few considerations we need to keep in mind\\n\\t\\t1) We\\'ll traverse dominoes string from right to left\\n\\t\\t2) If dominoes[i] == \\'R\\' then it won\\'t fall towards left so count=0 at ith index.\\n\\t\\t3) If dominoes[i] == \\'L\\' then it will fall towards left only so **count=1** at every ith index.\\n\\t\\t    For example - dominoes string = \"L L . L\"\\n\\t\\t\\t                        count =  1 1 2 1\\n\\t\\t\\tHere, As we are considering every \\'L\\' as a starting point of dominoes which will fall towards left\\n\\t\\t\\tAnd for now you can ignore how does 2 comes at 2nd index (We\\'ll discuss this in next point).\\n\\t\\t\\t*I hope I made myself clear about this particular case*\\n\\t\\t4) If dominoes[i] == \\'.\\' then we have to check if last index is non-zero or not. As In case 2) we have\\n\\t\\t    non-zero value at 3rd index so we\\'ll increment value by 1. As this will also fall on left only. Otherwise\\n\\t\\t\\tit\\'ll be 0 only.\\n\\t\\t\\tNote - Yah, there maybe case arising in your mind what if it falls on right as some dominoes maybe\\n\\t\\t\\tfalling on right. That we\\'ll consider once we find all the indexes with respect to \\'L\\' dominoes.\\n\\t\\t\\t\\n\\t\\tNow, coming back to example2. Here, we\\'ll firstly find right and left vector.\\n\\t\\tAfterwards we\\'ll perform some operations.\\n\\t\\t                                \". L . R . . . L R . . L . .\"\\n\\t\\t\\t\\t\\t\\t\\t\\t right - 0 0 0 1 2 3 4 0 1 2 3 0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t  left - 2 1 0 0 4 3 2 1 0 3 2 1 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t1) Now, if left[i]==0 && right[i]==0, it means it\\'ll be stable So, we\\'ll append \\'.\\' in ans.\\n\\t\\t2) Again, if either is non-zero and another is 0 then it\\'ll fall in favor of non-zero direction\\n\\t\\t3) And if both are non-zero then it\\'ll fall in favor of that direction which have a minimum\\n\\t\\t   value at that particular index. And if both have equal values then it\\'ll remain stable.\\n\\t\\t   Example - if right[i]=2 and left[i]=3 then it\\'ll fall towards right because all dominoes are\\n\\t\\t   simultaneously falling, so domino of this particular index will fall to that direction\\n\\t\\t   in which it has minimum value.\\n*/\\nstring pushDominoes(string s) {\\n        int n=s.length(), cnt=1;\\n        vector<int> left(n), right(n);\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'R\\')\\n                cnt=1, right[i]=cnt++;\\n            else if((i==0 && s[i]==\\'.\\')||s[i]==\\'L\\')\\n                right[i]=0, cnt=1;\\n            else if(i!=0 && s[i]==\\'.\\' && right[i-1]!=0)\\n                right[i]=cnt++;\\n            else\\n                right[i]=0;\\n        }\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i]==\\'L\\')\\n                cnt=1, left[i]=cnt++;\\n            else if((i==n-1 && s[i]==\\'.\\')||s[i]==\\'R\\')\\n                left[i]=0, cnt=1;\\n            else if(i!=n-1 && s[i]==\\'.\\' && left[i+1]!=0)\\n                left[i]=cnt++;\\n            else\\n                left[i]=0;\\n        }\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            if(left[i]!=0 && right[i]==0)\\n                ans+=\"L\";\\n            else if(left[i]==0 && right[i]!=0)\\n                ans+=\"R\";\\n            else if(left[i]==0 && right[i]==0)\\n                ans+=\".\";\\n            else {\\n                if(left[i]<right[i])\\n                    ans+=\"L\";\\n                else if(right[i]<left[i])\\n                    ans+=\"R\";\\n                else\\n                    ans+=\".\";\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t/* I tried my best to deliver explanation. I hope it helped you to understand, if you face any issue please do\\n\\task in comments. Thanks!! */",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/* Lets take example2 to understand the concept\\n                             \". L . R . . . L R . . L . .\"\\n\\t\\tFirstly we\\'ll do prefix count of how many will fall towards right and left.\\n\\t\\tWe\\'ll maintain 2 vectors right and left.\\n\\t\\t\\n\\t\\tFor right vector before that there are few considerations we need to keep in mind\\n\\t\\t1) We\\'ll traverse dominoes string from left to right\\n\\t\\t2) If dominoes[i] == \\'L\\' then it won\\'t fall towards right so count=0 at ith index.\\n\\t\\t3) If dominoes[i] == \\'R\\' then it will fall towards right only so **count=1** at every ith index.\\n\\t\\t    For example - dominoes string = \"R R . R\"\\n\\t\\t\\t                        count =  1 1 2 1\\n\\t\\t\\tHere, As we are considering every \\'R\\' as a starting point of dominoes which will fall towards right\\n\\t\\t\\tAnd for now you can ignore how does 2 comes at 2nd index (We\\'ll discuss this in next point).\\n\\t\\t\\t*I hope I made myself clear about this particular case*\\n\\t\\t4) If dominoes[i] == \\'.\\' then we have to check if last index is non-zero or not. As In case 2) we have\\n\\t\\t    non-zero value at 1st index so we\\'ll increment value by 1. As this will also fall on right only. Otherwise\\n\\t\\t\\tit\\'ll be 0 only.\\n\\t\\t\\tNote - Yah, there maybe case arising in your mind what if it falls on left as some dominoes maybe\\n\\t\\t\\tfalling on left. That we\\'ll consider once we find all the indexes with respect to \\'R\\' dominoes.\\n\\t\\t\\t\\n\\t\\tSimilarly, For left vector before that there are few considerations we need to keep in mind\\n\\t\\t1) We\\'ll traverse dominoes string from right to left\\n\\t\\t2) If dominoes[i] == \\'R\\' then it won\\'t fall towards left so count=0 at ith index.\\n\\t\\t3) If dominoes[i] == \\'L\\' then it will fall towards left only so **count=1** at every ith index.\\n\\t\\t    For example - dominoes string = \"L L . L\"\\n\\t\\t\\t                        count =  1 1 2 1\\n\\t\\t\\tHere, As we are considering every \\'L\\' as a starting point of dominoes which will fall towards left\\n\\t\\t\\tAnd for now you can ignore how does 2 comes at 2nd index (We\\'ll discuss this in next point).\\n\\t\\t\\t*I hope I made myself clear about this particular case*\\n\\t\\t4) If dominoes[i] == \\'.\\' then we have to check if last index is non-zero or not. As In case 2) we have\\n\\t\\t    non-zero value at 3rd index so we\\'ll increment value by 1. As this will also fall on left only. Otherwise\\n\\t\\t\\tit\\'ll be 0 only.\\n\\t\\t\\tNote - Yah, there maybe case arising in your mind what if it falls on right as some dominoes maybe\\n\\t\\t\\tfalling on right. That we\\'ll consider once we find all the indexes with respect to \\'L\\' dominoes.\\n\\t\\t\\t\\n\\t\\tNow, coming back to example2. Here, we\\'ll firstly find right and left vector.\\n\\t\\tAfterwards we\\'ll perform some operations.\\n\\t\\t                                \". L . R . . . L R . . L . .\"\\n\\t\\t\\t\\t\\t\\t\\t\\t right - 0 0 0 1 2 3 4 0 1 2 3 0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t  left - 2 1 0 0 4 3 2 1 0 3 2 1 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t1) Now, if left[i]==0 && right[i]==0, it means it\\'ll be stable So, we\\'ll append \\'.\\' in ans.\\n\\t\\t2) Again, if either is non-zero and another is 0 then it\\'ll fall in favor of non-zero direction\\n\\t\\t3) And if both are non-zero then it\\'ll fall in favor of that direction which have a minimum\\n\\t\\t   value at that particular index. And if both have equal values then it\\'ll remain stable.\\n\\t\\t   Example - if right[i]=2 and left[i]=3 then it\\'ll fall towards right because all dominoes are\\n\\t\\t   simultaneously falling, so domino of this particular index will fall to that direction\\n\\t\\t   in which it has minimum value.\\n*/\\nstring pushDominoes(string s) {\\n        int n=s.length(), cnt=1;\\n        vector<int> left(n), right(n);\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'R\\')\\n                cnt=1, right[i]=cnt++;\\n            else if((i==0 && s[i]==\\'.\\')||s[i]==\\'L\\')\\n                right[i]=0, cnt=1;\\n            else if(i!=0 && s[i]==\\'.\\' && right[i-1]!=0)\\n                right[i]=cnt++;\\n            else\\n                right[i]=0;\\n        }\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i]==\\'L\\')\\n                cnt=1, left[i]=cnt++;\\n            else if((i==n-1 && s[i]==\\'.\\')||s[i]==\\'R\\')\\n                left[i]=0, cnt=1;\\n            else if(i!=n-1 && s[i]==\\'.\\' && left[i+1]!=0)\\n                left[i]=cnt++;\\n            else\\n                left[i]=0;\\n        }\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            if(left[i]!=0 && right[i]==0)\\n                ans+=\"L\";\\n            else if(left[i]==0 && right[i]!=0)\\n                ans+=\"R\";\\n            else if(left[i]==0 && right[i]==0)\\n                ans+=\".\";\\n            else {\\n                if(left[i]<right[i])\\n                    ans+=\"L\";\\n                else if(right[i]<left[i])\\n                    ans+=\"R\";\\n                else\\n                    ans+=\".\";\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t/* I tried my best to deliver explanation. I hope it helped you to understand, if you face any issue please do\\n\\task in comments. Thanks!! */",
                "codeTag": "Unknown"
            },
            {
                "id": 2629078,
                "title": "python3-o-n-pythonic-two-pointers",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        res = list(\\'L\\' + dominoes + \\'R\\')\\n        l, r = 0, 1\\n        while r < len(res):\\n            if res[r] == \\'.\\':\\n                r += 1\\n                continue\\n            elif res[r] == \\'L\\' and res[l] == \\'R\\':\\n                h = (r - l - 1) // 2\\n                res[l+1:l+1+h] = [\\'R\\'] * h\\n                res[r-h:r] = [\\'L\\'] * h\\n            elif res[l] == res[r]:\\n                res[l+1:r] = [res[l]] * (r - l - 1)\\n            l, r = r, r + 1\\n        return \\'\\'.join(res[1:-1])        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        res = list(\\'L\\' + dominoes + \\'R\\')\\n        l, r = 0, 1\\n        while r < len(res):\\n            if res[r] == \\'.\\':\\n                r += 1\\n                continue\\n            elif res[r] == \\'L\\' and res[l] == \\'R\\':\\n                h = (r - l - 1) // 2\\n                res[l+1:l+1+h] = [\\'R\\'] * h\\n                res[r-h:r] = [\\'L\\'] * h\\n            elif res[l] == res[r]:\\n                res[l+1:r] = [res[l]] * (r - l - 1)\\n            l, r = r, r + 1\\n        return \\'\\'.join(res[1:-1])        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628947,
                "title": "c-bfs",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    string pushDominoes(string& dominoes) {\\n        \\n        int n = dominoes.size();\\n        vector<int> l( n, INT_MAX );\\n        vector<int> r( n, INT_MAX );\\n        \\n        queue< int > qr;\\n        queue< int > ql;\\n        \\n        for( int i=0; i<dominoes.size() ;i++ ){\\n            if( dominoes[i] == \\'R\\' ){\\n                r[i] = 0;\\n                qr.push(i);\\n            }\\n            else if( dominoes[i] == \\'L\\' ){\\n                l[i] = 0;\\n                ql.push(i);\\n            }\\n        }\\n        while( !ql.empty() ){\\n            int i = ql.front();\\n            ql.pop();\\n            \\n            if( i > 0 && dominoes[i-1] == \\'.\\' && 1+l[i] < l[i-1] ){\\n                l[i-1] = 1 + l[i];\\n                ql.push(i-1);\\n            }\\n        }\\n        while( !qr.empty() ){\\n            int i = qr.front();\\n            qr.pop();\\n            \\n            if( i < n-1 && dominoes[i+1] == \\'.\\' && 1 + r[i] < r[i+1] ){\\n                r[i+1] = 1 + r[i];\\n                qr.push(i+1);\\n            }\\n        }\\n        \\n        for( int i =0; i<n ;i++ ){\\n            if( l[i] < r[i] ){\\n                dominoes[i] = \\'L\\';\\n            }\\n            else if( l[i] == r[i] ){\\n                dominoes[i] = \\'.\\';\\n            }\\n            else{\\n                dominoes[i] = \\'R\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    string pushDominoes(string& dominoes) {\\n        \\n        int n = dominoes.size();\\n        vector<int> l( n, INT_MAX );\\n        vector<int> r( n, INT_MAX );\\n        \\n        queue< int > qr;\\n        queue< int > ql;\\n        \\n        for( int i=0; i<dominoes.size() ;i++ ){\\n            if( dominoes[i] == \\'R\\' ){\\n                r[i] = 0;\\n                qr.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2628922,
                "title": "simulation-in-a-while-loop",
                "content": "Not sure if it is a good solution, but my approach is just do simulation.\\nThe simulation is in the while loop, every time a push do only one forward unitl there is no pushes. like the description said\\n\\n\"each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\"\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes : str) -> str:\\n        dom = list(dominoes)\\n        ls, rs = set(), set()\\n        for i, c in enumerate(dom):\\n            if c==\\'L\\':ls.add(i)\\n            elif c==\\'R\\':rs.add(i)\\n        \\n        while ls or rs:            \\n            newls = set()\\n            for i in ls:\\n                if i-1>=0 and dom[i-1]==\\'.\\':\\n                    if (i-2) in rs:\\n                        rs.remove(i-2)\\n                    else:\\n                        dom[i-1]=\"L\"\\n                        newls.add(i-1)\\n            \\n            newrs = set()\\n            for i in rs:\\n                if i+1<len(dom) and dom[i+1]==\".\":\\n                    dom[i+1]=\"R\"\\n                    newrs.add(i+1)\\n            ls = newls\\n            rs = newrs\\n                \\n        return \"\".join(dom)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes : str) -> str:\\n        dom = list(dominoes)\\n        ls, rs = set(), set()\\n        for i, c in enumerate(dom):\\n            if c==\\'L\\':ls.add(i)\\n            elif c==\\'R\\':rs.add(i)\\n        \\n        while ls or rs:            \\n            newls = set()\\n            for i in ls:\\n                if i-1>=0 and dom[i-1]==\\'.\\':\\n                    if (i-2) in rs:\\n                        rs.remove(i-2)\\n                    else:\\n                        dom[i-1]=\"L\"\\n                        newls.add(i-1)\\n            \\n            newrs = set()\\n            for i in rs:\\n                if i+1<len(dom) and dom[i+1]==\".\":\\n                    dom[i+1]=\"R\"\\n                    newrs.add(i+1)\\n            ls = newls\\n            rs = newrs\\n                \\n        return \"\".join(dom)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628893,
                "title": "c-solution",
                "content": "1. There are just three condition `[L...R],[R..L],[L...L]` we need to care about \\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s,int left=-1,int right = -1) {\\n        for(int i= 0; i <= s.size(); ++i) {\\n            if(i == s.size() or s[i] == \\'R\\'){ // [R..L]\\n              if (right != left)for(int j = right; j < i; s[j++] = \\'R\\');\\n              right = i;\\n            }else if(s[i] == \\'L\\'){\\n                if (left == right) for(int j = left + 1; j < i; s[j++] = \\'L\\');//[L...L]\\n                else //[R...L]\\n                   for(int low = right + 1, high = i - 1;low < high;s[low++] = \\'R\\', s[high--] = \\'L\\');\\n                 left = right = i;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s,int left=-1,int right = -1) {\\n        for(int i= 0; i <= s.size(); ++i) {\\n            if(i == s.size() or s[i] == \\'R\\'){ // [R..L]\\n              if (right != left)for(int j = right; j < i; s[j++] = \\'R\\');\\n              right = i;\\n            }else if(s[i] == \\'L\\'){\\n                if (left == right) for(int j = left + 1; j < i; s[j++] = \\'L\\');//[L...L]\\n                else //[R...L]\\n                   for(int low = right + 1, high = i - 1;low < high;s[low++] = \\'R\\', s[high--] = \\'L\\');\\n                 left = right = i;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628850,
                "title": "java-solution-100-faster-and-easy-code",
                "content": "```\\nclass Solution {\\n  public String pushDominoes(String dominoes) {\\n    char[] s = dominoes.toCharArray();\\n    int L = -1;\\n    int R = -1;\\n\\n    for (int i = 0; i <= dominoes.length(); ++i)\\n      if (i == dominoes.length() || s[i] == \\'R\\') {\\n        if (L < R)\\n          while (R < i)\\n            s[R++] = \\'R\\';\\n        R = i;\\n      } else if (s[i] == \\'L\\') {\\n        if (R < L || L == -1 && R == -1) {\\n          if (L == -1 && R == -1)\\n            ++L;\\n          while (L < i)\\n            s[L++] = \\'L\\';\\n        } else {\\n          int l = R + 1;\\n          int r = i - 1;\\n          while (l < r) {\\n            s[l++] = \\'R\\';\\n            s[r--] = \\'L\\';\\n          }\\n        }\\n        L = i;\\n      }\\n\\n    return new String(s);\\n  }\\n}\\n```\\n// If you like the solution pls upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public String pushDominoes(String dominoes) {\\n    char[] s = dominoes.toCharArray();\\n    int L = -1;\\n    int R = -1;\\n\\n    for (int i = 0; i <= dominoes.length(); ++i)\\n      if (i == dominoes.length() || s[i] == \\'R\\') {\\n        if (L < R)\\n          while (R < i)\\n            s[R++] = \\'R\\';\\n        R = i;\\n      } else if (s[i] == \\'L\\') {\\n        if (R < L || L == -1 && R == -1) {\\n          if (L == -1 && R == -1)\\n            ++L;\\n          while (L < i)\\n            s[L++] = \\'L\\';\\n        } else {\\n          int l = R + 1;\\n          int r = i - 1;\\n          while (l < r) {\\n            s[l++] = \\'R\\';\\n            s[r--] = \\'L\\';\\n          }\\n        }\\n        L = i;\\n      }\\n\\n    return new String(s);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628717,
                "title": "java-easy-solution-easy-to-understand-100-faster-push-dominoes",
                "content": "## Upvote the solution if you liked it \\uD83D\\uDC4D\\n\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        char[] dArray = dominoes.toCharArray();\\n        char start = \\'.\\';\\n        char last = \\'.\\';\\n        int stidx = 0;\\n        int i = 0;\\n        while(i<n){\\n            stidx = i;\\n            while(i<n && dArray[i]==\\'.\\'){\\n                i++;\\n            }\\n            if(i<n){\\n                last = dArray[i];\\n            }\\n            if(i-stidx>0){\\n                if(start==\\'R\\' && last==\\'L\\'){\\n                    int l = stidx;\\n                    int r = i-1;\\n                    while(l<r){\\n                        dArray[l]=\\'R\\';\\n                        dArray[r]=\\'L\\';\\n                        l++;\\n                        r--;\\n                        \\n                    }\\n                   \\n                }\\n                else if(last==\\'L\\'){\\n                    int l = i-1;\\n                    while(l>=stidx){\\n                        dArray[l]=\\'L\\';\\n                        l--;\\n                    }\\n                }\\n                else if(start==\\'R\\'){\\n                    int r = stidx;\\n                    while(r<i){\\n                        dArray[r]=\\'R\\';\\n                        r++;\\n                    }   \\n                }\\n            }\\n            \\n            start = last;\\n            i++;\\n            last = \\'.\\';\\n        }\\n        return new String(dArray);\\n    }\\n}\\n```\\n\\n### If you liked the solution and it worked for you then please upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        char[] dArray = dominoes.toCharArray();\\n        char start = \\'.\\';\\n        char last = \\'.\\';\\n        int stidx = 0;\\n        int i = 0;\\n        while(i<n){\\n            stidx = i;\\n            while(i<n && dArray[i]==\\'.\\'){\\n                i++;\\n            }\\n            if(i<n){\\n                last = dArray[i];\\n            }\\n            if(i-stidx>0){\\n                if(start==\\'R\\' && last==\\'L\\'){\\n                    int l = stidx;\\n                    int r = i-1;\\n                    while(l<r){\\n                        dArray[l]=\\'R\\';\\n                        dArray[r]=\\'L\\';\\n                        l++;\\n                        r--;\\n                        \\n                    }\\n                   \\n                }\\n                else if(last==\\'L\\'){\\n                    int l = i-1;\\n                    while(l>=stidx){\\n                        dArray[l]=\\'L\\';\\n                        l--;\\n                    }\\n                }\\n                else if(start==\\'R\\'){\\n                    int r = stidx;\\n                    while(r<i){\\n                        dArray[r]=\\'R\\';\\n                        r++;\\n                    }   \\n                }\\n            }\\n            \\n            start = last;\\n            i++;\\n            last = \\'.\\';\\n        }\\n        return new String(dArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573350,
                "title": "c-95-time-99-99-memory-tricky-two-pointer-explain-comments",
                "content": "The n^2 solution to this problem is easy but it was difficult for me to find a way to not do so much repeated work. I came up with this idea: \\nMaintain the position of the closest domino pointing RIGHT. If we encounter a left domino along the way, the position of the closest domino pointing right is INFINITY because the left cancels it out.\\n\\nLook for the closest domino pointing LEFT. We do this by iterating ahead of our current position. If there is a right domino along the way, the position of the closest domino opint left is INFINITY because the right cancels it out.\\nImportant: We only need to redo this step if closestLeft is BEHIND our current position, because if the closestLeft for i = 3 is index 9, it will also be the closest left for indices 4...8.\\n\\nNow we know the positions of our closest right and left dominos. So for any given \\'.\\', we just need to check the absolute distance from the closestLeft or closestRight domino and set it to that one. If they are equidistant, then we do not change the \\'.\\'.\\n\\n```\\n    string pushDominoes(string d) {\\n        const int INF = 10e5;\\n        int closestLeft = INF; // in front\\n        int closestRight = INF; // behind\\n        int j = 0;\\n        for(int i = 0; i < d.length(); i++){\\n            if(closestLeft <= i || (j <= i && closestLeft == INF)){ // find the closest left domino if it exists \\n                j = i;\\n                while(j < d.length()){ // dont redo calculation if closestleft is >= i because the answer remains the same\\n                        // do redo if closestleft <= i OR j <= i AND closestLeft = infinity\\n                        if(d[j] == \\'L\\'){\\n                            closestLeft = j;\\n                            break;\\n                        }\\n                        if(d[j] == \\'R\\'){\\n                            closestLeft = INF;\\n                            break;\\n                        }\\n                        j++;\\n                    }\\n            }\\n            if(closestLeft < i) closestLeft = INF; // closestLeft does not exist if it\\'s behind the domino because it can never push it\\n            \\n            if(d[i] == \\'R\\') closestRight = i; // do this before checking if it\\'s a \\'.\\' because it might mistakenly update it\\n            else if(d[i] == \\'L\\') closestRight = INF;\\n    \\n            if(d[i] == \\'.\\'){\\n                if(abs(closestLeft-i) < abs(closestRight-i)) d[i] = \\'L\\'; // left is closer in absolute distance so it will reach this domino first\\n                else if(abs(closestLeft-i) > abs(closestRight-i)) d[i] = \\'R\\'; // right is closer in absolute distance so it will reach this domino first \\n            }\\n        }\\n        return d;\\n    }",
                "solutionTags": [],
                "code": "The n^2 solution to this problem is easy but it was difficult for me to find a way to not do so much repeated work. I came up with this idea: \\nMaintain the position of the closest domino pointing RIGHT. If we encounter a left domino along the way, the position of the closest domino pointing right is INFINITY because the left cancels it out.\\n\\nLook for the closest domino pointing LEFT. We do this by iterating ahead of our current position. If there is a right domino along the way, the position of the closest domino opint left is INFINITY because the right cancels it out.\\nImportant: We only need to redo this step if closestLeft is BEHIND our current position, because if the closestLeft for i = 3 is index 9, it will also be the closest left for indices 4...8.\\n\\nNow we know the positions of our closest right and left dominos. So for any given \\'.\\', we just need to check the absolute distance from the closestLeft or closestRight domino and set it to that one. If they are equidistant, then we do not change the \\'.\\'.\\n\\n```\\n    string pushDominoes(string d) {\\n        const int INF = 10e5;\\n        int closestLeft = INF; // in front\\n        int closestRight = INF; // behind\\n        int j = 0;\\n        for(int i = 0; i < d.length(); i++){\\n            if(closestLeft <= i || (j <= i && closestLeft == INF)){ // find the closest left domino if it exists \\n                j = i;\\n                while(j < d.length()){ // dont redo calculation if closestleft is >= i because the answer remains the same\\n                        // do redo if closestleft <= i OR j <= i AND closestLeft = infinity\\n                        if(d[j] == \\'L\\'){\\n                            closestLeft = j;\\n                            break;\\n                        }\\n                        if(d[j] == \\'R\\'){\\n                            closestLeft = INF;\\n                            break;\\n                        }\\n                        j++;\\n                    }\\n            }\\n            if(closestLeft < i) closestLeft = INF; // closestLeft does not exist if it\\'s behind the domino because it can never push it\\n            \\n            if(d[i] == \\'R\\') closestRight = i; // do this before checking if it\\'s a \\'.\\' because it might mistakenly update it\\n            else if(d[i] == \\'L\\') closestRight = INF;\\n    \\n            if(d[i] == \\'.\\'){\\n                if(abs(closestLeft-i) < abs(closestRight-i)) d[i] = \\'L\\'; // left is closer in absolute distance so it will reach this domino first\\n                else if(abs(closestLeft-i) > abs(closestRight-i)) d[i] = \\'R\\'; // right is closer in absolute distance so it will reach this domino first \\n            }\\n        }\\n        return d;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2433602,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tstring pushDominoes(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tvector<int> l(n, 0), r;\\n\\t\\tint ct = 0;\\n\\t\\tfor (auto &e : s) {\\n\\t\\t\\tif (e == \\'R\\') {\\n\\t\\t\\t\\tct = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ct && e == \\'.\\') {\\n\\t\\t\\t\\tct++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (e == \\'L\\') ct = 0;\\n\\t\\t\\tr.push_back(ct);\\n\\t\\t}\\n\\t\\tfor (int i = n - 1; i >= 0; --i) {\\n\\t\\t\\tchar e = s[i];\\n\\t\\t\\tif (e == \\'L\\') {\\n\\t\\t\\t\\tct = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ct && e == \\'.\\') {\\n\\t\\t\\t\\tct++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (e == \\'R\\') ct = 0;\\n\\t\\t\\tl[i] = ct;\\n\\t\\t}\\n\\t\\tstring ans;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tif (s[i] == \\'.\\') {\\n\\t\\t\\t\\tif (l[i] == r[i]) ans.push_back(\\'.\\');\\n\\t\\t\\t\\telse if (l[i] == 0) ans.push_back(\\'R\\');\\n\\t\\t\\t\\telse if (r[i] == 0) ans.push_back(\\'L\\');\\n\\t\\t\\t\\telse if (l[i] < r[i]) ans.push_back(\\'L\\');\\n\\t\\t\\t\\telse  ans.push_back(\\'R\\');\\n\\t\\t\\t}\\n\\t\\t\\telse ans.push_back(s[i]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring pushDominoes(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tvector<int> l(n, 0), r;\\n\\t\\tint ct = 0;\\n\\t\\tfor (auto &e : s) {\\n\\t\\t\\tif (e == \\'R\\') {\\n\\t\\t\\t\\tct = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ct && e == \\'.\\') {\\n\\t\\t\\t\\tct++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (e == \\'L\\') ct = 0;\\n\\t\\t\\tr.push_back(ct);\\n\\t\\t}\\n\\t\\tfor (int i = n - 1; i >= 0; --i) {\\n\\t\\t\\tchar e = s[i];\\n\\t\\t\\tif (e == \\'L\\') {\\n\\t\\t\\t\\tct = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ct && e == \\'.\\') {\\n\\t\\t\\t\\tct++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (e == \\'R\\') ct = 0;\\n\\t\\t\\tl[i] = ct;\\n\\t\\t}\\n\\t\\tstring ans;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tif (s[i] == \\'.\\') {\\n\\t\\t\\t\\tif (l[i] == r[i]) ans.push_back(\\'.\\');\\n\\t\\t\\t\\telse if (l[i] == 0) ans.push_back(\\'R\\');\\n\\t\\t\\t\\telse if (r[i] == 0) ans.push_back(\\'L\\');\\n\\t\\t\\t\\telse if (l[i] < r[i]) ans.push_back(\\'L\\');\\n\\t\\t\\t\\telse  ans.push_back(\\'R\\');\\n\\t\\t\\t}\\n\\t\\t\\telse ans.push_back(s[i]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404263,
                "title": "prefix-suffix-method-c-easiest-ace-solution",
                "content": "**\\n##  **********``**\\n \\n \\n string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n      vector<int> pre(n, 0);\\n      vector<int> suff(n, 0);\\n      \\n        for(int i=0; i<n; i++){\\n            if(dominoes[i]==\\'R\\'){\\n                for(int j=i+1; j<n; j++){\\n                    if(dominoes[j]!=\\'.\\') break;\\n                    else pre[j]=pre[j-1]+1;\\n                }\\n            }\\n           \\n        }\\n        \\n          for(int i=n-1; i>=0; i--){\\n            if(dominoes[i]==\\'L\\'){\\n                for(int j=i-1; j>=0; j--){\\n                    if(dominoes[j]!=\\'.\\') break;\\n                    else suff[j]=suff[j+1]+1;\\n                }\\n            }\\n           \\n        } \\n        for(int i=0; i<n; i++){\\n            if(dominoes[i]==\\'R\\'||dominoes[i]==\\'L\\') continue;\\n          if((pre[i]==0&&suff[i]==0)||pre[i]==suff[i]) continue;\\n            \\n            if(pre[i]!=0&&suff[i]!=0){\\n                if(pre[i]>suff[i]) dominoes[i]=\\'L\\';\\n                if(pre[i]<suff[i]) dominoes[i]=\\'R\\';\\n                else continue;\\n            }\\n            else{\\n                \\n              if(pre[i]==0) dominoes[i]=\\'L\\';\\n                else{\\n                    dominoes[i]=\\'R\\';\\n                }\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "**\\n##  **********``**\\n \\n \\n string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n      vector<int> pre(n, 0);\\n      vector<int> suff(n, 0);\\n      \\n        for(int i=0; i<n; i++){\\n            if(dominoes[i]==\\'R\\'){\\n                for(int j=i+1; j<n; j++){\\n                    if(dominoes[j]!=\\'.\\') break;\\n                    else pre[j]=pre[j-1]+1;\\n                }\\n            }\\n           \\n        }\\n        \\n          for(int i=n-1; i>=0; i--){\\n            if(dominoes[i]==\\'L\\'){\\n                for(int j=i-1; j>=0; j--){\\n                    if(dominoes[j]!=\\'.\\') break;\\n                    else suff[j]=suff[j+1]+1;\\n                }\\n            }\\n           \\n        } \\n        for(int i=0; i<n; i++){\\n            if(dominoes[i]==\\'R\\'||dominoes[i]==\\'L\\') continue;\\n          if((pre[i]==0&&suff[i]==0)||pre[i]==suff[i]) continue;\\n            \\n            if(pre[i]!=0&&suff[i]!=0){\\n                if(pre[i]>suff[i]) dominoes[i]=\\'L\\';\\n                if(pre[i]<suff[i]) dominoes[i]=\\'R\\';\\n                else continue;\\n            }\\n            else{\\n                \\n              if(pre[i]==0) dominoes[i]=\\'L\\';\\n                else{\\n                    dominoes[i]=\\'R\\';\\n                }\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2394442,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dom: str) -> str:\\n        from collections import deque\\n        n = len(dom)\\n        d = set()\\n        q = deque()\\n        arr = [0 for i in range(n)]\\n        for i in range(n):\\n            if dom[i] == \"L\":\\n                arr[i] = -1\\n                d.add(i)\\n                q.append((i,\"L\"))\\n            if dom[i] == \"R\":\\n                arr[i] = 1\\n                d.add(i)\\n                q.append((i,\"R\"))\\n        while q:\\n            t1 = set()\\n            for _ in range(len(q)):\\n                t = q.popleft()\\n                if t[1] == \"L\":\\n                    if t[0]-1 >= 0 and t[0]-1 not in d:\\n                        t1.add(t[0]-1)\\n                        arr[t[0]-1] -= 1\\n                else:\\n                    if t[0]+1 < n and t[0]+1 not in d:\\n                        t1.add(t[0]+1)\\n                        arr[t[0]+1] += 1\\n            for val in t1:\\n                d.add(val)\\n                if arr[val] > 0:\\n                    q.append((val,\"R\"))\\n                elif arr[val]<0:\\n                    q.append((val,\"L\"))\\n        ans = \"\"\\n        for val in arr:\\n            if val<0:\\n                ans += \"L\"\\n            elif val>0:\\n                ans += \"R\"\\n            else:\\n                ans += \".\"\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dom: str) -> str:\\n        from collections import deque\\n        n = len(dom)\\n        d = set()\\n        q = deque()\\n        arr = [0 for i in range(n)]\\n        for i in range(n):\\n            if dom[i] == \"L\":\\n                arr[i] = -1\\n                d.add(i)\\n                q.append((i,\"L\"))\\n            if dom[i] == \"R\":\\n                arr[i] = 1\\n                d.add(i)\\n                q.append((i,\"R\"))\\n        while q:\\n            t1 = set()\\n            for _ in range(len(q)):\\n                t = q.popleft()\\n                if t[1] == \"L\":\\n                    if t[0]-1 >= 0 and t[0]-1 not in d:\\n                        t1.add(t[0]-1)\\n                        arr[t[0]-1] -= 1\\n                else:\\n                    if t[0]+1 < n and t[0]+1 not in d:\\n                        t1.add(t[0]+1)\\n                        arr[t[0]+1] += 1\\n            for val in t1:\\n                d.add(val)\\n                if arr[val] > 0:\\n                    q.append((val,\"R\"))\\n                elif arr[val]<0:\\n                    q.append((val,\"L\"))\\n        ans = \"\"\\n        for val in arr:\\n            if val<0:\\n                ans += \"L\"\\n            elif val>0:\\n                ans += \"R\"\\n            else:\\n                ans += \".\"\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375230,
                "title": "c-easy-and-understanding-solution",
                "content": "```\\npublic class Solution {\\n    public string PushDominoes(string dominoes) {\\n        char[] elements = dominoes.ToCharArray();\\n        int length = elements.Length;\\n        int[] forces = new int[length];\\n        \\n        int force = 0;\\n        for(int i = 0; i < length; i++) {\\n            if(elements[i] == \\'R\\') {\\n                force = length;\\n            } else if(elements[i] == \\'L\\') {\\n                force = 0;\\n            } else {\\n                force = Math.Max(force - 1, 0);\\n            }\\n            \\n            forces[i] += force;\\n        }\\n        \\n        force = 0;\\n        for(int i = length - 1; i >= 0; i--) {\\n            if(elements[i] == \\'L\\') {\\n                force = length;\\n            } else if(elements[i] == \\'R\\') {\\n                force = 0;\\n            } else {\\n                force = Math.Max(force - 1, 0);\\n            }\\n            \\n            forces[i] -= force;\\n        }\\n        \\n        StringBuilder builder = new StringBuilder();\\n        foreach(int f in forces) {\\n            if(f > 0) {\\n                builder.Append(\\'R\\');\\n            } else if(f < 0) {\\n                builder.Append(\\'L\\');\\n            } else {\\n                builder.Append(\\'.\\');\\n            }\\n        }\\n        \\n        return builder.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string PushDominoes(string dominoes) {\\n        char[] elements = dominoes.ToCharArray();\\n        int length = elements.Length;\\n        int[] forces = new int[length];\\n        \\n        int force = 0;\\n        for(int i = 0; i < length; i++) {\\n            if(elements[i] == \\'R\\') {\\n                force = length;\\n            } else if(elements[i] == \\'L\\') {\\n                force = 0;\\n            } else {\\n                force = Math.Max(force - 1, 0);\\n            }\\n            \\n            forces[i] += force;\\n        }\\n        \\n        force = 0;\\n        for(int i = length - 1; i >= 0; i--) {\\n            if(elements[i] == \\'L\\') {\\n                force = length;\\n            } else if(elements[i] == \\'R\\') {\\n                force = 0;\\n            } else {\\n                force = Math.Max(force - 1, 0);\\n            }\\n            \\n            forces[i] -= force;\\n        }\\n        \\n        StringBuilder builder = new StringBuilder();\\n        foreach(int f in forces) {\\n            if(f > 0) {\\n                builder.Append(\\'R\\');\\n            } else if(f < 0) {\\n                builder.Append(\\'L\\');\\n            } else {\\n                builder.Append(\\'.\\');\\n            }\\n        }\\n        \\n        return builder.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315751,
                "title": "c-easy-to-understand-shitty-code-two-pointers-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        int n=d.size();\\n        int i=0;\\n        int j=0;\\n        string s(n,\\'.\\');\\n        if(d==s)\\n        return d;\\n        while(j<n)\\n        {\\n            if(d[j]==\\'.\\')\\n            {\\n                i=j;\\n                while(j<n&&d[j]==\\'.\\')\\n                {\\n                    j++;\\n                }\\n        \\n                if(i==0)\\n                {\\n                    if(d[j]==\\'L\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'L\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n                else if(j==n)\\n                {\\n                    if(d[i-1]==\\'R\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'R\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    if(d[j]==\\'L\\'&&d[i-1]==\\'R\\')\\n                    {\\n                        int len=j-(i-1)+1;\\n                        if(len%2==0)\\n                        {\\n                            int z=len/2;\\n                            int k=z;\\n                            --i;\\n                            while(z--)\\n                            {\\n                                d[i++]=\\'R\\';\\n                            }\\n                            while(k--)\\n                            {\\n                                d[j--]=\\'L\\';\\n                            }\\n                        }\\n                        else\\n                        {\\n                            int z=len/2;\\n                            int k=z;\\n                            --i;\\n                            while(z--)\\n                            {\\n                                d[i++]=\\'R\\';\\n                            }\\n                            while(k--)\\n                            {\\n                                d[j--]=\\'L\\';\\n                            } \\n                        }\\n                    }\\n                    if(d[j]==\\'L\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'L\\';\\n                            i++;\\n                        }\\n                    }\\n                    if(d[i-1]==\\'R\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'R\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            j++;\\n        }\\n        return d;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        int n=d.size();\\n        int i=0;\\n        int j=0;\\n        string s(n,\\'.\\');\\n        if(d==s)\\n        return d;\\n        while(j<n)\\n        {\\n            if(d[j]==\\'.\\')\\n            {\\n                i=j;\\n                while(j<n&&d[j]==\\'.\\')\\n                {\\n                    j++;\\n                }\\n        \\n                if(i==0)\\n                {\\n                    if(d[j]==\\'L\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'L\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n                else if(j==n)\\n                {\\n                    if(d[i-1]==\\'R\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'R\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    if(d[j]==\\'L\\'&&d[i-1]==\\'R\\')\\n                    {\\n                        int len=j-(i-1)+1;\\n                        if(len%2==0)\\n                        {\\n                            int z=len/2;\\n                            int k=z;\\n                            --i;\\n                            while(z--)\\n                            {\\n                                d[i++]=\\'R\\';\\n                            }\\n                            while(k--)\\n                            {\\n                                d[j--]=\\'L\\';\\n                            }\\n                        }\\n                        else\\n                        {\\n                            int z=len/2;\\n                            int k=z;\\n                            --i;\\n                            while(z--)\\n                            {\\n                                d[i++]=\\'R\\';\\n                            }\\n                            while(k--)\\n                            {\\n                                d[j--]=\\'L\\';\\n                            } \\n                        }\\n                    }\\n                    if(d[j]==\\'L\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'L\\';\\n                            i++;\\n                        }\\n                    }\\n                    if(d[i-1]==\\'R\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'R\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            j++;\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241066,
                "title": "easy-to-understand-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        //now what to do\\n        queue<int> q;\\n        for(int i=0;i<d.size();i++)\\n            if(d[i]!=\\'.\\')q.push(i);\\n        \\n        //last updated\\n        while(!q.empty())\\n        {\\n            int size=q.size(),last=-2;\\n            while(size--)\\n            {\\n                char dir=d[q.front()];\\n                int nxt=(dir==\\'L\\')?q.front()-1:q.front()+1;\\n                q.pop();\\n                if(last==nxt&&dir!=d[nxt])//then update to .\\n                    d[nxt]=\\'.\\';\\n                else if(nxt>=0&&nxt<d.size()&&d[nxt]==\\'.\\')//then only we will update\\n                {\\n                    d[nxt]=dir;\\n                    q.push(nxt);\\n                    last=nxt;\\n                }\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        //now what to do\\n        queue<int> q;\\n        for(int i=0;i<d.size();i++)\\n            if(d[i]!=\\'.\\')q.push(i);\\n        \\n        //last updated\\n        while(!q.empty())\\n        {\\n            int size=q.size(),last=-2;\\n            while(size--)\\n            {\\n                char dir=d[q.front()];\\n                int nxt=(dir==\\'L\\')?q.front()-1:q.front()+1;\\n                q.pop();\\n                if(last==nxt&&dir!=d[nxt])//then update to .\\n                    d[nxt]=\\'.\\';\\n                else if(nxt>=0&&nxt<d.size()&&d[nxt]==\\'.\\')//then only we will update\\n                {\\n                    d[nxt]=dir;\\n                    q.push(nxt);\\n                    last=nxt;\\n                }\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988884,
                "title": "simple-multi-source-bfs-with-python",
                "content": "This problem has simple graph-based formulation. Let\\'s consider dominoes to be vertices where every pair of adjecent dominoes are connected with an edge. In such graph spread of falling dominoes can be viewed as breadth-first-search from multiple sources. The sources here are \\'L\\' or \\'R\\' - pushed dominoes.\\nAs we know, breadth-first-search explores all nodes at the present depth prior to moving on to the nodes at the next depth level. Extra memory used for queue (deque in Python), which is needed to keep track of the nodes that were encountered but not yet explored.\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        qq = deque() # BFS candidate queue\\n        mp = {\\'L\\': -1, \\'R\\': 1} # Define mapping from the letter to the search direction\\n        was = [0 for _ in range(len(dominoes))] # To mark visited nodes with depths\\n        res = list(dominoes)\\n        # Add to queue nodes with \\'L\\' or \\'R\\' as a sources\\n        for i, x in enumerate(dominoes): \\n            if x != \\'.\\':\\n                qq.append((i, 1, x))\\n                was[i] = -1\\n\\t\\t# BFS\\n        while qq: \\n            idx, depth, direction = qq.popleft()\\n            if idx < 0 or idx >= len(res): # Check whether the borders are exceeded\\n                continue\\n            if was[idx] == depth: # Check if this node is pushed from both sides\\n                res[idx] = \\'.\\'\\n            elif was[idx] <= 0: # Check if this node haven\\'t been visited\\n                was[idx] = depth\\n                qq.append((idx + mp[direction], depth + 1, direction))\\n                res[idx] = direction\\n        return \\'\\'.join(res)\\n```\\nThis solution has O(n) time complexity because each node is visited no more than 3 times (ones in for loop and at most twice in BFS). Also here we use O(n) extra memory for queue, depths and result.",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        qq = deque() # BFS candidate queue\\n        mp = {\\'L\\': -1, \\'R\\': 1} # Define mapping from the letter to the search direction\\n        was = [0 for _ in range(len(dominoes))] # To mark visited nodes with depths\\n        res = list(dominoes)\\n        # Add to queue nodes with \\'L\\' or \\'R\\' as a sources\\n        for i, x in enumerate(dominoes): \\n            if x != \\'.\\':\\n                qq.append((i, 1, x))\\n                was[i] = -1\\n\\t\\t# BFS\\n        while qq: \\n            idx, depth, direction = qq.popleft()\\n            if idx < 0 or idx >= len(res): # Check whether the borders are exceeded\\n                continue\\n            if was[idx] == depth: # Check if this node is pushed from both sides\\n                res[idx] = \\'.\\'\\n            elif was[idx] <= 0: # Check if this node haven\\'t been visited\\n                was[idx] = depth\\n                qq.append((idx + mp[direction], depth + 1, direction))\\n                res[idx] = direction\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932475,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] str = dominoes.toCharArray();\\n        int n = str.length;\\n        Queue<Pair> que = new LinkedList<>();\\n        for(int i = 0; i < n ; i++) \\n            if(str[i] != \\'.\\') que.add(new Pair(i, str[i]));\\n        \\n        while(!que.isEmpty()) {\\n            Pair rem = que.remove();\\n            if(rem.c == \\'L\\'){\\n                if(rem.i - 1 >= 0 && str[rem.i - 1] == \\'.\\') {\\n                    int nidx = rem.i - 1;\\n                    str[nidx] = \\'L\\';\\n                    que.add(new Pair(nidx, \\'L\\'));\\n                }\\n            } else {\\n                if(rem.i + 1 < n && str[rem.i + 1] == \\'.\\') {\\n                    if(rem.i + 2 < n && str[rem.i + 2] == \\'L\\') que.remove();\\n                    else {\\n                        int nidx = rem.i + 1;\\n                        str[nidx] = \\'R\\';\\n                        que.add(new Pair(nidx, \\'R\\'));\\n                    }\\n                }\\n            }\\n        }\\n        return new String(str);\\n    }\\n    \\n    class Pair {\\n        int i;\\n        char c;\\n        Pair(int i, char c) {\\n            this.i = i;\\n            this.c = c;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] str = dominoes.toCharArray();\\n        int n = str.length;\\n        Queue<Pair> que = new LinkedList<>();\\n        for(int i = 0; i < n ; i++) \\n            if(str[i] != \\'.\\') que.add(new Pair(i, str[i]));\\n        \\n        while(!que.isEmpty()) {\\n            Pair rem = que.remove();\\n            if(rem.c == \\'L\\'){\\n                if(rem.i - 1 >= 0 && str[rem.i - 1] == \\'.\\') {\\n                    int nidx = rem.i - 1;\\n                    str[nidx] = \\'L\\';\\n                    que.add(new Pair(nidx, \\'L\\'));\\n                }\\n            } else {\\n                if(rem.i + 1 < n && str[rem.i + 1] == \\'.\\') {\\n                    if(rem.i + 2 < n && str[rem.i + 2] == \\'L\\') que.remove();\\n                    else {\\n                        int nidx = rem.i + 1;\\n                        str[nidx] = \\'R\\';\\n                        que.add(new Pair(nidx, \\'R\\'));\\n                    }\\n                }\\n            }\\n        }\\n        return new String(str);\\n    }\\n    \\n    class Pair {\\n        int i;\\n        char c;\\n        Pair(int i, char c) {\\n            this.i = i;\\n            this.c = c;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788135,
                "title": "java-easy-approach-with-comments",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String d) {\\n        int n = d.length();\\n        char[] arr = new char[n+2];//+2 as we will placed a dummy domino L on left and R on right\\n        arr[0] = \\'L\\';\\n        arr[arr.length-1] = \\'R\\';\\n        \\n        for(int i = 1; i < arr.length-1 ; i++){\\n            arr[i] = d.charAt(i-1);//as we put 1 and last so we start from 1 but char is at 0 so i-1    \\n        }\\n        \\n        int i = 0 , j = 1;//using two pointers we will find the posn for the pairs of dominoes\\n        while(j < arr.length){\\n            while(arr[j] == \\'.\\') \\n                j++;//till we found a L Or R move j ahead\\n            if(j - i > 1){\\n                solve(arr, i , j);//after finding it pass the index of it and its pair means i\\n            }\\n            i = j;//i will become j as its L|R\\n            j++;//and j againg will go in search for its pair\\n        }\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t//As first one was dummy just to make pairing and same for the last one so skip them in main ans\\n        for(int k = 1;k < arr.length-1; k++){\\n            sb.append(arr[k]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    \\n    \\n    private void solve(char[] arr , int i , int j){\\n        //#1 when there is L ... L then all in between will be L only \\\\\\\\\\\\\\\\\\\\\\n        if(arr[i] == \\'L\\' && arr[j] == \\'L\\'){\\n            for(int k = i + 1; k < j; k++){//from i+1 till just before j\\n                arr[k] = \\'L\\';\\n            }\\n        }\\n        \\n        //#2 when there is R ... R then all in between will be R only /////\\n        else if(arr[i] == \\'R\\' && arr[j] == \\'R\\'){\\n            for(int k = i + 1; k < j; k++){//from i+1 till just before j\\n                arr[k] = \\'R\\';\\n            }\\n        }\\n        \\n        //#3 when there is L....R then both will not affect in bet as \\\\...../\\n        else if(arr[i] == \\'L\\' && arr[j] == \\'R\\'){\\n            //do nothing and chill\\n        }\\n        \\n        //#4 when there is R....L then two more cases as\\n        else if(arr[i] == \\'R\\' && arr[j] == \\'L\\'){\\n            int diff = j - i;//the space in between those two\\n            int mid = (i + j) / 2;\\n            if(diff % 2 == 0){//if diff is even then R ... L r at 2and l at 6 then 6-2=4 so RR.LL //|\\\\\\\\\\n                for(int k = i+1; k < j; k++){\\n                    if(k < mid){\\n                        arr[k] = \\'R\\';\\n                    }else if(k == mid){\\n                        //do nothing\\n                    }else if(k > mid){\\n                        arr[k] = \\'L\\';\\n                    }\\n                }\\n            }\\n            else if(diff % 2 != 0){//if diff is odd then R .... L r at 2and l at 7 then 7-2=5 so RRRLLL ///\\\\\\\\\\\\\\n                for(int k = i+1; k < j; k++){\\n                    if(k <= mid){\\n                        arr[k] = \\'R\\';\\n                    }else if(k > mid){\\n                        arr[k] = \\'L\\';\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String d) {\\n        int n = d.length();\\n        char[] arr = new char[n+2];//+2 as we will placed a dummy domino L on left and R on right\\n        arr[0] = \\'L\\';\\n        arr[arr.length-1] = \\'R\\';\\n        \\n        for(int i = 1; i < arr.length-1 ; i++){\\n            arr[i] = d.charAt(i-1);//as we put 1 and last so we start from 1 but char is at 0 so i-1    \\n        }\\n        \\n        int i = 0 , j = 1;//using two pointers we will find the posn for the pairs of dominoes\\n        while(j < arr.length){\\n            while(arr[j] == \\'.\\') \\n                j++;//till we found a L Or R move j ahead\\n            if(j - i > 1){\\n                solve(arr, i , j);//after finding it pass the index of it and its pair means i\\n            }\\n            i = j;//i will become j as its L|R\\n            j++;//and j againg will go in search for its pair\\n        }\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t//As first one was dummy just to make pairing and same for the last one so skip them in main ans\\n        for(int k = 1;k < arr.length-1; k++){\\n            sb.append(arr[k]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    \\n    \\n    private void solve(char[] arr , int i , int j){\\n        //#1 when there is L ... L then all in between will be L only \\\\\\\\\\\\\\\\\\\\\\n        if(arr[i] == \\'L\\' && arr[j] == \\'L\\'){\\n            for(int k = i + 1; k < j; k++){//from i+1 till just before j\\n                arr[k] = \\'L\\';\\n            }\\n        }\\n        \\n        //#2 when there is R ... R then all in between will be R only /////\\n        else if(arr[i] == \\'R\\' && arr[j] == \\'R\\'){\\n            for(int k = i + 1; k < j; k++){//from i+1 till just before j\\n                arr[k] = \\'R\\';\\n            }\\n        }\\n        \\n        //#3 when there is L....R then both will not affect in bet as \\\\...../\\n        else if(arr[i] == \\'L\\' && arr[j] == \\'R\\'){\\n            //do nothing and chill\\n        }\\n        \\n        //#4 when there is R....L then two more cases as\\n        else if(arr[i] == \\'R\\' && arr[j] == \\'L\\'){\\n            int diff = j - i;//the space in between those two\\n            int mid = (i + j) / 2;\\n            if(diff % 2 == 0){//if diff is even then R ... L r at 2and l at 6 then 6-2=4 so RR.LL //|\\\\\\\\\\n                for(int k = i+1; k < j; k++){\\n                    if(k < mid){\\n                        arr[k] = \\'R\\';\\n                    }else if(k == mid){\\n                        //do nothing\\n                    }else if(k > mid){\\n                        arr[k] = \\'L\\';\\n                    }\\n                }\\n            }\\n            else if(diff % 2 != 0){//if diff is odd then R .... L r at 2and l at 7 then 7-2=5 so RRRLLL ///\\\\\\\\\\\\\\n                for(int k = i+1; k < j; k++){\\n                    if(k <= mid){\\n                        arr[k] = \\'R\\';\\n                    }else if(k > mid){\\n                        arr[k] = \\'L\\';\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787549,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] ch = dominoes.toCharArray();\\n        //pos, power, time\\n        int len = ch.length;\\n        //\\u4EE3\\u8868\\u53D7\\u529B\\u65F6\\u95F4\\n        int[] time = new int[len];\\n\\n        //\\u4EE3\\u8868\\u6700\\u65B0\\u72B6\\u6001\\n        // char[] update = new char[len];\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n\\n        for(int i = 0; i < len; i ++){\\n            if(ch[i] == \\'.\\')\\n                continue;\\n            int dir = (ch[i] == \\'L\\') ? -1 : 1;\\n            queue.offer(new int[]{i, dir, 1});\\n            time[i] = 1;\\n        }\\n\\n        while(! queue.isEmpty()){\\n            //\\u6BCF\\u4E00\\u8F6E--> \\u4E00\\u4E2A\\u65F6\\u95F4\\u70B9time\\n            int[] info = queue.poll();\\n            int pos = info[0];\\n            int dir = info[1];\\n            int hour = info[2];\\n\\n            int npos = pos + dir;\\n            if((ch[pos] == \\'.\\') || npos < 0 || npos > len - 1)\\n               continue;\\n\\n            //\\u5224\\u65AD\\u662F\\u5426\\u9996\\u6B21\\u53D7\\u529B\\n            if(time[npos] == 0){\\n                time[npos] = hour + 1;\\n                ch[npos] = ((dir == -1) ? \\'L\\' : \\'R\\');\\n                queue.offer(new int[]{npos, dir, hour + 1});\\n            }else if(time[npos] == hour + 1){\\n                ch[npos] = \\'.\\';\\n            }\\n            \\n        }\\n\\n        // return new String(update);\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] ch = dominoes.toCharArray();\\n        //pos, power, time\\n        int len = ch.length;\\n        //\\u4EE3\\u8868\\u53D7\\u529B\\u65F6\\u95F4\\n        int[] time = new int[len];\\n\\n        //\\u4EE3\\u8868\\u6700\\u65B0\\u72B6\\u6001\\n        // char[] update = new char[len];\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n\\n        for(int i = 0; i < len; i ++){\\n            if(ch[i] == \\'.\\')\\n                continue;\\n            int dir = (ch[i] == \\'L\\') ? -1 : 1;\\n            queue.offer(new int[]{i, dir, 1});\\n            time[i] = 1;\\n        }\\n\\n        while(! queue.isEmpty()){\\n            //\\u6BCF\\u4E00\\u8F6E--> \\u4E00\\u4E2A\\u65F6\\u95F4\\u70B9time\\n            int[] info = queue.poll();\\n            int pos = info[0];\\n            int dir = info[1];\\n            int hour = info[2];\\n\\n            int npos = pos + dir;\\n            if((ch[pos] == \\'.\\') || npos < 0 || npos > len - 1)\\n               continue;\\n\\n            //\\u5224\\u65AD\\u662F\\u5426\\u9996\\u6B21\\u53D7\\u529B\\n            if(time[npos] == 0){\\n                time[npos] = hour + 1;\\n                ch[npos] = ((dir == -1) ? \\'L\\' : \\'R\\');\\n                queue.offer(new int[]{npos, dir, hour + 1});\\n            }else if(time[npos] == hour + 1){\\n                ch[npos] = \\'.\\';\\n            }\\n            \\n        }\\n\\n        // return new String(update);\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772330,
                "title": "c-bfs-dp-o-n",
                "content": "**Idea**\\nFinal state of a domino depends upon the time of `left` and `right` force applied on it.\\n* if time of left force <time of right force, then state of that domino will be `L`\\n* if time of left force >time of right force, then state of that domino will be `R`\\n* if time of left force = time of right force **(balanced state)**, then state of that domino will be `.`\\n\\nThis can be done using bfs.\\n**Time complexity**: O(n) , **Space complexity**: O(n)\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        vector<bool> vis(s.size(),0); // to track the processed indices\\n        vector<int> left(s.size(),INT_MAX);  // to store time of left force on index i\\n        vector<int> right(s.size(),INT_MAX);  // to store time of right force on index i\\n        queue<int> q;  // to store the under process indices\\n        \\n        for(int i = 0; i<s.size();++i){  // initialize all the initial state of\\n            if(s[i]==\\'L\\'){               //  left and right with time 0\\n               q.push(i); vis[i] = 1; left[i] = 0;\\n            }\\n            if(s[i]==\\'R\\'){\\n               q.push(i); vis[i] = 1; right[i] = 0;\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int t = q.size();\\n            while(t--){\\n                int i = q.front(); q.pop();\\n                if(left[i]<right[i]){\\n                    s[i]=\\'L\\'; \\n                    if(i-1>=0){  // state \\'L\\' will always push its previous index to left\\n                        left[i-1]=min(left[i]+1,left[i-1]);  // store the min time of left force\\n                        if(vis[i-1]==0){\\n                            vis[i-1]=1; q.push(i-1);\\n                        }\\n                    }\\n                }\\n                else if(right[i]<left[i]){ \\n                    s[i]=\\'R\\';\\n                    if(i+1<s.size()){   // state \\'R\\' will always push its next index to right\\n                        right[i+1] = min(right[i]+1,right[i+1]);   // store the min time of right force\\n                        if(vis[i+1]==0){\\n                            vis[i+1]=1; q.push(i+1);\\n                        }\\n                    }\\n                }\\n                else s[i]=\\'.\\';\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        vector<bool> vis(s.size(),0); // to track the processed indices\\n        vector<int> left(s.size(),INT_MAX);  // to store time of left force on index i\\n        vector<int> right(s.size(),INT_MAX);  // to store time of right force on index i\\n        queue<int> q;  // to store the under process indices\\n        \\n        for(int i = 0; i<s.size();++i){  // initialize all the initial state of\\n            if(s[i]==\\'L\\'){               //  left and right with time 0\\n               q.push(i); vis[i] = 1; left[i] = 0;\\n            }\\n            if(s[i]==\\'R\\'){\\n               q.push(i); vis[i] = 1; right[i] = 0;\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int t = q.size();\\n            while(t--){\\n                int i = q.front(); q.pop();\\n                if(left[i]<right[i]){\\n                    s[i]=\\'L\\'; \\n                    if(i-1>=0){  // state \\'L\\' will always push its previous index to left\\n                        left[i-1]=min(left[i]+1,left[i-1]);  // store the min time of left force\\n                        if(vis[i-1]==0){\\n                            vis[i-1]=1; q.push(i-1);\\n                        }\\n                    }\\n                }\\n                else if(right[i]<left[i]){ \\n                    s[i]=\\'R\\';\\n                    if(i+1<s.size()){   // state \\'R\\' will always push its next index to right\\n                        right[i+1] = min(right[i]+1,right[i+1]);   // store the min time of right force\\n                        if(vis[i+1]==0){\\n                            vis[i+1]=1; q.push(i+1);\\n                        }\\n                    }\\n                }\\n                else s[i]=\\'.\\';\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706706,
                "title": "python-o-n-with-detailed-comments-explaining",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        arr = [[position, 1] for position in dominoes] #form = [[falling direction, seconds needed to fall]]\\n            #R means its already falling to right \\n            #L means its already falling to left\\n            #r means its standing still but the dominoe next to it is potentially falling to right\\n            #we need r because when there is dominoes falling from left this r may be changed to L or .\\n            #it will be changed to . if the dominoe falling to L is as far from it as the domnoe falling to right\\n            #it will be changed to L if the dominoe falling to L is closer to it than the one falling to right\\n            #by closer we mean it takes less seconds\\n            #the array we are keeping stores seconds needed for each dominoe to fall to a direction\\n            #in the case of . the seconds are trash meaning we don\\'t really care about them\\n            #in the end we change all dominoes with r to R\\n            #NOTE: this code may be simplified but i am lazy to simplify it :P\\n\\t\\t\\t\\n        for right in range(0,len(dominoes) - 1):\\n            next_direction, next_seconds = arr[right + 1]\\n            curr_direction, curr_seconds = arr[right]\\n            if curr_direction in (\"R\", \"r\") and next_direction == \".\":\\n                arr[right + 1] = [\\'r\\', curr_seconds + 1]\\n        \\n        for left in range(len(dominoes) - 1, 0, -1):\\n            next_direction, next_seconds = arr[left - 1]\\n            curr_direction, curr_seconds = arr[left]\\n            if curr_direction in (\"L\", \\'l\\'):\\n                if next_direction == \\'.\\':\\n                    arr[left - 1] = [\\'L\\', curr_seconds + 1]\\n                elif next_direction == \"r\" and curr_seconds + 1 < next_seconds:\\n                    arr[left - 1] = [\\'L\\', curr_seconds + 1]\\n                elif next_direction == \"r\" and curr_seconds + 1 == next_seconds:\\n                    arr[left - 1] = [\\'.\\', 1]\\n        res = \\'\\'\\n        for i in range(0,len(arr)):\\n            direction = arr[i][0]\\n            if direction == \"r\":\\n                res += \"R\"\\n            else:\\n                res += direction\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        arr = [[position, 1] for position in dominoes] #form = [[falling direction, seconds needed to fall]]\\n            #R means its already falling to right \\n            #L means its already falling to left\\n            #r means its standing still but the dominoe next to it is potentially falling to right\\n            #we need r because when there is dominoes falling from left this r may be changed to L or .\\n            #it will be changed to . if the dominoe falling to L is as far from it as the domnoe falling to right\\n            #it will be changed to L if the dominoe falling to L is closer to it than the one falling to right\\n            #by closer we mean it takes less seconds\\n            #the array we are keeping stores seconds needed for each dominoe to fall to a direction\\n            #in the case of . the seconds are trash meaning we don\\'t really care about them\\n            #in the end we change all dominoes with r to R\\n            #NOTE: this code may be simplified but i am lazy to simplify it :P\\n\\t\\t\\t\\n        for right in range(0,len(dominoes) - 1):\\n            next_direction, next_seconds = arr[right + 1]\\n            curr_direction, curr_seconds = arr[right]\\n            if curr_direction in (\"R\", \"r\") and next_direction == \".\":\\n                arr[right + 1] = [\\'r\\', curr_seconds + 1]\\n        \\n        for left in range(len(dominoes) - 1, 0, -1):\\n            next_direction, next_seconds = arr[left - 1]\\n            curr_direction, curr_seconds = arr[left]\\n            if curr_direction in (\"L\", \\'l\\'):\\n                if next_direction == \\'.\\':\\n                    arr[left - 1] = [\\'L\\', curr_seconds + 1]\\n                elif next_direction == \"r\" and curr_seconds + 1 < next_seconds:\\n                    arr[left - 1] = [\\'L\\', curr_seconds + 1]\\n                elif next_direction == \"r\" and curr_seconds + 1 == next_seconds:\\n                    arr[left - 1] = [\\'.\\', 1]\\n        res = \\'\\'\\n        for i in range(0,len(arr)):\\n            direction = arr[i][0]\\n            if direction == \"r\":\\n                res += \"R\"\\n            else:\\n                res += direction\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656430,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        //method 2 based on distance\\n        int n=dominoes.size();\\n        vector<int> right(n,INT_MAX),left(n,INT_MAX);\\n        \\n        //fill right\\n        if(dominoes[0]==\\'R\\') right[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'L\\') continue;\\n            else if(dominoes[i]==\\'R\\') right[i]=0;\\n            else if(right[i-1]!=INT_MAX) right[i]=right[i-1]+1;\\n            else right[i]=INT_MAX;\\n        }\\n        //fill left\\n        if(dominoes[n-1]==\\'L\\') left[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'R\\') continue;\\n            else if(dominoes[i]==\\'L\\') left[i]=0;\\n            else if(left[i+1]!=INT_MAX) left[i]=left[i+1]+1;\\n            else left[i]=INT_MAX;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]!=right[i])\\n            {\\n                dominoes[i]=left[i]<right[i]?\\'L\\':\\'R\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        //method 2 based on distance\\n        int n=dominoes.size();\\n        vector<int> right(n,INT_MAX),left(n,INT_MAX);\\n        \\n        //fill right\\n        if(dominoes[0]==\\'R\\') right[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'L\\') continue;\\n            else if(dominoes[i]==\\'R\\') right[i]=0;\\n            else if(right[i-1]!=INT_MAX) right[i]=right[i-1]+1;\\n            else right[i]=INT_MAX;\\n        }\\n        //fill left\\n        if(dominoes[n-1]==\\'L\\') left[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'R\\') continue;\\n            else if(dominoes[i]==\\'L\\') left[i]=0;\\n            else if(left[i+1]!=INT_MAX) left[i]=left[i+1]+1;\\n            else left[i]=INT_MAX;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]!=right[i])\\n            {\\n                dominoes[i]=left[i]<right[i]?\\'L\\':\\'R\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415904,
                "title": "easy-c-faster-than-97-algorithm",
                "content": "Algorithm:\\n\\nOnly four cases:\\n\\nAny character can be between\\n1. \"L\" and \"L\"  --> All in betweens would be \"L\" too.\\n2. \"L\" and \"R\"  --> All from [L, R] would remain as it is(no effect)\\n3. \"R\" and \"L\" --> would depend either the number of dots between are even or odd, iff even then half R\\'s would come and half L\\'s would come, iff odd then half R\\'s followed by a dot and half L\\'s. (I have taken one less L than half because it would be taken care of in one of other 3 cases).\\n4. \"R\" and \"R\"  --> All in betweens would be \"R\" too.\\n\\n\\texcept for those which are in beginning or end, for those explicitly add one \"L\" at beginnig and one \"R\" at end, because they are not gonna make any difference and we won\\'t need to handle that case explicitly.\\n\\tFinally remove first char and last char which we added and return the string.\\n\\t\\n\\tCode: \\n\\t\\n\\t\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n    string pushDominoes(string dominoes) {\\n        string helper = \"L\" + dominoes + \"R\";\\n        int lo = 0, hi = 1;\\n        string ans = \"\";\\n        while(hi <= helper.length()){\\n            bool flag = true;\\n            while(helper[hi] == \\'.\\'){\\n                hi++;\\n                if(hi == helper.length()){\\n                    break;\\n                }\\n            }\\n            if(hi == helper.length()){\\n                break;\\n            }\\n            if(flag && helper[lo] == \\'L\\' && helper[hi] == \\'L\\'){\\n                while(lo < hi){\\n                    ans += \\'L\\';\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'L\\' && helper[hi] == \\'R\\'){\\n                while(lo < hi){\\n                    ans += helper[lo];\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'R\\' && helper[hi] == \\'R\\'){\\n                while(lo < hi){\\n                    ans += \\'R\\';\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'R\\' && helper[hi] == \\'L\\'){\\n                int count = 0;\\n                while(lo <= hi){\\n                    count++;\\n                    lo++;\\n                }\\n                flag = false;\\n                if(count % 2 == 0){\\n                    for(int i=0;i<count/2;i++){\\n                        ans += \\'R\\';\\n                    }\\n                    for(int i=0;i<(count/2)-1;i++){\\n                        ans += \\'L\\';\\n                    }\\n                } else {\\n                    for(int i=0;i<count/2;i++){\\n                        ans += \\'R\\';\\n                    }\\n                    ans += \\'.\\';\\n                    for(int i=0;i<(count/2)-1;i++){\\n                        ans += \\'L\\';\\n                    }\\n                }\\n                lo--;\\n                hi++;\\n            }\\n        }\\n        \\n        return ans.substr(1, ans.length()-1); \\n        \\n    }\\n\\t};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\n\\tpublic:\\n    string pushDominoes(string dominoes) {\\n        string helper = \"L\" + dominoes + \"R\";\\n        int lo = 0, hi = 1;\\n        string ans = \"\";\\n        while(hi <= helper.length()){\\n            bool flag = true;\\n            while(helper[hi] == \\'.\\'){\\n                hi++;\\n                if(hi == helper.length()){\\n                    break;\\n                }\\n            }\\n            if(hi == helper.length()){\\n                break;\\n            }\\n            if(flag && helper[lo] == \\'L\\' && helper[hi] == \\'L\\'){\\n                while(lo < hi){\\n                    ans += \\'L\\';\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'L\\' && helper[hi] == \\'R\\'){\\n                while(lo < hi){\\n                    ans += helper[lo];\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'R\\' && helper[hi] == \\'R\\'){\\n                while(lo < hi){\\n                    ans += \\'R\\';\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'R\\' && helper[hi] == \\'L\\'){\\n                int count = 0;\\n                while(lo <= hi){\\n                    count++;\\n                    lo++;\\n                }\\n                flag = false;\\n                if(count % 2 == 0){\\n                    for(int i=0;i<count/2;i++){\\n                        ans += \\'R\\';\\n                    }\\n                    for(int i=0;i<(count/2)-1;i++){\\n                        ans += \\'L\\';\\n                    }\\n                } else {\\n                    for(int i=0;i<count/2;i++){\\n                        ans += \\'R\\';\\n                    }\\n                    ans += \\'.\\';\\n                    for(int i=0;i<(count/2)-1;i++){\\n                        ans += \\'L\\';\\n                    }\\n                }\\n                lo--;\\n                hi++;\\n            }\\n        }\\n        \\n        return ans.substr(1, ans.length()-1); \\n        \\n    }\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380406,
                "title": "solved-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        string mainstr=dominoes;\\n        int n=dominoes.length();\\n        queue<int>q;\\n        for(int i=0;i<dominoes.length();i++)\\n        {  \\n            if(dominoes[i]==\\'R\\'||dominoes[i]==\\'L\\')\\n            {q.push(i);}\\n        }\\n        \\n        while(!q.empty())\\n        {\\n           \\n            int size=q.size();\\n            string str=mainstr;\\n            while(size)\\n            {\\n                size--;\\n                int ind=q.front();\\n                q.pop();\\n               if(mainstr[ind]==\\'L\\')\\n               {\\n                   int index=ind-1;\\n                   if(index>=0&&mainstr[index]==\\'.\\')\\n                   {\\n                      \\n                       if(index-1<0||mainstr[index-1]!=\\'R\\'){str[index]=\\'L\\';q.push(index);}\\n                       \\n                   }\\n                       \\n               }\\n            else\\n            {\\n                 int index=ind+1;\\n                   if(index<n&&mainstr[index]==\\'.\\')\\n                   {\\n                      \\n                       if(index+1>=n||mainstr[index+1]!=\\'L\\'){str[index]=\\'R\\';q.push(index);}\\n                       \\n                   }\\n            }\\n                \\n              \\n                \\n            }\\n            mainstr=str;\\n        }\\n        return mainstr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        string mainstr=dominoes;\\n        int n=dominoes.length();\\n        queue<int>q;\\n        for(int i=0;i<dominoes.length();i++)\\n        {  \\n            if(dominoes[i]==\\'R\\'||dominoes[i]==\\'L\\')\\n            {q.push(i);}\\n        }\\n        \\n        while(!q.empty())\\n        {\\n           \\n            int size=q.size();\\n            string str=mainstr;\\n            while(size)\\n            {\\n                size--;\\n                int ind=q.front();\\n                q.pop();\\n               if(mainstr[ind]==\\'L\\')\\n               {\\n                   int index=ind-1;\\n                   if(index>=0&&mainstr[index]==\\'.\\')\\n                   {\\n                      \\n                       if(index-1<0||mainstr[index-1]!=\\'R\\'){str[index]=\\'L\\';q.push(index);}\\n                       \\n                   }\\n                       \\n               }\\n            else\\n            {\\n                 int index=ind+1;\\n                   if(index<n&&mainstr[index]==\\'.\\')\\n                   {\\n                      \\n                       if(index+1>=n||mainstr[index+1]!=\\'L\\'){str[index]=\\'R\\';q.push(index);}\\n                       \\n                   }\\n            }\\n                \\n              \\n                \\n            }\\n            mainstr=str;\\n        }\\n        return mainstr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356829,
                "title": "c-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int N = dominoes.size();\\n        queue<int> todo;\\n        vector<int> fallLevel(N, -1);\\n        // Get currently falling dominoes\\n        for (int i = 0; i < N; i++) {\\n            if (dominoes[i] != \\'.\\') {\\n                todo.push(i); // { index, fall level }\\n                fallLevel[i] = 0; // { fall level }\\n            }\\n        }\\n        \\n        while (!todo.empty()) {\\n            int curIndex = todo.front();\\n            todo.pop();\\n            if (dominoes[curIndex] == \\'L\\') {\\n                if (isStatic(curIndex - 1, N, dominoes)) {\\n                    todo.push( curIndex - 1 );\\n                    dominoes[curIndex - 1] = \\'L\\';\\n                    fallLevel[curIndex - 1] = fallLevel[curIndex] + 1;\\n                }\\n            }\\n            else if (dominoes[curIndex] == \\'R\\') {\\n                if (isStatic(curIndex + 1, N, dominoes)) {\\n                    todo.push( curIndex + 1 );\\n                    dominoes[curIndex + 1] = \\'R\\';\\n                    fallLevel[curIndex + 1] = fallLevel[curIndex] + 1;\\n                }\\n            }\\n        }\\n        \\n        // Last pass for middle dominoes\\n        for (int i = 1; i < N - 1; i++) {\\n            if (fallLevel[i - 1] == fallLevel[i + 1] && fallLevel[i] != 0 && dominoes[i - 1] != dominoes[i + 1]) {\\n                dominoes[i] = \\'.\\';\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n    \\n    bool isStatic(int index, int &N, string &dominoes) {\\n        if (index < 0 || index >= N || dominoes[index] != \\'.\\') {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int N = dominoes.size();\\n        queue<int> todo;\\n        vector<int> fallLevel(N, -1);\\n        // Get currently falling dominoes\\n        for (int i = 0; i < N; i++) {\\n            if (dominoes[i] != \\'.\\') {\\n                todo.push(i); // { index, fall level }\\n                fallLevel[i] = 0; // { fall level }\\n            }\\n        }\\n        \\n        while (!todo.empty()) {\\n            int curIndex = todo.front();\\n            todo.pop();\\n            if (dominoes[curIndex] == \\'L\\') {\\n                if (isStatic(curIndex - 1, N, dominoes)) {\\n                    todo.push( curIndex - 1 );\\n                    dominoes[curIndex - 1] = \\'L\\';\\n                    fallLevel[curIndex - 1] = fallLevel[curIndex] + 1;\\n                }\\n            }\\n            else if (dominoes[curIndex] == \\'R\\') {\\n                if (isStatic(curIndex + 1, N, dominoes)) {\\n                    todo.push( curIndex + 1 );\\n                    dominoes[curIndex + 1] = \\'R\\';\\n                    fallLevel[curIndex + 1] = fallLevel[curIndex] + 1;\\n                }\\n            }\\n        }\\n        \\n        // Last pass for middle dominoes\\n        for (int i = 1; i < N - 1; i++) {\\n            if (fallLevel[i - 1] == fallLevel[i + 1] && fallLevel[i] != 0 && dominoes[i - 1] != dominoes[i + 1]) {\\n                dominoes[i] = \\'.\\';\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n    \\n    bool isStatic(int index, int &N, string &dominoes) {\\n        if (index < 0 || index >= N || dominoes[index] != \\'.\\') {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354143,
                "title": "java-simple-and-easy-to-understand-solution-t-o-n-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        \\n        StringBuilder sb = new StringBuilder(dominoes);\\n        \\n        int n = sb.length();\\n        \\n        \\n        //mark true for all the unpushed block, after pushing a bloch in right direction\\n        char prev = \\'.\\';\\n        boolean[] forward = new boolean[n];\\n        for(int i = 0; i < n; i++){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'R\\') forward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        //mark true for all the unpushed block, after pushing a block in left direction\\n        prev = \\'.\\';\\n        boolean[] backward  = new boolean[n];\\n        for(int i = n - 1; i >= 0; i--){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'L\\') backward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while(i < n){\\n            if(backward[i] && !forward[i]){\\n                //fall block as there is force in left direction\\n                sb.setCharAt(i++, \\'L\\');\\n                \\n            }else if(!backward[i] && forward[i]){\\n                //fall block as there is force in right direction\\n                sb.setCharAt(i++, \\'R\\');\\n                \\n            }else if(backward[i] && forward[i]){\\n                //fall block as there is force in both  direction\\n                int j = (i + 1);\\n                while(j < n && backward[j] && forward[j]){\\n                    j++;\\n                }\\n                pushDominoesInBetween(sb, i, j - 1);\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    \\n    private void pushDominoesInBetween(StringBuilder sb, int l, int r){\\n        while(l < r){\\n            sb.setCharAt(l++, \\'R\\');\\n            sb.setCharAt(r--, \\'L\\');\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        \\n        StringBuilder sb = new StringBuilder(dominoes);\\n        \\n        int n = sb.length();\\n        \\n        \\n        //mark true for all the unpushed block, after pushing a bloch in right direction\\n        char prev = \\'.\\';\\n        boolean[] forward = new boolean[n];\\n        for(int i = 0; i < n; i++){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'R\\') forward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        //mark true for all the unpushed block, after pushing a block in left direction\\n        prev = \\'.\\';\\n        boolean[] backward  = new boolean[n];\\n        for(int i = n - 1; i >= 0; i--){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'L\\') backward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while(i < n){\\n            if(backward[i] && !forward[i]){\\n                //fall block as there is force in left direction\\n                sb.setCharAt(i++, \\'L\\');\\n                \\n            }else if(!backward[i] && forward[i]){\\n                //fall block as there is force in right direction\\n                sb.setCharAt(i++, \\'R\\');\\n                \\n            }else if(backward[i] && forward[i]){\\n                //fall block as there is force in both  direction\\n                int j = (i + 1);\\n                while(j < n && backward[j] && forward[j]){\\n                    j++;\\n                }\\n                pushDominoesInBetween(sb, i, j - 1);\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    \\n    private void pushDominoesInBetween(StringBuilder sb, int l, int r){\\n        while(l < r){\\n            sb.setCharAt(l++, \\'R\\');\\n            sb.setCharAt(r--, \\'L\\');\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1790122,
                "content": [
                    {
                        "username": "veecos",
                        "content": "Think of the \".\" dominoes in terms of how far away they are from the influential dominoes. Think of distance as influence and only the nearest influential domino can exert control. Add all influences for both directions."
                    },
                    {
                        "username": "suhit",
                        "content": "Why is it that for this as input ,\\n\\ninput : \".L.R...LR..L..\"\\n\\nthis is not the correct output? \\noutput : \"LL.RRR.LRR.L..\"\\n\\nand this is the correct output? \\nexpected : \"LL.RR.LLRRLL..\"\\n\\nCan someone please explain? \\nWouldn\\'t there be a cascading effect?"
                    },
                    {
                        "username": "q121212",
                        "content": "just draw and separate to blocks. Each block is independent because either nothing falls on each other inside it, or only what falls inside it: \n( | \\ )  ( | / | | | \\ )   ( / | | \\ )   ( | | )\nthe same in result: (LL) (.RR.LL) (RRLL) (..)"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "yes, there is cascading effect but you are missing one point, that is at every second both left and right dominoes collapsing. So at index 3 right collapses to right and at index 7 left also collapses to left at the same time, again for indices 4 and 6  4 collapses to 5 and  6 collapses to 5 also since both are collapsing to 5 and question stated that they both have equal forces, therefore 5 remains stbale..........\\nHope I was able to clear your doubt\\uD83D\\uDE00"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Anyone was asked this as an interview question?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "The worst thing on leetcode - lack of standard test cases"
                    }
                ]
            },
            {
                "id": 1572223,
                "content": [
                    {
                        "username": "veecos",
                        "content": "Think of the \".\" dominoes in terms of how far away they are from the influential dominoes. Think of distance as influence and only the nearest influential domino can exert control. Add all influences for both directions."
                    },
                    {
                        "username": "suhit",
                        "content": "Why is it that for this as input ,\\n\\ninput : \".L.R...LR..L..\"\\n\\nthis is not the correct output? \\noutput : \"LL.RRR.LRR.L..\"\\n\\nand this is the correct output? \\nexpected : \"LL.RR.LLRRLL..\"\\n\\nCan someone please explain? \\nWouldn\\'t there be a cascading effect?"
                    },
                    {
                        "username": "q121212",
                        "content": "just draw and separate to blocks. Each block is independent because either nothing falls on each other inside it, or only what falls inside it: \n( | \\ )  ( | / | | | \\ )   ( / | | \\ )   ( | | )\nthe same in result: (LL) (.RR.LL) (RRLL) (..)"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "yes, there is cascading effect but you are missing one point, that is at every second both left and right dominoes collapsing. So at index 3 right collapses to right and at index 7 left also collapses to left at the same time, again for indices 4 and 6  4 collapses to 5 and  6 collapses to 5 also since both are collapsing to 5 and question stated that they both have equal forces, therefore 5 remains stbale..........\\nHope I was able to clear your doubt\\uD83D\\uDE00"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Anyone was asked this as an interview question?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "The worst thing on leetcode - lack of standard test cases"
                    }
                ]
            },
            {
                "id": 2077061,
                "content": [
                    {
                        "username": "veecos",
                        "content": "Think of the \".\" dominoes in terms of how far away they are from the influential dominoes. Think of distance as influence and only the nearest influential domino can exert control. Add all influences for both directions."
                    },
                    {
                        "username": "suhit",
                        "content": "Why is it that for this as input ,\\n\\ninput : \".L.R...LR..L..\"\\n\\nthis is not the correct output? \\noutput : \"LL.RRR.LRR.L..\"\\n\\nand this is the correct output? \\nexpected : \"LL.RR.LLRRLL..\"\\n\\nCan someone please explain? \\nWouldn\\'t there be a cascading effect?"
                    },
                    {
                        "username": "q121212",
                        "content": "just draw and separate to blocks. Each block is independent because either nothing falls on each other inside it, or only what falls inside it: \n( | \\ )  ( | / | | | \\ )   ( / | | \\ )   ( | | )\nthe same in result: (LL) (.RR.LL) (RRLL) (..)"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "yes, there is cascading effect but you are missing one point, that is at every second both left and right dominoes collapsing. So at index 3 right collapses to right and at index 7 left also collapses to left at the same time, again for indices 4 and 6  4 collapses to 5 and  6 collapses to 5 also since both are collapsing to 5 and question stated that they both have equal forces, therefore 5 remains stbale..........\\nHope I was able to clear your doubt\\uD83D\\uDE00"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Anyone was asked this as an interview question?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "The worst thing on leetcode - lack of standard test cases"
                    }
                ]
            },
            {
                "id": 2053538,
                "content": [
                    {
                        "username": "veecos",
                        "content": "Think of the \".\" dominoes in terms of how far away they are from the influential dominoes. Think of distance as influence and only the nearest influential domino can exert control. Add all influences for both directions."
                    },
                    {
                        "username": "suhit",
                        "content": "Why is it that for this as input ,\\n\\ninput : \".L.R...LR..L..\"\\n\\nthis is not the correct output? \\noutput : \"LL.RRR.LRR.L..\"\\n\\nand this is the correct output? \\nexpected : \"LL.RR.LLRRLL..\"\\n\\nCan someone please explain? \\nWouldn\\'t there be a cascading effect?"
                    },
                    {
                        "username": "q121212",
                        "content": "just draw and separate to blocks. Each block is independent because either nothing falls on each other inside it, or only what falls inside it: \n( | \\ )  ( | / | | | \\ )   ( / | | \\ )   ( | | )\nthe same in result: (LL) (.RR.LL) (RRLL) (..)"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "yes, there is cascading effect but you are missing one point, that is at every second both left and right dominoes collapsing. So at index 3 right collapses to right and at index 7 left also collapses to left at the same time, again for indices 4 and 6  4 collapses to 5 and  6 collapses to 5 also since both are collapsing to 5 and question stated that they both have equal forces, therefore 5 remains stbale..........\\nHope I was able to clear your doubt\\uD83D\\uDE00"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Anyone was asked this as an interview question?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "The worst thing on leetcode - lack of standard test cases"
                    }
                ]
            }
        ]
    }
]