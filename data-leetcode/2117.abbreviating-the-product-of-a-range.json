[
    {
        "title": "Abbreviating the Product of a Range",
        "question_content": "You are given two positive integers left and right with left <= right. Calculate the product of all integers in the inclusive range [left, right].\nSince the product may be very large, you will abbreviate it following these steps:\n\n\tCount all trailing zeros in the product and remove them. Let us denote this count as C.\n\t\n\t\tFor example, there are 3 trailing zeros in 1000, and there are 0 trailing zeros in 546.\n\t\n\t\n\tDenote the remaining number of digits in the product as d. If d > 10, then express the product as <pre>...<suf> where <pre> denotes the first 5 digits of the product, and <suf> denotes the last 5 digits of the product after removing all trailing zeros. If d <= 10, we keep it unchanged.\n\t\n\t\tFor example, we express 1234567654321 as 12345...54321, but 1234567 is represented as 1234567.\n\t\n\t\n\tFinally, represent the product as a string \"<pre>...<suf>eC\".\n\t\n\t\tFor example, 12345678987600000 will be represented as \"12345...89876e5\".\n\t\n\t\n\nReturn a string denoting the abbreviated product of all integers in the inclusive range [left, right].\n&nbsp;\nExample 1:\n\nInput: left = 1, right = 4\nOutput: \"24e0\"\nExplanation: The product is 1 &times; 2 &times; 3 &times; 4 = 24.\nThere are no trailing zeros, so 24 remains the same. The abbreviation will end with \"e0\".\nSince the number of digits is 2, which is less than 10, we do not have to abbreviate it further.\nThus, the final representation is \"24e0\".\n\nExample 2:\n\nInput: left = 2, right = 11\nOutput: \"399168e2\"\nExplanation: The product is 39916800.\nThere are 2 trailing zeros, which we remove to get 399168. The abbreviation will end with \"e2\".\nThe number of digits after removing the trailing zeros is 6, so we do not abbreviate it further.\nHence, the abbreviated product is \"399168e2\".\n\nExample 3:\n\nInput: left = 371, right = 375\nOutput: \"7219856259e3\"\nExplanation: The product is 7219856259000.\n\n&nbsp;\nConstraints:\n\n\t1 <= left <= right <= 104",
        "solutions": [
            {
                "id": 1647115,
                "title": "modulo-and-double",
                "content": "First, after any multiplication, we get rid of trailing zeros, counting them in `c`.\\n\\nNow, how to find out the last 5 digits of the product? For that, we multiply numbers, remove trailing zeros, and keep last `n` digits using the modulo operation. Simple.\\n\\nWhat about the first 5 digits? We could use `double`, multiply numbers, and *divide* the result by 10 until we only have 5 digits before the decimal point. The precision seems to be sufficient enough.\\n\\n**C++**\\n```cpp\\nstring abbreviateProduct(int left, int right) {\\n    long long suff = 1, c = 0, total = 0, max_suff = 100000000000;\\n    double pref = 1.0;\\n    for (int i = left; i <= right; ++i) {\\n        pref *= i;\\n        suff *= i;\\n        while (pref >= 100000) {\\n            pref /= 10;\\n            total = total == 0 ? 6 : total + 1; \\n        }\\n        while (suff % 10 == 0) {\\n            suff /= 10;\\n            ++c;\\n        }\\n        suff %= max_suff;\\n    }\\n    string s = to_string(suff);\\n    return to_string((int)pref) + (total - c <= 10 ? \"\" : \"...\") \\n            + (total - c < 5 ? \"\" : s.substr(s.size() - min(5LL, total - c - 5))) + \"e\" + to_string(c);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring abbreviateProduct(int left, int right) {\\n    long long suff = 1, c = 0, total = 0, max_suff = 100000000000;\\n    double pref = 1.0;\\n    for (int i = left; i <= right; ++i) {\\n        pref *= i;\\n        suff *= i;\\n        while (pref >= 100000) {\\n            pref /= 10;\\n            total = total == 0 ? 6 : total + 1; \\n        }\\n        while (suff % 10 == 0) {\\n            suff /= 10;\\n            ++c;\\n        }\\n        suff %= max_suff;\\n    }\\n    string s = to_string(suff);\\n    return to_string((int)pref) + (total - c <= 10 ? \"\" : \"...\") \\n            + (total - c < 5 ? \"\" : s.substr(s.size() - min(5LL, total - c - 5))) + \"e\" + to_string(c);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646608,
                "title": "c-java-python-scientific-notation-very-detailed-explanation-with-and-without-logarithm",
                "content": "\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n<br>\\n\\nThere is no free lunch, both logarithmic sum and scientific notation will definitely lose accuracy. we can only discard the last digits and keep the most important prefix as many as possible, actually `float` even `double` are also imprecise.\\n```\\nTime  Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\n\\n* **Solution 1: use float or double to record prefix, inspired by scientific notation**\\n\\t* keep `0.1 <= prod < 1.0`, so `len(str(int(prod * 100000))) == 5`, just like **scientific notation**\\n\\t\\t* so we can easily get `pre` via `pre = str(int(prod * 100000))`\\n\\t* `org_digits` is the number of digits of the original very very large product number, `zeros` is the number of its trailing zeros, so that `org_digits - zeros` is the number of its actual non-zero digits.\\n\\t* The error of `suf` can only come from the trailing zeros.\\n\\t\\t* Although we remove all of the trailing zeros every time and then take the modulus, but 2 and 5 as thedivision of suf may squeeze the effective digit length.\\n\\t\\t* so if we want to keep the exactly accurate last 5 Digits, we need to increase the digit length.\\n\\t\\t* Since `n` is less than or equal to  `10 ** 4`, there are no more than 5 trailing zeros that can be eliminated at one time. At this time, `n = 5 ** 5`, and the eliminated invalidity factor is `2 ** 5 = 32`, so we waste up to 5 digits for recording useless information at one time, so `suf %= 10 ** 14` is large enough to keep accurate 5 digits of `suf`.\\n\\t\\t* Another reason we chose `10 ** 14` is that `(10 ** 14) * (10 ** 4) = 10 ** 18` is in the range of `int64`, so it can be easily migrated to other programming languages such as Java and C++.\\n\\n\\n\\t\\t**Python**\\n\\t\\t```\\n\\t\\tclass Solution(object):\\n\\t\\t\\tdef abbreviateProduct(self, left, right):\\n\\t\\t\\t\\tprod, suf, zeros, org_digits = 1.0, 1, 0, 0\\n\\t\\t\\t\\tfor n in range(left, right + 1):\\n\\t\\t\\t\\t\\tprod *= n\\n\\t\\t\\t\\t\\twhile prod >= 1:  # keep 0.1 <= prod < 1.0, so len(str(int(prod * 100000))) == 5\\n\\t\\t\\t\\t\\t\\tprod /= 10\\n\\t\\t\\t\\t\\t\\torg_digits += 1  # add 1 while remove 1 digit\\n\\t\\t\\t\\t\\tsuf *= n\\n\\t\\t\\t\\t\\twhile suf % 10 == 0:  # count and remove the trailing zeros\\n\\t\\t\\t\\t\\t\\tzeros += 1\\n\\t\\t\\t\\t\\t\\tsuf //= 10\\n\\t\\t\\t\\t\\tif suf > 10 ** 14:\\n\\t\\t\\t\\t\\t\\tsuf %= 10 ** 14\\n\\t\\t\\t\\tif org_digits - zeros <= 10:\\n\\t\\t\\t\\t\\treturn str(int(prod * (10 ** (org_digits - zeros)) + 0.5)) + \\'e\\' + str(zeros)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# you may find that I add 0.5 before cast to int above, but not here.\\n\\t\\t\\t\\t\\t# It is because when org_digits - zeros <= 10, int(prod * (10 ** (org_digits - zeros)) + 0.5) is the actual\\n\\t\\t\\t\\t\\t# value, we add 0.5 to the last non-zero digits for rounding, 0.5 just means 0.5 over there.\\n\\t\\t\\t\\t\\t# However here int(prod * 100000) is the first 5-digit prefix, the 6-th digit is also a valid digit not\\n\\t\\t\\t\\t\\t# error.If we add 0.5 to 6-th digit, how do we calculate the first 6-digit or 7-digit prefix?\\n\\t\\t\\t\\t\\treturn str(int(prod * 100000)) + \\'...\\' + (\\'0000\\' + str(suf))[-5:] + \\'e\\' + str(zeros)\\n\\t\\t```\\n\\t\\t**C++**\\n\\t\\t```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring abbreviateProduct(int left, int right) {\\n\\t\\t\\t\\tlong long suf = 1;\\n\\t\\t\\t\\tint zeros = 0, org_digits = 0;\\n\\t\\t\\t\\tdouble prod = 1.0;\\n\\t\\t\\t\\tfor (int n = left; n <= right; n ++) {\\n\\t\\t\\t\\t\\tprod *= n;\\n\\t\\t\\t\\t\\twhile (prod >= 1.0) { // keep 0.1 <= prod < 1.0, so len(str(int(prod * 100000))) == 5\\n\\t\\t\\t\\t\\t\\tprod /= 10.0;\\n\\t\\t\\t\\t\\t\\torg_digits ++; // add 1 while remove 1 digit\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsuf *= n;\\n\\t\\t\\t\\t\\twhile (suf % 10 == 0) { // count and remove the trailing zeros\\n\\t\\t\\t\\t\\t\\tzeros ++;\\n\\t\\t\\t\\t\\t\\tsuf /= 10;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (suf > pow(10, 14)) suf %= (long long)pow(10, 14);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (org_digits - zeros <= 10) {\\n\\t\\t\\t\\t\\treturn to_string((long long)(prod * pow(10, org_digits - zeros) + 0.5)) + \\'e\\' + to_string(zeros);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// you may find that I add 0.5 before cast to int above, but not here.\\n\\t\\t\\t\\t\\t// It is because when org_digits - zeros <= 10, int(prod * (10 ** (org_digits - zeros)) + 0.5) is the actual\\n\\t\\t\\t\\t\\t// value, we add 0.5 to the last non-zero digits for rounding, 0.5 just means 0.5 over there.\\n\\t\\t\\t\\t\\t// However here int(prod * 100000) is the first 5-digit prefix, the 6-th digit is also a valid digit not\\n\\t\\t\\t\\t\\t// error.If we add 0.5 to 6-th digit, how do we calculate the first 6-digit or 7-digit prefix?\\n\\t\\t\\t\\t\\tstring str_suf = \"0000\" + to_string(suf);\\n\\t\\t\\t\\t\\treturn to_string((int)(prod * 100000)) + \"...\" + str_suf.substr(str_suf.length() - 5) + \\'e\\' + to_string(zeros);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t```\\n\\t\\t**Java**\\n\\t\\t```\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic String abbreviateProduct(int left, int right) {\\n\\t\\t\\t\\tlong suf = 1;\\n\\t\\t\\t\\tint zeros = 0, org_digits = 0;\\n\\t\\t\\t\\tdouble prod = 1.0;\\n\\t\\t\\t\\tfor (int n = left; n <= right; n ++) {\\n\\t\\t\\t\\t\\tprod *= n;\\n\\t\\t\\t\\t\\twhile (prod >= 1.0) { // keep 0.1 <= prod < 1.0, so len(str(int(prod * 100000))) == 5\\n\\t\\t\\t\\t\\t\\tprod /= 10.0;\\n\\t\\t\\t\\t\\t\\torg_digits ++; // add 1 while remove 1 digit\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsuf *= n;\\n\\t\\t\\t\\t\\twhile (suf % 10 == 0) { // count and remove the trailing zeros\\n\\t\\t\\t\\t\\t\\tzeros ++;\\n\\t\\t\\t\\t\\t\\tsuf /= 10;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (suf > Math.pow(10, 14)) suf %= (long)Math.pow(10, 14);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (org_digits - zeros <= 10) {\\n\\t\\t\\t\\t\\treturn (long)(prod * Math.pow(10, org_digits - zeros) + 0.5) + \"e\" + zeros;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// you may find that I add 0.5 before cast to int above, but not here.\\n\\t\\t\\t\\t\\t// It is because when org_digits - zeros <= 10, int(prod * (10 ** (org_digits - zeros)) + 0.5) is the actual\\n\\t\\t\\t\\t\\t// value, we add 0.5 to the last non-zero digits for rounding, 0.5 just means 0.5 over there.\\n\\t\\t\\t\\t\\t// However here int(prod * 100000) is the first 5-digit prefix, the 6-th digit is also a valid digit not\\n\\t\\t\\t\\t\\t// error.If we add 0.5 to 6-th digit, how do we calculate the first 6-digit or 7-digit prefix?\\n\\t\\t\\t\\t\\tString str_suf = \"0000\" + Long.toString(suf);\\n\\t\\t\\t\\t\\treturn (int)(prod * 100000) + \"...\" + str_suf.substring(str_suf.length() - 5) + \\'e\\' + zeros;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t```\\n\\n* **Solution 2\\uFF1Ause int64 to record prefix**\\n\\n\\t* `pre `and `suf` retain at most 13 digits each\\n\\t* They update separately\\n\\t* at any time, once the trailing `0` appears  it will not disappear.\\n\\t\\t* so we count trailing zeros in `suf`  immediately via `zeros += 1`, then remove them from suf via `suf //= 10`\\n\\t* My naive motivation is as long as `MAX` is large enough, the code above would work well.\\n\\t\\t```\\n\\t\\tclass Solution(object):\\n\\t\\t\\tdef abbreviateProduct(self, left, right):\\n\\t\\t\\t\\tMAX = 10 ** 13\\n\\t\\t\\t\\tpre, suf, zeros, org_digits = 1, 1, 0, 0\\n\\t\\t\\t\\tfor n in range(left, right + 1):\\n\\t\\t\\t\\t\\tpre *= n  # update pre\\n\\t\\t\\t\\t\\tsuf *= n  # update suf\\n\\t\\t\\t\\t\\twhile suf % 10 == 0:  # count and remove the trailing zeros\\n\\t\\t\\t\\t\\t\\tzeros += 1\\n\\t\\t\\t\\t\\t\\tsuf //= 10\\n\\t\\t\\t\\t\\tif suf > MAX:  # retain at most 13 digits\\n\\t\\t\\t\\t\\t\\tsuf %= MAX\\n\\t\\t\\t\\t\\twhile pre > MAX:  # retain at most 13 digits\\n\\t\\t\\t\\t\\t\\tif org_digits == 0:\\n\\t\\t\\t\\t\\t\\t\\torg_digits = 13\\n\\t\\t\\t\\t\\t\\tpre //= 10\\n\\t\\t\\t\\t\\t\\torg_digits += 1\\n\\t\\t\\t\\tif len(str(suf)) <= 10 and org_digits - zeros <= 10:\\n\\t\\t\\t\\t\\treturn str(suf)[:10] + \\'e\\' + str(zeros)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn str(pre)[:5] + \\'...\\' + str(suf)[-5:] + \\'e\\' + str(zeros)\\n\\t\\t```\\n\\t\\n\\n* **Solution 3: use logarithmic sum to record prefix**\\n\\t* I noticed a popular solution from another perspective using logarithmic sum, but since the time complexity is still `O(R - L)`, maybe it is no need to waste code to deal with 2 and 5 specially, removing them can make the code and the idea concise a lot.\\n\\t* the key idea is the logarithm of the product of a set of numbers is equal to the sum of the logarithms of the set of numbers.\\n\\t\\t* `log(a * b * c) = log(a) + log(b) + log(c)`\\n\\t* Although the multiplication of `1` to `10 ** 6` is very very large, far exceeding the range of any basic data type in the programming language, its logarithm base `10` is only `5565702.91719`\\n\\t\\t* however there is no free lunch, it must also loss precision when you recover the original large number N via power of `10`, like the 2 solutions above.\\n\\t* The integer part of the logarithm of a number N records the scale of N, and the decimal part records the precision of N.\\n\\t\\t* for example, `log10(37968) = 4.579417720873264`\\n\\t\\t\\t* `10 ** 0.579417720873264 = 3.7968000000000024`\\n\\t\\t\\t* `10 ** 4 = 10000`\\n\\t\\t\\t* `37968 = 10 ** 4.579417720873264 = (10 ** 4) * (10 ** 0.579417720873264)`\\n\\t\\t* Since `10 ** 0 = 1` and `10 ** 1 == 10`, for any `0 < x < 1`, `1 < 10 ** x < 10`, that also means so `len(str(int((10 ** x) * 100000))) == 5`\\n\\t\\t* **Essentially this is the same as scientific notation.**\\n\\t\\t```\\n\\t\\tclass Solution(object):\\n\\t\\t\\tdef abbreviateProduct(self, left, right):\\n\\t\\t\\t\\tsuf, zeros, log_sum, prod, org_digits = 1, 0, 0, 1.0, 0\\n\\t\\t\\t\\tfor n in range(left, right + 1):\\n\\t\\t\\t\\t\\tlog_sum += math.log10(n)\\n\\t\\t\\t\\t\\tsuf *= n\\n\\t\\t\\t\\t\\twhile suf % 10 == 0:  # count and remove the trailing zeros\\n\\t\\t\\t\\t\\t\\tzeros += 1\\n\\t\\t\\t\\t\\t\\tsuf //= 10\\n\\t\\t\\t\\t\\tif suf > 10 ** 8:\\n\\t\\t\\t\\t\\t\\tsuf %= 10 ** 8\\n\\t\\t\\t\\t\\tprod *= n\\n\\t\\t\\t\\t\\twhile prod > 1.0:\\n\\t\\t\\t\\t\\t\\torg_digits += 1\\n\\t\\t\\t\\t\\t\\tprod /= 10\\n\\t\\t\\t\\tif org_digits - zeros <= 10:\\n\\t\\t\\t\\t\\tpre = 10 ** (log_sum - int(log_sum) + 9)\\n\\t\\t\\t\\t\\treturn str(pre)[:max(1, org_digits - zeros)] + \\'e\\' + str(zeros)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpre = 10 ** (log_sum - int(log_sum) + 4)\\n\\t\\t\\t\\t\\treturn str(pre)[:5] + \\'...\\' + str(suf)[-5:] + \\'e\\' + str(zeros)\\n\\t\\t```\\n\\n\\n**PLEASE UPVOTE if you like \\uD83D\\uDE01 If you have any question, feel free to ask.**",
                "solutionTags": [],
                "code": "```\\nTime  Complexity: O(N)\\nSpace Complexity: O(1)\\n```\n```\\n\\t\\tclass Solution(object):\\n\\t\\t\\tdef abbreviateProduct(self, left, right):\\n\\t\\t\\t\\tprod, suf, zeros, org_digits = 1.0, 1, 0, 0\\n\\t\\t\\t\\tfor n in range(left, right + 1):\\n\\t\\t\\t\\t\\tprod *= n\\n\\t\\t\\t\\t\\twhile prod >= 1:  # keep 0.1 <= prod < 1.0, so len(str(int(prod * 100000))) == 5\\n\\t\\t\\t\\t\\t\\tprod /= 10\\n\\t\\t\\t\\t\\t\\torg_digits += 1  # add 1 while remove 1 digit\\n\\t\\t\\t\\t\\tsuf *= n\\n\\t\\t\\t\\t\\twhile suf % 10 == 0:  # count and remove the trailing zeros\\n\\t\\t\\t\\t\\t\\tzeros += 1\\n\\t\\t\\t\\t\\t\\tsuf //= 10\\n\\t\\t\\t\\t\\tif suf > 10 ** 14:\\n\\t\\t\\t\\t\\t\\tsuf %= 10 ** 14\\n\\t\\t\\t\\tif org_digits - zeros <= 10:\\n\\t\\t\\t\\t\\treturn str(int(prod * (10 ** (org_digits - zeros)) + 0.5)) + \\'e\\' + str(zeros)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# you may find that I add 0.5 before cast to int above, but not here.\\n\\t\\t\\t\\t\\t# It is because when org_digits - zeros <= 10, int(prod * (10 ** (org_digits - zeros)) + 0.5) is the actual\\n\\t\\t\\t\\t\\t# value, we add 0.5 to the last non-zero digits for rounding, 0.5 just means 0.5 over there.\\n\\t\\t\\t\\t\\t# However here int(prod * 100000) is the first 5-digit prefix, the 6-th digit is also a valid digit not\\n\\t\\t\\t\\t\\t# error.If we add 0.5 to 6-th digit, how do we calculate the first 6-digit or 7-digit prefix?\\n\\t\\t\\t\\t\\treturn str(int(prod * 100000)) + \\'...\\' + (\\'0000\\' + str(suf))[-5:] + \\'e\\' + str(zeros)\\n\\t\\t```\n```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring abbreviateProduct(int left, int right) {\\n\\t\\t\\t\\tlong long suf = 1;\\n\\t\\t\\t\\tint zeros = 0, org_digits = 0;\\n\\t\\t\\t\\tdouble prod = 1.0;\\n\\t\\t\\t\\tfor (int n = left; n <= right; n ++) {\\n\\t\\t\\t\\t\\tprod *= n;\\n\\t\\t\\t\\t\\twhile (prod >= 1.0) { // keep 0.1 <= prod < 1.0, so len(str(int(prod * 100000))) == 5\\n\\t\\t\\t\\t\\t\\tprod /= 10.0;\\n\\t\\t\\t\\t\\t\\torg_digits ++; // add 1 while remove 1 digit\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsuf *= n;\\n\\t\\t\\t\\t\\twhile (suf % 10 == 0) { // count and remove the trailing zeros\\n\\t\\t\\t\\t\\t\\tzeros ++;\\n\\t\\t\\t\\t\\t\\tsuf /= 10;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (suf > pow(10, 14)) suf %= (long long)pow(10, 14);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (org_digits - zeros <= 10) {\\n\\t\\t\\t\\t\\treturn to_string((long long)(prod * pow(10, org_digits - zeros) + 0.5)) + \\'e\\' + to_string(zeros);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// you may find that I add 0.5 before cast to int above, but not here.\\n\\t\\t\\t\\t\\t// It is because when org_digits - zeros <= 10, int(prod * (10 ** (org_digits - zeros)) + 0.5) is the actual\\n\\t\\t\\t\\t\\t// value, we add 0.5 to the last non-zero digits for rounding, 0.5 just means 0.5 over there.\\n\\t\\t\\t\\t\\t// However here int(prod * 100000) is the first 5-digit prefix, the 6-th digit is also a valid digit not\\n\\t\\t\\t\\t\\t// error.If we add 0.5 to 6-th digit, how do we calculate the first 6-digit or 7-digit prefix?\\n\\t\\t\\t\\t\\tstring str_suf = \"0000\" + to_string(suf);\\n\\t\\t\\t\\t\\treturn to_string((int)(prod * 100000)) + \"...\" + str_suf.substr(str_suf.length() - 5) + \\'e\\' + to_string(zeros);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t```\n```\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic String abbreviateProduct(int left, int right) {\\n\\t\\t\\t\\tlong suf = 1;\\n\\t\\t\\t\\tint zeros = 0, org_digits = 0;\\n\\t\\t\\t\\tdouble prod = 1.0;\\n\\t\\t\\t\\tfor (int n = left; n <= right; n ++) {\\n\\t\\t\\t\\t\\tprod *= n;\\n\\t\\t\\t\\t\\twhile (prod >= 1.0) { // keep 0.1 <= prod < 1.0, so len(str(int(prod * 100000))) == 5\\n\\t\\t\\t\\t\\t\\tprod /= 10.0;\\n\\t\\t\\t\\t\\t\\torg_digits ++; // add 1 while remove 1 digit\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsuf *= n;\\n\\t\\t\\t\\t\\twhile (suf % 10 == 0) { // count and remove the trailing zeros\\n\\t\\t\\t\\t\\t\\tzeros ++;\\n\\t\\t\\t\\t\\t\\tsuf /= 10;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (suf > Math.pow(10, 14)) suf %= (long)Math.pow(10, 14);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (org_digits - zeros <= 10) {\\n\\t\\t\\t\\t\\treturn (long)(prod * Math.pow(10, org_digits - zeros) + 0.5) + \"e\" + zeros;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// you may find that I add 0.5 before cast to int above, but not here.\\n\\t\\t\\t\\t\\t// It is because when org_digits - zeros <= 10, int(prod * (10 ** (org_digits - zeros)) + 0.5) is the actual\\n\\t\\t\\t\\t\\t// value, we add 0.5 to the last non-zero digits for rounding, 0.5 just means 0.5 over there.\\n\\t\\t\\t\\t\\t// However here int(prod * 100000) is the first 5-digit prefix, the 6-th digit is also a valid digit not\\n\\t\\t\\t\\t\\t// error.If we add 0.5 to 6-th digit, how do we calculate the first 6-digit or 7-digit prefix?\\n\\t\\t\\t\\t\\tString str_suf = \"0000\" + Long.toString(suf);\\n\\t\\t\\t\\t\\treturn (int)(prod * 100000) + \"...\" + str_suf.substring(str_suf.length() - 5) + \\'e\\' + zeros;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t```\n```\\n\\t\\tclass Solution(object):\\n\\t\\t\\tdef abbreviateProduct(self, left, right):\\n\\t\\t\\t\\tMAX = 10 ** 13\\n\\t\\t\\t\\tpre, suf, zeros, org_digits = 1, 1, 0, 0\\n\\t\\t\\t\\tfor n in range(left, right + 1):\\n\\t\\t\\t\\t\\tpre *= n  # update pre\\n\\t\\t\\t\\t\\tsuf *= n  # update suf\\n\\t\\t\\t\\t\\twhile suf % 10 == 0:  # count and remove the trailing zeros\\n\\t\\t\\t\\t\\t\\tzeros += 1\\n\\t\\t\\t\\t\\t\\tsuf //= 10\\n\\t\\t\\t\\t\\tif suf > MAX:  # retain at most 13 digits\\n\\t\\t\\t\\t\\t\\tsuf %= MAX\\n\\t\\t\\t\\t\\twhile pre > MAX:  # retain at most 13 digits\\n\\t\\t\\t\\t\\t\\tif org_digits == 0:\\n\\t\\t\\t\\t\\t\\t\\torg_digits = 13\\n\\t\\t\\t\\t\\t\\tpre //= 10\\n\\t\\t\\t\\t\\t\\torg_digits += 1\\n\\t\\t\\t\\tif len(str(suf)) <= 10 and org_digits - zeros <= 10:\\n\\t\\t\\t\\t\\treturn str(suf)[:10] + \\'e\\' + str(zeros)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn str(pre)[:5] + \\'...\\' + str(suf)[-5:] + \\'e\\' + str(zeros)\\n\\t\\t```\n```\\n\\t\\tclass Solution(object):\\n\\t\\t\\tdef abbreviateProduct(self, left, right):\\n\\t\\t\\t\\tsuf, zeros, log_sum, prod, org_digits = 1, 0, 0, 1.0, 0\\n\\t\\t\\t\\tfor n in range(left, right + 1):\\n\\t\\t\\t\\t\\tlog_sum += math.log10(n)\\n\\t\\t\\t\\t\\tsuf *= n\\n\\t\\t\\t\\t\\twhile suf % 10 == 0:  # count and remove the trailing zeros\\n\\t\\t\\t\\t\\t\\tzeros += 1\\n\\t\\t\\t\\t\\t\\tsuf //= 10\\n\\t\\t\\t\\t\\tif suf > 10 ** 8:\\n\\t\\t\\t\\t\\t\\tsuf %= 10 ** 8\\n\\t\\t\\t\\t\\tprod *= n\\n\\t\\t\\t\\t\\twhile prod > 1.0:\\n\\t\\t\\t\\t\\t\\torg_digits += 1\\n\\t\\t\\t\\t\\t\\tprod /= 10\\n\\t\\t\\t\\tif org_digits - zeros <= 10:\\n\\t\\t\\t\\t\\tpre = 10 ** (log_sum - int(log_sum) + 9)\\n\\t\\t\\t\\t\\treturn str(pre)[:max(1, org_digits - zeros)] + \\'e\\' + str(zeros)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpre = 10 ** (log_sum - int(log_sum) + 4)\\n\\t\\t\\t\\t\\treturn str(pre)[:5] + \\'...\\' + str(suf)[-5:] + \\'e\\' + str(zeros)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1646587,
                "title": "python-math-soluthion-explained",
                "content": "I will tidy up my code a bit later, for the moment what is important is idea. Basically, problem can be separated into 3 independet smaller problems:\\n\\n1. Find number of trailing zeroes.\\n2. Find last 5 digits which are not zeroes.\\n3. Find first 5 digits.\\n\\nLet us deal with this problems one by one.\\n1. To find number of trailing zeroes, we can use problem 172. Factorial Trailing Zeroes with modifications. We will find number of times divisors 2 and 5 met in our product and then choose the smallest one. I spend one fail attempt to catch the case like `L = R = 15`, then we have 1 five and 0 two.\\n2. Find last 5 digits which are not zeroes: here what we need to do is to multiply all numbers, but also divide it by correct number of 5 and 2. To make our life easier I consider cases `R - L <= 30` separately where I just calculate product which is not very big by hands, python allows us to do it. In all other cases we can be sure that number of `5` in our prime factorization is smaller than number of `2`. I do not have strict proof, but it will help to make code a bit easier. So, each time we have number divisible by `5`, we divide it by `5` as many times as possible. Also we keep count of how many times we need to divide by `2` and when we reached limit, we stop dividing.\\n3. Finally, how to find the first `5` digits of product. We will use logarithms and pray that we do not have rounding error. Indeed: `t = log10(L * (L+1) * ... * R) = log10(L) + ... + log10(R)`. What we need to take now is `10^(4 + {t})`, where `{t}` is fraction part. Luckily all tests were passed, probably because rounding error goes up and down and do not grow a lot.\\n\\n#### Complexity\\nIt is `O(R - L)` for time because we need to work with modules and also with logarithms.\\n\\n#### Code\\n```python\\nfrom math import log10, floor, ceil\\n\\nclass Solution:\\n    def abbreviateProduct(self, L, R):\\n        def TZ(n, q):\\n            ans = 0\\n            while q <= n:\\n                ans += n//q\\n                q *= 5\\n            return ans\\n\\n        c1 = TZ(R, 5) - TZ(L-1, 5)\\n        c2 = TZ(R, 2) - TZ(L-1, 2)\\n        tr_zeroes = min(c1, c2)\\n\\n        if R - L <= 30:\\n            ans = 1\\n            for i in range(L, R + 1):\\n                ans *= i\\n            ans_str = str(ans) if tr_zeroes == 0 else str(ans)[:-tr_zeroes]\\n                \\n            if len(ans_str) > 10:\\n                return ans_str[:5] + \"...\" + ans_str[-5:] + \"e\" + str(tr_zeroes)\\n            else:\\n                return ans_str + \"e\" + str(tr_zeroes)\\n            \\n        else:\\n            t = sum(log10(i) for i in range(L, R + 1))\\n            tmp = t - floor(t)\\n            first = floor(10**(tmp + 4))\\n\\n            last = 1\\n            to_do = tr_zeroes\\n            for i in range(L, R+1):\\n                Q = i\\n                while Q % 5 == 0: Q//=5\\n                if Q % 2 == 0 and to_do > 0:\\n                    Q = Q//2\\n                    to_do -= 1\\n                last = (last * Q) % 100000\\n\\n            return str(first) + \"...\" + \"0\" * (5 - len(str(last))) + str(last) + \"e\" + str(tr_zeroes)\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nfrom math import log10, floor, ceil\\n\\nclass Solution:\\n    def abbreviateProduct(self, L, R):\\n        def TZ(n, q):\\n            ans = 0\\n            while q <= n:\\n                ans += n//q\\n                q *= 5\\n            return ans\\n\\n        c1 = TZ(R, 5) - TZ(L-1, 5)\\n        c2 = TZ(R, 2) - TZ(L-1, 2)\\n        tr_zeroes = min(c1, c2)\\n\\n        if R - L <= 30:\\n            ans = 1\\n            for i in range(L, R + 1):\\n                ans *= i\\n            ans_str = str(ans) if tr_zeroes == 0 else str(ans)[:-tr_zeroes]\\n                \\n            if len(ans_str) > 10:\\n                return ans_str[:5] + \"...\" + ans_str[-5:] + \"e\" + str(tr_zeroes)\\n            else:\\n                return ans_str + \"e\" + str(tr_zeroes)\\n            \\n        else:\\n            t = sum(log10(i) for i in range(L, R + 1))\\n            tmp = t - floor(t)\\n            first = floor(10**(tmp + 4))\\n\\n            last = 1\\n            to_do = tr_zeroes\\n            for i in range(L, R+1):\\n                Q = i\\n                while Q % 5 == 0: Q//=5\\n                if Q % 2 == 0 and to_do > 0:\\n                    Q = Q//2\\n                    to_do -= 1\\n                last = (last * Q) % 100000\\n\\n            return str(first) + \"...\" + \"0\" * (5 - len(str(last))) + str(last) + \"e\" + str(tr_zeroes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646721,
                "title": "python-feel-so-sorry-about-the-man-who-was-asked-this-problem-in-the-interview",
                "content": "I don\\'t like this type of question,  although I solved it in the contest.   \\nIt is pure math,  and nearly doesn\\'t contain any algorithem.  Maybe the hedge found  like this problem. \\n\\n##### Also,  according to @hqztrue ,  there are possibly some annoying edge testcases,   if the product is like xxxxx99999999....  or xxxxx00000000,   many solution will fail due to the precision error.   I don\\'t think these test cases should be collected,   and problem author should make statement:    It is guaranteed that the 6-7 digits will not be 99 or 00. \\n\\nBut since someone asked it,  let me share my idea\\n**1,  count the number of zeros in the range(left,right):**\\nThis can be done by calculating total factor of 2s and 5s,  and take their minimum, that\\'s the number of 0s.\\n\\n**2,  remove the factor of 2 and 5 in the number range**\\nThe factor removed  both should be the same number of 0s  \\nIn step 1.  For example,  in the range (24,27), there are two 5s and four 2s   so number of 0s should be two,  you needed to divide two 2s in 24,  and two 5s in 25,  so the array[24,25,26,27] will become [6,1,26,27]\\n\\n**3,  iterate through the array for front 5 digits and rear 5 digits**\\nfor the rear 5 digits,  just take the mod 100000,  and for the front 5 digits, you can multiply these number together, and if the number greater than 100000,  you divide these number by 10 until the number smaller than 100000,  finally you take the integer part of the number. \\n\\nBelow is my code,  total time:  1396ms,  beat 100%.\\n\\n```\\nimport math \\nf2,f5 = [0]*1000001,  [0]*1000001\\nfor i in range(1,1000001):\\n    temp,d2,d5 = i,0,0\\n    while temp%2==0:\\n        temp = temp//2\\n        d2 += 1\\n    while temp%5==0:\\n        temp = temp//5\\n        d5 += 1\\n    f2[i] = f2[i-1] + d2\\n    f5[i] = f5[i-1] + d5\\n    \\nclass Solution(object):\\n    def abbreviateProduct(self, left, right):\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: str\\n        \"\"\"\\n        twos = f2[right] - f2[left-1]\\n        fives = f5[right] - f5[left-1]\\n        tens = min(fives,twos)\\n        rest2,rest5 = tens, tens\\n        nums = [i for i in range(left,right+1)]\\n        for i in range(len(nums)):\\n            while rest2>0 and nums[i]%2==0:\\n                nums[i] = nums[i] // 2\\n                rest2 -= 1\\n            while rest5>0 and nums[i]%5==0:\\n                nums[i] = nums[i] // 5\\n                rest5 -= 1      \\n        rear,realnum, = 1,1\\n        front = 1.0\\n\\t\\t\\n        for num in nums:\\n            front *= num\\n            while front > 100000:  \\n                front = front * 0.1 \\n            rear = rear * num\\n            rear = rear % 100000\\n            if realnum>0:  realnum = realnum * num\\n            if realnum>10**10:  realnum = -1\\n        front = int(front)\\n        \\n        if realnum>0:\\n            ans = str(realnum) + \"e\" + str(tens)\\n        else:\\n            rears = str(rear)\\n            if len(rears)<5:\\n                rears = \"0\"*(5-len(rears)) + rears\\n            ans = str(front)+\"...\"+rears+\"e\"+str(tens)   \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nimport math \\nf2,f5 = [0]*1000001,  [0]*1000001\\nfor i in range(1,1000001):\\n    temp,d2,d5 = i,0,0\\n    while temp%2==0:\\n        temp = temp//2\\n        d2 += 1\\n    while temp%5==0:\\n        temp = temp//5\\n        d5 += 1\\n    f2[i] = f2[i-1] + d2\\n    f5[i] = f5[i-1] + d5\\n    \\nclass Solution(object):\\n    def abbreviateProduct(self, left, right):\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: str\\n        \"\"\"\\n        twos = f2[right] - f2[left-1]\\n        fives = f5[right] - f5[left-1]\\n        tens = min(fives,twos)\\n        rest2,rest5 = tens, tens\\n        nums = [i for i in range(left,right+1)]\\n        for i in range(len(nums)):\\n            while rest2>0 and nums[i]%2==0:\\n                nums[i] = nums[i] // 2\\n                rest2 -= 1\\n            while rest5>0 and nums[i]%5==0:\\n                nums[i] = nums[i] // 5\\n                rest5 -= 1      \\n        rear,realnum, = 1,1\\n        front = 1.0\\n\\t\\t\\n        for num in nums:\\n            front *= num\\n            while front > 100000:  \\n                front = front * 0.1 \\n            rear = rear * num\\n            rear = rear % 100000\\n            if realnum>0:  realnum = realnum * num\\n            if realnum>10**10:  realnum = -1\\n        front = int(front)\\n        \\n        if realnum>0:\\n            ans = str(realnum) + \"e\" + str(tens)\\n        else:\\n            rears = str(rear)\\n            if len(rears)<5:\\n                rears = \"0\"*(5-len(rears)) + rears\\n            ans = str(front)+\"...\"+rears+\"e\"+str(tens)   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646615,
                "title": "python3-quasi-brute-force",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/8bba95f803d58a5e571fa13de6635c96f5d1c1ee) for solutions of biweekly 68. \\n\\n```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        ans = prefix = suffix = 1\\n        trailing = 0 \\n        flag = False \\n        for x in range(left, right+1): \\n            if not flag: \\n                ans *= x\\n                while ans % 10 == 0: ans //= 10 \\n                if ans >= 1e10: flag = True \\n            prefix *= x\\n            suffix *= x\\n            while prefix >= 1e12: prefix //= 10 \\n            while suffix % 10 == 0: \\n                trailing += 1\\n                suffix //= 10 \\n            if suffix >= 1e10: suffix %= 10_000_000_000\\n        while prefix >= 100000: prefix //= 10 \\n        suffix %= 100000\\n        if flag: return f\"{prefix}...{suffix:>05}e{trailing}\"\\n        return f\"{ans}e{trailing}\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        ans = prefix = suffix = 1\\n        trailing = 0 \\n        flag = False \\n        for x in range(left, right+1): \\n            if not flag: \\n                ans *= x\\n                while ans % 10 == 0: ans //= 10 \\n                if ans >= 1e10: flag = True \\n            prefix *= x\\n            suffix *= x\\n            while prefix >= 1e12: prefix //= 10 \\n            while suffix % 10 == 0: \\n                trailing += 1\\n                suffix //= 10 \\n            if suffix >= 1e10: suffix %= 10_000_000_000\\n        while prefix >= 100000: prefix //= 10 \\n        suffix %= 100000\\n        if flag: return f\"{prefix}...{suffix:>05}e{trailing}\"\\n        return f\"{ans}e{trailing}\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646596,
                "title": "python-use-log-value-explained",
                "content": "First we notice that the trailing zeroes should be abbreviated, so we can calculate the number of trailing zeroes by calculating how many `2` and `5` in the result of prime factorization of the product, and the number of trailing zeroes is the minimum between the two values.\\n\\nNext we notice that we only need to calculate the first and the last 5 digits of the result. We can handle it separately.\\n* How to calculate the last 5 digits?\\nWell, it is easier than calculating first 5 digits. We only need to keep the remainder of the running product divided by `100000`.\\n* How to calculate the first 5 digits?\\nWe can calculate the cumulative sum of log value of the product, then convert it back to real numbers.\\nFor example, `log(123456789) ~= 8.09151497717` and `pow(10, 4.09151497717) ~= 12345.6789`. We can find that if we only need to calculate the first 5 digits, the log value larger than 4 (i.e. `4.xx`) would be enough.\\n\\nThere is a small trick that we need to add a small epsilon (like `1e-11`) to handle the float precision.\\n\\n```python \\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        \\n        twos, fives = 0, 0\\n        tail, cum_log = 1, 0.0\\n        for i in range(left, right + 1):\\n            # eliminate all the 2\\'s and 5\\'s\\n            while i % 2 == 0:\\n                i //= 2\\n                twos += 1\\n            while i % 5 == 0:\\n                i //= 5\\n                fives += 1\\n            # keep last 5 digits with division by 100000\\n            tail = (tail * i) % 100000\\n            # calculate cumulative log\\n            cum_log += log(i, 10)\\n        # the number of trailing zeros\\n        zeros = min(twos, fives)\\n        \\n        # add the extra 2\\'s or 5\\'s into tail and cum_log\\n        tail = (tail * pow(2, twos - zeros, 100000) * pow(5, fives - zeros, 100000)) % 100000\\n        cum_log += log(2, 10) * (twos - zeros) + log(5, 10) * (fives - zeros)\\n        \\n        if cum_log >= 10:\\n            # extract first 5 digits from cumulative log\\n            head = str(pow(10, cum_log - floor(cum_log) + 1e-11 + 4))[:5]\\n            tail = str(tail).zfill(5)\\n            return f\\'{head}...{tail}e{zeros}\\'\\n        else:\\n            # use the cumulative log to calcualte the whole digits\\n            whole = str(floor(pow(10, cum_log + 1e-11)))\\n            return f\\'{whole}e{zeros}\\'\\n```",
                "solutionTags": [],
                "code": "```python \\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        \\n        twos, fives = 0, 0\\n        tail, cum_log = 1, 0.0\\n        for i in range(left, right + 1):\\n            # eliminate all the 2\\'s and 5\\'s\\n            while i % 2 == 0:\\n                i //= 2\\n                twos += 1\\n            while i % 5 == 0:\\n                i //= 5\\n                fives += 1\\n            # keep last 5 digits with division by 100000\\n            tail = (tail * i) % 100000\\n            # calculate cumulative log\\n            cum_log += log(i, 10)\\n        # the number of trailing zeros\\n        zeros = min(twos, fives)\\n        \\n        # add the extra 2\\'s or 5\\'s into tail and cum_log\\n        tail = (tail * pow(2, twos - zeros, 100000) * pow(5, fives - zeros, 100000)) % 100000\\n        cum_log += log(2, 10) * (twos - zeros) + log(5, 10) * (fives - zeros)\\n        \\n        if cum_log >= 10:\\n            # extract first 5 digits from cumulative log\\n            head = str(pow(10, cum_log - floor(cum_log) + 1e-11 + 4))[:5]\\n            tail = str(tail).zfill(5)\\n            return f\\'{head}...{tail}e{zeros}\\'\\n        else:\\n            # use the cumulative log to calcualte the whole digits\\n            whole = str(floor(pow(10, cum_log + 1e-11)))\\n            return f\\'{whole}e{zeros}\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647125,
                "title": "c-solution-using-logarithm-property",
                "content": "**Approach**\\n1. remove all 2\\'s and 5\\'s while multiplying numbers and count how many times 2\\'s and 5\\'s appear\\n2. number of zeros will be equal to ```min(two,five)```\\n3. get original number back by multiplying extra occurence of two or five\\n4. we maintain two numbers ```original``` and ```suffix``` by taking modulus with different numbers. If our final product has 10 or less digits then ```original``` value is equal to the ```suffix``` value otherwise we take last five digits of ```suffix```.\\n5. to get first 5 digits we take ```log``` of all values from ```left``` to ```right``` and add them all. Coz we need only first five digits of number we take ```10^(4+fraction part)```\\n\\n**Time Complexity :** **O(n),** **where n=(right-left)**\\n\\n```\\nclass Solution\\n{\\n    public:\\n    void reduceNumber(unsigned long long& val,unsigned long long x,unsigned long long& count)\\n    {\\n        while (val%x==0)\\n        {\\n            val/=x;\\n            count++;\\n        }\\n    }\\n    void getBackOriginal(unsigned long long& val,unsigned long long two,unsigned long long five,unsigned long long& mod)\\n    {\\n        if (two<five)\\n        {\\n            five-=two;\\n            while (five--)\\n                val=(val*5)%mod;\\n        }\\n        else if (five<two)\\n        {\\n            two-=five;\\n            while (two--)\\n                val=(val*2)%mod;\\n        }\\n    }\\n    string abbreviateProduct(int left, int right)\\n    {\\n        unsigned long long original=1,suffix=1,two=0,five=0,mod1=1e10,mod2=1e13;\\n        double power=0;\\n        for (long long i=left;i<=right;i++)\\n        {\\n            unsigned long long val=i;\\n            power=power+(double)(log10(i));\\n            \\n            //Reduce number by removing multiple of 2 and 5 from them and count them\\n            reduceNumber(val,2,two);\\n            reduceNumber(val,5,five);\\n            \\n            //Maintain two number suffix and original by taking modulus with different numbers\\n            suffix=(suffix*val)%mod1;\\n            original=(original*val)%mod2;\\n        }\\n        \\n        //Get original number back by multiplying extra two or five\\n        getBackOriginal(suffix,two,five,mod1);\\n        getBackOriginal(original,two,five,mod2);\\n        \\n        string ans=\"\";\\n        //If suffix is equal to original it means final product has 10 or maybe less digits\\n        if (original==suffix)\\n            ans=to_string(original)+\\'e\\'+to_string(min(two,five));\\n        else\\n        {\\n            power=power-(int)(power)+4.0;\\n            long long prefix=pow(10,power);\\n            string temp=to_string(suffix);\\n            for (int i=temp.length()-1;i>temp.length()-6;i--)\\n                ans=temp[i]+ans;\\n            ans=to_string(prefix)+\"...\"+ans+\\'e\\'+to_string(min(two,five));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```min(two,five)```\n```original```\n```suffix```\n```original```\n```suffix```\n```suffix```\n```log```\n```left```\n```right```\n```10^(4+fraction part)```\n```\\nclass Solution\\n{\\n    public:\\n    void reduceNumber(unsigned long long& val,unsigned long long x,unsigned long long& count)\\n    {\\n        while (val%x==0)\\n        {\\n            val/=x;\\n            count++;\\n        }\\n    }\\n    void getBackOriginal(unsigned long long& val,unsigned long long two,unsigned long long five,unsigned long long& mod)\\n    {\\n        if (two<five)\\n        {\\n            five-=two;\\n            while (five--)\\n                val=(val*5)%mod;\\n        }\\n        else if (five<two)\\n        {\\n            two-=five;\\n            while (two--)\\n                val=(val*2)%mod;\\n        }\\n    }\\n    string abbreviateProduct(int left, int right)\\n    {\\n        unsigned long long original=1,suffix=1,two=0,five=0,mod1=1e10,mod2=1e13;\\n        double power=0;\\n        for (long long i=left;i<=right;i++)\\n        {\\n            unsigned long long val=i;\\n            power=power+(double)(log10(i));\\n            \\n            //Reduce number by removing multiple of 2 and 5 from them and count them\\n            reduceNumber(val,2,two);\\n            reduceNumber(val,5,five);\\n            \\n            //Maintain two number suffix and original by taking modulus with different numbers\\n            suffix=(suffix*val)%mod1;\\n            original=(original*val)%mod2;\\n        }\\n        \\n        //Get original number back by multiplying extra two or five\\n        getBackOriginal(suffix,two,five,mod1);\\n        getBackOriginal(original,two,five,mod2);\\n        \\n        string ans=\"\";\\n        //If suffix is equal to original it means final product has 10 or maybe less digits\\n        if (original==suffix)\\n            ans=to_string(original)+\\'e\\'+to_string(min(two,five));\\n        else\\n        {\\n            power=power-(int)(power)+4.0;\\n            long long prefix=pow(10,power);\\n            string temp=to_string(suffix);\\n            for (int i=temp.length()-1;i>temp.length()-6;i--)\\n                ans=temp[i]+ans;\\n            ans=to_string(prefix)+\"...\"+ans+\\'e\\'+to_string(min(two,five));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646713,
                "title": "java-keep-track-of-the-product-start-and-end",
                "content": "We can separately compute the start and end part of the number (as well as the number of trailing zeros).\\nExample (with smaller numbers):\\n```\\n    999[999]999 * 99 // start = 999, end = 999\\n =  989[99999]901 // start = 989, end = 901 => same as computing separately with 999 * 99 = 98901\\n```\\n\\nUsing `long` provides enough precision to pass the tests (though I don\\'t have a formal proof yet).\\nGiven that input numbers are smaller than 10^6 and the max value of a long is (roughly) 9 * 10^18, we need to keep start and end smaller than 9 * 10^12.\\n\\nEdit: we actually need to use `double` for start, to have enough precision to pass new tests. Thanks @DIMITR for the comment!\\n\\n```\\npublic static final long LIMIT = 1_000_000_000_000l; // keep start/end smaller than 10^12\\n    \\npublic String abbreviateProduct(int left, int right) {\\n    long end = 1; // end part of the product (or the whole number if small enough)\\n    long nZeros = 0; // trailing zeros\\n    boolean usedModulo = false;\\n    for (int n = left; n <= right; n++) {\\n        end *= n;\\n\\n        while (end % 10 == 0) { // extract trailing zeros into nZeros\\n            end /= 10;\\n            nZeros++;\\n        }\\n\\n        if (end >= LIMIT) { // truncate if needed\\n            end %= LIMIT;\\n            usedModulo = true;\\n        }\\n    }\\n\\n    if (!usedModulo && end < 10_000_000_000l) { // doesn\\'t need abbreviation below 10^10\\n        return String.format(\"%de%d\", end, nZeros);\\n    }\\n\\n    double start = 1; // start part of the product\\n    for (int n = left; n <= right; n++) {\\n        start *= n;\\n\\n        while (start >= LIMIT) { // truncate if needed\\n            start /= 10;\\n        }\\n    }\\n\\n    return buildAbbreviation(usedModulo, start, end, nZeros);\\n}\\n\\nprivate String buildAbbreviation(boolean usedModulo, double start, long end, long nZeros) {\\n    while (start >= 100_000) { // keep the 5 first digits\\n        start /= 10;\\n    }\\n\\n    end %= 100_000; // keep the last 5 digits\\n\\n    return String.format(\"%d...%05de%d\", (int) start, end, nZeros); // zero-padding of the end\\n}\\n```\\n\\nQuestions and comments welcome!",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n    999[999]999 * 99 // start = 999, end = 999\\n =  989[99999]901 // start = 989, end = 901 => same as computing separately with 999 * 99 = 98901\\n```\n```\\npublic static final long LIMIT = 1_000_000_000_000l; // keep start/end smaller than 10^12\\n    \\npublic String abbreviateProduct(int left, int right) {\\n    long end = 1; // end part of the product (or the whole number if small enough)\\n    long nZeros = 0; // trailing zeros\\n    boolean usedModulo = false;\\n    for (int n = left; n <= right; n++) {\\n        end *= n;\\n\\n        while (end % 10 == 0) { // extract trailing zeros into nZeros\\n            end /= 10;\\n            nZeros++;\\n        }\\n\\n        if (end >= LIMIT) { // truncate if needed\\n            end %= LIMIT;\\n            usedModulo = true;\\n        }\\n    }\\n\\n    if (!usedModulo && end < 10_000_000_000l) { // doesn\\'t need abbreviation below 10^10\\n        return String.format(\"%de%d\", end, nZeros);\\n    }\\n\\n    double start = 1; // start part of the product\\n    for (int n = left; n <= right; n++) {\\n        start *= n;\\n\\n        while (start >= LIMIT) { // truncate if needed\\n            start /= 10;\\n        }\\n    }\\n\\n    return buildAbbreviation(usedModulo, start, end, nZeros);\\n}\\n\\nprivate String buildAbbreviation(boolean usedModulo, double start, long end, long nZeros) {\\n    while (start >= 100_000) { // keep the 5 first digits\\n        start /= 10;\\n    }\\n\\n    end %= 100_000; // keep the last 5 digits\\n\\n    return String.format(\"%d...%05de%d\", (int) start, end, nZeros); // zero-padding of the end\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646890,
                "title": "c-2117-abbreviating-the-product-of-a-range",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string abbreviateProduct(int left, int right) {\\n        int highest = 0, trailing = 0; \\n        long prefix = 1, suffix = 1; \\n        \\n        for (int x = left; x <= right; ++x) {\\n            prefix *= x; \\n            suffix *= x; \\n            for (; prefix >= 1e12; ++highest, prefix /= 10); \\n            for (; suffix % 10 == 0; ++trailing, suffix /= 10); \\n            if (suffix >= 1e10) suffix %= 10\\'000\\'000\\'000; \\n        }\\n        \\n        for (; prefix >= 1e5; ++highest, prefix /= 10); \\n        highest += log10(prefix); \\n        if (highest - trailing < 10) return to_string(suffix) + \"e\" + to_string(trailing); \\n        suffix %= 100\\'000; \\n        return to_string(prefix) + \"...\" + string(5-to_string(suffix).size(), \\'0\\') + to_string(suffix) + \"e\" + to_string(trailing); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string abbreviateProduct(int left, int right) {\\n        int highest = 0, trailing = 0; \\n        long prefix = 1, suffix = 1; \\n        \\n        for (int x = left; x <= right; ++x) {\\n            prefix *= x; \\n            suffix *= x; \\n            for (; prefix >= 1e12; ++highest, prefix /= 10); \\n            for (; suffix % 10 == 0; ++trailing, suffix /= 10); \\n            if (suffix >= 1e10) suffix %= 10\\'000\\'000\\'000; \\n        }\\n        \\n        for (; prefix >= 1e5; ++highest, prefix /= 10); \\n        highest += log10(prefix); \\n        if (highest - trailing < 10) return to_string(suffix) + \"e\" + to_string(trailing); \\n        suffix %= 100\\'000; \\n        return to_string(prefix) + \"...\" + string(5-to_string(suffix).size(), \\'0\\') + to_string(suffix) + \"e\" + to_string(trailing); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646806,
                "title": "c-pure-math-no-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    string abbreviateProduct(int left, int right) {\\n        int num_2 = 0, num_5 = 0;\\n        vector<int> arr;\\n        for(int i=left; i<=right; i++) {\\n            int num = i;\\n            while(!(num % 2)) {\\n                num_2 += 1;\\n                num /= 2;\\n            }\\n            while(!(num % 5)) {\\n                num_5 += 1;\\n                num /= 5;\\n            }\\n            arr.push_back(num);\\n        }\\n        int C = min(num_2, num_5);\\n        long M = 1e5;\\n        long suf = 1;\\n        for(auto& num : arr) {\\n            suf *= long(num);\\n            suf %= M;\\n        }\\n        for(int i=C+1; i<=num_2; i++) {\\n            suf *= 2;\\n            suf %= M;\\n        }\\n        for(int i=C+1; i<=num_5; i++) {\\n            suf *= 5;\\n            suf %= M;\\n        }\\n        double log = 0.0;\\n        for(int i=left; i<=right; i++) log += log10(double(i));\\n        log -= double(C);\\n        if(log < 10.0) {\\n            suf = 1;\\n            for(auto& num : arr) suf *= long(num);\\n            for(int i=C+1; i<=num_2; i++) suf *= 2;\\n            for(int i=C+1; i<=num_5; i++) suf *= 5;\\n            return to_string(suf) + \"e\" + to_string(C);\\n        }\\n        log -= floor(log);\\n        log += 4.0;\\n        int prev = int(pow(10.0, log));\\n        char p[30];\\n        snprintf(p, 30, \"%5d...%05de%d\", prev, suf, C);\\n        return string(p);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string abbreviateProduct(int left, int right) {\\n        int num_2 = 0, num_5 = 0;\\n        vector<int> arr;\\n        for(int i=left; i<=right; i++) {\\n            int num = i;\\n            while(!(num % 2)) {\\n                num_2 += 1;\\n                num /= 2;\\n            }\\n            while(!(num % 5)) {\\n                num_5 += 1;\\n                num /= 5;\\n            }\\n            arr.push_back(num);\\n        }\\n        int C = min(num_2, num_5);\\n        long M = 1e5;\\n        long suf = 1;\\n        for(auto& num : arr) {\\n            suf *= long(num);\\n            suf %= M;\\n        }\\n        for(int i=C+1; i<=num_2; i++) {\\n            suf *= 2;\\n            suf %= M;\\n        }\\n        for(int i=C+1; i<=num_5; i++) {\\n            suf *= 5;\\n            suf %= M;\\n        }\\n        double log = 0.0;\\n        for(int i=left; i<=right; i++) log += log10(double(i));\\n        log -= double(C);\\n        if(log < 10.0) {\\n            suf = 1;\\n            for(auto& num : arr) suf *= long(num);\\n            for(int i=C+1; i<=num_2; i++) suf *= 2;\\n            for(int i=C+1; i<=num_5; i++) suf *= 5;\\n            return to_string(suf) + \"e\" + to_string(C);\\n        }\\n        log -= floor(log);\\n        log += 4.0;\\n        int prev = int(pow(10.0, log));\\n        char p[30];\\n        snprintf(p, 30, \"%5d...%05de%d\", prev, suf, C);\\n        return string(p);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646606,
                "title": "python-straightforward",
                "content": "Track the head, tail and trailing zero when passing through the range.\\nFor trailing zero, we need to count the number of 2 and 5 within the range.\\nFor the head, as 1 <= left <= right <= 10^6, the top 5 digits can be calculated with the 1st ~ 12th digits, so we track top 12 digits.\\nFor the tail, if we track the last 5 digits, when a new trailing zero pops up, we may get 4 effective digits left. \\nSo I remove all the 2 and 5 in each step and multiply the remaining ones in the end.\\n\\n```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        c2 = c5 = 0\\n        top12 = tail5 = 1\\n\\n        for i in range(left, right+1):\\n            # count and remove all 2 and 5\\n            while i % 2 == 0:\\n                i //= 2\\n                c2 += 1\\n            while i % 5 == 0:\\n                i //= 5\\n                c5 += 1\\n\\n            # track top 12 and last 5\\n            top12 = int(str(top12 * i)[:12])\\n            tail5 = tail5 * i % 100000\\n        \\n        # multiply the remained 2 or 5\\n        if c2 > c5:\\n            for _ in range(c2 - c5):\\n                top12 = int(str(top12 * 2)[:12])\\n                tail5 = tail5 * 2 % 100000\\n        elif c2 < c5:\\n            for _ in range(c5 - c2):\\n                top12 = int(str(top12 * 5)[:12])\\n                tail5 = tail5 * 5 % 100000\\n\\n        zero = min(c2, c5)\\n\\n        # as is included in top 12, it\\'s easy to tell when d<=10\\n        if len(str(top12))<=10:\\n            return str(top12)+\\'e\\'+str(zero)\\n        \\n        return str(top12)[:5] + \\'.\\'*3 + \\'0\\'*(5-len(str(tail5)))+str(tail5)+\\'e\\'+str(zero)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        c2 = c5 = 0\\n        top12 = tail5 = 1\\n\\n        for i in range(left, right+1):\\n            # count and remove all 2 and 5\\n            while i % 2 == 0:\\n                i //= 2\\n                c2 += 1\\n            while i % 5 == 0:\\n                i //= 5\\n                c5 += 1\\n\\n            # track top 12 and last 5\\n            top12 = int(str(top12 * i)[:12])\\n            tail5 = tail5 * i % 100000\\n        \\n        # multiply the remained 2 or 5\\n        if c2 > c5:\\n            for _ in range(c2 - c5):\\n                top12 = int(str(top12 * 2)[:12])\\n                tail5 = tail5 * 2 % 100000\\n        elif c2 < c5:\\n            for _ in range(c5 - c2):\\n                top12 = int(str(top12 * 5)[:12])\\n                tail5 = tail5 * 5 % 100000\\n\\n        zero = min(c2, c5)\\n\\n        # as is included in top 12, it\\'s easy to tell when d<=10\\n        if len(str(top12))<=10:\\n            return str(top12)+\\'e\\'+str(zero)\\n        \\n        return str(top12)[:5] + \\'.\\'*3 + \\'0\\'*(5-len(str(tail5)))+str(tail5)+\\'e\\'+str(zero)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512713,
                "title": "basic-maths-shortest-c-cleanest-solution-easy-to-understand",
                "content": "The Solution basically consists of 3 things \\n\\n1.  Counting Zeroes \\n2.  Getting Suffix\\n3.  Getting Prefix\\n\\nCounting Zeroes and Suffix can be done easily by extracting only last 10-12 digits of the answer after every multiplication and counting and removing zeroes as soon as we found them.\\n\\nNow is the time tricky part :- How to get the first 5 digits ??\\nHere comes the Logarithmic property : To get the start 5 digits \\n1. Take sum of log(base10)(number) of all the numbers from left to right.\\n2. Once the sum is calculated extract the decimal part by ```Decimal(Sum) -  long(Sum)```.\\n3. Then Add 4 to it since we want first 5 numbers.\\n4. After that lets say you get result Res , Take ```floor(10 power Res)``` and that will be the first 5 digits.\\n\\nCode Snippet for the above tricky Part\\n```\\n   long double SumLog= 0;\\n        for(int i=left;i<=right;i++)\\n        SumLog += log10(i);\\n        string P =to_string(floor(pow(10,4.0+(SumLog-long(SumLog)))));\\n```\\n\\nNote : ``` long double ``` is used to get more precision avoid the round off errors which comes with float/double. \\n\\n```\\nclass Solution {\\npublic:\\n\\n    string abbreviateProduct(int left, int right) {\\n    \\n        string Ans = \"1\",Prefix =\"1\";\\n        int count = 0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            Ans = to_string(i*stol(Ans));\\n            while(Ans.back()==\\'0\\') Ans.pop_back() , count++;\\n            if(Ans.size()>12)\\n            Ans =Ans.substr(Ans.size()-12); \\n        }\\n        \\n        long double SumLog= 0;\\n        for(int i=left;i<=right;i++)\\n        SumLog += log10(i);\\n        string P =to_string(floor(pow(10,4.0+(SumLog-long(SumLog)))));\\n        \\n        if(Ans.size()>10)\\n        Ans = (P.size()>5?P.substr(0,5):P) +\"...\" + Ans.substr(Ans.size()-5);\\n        \\n        return Ans+\"e\"+to_string(count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```Decimal(Sum) -  long(Sum)```\n```floor(10 power Res)```\n```\\n   long double SumLog= 0;\\n        for(int i=left;i<=right;i++)\\n        SumLog += log10(i);\\n        string P =to_string(floor(pow(10,4.0+(SumLog-long(SumLog)))));\\n```\n``` long double ```\n```\\nclass Solution {\\npublic:\\n\\n    string abbreviateProduct(int left, int right) {\\n    \\n        string Ans = \"1\",Prefix =\"1\";\\n        int count = 0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            Ans = to_string(i*stol(Ans));\\n            while(Ans.back()==\\'0\\') Ans.pop_back() , count++;\\n            if(Ans.size()>12)\\n            Ans =Ans.substr(Ans.size()-12); \\n        }\\n        \\n        long double SumLog= 0;\\n        for(int i=left;i<=right;i++)\\n        SumLog += log10(i);\\n        string P =to_string(floor(pow(10,4.0+(SumLog-long(SumLog)))));\\n        \\n        if(Ans.size()>10)\\n        Ans = (P.size()>5?P.substr(0,5):P) +\"...\" + Ans.substr(Ans.size()-5);\\n        \\n        return Ans+\"e\"+to_string(count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417281,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def abbreviateProduct(self, left, right):\\n        string = str(prod(list(range(left,right+1))))\\n        n_string = string.rstrip(\"0\")\\n        zeros = len(string) - len(n_string)\\n\\n        if len(n_string) <= 10:\\n            return n_string + \"e\" + str(zeros)\\n        else:\\n            return n_string[:5] + \"...\" + n_string[-5:] + \"e\" + str(zeros)\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, left, right):\\n        string = str(prod(list(range(left,right+1))))\\n        n_string = string.rstrip(\"0\")\\n        zeros = len(string) - len(n_string)\\n\\n        if len(n_string) <= 10:\\n            return n_string + \"e\" + str(zeros)\\n        else:\\n            return n_string[:5] + \"...\" + n_string[-5:] + \"e\" + str(zeros)\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682244,
                "title": "java-precision-precision-precision",
                "content": "```\\n    public String abbreviateProduct(int left, int right) {\\n        final long threshold0 = 100_000_000_000_000L,threshold1 = 10_000_000_000L,threshold2 = 100_000;\\n        long curr=1;\\n        int i, zerosCount = 0;\\n        for(i=left;i<=right && curr<threshold0;i++){\\n            curr *= i;\\n            while(curr%10==0){\\n                curr/=10;\\n                zerosCount++;\\n            }\\n        }\\n        if(curr<threshold1)\\n            return String.format(\"%de%d\",curr,zerosCount);\\n\\n        long low=curr%threshold1;\\n        double high = curr; //double precision is more accurate than long when we need to divide by 10 by 10 and multiply again\\n        while(high>threshold1)\\n            high/=10;\\n        \\n        for(;i<=right;i++){\\n            low  *=i;\\n            high *=i;\\n            while(low%10==0){\\n                low/=10;\\n                zerosCount++;\\n            }\\n            if(low>=threshold1)\\n                low %= threshold1;\\n            while(high>threshold1)\\n                high/=10;\\n        }\\n\\n        while(high>=threshold2)\\n            high/=10;\\n        low %= threshold2;\\n        return String.format(\"%d...%05de%d\",(int)high,low,zerosCount);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String abbreviateProduct(int left, int right) {\\n        final long threshold0 = 100_000_000_000_000L,threshold1 = 10_000_000_000L,threshold2 = 100_000;\\n        long curr=1;\\n        int i, zerosCount = 0;\\n        for(i=left;i<=right && curr<threshold0;i++){\\n            curr *= i;\\n            while(curr%10==0){\\n                curr/=10;\\n                zerosCount++;\\n            }\\n        }\\n        if(curr<threshold1)\\n            return String.format(\"%de%d\",curr,zerosCount);\\n\\n        long low=curr%threshold1;\\n        double high = curr; //double precision is more accurate than long when we need to divide by 10 by 10 and multiply again\\n        while(high>threshold1)\\n            high/=10;\\n        \\n        for(;i<=right;i++){\\n            low  *=i;\\n            high *=i;\\n            while(low%10==0){\\n                low/=10;\\n                zerosCount++;\\n            }\\n            if(low>=threshold1)\\n                low %= threshold1;\\n            while(high>threshold1)\\n                high/=10;\\n        }\\n\\n        while(high>=threshold2)\\n            high/=10;\\n        low %= threshold2;\\n        return String.format(\"%d...%05de%d\",(int)high,low,zerosCount);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1657142,
                "title": "straight-forward-brute-force",
                "content": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        num = 1\\n        while left<=right:\\n            num *= left\\n            left+= 1\\n        a = str(num)\\n        b = a.rstrip(\"0\")\\n        e = len(a)-len(b)\\n        if len(b) > 10:\\n            b = b[:5]+\"...\"+b[-5:]\\n        return b+\"e\"+str(e)\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        num = 1\\n        while left<=right:\\n            num *= left\\n            left+= 1\\n        a = str(num)\\n        b = a.rstrip(\"0\")\\n        e = len(a)-len(b)\\n        if len(b) > 10:\\n            b = b[:5]+\"...\"+b[-5:]\\n        return b+\"e\"+str(e)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651716,
                "title": "java-solution-brute-force",
                "content": "```\\nclass Solution {\\n    public String abbreviateProduct(int left, int right) {\\n        double a = 1L; // for first 5 digits\\n        long b = 1L; // for last 5 digits\\n        long c = 1L; // for small result\\n        int zn = 0; // zero count\\n        for(int i=left; i<=right; i++){\\n            a*=i;\\n            b*=i;\\n            while(b%10==0){\\n                b/=10;\\n                zn++;\\n            }\\n            if(a>1000000000000L) a/=1000000;\\n            if(b>1000000000000L) b%=1000000;\\n            if(c<10000000000L) c*=i;\\n            while(c%10==0) c/=10;\\n        }\\n        if(c<10000000000L) return c+\"e\"+zn;\\n        String astr = String.valueOf(a).replace(\".\", \"\");\\n        String bstr = String.valueOf(b);\\n        while(bstr.length()<5) bstr=\"0\"+bstr;\\n        return astr.substring(0,5)+\"...\"+bstr.substring(bstr.length()-5)+\"e\"+zn;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String abbreviateProduct(int left, int right) {\\n        double a = 1L; // for first 5 digits\\n        long b = 1L; // for last 5 digits\\n        long c = 1L; // for small result\\n        int zn = 0; // zero count\\n        for(int i=left; i<=right; i++){\\n            a*=i;\\n            b*=i;\\n            while(b%10==0){\\n                b/=10;\\n                zn++;\\n            }\\n            if(a>1000000000000L) a/=1000000;\\n            if(b>1000000000000L) b%=1000000;\\n            if(c<10000000000L) c*=i;\\n            while(c%10==0) c/=10;\\n        }\\n        if(c<10000000000L) return c+\"e\"+zn;\\n        String astr = String.valueOf(a).replace(\".\", \"\");\\n        String bstr = String.valueOf(b);\\n        while(bstr.length()<5) bstr=\"0\"+bstr;\\n        return astr.substring(0,5)+\"...\"+bstr.substring(bstr.length()-5)+\"e\"+zn;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646731,
                "title": "python-almost-brute-force",
                "content": "There are 2 steps:\\nStep1: Calculate the number of trailing zeros\\nStep2: Multiply & Keep track of the first 12 numbers and the last 5 numbers\\n\\nFor step1, we need to know the number of factors 2 and 5 in [right, left], because 10 = 2 * 5. The minimum of the two will be the number of trailing zeros.\\n\\nFor step2, If the final number is less than 10 ** 10, I just output the number without abbreviation, but if the number exceeds 10 ** 10, then I switch to the calculation of the \"big\" number which needs abbreviation. For each, step, I only keep track of the first and last few numbers because they don\\'t change by multiplication. \\n\\n```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        #Step1: count the num of trailing zeros\\n        factor_two, factor_five = 0, 0\\n        curr_factor = 2\\n        while curr_factor <= right:\\n            factor_two += (right // curr_factor) - ((left - 1) // curr_factor)\\n            curr_factor *= 2\\n        curr_factor = 5\\n        while curr_factor <= right:\\n            factor_five += (right // curr_factor) - ((left - 1) // curr_factor)\\n            curr_factor *= 5\\n        trailing_zeros = min(factor_two, factor_five)\\n        \\n        #Step2: Multiply until it gets too big, while dividing 2 and 5\\n\\t\\tdivide_two_so_far, divide_five_so_far = 0, 0\\n        curr_num = 1\\n        for i in range(left, right + 1):\\n            multiply = i\\n            while multiply % 2 == 0 and divide_two_so_far < trailing_zeros:\\n                multiply //= 2\\n                divide_two_so_far += 1\\n            while multiply % 5 == 0 and divide_five_so_far < trailing_zeros:\\n                multiply //= 5\\n                divide_five_so_far += 1\\n            curr_num *= multiply\\n            if curr_num >= 10 ** 10:\\n                break\\n        \\n        #if the number doesn\\'t get too large (less than or equal to 10 digits)\\n        if curr_num < 10 ** 10:\\n            return str(curr_num) + \\'e\\' + str(trailing_zeros)\\n        \\n        #Step2: if the number exceeds 10 ** 10, then keep track of the first and last digits\\n        first_digits, last_digits = int(str(curr_num)[:12]), int(str(curr_num)[-5:])\\n        start = i + 1\\n        for i in range(start, right + 1):\\n            multiply = i\\n            while multiply % 2 == 0 and divide_two_so_far < trailing_zeros:\\n                multiply //= 2\\n                divide_two_so_far += 1\\n            while multiply % 5 == 0 and divide_five_so_far < trailing_zeros:\\n                multiply //= 5\\n                divide_five_so_far += 1\\n            first_digits = int(str(first_digits * multiply)[:12])\\n            last_digits = int(str(last_digits * multiply)[-5:])\\n        \\n\\t\\t#output\\n        return str(first_digits)[:5] + \\'...\\' + \\'{:>05d}\\'.format(last_digits) + \\'e\\' + str(trailing_zeros)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        #Step1: count the num of trailing zeros\\n        factor_two, factor_five = 0, 0\\n        curr_factor = 2\\n        while curr_factor <= right:\\n            factor_two += (right // curr_factor) - ((left - 1) // curr_factor)\\n            curr_factor *= 2\\n        curr_factor = 5\\n        while curr_factor <= right:\\n            factor_five += (right // curr_factor) - ((left - 1) // curr_factor)\\n            curr_factor *= 5\\n        trailing_zeros = min(factor_two, factor_five)\\n        \\n        #Step2: Multiply until it gets too big, while dividing 2 and 5\\n\\t\\tdivide_two_so_far, divide_five_so_far = 0, 0\\n        curr_num = 1\\n        for i in range(left, right + 1):\\n            multiply = i\\n            while multiply % 2 == 0 and divide_two_so_far < trailing_zeros:\\n                multiply //= 2\\n                divide_two_so_far += 1\\n            while multiply % 5 == 0 and divide_five_so_far < trailing_zeros:\\n                multiply //= 5\\n                divide_five_so_far += 1\\n            curr_num *= multiply\\n            if curr_num >= 10 ** 10:\\n                break\\n        \\n        #if the number doesn\\'t get too large (less than or equal to 10 digits)\\n        if curr_num < 10 ** 10:\\n            return str(curr_num) + \\'e\\' + str(trailing_zeros)\\n        \\n        #Step2: if the number exceeds 10 ** 10, then keep track of the first and last digits\\n        first_digits, last_digits = int(str(curr_num)[:12]), int(str(curr_num)[-5:])\\n        start = i + 1\\n        for i in range(start, right + 1):\\n            multiply = i\\n            while multiply % 2 == 0 and divide_two_so_far < trailing_zeros:\\n                multiply //= 2\\n                divide_two_so_far += 1\\n            while multiply % 5 == 0 and divide_five_so_far < trailing_zeros:\\n                multiply //= 5\\n                divide_five_so_far += 1\\n            first_digits = int(str(first_digits * multiply)[:12])\\n            last_digits = int(str(last_digits * multiply)[-5:])\\n        \\n\\t\\t#output\\n        return str(first_digits)[:5] + \\'...\\' + \\'{:>05d}\\'.format(last_digits) + \\'e\\' + str(trailing_zeros)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646704,
                "title": "python-short-contest-oriented-solution",
                "content": "Multiply all the numbers within the range but only keep track of the # of trailing zeros and the last 10 digits before that. Set the flag if the product ever grows above what `mod` can express. If it does, use the sum of `math.log10()` to calculate the leading 5 digits.\\n\\nI can probably use the sum of `math.log10()` to estimate whether I need the last 10 digits or just the last 5, but it wouldn\\'t be much faster.\\n```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        mod = 1\\n        zeros = 0\\n        div = False\\n        for x in range(left, right + 1):\\n            mod *= x\\n            while not mod % 10:\\n                mod //= 10\\n                zeros += 1\\n            d, mod = divmod(mod, 10000000000)\\n            if d:\\n                div = True\\n        if not div:\\n            return f\\'{str(mod)}e{zeros}\\'\\n        else:\\n            log_sum = sum(math.log10(i) for i in range(left, right + 1))\\n            s = str(10 ** (log_sum % 1))\\n            leading = s[0] + s[2:6]\\n            return f\\'{leading}...{str(mod % 10 ** 5).zfill(5)}e{zeros}\\'\\n```\\n**A note on floating point precision**\\nWe only need to get the first 5 leading digits right so we never come close to the limit of floating point precision, but it\\'s interesting to note how many leading digits we can get right and by what implementation. The largest exact product `functools.reduce(operator.mul, range(1, 10 ** 6 + 1))` is\\n```\\n826393168833124006237...\\n```\\nThe simplest implementation `10 ** (sum(math.log10(i) for i in range(1, 10 ** 6 + 1)) % 1)` gives\\n```\\n8.263930516641858\\n```\\n, correct up to 6 digits. `math.fsum()` is more precise than `sum()`: `10 ** (math.fsum(math.log10(i) for i in range(1, 10 ** 6 + 1)) % 1)` gives\\n```\\n8.263931686266318\\n```\\n, correct up to 9 digits. However, it\\'s more important not to sum up a large number if we only want the mantissa. `10 ** functools.reduce(lambda a, b: (a + b) % 1, (math.log10(i) for i in range(1, 10 ** 6 + 1)))` gives\\n```\\n8.26393168831949\\n```\\nwhich is correct up to 11 digits.\\n\\n**Addendum**\\nApparently [the standard solution failed for `left=184, right=70145`](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/5657) and the most precise implementation above somehow [gives different answers on my computer vs. on LC](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/5657#issuecomment-1001244092). The correct leading digits for `left=184, right=70145` are\\n```\\n391180000000002366...\\n```\\n`10 ** functools.reduce(lambda a, b: (a + b) % 1,...)` on my computer gives\\n```\\n3.9118000000001816\\n```\\n`10 ** (math.fsum(...) % 1)` gives\\n```\\n3.9117999998468442\\n```\\nbut `10 ** (sum(...) % 1)` gives\\n```\\n3.911800002992591\\n```\\nSo the ordering of the implementations in terms of precision doesn\\'t change, but ironically in this case more precise implementation may fail to give the correct answer\\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F\\n\\n**Addendum 2**\\nUsing `np.longdouble` and vectorized `np.log10()` yields the most precise estimate so far, but it still takes some luck to err on the \"right side\" for the case `left=184, right=70145`:\\n\\n```\\nimport numpy as np\\n\\nlog_sum = functools.reduce(lambda a, b: (a + b) % 1, np.log10(np.arange(left, right + 1, dtype=np.longdouble)))\\nestimate = 10 ** (log_sum + 4)\\nprint(estimate)\\n```\\nThe stdout:\\n```\\n39118.00000000122791\\n```\\nSolution doing this is slower and takes more memory but still fast enough to get AC.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        mod = 1\\n        zeros = 0\\n        div = False\\n        for x in range(left, right + 1):\\n            mod *= x\\n            while not mod % 10:\\n                mod //= 10\\n                zeros += 1\\n            d, mod = divmod(mod, 10000000000)\\n            if d:\\n                div = True\\n        if not div:\\n            return f\\'{str(mod)}e{zeros}\\'\\n        else:\\n            log_sum = sum(math.log10(i) for i in range(left, right + 1))\\n            s = str(10 ** (log_sum % 1))\\n            leading = s[0] + s[2:6]\\n            return f\\'{leading}...{str(mod % 10 ** 5).zfill(5)}e{zeros}\\'\\n```\n```\\n826393168833124006237...\\n```\n```\\n8.263930516641858\\n```\n```\\n8.263931686266318\\n```\n```\\n8.26393168831949\\n```\n```\\n391180000000002366...\\n```\n```\\n3.9118000000001816\\n```\n```\\n3.9117999998468442\\n```\n```\\n3.911800002992591\\n```\n```\\nimport numpy as np\\n\\nlog_sum = functools.reduce(lambda a, b: (a + b) % 1, np.log10(np.arange(left, right + 1, dtype=np.longdouble)))\\nestimate = 10 ** (log_sum + 4)\\nprint(estimate)\\n```\n```\\n39118.00000000122791\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992831,
                "title": "simple-5-line-python-solution-beats-100-5-line-solution-beats-100",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Simple and step by step approach as mentiones in problem description \\nstep 1: calculate the product of the given range (left, right)\\nrange(left, right+1) will give us a range object or the range which is converted into list by list() function and then to calculate the product of whole list we use prod() function \\nso till here the 1st line is explained \\n**prod(list(range(left, right+1)))** and converting the result into string with the help of str() function as we have to print our solution in string format and for later opertions\\n\\nstep 2: removing the trailing zeros form the end of the calculated product with the help of rstrip() method which removes the white space in case of no string is given to it (i.e. \"hii   \".rstrip() will become \"hii\" if we give it any string/parameter it will remove all occurence till any other charater apper for example- \"hii00000000000000\".rstrip(\"0\") will become \"hii\")\\n\\nstep 3: count of traling zeros of the string \\nthe experssion goes like this **lenght of string with zeros - length of string without zeros**\\n\\nstep 4: as there is 2 way to output the result if the lenght of string (without zeros) is less then or equal to 10 the we will output it as it is string (without zeros)+\"e\"+ count of zeros\\n\\nstep 5: if the lenght of string after removing zeros is greater then > 10 then we have to print the it in 2 parts the starting 5 digits and the last 5 digits \\nexample 123456789987654 consider this as our non zero string \\nso we have to print the starting 5 digits which is 12345 and the last 5 digits if it which is 87654 in the given format \\nstarting 5 digits + \"...\" + last 5 digits + \"e\" + count of zeros\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1) \\n- as we have not used any loops or recursion call so i think the TC will be O(1) **correct me if i\\'m wrong** \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) \\n- as for space complexity, we are not doing any recursion and using only 3 veriables to store our calculation so i think this solution uses constant space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        summ = str(prod(list(range(left, right+1))))\\n        su = summ.rstrip(\"0\")\\n        zeros = len(summ)-len(su)\\n        if len(su)<=10: return (su+\"e\"+str(zeros))\\n        else: return (su[:5]+\"...\"+su[-5:]+\"e\"+str(zeros))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        summ = str(prod(list(range(left, right+1))))\\n        su = summ.rstrip(\"0\")\\n        zeros = len(summ)-len(su)\\n        if len(su)<=10: return (su+\"e\"+str(zeros))\\n        else: return (su[:5]+\"...\"+su[-5:]+\"e\"+str(zeros))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134035,
                "title": "python-soln",
                "content": "```\\nclass Solution:\\n    def abbreviateProduct(self, l: int, r: int) -> str:\\n        \\n        num=1\\n        for i in range(l,r+1):\\n            num=num*i\\n            \\n        c=0\\n        while(num>0 and num%10==0):\\n            c+=1\\n            num=num//10\\n        \\n        s=str(num)\\n        res=s\\n        if len(s)>10:\\n            res=s[:5]+\\'...\\'+s[-5:]\\n        res=res+\\'e\\'+str(c)\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, l: int, r: int) -> str:\\n        \\n        num=1\\n        for i in range(l,r+1):\\n            num=num*i\\n            \\n        c=0\\n        while(num>0 and num%10==0):\\n            c+=1\\n            num=num//10\\n        \\n        s=str(num)\\n        res=s\\n        if len(s)>10:\\n            res=s[:5]+\\'...\\'+s[-5:]\\n        res=res+\\'e\\'+str(c)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050363,
                "title": "c-math-solution",
                "content": "```\\n1. We can always store first 12 digits of and last 12 digits of the multiplication as upper and lower\\n2. We can count the number of digits in final product using Log formula\\n3. We can count number of trailing zero by incrementing counter when lower digit is 0\\n4. We can get first and last 5 digits of upper and lower from their 12 digit\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    string abbreviateProduct(int left, int right) {\\n       \\n        // upper 12 digit of product\\n        double upper = 1;\\n        \\n        // lower 12 digit of product\\n        long long lower = 1L;\\n        \\n        // offset to make 12 digit in upper and lower\\n        long long Offset = 1e12;\\n        \\n        // offset to make 5 digit in upper and lower\\n        long long cutOffset = 1e5;\\n        \\n        // store log value of the product        \\n        double product = 0.0;\\n        \\n        // count trailing zero in the product\\n        int trailing = 0;\\n        \\n        for(int i=left;i<=right;i++)\\n        {\\n            // update log value of product\\n            product +=  log10(i);\\n            \\n            // multiple value with upper and lower 12 digit\\n            upper *= i;\\n            lower *= i;\\n            \\n            // keep 12 digit in upper\\n            while(upper>=Offset)upper/=10;\\n            \\n            // remove trailing zeroes\\n            while(lower%10==0)lower/=10,trailing++;\\n            \\n            // keep 12 digits in lower\\n            lower %= Offset;\\n        }\\n        \\n        // count total digits in product except trailing zeroes\\n        int digitLength = (int)product + 1 - trailing;\\n        \\n        // keep 5 digit in upper and lower\\n        while(upper>=cutOffset)upper/=10;\\n        lower %= cutOffset;\\n        \\n        int upperInt = upper;\\n        \\n        // take digit length digits from upper and lower when digit length <= 10\\n        if(digitLength<=10)\\n        {\\n            // make all digit 0 to tackle missing MSB zeroes in lower\\n            string result(digitLength,\\'0\\');\\n            string upperStr = to_string(upperInt);\\n            string lowerStr = to_string(lower);\\n            \\n            for(int i=0;i<upperStr.length() && digitLength >0; i++,digitLength--)\\n                result[i] = upperStr[i];\\n            \\n            for(int k=1;!lowerStr.empty() && digitLength >0; digitLength--,k++)\\n            {\\n                result[result.length()-k] = lowerStr.back();\\n                lowerStr.pop_back();\\n            }\\n\\n            \\n            return result + \"e\" + to_string(trailing);\\n        } \\n        else\\n        {   \\n           // take upper and lower 5 digits \\n           string result = to_string(lower);\\n           return to_string(upperInt) + \"...\" + string(5-result.size(),\\'0\\') + result  + \"e\" + to_string(trailing);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n1. We can always store first 12 digits of and last 12 digits of the multiplication as upper and lower\\n2. We can count the number of digits in final product using Log formula\\n3. We can count number of trailing zero by incrementing counter when lower digit is 0\\n4. We can get first and last 5 digits of upper and lower from their 12 digit\\n```\n```\\nclass Solution {\\npublic:\\n    string abbreviateProduct(int left, int right) {\\n       \\n        // upper 12 digit of product\\n        double upper = 1;\\n        \\n        // lower 12 digit of product\\n        long long lower = 1L;\\n        \\n        // offset to make 12 digit in upper and lower\\n        long long Offset = 1e12;\\n        \\n        // offset to make 5 digit in upper and lower\\n        long long cutOffset = 1e5;\\n        \\n        // store log value of the product        \\n        double product = 0.0;\\n        \\n        // count trailing zero in the product\\n        int trailing = 0;\\n        \\n        for(int i=left;i<=right;i++)\\n        {\\n            // update log value of product\\n            product +=  log10(i);\\n            \\n            // multiple value with upper and lower 12 digit\\n            upper *= i;\\n            lower *= i;\\n            \\n            // keep 12 digit in upper\\n            while(upper>=Offset)upper/=10;\\n            \\n            // remove trailing zeroes\\n            while(lower%10==0)lower/=10,trailing++;\\n            \\n            // keep 12 digits in lower\\n            lower %= Offset;\\n        }\\n        \\n        // count total digits in product except trailing zeroes\\n        int digitLength = (int)product + 1 - trailing;\\n        \\n        // keep 5 digit in upper and lower\\n        while(upper>=cutOffset)upper/=10;\\n        lower %= cutOffset;\\n        \\n        int upperInt = upper;\\n        \\n        // take digit length digits from upper and lower when digit length <= 10\\n        if(digitLength<=10)\\n        {\\n            // make all digit 0 to tackle missing MSB zeroes in lower\\n            string result(digitLength,\\'0\\');\\n            string upperStr = to_string(upperInt);\\n            string lowerStr = to_string(lower);\\n            \\n            for(int i=0;i<upperStr.length() && digitLength >0; i++,digitLength--)\\n                result[i] = upperStr[i];\\n            \\n            for(int k=1;!lowerStr.empty() && digitLength >0; digitLength--,k++)\\n            {\\n                result[result.length()-k] = lowerStr.back();\\n                lowerStr.pop_back();\\n            }\\n\\n            \\n            return result + \"e\" + to_string(trailing);\\n        } \\n        else\\n        {   \\n           // take upper and lower 5 digits \\n           string result = to_string(lower);\\n           return to_string(upperInt) + \"...\" + string(5-result.size(),\\'0\\') + result  + \"e\" + to_string(trailing);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699906,
                "title": "python-solution-brute-force",
                "content": "**Upvote if you like the solution**\\n```\\n\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        value = 1\\n        count = 0\\n        for i in range(left,right+1):\\n            value*=i                # calculation of product value from left to right\\n        string = str(value)\\n        for j in string[::-1]:\\n            if(j == \\'0\\'):\\n                count+=1            # counting suffix zeros(trailing zeros)\\n            else:\\n                break\\n        length = len(string)        # Total length of product\\n        len_digit = length-count    # Length of product neglecting trailing zeros\\n        if(\\'0\\' in string and len(string[0:len_digit]) <= 10):   # If length without zeros less than 10\\n            return string[0:len_digit]+\\'e\\'+str(count)\\n        elif(\\'0\\' in str(value) and len(string[0:len_digit]) > 10):  # If length without zeros greater than 10\\n            return str(value)[0:5]+\\'...\\'+str(value)[0:len_digit][-5:]+\\'e\\'+str(count)\\n        else:\\n            return str(value)+\\'e0\\'      # If no trailing zeros\\n\\n```\\n\\n**Thank You**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        value = 1\\n        count = 0\\n        for i in range(left,right+1):\\n            value*=i                # calculation of product value from left to right\\n        string = str(value)\\n        for j in string[::-1]:\\n            if(j == \\'0\\'):\\n                count+=1            # counting suffix zeros(trailing zeros)\\n            else:\\n                break\\n        length = len(string)        # Total length of product\\n        len_digit = length-count    # Length of product neglecting trailing zeros\\n        if(\\'0\\' in string and len(string[0:len_digit]) <= 10):   # If length without zeros less than 10\\n            return string[0:len_digit]+\\'e\\'+str(count)\\n        elif(\\'0\\' in str(value) and len(string[0:len_digit]) > 10):  # If length without zeros greater than 10\\n            return str(value)[0:5]+\\'...\\'+str(value)[0:len_digit][-5:]+\\'e\\'+str(count)\\n        else:\\n            return str(value)+\\'e0\\'      # If no trailing zeros\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658064,
                "title": "brute-force-python",
                "content": "\\tclass Solution:\\n\\t\\tdef abbreviateProduct(self, left: int, right: int) -> str:\\n\\t\\t\\tans=1\\n\\t\\t\\tfor i in range(left,right+1):\\n\\t\\t\\t\\tans*=i\\n\\t\\t\\tst=str(ans)\\n\\t\\t\\tcnt=0\\n\\t\\t\\ti=len(st)-1\\n\\t\\t\\twhile st[i]==\"0\":\\n\\t\\t\\t\\tcnt+=1\\n\\t\\t\\t\\ti-=1\\n\\t\\t\\tst=st[:i+1]+\"e\"+str(cnt)\\n\\t\\t\\tif len(st)-cnt>10:\\n\\t\\t\\t\\te_idx=st.index(\"e\")\\n\\t\\t\\t\\ts_idx=e_idx-5\\n\\t\\t\\t\\tans=st[:5]+\"...\"+st[s_idx:e_idx]+st[e_idx:]\\n\\t\\t\\t\\treturn ans\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn st",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef abbreviateProduct(self, left: int, right: int) -> str:\\n\\t\\t\\tans=1\\n\\t\\t\\tfor i in range(left,right+1):\\n\\t\\t\\t\\tans*=i\\n\\t\\t\\tst=str(ans)\\n\\t\\t\\tcnt=0\\n\\t\\t\\ti=len(st)-1\\n\\t\\t\\twhile st[i]==\"0\":\\n\\t\\t\\t\\tcnt+=1\\n\\t\\t\\t\\ti-=1\\n\\t\\t\\tst=st[:i+1]+\"e\"+str(cnt)\\n\\t\\t\\tif len(st)-cnt>10:\\n\\t\\t\\t\\te_idx=st.index(\"e\")\\n\\t\\t\\t\\ts_idx=e_idx-5\\n\\t\\t\\t\\tans=st[:5]+\"...\"+st[s_idx:e_idx]+st[e_idx:]\\n\\t\\t\\t\\treturn ans\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn st",
                "codeTag": "Java"
            },
            {
                "id": 4027006,
                "title": "python-5-lines-only-by-0-count-for-beginner",
                "content": "- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n```\\nclass Solution(object):\\n    def abbreviateProduct(self, left, right):\\n        t, k = str(reduce(operator.mul,range(left,right+1))), 0\\n        while t[-k-1]==\\'0\\': k +=1\\n        if k: t=t[:-k]\\n        if len(t)>10: t=t[:5]+\\'...\\'+t[-5:]\\n        return t+\\'e\\'+str(k)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def abbreviateProduct(self, left, right):\\n        t, k = str(reduce(operator.mul,range(left,right+1))), 0\\n        while t[-k-1]==\\'0\\': k +=1\\n        if k: t=t[:-k]\\n        if len(t)>10: t=t[:5]+\\'...\\'+t[-5:]\\n        return t+\\'e\\'+str(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967134,
                "title": "very-straightforward-completely-beginner-friendly-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFairly easy. Just find the product and convert it to str\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou just find the product and convert to string to slice it\\n\\n# Complexity\\n- Time complexity: 51%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 70%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport sys \\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        sys.set_int_max_str_digits(20000000)\\n        p = 1\\n        for i in range(left, right+1):\\n            p *= i\\n        s = str(p)\\n        c = len(s) \\n        s = s.rstrip(\\'0\\')\\n        c = c - len(s)\\n        if len(s) > 10:\\n            return \\'%s...%se%s\\' % (s[:5], s[-5:], str(c))\\n        return \\'%se%s\\' % (s, str(c))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport sys \\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        sys.set_int_max_str_digits(20000000)\\n        p = 1\\n        for i in range(left, right+1):\\n            p *= i\\n        s = str(p)\\n        c = len(s) \\n        s = s.rstrip(\\'0\\')\\n        c = c - len(s)\\n        if len(s) > 10:\\n            return \\'%s...%se%s\\' % (s[:5], s[-5:], str(c))\\n        return \\'%se%s\\' % (s, str(c))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645887,
                "title": "easy-to-understand-python-solution-for-abbreviating-the-product-of-a-range",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGood challenging problem \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnormal method , solution is easy to understand just used simple string slicing methods to solve it \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(right-left+logN) \\nN = value of product of all numbers between left and right\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def abbreviateProduct(self, left, right):\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: str\\n        \"\"\"\\n        prod=1\\n        for i in range(left,right+1):\\n            prod*=i\\n        str_prod = str(prod)\\n        count_digit=0\\n        count_zeros=0\\n        str5=str_prod\\n        while (str5[-1] == \\'0\\'):\\n            str5 = str5[:-1]\\n            count_zeros = count_zeros+1\\n        count_digit = len(str5)\\n        res=\"\"\\n        if count_digit<=10:\\n            str2=\"e\"+str(count_zeros)\\n            if(count_zeros==0):\\n                res = str_prod+str2\\n            else:\\n                res = str_prod[:-count_zeros]\\n                res = res+str2\\n            #print(res)\\n        else:\\n            str4 = str_prod[:-count_zeros]\\n            str3 = \"e\"+str(count_zeros)\\n            pre = str5[:5]\\n            suf = str5[len(str5)-5:]\\n            res = pre+\"...\"+suf+str3\\n            #print(\"res = \",res)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def abbreviateProduct(self, left, right):\\n        \"\"\"\\n        :type left: int\\n        :type right: int\\n        :rtype: str\\n        \"\"\"\\n        prod=1\\n        for i in range(left,right+1):\\n            prod*=i\\n        str_prod = str(prod)\\n        count_digit=0\\n        count_zeros=0\\n        str5=str_prod\\n        while (str5[-1] == \\'0\\'):\\n            str5 = str5[:-1]\\n            count_zeros = count_zeros+1\\n        count_digit = len(str5)\\n        res=\"\"\\n        if count_digit<=10:\\n            str2=\"e\"+str(count_zeros)\\n            if(count_zeros==0):\\n                res = str_prod+str2\\n            else:\\n                res = str_prod[:-count_zeros]\\n                res = res+str2\\n            #print(res)\\n        else:\\n            str4 = str_prod[:-count_zeros]\\n            str3 = \"e\"+str(count_zeros)\\n            pre = str5[:5]\\n            suf = str5[len(str5)-5:]\\n            res = pre+\"...\"+suf+str3\\n            #print(\"res = \",res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254052,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn abbreviate_product(left: i32, right: i32) -> String {\\n        let (mut suff, mut c, mut total, max_suff) = (1, 0, 0, 100_000_000_000);\\n        let mut pref = 1.0;\\n        for i in left..=right {\\n            pref *= i as f64;\\n            suff *= i as i64;\\n            while pref >= 100_000.0 {\\n                pref /= 10.0;\\n                total = if total == 0 { 6 } else { total + 1 };\\n            }\\n            while suff % 10 == 0 {\\n                suff /= 10;\\n                c += 1;\\n            }\\n            suff %= max_suff;\\n        }\\n        let s = suff.to_string();\\n        format!(\\n            \"{}{}{}e{}\",\\n            pref as i32,\\n            if total - c <= 10 { \"\" } else { \"...\" },\\n            if total - c < 5 {\\n                \"\"\\n            } else {\\n                &s[s.len() - (total - c - 5).min(5) as usize..]\\n            },\\n            c\\n        )\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn abbreviate_product(left: i32, right: i32) -> String {\\n        let (mut suff, mut c, mut total, max_suff) = (1, 0, 0, 100_000_000_000);\\n        let mut pref = 1.0;\\n        for i in left..=right {\\n            pref *= i as f64;\\n            suff *= i as i64;\\n            while pref >= 100_000.0 {\\n                pref /= 10.0;\\n                total = if total == 0 { 6 } else { total + 1 };\\n            }\\n            while suff % 10 == 0 {\\n                suff /= 10;\\n                c += 1;\\n            }\\n            suff %= max_suff;\\n        }\\n        let s = suff.to_string();\\n        format!(\\n            \"{}{}{}e{}\",\\n            pref as i32,\\n            if total - c <= 10 { \"\" } else { \"...\" },\\n            if total - c < 5 {\\n                \"\"\\n            } else {\\n                &s[s.len() - (total - c - 5).min(5) as usize..]\\n            },\\n            c\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3035796,
                "title": "understandable-python-solution-with-linear-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the above code is to efficiently calculate and represent the product of all integers in the given range in a human-readable format. The product can be very large and contain many trailing zeros, which can make it difficult to read and understand. So this code aims to simplify the representation of the product by removing trailing zeros and truncating the number to the first 5 and last 5 digits, if it has more than 10 digits.\\n\\n# Approach\\n1. Initialize a variable \\'product\\' to 1 and a variable \\'trailing_zeros\\' to 0.\\n2. Use a for loop to iterate over all integers in the range [left, right]. For each integer in the range, multiply it with the current value of \\'product\\'\\n3. While the last digit of product is zero, count number of trailing zeros and divide product by 10\\n4. Convert product to a string, store the number of digits of product in a variable \\'digits\\'\\n5. If the number of digits of the product is greater than 10, return the first 5 digits followed by \\'...\\' and the last 5 digits, followed by \\'e\\' and the number of trailing zeros.\\n6. If the number of digits of the product is less than or equal to 10, return the original number followed by \\'e\\' and the number of trailing zeros.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        product = 1\\n        for i in range(left, right + 1):\\n            product *= i\\n        trailing_zeros = 0\\n        while product % 10 == 0:\\n            trailing_zeros += 1\\n            product //= 10\\n        product_str = str(product)\\n        digits = len(product_str)\\n        if digits > 10:\\n            pre = product_str[:5]\\n            suf = product_str[-5:]\\n            return f\"{pre}...{suf}e{trailing_zeros}\"\\n        else:\\n            return f\"{product_str}e{trailing_zeros}\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        product = 1\\n        for i in range(left, right + 1):\\n            product *= i\\n        trailing_zeros = 0\\n        while product % 10 == 0:\\n            trailing_zeros += 1\\n            product //= 10\\n        product_str = str(product)\\n        digits = len(product_str)\\n        if digits > 10:\\n            pre = product_str[:5]\\n            suf = product_str[-5:]\\n            return f\"{pre}...{suf}e{trailing_zeros}\"\\n        else:\\n            return f\"{product_str}e{trailing_zeros}\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865331,
                "title": "i-strive-for-the-simple-things-lol-python-truly-simple-solution",
                "content": "The longest it took for me: https://leetcode.com/submissions/detail/852714885/\\n\\n```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        product, numZeros = factorial(right) // factorial(left - 1), 0\\n        while not product % 10:\\n            product //= 10\\n            numZeros += 1\\n        product = str(product)\\n        if len(product) > 10:\\n            return product[:5] + \\'...\\' + product[-5:] + \\'e\\' + str(numZeros)\\n        return product + \\'e\\' + str(numZeros)\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        product, numZeros = factorial(right) // factorial(left - 1), 0\\n        while not product % 10:\\n            product //= 10\\n            numZeros += 1\\n        product = str(product)\\n        if len(product) > 10:\\n            return product[:5] + \\'...\\' + product[-5:] + \\'e\\' + str(numZeros)\\n        return product + \\'e\\' + str(numZeros)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753591,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        prod = left\\n        for i in range(prod+1,right+1):\\n            prod *= i\\n        \\n        prod = str(prod)\\n        prod = [prod[i] for i in range(len(prod))]\\n        pos = len(prod)-1\\n        count = 0\\n        for j in range(pos,-1,-1):\\n            if prod[j] == \"0\":\\n                count += 1\\n            else:\\n                break\\n        \\n        start = pos-count\\n        prod = prod[:start+1]\\n        if len(prod) > 10:\\n            first_five = \"\".join(prod[:5])\\n            last_five = \"\".join(prod[len(prod)-5:])\\n            return first_five + \"...\" + last_five + \"e\" + str(count)\\n        else:\\n            string = \"\".join(prod)\\n            return string + \"e\" + str(count)\\n        \\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        prod = left\\n        for i in range(prod+1,right+1):\\n            prod *= i\\n        \\n        prod = str(prod)\\n        prod = [prod[i] for i in range(len(prod))]\\n        pos = len(prod)-1\\n        count = 0\\n        for j in range(pos,-1,-1):\\n            if prod[j] == \"0\":\\n                count += 1\\n            else:\\n                break\\n        \\n        start = pos-count\\n        prod = prod[:start+1]\\n        if len(prod) > 10:\\n            first_five = \"\".join(prod[:5])\\n            last_five = \"\".join(prod[len(prod)-5:])\\n            return first_five + \"...\" + last_five + \"e\" + str(count)\\n        else:\\n            string = \"\".join(prod)\\n            return string + \"e\" + str(count)\\n        \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663094,
                "title": "python-solution-faster-90",
                "content": "\\tclass Solution:\\n\\t\\tdef abbreviateProduct(self, l: int, r: int) -> str:\\n\\n\\t\\t\\tnum=1\\n\\t\\t\\tfor i in range(l,r+1):\\n\\t\\t\\t\\tnum=num*i\\n\\n\\t\\t\\tc=0\\n\\t\\t\\twhile(num>0 and num%10==0):\\n\\t\\t\\t\\tc+=1\\n\\t\\t\\t\\tnum=num//10\\n\\n\\t\\t\\ts=str(num)\\n\\t\\t\\tres=s\\n\\t\\t\\tif len(s)>10:\\n\\t\\t\\t\\tres=s[:5]+\\'...\\'+s[-5:]\\n\\t\\t\\tres=res+\\'e\\'+str(c)\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef abbreviateProduct(self, l: int, r: int) -> str:\\n\\n\\t\\t\\tnum=1\\n\\t\\t\\tfor i in range(l,r+1):\\n\\t\\t\\t\\tnum=num*i\\n\\n\\t\\t\\tc=0\\n\\t\\t\\twhile(num>0 and num%10==0):\\n\\t\\t\\t\\tc+=1\\n\\t\\t\\t\\tnum=num//10\\n\\n\\t\\t\\ts=str(num)\\n\\t\\t\\tres=s\\n\\t\\t\\tif len(s)>10:\\n\\t\\t\\t\\tres=s[:5]+\\'...\\'+s[-5:]\\n\\t\\t\\tres=res+\\'e\\'+str(c)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2323614,
                "title": "non-bruteforce-algorithm-in-python3-with-numpy",
                "content": "As suggested in the hints, the three parts are calculated separately.  The precision issue in the Python built-in floating numbers happen, so I use numpy.float128 instead of the built-in floats. \\n\\n```\\nimport numpy\\n\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        log_prod = numpy.float128(0)\\n        last = 1\\n        num_zeros = 0\\n        for x in range(left, right+1):\\n            log_prod += numpy.log10(x)\\n            last *= x\\n            while last % 10 == 0:\\n                last //= 10\\n                num_zeros += 1\\n            last %= 1000000000000\\n        x = floor(log_prod)\\n        if x - num_zeros < 10:\\n            return \"%de%d\" % (last % 10000000000, num_zeros)\\n        return \"%.0f...%05de%d\" % (floor(numpy.power(10, (4 + log_prod - x))), last % 100000, num_zeros)\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "As suggested in the hints, the three parts are calculated separately.  The precision issue in the Python built-in floating numbers happen, so I use numpy.float128 instead of the built-in floats. \\n\\n```\\nimport numpy\\n\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        log_prod = numpy.float128(0)\\n        last = 1\\n        num_zeros = 0\\n        for x in range(left, right+1):\\n            log_prod += numpy.log10(x)\\n            last *= x\\n            while last % 10 == 0:\\n                last //= 10\\n                num_zeros += 1\\n            last %= 1000000000000\\n        x = floor(log_prod)\\n        if x - num_zeros < 10:\\n            return \"%de%d\" % (last % 10000000000, num_zeros)\\n        return \"%.0f...%05de%d\" % (floor(numpy.power(10, (4 + log_prod - x))), last % 100000, num_zeros)\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2236248,
                "title": "fast-o-polylog-n-time-algorithm-c-0ms-100",
                "content": "An algorithmic math problem.\\nFirst 5 digits: numerical analysis.\\nLast 5 digits: number theory.\\n```\\n#define double long double\\nconst double PI=atan((double)1)*4,E=exp((double)1),\\n  B[]={1,1./2,1./6,0,-1./30,0,1./42,0,-1./30,0,5./66,0,-691./2730,0,7./6,0,-3617./510,0,43867./798,0,-174611./330};\\nconst int M=10;\\ndouble log_fac(double n){\\n\\tdouble ans=n*log(n/E)+log(n)/2+log(sqrt(PI*2));\\n\\tfor (int i=2;i<=M;++i)ans+=pow(-1,i)*B[i]/(i*(i-1)*pow(n,i-1));\\n\\tif (n<20){\\n\\t\\tans=0;\\n\\t\\tfor (int i=1;i<=n;++i)ans+=log(i);\\n\\t}\\n\\treturn ans;\\n}\\nint leading(int l,int r){\\n\\tdouble t=log_fac(r)-log_fac(l-1);\\n\\tt/=log((double)10); t-=int(t)-4;\\n\\treturn pow(10,t);\\n}\\n\\nconst int P=3125;\\ntemplate<class T> T extend_gcd(T a,T b,T &x,T &y){\\n\\tif (!b){x=1;y=0;return a;}\\n\\tT res=extend_gcd(b,a%b,y,x); y-=x*(a/b);\\n\\treturn res;\\n}\\ntemplate<class T>\\ninline T inv(T a,T M){\\n\\tT x,y; extend_gcd(a,M,x,y);\\n\\treturn (x%M+M)%M;\\n}\\nconst int inv2=inv(2,P);\\nint exp(int x,int y,int z){\\n\\tint ans=1;\\n\\twhile (y){\\n\\t\\tif (y&1)ans=ans*x%z;\\n\\t\\tx=x*x%z;y>>=1;\\n\\t}\\n\\treturn ans;\\n}\\nint Chinese_Remainder_Theorem(int A[],int M[],int n){\\n\\tfor (int i=1;i<n;++i){\\n\\t\\tint x,y,P=M[0]*M[i];\\n\\t\\textend_gcd(M[0],M[i],x,y);\\n\\t\\tx=(x*(A[i]-A[0])%P+P)%P;\\n\\t\\tA[0]=(x*M[0]+A[0])%P; M[0]=P;\\n\\t}\\n\\treturn A[0];\\n}\\n// PolynomialMod[Product[If[Mod[i,5]>0,5^4*x+i,1],{i,1,5^4}],3125]\\nint calc(int x,int d){\\n\\tswitch(d){\\n\\t\\tcase 0: return x%5?x%P:1;\\n\\t\\tcase 1: return (24+250*x+875*x%P*x+1250*x%P*x%P*x+625*x%P*x%P*x%P*x)%P;\\n\\t\\tcase 2: return 124;\\n\\t\\tcase 3: return 624;\\n\\t\\tcase 4:\\n\\t\\tcase 5: return 3124;\\n\\t}\\n\\treturn 0;\\n}\\nint get(int l,int r,int d){\\n\\tif (l>r||d<0)return 1;\\n\\tint mod=pow(5,d),l0=(l-1)/mod+1,r0=(r+1)/mod,res=1;\\n\\tfor (int i=l0;i<r0;++i)res=res*calc(i,d)%P;\\n\\tif (l0<r0)return res*get(l,l0*mod-1,d-1)%P*get(r0*mod,r,d-1)%P;\\n\\telse return get(l,r,d-1);\\n}\\nstring abbreviateProduct1(int left, int right) {  // brute force\\n    long long suff = 1, c = 0, total = 0, max_suff = 100000000000LL;\\n    double pref = 1.0;\\n    for (int i = left; i <= right; ++i) {\\n        pref *= i;\\n        suff *= i;\\n        while (pref >= 100000) {\\n            pref /= 10;\\n            total = total == 0 ? 6 : total + 1; \\n        }\\n        while (suff % 10 == 0) {\\n            suff /= 10;\\n            ++c;\\n        }\\n        suff %= max_suff;\\n    }\\n    string s = to_string(suff);\\n    return to_string((int)pref) + (total - c <= 10 ? \"\" : \"...\") \\n    \\t+ (total - c < 5 ? \"\" : s.substr(s.size() - min(5LL, total - c - 5))) + \"e\" + to_string(c);\\n}\\nclass Solution {\\npublic:\\n\\tstring abbreviateProduct(int l, int r) {\\n\\t\\tif (r-l<20)return abbreviateProduct1(l,r);\\n\\t\\tint last=1,l0=l,r0=r,zeros=0;\\n\\t\\twhile (l0<=r0){\\n\\t\\t\\tlast=last*get(l0,r0,5)%P;\\n\\t\\t\\tl0=(l0-1)/5+1; r0/=5;\\n\\t\\t\\tzeros+=r0-l0+1;\\n\\t\\t}\\n\\t\\tlast=last*exp(inv2,zeros,P)%P;\\n\\t\\tint A[]={0,last},M[]={32,3125};\\n\\t\\tlast=Chinese_Remainder_Theorem(A,M,2);\\n\\t\\tchar str1[15]; sprintf(str1,\"%05d\",last);\\n\\t\\treturn to_string(leading(l,r))+\"...\"+string(str1)+\"e\"+to_string(zeros);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n#define double long double\\nconst double PI=atan((double)1)*4,E=exp((double)1),\\n  B[]={1,1./2,1./6,0,-1./30,0,1./42,0,-1./30,0,5./66,0,-691./2730,0,7./6,0,-3617./510,0,43867./798,0,-174611./330};\\nconst int M=10;\\ndouble log_fac(double n){\\n\\tdouble ans=n*log(n/E)+log(n)/2+log(sqrt(PI*2));\\n\\tfor (int i=2;i<=M;++i)ans+=pow(-1,i)*B[i]/(i*(i-1)*pow(n,i-1));\\n\\tif (n<20){\\n\\t\\tans=0;\\n\\t\\tfor (int i=1;i<=n;++i)ans+=log(i);\\n\\t}\\n\\treturn ans;\\n}\\nint leading(int l,int r){\\n\\tdouble t=log_fac(r)-log_fac(l-1);\\n\\tt/=log((double)10); t-=int(t)-4;\\n\\treturn pow(10,t);\\n}\\n\\nconst int P=3125;\\ntemplate<class T> T extend_gcd(T a,T b,T &x,T &y){\\n\\tif (!b){x=1;y=0;return a;}\\n\\tT res=extend_gcd(b,a%b,y,x); y-=x*(a/b);\\n\\treturn res;\\n}\\ntemplate<class T>\\ninline T inv(T a,T M){\\n\\tT x,y; extend_gcd(a,M,x,y);\\n\\treturn (x%M+M)%M;\\n}\\nconst int inv2=inv(2,P);\\nint exp(int x,int y,int z){\\n\\tint ans=1;\\n\\twhile (y){\\n\\t\\tif (y&1)ans=ans*x%z;\\n\\t\\tx=x*x%z;y>>=1;\\n\\t}\\n\\treturn ans;\\n}\\nint Chinese_Remainder_Theorem(int A[],int M[],int n){\\n\\tfor (int i=1;i<n;++i){\\n\\t\\tint x,y,P=M[0]*M[i];\\n\\t\\textend_gcd(M[0],M[i],x,y);\\n\\t\\tx=(x*(A[i]-A[0])%P+P)%P;\\n\\t\\tA[0]=(x*M[0]+A[0])%P; M[0]=P;\\n\\t}\\n\\treturn A[0];\\n}\\n// PolynomialMod[Product[If[Mod[i,5]>0,5^4*x+i,1],{i,1,5^4}],3125]\\nint calc(int x,int d){\\n\\tswitch(d){\\n\\t\\tcase 0: return x%5?x%P:1;\\n\\t\\tcase 1: return (24+250*x+875*x%P*x+1250*x%P*x%P*x+625*x%P*x%P*x%P*x)%P;\\n\\t\\tcase 2: return 124;\\n\\t\\tcase 3: return 624;\\n\\t\\tcase 4:\\n\\t\\tcase 5: return 3124;\\n\\t}\\n\\treturn 0;\\n}\\nint get(int l,int r,int d){\\n\\tif (l>r||d<0)return 1;\\n\\tint mod=pow(5,d),l0=(l-1)/mod+1,r0=(r+1)/mod,res=1;\\n\\tfor (int i=l0;i<r0;++i)res=res*calc(i,d)%P;\\n\\tif (l0<r0)return res*get(l,l0*mod-1,d-1)%P*get(r0*mod,r,d-1)%P;\\n\\telse return get(l,r,d-1);\\n}\\nstring abbreviateProduct1(int left, int right) {  // brute force\\n    long long suff = 1, c = 0, total = 0, max_suff = 100000000000LL;\\n    double pref = 1.0;\\n    for (int i = left; i <= right; ++i) {\\n        pref *= i;\\n        suff *= i;\\n        while (pref >= 100000) {\\n            pref /= 10;\\n            total = total == 0 ? 6 : total + 1; \\n        }\\n        while (suff % 10 == 0) {\\n            suff /= 10;\\n            ++c;\\n        }\\n        suff %= max_suff;\\n    }\\n    string s = to_string(suff);\\n    return to_string((int)pref) + (total - c <= 10 ? \"\" : \"...\") \\n    \\t+ (total - c < 5 ? \"\" : s.substr(s.size() - min(5LL, total - c - 5))) + \"e\" + to_string(c);\\n}\\nclass Solution {\\npublic:\\n\\tstring abbreviateProduct(int l, int r) {\\n\\t\\tif (r-l<20)return abbreviateProduct1(l,r);\\n\\t\\tint last=1,l0=l,r0=r,zeros=0;\\n\\t\\twhile (l0<=r0){\\n\\t\\t\\tlast=last*get(l0,r0,5)%P;\\n\\t\\t\\tl0=(l0-1)/5+1; r0/=5;\\n\\t\\t\\tzeros+=r0-l0+1;\\n\\t\\t}\\n\\t\\tlast=last*exp(inv2,zeros,P)%P;\\n\\t\\tint A[]={0,last},M[]={32,3125};\\n\\t\\tlast=Chinese_Remainder_Theorem(A,M,2);\\n\\t\\tchar str1[15]; sprintf(str1,\"%05d\",last);\\n\\t\\treturn to_string(leading(l,r))+\"...\"+string(str1)+\"e\"+to_string(zeros);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166680,
                "title": "go-golang-prefix-suffix-totaldigits-count-trailingzeroes-math",
                "content": "```\\nfunc abbreviateProduct(left int, right int) string {\\n    product, trailingZeros, totalDigitsInProduct := 1, 0, 0.0\\n    maxSuffix:=100000000000\\n    maxPrefix:=100000\\n\\tprefix := 1.0\\n\\n\\tfor i := left; i <= right; i++ {\\n\\t\\tproduct *= i\\n        totalDigitsInProduct += math.Log10(float64(i))\\n        prefix *= float64(i)\\n        for prefix >= float64(maxPrefix)  {\\n\\t\\t\\tprefix /= 10\\n\\t\\t}\\n        \\n\\t\\tfor product%10 == 0 {\\n\\t\\t\\tproduct /= 10\\n\\t\\t\\ttrailingZeros++\\n\\t\\t}\\n\\n\\t\\tproduct %= maxSuffix\\n\\t}\\n    totalDigitsInProduct+=1\\n    totalDigitsInProduct=math.Floor(totalDigitsInProduct)\\n    workingDigits:= int(totalDigitsInProduct) - trailingZeros\\n    \\n\\tsuffix := fmt.Sprintf(\"%v\",product)\\n    if workingDigits > 10 {\\n        return fmt.Sprintf(\"%v...%se%v\",int(prefix),suffix[len(suffix)-5:],trailingZeros)\\n\\t}\\n\\tif workingDigits >= 5 {\\n        return fmt.Sprintf(\"%v%se%v\",int(prefix),suffix[len(suffix)-(workingDigits-5):],trailingZeros)\\n\\t}\\n    return fmt.Sprintf(\"%ve%v\",int(prefix),trailingZeros)\\n}",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nfunc abbreviateProduct(left int, right int) string {\\n    product, trailingZeros, totalDigitsInProduct := 1, 0, 0.0\\n    maxSuffix:=100000000000\\n    maxPrefix:=100000\\n\\tprefix := 1.0\\n\\n\\tfor i := left; i <= right; i++ {\\n\\t\\tproduct *= i\\n        totalDigitsInProduct += math.Log10(float64(i))\\n        prefix *= float64(i)\\n        for prefix >= float64(maxPrefix)  {\\n\\t\\t\\tprefix /= 10\\n\\t\\t}\\n        \\n\\t\\tfor product%10 == 0 {\\n\\t\\t\\tproduct /= 10\\n\\t\\t\\ttrailingZeros++\\n\\t\\t}\\n\\n\\t\\tproduct %= maxSuffix\\n\\t}\\n    totalDigitsInProduct+=1\\n    totalDigitsInProduct=math.Floor(totalDigitsInProduct)\\n    workingDigits:= int(totalDigitsInProduct) - trailingZeros\\n    \\n\\tsuffix := fmt.Sprintf(\"%v\",product)\\n    if workingDigits > 10 {\\n        return fmt.Sprintf(\"%v...%se%v\",int(prefix),suffix[len(suffix)-5:],trailingZeros)\\n\\t}\\n\\tif workingDigits >= 5 {\\n        return fmt.Sprintf(\"%v%se%v\",int(prefix),suffix[len(suffix)-(workingDigits-5):],trailingZeros)\\n\\t}\\n    return fmt.Sprintf(\"%ve%v\",int(prefix),trailingZeros)\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1872369,
                "title": "modulo-and-double",
                "content": "Go version of the solution:\\nhttps://leetcode.com/problems/abbreviating-the-product-of-a-range/discuss/1647115/Modulo-and-Double\\n\\n```\\nfunc abbreviateProduct(left int, right int) string {\\n\\tstuff, c, total, maxStuff := 1, 0, 0, 100000000000\\n\\tpref := 1.0\\n\\n\\tfor i := left; i <= right; i++ {\\n\\t\\tpref *= float64(i)\\n\\t\\tstuff *= i\\n\\n\\t\\tfor pref >= 100000 {\\n\\t\\t\\tpref /= 10\\n\\t\\t\\tif total == 0 {\\n\\t\\t\\t\\ttotal = 6\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttotal++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor stuff%10 == 0 {\\n\\t\\t\\tstuff /= 10\\n\\t\\t\\tc++\\n\\t\\t}\\n\\n\\t\\tstuff %= maxStuff\\n\\t}\\n\\n\\ts := strconv.Itoa(stuff)\\n\\n\\tres := strconv.Itoa(int(pref))\\n\\tif total-c > 10 {\\n\\t\\tres += \"...\"\\n\\t}\\n\\tif total-c >= 5 {\\n\\t\\tres += s[len(s)-min(5, total-c-5):]\\n\\t}\\n\\n\\tres += \"e\" + strconv.Itoa(c)\\n\\n\\treturn res\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc abbreviateProduct(left int, right int) string {\\n\\tstuff, c, total, maxStuff := 1, 0, 0, 100000000000\\n\\tpref := 1.0\\n\\n\\tfor i := left; i <= right; i++ {\\n\\t\\tpref *= float64(i)\\n\\t\\tstuff *= i\\n\\n\\t\\tfor pref >= 100000 {\\n\\t\\t\\tpref /= 10\\n\\t\\t\\tif total == 0 {\\n\\t\\t\\t\\ttotal = 6\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttotal++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor stuff%10 == 0 {\\n\\t\\t\\tstuff /= 10\\n\\t\\t\\tc++\\n\\t\\t}\\n\\n\\t\\tstuff %= maxStuff\\n\\t}\\n\\n\\ts := strconv.Itoa(stuff)\\n\\n\\tres := strconv.Itoa(int(pref))\\n\\tif total-c > 10 {\\n\\t\\tres += \"...\"\\n\\t}\\n\\tif total-c >= 5 {\\n\\t\\tres += s[len(s)-min(5, total-c-5):]\\n\\t}\\n\\n\\tres += \"e\" + strconv.Itoa(c)\\n\\n\\treturn res\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1792012,
                "title": "python3-accepted-solution-using-rstrip",
                "content": "```\\n  class Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        product=1\\n        for i in range(left,right+1):\\n            product *= i\\n        if(len(str(product).rstrip(\"0\"))<=10):\\n            return str(product).rstrip(\"0\") + \"e\" + str(len(str(product)) - len(str(product).rstrip(\"0\")))\\n        else:\\n            return str(product).rstrip(\"0\")[:5] +\"...\"+ str(product).rstrip(\"0\")[-5:]+\"e\" + str(len(str(product)) - len(str(product).rstrip(\"0\")))\\n           \\n ```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\n  class Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        product=1\\n        for i in range(left,right+1):\\n            product *= i\\n        if(len(str(product).rstrip(\"0\"))<=10):\\n            return str(product).rstrip(\"0\") + \"e\" + str(len(str(product)) - len(str(product).rstrip(\"0\")))\\n        else:\\n            return str(product).rstrip(\"0\")[:5] +\"...\"+ str(product).rstrip(\"0\")[-5:]+\"e\" + str(len(str(product)) - len(str(product).rstrip(\"0\")))\\n           \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1738299,
                "title": "straightforward-python-3-solution-beats-98-29-on-memory",
                "content": "Hope this helps...\\n\\n\\'\\'\\'\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n\\t\\n        product = 1\\n        \\n        #Since trailing zeros come from 2*5 ultimately...\\n        two_count = 0\\n        five_count = 0\\n\\n        for i in range(left, right+1):\\n            \\n            #Filter all 2s and 5s:\\n            while i%2 == 0:\\n                i = i//2\\n                two_count += 1\\n            while i%5 == 0:\\n                i = i//5\\n                five_count += 1\\n            \\n            #Do the math on the rest\\n            product *= i\\n\\n        #Whichever smaller is the pairs of 2*5 we have\\n        trailing_zeros = min(two_count, five_count)\\n\\n        two_count -= trailing_zeros\\n        five_count -= trailing_zeros\\n        \\n        #Multiply the \"unused 2s or 5s\"\\n        if two_count > 0:\\n            product *= 2 ** two_count\\n        elif five_count > 0:\\n            product *= 5 ** five_count\\n        \\n        #Format as instructed\\n        if product > 9999999999:\\n            product = str(product)[:5] +\"...\"+ str(product)[-5:]\\n\\n        product = str(product)+\"e\"+str(trailing_zeros)\\n\\n        return(product)\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Hope this helps...\\n\\n\\'\\'\\'\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n\\t\\n        product = 1\\n        \\n        #Since trailing zeros come from 2*5 ultimately...\\n        two_count = 0\\n        five_count = 0\\n\\n        for i in range(left, right+1):\\n            \\n            #Filter all 2s and 5s:\\n            while i%2 == 0:\\n                i = i//2\\n                two_count += 1\\n            while i%5 == 0:\\n                i = i//5\\n                five_count += 1\\n            \\n            #Do the math on the rest\\n            product *= i\\n\\n        #Whichever smaller is the pairs of 2*5 we have\\n        trailing_zeros = min(two_count, five_count)\\n\\n        two_count -= trailing_zeros\\n        five_count -= trailing_zeros\\n        \\n        #Multiply the \"unused 2s or 5s\"\\n        if two_count > 0:\\n            product *= 2 ** two_count\\n        elif five_count > 0:\\n            product *= 5 ** five_count\\n        \\n        #Format as instructed\\n        if product > 9999999999:\\n            product = str(product)[:5] +\"...\"+ str(product)[-5:]\\n\\n        product = str(product)+\"e\"+str(trailing_zeros)\\n\\n        return(product)\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1686960,
                "title": "c-math-solution",
                "content": "See problem hints for why this works.\\n```\\n#define MAX_CONTIGUOUS 10000000000ULL\\n\\nchar *abbreviateProduct(int left, int right){\\n    // Max size: #####...#####e####\\n    char* ret = calloc(19, sizeof(char));\\n    \\n    uint64_t product = 0;\\n    uint32_t top = 0;\\n    uint32_t bottom = 0;\\n    // 10000! has 2499 trailing zeros\\n    uint16_t numZeros = 0;\\n    \\n    { // Num zeros\\n        uint16_t numTwos = 0;\\n        uint16_t numFives = 0;\\n\\n        for (uint16_t m = left; m <= right; m++) {\\n            uint16_t cur = m;\\n            \\n            for(; (cur % 2) == 0; cur /= 2, numTwos++);\\n            for(; (cur % 5) == 0; cur /= 5, numFives++);\\n        }\\n        \\n        numZeros = (numTwos < numFives) ? numTwos : numFives;\\n    }\\n    \\n    { // Bottom 5 digits\\n        uint16_t numTwos = numZeros;\\n        uint16_t numFives = numZeros;\\n\\n        bottom = 1;\\n        product = 1;\\n        for (uint16_t m = left; m <= right; m++) {\\n            uint16_t cur = m;\\n            \\n            for(; (cur % 2) == 0 && numTwos  > 0; cur /= 2, numTwos--);\\n            for(; (cur % 5) == 0 && numFives > 0; cur /= 5, numFives--);\\n            \\n            bottom *= cur;\\n            bottom %= 100000;\\n            \\n            if (product < MAX_CONTIGUOUS) {\\n                product *= cur;\\n            }\\n        }\\n    }\\n    \\n    // Top 5 digits\\n    if (product >= MAX_CONTIGUOUS) { \\n        // \\'long double\\' precision is required for all tests to pass.\\n        long double sum = 0;\\n        double temp = 0;\\n        \\n        for (double m = left; m <= right; m++) {\\n            sum += log10(m);\\n        }\\n        \\n\\t\\t// Set sum to fraction part of the double\\n        sum = modf(sum, &temp);\\n        top = floor(pow(10.0, 4.0 + sum));\\n    }\\n    \\n    if (product < MAX_CONTIGUOUS) {\\n        sprintf(ret, \"%llue%lu\", product, numZeros);\\n    } else {\\n        sprintf(ret, \"%lu...%05lue%lu\", top, bottom, numZeros);\\n    }\\n    \\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n#define MAX_CONTIGUOUS 10000000000ULL\\n\\nchar *abbreviateProduct(int left, int right){\\n    // Max size: #####...#####e####\\n    char* ret = calloc(19, sizeof(char));\\n    \\n    uint64_t product = 0;\\n    uint32_t top = 0;\\n    uint32_t bottom = 0;\\n    // 10000! has 2499 trailing zeros\\n    uint16_t numZeros = 0;\\n    \\n    { // Num zeros\\n        uint16_t numTwos = 0;\\n        uint16_t numFives = 0;\\n\\n        for (uint16_t m = left; m <= right; m++) {\\n            uint16_t cur = m;\\n            \\n            for(; (cur % 2) == 0; cur /= 2, numTwos++);\\n            for(; (cur % 5) == 0; cur /= 5, numFives++);\\n        }\\n        \\n        numZeros = (numTwos < numFives) ? numTwos : numFives;\\n    }\\n    \\n    { // Bottom 5 digits\\n        uint16_t numTwos = numZeros;\\n        uint16_t numFives = numZeros;\\n\\n        bottom = 1;\\n        product = 1;\\n        for (uint16_t m = left; m <= right; m++) {\\n            uint16_t cur = m;\\n            \\n            for(; (cur % 2) == 0 && numTwos  > 0; cur /= 2, numTwos--);\\n            for(; (cur % 5) == 0 && numFives > 0; cur /= 5, numFives--);\\n            \\n            bottom *= cur;\\n            bottom %= 100000;\\n            \\n            if (product < MAX_CONTIGUOUS) {\\n                product *= cur;\\n            }\\n        }\\n    }\\n    \\n    // Top 5 digits\\n    if (product >= MAX_CONTIGUOUS) { \\n        // \\'long double\\' precision is required for all tests to pass.\\n        long double sum = 0;\\n        double temp = 0;\\n        \\n        for (double m = left; m <= right; m++) {\\n            sum += log10(m);\\n        }\\n        \\n\\t\\t// Set sum to fraction part of the double\\n        sum = modf(sum, &temp);\\n        top = floor(pow(10.0, 4.0 + sum));\\n    }\\n    \\n    if (product < MAX_CONTIGUOUS) {\\n        sprintf(ret, \"%llue%lu\", product, numZeros);\\n    } else {\\n        sprintf(ret, \"%lu...%05lue%lu\", top, bottom, numZeros);\\n    }\\n    \\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1670667,
                "title": "clean-and-fast-java-solution",
                "content": "```\\n\\tprivate static final long MAX_SUFFIX = 1000000000000L;\\n    private static final int MAX_PREFIX = 100000;\\n    \\n    public String abbreviateProduct(int left, int right) {\\n        long product = 1;\\n        int trailingZeros = 0;\\n        double prefix = 1.0;\\n        \\n        for (int num = left; num <= right; num++) {\\n            product *= num;\\n            while (product % 10 == 0) {\\n                product /= 10;\\n                trailingZeros++;\\n            }\\n            \\n            if (product >= MAX_SUFFIX) {\\n                product %= MAX_SUFFIX;\\n            }\\n            \\n            prefix *= num;\\n            \\n            while (prefix >= MAX_PREFIX) {\\n                prefix /= 10;\\n            }\\n        }\\n        return buildAbbreviation(prefix, product, trailingZeros);\\n    }\\n    \\n    private String buildAbbreviation(double prefix, long product, int trailingZeros) {\\n        String suffix = String.valueOf(product);\\n        if (suffix.length() > 10) {\\n            suffix = (int)prefix + \"...\" + suffix.substring(suffix.length() - 5);\\n        }\\n        \\n        return String.format(\"%se%d\", suffix, trailingZeros);\\n    }\\n```\\n\\nHopefully code is self explanatory. But if you need explanation, reply below and I\\'ll send the video link. \\nThank you!\\n",
                "solutionTags": [],
                "code": "```\\n\\tprivate static final long MAX_SUFFIX = 1000000000000L;\\n    private static final int MAX_PREFIX = 100000;\\n    \\n    public String abbreviateProduct(int left, int right) {\\n        long product = 1;\\n        int trailingZeros = 0;\\n        double prefix = 1.0;\\n        \\n        for (int num = left; num <= right; num++) {\\n            product *= num;\\n            while (product % 10 == 0) {\\n                product /= 10;\\n                trailingZeros++;\\n            }\\n            \\n            if (product >= MAX_SUFFIX) {\\n                product %= MAX_SUFFIX;\\n            }\\n            \\n            prefix *= num;\\n            \\n            while (prefix >= MAX_PREFIX) {\\n                prefix /= 10;\\n            }\\n        }\\n        return buildAbbreviation(prefix, product, trailingZeros);\\n    }\\n    \\n    private String buildAbbreviation(double prefix, long product, int trailingZeros) {\\n        String suffix = String.valueOf(product);\\n        if (suffix.length() > 10) {\\n            suffix = (int)prefix + \"...\" + suffix.substring(suffix.length() - 5);\\n        }\\n        \\n        return String.format(\"%se%d\", suffix, trailingZeros);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1660150,
                "title": "python-easy-to-read",
                "content": "\\n```\\ndef abbreviateProduct(self, left: int, right: int) -> str:\\n\\tpre, suf, cnt = 1, 1, 0\\n\\tthreshold, pre_precision, suf_precision = int(1e14), int(1e5), (1e10)\\n\\n\\tfor num in range(left, right + 1):\\n\\t\\tpre *= num\\n\\t\\tsuf *= num\\n\\n\\t\\twhile pre >= pre_precision:\\n\\t\\t\\tpre /= 10\\n\\n\\t\\twhile suf % 10 == 0:\\n\\t\\t\\tsuf //= 10\\n\\t\\t\\tcnt += 1\\n\\n\\t\\tsuf %= threshold\\n\\n\\tif suf // suf_precision == 0:\\n\\t\\treturn f\"{suf}e{cnt}\"\\n\\telse:\\n\\t\\treturn f\"{int(pre)}...{suf % pre_precision:05}e{cnt}\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef abbreviateProduct(self, left: int, right: int) -> str:\\n\\tpre, suf, cnt = 1, 1, 0\\n\\tthreshold, pre_precision, suf_precision = int(1e14), int(1e5), (1e10)\\n\\n\\tfor num in range(left, right + 1):\\n\\t\\tpre *= num\\n\\t\\tsuf *= num\\n\\n\\t\\twhile pre >= pre_precision:\\n\\t\\t\\tpre /= 10\\n\\n\\t\\twhile suf % 10 == 0:\\n\\t\\t\\tsuf //= 10\\n\\t\\t\\tcnt += 1\\n\\n\\t\\tsuf %= threshold\\n\\n\\tif suf // suf_precision == 0:\\n\\t\\treturn f\"{suf}e{cnt}\"\\n\\telse:\\n\\t\\treturn f\"{int(pre)}...{suf % pre_precision:05}e{cnt}\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1656189,
                "title": "brute-force-approach-python3-accepted-commented",
                "content": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        ans = 1                                                                  //Initialise the product with 1\\n        while left <= right:                                               // Start the multiplying numbers in\\n            if left == right:                                                 // Exception case when left is right else the number will be multiplied 2 times\\n                ans *= left                                                   //then only multiply either left or right\\n            else:\\n                ans *= left * right                                        // Else multiply left and right numbers and multiply with ans\\n            left += 1                                                         // Increment left by one\\n            right -= 1                                                        //Decrement right by 1\\n        count = 0                                                           // Initialise count of trailing zeroes\\n        ans = str(ans)                                                    // Converting integer to string\\n        i = len(ans) - 1                                                  // Start the pointer with end of string\\n        while i >= 0 and ans[i] == \\'0\\':                          // Decrement pointer by one while the value at pointer is 0\\n            count += 1                                                   //and increase the count of trailing zeroes\\n            i -= 1\\n        fans = \\'\\'                                                            //Empty string which will store the number without the trailing zeroes\\n        for j in range(i+1):                                            // will use the i pointer which stored the last location of the trailing zero\\n            fans += ans[j]                                              //store each character until the trailing zero isn\\'t reached\\n        final = \\'\\'                                                           //Final ans which will give the required result \\n        if len(fans) > 10:                                              //If the length of the number without the trailing zeroes has a length greater than 10\\n            temp1 = \\'\\'                                                   //Will store the first 5 character of the number\\n            for j in range(5):                                          // Adding the first 5 characters\\n                temp1 += fans[j]\\n            temp2 = \\'\\'                                                   //Will store the last 5 characters of the number\\n            for j in range(-5,0):                                      // Add the last 5 characters\\n                temp2 += fans[j]\\n            final = temp1 + \\'...\\' + temp2 + \\'e\\' + str(count)           //Final ans with first 5 character, last 5 characters + e + count of trailing zeroes\\n        else:                                                                    //If length of the number is less than 10\\n            final = fans + \\'e\\' + str(count)                         // Final ans with number without trailing zeroes + e + count of trailing zeroes\\n        return final                                                      //Return the final string\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        ans = 1                                                                  //Initialise the product with 1\\n        while left <= right:                                               // Start the multiplying numbers in\\n            if left == right:                                                 // Exception case when left is right else the number will be multiplied 2 times\\n                ans *= left                                                   //then only multiply either left or right\\n            else:\\n                ans *= left * right                                        // Else multiply left and right numbers and multiply with ans\\n            left += 1                                                         // Increment left by one\\n            right -= 1                                                        //Decrement right by 1\\n        count = 0                                                           // Initialise count of trailing zeroes\\n        ans = str(ans)                                                    // Converting integer to string\\n        i = len(ans) - 1                                                  // Start the pointer with end of string\\n        while i >= 0 and ans[i] == \\'0\\':                          // Decrement pointer by one while the value at pointer is 0\\n            count += 1                                                   //and increase the count of trailing zeroes\\n            i -= 1\\n        fans = \\'\\'                                                            //Empty string which will store the number without the trailing zeroes\\n        for j in range(i+1):                                            // will use the i pointer which stored the last location of the trailing zero\\n            fans += ans[j]                                              //store each character until the trailing zero isn\\'t reached\\n        final = \\'\\'                                                           //Final ans which will give the required result \\n        if len(fans) > 10:                                              //If the length of the number without the trailing zeroes has a length greater than 10\\n            temp1 = \\'\\'                                                   //Will store the first 5 character of the number\\n            for j in range(5):                                          // Adding the first 5 characters\\n                temp1 += fans[j]\\n            temp2 = \\'\\'                                                   //Will store the last 5 characters of the number\\n            for j in range(-5,0):                                      // Add the last 5 characters\\n                temp2 += fans[j]\\n            final = temp1 + \\'...\\' + temp2 + \\'e\\' + str(count)           //Final ans with first 5 character, last 5 characters + e + count of trailing zeroes\\n        else:                                                                    //If length of the number is less than 10\\n            final = fans + \\'e\\' + str(count)                         // Final ans with number without trailing zeroes + e + count of trailing zeroes\\n        return final                                                      //Return the final string\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652926,
                "title": "python-3-math-solution-that-follows-hints",
                "content": "Hints followed\\n\\n```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        # hints followed\\n        left = max(2, left)\\n        mod = 10 ** 5\\n        p = 1 # 10**5 modulo of the product to represent the lowest 5 digits\\n        lg = 0 # cumulates log10 of each number left to right, for the highest 5 digits\\n        c2 = 0 # occurrences of prime factor 2\\n        c5 = 0 # occurrences of prime factor 5\\n        \\n        for i in range(left, right + 1):\\n            lg += log10(i)\\n            while i > 1 and not (i % 2):\\n                c2 += 1\\n                i //= 2\\n            while i > 1 and not (i % 5):\\n                c5 += 1\\n                i //= 5\\n            p *= i\\n            if p > mod:\\n                p %= mod\\n        \\n        e = min(c2, c5)\\n        es = \\'e\\' + str(e)\\n        c2 -= e\\n        c5 -= e\\n        if not c2:\\n            p *= pow(5, c5, mod)\\n        else:\\n            p *= pow(2, c2, mod)\\n        if p > mod:\\n            p %= mod\\n        ps = str(p)\\n        \\n        lg = lg - e\\n        if lg <= 5:\\n            return ps + es\\n        \\n        # more than 5 digits to display, fill ps with leading 0s as need\\n        if len(ps) < 5:\\n            ps = \\'0\\' * (5 - len(ps)) + ps\\n        \\n        # digits to display <= 10\\n        lg -= 5\\n        if lg < 5:\\n            return str(10**lg)[:ceil(lg)] + ps + es\\n        \\n        # digits to display > 10, abbreviate the middle\\n        lg -= (ceil(lg) - 5)\\n        return str(10**lg)[:5] + \\'...\\' + ps + es\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        # hints followed\\n        left = max(2, left)\\n        mod = 10 ** 5\\n        p = 1 # 10**5 modulo of the product to represent the lowest 5 digits\\n        lg = 0 # cumulates log10 of each number left to right, for the highest 5 digits\\n        c2 = 0 # occurrences of prime factor 2\\n        c5 = 0 # occurrences of prime factor 5\\n        \\n        for i in range(left, right + 1):\\n            lg += log10(i)\\n            while i > 1 and not (i % 2):\\n                c2 += 1\\n                i //= 2\\n            while i > 1 and not (i % 5):\\n                c5 += 1\\n                i //= 5\\n            p *= i\\n            if p > mod:\\n                p %= mod\\n        \\n        e = min(c2, c5)\\n        es = \\'e\\' + str(e)\\n        c2 -= e\\n        c5 -= e\\n        if not c2:\\n            p *= pow(5, c5, mod)\\n        else:\\n            p *= pow(2, c2, mod)\\n        if p > mod:\\n            p %= mod\\n        ps = str(p)\\n        \\n        lg = lg - e\\n        if lg <= 5:\\n            return ps + es\\n        \\n        # more than 5 digits to display, fill ps with leading 0s as need\\n        if len(ps) < 5:\\n            ps = \\'0\\' * (5 - len(ps)) + ps\\n        \\n        # digits to display <= 10\\n        lg -= 5\\n        if lg < 5:\\n            return str(10**lg)[:ceil(lg)] + ps + es\\n        \\n        # digits to display > 10, abbreviate the middle\\n        lg -= (ceil(lg) - 5)\\n        return str(10**lg)[:5] + \\'...\\' + ps + es\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652389,
                "title": "java-handwritten-illustrations-very-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/d7ea6fdf-dfa7-4bcf-8b5a-e7dd6c3eaf2b_1640684899.9220698.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/d7ea6fdf-dfa7-4bcf-8b5a-e7dd6c3eaf2b_1640684899.9220698.png)\\nAny corrections, suggestions or optimizations to code are welcomed. :)\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1650731,
                "title": "java-follow-hints-275ms-two-pass-solution",
                "content": "* Use module to get last 5 digits in first pass\\n* Use log10 to get first 5 digits in second pass\\n\\n```\\nclass Solution {\\n    public String abbreviateProduct(int left, int right) {\\n        int zero = 0;\\n        boolean mod = false;\\n        \\n        long val = 1L;\\n        for (int i = left; i <= right; i++) {\\n            val *= i;\\n            while (val % 10 == 0) {\\n                val /= 10;\\n                zero++;\\n            }\\n            if (val > 10_000_000_000L) {\\n                val %= 10_000_000_000L;\\n                mod = true;\\n            }\\n        }\\n        if (!mod) {\\n            return String.format(\"%de%d\", val, zero);\\n        }\\n        long end = val % 100_000L;\\n        double s = 0.0;\\n        for (int i = left; i <= right; i++) {\\n            s += Math.log10(i);\\n        }\\n        s -= (int)s;\\n        double start = Math.pow(10.0, (s + 4));\\n        return String.format(\"%d...%05de%d\", (int)start, end, zero);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String abbreviateProduct(int left, int right) {\\n        int zero = 0;\\n        boolean mod = false;\\n        \\n        long val = 1L;\\n        for (int i = left; i <= right; i++) {\\n            val *= i;\\n            while (val % 10 == 0) {\\n                val /= 10;\\n                zero++;\\n            }\\n            if (val > 10_000_000_000L) {\\n                val %= 10_000_000_000L;\\n                mod = true;\\n            }\\n        }\\n        if (!mod) {\\n            return String.format(\"%de%d\", val, zero);\\n        }\\n        long end = val % 100_000L;\\n        double s = 0.0;\\n        for (int i = left; i <= right; i++) {\\n            s += Math.log10(i);\\n        }\\n        s -= (int)s;\\n        double start = Math.pow(10.0, (s + 4));\\n        return String.format(\"%d...%05de%d\", (int)start, end, zero);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647225,
                "title": "c-solution",
                "content": "```\\npublic:\\n    int calcBas(int x, int y, int bas){\\n        int ret = 0;\\n        -- x;\\n        while(x)\\n            ret -= (x /= bas);\\n        while(y)\\n            ret += (y /= bas);\\n        return ret;\\n    }\\n    int calcZeros(int x, int y){\\n        return min(calcBas(x, y, 2), calcBas(x, y, 5));\\n    }\\n    string toFixedString(int x){\\n        string ret = \"\";\\n        for(int i=0; i<5; i++){\\n            ret = (char)((x % 10) + \\'0\\') + ret;\\n            x /= 10;\\n        }\\n        return ret;\\n    }\\n    string abbreviateProduct(int left, int right) {\\n        int Z = calcZeros(left, right);\\n        long long x = 1;\\n        bool sCalc = true;\\n        int eZ = Z, fZ = Z;\\n        for(int i=left; i<=right; i++){\\n            int X = i;\\n            while(X % 2 == 0 && eZ)\\n                X /= 2, -- eZ;\\n            while(X % 5 == 0 && fZ)\\n                X /= 5, -- fZ;\\n            x *= X;\\n            if(x >= 1e10){\\n                sCalc = false;\\n                break;\\n            }\\n        }\\n        if(sCalc)\\n            return to_string(x) + \\'e\\' + to_string(Z);\\n        long long las = 1;\\n        eZ = Z, fZ = Z;\\n        for(int i=left; i<=right; i++){\\n            int X = i;\\n            while(X % 2 == 0 && eZ)\\n                X /= 2, -- eZ;\\n            while(X % 5 == 0 && fZ)\\n                X /= 5, -- fZ;\\n            las *= X;\\n            las %= 100000;\\n        }\\n        long long fir = 1;\\n        eZ = Z, fZ = Z;\\n        for(int i=left; i<=right; i++){\\n            int X = i;\\n            while(X % 2 == 0 && eZ)\\n                X /= 2, -- eZ;\\n            while(X % 5 == 0 && fZ)\\n                X /= 5, -- fZ;\\n            fir *= X;\\n            while(fir >= 1e12)\\n                fir /= 10;\\n        }\\n        while(fir >= 1e5)\\n            fir /= 10;\\n        return to_string(fir) + \"...\" + toFixedString(las) + \\'e\\' + to_string(Z);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    int calcBas(int x, int y, int bas){\\n        int ret = 0;\\n        -- x;\\n        while(x)\\n            ret -= (x /= bas);\\n        while(y)\\n            ret += (y /= bas);\\n        return ret;\\n    }\\n    int calcZeros(int x, int y){\\n        return min(calcBas(x, y, 2), calcBas(x, y, 5));\\n    }\\n    string toFixedString(int x){\\n        string ret = \"\";\\n        for(int i=0; i<5; i++){\\n            ret = (char)((x % 10) + \\'0\\') + ret;\\n            x /= 10;\\n        }\\n        return ret;\\n    }\\n    string abbreviateProduct(int left, int right) {\\n        int Z = calcZeros(left, right);\\n        long long x = 1;\\n        bool sCalc = true;\\n        int eZ = Z, fZ = Z;\\n        for(int i=left; i<=right; i++){\\n            int X = i;\\n            while(X % 2 == 0 && eZ)\\n                X /= 2, -- eZ;\\n            while(X % 5 == 0 && fZ)\\n                X /= 5, -- fZ;\\n            x *= X;\\n            if(x >= 1e10){\\n                sCalc = false;\\n                break;\\n            }\\n        }\\n        if(sCalc)\\n            return to_string(x) + \\'e\\' + to_string(Z);\\n        long long las = 1;\\n        eZ = Z, fZ = Z;\\n        for(int i=left; i<=right; i++){\\n            int X = i;\\n            while(X % 2 == 0 && eZ)\\n                X /= 2, -- eZ;\\n            while(X % 5 == 0 && fZ)\\n                X /= 5, -- fZ;\\n            las *= X;\\n            las %= 100000;\\n        }\\n        long long fir = 1;\\n        eZ = Z, fZ = Z;\\n        for(int i=left; i<=right; i++){\\n            int X = i;\\n            while(X % 2 == 0 && eZ)\\n                X /= 2, -- eZ;\\n            while(X % 5 == 0 && fZ)\\n                X /= 5, -- fZ;\\n            fir *= X;\\n            while(fir >= 1e12)\\n                fir /= 10;\\n        }\\n        while(fir >= 1e5)\\n            fir /= 10;\\n        return to_string(fir) + \"...\" + toFixedString(las) + \\'e\\' + to_string(Z);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1567707,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "The first few digits should be 39118000000000236, but the standard solution outputs 39117.\\n\\nAbout error analysis, and how this data is generated: (in chinese)\\nhttps://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/yi-ge-shu-ju-tuan-mie-jue-da-bu-fen-dai-234yd/"
                    },
                    {
                        "username": "brinuke",
                        "content": "You forgot to mention the input."
                    },
                    {
                        "username": "brinuke",
                        "content": "### Here are the most interesting testcases:\n|Left|Right|Correct Answer|\n|---|---|---|\n|621|625|\"9385007814e4\"|\n|1385|5673|\"46222...39296e1071\"|\n|2230|5489|\"34409...70144e814\"|\n|4838|6186|\"36088...36896e337\"|\n|5451|7344|\"36274...84768e472\"|\n|2031|9331|\"53724...52896e1823\"|"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "if you are getting below error\\nValueError: Exceeds the limit (4300) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit\\n\\nuse below code in very beginning of your code\\nimport sys\\nsys.set_int_max_str_digits(0)\\n\\nHope this helps"
                    },
                    {
                        "username": "s1ttu",
                        "content": "summ = str(prod(list(range(left, right+1))))\\n        su = summ.rstrip(\"0\")\\n        zeros = len(summ)-len(su)\\n        if len(su)<=10: return (su+\"e\"+str(zeros))\\n        else: return (su[:5]+\"...\"+su[-5:]+\"e\"+str(zeros))\\n\\ncomplete explanation in this link https://leetcode.com/problems/abbreviating-the-product-of-a-range/solutions/2992831/simple-5-line-python-solution-beats-100-5-line-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1919450,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "The first few digits should be 39118000000000236, but the standard solution outputs 39117.\\n\\nAbout error analysis, and how this data is generated: (in chinese)\\nhttps://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/yi-ge-shu-ju-tuan-mie-jue-da-bu-fen-dai-234yd/"
                    },
                    {
                        "username": "brinuke",
                        "content": "You forgot to mention the input."
                    },
                    {
                        "username": "brinuke",
                        "content": "### Here are the most interesting testcases:\n|Left|Right|Correct Answer|\n|---|---|---|\n|621|625|\"9385007814e4\"|\n|1385|5673|\"46222...39296e1071\"|\n|2230|5489|\"34409...70144e814\"|\n|4838|6186|\"36088...36896e337\"|\n|5451|7344|\"36274...84768e472\"|\n|2031|9331|\"53724...52896e1823\"|"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "if you are getting below error\\nValueError: Exceeds the limit (4300) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit\\n\\nuse below code in very beginning of your code\\nimport sys\\nsys.set_int_max_str_digits(0)\\n\\nHope this helps"
                    },
                    {
                        "username": "s1ttu",
                        "content": "summ = str(prod(list(range(left, right+1))))\\n        su = summ.rstrip(\"0\")\\n        zeros = len(summ)-len(su)\\n        if len(su)<=10: return (su+\"e\"+str(zeros))\\n        else: return (su[:5]+\"...\"+su[-5:]+\"e\"+str(zeros))\\n\\ncomplete explanation in this link https://leetcode.com/problems/abbreviating-the-product-of-a-range/solutions/2992831/simple-5-line-python-solution-beats-100-5-line-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1905889,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "The first few digits should be 39118000000000236, but the standard solution outputs 39117.\\n\\nAbout error analysis, and how this data is generated: (in chinese)\\nhttps://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/yi-ge-shu-ju-tuan-mie-jue-da-bu-fen-dai-234yd/"
                    },
                    {
                        "username": "brinuke",
                        "content": "You forgot to mention the input."
                    },
                    {
                        "username": "brinuke",
                        "content": "### Here are the most interesting testcases:\n|Left|Right|Correct Answer|\n|---|---|---|\n|621|625|\"9385007814e4\"|\n|1385|5673|\"46222...39296e1071\"|\n|2230|5489|\"34409...70144e814\"|\n|4838|6186|\"36088...36896e337\"|\n|5451|7344|\"36274...84768e472\"|\n|2031|9331|\"53724...52896e1823\"|"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "if you are getting below error\\nValueError: Exceeds the limit (4300) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit\\n\\nuse below code in very beginning of your code\\nimport sys\\nsys.set_int_max_str_digits(0)\\n\\nHope this helps"
                    },
                    {
                        "username": "s1ttu",
                        "content": "summ = str(prod(list(range(left, right+1))))\\n        su = summ.rstrip(\"0\")\\n        zeros = len(summ)-len(su)\\n        if len(su)<=10: return (su+\"e\"+str(zeros))\\n        else: return (su[:5]+\"...\"+su[-5:]+\"e\"+str(zeros))\\n\\ncomplete explanation in this link https://leetcode.com/problems/abbreviating-the-product-of-a-range/solutions/2992831/simple-5-line-python-solution-beats-100-5-line-solution-beats-100/"
                    }
                ]
            },
            {
                "id": 1784657,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "The first few digits should be 39118000000000236, but the standard solution outputs 39117.\\n\\nAbout error analysis, and how this data is generated: (in chinese)\\nhttps://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/yi-ge-shu-ju-tuan-mie-jue-da-bu-fen-dai-234yd/"
                    },
                    {
                        "username": "brinuke",
                        "content": "You forgot to mention the input."
                    },
                    {
                        "username": "brinuke",
                        "content": "### Here are the most interesting testcases:\n|Left|Right|Correct Answer|\n|---|---|---|\n|621|625|\"9385007814e4\"|\n|1385|5673|\"46222...39296e1071\"|\n|2230|5489|\"34409...70144e814\"|\n|4838|6186|\"36088...36896e337\"|\n|5451|7344|\"36274...84768e472\"|\n|2031|9331|\"53724...52896e1823\"|"
                    },
                    {
                        "username": "ItiSingh",
                        "content": "if you are getting below error\\nValueError: Exceeds the limit (4300) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit\\n\\nuse below code in very beginning of your code\\nimport sys\\nsys.set_int_max_str_digits(0)\\n\\nHope this helps"
                    },
                    {
                        "username": "s1ttu",
                        "content": "summ = str(prod(list(range(left, right+1))))\\n        su = summ.rstrip(\"0\")\\n        zeros = len(summ)-len(su)\\n        if len(su)<=10: return (su+\"e\"+str(zeros))\\n        else: return (su[:5]+\"...\"+su[-5:]+\"e\"+str(zeros))\\n\\ncomplete explanation in this link https://leetcode.com/problems/abbreviating-the-product-of-a-range/solutions/2992831/simple-5-line-python-solution-beats-100-5-line-solution-beats-100/"
                    }
                ]
            }
        ]
    }
]