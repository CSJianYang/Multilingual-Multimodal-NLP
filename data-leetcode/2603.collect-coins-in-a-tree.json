[
    {
        "title": "Collect Coins in a Tree",
        "question_content": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given an integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given&nbsp;an array coins of size n where coins[i] can be either 0 or 1, where 1 indicates the presence of a coin in the vertex i.\nInitially, you choose to start at any vertex in&nbsp;the tree.&nbsp;Then, you can perform&nbsp;the following operations any number of times:&nbsp;\n\n\tCollect all the coins that are at a distance of at most 2 from the current vertex, or\n\tMove to any adjacent vertex in the tree.\n\nFind the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex.\nNote that if you pass an edge several times, you need to count it into the answer several times.\n&nbsp;\nExample 1:\n\nInput: coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\nOutput: 2\nExplanation: Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\nExample 2:\n\nInput: coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]\nOutput: 2\nExplanation: Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n\n&nbsp;\nConstraints:\n\n\tn == coins.length\n\t1 <= n <= 3 * 104\n\t0 <= coins[i] <= 1\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t0 <= ai, bi < n\n\tai != bi\n\tedges represents a valid tree.",
        "solutions": [
            {
                "id": 3343497,
                "title": "easy-bfs-intuition-explained-o-n-tc-and-sc-trim-c-java",
                "content": "# Intuition\\nsince we have to come back to the same point hence the starting point doesn\\'t matter!we anyway would be going over all the edges. \\nBut do all the nodes matter? can we prune some of the edges and nodes to make the tree shorter and reduce the overall path? leaf nodes which don\\'t have a coin are useless!\\nBut do I need to traverse the remaining tree? No! let\\'s say now in your tree all the leafs actually contain coins; you can gather these coins from the grandparent (parent of parent of the leaf) since the coins from nodes upto a distance 2 can be directly achieved.\\n\\n\\n# Approach\\nSince the non coin leaves are useless, let\\'s prune them recursivey (delete the edge cononecting leaf to it\\'s parent, if now the parent has only 1 edge connected then the parent also becomes a leaf, if the parent doesn\\'t have a coin on it then it also is useleess so remove it).\\nNow in the remaining tree remove 2 nodes for each leaf (for the logic as stated in the intuition!)\\nNow in this entire process you must have deleted several edges. so you\\'ll be left with some edges. the answer is the number of edges we are left with! \\nNOTE-> since I considered a->b and b->a as 2 different edges hence I need to multiply it by 2 so as to imitate coming back to the origin node!\\n\\nThe code has been populated with several comments for convenience! \\n\\n# Complexity\\n- Time complexity: o(n)\\n\\n- Space complexity: o(n)\\n\\n# Code C++\\n```\\nclass Solution {\\n    public:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n\\n        int n=coins.size();\\n        vector<set<int>> g(n);\\n        \\n        for(auto& e:edges)  g[e[0]].insert(e[1]),g[e[1]].insert(e[0]);\\n        queue<int> leaves;\\n\\n        int totalEdges=edges.size()*2,deleted=0;\\n        // let\\'s add the leaves which don\\'t have any coins!\\n        \\n        for(int i=0;i<n;i++)    if(g[i].size()==1 && coins[i]==0)  leaves.push(i);\\n\\n        while(leaves.size()){   // keep removing leaves with no coins!\\n            int leaf=leaves.front();\\n            leaves.pop();\\n            if(g[leaf].empty()) continue;// this not has no parent! [last node of the tree]\\n\\n            int p=*g[leaf].begin();     // parent\\n            \\n            g[p].erase(leaf),deleted++;\\n            g[leaf].erase(p),deleted++;        // clear the entire mappings for it as it\\'s useless now!\\n            \\n            if(g[p].size()==1 && coins[p]==0)   leaves.push(p); // if this now becomes a leaf with no coins. \\n        }\\n        // now the leaves would be having the coin! \\n        for(int i=0;i<n;i++)    if(g[i].size()==1)  leaves.push(i);\\n        // now I need to remove the leaf nodes and their immediate parents\\n        int step=2; //1 for parent and 1 for children\\n        while(step--){\\n            int sz=leaves.size();\\n            while(sz--){\\n                int leaf=leaves.front();\\n                leaves.pop();\\n                if(!g[leaf].size()) continue;// this not has no parent! [last node of the tree]\\n                \\n                int p=*g[leaf].begin();     // only parent would be there in leaf!\\n                \\n                g[p].erase(leaf),deleted++;\\n                g[leaf].erase(p),deleted++;\\n\\n                if(g[p].size()==1)  leaves.push(p);\\n            \\n            }\\n        }\\n        \\n        return totalEdges-deleted;\\n    }\\n};\\n```\\n\\n# Code Java\\n```\\nclass Solution {\\npublic int collectTheCoins(int[] coins, int[][] edges) {\\n\\n    int n = edges.length;\\n    ArrayList<HashSet<Integer>> list = new ArrayList<>();\\n    Queue<Integer> q = new LinkedList<>();\\n    int totalEdges = 2*n;\\n    int deletedEdges = 0;\\n\\n    for(int i=0;i<=n;i++){\\n        list.add(new HashSet<Integer>());\\n    }\\n\\n    for(int i=0;i<n;i++){\\n        int a = edges[i][0];\\n        int b = edges[i][1];\\n        list.get(a).add(b);\\n        list.get(b).add(a);\\n    }\\n\\n    for(int i=0;i<=n;i++){\\n        if(list.get(i).size()==1 && coins[i]==0){\\n            q.add(i);\\n        }\\n    }\\n    while(!q.isEmpty()){\\n        int cur = q.remove();\\n        if(list.get(cur).size()==0) continue;\\n        int p = list.get(cur).iterator().next();\\n        list.get(cur).remove(p);\\n        list.get(p).remove(cur);\\n        if(list.get(p).size()==1 && coins[p]==0){\\n            q.add(p);\\n        }\\n        deletedEdges += 2;\\n    }\\n\\n    for(int i=0;i<=n;i++){\\n        if(list.get(i).size()==1){\\n            q.add(i);\\n        }\\n    }\\n\\n    int size=2;\\n    while(size>0){\\n        size--;\\n        int qsize = q.size();\\n        while(qsize>0){\\n            qsize--;\\n            int cur = q.remove();\\n            if(list.get(cur).size()==0) continue;\\n            int p = list.get(cur).iterator().next();\\n            list.get(cur).remove(p);\\n            list.get(p).remove(cur);\\n            if(list.get(p).size()==1){\\n                q.add(p);\\n            }\\n            deletedEdges += 2;\\n        }\\n    }\\n\\n    return totalEdges - deletedEdges;\\n}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n\\n        int n=coins.size();\\n        vector<set<int>> g(n);\\n        \\n        for(auto& e:edges)  g[e[0]].insert(e[1]),g[e[1]].insert(e[0]);\\n        queue<int> leaves;\\n\\n        int totalEdges=edges.size()*2,deleted=0;\\n        // let\\'s add the leaves which don\\'t have any coins!\\n        \\n        for(int i=0;i<n;i++)    if(g[i].size()==1 && coins[i]==0)  leaves.push(i);\\n\\n        while(leaves.size()){   // keep removing leaves with no coins!\\n            int leaf=leaves.front();\\n            leaves.pop();\\n            if(g[leaf].empty()) continue;// this not has no parent! [last node of the tree]\\n\\n            int p=*g[leaf].begin();     // parent\\n            \\n            g[p].erase(leaf),deleted++;\\n            g[leaf].erase(p),deleted++;        // clear the entire mappings for it as it\\'s useless now!\\n            \\n            if(g[p].size()==1 && coins[p]==0)   leaves.push(p); // if this now becomes a leaf with no coins. \\n        }\\n        // now the leaves would be having the coin! \\n        for(int i=0;i<n;i++)    if(g[i].size()==1)  leaves.push(i);\\n        // now I need to remove the leaf nodes and their immediate parents\\n        int step=2; //1 for parent and 1 for children\\n        while(step--){\\n            int sz=leaves.size();\\n            while(sz--){\\n                int leaf=leaves.front();\\n                leaves.pop();\\n                if(!g[leaf].size()) continue;// this not has no parent! [last node of the tree]\\n                \\n                int p=*g[leaf].begin();     // only parent would be there in leaf!\\n                \\n                g[p].erase(leaf),deleted++;\\n                g[leaf].erase(p),deleted++;\\n\\n                if(g[p].size()==1)  leaves.push(p);\\n            \\n            }\\n        }\\n        \\n        return totalEdges-deleted;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic int collectTheCoins(int[] coins, int[][] edges) {\\n\\n    int n = edges.length;\\n    ArrayList<HashSet<Integer>> list = new ArrayList<>();\\n    Queue<Integer> q = new LinkedList<>();\\n    int totalEdges = 2*n;\\n    int deletedEdges = 0;\\n\\n    for(int i=0;i<=n;i++){\\n        list.add(new HashSet<Integer>());\\n    }\\n\\n    for(int i=0;i<n;i++){\\n        int a = edges[i][0];\\n        int b = edges[i][1];\\n        list.get(a).add(b);\\n        list.get(b).add(a);\\n    }\\n\\n    for(int i=0;i<=n;i++){\\n        if(list.get(i).size()==1 && coins[i]==0){\\n            q.add(i);\\n        }\\n    }\\n    while(!q.isEmpty()){\\n        int cur = q.remove();\\n        if(list.get(cur).size()==0) continue;\\n        int p = list.get(cur).iterator().next();\\n        list.get(cur).remove(p);\\n        list.get(p).remove(cur);\\n        if(list.get(p).size()==1 && coins[p]==0){\\n            q.add(p);\\n        }\\n        deletedEdges += 2;\\n    }\\n\\n    for(int i=0;i<=n;i++){\\n        if(list.get(i).size()==1){\\n            q.add(i);\\n        }\\n    }\\n\\n    int size=2;\\n    while(size>0){\\n        size--;\\n        int qsize = q.size();\\n        while(qsize>0){\\n            qsize--;\\n            int cur = q.remove();\\n            if(list.get(cur).size()==0) continue;\\n            int p = list.get(cur).iterator().next();\\n            list.get(cur).remove(p);\\n            list.get(p).remove(cur);\\n            if(list.get(p).size()==1){\\n                q.add(p);\\n            }\\n            deletedEdges += 2;\\n        }\\n    }\\n\\n    return totalEdges - deletedEdges;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345266,
                "title": "trim-leaves",
                "content": "We can trim leaves from the tree using BFS. We trim all leaves before trimming a branch, using counter `cnt` to track remaining edges.\\n\\nIf a branch does not have coins, we can trim it freely (gray edges).\\n\\nHowever, once we see a coin for the first time, we can trim up to 2 levels of leaves (red edges).\\n\\n![image](https://assets.leetcode.com/users/images/8286aa81-245b-4eed-b74e-483371156b9e_1679861691.230126.png)\\n\\nIn the end, we will have a subtree that we cannot trim anymore, containing `m` nodes.\\n\\nBecause it\\'s a tree (and not a graph), this subtree will have `m - 1` edges (green in the picture above).\\n\\nIt does not matter how we choose a starting node - it will take `2 * (m - 1)` steps to visit all nodes and get back.\\n\\n**C++**\\n```cpp\\nint collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n    int sz = coins.size();\\n    vector<vector<int>> al(sz);\\n    for (const auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    vector<int> cnt(sz), steps(sz, 30000), q;\\n    for (int i = 0; i < sz; ++i) {\\n        cnt[i] = al[i].size();\\n        if (cnt[i] == 1)\\n            q.push_back(i);\\n    }\\n    while (!q.empty()) {\\n        auto i = q.back(); q.pop_back();\\n        if (--steps[i]) {\\n            --sz;\\n            for (int j : al[i]) {\\n                steps[j] = min(steps[j], min(steps[i], coins[i] ? 2 : 30000));\\n                if (--cnt[j] == 1)\\n                    q.push_back(j);\\n            }\\n        }\\n    }\\n    return 2 * max(0, sz - 1);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n    int sz = coins.size();\\n    vector<vector<int>> al(sz);\\n    for (const auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    vector<int> cnt(sz), steps(sz, 30000), q;\\n    for (int i = 0; i < sz; ++i) {\\n        cnt[i] = al[i].size();\\n        if (cnt[i] == 1)\\n            q.push_back(i);\\n    }\\n    while (!q.empty()) {\\n        auto i = q.back(); q.pop_back();\\n        if (--steps[i]) {\\n            --sz;\\n            for (int j : al[i]) {\\n                steps[j] = min(steps[j], min(steps[i], coins[i] ? 2 : 30000));\\n                if (--cnt[j] == 1)\\n                    q.push_back(j);\\n            }\\n        }\\n    }\\n    return 2 * max(0, sz - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3342149,
                "title": "clear-explanation-o-n-c-code",
                "content": "\\n# Approach\\nFirst of all trim the graph. Remove all the leaves with no coins. Repeat this process untill we get a graph with all leaves having coins. This is the graph that needs to be analyzed.\\n\\nNow since we can collect the coins from a distance of 2, We will never have to traverse the edges containing these leaves as a vertex. So transfer the coins to the parents of respective leaves and delete these edges.  \\n\\nNow we have a new graph with new leaves. Here we can only collect points from a distance of 1. Find the number of leaves in this new graph. We will never have to traverse these leaves (similar logic as above). Remove their edges (edges containing the leaves as a vertex). This is the final graph that we will traverse. Every edge will be traversed twice (as we need to come back to the starting position as well). The order of traversal does not matter.\\n\\n\\nKINDLY UPVOTE!!!\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rem(vector<int>& v,int a)  // to remove the edges\\n    {\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]==a)\\n            {\\n                v.erase(v.begin()+i);\\n                return;\\n            }\\n        }\\n    }\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n = coins.size();\\n        int ans=edges.size();\\n        int sum=accumulate(coins.begin(),coins.end(),0);\\n        if(sum<=1)\\n            return 0;\\n        vector<vector<int>> graph(n);\\n        for(auto& e:edges)\\n        {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        vector<int> leaf;     //Stores the leaves\\n        for(int i=0;i<graph.size();i++)\\n        {\\n            if(graph[i].size()!=1)\\n            {\\n                continue;\\n            }\\n            leaf.push_back(i);\\n        }\\n        vector<int> leav;   // Now remove the leaves with no coins and stoer new leaves here\\n        for(auto l:leaf)\\n        {\\n            if(coins[l]>0)\\n            {\\n                leav.push_back(l);\\n                continue;\\n            }\\n            while(coins[l]==0 && graph[l].size()==1)\\n            {\\n                int p=graph[l][0];\\n                rem(graph[l],p);\\n                rem(graph[p],l);\\n                ans--;\\n                l=p;\\n            }\\n            if(graph[l].size()==1)\\n            {\\n                leav.push_back(l);\\n            }\\n        }\\n        leaf=vector<int>();\\n        \\n        \\n        for(auto& l:leav)\\n        {\\n            if(graph[l].size()!=1)\\n                continue;\\n            int p=graph[l][0];\\n            coins[p]=1;\\n            rem(graph[p],l);\\n            rem(graph[l],p);\\n            ans--;\\n            if(graph[p].size()==1)\\n            {\\n                leaf.push_back(p);\\n            }\\n        }\\n        ans-=leaf.size();\\n        ans*=2;\\n        return max(0,ans);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rem(vector<int>& v,int a)  // to remove the edges\\n    {\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]==a)\\n            {\\n                v.erase(v.begin()+i);\\n                return;\\n            }\\n        }\\n    }\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n = coins.size();\\n        int ans=edges.size();\\n        int sum=accumulate(coins.begin(),coins.end(),0);\\n        if(sum<=1)\\n            return 0;\\n        vector<vector<int>> graph(n);\\n        for(auto& e:edges)\\n        {\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        vector<int> leaf;     //Stores the leaves\\n        for(int i=0;i<graph.size();i++)\\n        {\\n            if(graph[i].size()!=1)\\n            {\\n                continue;\\n            }\\n            leaf.push_back(i);\\n        }\\n        vector<int> leav;   // Now remove the leaves with no coins and stoer new leaves here\\n        for(auto l:leaf)\\n        {\\n            if(coins[l]>0)\\n            {\\n                leav.push_back(l);\\n                continue;\\n            }\\n            while(coins[l]==0 && graph[l].size()==1)\\n            {\\n                int p=graph[l][0];\\n                rem(graph[l],p);\\n                rem(graph[p],l);\\n                ans--;\\n                l=p;\\n            }\\n            if(graph[l].size()==1)\\n            {\\n                leav.push_back(l);\\n            }\\n        }\\n        leaf=vector<int>();\\n        \\n        \\n        for(auto& l:leav)\\n        {\\n            if(graph[l].size()!=1)\\n                continue;\\n            int p=graph[l][0];\\n            coins[p]=1;\\n            rem(graph[p],l);\\n            rem(graph[l],p);\\n            ans--;\\n            if(graph[p].size()==1)\\n            {\\n                leaf.push_back(p);\\n            }\\n        }\\n        ans-=leaf.size();\\n        ans*=2;\\n        return max(0,ans);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347482,
                "title": "day-361-100-java-c-python-explained-most-upvoted-meme",
                "content": "![image.png](https://assets.leetcode.com/users/images/a2267944-10b8-41f2-b624-81a67ccea163_1680148646.205976.png)\\n\\n# Please Upvote as it really motivates me\\n![image.png](https://assets.leetcode.com/users/images/c9ef4255-ae69-49be-bed2-088d19be4bf1_1679917454.5568264.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### \\u2022\\tThe goal of this code is to find the minimum number of edges that need to be removed from a given undirected tree such that the resulting graph is a forest (a collection of disjoint trees).\\n\\n##### \\u2022\\tTo achieve this, the code first builds the tree from the given edges by creating an adjacency list representation of the graph.\\n\\n##### \\u2022\\tNext, the code identifies all the leaves of the tree that have zero coins. A leaf node is a node that has only one neighbor. If a node is a leaf and has zero coins, then it is removed from the tree by removing the edge that connects it to its parent node. This process is repeated until all leaf nodes with zero coins are removed from the tree.\\n\\n##### \\u2022\\tAfter removing all such nodes, the tree may still have leaves. The code then removes these leaves one by one, starting with the leaves that are farthest from the root of the tree. The code keeps track of all the leaf nodes that are removed during this process.\\n\\n##### \\u2022\\tFinally, the code counts the number of edges that remain in the tree after all leaf nodes with zero coins and all other leaf nodes have been removed. This count represents the minimum number of edges that need to be removed from the original tree to obtain a forest.\\n\\n##### \\u2022\\tThe intuition behind this algorithm is to identify the nodes that are less valuable (i.e., nodes with zero coins) and remove them first. This helps in reducing the number of edges that need to be removed from the original tree to obtain a forest. After removing the less valuable nodes, the code then removes the remaining leaf nodes one by one, starting with the leaves that are farthest from the root of the tree. This helps in minimizing the number of edges that need to be removed by preserving the structure of the tree as much as possible.\\n\\n\\n# Approach\\n\\nHere is a step-by-step explanation of the approach used in this code:\\n##### 1. Initialize the variables: The code starts by initializing the variables. The variable n represents the number of nodes in the tree (equal to the length of the coins array). The variable tree is an array of Sets, where each element represents the neighbors of a node. The variable leaf is an ArrayList that will be used to store the leaf nodes of the tree.\\n##### 2.\\tBuild the tree from the edges: The input graph is represented as an array of coins and a 2D array of edges. The edges are used to build an adjacency list representation of the graph. This is done by iterating through the edges array and adding the corresponding edges to the tree array.\\n##### 3.\\tFind the leaves with zero coins: A leaf node is a node with only one neighbor. The code iterates through all nodes in the graph and checks if a node has only one neighbor and it has zero coins. If this is the case, the node is removed from the graph by removing the edge connecting it to its neighbor. This process is repeated until all leaf nodes that have zero coins are removed from the graph. The remaining leaf nodes are added to the leaf list.\\n##### 4.\\tRemove the leaves one by one: The code iteratively removes leaf nodes one by one, starting with the leaves that are farthest from the root of the tree. This is done by iterating through the leaf list and checking if a leaf node has only one neighbor. If it does, the node is removed from the graph by removing the edge connecting it to its neighbor. If the neighbor of the removed node is now a leaf node, it is added to a temporary list temp.\\n##### 5.\\tCount the remaining edges in the tree: After removing all leaf nodes, the code counts the number of edges that remain in the graph. This is done by iterating through the tree array and counting the size of each Set (i.e., the number of neighbors of each node). The sum of these sizes represents the minimum number of edges that need to be removed to disconnect the graph and make it into a forest.\\n\\n##### Overall, the approach used in this code is to identify and remove the least valuable nodes (i.e., nodes with zero coins) first, and then iteratively remove the remaining leaf nodes while preserving the structure of the tree as much as possible. This helps in minimizing the number of edges that need to be removed to obtain a forest.\\n\\n\\n\\n# Code\\n```java []\\npublic int collectTheCoins(int[] coins, int[][] edges) {\\n    int n = coins.length; \\n    Set<Integer>[] tree = new HashSet[n]; \\n    for (int i = 0; i < n; ++i) {\\n        tree[i] = new HashSet(); \\n    }\\n    \\n    // Build the tree from the edges\\n    for (int[] e : edges) {\\n        tree[e[0]].add(e[1]); \\n        tree[e[1]].add(e[0]); \\n    }\\n    \\n    // Find the leaves with zero coins\\n    List<Integer> leaf = new ArrayList(); \\n    for (int i = 0; i < n; ++i) {\\n        int u = i; \\n        while (tree[u].size() == 1 && coins[u] == 0) {\\n            int v = tree[u].iterator().next(); \\n            tree[u].remove(v); \\n            tree[v].remove(u); \\n            u = v; \\n        }\\n        if (tree[u].size() == 1) {\\n            leaf.add(u); \\n        }\\n    }\\n    \\n    // Remove the leaves one by one\\n    for (int sz = 2; sz > 0; --sz) {\\n        List<Integer> temp = new ArrayList(); \\n        for (int u : leaf) {\\n            if (tree[u].size() == 1) {\\n                int v = tree[u].iterator().next(); \\n                tree[u].remove(v); \\n                tree[v].remove(u); \\n                if (tree[v].size() == 1) {\\n                    temp.add(v); \\n                }\\n            }\\n        }\\n        leaf = temp; \\n    }\\n    \\n    // Count the remaining edges in the tree\\n    int ans = 0; \\n    for (int i = 0; i < n; ++i) {\\n        ans += tree[i].size(); \\n    }\\n    \\n    return ans; \\n}\\n```\\n```c++ []\\nint collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n    int n = coins.size();\\n    vector<unordered_set<int>> tree(n);\\n    \\n    // Build the tree from the edges\\n    for (auto& e : edges) {\\n        tree[e[0]].insert(e[1]);\\n        tree[e[1]].insert(e[0]);\\n    }\\n    \\n    // Find the leaves with zero coins\\n    vector<int> leaf;\\n    for (int i = 0; i < n; ++i) {\\n        int u = i;\\n        while (tree[u].size() == 1 && coins[u] == 0) {\\n            int v = *(tree[u].begin());\\n            tree[u].erase(v);\\n            tree[v].erase(u);\\n            u = v;\\n        }\\n        if (tree[u].size() == 1) {\\n            leaf.push_back(u);\\n        }\\n    }\\n    \\n    // Remove the leaves one by one\\n    for (int sz = 2; sz > 0; --sz) {\\n        vector<int> temp;\\n        for (int u : leaf) {\\n            if (tree[u].size() == 1) {\\n                int v = *(tree[u].begin());\\n                tree[u].erase(v);\\n                tree[v].erase(u);\\n                if (tree[v].size() == 1) {\\n                    temp.push_back(v);\\n                }\\n            }\\n        }\\n        leaf = temp;\\n    }\\n    \\n    // Count the remaining edges in the tree\\n    int ans = 0;\\n    for (int i = 0; i < n; ++i) {\\n        ans += tree[i].size();\\n    }\\n    \\n    return ans;\\n}\\n```\\n```python []\\ndef collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\\n    n = len(coins)\\n    tree = [set() for _ in range(n)]\\n    \\n    # Build the tree from the edges\\n    for e in edges:\\n        tree[e[0]].add(e[1])\\n        tree[e[1]].add(e[0])\\n    \\n    # Find the leaves with zero coins\\n    leaf = []\\n    for i in range(n):\\n        u = i\\n        while len(tree[u]) == 1 and coins[u] == 0:\\n            v = tree[u].pop()\\n            tree[v].remove(u)\\n            u = v\\n        if len(tree[u]) == 1:\\n            leaf.append(u)\\n    \\n    # Remove the leaves one by one\\n    for sz in range(2, 0, -1):\\n        temp = []\\n        for u in leaf:\\n            if len(tree[u]) == 1:\\n                v = tree[u].pop()\\n                tree[v].remove(u)\\n                if len(tree[v]) == 1:\\n                    temp.append(v)\\n        leaf = temp\\n    \\n    # Count the remaining edges in the tree\\n    ans = 0\\n    for i in range(n):\\n        ans += len(tree[i])\\n    \\n    return ans\\n```\\n\\n# Complexity\\nHere\\'s the time complexity and space complexity analysis of the algorithm:\\n# Time complexity:\\n##### \\u2022\\tBuilding the tree from the edges takes O(N), where N is the number of nodes in the tree.\\n##### \\u2022\\t\\tFinding the leaves with zero coins takes O(N+2E) in the worst case, because we may have to iterate through all nodes and their neighbors multiple times to remove zero-coin leaves.\\n##### \\u2022\\t\\tRemoving the leaves one by one takes O(N), because each leaf is removed only once.\\n##### \\u2022\\t\\tCounting the remaining edges in the tree takes O(N), because we have to iterate through all nodes and their neighbors once.\\nTherefore, the total time complexity of the algorithm is O(N+2E), dominated by the step of finding the leaves with zero coins.\\nSpace complexity:\\n##### \\u2022\\t\\tBuilding the tree array takes O(N) space.\\n##### \\u2022\\t\\tThe leaf list can have up to N elements, so it takes O(N) space.\\n##### \\u2022\\tThe temp list used during leaf removal can also have up to N elements, so it takes O(N) space.\\nTherefore, the total space complexity of the algorithm is O(N).\\nIn summary, the algorithm has quadratic time complexity and linear space complexity.\\n#   UPVOTE PLEASE\\n# 2nd way\\n```java []\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n = coins.length;\\n        List<Integer>[] g = new List[n];\\n        // Initialize adjacency list\\n        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\\n\\n        // create a degree to for topological iteration\\n        int[] deg = new int[n];\\n        for (int[] edge : edges) {\\n            deg[edge[0]]++;\\n            deg[edge[1]]++;\\n            g[edge[0]].add(edge[1]);\\n            g[edge[1]].add(edge[0]);\\n        }\\n\\n        // remove non-coin leaf node first\\n        Queue<Integer> q = new ArrayDeque<>();\\n        for (int i = 0; i < n; i++)\\n            if (deg[i] == 1 && coins[i] == 0)\\n                q.add(i);\\n\\n        // total amount of edges in the graph\\n        int totalEdges = n - 1;\\n        while (!q.isEmpty()) {\\n            // remove the current edge\\n            int d = q.poll();\\n            totalEdges -= 1;\\n            // update neighbor degree\\n            for (int neigh : g[d]) {\\n                deg[neigh]--;\\n                if (deg[neigh] == 1 && coins[neigh] == 0) {\\n                    q.add(neigh);\\n                }\\n            }\\n        }\\n        // we have remove all non-coin leaves, now remove two degree of coins\\n        for (int i = 0; i < n; i++)\\n            if (deg[i] == 1 && coins[i] == 1)\\n                q.add(i);\\n\\n        totalEdges -= q.size();\\n        for (int x : q) for (int neigh : g[x])\\n            if (--deg[neigh] == 1)\\n                totalEdges -= 1;\\n\\n        // we might have negative case if there is no coin, check edge cases\\n        return Math.max(totalEdges * 2, 0);\\n    }\\n\\n}\\n```\\n```python []\\ndef _build_tree(edges: list[list[int]]) -> list[list[int]]:\\n    tree = [[] for _ in range(len(edges) + 1)]\\n\\n    for vertex, adjacent in edges:\\n        tree[vertex].append(adjacent)\\n        tree[adjacent].append(vertex)\\n\\n    return tree\\n\\n\\nclass Solution:\\n    def collectTheCoins(self, coins: list[int], edges: list[list[int]]) -> int:\\n        tree = _build_tree(edges)\\n        degree = list(map(len, tree))\\n\\n        queue = collections.deque()\\n\\n        for vertex in range(len(tree)):\\n            if degree[vertex] == 1:\\n                if coins[vertex]:\\n                    queue.append((vertex, True))\\n                else:\\n                    queue.appendleft((vertex, True))\\n\\n        count_pruned = 0\\n\\n        while queue:\\n            vertex, is_leaf = queue.popleft()\\n            count_pruned += 1\\n\\n            for adjacent in tree[vertex]:\\n                degree[adjacent] -= 1\\n\\n                if is_leaf and degree[adjacent] == 1:\\n                    if coins[vertex]:\\n                        queue.append((adjacent, False))\\n                    elif coins[adjacent]:\\n                        queue.append((adjacent, True))\\n                    else:\\n                        queue.appendleft((adjacent, True))\\n\\n        return 2 * max(0, len(edges) - count_pruned)\\n```\\n```c++ []\\n#ifndef out\\n#define out(...)\\n#endif\\ntemplate<class Tp, class Up = typename std::remove_reference<Tp>::type>\\nconstexpr auto Max(Tp &&a, const Up &b) -> decltype(a < b && (a = b, true)) { return a < b && (a = b, true); }\\n\\nconst int N = 3e4 + 5;\\nstruct Edge {\\n    Edge *next;\\n    int to;\\n} container[N * 2];\\n\\nvoid add(int from, int to, vector<Edge *> &next, int &top) {\\n    next[from] = &(container[top++] = Edge{\\n            .next = next[from],\\n            .to   = to,\\n    });\\n}\\n\\nint dfs1(\\n        int cur, int f, int depth,\\n        const vector<Edge *> &next,\\n        const vector<int> &coins,\\n        int &root) {\\n    int ret = coins[cur] ? depth : -1;\\n    for (auto p = next[cur]; p; p = p->next) {\\n        int to = p->to;\\n        if (to != f) {\\n            Max(ret, dfs1(to, cur, depth + 1, next, coins, root));\\n            if (root >= 0) break;\\n            if (ret >= 0 && ret - depth >= 2) {\\n                root = cur;\\n                break;\\n            }\\n        }\\n    }\\n    return ret;\\n}\\n\\npair<int, int> dfs2(\\n        int cur, int f, int depth,\\n        const vector<Edge *> &next,\\n        const vector<int> &coins) {\\n    int max_depth = coins[cur] ? depth : -1;\\n    int sum = 0;\\n    for (auto p = next[cur]; p; p = p->next) {\\n        int to = p->to;\\n        if (to != f) {\\n            auto [dp, s] = dfs2(to, cur, depth + 1, next, coins);\\n            Max(max_depth, dp);\\n            if (dp >= 0 && dp - depth > 2) {\\n                sum += 1 + s;\\n            }\\n        }\\n    }\\n    return {max_depth, sum};\\n}\\n\\nclass Solution {\\npublic:\\n    static int collectTheCoins(const vector<int> &coins, const vector<vector<int>> &edges) {\\n        size_t n = coins.size();\\n        assert(n == edges.size() + 1);\\n        vector<Edge *> next(n);\\n        int top = 0;\\n        for (auto &&e: edges) {\\n            int x = e[0], y = e[1];\\n            add(x, y, next, top);\\n            add(y, x, next, top);\\n        }\\n        vector<int> mark;\\n        int root = -1;\\n        dfs1(0, -1, 0, next, coins, root);\\n        if (root < 0) return 0;\\n        out(root);\\n        return dfs2(root, -1, 0, next, coins).second * 2;\\n    }\\n};\\n```\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n![meme2.png](https://assets.leetcode.com/users/images/d588f492-3f95-45f6-8e4a-10d6069002a5_1680054021.7117147.png)\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\npublic int collectTheCoins(int[] coins, int[][] edges) {\\n    int n = coins.length; \\n    Set<Integer>[] tree = new HashSet[n]; \\n    for (int i = 0; i < n; ++i) {\\n        tree[i] = new HashSet(); \\n    }\\n    \\n    // Build the tree from the edges\\n    for (int[] e : edges) {\\n        tree[e[0]].add(e[1]); \\n        tree[e[1]].add(e[0]); \\n    }\\n    \\n    // Find the leaves with zero coins\\n    List<Integer> leaf = new ArrayList(); \\n    for (int i = 0; i < n; ++i) {\\n        int u = i; \\n        while (tree[u].size() == 1 && coins[u] == 0) {\\n            int v = tree[u].iterator().next(); \\n            tree[u].remove(v); \\n            tree[v].remove(u); \\n            u = v; \\n        }\\n        if (tree[u].size() == 1) {\\n            leaf.add(u); \\n        }\\n    }\\n    \\n    // Remove the leaves one by one\\n    for (int sz = 2; sz > 0; --sz) {\\n        List<Integer> temp = new ArrayList(); \\n        for (int u : leaf) {\\n            if (tree[u].size() == 1) {\\n                int v = tree[u].iterator().next(); \\n                tree[u].remove(v); \\n                tree[v].remove(u); \\n                if (tree[v].size() == 1) {\\n                    temp.add(v); \\n                }\\n            }\\n        }\\n        leaf = temp; \\n    }\\n    \\n    // Count the remaining edges in the tree\\n    int ans = 0; \\n    for (int i = 0; i < n; ++i) {\\n        ans += tree[i].size(); \\n    }\\n    \\n    return ans; \\n}\\n```\n```c++ []\\nint collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n    int n = coins.size();\\n    vector<unordered_set<int>> tree(n);\\n    \\n    // Build the tree from the edges\\n    for (auto& e : edges) {\\n        tree[e[0]].insert(e[1]);\\n        tree[e[1]].insert(e[0]);\\n    }\\n    \\n    // Find the leaves with zero coins\\n    vector<int> leaf;\\n    for (int i = 0; i < n; ++i) {\\n        int u = i;\\n        while (tree[u].size() == 1 && coins[u] == 0) {\\n            int v = *(tree[u].begin());\\n            tree[u].erase(v);\\n            tree[v].erase(u);\\n            u = v;\\n        }\\n        if (tree[u].size() == 1) {\\n            leaf.push_back(u);\\n        }\\n    }\\n    \\n    // Remove the leaves one by one\\n    for (int sz = 2; sz > 0; --sz) {\\n        vector<int> temp;\\n        for (int u : leaf) {\\n            if (tree[u].size() == 1) {\\n                int v = *(tree[u].begin());\\n                tree[u].erase(v);\\n                tree[v].erase(u);\\n                if (tree[v].size() == 1) {\\n                    temp.push_back(v);\\n                }\\n            }\\n        }\\n        leaf = temp;\\n    }\\n    \\n    // Count the remaining edges in the tree\\n    int ans = 0;\\n    for (int i = 0; i < n; ++i) {\\n        ans += tree[i].size();\\n    }\\n    \\n    return ans;\\n}\\n```\n```python []\\ndef collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\\n    n = len(coins)\\n    tree = [set() for _ in range(n)]\\n    \\n    # Build the tree from the edges\\n    for e in edges:\\n        tree[e[0]].add(e[1])\\n        tree[e[1]].add(e[0])\\n    \\n    # Find the leaves with zero coins\\n    leaf = []\\n    for i in range(n):\\n        u = i\\n        while len(tree[u]) == 1 and coins[u] == 0:\\n            v = tree[u].pop()\\n            tree[v].remove(u)\\n            u = v\\n        if len(tree[u]) == 1:\\n            leaf.append(u)\\n    \\n    # Remove the leaves one by one\\n    for sz in range(2, 0, -1):\\n        temp = []\\n        for u in leaf:\\n            if len(tree[u]) == 1:\\n                v = tree[u].pop()\\n                tree[v].remove(u)\\n                if len(tree[v]) == 1:\\n                    temp.append(v)\\n        leaf = temp\\n    \\n    # Count the remaining edges in the tree\\n    ans = 0\\n    for i in range(n):\\n        ans += len(tree[i])\\n    \\n    return ans\\n```\n```java []\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n = coins.length;\\n        List<Integer>[] g = new List[n];\\n        // Initialize adjacency list\\n        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\\n\\n        // create a degree to for topological iteration\\n        int[] deg = new int[n];\\n        for (int[] edge : edges) {\\n            deg[edge[0]]++;\\n            deg[edge[1]]++;\\n            g[edge[0]].add(edge[1]);\\n            g[edge[1]].add(edge[0]);\\n        }\\n\\n        // remove non-coin leaf node first\\n        Queue<Integer> q = new ArrayDeque<>();\\n        for (int i = 0; i < n; i++)\\n            if (deg[i] == 1 && coins[i] == 0)\\n                q.add(i);\\n\\n        // total amount of edges in the graph\\n        int totalEdges = n - 1;\\n        while (!q.isEmpty()) {\\n            // remove the current edge\\n            int d = q.poll();\\n            totalEdges -= 1;\\n            // update neighbor degree\\n            for (int neigh : g[d]) {\\n                deg[neigh]--;\\n                if (deg[neigh] == 1 && coins[neigh] == 0) {\\n                    q.add(neigh);\\n                }\\n            }\\n        }\\n        // we have remove all non-coin leaves, now remove two degree of coins\\n        for (int i = 0; i < n; i++)\\n            if (deg[i] == 1 && coins[i] == 1)\\n                q.add(i);\\n\\n        totalEdges -= q.size();\\n        for (int x : q) for (int neigh : g[x])\\n            if (--deg[neigh] == 1)\\n                totalEdges -= 1;\\n\\n        // we might have negative case if there is no coin, check edge cases\\n        return Math.max(totalEdges * 2, 0);\\n    }\\n\\n}\\n```\n```python []\\ndef _build_tree(edges: list[list[int]]) -> list[list[int]]:\\n    tree = [[] for _ in range(len(edges) + 1)]\\n\\n    for vertex, adjacent in edges:\\n        tree[vertex].append(adjacent)\\n        tree[adjacent].append(vertex)\\n\\n    return tree\\n\\n\\nclass Solution:\\n    def collectTheCoins(self, coins: list[int], edges: list[list[int]]) -> int:\\n        tree = _build_tree(edges)\\n        degree = list(map(len, tree))\\n\\n        queue = collections.deque()\\n\\n        for vertex in range(len(tree)):\\n            if degree[vertex] == 1:\\n                if coins[vertex]:\\n                    queue.append((vertex, True))\\n                else:\\n                    queue.appendleft((vertex, True))\\n\\n        count_pruned = 0\\n\\n        while queue:\\n            vertex, is_leaf = queue.popleft()\\n            count_pruned += 1\\n\\n            for adjacent in tree[vertex]:\\n                degree[adjacent] -= 1\\n\\n                if is_leaf and degree[adjacent] == 1:\\n                    if coins[vertex]:\\n                        queue.append((adjacent, False))\\n                    elif coins[adjacent]:\\n                        queue.append((adjacent, True))\\n                    else:\\n                        queue.appendleft((adjacent, True))\\n\\n        return 2 * max(0, len(edges) - count_pruned)\\n```\n```c++ []\\n#ifndef out\\n#define out(...)\\n#endif\\ntemplate<class Tp, class Up = typename std::remove_reference<Tp>::type>\\nconstexpr auto Max(Tp &&a, const Up &b) -> decltype(a < b && (a = b, true)) { return a < b && (a = b, true); }\\n\\nconst int N = 3e4 + 5;\\nstruct Edge {\\n    Edge *next;\\n    int to;\\n} container[N * 2];\\n\\nvoid add(int from, int to, vector<Edge *> &next, int &top) {\\n    next[from] = &(container[top++] = Edge{\\n            .next = next[from],\\n            .to   = to,\\n    });\\n}\\n\\nint dfs1(\\n        int cur, int f, int depth,\\n        const vector<Edge *> &next,\\n        const vector<int> &coins,\\n        int &root) {\\n    int ret = coins[cur] ? depth : -1;\\n    for (auto p = next[cur]; p; p = p->next) {\\n        int to = p->to;\\n        if (to != f) {\\n            Max(ret, dfs1(to, cur, depth + 1, next, coins, root));\\n            if (root >= 0) break;\\n            if (ret >= 0 && ret - depth >= 2) {\\n                root = cur;\\n                break;\\n            }\\n        }\\n    }\\n    return ret;\\n}\\n\\npair<int, int> dfs2(\\n        int cur, int f, int depth,\\n        const vector<Edge *> &next,\\n        const vector<int> &coins) {\\n    int max_depth = coins[cur] ? depth : -1;\\n    int sum = 0;\\n    for (auto p = next[cur]; p; p = p->next) {\\n        int to = p->to;\\n        if (to != f) {\\n            auto [dp, s] = dfs2(to, cur, depth + 1, next, coins);\\n            Max(max_depth, dp);\\n            if (dp >= 0 && dp - depth > 2) {\\n                sum += 1 + s;\\n            }\\n        }\\n    }\\n    return {max_depth, sum};\\n}\\n\\nclass Solution {\\npublic:\\n    static int collectTheCoins(const vector<int> &coins, const vector<vector<int>> &edges) {\\n        size_t n = coins.size();\\n        assert(n == edges.size() + 1);\\n        vector<Edge *> next(n);\\n        int top = 0;\\n        for (auto &&e: edges) {\\n            int x = e[0], y = e[1];\\n            add(x, y, next, top);\\n            add(y, x, next, top);\\n        }\\n        vector<int> mark;\\n        int root = -1;\\n        dfs1(0, -1, 0, next, coins, root);\\n        if (root < 0) return 0;\\n        out(root);\\n        return dfs2(root, -1, 0, next, coins).second * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342984,
                "title": "rerooting-explaination",
                "content": "# Approach\\nThe solution has 2 parts - \\n1. Calculating ans from 0 as root\\n2. rerooting the tree\\n\\nPart1- Calculate ans from 0 as root - \\n\\n1. Create 2 arrays coinDistance , where coinDistance[i] denotes maximum distance to the coin containing node in the subtree and coinDistance[i]=-1 denotes absence of any fruit ,  and score where score[i] denotes edges to be travelled when collecting all the coins in the subtree .\\n2.For a node , if the child has no coin in it\\'s subtree , then no need to go to that subtree\\n3. For a node , if the child contains a coin and but distance <2 , no need to go to the subtree , we can collect from the current node itself\\n4. if the child contains a coin and the distance > 2, then we must go to the subtree, therefore we use 2 edges , one to go and other to then comeback from the subtree\\n\\n\\n\\n\\nPart2- Rerooting\\n1. We can now perform rerooting and calculate ans if each node was a root\\n\\n2. While rerooting to a child , check if we were earlier entering entering into the child subtree i.e coindDistance[child]>2 , if yes subtract 2 from the ans as we can no longer enter to that subtree because child is now going to be the parent\\n\\n3. when the child is removed from the subtree of the currentNode , we now need to update the maxCoinDistance of currentNode with the help of firstMax and secondMax\\n\\n4. We now update the score when child becomes the parent of currentNode, we check if maxCoinDistance[currentNode] >2 and if yes we add +2 i.e we enter and the leave the subtree of currentNode when child is the parent\\n\\n5. While updating the ans for each node , minimise the finalAns\\n\\n\\n\\n# Complexity\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic: \\n    vector<int> coinDistance;//maxDistance coin in the substree\\n    vector<int> score;//total edges travelled for the subtree rooted at node i\\n    int finalAns;\\n    void dfs(int node , vector<vector<int> > &adj , int p , vector<int> &coins){\\n        \\n        int maxCoinDistance = (coins[node])?0:-1 ;  //- denotes absence of any coin\\n        int ans=0;\\n        \\n        for(int v:adj[node]){\\n            if(v==p) continue;  //check if not parent\\n            dfs(v,adj,node,coins);//dfs on the child\\n            int distance = coinDistance[v];\\n            if(distance>2) ans+=2; //+2 for going and then coming back\\n            maxCoinDistance = max(maxCoinDistance,distance);//get maxDistance for currentNode\\n            ans += score[v];//update the totalEdgestravelled for current substree\\n        }\\n        \\n        if(maxCoinDistance!=-1) maxCoinDistance++;//if there is a coin , increment the distance for further nodes\\n        coinDistance[node] =maxCoinDistance;//update the maxDistance for currentNode\\n        score[node] = ans;//update the score\\n    }\\n    \\n    void reroot(int node , vector<vector<int> > &adj,int p , vector<int> &coins , int currAns ){\\n        \\n        /*\\n        we need first max and secondMax to get the maximum distance of coin from the currentnode , when we remove the child which we are re rooting to \\n        */\\n        int firstMax = (coins[node])?0:-1 , secondMax = -1;\\n        vector<int> childDistances ;\\n        for(auto v:adj[node]) childDistances.push_back(coinDistance[v]);\\n\\n\\n        for(int distance:childDistances){\\n            if(distance >= firstMax){\\n                secondMax = firstMax;\\n                firstMax = distance;\\n            }else if(distance > secondMax){\\n                secondMax = distance;\\n            }else{}\\n        }\\n    \\n        for(int v:adj[node]){\\n            if(v==p) continue;\\n            //reroot the tree\\n            int newAns = currAns;\\n            //if we were earlier visiting the child, remove those visited edges\\n            if(coinDistance[v]>2) newAns-=2;\\n            \\n            //if the currentChild has maxDistance , then we need to select the secondMax\\n            if(coinDistance[v] == firstMax){\\n                if(secondMax+1 >2) newAns+=2;\\n                coinDistance[node] = (secondMax==-1)?-1:secondMax+1;\\n            }else{\\n                //if the currentChild doesn\\'t have maxDistance select the maxDistance\\n                if(firstMax+1>2) newAns+=2;\\n                coinDistance[node] = (firstMax==-1)?-1:firstMax+1;\\n            }            \\n            \\n            finalAns = min(finalAns,newAns);\\n            reroot(v,adj,node,coins,newAns);\\n\\n        }\\n    }\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n=coins.size();\\n        coinDistance.resize(n);\\n        score.resize(n);\\n        vector<vector<int> > adj(n);\\n        for(auto &edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        dfs(0,adj,-1 , coins);\\n        finalAns = score[0];\\n        reroot(0,adj,-1,coins,finalAns);\\n        return finalAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    vector<int> coinDistance;//maxDistance coin in the substree\\n    vector<int> score;//total edges travelled for the subtree rooted at node i\\n    int finalAns;\\n    void dfs(int node , vector<vector<int> > &adj , int p , vector<int> &coins){\\n        \\n        int maxCoinDistance = (coins[node])?0:-1 ;  //- denotes absence of any coin\\n        int ans=0;\\n        \\n        for(int v:adj[node]){\\n            if(v==p) continue;  //check if not parent\\n            dfs(v,adj,node,coins);//dfs on the child\\n            int distance = coinDistance[v];\\n            if(distance>2) ans+=2; //+2 for going and then coming back\\n            maxCoinDistance = max(maxCoinDistance,distance);//get maxDistance for currentNode\\n            ans += score[v];//update the totalEdgestravelled for current substree\\n        }\\n        \\n        if(maxCoinDistance!=-1) maxCoinDistance++;//if there is a coin , increment the distance for further nodes\\n        coinDistance[node] =maxCoinDistance;//update the maxDistance for currentNode\\n        score[node] = ans;//update the score\\n    }\\n    \\n    void reroot(int node , vector<vector<int> > &adj,int p , vector<int> &coins , int currAns ){\\n        \\n        /*\\n        we need first max and secondMax to get the maximum distance of coin from the currentnode , when we remove the child which we are re rooting to \\n        */\\n        int firstMax = (coins[node])?0:-1 , secondMax = -1;\\n        vector<int> childDistances ;\\n        for(auto v:adj[node]) childDistances.push_back(coinDistance[v]);\\n\\n\\n        for(int distance:childDistances){\\n            if(distance >= firstMax){\\n                secondMax = firstMax;\\n                firstMax = distance;\\n            }else if(distance > secondMax){\\n                secondMax = distance;\\n            }else{}\\n        }\\n    \\n        for(int v:adj[node]){\\n            if(v==p) continue;\\n            //reroot the tree\\n            int newAns = currAns;\\n            //if we were earlier visiting the child, remove those visited edges\\n            if(coinDistance[v]>2) newAns-=2;\\n            \\n            //if the currentChild has maxDistance , then we need to select the secondMax\\n            if(coinDistance[v] == firstMax){\\n                if(secondMax+1 >2) newAns+=2;\\n                coinDistance[node] = (secondMax==-1)?-1:secondMax+1;\\n            }else{\\n                //if the currentChild doesn\\'t have maxDistance select the maxDistance\\n                if(firstMax+1>2) newAns+=2;\\n                coinDistance[node] = (firstMax==-1)?-1:firstMax+1;\\n            }            \\n            \\n            finalAns = min(finalAns,newAns);\\n            reroot(v,adj,node,coins,newAns);\\n\\n        }\\n    }\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n=coins.size();\\n        coinDistance.resize(n);\\n        score.resize(n);\\n        vector<vector<int> > adj(n);\\n        for(auto &edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        dfs(0,adj,-1 , coins);\\n        finalAns = score[0];\\n        reroot(0,adj,-1,coins,finalAns);\\n        return finalAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434365,
                "title": "bfs-c-trimming-nodes-easy-implementation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n To Solve this Question we using `Node Trimming` which is removing all the unnecessary Nodes in the unrooted tree \\n\\n\\n#### So what are Unnecessary Nodes ?\\nA Leaf node that does not have a coin.\\n\\n### How to Solve ?\\n  \\n##### Operation on Leaf Nodes WITHOUT and WITH coins\\n\\n 1. Maintain a count of total Nodes `remainingNode`.\\n 1. Find all the leaf Nodes ( by using Adj List Size ) and store it in a queue `Leaf Node`.\\n 2. Check is that leaf Node has a coin or not ?.\\n    1. If it does store that Node in a separate Queue `leafWithCoins`\\n    2. If it does not => Find the parent of the leaf Node and remove  the edge from parent to child and child to parent where Child is the leaf Node, Now check Again if Parent Has Become a leaf or not if (`parent` == leaf) push parent into the queue of `Leaf Nodes`\\n3. Every time a leaf Node is poped out queue decrement the value of `remainingNode`\\n##### Operation on Leaf Nodes WITH coins\\n    After the above operation we have remove all the unnecessary Node \\n    Here all the leafs are with coins\\n1. Since we can take coins of atmost 2 distance, which means now leaf (with coins) and their parents are unncessary so we have to remove them\\n2. Do a for Loop 2 times and do a `MultiSoure BFS` remove node from Queue `leafWithCoins` and reduce `remainingNode`, which at first iteration remove all the leaf and for the second iteration removes the parent.\\n\\n#### Final Ans\\n Final answer will be `(remainingNode -1)*2` if `remainingNode` is > 0 else `0`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n = coins.size();\\n        vector<vector<int>> adj(n);\\n\\n        // Create adjacency list from edges\\n        for(auto &it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        queue<int> leafWithCoins;\\n        queue<int> q;\\n\\n        // Find all leaf nodes and add them to queue\\n        for(int i = 0;i<n;i++){\\n            if(adj[i].size() == 1){\\n                 q.push(i);\\n            }\\n        }\\n        \\n        int remainingCoins = n;\\n        \\n        // BFS traversal of the graph\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n\\n            // If the node has coins, add it to the queue of nodes with coins\\n            if(coins[node]){\\n                leafWithCoins.push(node);\\n                continue;\\n            }\\n\\n            // If the node does not have coins, delete it and update remaining coins count\\n            remainingCoins--;\\n\\n            // Deleting leaf Node\\n            for(auto &it: adj[node]){\\n                auto parent = find(adj[node].begin(), adj[node].end(), it);\\n                auto child = find(adj[it].begin(), adj[it].end(), node);\\n\\n                adj[it].erase(child);\\n                adj[node].erase(parent);\\n\\n                // If a new leaf node is formed after deleting a node, add it to the queue\\n                if(adj[it].size() == 1){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n\\n        // Deleting leaf with coins\\n\\n        // Perform two passes to delete leaf nodes with coins\\n        for(int i = 0;i<2;i++){\\n            int l = leafWithCoins.size();\\n            while(l--){\\n                int node = leafWithCoins.front();\\n                leafWithCoins.pop();\\n\\n                // Delete the node and update remaining coins count\\n                remainingCoins--;\\n\\n                for(auto &it: adj[node]){\\n                    auto parent = find(adj[node].begin(), adj[node].end(), it);\\n                    auto child = find(adj[it].begin(), adj[it].end(), node);\\n                    adj[it].erase(child);\\n                    adj[node].erase(parent);\\n\\n                    // If a new leaf node is formed after deleting a node, add it to the queue\\n                    if(adj[it].size() == 1){\\n                        leafWithCoins.push(it);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // If all nodes have been deleted, return 0. Otherwise, return the minimum number of steps to collect all coins\\n        return  remainingCoins == 0 ? 0: (remainingCoins-1)*2;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n = coins.size();\\n        vector<vector<int>> adj(n);\\n\\n        // Create adjacency list from edges\\n        for(auto &it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        queue<int> leafWithCoins;\\n        queue<int> q;\\n\\n        // Find all leaf nodes and add them to queue\\n        for(int i = 0;i<n;i++){\\n            if(adj[i].size() == 1){\\n                 q.push(i);\\n            }\\n        }\\n        \\n        int remainingCoins = n;\\n        \\n        // BFS traversal of the graph\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n\\n            // If the node has coins, add it to the queue of nodes with coins\\n            if(coins[node]){\\n                leafWithCoins.push(node);\\n                continue;\\n            }\\n\\n            // If the node does not have coins, delete it and update remaining coins count\\n            remainingCoins--;\\n\\n            // Deleting leaf Node\\n            for(auto &it: adj[node]){\\n                auto parent = find(adj[node].begin(), adj[node].end(), it);\\n                auto child = find(adj[it].begin(), adj[it].end(), node);\\n\\n                adj[it].erase(child);\\n                adj[node].erase(parent);\\n\\n                // If a new leaf node is formed after deleting a node, add it to the queue\\n                if(adj[it].size() == 1){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n\\n        // Deleting leaf with coins\\n\\n        // Perform two passes to delete leaf nodes with coins\\n        for(int i = 0;i<2;i++){\\n            int l = leafWithCoins.size();\\n            while(l--){\\n                int node = leafWithCoins.front();\\n                leafWithCoins.pop();\\n\\n                // Delete the node and update remaining coins count\\n                remainingCoins--;\\n\\n                for(auto &it: adj[node]){\\n                    auto parent = find(adj[node].begin(), adj[node].end(), it);\\n                    auto child = find(adj[it].begin(), adj[it].end(), node);\\n                    adj[it].erase(child);\\n                    adj[node].erase(parent);\\n\\n                    // If a new leaf node is formed after deleting a node, add it to the queue\\n                    if(adj[it].size() == 1){\\n                        leafWithCoins.push(it);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // If all nodes have been deleted, return 0. Otherwise, return the minimum number of steps to collect all coins\\n        return  remainingCoins == 0 ? 0: (remainingCoins-1)*2;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356634,
                "title": "c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) \\n    {\\n        int n=coins.size();\\n        vector<vector<int>>dp(n+1);\\n        vector<int>ind(n,0);\\n        for(auto &it:edges)\\n        {\\n            ind[it[0]]++;\\n            ind[it[1]]++;\\n            dp[it[0]].push_back(it[1]);\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i]==1&&coins[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            for(auto &it:dp[temp])\\n            {\\n                if(ind[it]>=1)\\n                {\\n                    ind[it]--;\\n                    if(ind[it]==1&&coins[it]==0)\\n                    {\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            ind[temp]=0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i]==1&&coins[i]==1)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            for(auto &it:dp[temp])\\n            {\\n                if(ind[it]>=1)\\n                {\\n                    ind[it]--;\\n                    if(ind[it]==1)\\n                    {\\n                        ind[it]=0;\\n                    }\\n                }\\n            }\\n            ind[temp]=0;\\n        }\\n        int count=0;\\n        for(auto &it:edges)\\n        {\\n            if(ind[it[0]]&&ind[it[1]])\\n            {\\n                count++;\\n            }\\n        }\\n        return 2*count;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) \\n    {\\n        int n=coins.size();\\n        vector<vector<int>>dp(n+1);\\n        vector<int>ind(n,0);\\n        for(auto &it:edges)\\n        {\\n            ind[it[0]]++;\\n            ind[it[1]]++;\\n            dp[it[0]].push_back(it[1]);\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        queue<int>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i]==1&&coins[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            for(auto &it:dp[temp])\\n            {\\n                if(ind[it]>=1)\\n                {\\n                    ind[it]--;\\n                    if(ind[it]==1&&coins[it]==0)\\n                    {\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            ind[temp]=0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ind[i]==1&&coins[i]==1)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            for(auto &it:dp[temp])\\n            {\\n                if(ind[it]>=1)\\n                {\\n                    ind[it]--;\\n                    if(ind[it]==1)\\n                    {\\n                        ind[it]=0;\\n                    }\\n                }\\n            }\\n            ind[temp]=0;\\n        }\\n        int count=0;\\n        for(auto &it:edges)\\n        {\\n            if(ind[it[0]]&&ind[it[1]])\\n            {\\n                count++;\\n            }\\n        }\\n        return 2*count;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346183,
                "title": "python-code-with-human-readable-explanation",
                "content": "Here is a step-by-step analysis of the solution:\\n\\n    The solution starts by creating an empty dictionary called g to represent the graph. It then iterates over the input edges, adds each edge to the graph twice (once for each direction), and stores the neighbors of each node in the dictionary. This step correctly constructs an undirected graph from the given edges.\\n\\n    The solution then identifies the leaves of the graph by iterating over all nodes in the graph and selecting those with only one neighbor. It then iteratively removes leaves with no coins until there are no more leaves left, or a non-zero coin leaf is reached.\\n\\n    The second step is repeated twice to handle the case where removing one leaf causes the neighboring node to become a leaf. In this case, the algorithm removes this newly created leaf in the next iteration.\\n\\n    Finally, the number of remaining edges in the graph is calculated and multiplied by two to get the minimum number of steps required to collect all the coins.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def collectTheCoins(self, coins, edges):\\n        \"\"\"\\n        :type coins: List[int]\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not edges:\\n            return 0\\n\\n        n = len(edges) + 1\\n\\n        g = {}\\n        for a, b in edges:\\n            for u, v in [(a, b), (b, a)]:\\n                if u in g:\\n                    g[u].add(v)\\n                else:\\n                    g[u] = set([v])\\n\\n        leaves = [u for u in g if len(g[u])==1]\\n        for u in leaves:\\n            while len(g[u]) == 1 and coins[u] == 0:\\n                p = g[u].pop() \\n                del g[u]\\n                g[p].remove(u)\\n                u = p\\n\\n\\n        for _ in range(2):\\n            leaves = [u for u in g if len(g[u])==1]\\n            for u in leaves:\\n                p = g[u].pop() \\n                del g[u]\\n                g[p].remove(u)\\n                if len(g) < 2:\\n                    return 0\\n                \\n\\n        return  2*(len(g)-1)\\n        \\n\\n            \\n             \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def collectTheCoins(self, coins, edges):\\n        \"\"\"\\n        :type coins: List[int]\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not edges:\\n            return 0\\n\\n        n = len(edges) + 1\\n\\n        g = {}\\n        for a, b in edges:\\n            for u, v in [(a, b), (b, a)]:\\n                if u in g:\\n                    g[u].add(v)\\n                else:\\n                    g[u] = set([v])\\n\\n        leaves = [u for u in g if len(g[u])==1]\\n        for u in leaves:\\n            while len(g[u]) == 1 and coins[u] == 0:\\n                p = g[u].pop() \\n                del g[u]\\n                g[p].remove(u)\\n                u = p\\n\\n\\n        for _ in range(2):\\n            leaves = [u for u in g if len(g[u])==1]\\n            for u in leaves:\\n                p = g[u].pop() \\n                del g[u]\\n                g[p].remove(u)\\n                if len(g) < 2:\\n                    return 0\\n                \\n\\n        return  2*(len(g)-1)\\n        \\n\\n            \\n             \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342770,
                "title": "c-bfs-from-leaf-nodes",
                "content": "# Intuition\\n**Step 1:** Remove all leaf nodes with no coins.\\n**Step 2:** Remove 2 more layers of leaf nodes.\\n**Step 3:** If $$n$$ nodes remain, there are $$(n-1)$$ edges, so the answer is $$(n-1)*2$$.\\n\\n# Approach\\n**Steps 1+2:** BFS from the leaf nodes, removing edges from the graph as you go.\\n**Step 3:** ~~Count remaining nodes using DFS.~~ Maintain count of remaining nodes during steps 1+2. (Thanks to [@hoanghonghieu](https://leetcode.com/hoanghonghieu/))\\n\\n# Complexity\\n**Time complexity:** $$O(n)$$\\n**Space complexity:** $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        // Build graph\\n        int n = coins.size();\\n        int remaining_nodes = n;\\n        vector<unordered_set<int>> g(n);\\n        for (vector<int>& e: edges) {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n\\n        // Step 1\\n        queue<int> empty_leaves;\\n        for (int i = 0; i < n; ++i) {\\n            if (g[i].size() == 1 && !coins[i]) {\\n                empty_leaves.push(i);\\n            }\\n        }\\n        while (empty_leaves.size()) {\\n            int i = empty_leaves.front();\\n            empty_leaves.pop();\\n            --remaining_nodes;\\n\\n            for (int nb: vector<int>(g[i].begin(), g[i].end())) {\\n                g[i].erase(nb);\\n                g[nb].erase(i);\\n                if (g[nb].size() == 1 && !coins[nb]) {\\n                    empty_leaves.push(nb);\\n                }\\n            }\\n        }\\n\\n        // Step 2\\n        queue<int> leaves;\\n        for (int i = 0; i < n; ++i) {\\n            if (g[i].size() == 1) {\\n                leaves.push(i);\\n            }\\n        }\\n        for (int trim = 0; trim < 2; ++trim) {\\n            int size = leaves.size();\\n            for (int i = 0; i < size; ++i) {\\n                int cur = leaves.front();\\n                leaves.pop();\\n                --remaining_nodes;\\n\\n                for (int nb: vector<int>(g[cur].begin(), g[cur].end())) {\\n                    g[cur].erase(nb);\\n                    g[nb].erase(cur);\\n                    if (g[nb].size() == 1) {\\n                        leaves.push(nb);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Step 3\\n        return max(0, (remaining_nodes - 1) *2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        // Build graph\\n        int n = coins.size();\\n        int remaining_nodes = n;\\n        vector<unordered_set<int>> g(n);\\n        for (vector<int>& e: edges) {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n\\n        // Step 1\\n        queue<int> empty_leaves;\\n        for (int i = 0; i < n; ++i) {\\n            if (g[i].size() == 1 && !coins[i]) {\\n                empty_leaves.push(i);\\n            }\\n        }\\n        while (empty_leaves.size()) {\\n            int i = empty_leaves.front();\\n            empty_leaves.pop();\\n            --remaining_nodes;\\n\\n            for (int nb: vector<int>(g[i].begin(), g[i].end())) {\\n                g[i].erase(nb);\\n                g[nb].erase(i);\\n                if (g[nb].size() == 1 && !coins[nb]) {\\n                    empty_leaves.push(nb);\\n                }\\n            }\\n        }\\n\\n        // Step 2\\n        queue<int> leaves;\\n        for (int i = 0; i < n; ++i) {\\n            if (g[i].size() == 1) {\\n                leaves.push(i);\\n            }\\n        }\\n        for (int trim = 0; trim < 2; ++trim) {\\n            int size = leaves.size();\\n            for (int i = 0; i < size; ++i) {\\n                int cur = leaves.front();\\n                leaves.pop();\\n                --remaining_nodes;\\n\\n                for (int nb: vector<int>(g[cur].begin(), g[cur].end())) {\\n                    g[cur].erase(nb);\\n                    g[nb].erase(cur);\\n                    if (g[nb].size() == 1) {\\n                        leaves.push(nb);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Step 3\\n        return max(0, (remaining_nodes - 1) *2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342579,
                "title": "trim-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Idea was to first prune leaf nodes with no coin and continue this process till no leaf node is possible to remove  .\\n- Afterwards we can remove two layers of leaves and then at  last we return  2*(number of edges still left) as each edge is traversed twice.\\n- Reason why we are removing two layers of leaf nodes because if a leaf is chosen as start vertex then its parent is a better option then the leaf and similarly for that parent its parent is better option . So hence we can remove two level of nodes. \\n\\nIf you guys liked the explanation do Upvote it motivates alot. Thank you for reading the solution\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\\n        n = len(coins)\\n        ans = n - 1\\n        \\n        adj = [set() for i in range(n)]\\n        for i, j in edges:\\n            adj[i].add(j)\\n            adj[j].add(i)\\n                \\n        l = [i for i in range(n) if len(adj[i]) == 1 and coins[i] == 0]\\n        while l:\\n            nextlayer = []\\n            for i in l:\\n                # Prune leaf i\\n                ans -= 1\\n                if adj[i]:\\n                    j = list(adj[i])[0]\\n                    adj[j].remove(i)\\n                    adj[i].remove(j)\\n                    if len(adj[j]) == 1 and coins[j] == 0:\\n                        nextlayer.append(j)\\n            l = nextlayer[:]\\n        \\n        l = [i for i in range(n) if len(adj[i]) == 1]\\n        \\n        for _ in range(2):\\n            nextlayer = []\\n            for i in l:\\n                ans -= 1\\n                if adj[i]:\\n                    j = list(adj[i])[0]\\n                    adj[j].remove(i)\\n                    if len(adj[j]) == 1:\\n                        nextlayer.append(j)\\n            l = nextlayer[:]\\n            \\n        return 2 * max(0, ans)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\\n        n = len(coins)\\n        ans = n - 1\\n        \\n        adj = [set() for i in range(n)]\\n        for i, j in edges:\\n            adj[i].add(j)\\n            adj[j].add(i)\\n                \\n        l = [i for i in range(n) if len(adj[i]) == 1 and coins[i] == 0]\\n        while l:\\n            nextlayer = []\\n            for i in l:\\n                # Prune leaf i\\n                ans -= 1\\n                if adj[i]:\\n                    j = list(adj[i])[0]\\n                    adj[j].remove(i)\\n                    adj[i].remove(j)\\n                    if len(adj[j]) == 1 and coins[j] == 0:\\n                        nextlayer.append(j)\\n            l = nextlayer[:]\\n        \\n        l = [i for i in range(n) if len(adj[i]) == 1]\\n        \\n        for _ in range(2):\\n            nextlayer = []\\n            for i in l:\\n                ans -= 1\\n                if adj[i]:\\n                    j = list(adj[i])[0]\\n                    adj[j].remove(i)\\n                    if len(adj[j]) == 1:\\n                        nextlayer.append(j)\\n            l = nextlayer[:]\\n            \\n        return 2 * max(0, ans)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342297,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLeaf nodes with no coins are none of our business.Keep removing them from the tree.Meanwhile,if we encounter leaf nodes with a coin, their grandparent (if there is any) has to be attached with tree.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& c, vector<vector<int>>& e) \\n    {\\n        int n = c.size();\\n        \\n        vector<set<int>>adj(n+1);\\n        vector<int>deg(n+1,0);\\n        for(auto x:e)\\n        {\\n            adj[x[0]].insert(x[1]);\\n            adj[x[1]].insert(x[0]);\\n            deg[x[0]]++;\\n            deg[x[1]]++;\\n        }\\n        \\n        vector<int>mark(n+1,0); \\n        vector<int>imp(n+1,0);\\n        queue<int>q;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(deg[i]==1)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n                auto x = q.front();\\n                q.pop();\\n\\n                if(deg[x]!=1||imp[x])\\n                continue;\\n\\n                deg[x]--;\\n                auto y = adj[x].begin();\\n                deg[*y]--;\\n                \\n                if(deg[*y]==1)\\n                q.push(*y);\\n\\n                if(c[x]) // if leaf node x contains a coin , then the node which x is directly attached with (node *y) will become marked.\\n                mark[*y]=1;\\n\\n                if(mark[x]) // if node x is marked,then the node which x is directly attached with (node *y) will become important. \\n                imp[*y]=1;\\n\\n                int va1=x,va2=*y;\\n                adj[va1].erase(va2);\\n                adj[va2].erase(va1);\\n            \\n           \\n        }\\n        \\n        int ans =0;\\n        for(int i=0;i<n;i++)\\n        {\\n             ans+=deg[i];\\n        }  \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& c, vector<vector<int>>& e) \\n    {\\n        int n = c.size();\\n        \\n        vector<set<int>>adj(n+1);\\n        vector<int>deg(n+1,0);\\n        for(auto x:e)\\n        {\\n            adj[x[0]].insert(x[1]);\\n            adj[x[1]].insert(x[0]);\\n            deg[x[0]]++;\\n            deg[x[1]]++;\\n        }\\n        \\n        vector<int>mark(n+1,0); \\n        vector<int>imp(n+1,0);\\n        queue<int>q;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(deg[i]==1)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n                auto x = q.front();\\n                q.pop();\\n\\n                if(deg[x]!=1||imp[x])\\n                continue;\\n\\n                deg[x]--;\\n                auto y = adj[x].begin();\\n                deg[*y]--;\\n                \\n                if(deg[*y]==1)\\n                q.push(*y);\\n\\n                if(c[x]) // if leaf node x contains a coin , then the node which x is directly attached with (node *y) will become marked.\\n                mark[*y]=1;\\n\\n                if(mark[x]) // if node x is marked,then the node which x is directly attached with (node *y) will become important. \\n                imp[*y]=1;\\n\\n                int va1=x,va2=*y;\\n                adj[va1].erase(va2);\\n                adj[va2].erase(va1);\\n            \\n           \\n        }\\n        \\n        int ans =0;\\n        for(int i=0;i<n;i++)\\n        {\\n             ans+=deg[i];\\n        }  \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347456,
                "title": "why-all-the-nodes-edges-in-the-remaining-tree-must-be-visited-after-leaves-trimming",
                "content": "The algorithm for this problem (as provided by Leetcode Hint as well as other posted solutions):\\n- Step 1: Trim all leaves with no coins. (After Step 1, we obtain a tree whose all leaves have coins. Let\\'s call this set of leaves **L1**.)\\n- Step 2. Trim **L1**.\\n- Step 3. Trim all leaves of the tree obtained after Step 2.\\n- Step 4. To collect all the coins, all the remaining nodes (edges) in the remaining tree after Step 3 must be visited. Since we have to go back to the initial vertex, the answer equals to \\n2*(remaining_nodes-1) = 2*remaining_edges.\\n\\nIt\\'s easy to understand Step 1. Since *all the coins that are at a distance of at most 2 from the current vertex can be collected*, Steps 2-3 are also understandable. But in Step 4, why *all the remaining nodes (edges) in the remaining tree must be visited*? This confused me, and all the posted solutions did not seem to care to give any explanation (while this argument plays the key role to the correctness of the algorithm and why it works). I tried to understand this and my explanations are as follows.\\n\\nLet\\'s call the set of all leaves of the remaining tree **L3**. To collect all the coins in **L1**, clearly, we have to visit all **L3**. Note that, a tree is minimally connected (you can search this tree theorem as I cannot include link), i.e. removal of one edge make it disconnected. Thus, we can visit all leaves **L3** if and only if we visit all nodes of the remaining tree.\\n\\nFurthermore, to collect coins in **L1**, visit **L3** is the optimal approach. Thus, the provided algorithm is also optimal.\\n\\nCodes are available in other posted solutions and not provided in this post.",
                "solutionTags": [
                    "Tree"
                ],
                "code": "The algorithm for this problem (as provided by Leetcode Hint as well as other posted solutions):\\n- Step 1: Trim all leaves with no coins. (After Step 1, we obtain a tree whose all leaves have coins. Let\\'s call this set of leaves **L1**.)\\n- Step 2. Trim **L1**.\\n- Step 3. Trim all leaves of the tree obtained after Step 2.\\n- Step 4. To collect all the coins, all the remaining nodes (edges) in the remaining tree after Step 3 must be visited. Since we have to go back to the initial vertex, the answer equals to \\n2*(remaining_nodes-1) = 2*remaining_edges.\\n\\nIt\\'s easy to understand Step 1. Since *all the coins that are at a distance of at most 2 from the current vertex can be collected*, Steps 2-3 are also understandable. But in Step 4, why *all the remaining nodes (edges) in the remaining tree must be visited*? This confused me, and all the posted solutions did not seem to care to give any explanation (while this argument plays the key role to the correctness of the algorithm and why it works). I tried to understand this and my explanations are as follows.\\n\\nLet\\'s call the set of all leaves of the remaining tree **L3**. To collect all the coins in **L1**, clearly, we have to visit all **L3**. Note that, a tree is minimally connected (you can search this tree theorem as I cannot include link), i.e. removal of one edge make it disconnected. Thus, we can visit all leaves **L3** if and only if we visit all nodes of the remaining tree.\\n\\nFurthermore, to collect coins in **L1**, visit **L3** is the optimal approach. Thus, the provided algorithm is also optimal.\\n\\nCodes are available in other posted solutions and not provided in this post.",
                "codeTag": "Unknown"
            },
            {
                "id": 3345255,
                "title": "java-optimal-tree-o-n-with-proof",
                "content": "essentially the same as ye15 solution\\n# Intuition\\n\\nYou don\\'t have to go to some coined nodes in the tree because you can collect their coins from a distance. Additionally, some paths lead to nodes with no coins so we don\\'t have to go there either. Remove these nodes from the tree, and you are left with nodes you must go to. The minimum number of steps you must take is the remaining edges * 2 because you must go to each node by traversing an edge, and then, go back to your home node by traversing the edge again.\\n\\n# Approach\\n1) **Remove paths with no coins:** remove leaf nodes with no coins. If leaf nodes with no coins are produced from this step, repeat until you are left with leaf nodes with coins\\n2) **Onion Peelingx2:** Since each node can collect coins from nodes two edges away, remove leaf nodes twice, not caring if they have coins. You can think of this step as peeling the first two layers of an onion, and every node in the first layer has coins while nodes in the second layer may or may not have coins.\\n3) return edges remaining * 2\\n\\nProof by contradiction:\\ncase 1: assume too many nodes were visited\\nWe removed leaf nodes with no coins, and then, we removed the outermost layer of coin nodes and its immediate inner layer. if we dont visit all the nodes in this tree, we will be unable to collect a trimed node\\'s coin, or we will partition the trimmed tree losing out on atleast one coin.\\ncase 2: assume a smaller tree is optimal with some different nodes\\nWe removed leaf nodes with no coins, and then, we removed the outermost layer of coin nodes and its immediate inner layer. if a smaller tree with some different nodes is optimal, it would have to remove a path of atleast three nodes where the end node is a coined node making atleast one of the coined nodes unreachable in this tree.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        Map<Integer, Set<Integer>> edgeList = initEdgeList(edges);\\n        //used for trimming leaf nodes with no coins\\n        Map<Integer, Boolean> hasCoins = initCoinMap(coins);\\n        int remainingEdges = trimTree(edgeList, hasCoins);\\n        //each edge that remains must be traversed exactly twice\\n        int minSteps = remainingEdges * 2;\\n        return minSteps;\\n    }\\n\\n    private int trimTree(Map<Integer, Set<Integer>> edgeList, \\n                                Map<Integer, Boolean> hasCoins) {\\n        //these nodes will never be traversed so we remove them all\\n        removeLeafNodesWithNoCoins(edgeList, hasCoins);\\n        //you can reach up to two nodes that have coins so remove all leaf nodes twice\\n        removeLeafNodes(edgeList, hasCoins, true);\\n        removeLeafNodes(edgeList, hasCoins, true);\\n        //a tree has nodeSize - 1 edges\\n        //if tree is zero nodes therefore 0 edges return 0 instead of -1\\n        return edgeList.size() > 1 ? edgeList.size() - 1 : 0;\\n    }\\n\\n    private void removeLeafNodesWithNoCoins(Map<Integer, Set<Integer>> edgeList, \\n                                            Map<Integer, Boolean> nodeToCoins) {\\n        removeLeafNodes(edgeList, nodeToCoins, false);\\n    }\\n\\n    private void removeLeafNodes(Map<Integer, Set<Integer>> edgeList, \\n                            Map<Integer, Boolean> hasCoins, boolean removeAnyNode) {\\n        LinkedList<Integer> q = new LinkedList<>();\\n        for (Map.Entry<Integer, Set<Integer> > entry : edgeList.entrySet()) {\\n            int node = entry.getKey();\\n            int nodeDegree = entry.getValue().size();\\n            //a leaf node has one edge\\n            if (nodeDegree == 1 && (removeAnyNode || !hasCoins.get(node)))\\n                q.addLast(node);\\n        }\\n        //removes leaf nodes with no coins\\n        //or if in onion peeling step, remove leaf nodes with or without coins\\n        while (q.size() > 0) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int leafNode = q.pollFirst();\\n                Set<Integer> adjacentNodes = edgeList.get(leafNode);\\n                //removes leaf node from adjacent nodes edgelist\\n                //adds the adjacent node to queue\\n                //if it becomes a new leaf node with desired properties\\n                for (int adjacentNode : adjacentNodes) {\\n                    Set<Integer> adjacentNodeAdjacentNodes = edgeList.get(adjacentNode);\\n                    adjacentNodeAdjacentNodes.remove(leafNode);\\n                    int adjacentNodeDegree = adjacentNodeAdjacentNodes.size();\\n                    if (adjacentNodeDegree == 1 && \\n                        (removeAnyNode || !hasCoins.get(adjacentNode)))\\n                        q.addLast(adjacentNode);\\n                }\\n                //remove leafNode from map since it will never be stepped on\\n                edgeList.remove(leafNode);\\n            }\\n            //only allowed one iteration if in step 2\\n            if (removeAnyNode)\\n                break;\\n        }\\n    }\\n\\n    private Map<Integer, Boolean> initCoinMap(int[] coins) {\\n        Map<Integer, Boolean> hasCoins = new HashMap<>();\\n        for (int i = 0; i < coins.length; i++)\\n            hasCoins.put(i, coins[i] == 1);\\n        return hasCoins;\\n    }\\n    \\n    private Map<Integer, Set<Integer>> initEdgeList(int[][] edges) {\\n        Map<Integer, Set<Integer>> edgeList = new HashMap<>();\\n        for (int[] edge : edges) {\\n            edgeList.computeIfAbsent(edge[0], key -> new HashSet<Integer>())\\n                .add(edge[1]);\\n            edgeList.computeIfAbsent(edge[1], key -> new HashSet<Integer>())\\n                .add(edge[0]);\\n        }\\n        return edgeList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        Map<Integer, Set<Integer>> edgeList = initEdgeList(edges);\\n        //used for trimming leaf nodes with no coins\\n        Map<Integer, Boolean> hasCoins = initCoinMap(coins);\\n        int remainingEdges = trimTree(edgeList, hasCoins);\\n        //each edge that remains must be traversed exactly twice\\n        int minSteps = remainingEdges * 2;\\n        return minSteps;\\n    }\\n\\n    private int trimTree(Map<Integer, Set<Integer>> edgeList, \\n                                Map<Integer, Boolean> hasCoins) {\\n        //these nodes will never be traversed so we remove them all\\n        removeLeafNodesWithNoCoins(edgeList, hasCoins);\\n        //you can reach up to two nodes that have coins so remove all leaf nodes twice\\n        removeLeafNodes(edgeList, hasCoins, true);\\n        removeLeafNodes(edgeList, hasCoins, true);\\n        //a tree has nodeSize - 1 edges\\n        //if tree is zero nodes therefore 0 edges return 0 instead of -1\\n        return edgeList.size() > 1 ? edgeList.size() - 1 : 0;\\n    }\\n\\n    private void removeLeafNodesWithNoCoins(Map<Integer, Set<Integer>> edgeList, \\n                                            Map<Integer, Boolean> nodeToCoins) {\\n        removeLeafNodes(edgeList, nodeToCoins, false);\\n    }\\n\\n    private void removeLeafNodes(Map<Integer, Set<Integer>> edgeList, \\n                            Map<Integer, Boolean> hasCoins, boolean removeAnyNode) {\\n        LinkedList<Integer> q = new LinkedList<>();\\n        for (Map.Entry<Integer, Set<Integer> > entry : edgeList.entrySet()) {\\n            int node = entry.getKey();\\n            int nodeDegree = entry.getValue().size();\\n            //a leaf node has one edge\\n            if (nodeDegree == 1 && (removeAnyNode || !hasCoins.get(node)))\\n                q.addLast(node);\\n        }\\n        //removes leaf nodes with no coins\\n        //or if in onion peeling step, remove leaf nodes with or without coins\\n        while (q.size() > 0) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int leafNode = q.pollFirst();\\n                Set<Integer> adjacentNodes = edgeList.get(leafNode);\\n                //removes leaf node from adjacent nodes edgelist\\n                //adds the adjacent node to queue\\n                //if it becomes a new leaf node with desired properties\\n                for (int adjacentNode : adjacentNodes) {\\n                    Set<Integer> adjacentNodeAdjacentNodes = edgeList.get(adjacentNode);\\n                    adjacentNodeAdjacentNodes.remove(leafNode);\\n                    int adjacentNodeDegree = adjacentNodeAdjacentNodes.size();\\n                    if (adjacentNodeDegree == 1 && \\n                        (removeAnyNode || !hasCoins.get(adjacentNode)))\\n                        q.addLast(adjacentNode);\\n                }\\n                //remove leafNode from map since it will never be stepped on\\n                edgeList.remove(leafNode);\\n            }\\n            //only allowed one iteration if in step 2\\n            if (removeAnyNode)\\n                break;\\n        }\\n    }\\n\\n    private Map<Integer, Boolean> initCoinMap(int[] coins) {\\n        Map<Integer, Boolean> hasCoins = new HashMap<>();\\n        for (int i = 0; i < coins.length; i++)\\n            hasCoins.put(i, coins[i] == 1);\\n        return hasCoins;\\n    }\\n    \\n    private Map<Integer, Set<Integer>> initEdgeList(int[][] edges) {\\n        Map<Integer, Set<Integer>> edgeList = new HashMap<>();\\n        for (int[] edge : edges) {\\n            edgeList.computeIfAbsent(edge[0], key -> new HashSet<Integer>())\\n                .add(edge[1]);\\n            edgeList.computeIfAbsent(edge[1], key -> new HashSet<Integer>())\\n                .add(edge[0]);\\n        }\\n        return edgeList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343063,
                "title": "tree-dp-c-o-n",
                "content": "# Intuition\\nFirst time dfs, fix the node `0` as root, and `dis[i]` represents the maximum distance from node `i` to a coin. `dp[i]` stands for the cost to collect all the coins in the subtree rooted at node `i`. \\n\\nFor `dp[u]`, if it\\'s child node `v` has `dis[v] > 1` means, we need to add the `dp[v] + 2` to `dp[u]`.\\n\\nNow we know the cost if start from node `0`, so in the second time of dfs, we need to do Tree dp to adjust the cost by change the root, so that we know which node to select as root.\\n\\nAssume we know the cost when select node `u` as root, now we want to know how to calculate the cost if we transfer the root to node `u`\\'s child `v`. \\n\\nActually, there is only small chance that the cost will be different when transfer root from `u` to it\\'s child `v`. That is when it\\'s not neccessary to visit node `u` or node `v`. For example, when `u` was the root, if `dis[v] <= 1` then it means we don\\'t need to visit node `v` to collect the coin in the subtree `v`, so after we transfer root to `v`, if we still need to go back to u for the coin in the subtree of `u` then there is extra 2 edges we need to add into the current answer. Also, we may not neccessary to go back to `u`, if `u` does not containe any coin with distance larger then 1 in it\\'s own subtree(exclude the subtree of node `v`, since after root transfer now `u` is child node of `v`).\\n\\nFor this purpose, I add another two information to help do the tree dp, that is hasDis1 and hasDis2, for example, `hasDis2[u] = 3` means node `u` has three childs node that has one or more coins with distance >= 2 to the node `u` in there subtree (it\\'s not the number of the coins, it\\'s the number of child node meet this requirement, so that when we do the tree dp, we can simply subtract node `v`\\'s case).  \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        vector<vector<int>> E(coins.size());\\n        for (auto &e : edges) \\n            E[e[0]].push_back(e[1]), E[e[1]].push_back(e[0]);\\n        vector<int> dis(coins.size(), -1), dp(coins.size(), 0), hasDis2(coins.size(), 0), hasDis1(coins.size(), 0);\\n        function<void(int, int)> dfs = [&] (int u, int fa) {\\n            if (coins[u]) dis[u] = 0;\\n            for (auto &v : E[u]) {\\n                if (v == fa) continue;\\n                dfs(v, u);\\n                if (~dis[v]) {\\n                    dis[u] = max(dis[u], dis[v] + 1);\\n                    hasDis1[u]++;\\n                    if (dis[v] > 1) dp[u] += dp[v] + 2;\\n                    if (dis[v] >= 1) hasDis2[u]++;\\n                }\\n            }\\n        };\\n        dfs(0, -1);\\n        int ans = dp[0];\\n        function<void(int, int)> dfs2 = [&] (int u, int fa) {\\n            if (dis[u] == -1) return;\\n            for (auto &v : E[u]) {\\n                if (v == fa) continue;\\n                int tmpAns = dp[u];\\n                if (dis[v] <= 1) tmpAns += 2;\\n                if (hasDis2[u] == 0 || hasDis2[u] == 1 && dis[v] >= 1) tmpAns -= 2;\\n                dp[v] = tmpAns;\\n                ans = min(dp[v], ans);\\n                hasDis1[v] += min(1, coins[u] + hasDis1[u] - (dis[v] >= 0) + hasDis2[u] - (dis[v] >= 1));\\n                hasDis2[v] += min(1, hasDis1[u] - (dis[v] >= 0) + hasDis2[u] - (dis[v] >= 1));\\n                dfs2(v, u);\\n            }\\n        };\\n        dfs2(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        vector<vector<int>> E(coins.size());\\n        for (auto &e : edges) \\n            E[e[0]].push_back(e[1]), E[e[1]].push_back(e[0]);\\n        vector<int> dis(coins.size(), -1), dp(coins.size(), 0), hasDis2(coins.size(), 0), hasDis1(coins.size(), 0);\\n        function<void(int, int)> dfs = [&] (int u, int fa) {\\n            if (coins[u]) dis[u] = 0;\\n            for (auto &v : E[u]) {\\n                if (v == fa) continue;\\n                dfs(v, u);\\n                if (~dis[v]) {\\n                    dis[u] = max(dis[u], dis[v] + 1);\\n                    hasDis1[u]++;\\n                    if (dis[v] > 1) dp[u] += dp[v] + 2;\\n                    if (dis[v] >= 1) hasDis2[u]++;\\n                }\\n            }\\n        };\\n        dfs(0, -1);\\n        int ans = dp[0];\\n        function<void(int, int)> dfs2 = [&] (int u, int fa) {\\n            if (dis[u] == -1) return;\\n            for (auto &v : E[u]) {\\n                if (v == fa) continue;\\n                int tmpAns = dp[u];\\n                if (dis[v] <= 1) tmpAns += 2;\\n                if (hasDis2[u] == 0 || hasDis2[u] == 1 && dis[v] >= 1) tmpAns -= 2;\\n                dp[v] = tmpAns;\\n                ans = min(dp[v], ans);\\n                hasDis1[v] += min(1, coins[u] + hasDis1[u] - (dis[v] >= 0) + hasDis2[u] - (dis[v] >= 1));\\n                hasDis2[v] += min(1, hasDis1[u] - (dis[v] >= 0) + hasDis2[u] - (dis[v] >= 1));\\n                dfs2(v, u);\\n            }\\n        };\\n        dfs2(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342476,
                "title": "java-trim-empty-leaves-then-trim-remaining-leaves-twice-to-shrink-the-radius-to-0",
                "content": "# Intuition\\nWe are going to build a tree, and remove dead leaves (no coins) repeatedly. Then, we are going to remove leaves twice more - once as we push the coins up to the parent and reduce our search range from 2 to 1, then again, to reduce our search range from 1 to 0. The remaining nodes are our search nodes. Consider any starting point our root. Then to traverse our remaining tree of k nodes (with k - 1 edges) we will require (k - 1) * 2 steps, one step out, one step in along each edge. So our answer is (k - 1) * 2 where k is the remaining number of nodes after removing them with the steps listed above (with a special case, where if we have 0 nodes remaining, then our answer is 0).\\n\\n# Approach\\nBuild the tree. We use IntSet here as a class to avoid having an array of `Set<Integer>`. This is just syntactic sugar to make the array declaration more readable, etc (and to encapsulate a static factory method for instantiating an array of these sets).\\n\\nNext, remove all leaves without coins (repeatedly until we cannot trim any further).\\n\\nThen, remove all leaves (with coins) and track the parents of these leaves. This represents shrinking our search radius by 1 from 2 to 1. And, repeat this by checking any parent found in the previous step, to see if it is now a leaf; if so, trim it, too, thus reducing our search radius from 1 to 0.\\n\\nNow, count the remaining nodes. If 0, our answer is 0, else our answer is `(count - 1) * 2`.\\n\\n# Code (Java)\\n```\\nclass Solution {\\n\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        final int n = coins.length;\\n        final IntSet[] graph = IntSet.arrayOfSize(n);\\n        for (int[] edge : edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        final boolean[] removed = new boolean[n];\\n        trimTreeOfFruitlessLeaves(graph, coins, removed);\\n        trimTreeOfLeavesAndParents(graph, removed);\\n        int count = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                count++;\\n            }\\n        }\\n        return Math.max(0, (count - 1) << 1); // (count - 1) * 2, because each edge twice (in, out)\\n    }\\n\\n    private void trimTreeOfFruitlessLeaves(IntSet[] graph, int[] coins, boolean[] removed) {\\n        final int n = coins.length;\\n        Set<Integer> removedLast = new LinkedHashSet<>();\\n        Set<Integer> parents = new LinkedHashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                parents.add(i);\\n            }\\n        }\\n        while (!parents.isEmpty()) {\\n            Set<Integer> removedNext = new LinkedHashSet<>();\\n            Set<Integer> nextParents = new LinkedHashSet<>();\\n            for (int p : parents) {\\n                if (!removed[p]) {\\n                    graph[p].removeAll(removedLast);\\n                    if (graph[p].size() == 1 && coins[p] == 0) {\\n                        removed[p] = true;\\n                        removedNext.add(p);\\n                        nextParents.addAll(graph[p]);\\n                    }\\n                }\\n            }\\n            removedLast = removedNext;\\n            parents = nextParents;\\n        }\\n    }\\n\\n    private void trimTreeOfLeavesAndParents(IntSet[] graph, boolean[] removed) {\\n        final int n = graph.length;\\n        Set<Integer> toRemove = new LinkedHashSet<>();\\n        Set<Integer> parents = new LinkedHashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i] && graph[i].size() == 1) {\\n                toRemove.add(i);\\n                parents.addAll(graph[i]);\\n            }\\n        }\\n        for (int i : toRemove) {\\n            removed[i] = true;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                graph[i].removeAll(toRemove);\\n            }\\n        }\\n        for (int p : parents) {\\n            if (!removed[p] && graph[p].size() == 1) {\\n                removed[p] = true;\\n            }\\n        }\\n    }\\n\\n    static class IntSet extends LinkedHashSet<Integer> {\\n\\n        static IntSet[] arrayOfSize(int n) {\\n            final IntSet[] out = new IntSet[n];\\n            for (int i = 0; i < n; ++i) {\\n                out[i] = new IntSet();\\n            }\\n            return out;\\n        }\\n\\n    }\\n\\n}\\n```\\n\\n# Complexity\\n- Time complexity: O(n) for visiting each node at most once in each step.\\n- Space complexity: effectively O(n) for enough storage of the graph, etc.\\n\\n# Note: The Above Is Not Optimized Code\\nThis solution favors using methods which correlate to the steps listed above, and this isn\\'t necessarily the most efficient way to solve the problem. We could be more efficient by tracking leaves as we encounter them, and updating as we create new leaves, etc. to avoid looping over the same elements multiple times, etc. I tend to think it makes the code a bit easier to understand, but it\\'s definitely slower than it could be (probably by a factor of 2 or more).  Runtime is around 125-150ms as of 2023-03-26.\\n\\n# Standard Plea\\nIf you found this useful, interesting or otherwise not a waste of your time, **I\\'d appreciate your upvote**. If you think this solution could be better (or you think I should discuss something that I skipped), **I\\'d greatly appreciate your constructive criticism** in the comments. Thanks for your time and happy coding!",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        final int n = coins.length;\\n        final IntSet[] graph = IntSet.arrayOfSize(n);\\n        for (int[] edge : edges) {\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        final boolean[] removed = new boolean[n];\\n        trimTreeOfFruitlessLeaves(graph, coins, removed);\\n        trimTreeOfLeavesAndParents(graph, removed);\\n        int count = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                count++;\\n            }\\n        }\\n        return Math.max(0, (count - 1) << 1); // (count - 1) * 2, because each edge twice (in, out)\\n    }\\n\\n    private void trimTreeOfFruitlessLeaves(IntSet[] graph, int[] coins, boolean[] removed) {\\n        final int n = coins.length;\\n        Set<Integer> removedLast = new LinkedHashSet<>();\\n        Set<Integer> parents = new LinkedHashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                parents.add(i);\\n            }\\n        }\\n        while (!parents.isEmpty()) {\\n            Set<Integer> removedNext = new LinkedHashSet<>();\\n            Set<Integer> nextParents = new LinkedHashSet<>();\\n            for (int p : parents) {\\n                if (!removed[p]) {\\n                    graph[p].removeAll(removedLast);\\n                    if (graph[p].size() == 1 && coins[p] == 0) {\\n                        removed[p] = true;\\n                        removedNext.add(p);\\n                        nextParents.addAll(graph[p]);\\n                    }\\n                }\\n            }\\n            removedLast = removedNext;\\n            parents = nextParents;\\n        }\\n    }\\n\\n    private void trimTreeOfLeavesAndParents(IntSet[] graph, boolean[] removed) {\\n        final int n = graph.length;\\n        Set<Integer> toRemove = new LinkedHashSet<>();\\n        Set<Integer> parents = new LinkedHashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i] && graph[i].size() == 1) {\\n                toRemove.add(i);\\n                parents.addAll(graph[i]);\\n            }\\n        }\\n        for (int i : toRemove) {\\n            removed[i] = true;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                graph[i].removeAll(toRemove);\\n            }\\n        }\\n        for (int p : parents) {\\n            if (!removed[p] && graph[p].size() == 1) {\\n                removed[p] = true;\\n            }\\n        }\\n    }\\n\\n    static class IntSet extends LinkedHashSet<Integer> {\\n\\n        static IntSet[] arrayOfSize(int n) {\\n            final IntSet[] out = new IntSet[n];\\n            for (int i = 0; i < n; ++i) {\\n                out[i] = new IntSet();\\n            }\\n            return out;\\n        }\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341918,
                "title": "yeah-let-compare-who-can-submit-all-four-answers-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust toplogial sort twice. one for trim, one for answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int collectTheCoins(const vector<int>& coins, const vector<vector<int>>& edges) {\\n    int n = coins.size();\\n    vector<unordered_set<int>> g(n, unordered_set<int>());\\n    vector<int> degree(n, 0);\\n    for (auto& e : edges) {\\n      g[e.front()].insert(e.back());\\n      g[e.back()].insert(e.front());\\n      ++degree[e.back()];\\n      ++degree[e.front()];\\n    }\\n    queue<int> q;\\n    for (int i = 0; i < n; ++i) {\\n      if (degree[i] == 1 && coins[i] == 0) {\\n        q.emplace(i);\\n      }\\n    }\\n    while (q.size()) {\\n      int i = q.front();\\n      q.pop();\\n      for (int n : g[i]) {\\n        if (--degree[n] == 1 && coins[n] == 0) {\\n          q.push(n);\\n        }\\n        g[n].erase(i);\\n      }\\n      g[i].clear();\\n      degree[i] = n;\\n    }\\n    for (int i = 0; i < n; ++i) {\\n      if (degree[i] == 1) {\\n        q.emplace(i);\\n      }\\n    }\\n    for (int t = 0; t < 2; ++t) {\\n      int len = q.size();\\n      while (len-- > 0) {\\n        int cur = q.front();\\n        q.pop();\\n        for (int next : g[cur]) {\\n          if (--degree[next] == 1) {\\n            q.push(next);\\n          }\\n          g[next].erase(cur);\\n        }\\n        g[cur].clear();\\n        degree[cur] = n;\\n      }\\n    }\\n    int left = 0;\\n    for (auto& v : g) {\\n      if (v.size() > 0) {\\n        ++left;\\n      }\\n    }\\n    return max(0, (left - 1) * 2);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int collectTheCoins(const vector<int>& coins, const vector<vector<int>>& edges) {\\n    int n = coins.size();\\n    vector<unordered_set<int>> g(n, unordered_set<int>());\\n    vector<int> degree(n, 0);\\n    for (auto& e : edges) {\\n      g[e.front()].insert(e.back());\\n      g[e.back()].insert(e.front());\\n      ++degree[e.back()];\\n      ++degree[e.front()];\\n    }\\n    queue<int> q;\\n    for (int i = 0; i < n; ++i) {\\n      if (degree[i] == 1 && coins[i] == 0) {\\n        q.emplace(i);\\n      }\\n    }\\n    while (q.size()) {\\n      int i = q.front();\\n      q.pop();\\n      for (int n : g[i]) {\\n        if (--degree[n] == 1 && coins[n] == 0) {\\n          q.push(n);\\n        }\\n        g[n].erase(i);\\n      }\\n      g[i].clear();\\n      degree[i] = n;\\n    }\\n    for (int i = 0; i < n; ++i) {\\n      if (degree[i] == 1) {\\n        q.emplace(i);\\n      }\\n    }\\n    for (int t = 0; t < 2; ++t) {\\n      int len = q.size();\\n      while (len-- > 0) {\\n        int cur = q.front();\\n        q.pop();\\n        for (int next : g[cur]) {\\n          if (--degree[next] == 1) {\\n            q.push(next);\\n          }\\n          g[next].erase(cur);\\n        }\\n        g[cur].clear();\\n        degree[cur] = n;\\n      }\\n    }\\n    int left = 0;\\n    for (auto& v : g) {\\n      if (v.size() > 0) {\\n        ++left;\\n      }\\n    }\\n    return max(0, (left - 1) * 2);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480722,
                "title": "python-simple-topological-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def collectTheCoins(self, coins, edges):\\n        if not edges:\\n            return 0\\n\\n        n, dict1 = len(coins), defaultdict(set)\\n\\n        for i,j in edges:\\n            dict1[i].add(j)\\n            dict1[j].add(i)\\n\\n        leaves = [i for i in dict1 if len(dict1[i]) == 1]\\n\\n        for u in leaves:\\n            while len(dict1[u]) == 1 and coins[u] == 0:\\n                p = dict1[u].pop()\\n                del dict1[u]\\n                dict1[p].remove(u)\\n                u = p\\n\\n        for _ in range(2):\\n            leaves = [i for i in dict1 if len(dict1[i]) == 1]\\n            for u in leaves:\\n                p = dict1[u].pop()\\n                del dict1[u]\\n                dict1[p].remove(u)\\n                if len(dict1) < 2:\\n                    return 0\\n\\n        return 2*(len(dict1)-1)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n        \\n\\n        \\n\\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def collectTheCoins(self, coins, edges):\\n        if not edges:\\n            return 0\\n\\n        n, dict1 = len(coins), defaultdict(set)\\n\\n        for i,j in edges:\\n            dict1[i].add(j)\\n            dict1[j].add(i)\\n\\n        leaves = [i for i in dict1 if len(dict1[i]) == 1]\\n\\n        for u in leaves:\\n            while len(dict1[u]) == 1 and coins[u] == 0:\\n                p = dict1[u].pop()\\n                del dict1[u]\\n                dict1[p].remove(u)\\n                u = p\\n\\n        for _ in range(2):\\n            leaves = [i for i in dict1 if len(dict1[i]) == 1]\\n            for u in leaves:\\n                p = dict1[u].pop()\\n                del dict1[u]\\n                dict1[p].remove(u)\\n                if len(dict1) < 2:\\n                    return 0\\n\\n        return 2*(len(dict1)-1)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n        \\n\\n        \\n\\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446090,
                "title": "tree-dp-and-rerooting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst finding solution for a single vertex that is 0 then\\nrerooting for all the other vertices.\\n\\n# Approach\\nFirstly calculating maximum distance for every path where\\nthere can be a coin, if for any path there is no coin we are assigning that path to -1 this will indicate that this path should not be visited. \\n\\n->In the next step in DFS function we are checking if\\nfor any child the maximum distance is \\'$$>2$$\\' then there is no choice but to visit that path, so we are adding $$+ 2$$ in our dp (+1 for visiting and +1 for re-visiting)\\n\\n->Next step we are rerooting the edges\\nfirstly remove all the contribution of the upcoming parent from the cureent parent that is:\\n$$Dp[s]-=Dp[i]$$\\nSimilarly also remove the contribution from the distance if the maximum distance comes from the child which is going to be upcoming parent, that is\\nif ($$Dis[par]==1+Dis[child]$$){\\nthen replace distance of the parent to the second maximum distance $$Dis[par]=smax$$\\n}.\\nelse{\\nNo need to remove contribution of Dis[upcoming_parent]\\n}\\n(Note every dis[i] stores the maximum distance of the coin in that path)\\n\\nNow every contibution of the child is removed, now calculate new \"DP[upcoming_Par]\" considering Curr_Par as a child for the \\nUpcoming_Par.\\nYou can get more clarity by going through the implementation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    const static int M=3e4+2;\\n    int dis[M];\\n    int dp[M];\\n    int ans;\\n    vector<int>graph[M];\\n    \\n    void mx_dis(int s,int p,vector<int>&coins){\\n       \\n        int cd=0;\\n         if(coins[s])\\n        cd=0;\\n        else\\n        cd=-1;\\n        \\n        for(auto i:graph[s]){\\n            if(i!=p){\\n                mx_dis(i,s,coins);\\n                cd=max(cd,dis[i]);\\n            }\\n        }\\n       if(cd!=-1)\\n       cd+=1; //Valid path,so adding child to parent distance\\n       dis[s]=cd;\\n    }\\n    void dfs(int s,int p){\\n       \\n       int ans=0;\\n        for(auto i:graph[s]){\\n            if(i!=p){\\n                dfs(i,s);\\n                if(dis[i]>2)\\n                ans+=2;\\n                ans+=dp[i];\\n            }\\n        }\\n        dp[s]=ans;\\n       \\n    }\\n\\n\\n    void reroot(int s,int p,vector<int>&coins){\\n         ans=min(ans,dp[s]);\\n        vector<int>t;\\n        for(auto i:graph[s])\\n        t.push_back(dis[i]);\\n        int fmax=(coins[s])?0:-1,smax=-1;\\n\\n        for(auto i:t){\\n            if(i>=fmax)\\n            {\\n                smax=fmax;\\n                fmax=i;    \\n            }\\n            else if(i>smax){\\n                smax=i;\\n            }\\n        }\\n\\n        for(auto i:graph[s]){\\n            if(i==p)continue;\\n\\n            int pdis=dis[s];\\n            int pdp=dp[s];\\n            int cdis=dis[i];\\n            int cdp=dp[i];\\n\\n           dp[s]-=dp[i];\\n            if(dis[i]>2)\\n            dp[s]-=2;\\n\\n           dp[i]+=dp[s];\\n\\n            if(dis[i]==fmax){\\n //If SMAX or FMAX comes to be -1 make sure \\n//you leave it to -1 this will indicate\\n //invalid path as there will be no coin in that path.\\n\\n                dis[s]=(smax!=-1)?1+smax:-1;\\n      \\n                if(dis[s]>2){\\n                    dp[i]+=2;\\n                }\\n                dis[i]=max((dis[s]!=-1)?1+dis[s]:-1,dis[i]);\\n            }else{\\n          \\n                if(dis[s]>2){\\n                    dp[i]+=2;\\n                }\\n                dis[i]=max(dis[i],(dis[s]!=-1)?1+dis[s]:-1);\\n            }\\n           \\n            reroot(i,s,coins);\\n\\n            dis[s]=pdis;\\n            dp[s]=pdp;\\n            dis[i]=cdis;\\n            dp[i]=cdp;\\n        }\\n    }\\n\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n       for(auto i:edges)\\n       graph[i[0]].push_back(i[1]),graph[i[1]].push_back(i[0]);\\n        mx_dis(0,-1,coins);\\n        dfs(0,-1);\\n        ans=dp[0];\\n        reroot(0,-1,coins);\\n        if(ans<0)\\n        ans=0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    const static int M=3e4+2;\\n    int dis[M];\\n    int dp[M];\\n    int ans;\\n    vector<int>graph[M];\\n    \\n    void mx_dis(int s,int p,vector<int>&coins){\\n       \\n        int cd=0;\\n         if(coins[s])\\n        cd=0;\\n        else\\n        cd=-1;\\n        \\n        for(auto i:graph[s]){\\n            if(i!=p){\\n                mx_dis(i,s,coins);\\n                cd=max(cd,dis[i]);\\n            }\\n        }\\n       if(cd!=-1)\\n       cd+=1; //Valid path,so adding child to parent distance\\n       dis[s]=cd;\\n    }\\n    void dfs(int s,int p){\\n       \\n       int ans=0;\\n        for(auto i:graph[s]){\\n            if(i!=p){\\n                dfs(i,s);\\n                if(dis[i]>2)\\n                ans+=2;\\n                ans+=dp[i];\\n            }\\n        }\\n        dp[s]=ans;\\n       \\n    }\\n\\n\\n    void reroot(int s,int p,vector<int>&coins){\\n         ans=min(ans,dp[s]);\\n        vector<int>t;\\n        for(auto i:graph[s])\\n        t.push_back(dis[i]);\\n        int fmax=(coins[s])?0:-1,smax=-1;\\n\\n        for(auto i:t){\\n            if(i>=fmax)\\n            {\\n                smax=fmax;\\n                fmax=i;    \\n            }\\n            else if(i>smax){\\n                smax=i;\\n            }\\n        }\\n\\n        for(auto i:graph[s]){\\n            if(i==p)continue;\\n\\n            int pdis=dis[s];\\n            int pdp=dp[s];\\n            int cdis=dis[i];\\n            int cdp=dp[i];\\n\\n           dp[s]-=dp[i];\\n            if(dis[i]>2)\\n            dp[s]-=2;\\n\\n           dp[i]+=dp[s];\\n\\n            if(dis[i]==fmax){\\n //If SMAX or FMAX comes to be -1 make sure \\n//you leave it to -1 this will indicate\\n //invalid path as there will be no coin in that path.\\n\\n                dis[s]=(smax!=-1)?1+smax:-1;\\n      \\n                if(dis[s]>2){\\n                    dp[i]+=2;\\n                }\\n                dis[i]=max((dis[s]!=-1)?1+dis[s]:-1,dis[i]);\\n            }else{\\n          \\n                if(dis[s]>2){\\n                    dp[i]+=2;\\n                }\\n                dis[i]=max(dis[i],(dis[s]!=-1)?1+dis[s]:-1);\\n            }\\n           \\n            reroot(i,s,coins);\\n\\n            dis[s]=pdis;\\n            dp[s]=pdp;\\n            dis[i]=cdis;\\n            dp[i]=cdp;\\n        }\\n    }\\n\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n       for(auto i:edges)\\n       graph[i[0]].push_back(i[1]),graph[i[1]].push_back(i[0]);\\n        mx_dis(0,-1,coins);\\n        dfs(0,-1);\\n        ans=dp[0];\\n        reroot(0,-1,coins);\\n        if(ans<0)\\n        ans=0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351190,
                "title": "javascript-dfs-tree-dp-370ms",
                "content": "```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packUG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); g[v].push(u); } };\\nconst sm = (a) => a.reduce(((x, y) => x + y), 0);\\n\\nlet a, cum, res, v, sum, g;\\nconst collectTheCoins = (coins, edges) => {\\n    let n = coins.length;\\n    g = initializeGraph(n), a = coins, res = 0, cum = Array(n), v = Array(n), sum = sm(a);\\n    packUG(g, edges);\\n    for (let i = 0; i < n; i++) {\\n        cum[i] = a[i];\\n        for (const child of g[i]) cum[i] += a[child];\\n    }\\n    tree_dp(0, 0);\\n    return res;\\n};\\n\\nconst tree_dp = (cur, par) => {\\n    v[cur] = a[cur];\\n    for (const child of g[cur]) {\\n        if (child != par) {\\n            v[cur] += tree_dp(child, cur);\\n        }\\n    }\\n    if (cur != par) {\\n        let x = v[cur] + cum[par] - a[cur];\\n        let y = (sum - v[cur]) + cum[cur] - a[par];\\n        if (x != sum && y != sum) res += 2;\\n    }\\n    return v[cur];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packUG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); g[v].push(u); } };\\nconst sm = (a) => a.reduce(((x, y) => x + y), 0);\\n\\nlet a, cum, res, v, sum, g;\\nconst collectTheCoins = (coins, edges) => {\\n    let n = coins.length;\\n    g = initializeGraph(n), a = coins, res = 0, cum = Array(n), v = Array(n), sum = sm(a);\\n    packUG(g, edges);\\n    for (let i = 0; i < n; i++) {\\n        cum[i] = a[i];\\n        for (const child of g[i]) cum[i] += a[child];\\n    }\\n    tree_dp(0, 0);\\n    return res;\\n};\\n\\nconst tree_dp = (cur, par) => {\\n    v[cur] = a[cur];\\n    for (const child of g[cur]) {\\n        if (child != par) {\\n            v[cur] += tree_dp(child, cur);\\n        }\\n    }\\n    if (cur != par) {\\n        let x = v[cur] + cum[par] - a[cur];\\n        let y = (sum - v[cur]) + cum[cur] - a[par];\\n        if (x != sum && y != sum) res += 2;\\n    }\\n    return v[cur];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3343350,
                "title": "c-removing-unused-edges",
                "content": "# Approach\\nRemoving unused edges starting from leaves\\n\\n# Complexity\\n\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    private IDictionary<int, ISet<int>> tree;\\n    private int[] degree;\\n\\n    public int CollectTheCoins(int[] coins, int[][] edges)\\n    {\\n        int n = coins.Length;\\n\\n        BuildTree(n, edges);\\n\\n        int result = edges.Length;\\n\\n        bool[] visited = new bool[n];\\n        int[] d = new int[n];\\n\\n        var queue = new Queue<int>();\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (degree[i] == 1)\\n            {\\n                queue.Enqueue(i);\\n            }\\n        }\\n\\n        int u;\\n        while (queue.Count > 0)\\n        {\\n            u = queue.Dequeue();\\n\\n            visited[u] = true;\\n\\n            foreach (int v in tree[u])\\n            {\\n                if (!visited[v])\\n                {\\n                    d[v] = Math.Max(d[v], d[u] > 0 ? 1 + d[u] : coins[u]);\\n\\n                    result--;\\n\\n                    degree[v]--;\\n                    if (degree[v] == 1 && d[v] < 2)\\n                    {\\n                        queue.Enqueue(v);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return 2 * result;\\n    }\\n\\n    private void BuildTree(int n, int[][] edges)\\n    {\\n        tree = new Dictionary<int, ISet<int>>();\\n        degree = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            tree.Add(i, new HashSet<int>());\\n        }\\n\\n        foreach (var edge in edges)\\n        {\\n            tree[edge[0]].Add(edge[1]);\\n            tree[edge[1]].Add(edge[0]);\\n\\n            degree[edge[0]]++;\\n            degree[edge[1]]++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Queue"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private IDictionary<int, ISet<int>> tree;\\n    private int[] degree;\\n\\n    public int CollectTheCoins(int[] coins, int[][] edges)\\n    {\\n        int n = coins.Length;\\n\\n        BuildTree(n, edges);\\n\\n        int result = edges.Length;\\n\\n        bool[] visited = new bool[n];\\n        int[] d = new int[n];\\n\\n        var queue = new Queue<int>();\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (degree[i] == 1)\\n            {\\n                queue.Enqueue(i);\\n            }\\n        }\\n\\n        int u;\\n        while (queue.Count > 0)\\n        {\\n            u = queue.Dequeue();\\n\\n            visited[u] = true;\\n\\n            foreach (int v in tree[u])\\n            {\\n                if (!visited[v])\\n                {\\n                    d[v] = Math.Max(d[v], d[u] > 0 ? 1 + d[u] : coins[u]);\\n\\n                    result--;\\n\\n                    degree[v]--;\\n                    if (degree[v] == 1 && d[v] < 2)\\n                    {\\n                        queue.Enqueue(v);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return 2 * result;\\n    }\\n\\n    private void BuildTree(int n, int[][] edges)\\n    {\\n        tree = new Dictionary<int, ISet<int>>();\\n        degree = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            tree.Add(i, new HashSet<int>());\\n        }\\n\\n        foreach (var edge in edges)\\n        {\\n            tree[edge[0]].Add(edge[1]);\\n            tree[edge[1]].Add(edge[0]);\\n\\n            degree[edge[0]]++;\\n            degree[edge[1]]++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342556,
                "title": "java-o-n-tree-trimming",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        HashSet<Integer>[] map = new HashSet[coins.length];\\n        for (int i = 0; i < coins.length; i++) {\\n            map[i] = new HashSet<>();\\n        }\\n        for (int[] e : edges) {\\n            map[e[0]].add(e[1]);\\n            map[e[1]].add(e[0]);\\n        }\\n        \\n        int[] jumps = new int[coins.length];\\n        int[] dist = new int[coins.length];\\n        Arrays.fill(dist, 2);\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n\\n        /*\\n        First of all trim the graph. \\n        Remove all the leaves with no coins. \\n        Repeat this process untill we get a graph with all \\n        leaves having coins. This is the graph that needs \\n        to be analyzed.\\n        */\\n        for (int i = 0; i < coins.length; i++) {\\n            if (map[i].size() == 1 && coins[i] == 0) {\\n                q.add(i);\\n            }\\n        }\\n        while ( ! q.isEmpty()) {\\n            int u = q.poll();\\n            if (map[u].size() == 0) {\\n                continue;\\n            }\\n            int v = map[u].stream().findFirst().get();\\n            map[u].clear();\\n            map[v].remove(u);\\n            if ( map[v].size() == 1 && coins[v] == 0) {\\n                q.add(v);\\n            }\\n        }\\n\\n        for (int i = 0; i < coins.length; i++) {\\n            if (map[i].size() == 1) {\\n                q.add(i);\\n            }\\n        }\\n        \\n        /*\\n        Transfer the coins to the parents of respective leaves \\n        and delete these edges.\\n        */\\n        while ( ! q.isEmpty()) {\\n            int u = q.poll();\\n            if (map[u].size() == 0) {\\n                // last vortex\\n                return jumps[u];\\n            }\\n            \\n            int v = map[u].stream().findFirst().get();\\n            map[u].clear();\\n            map[v].remove(u);\\n            \\n            if (jumps[u] > 0) {\\n                jumps[v] += (jumps[u]+2);\\n            } else if (dist[u] == 0) {\\n                jumps[v] += 2;\\n            } else {\\n                dist[v] = Math.min(dist[v], dist[u]-1);\\n            }\\n\\n            if ( map[v].size() == 1) {\\n                q.add(v);\\n            }\\n            \\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        HashSet<Integer>[] map = new HashSet[coins.length];\\n        for (int i = 0; i < coins.length; i++) {\\n            map[i] = new HashSet<>();\\n        }\\n        for (int[] e : edges) {\\n            map[e[0]].add(e[1]);\\n            map[e[1]].add(e[0]);\\n        }\\n        \\n        int[] jumps = new int[coins.length];\\n        int[] dist = new int[coins.length];\\n        Arrays.fill(dist, 2);\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n\\n        /*\\n        First of all trim the graph. \\n        Remove all the leaves with no coins. \\n        Repeat this process untill we get a graph with all \\n        leaves having coins. This is the graph that needs \\n        to be analyzed.\\n        */\\n        for (int i = 0; i < coins.length; i++) {\\n            if (map[i].size() == 1 && coins[i] == 0) {\\n                q.add(i);\\n            }\\n        }\\n        while ( ! q.isEmpty()) {\\n            int u = q.poll();\\n            if (map[u].size() == 0) {\\n                continue;\\n            }\\n            int v = map[u].stream().findFirst().get();\\n            map[u].clear();\\n            map[v].remove(u);\\n            if ( map[v].size() == 1 && coins[v] == 0) {\\n                q.add(v);\\n            }\\n        }\\n\\n        for (int i = 0; i < coins.length; i++) {\\n            if (map[i].size() == 1) {\\n                q.add(i);\\n            }\\n        }\\n        \\n        /*\\n        Transfer the coins to the parents of respective leaves \\n        and delete these edges.\\n        */\\n        while ( ! q.isEmpty()) {\\n            int u = q.poll();\\n            if (map[u].size() == 0) {\\n                // last vortex\\n                return jumps[u];\\n            }\\n            \\n            int v = map[u].stream().findFirst().get();\\n            map[u].clear();\\n            map[v].remove(u);\\n            \\n            if (jumps[u] > 0) {\\n                jumps[v] += (jumps[u]+2);\\n            } else if (dist[u] == 0) {\\n                jumps[v] += 2;\\n            } else {\\n                dist[v] = Math.min(dist[v], dist[u]-1);\\n            }\\n\\n            if ( map[v].size() == 1) {\\n                q.add(v);\\n            }\\n            \\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342321,
                "title": "2-times-dfs",
                "content": "It is easy to observe that the final path will consisting of a set of $u \\\\to v$ and $v \\\\to u$ s. And no edge will bevisited more than 2 times.\\n\\nTherefore, in this case, we want to get the number of edges will be visited. And then multiply it by 2.\\n\\nIf the root is fixed, the question is easy, we can solve it by writing like:\\n\\n```cpp\\nvoid dfsinit(int x, int p) {\\n    dp[x] = 0;\\n    pa[x] = p;\\n    if (p == -1) dpth[x] = 0;\\n    else dpth[x] = dpth[p] + 1;\\n    has0[x] = cs[x];\\n    has1[x] = false;\\n    has2[x] = false;\\n    for (auto v: adj[x]) {\\n        if (v == p) continue;\\n        dfsinit(v, x);\\n        has1[x] = has0[v] || has1[v] || has1[x];\\n        has2[x] = has1[v] || has2[v] || has2[x];\\n        dp[x] += dp[v];\\n        if (has2[v] || dp[v]) {\\n            dp[x] ++;\\n        }\\n    }\\n}\\n```\\n\\nAnd $dp[root]$ will be the answer. However, in this case, root isn\\'t fixed. So it is hard for us to solve the question.\\n\\nHowever, there is also a fix. Because our path is similar to a tree (imaging a combination of $u \\\\to v$ and $v \\\\to u$ edges visited). So we observe, as long as we can get arbitrary vertex on the path that has to be visited, then dfs through that vertex for getting best result, we can get our answer. This is because the whole process doesn\\'t matter which vertex is visited first or last.\\n\\nA vertex that has to be visited is:\\nLet the deepest coined vertex be $v$, then $w=parent[parent[v]]$ has to be visited. Because if some child node $u$ of $parent[v]$ is visited to contribute for some other vertex $x$, then it means $dis(u \\\\to x) >= 2$, meaning depth of $x$ is greater than depth of $v$, contradicting with $v$ is deepest.\\n\\nIf we know $w$ has to be visited. So do a dfs on $w$, and the answer is get.\\n\\n\\n```cpp\\nvector<int> cs;\\n\\nvector<int> adj[30005];\\n\\nint dp[30005];\\nbool has0[30005];\\nbool has1[30005];\\nbool has2[30005];\\nint pa[30005];\\nint dpth[30005];\\n\\nvoid dfsinit(int x, int p) {\\n    dp[x] = 0;\\n    pa[x] = p;\\n    if (p == -1) dpth[x] = 0;\\n    else dpth[x] = dpth[p] + 1;\\n    has0[x] = cs[x];\\n    has1[x] = false;\\n    has2[x] = false;\\n    for (auto v: adj[x]) {\\n        if (v == p) continue;\\n        dfsinit(v, x);\\n        has1[x] = has0[v] || has1[v] || has1[x];\\n        has2[x] = has1[v] || has2[v] || has2[x];\\n        dp[x] += dp[v];\\n        if (has2[v] || dp[v]) {\\n            dp[x] ++;\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        cs = coins;\\n        int N = coins.size();\\n        for (int i = 0; i < N; i ++) {\\n            adj[i].clear();\\n            has0[i] = false;\\n            has1[i] = false;\\n            has2[i] = false;\\n            dp[i] = 0;\\n        }\\n        for (auto &v: edges) {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        \\n        dfsinit(0, -1);\\n        int tot = 0;\\n        int mxdpt = 0, mxidx = -1;\\n        \\n        for (int i = 0; i < N; i ++) {\\n            if (cs[i] && mxdpt < dpth[i]) {\\n                mxdpt = dpth[i];\\n                mxidx = i;\\n            }\\n        }\\n        \\n        if (mxidx == -1 || pa[mxidx] == -1 || pa[pa[mxidx]] == -1 || pa[pa[pa[mxidx]]] == -1) {\\n            return 0;\\n        }\\n        \\n        int now = pa[pa[mxidx]];\\n        \\n        dfsinit(now, -1);\\n        \\n        return dp[now] * 2;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nvoid dfsinit(int x, int p) {\\n    dp[x] = 0;\\n    pa[x] = p;\\n    if (p == -1) dpth[x] = 0;\\n    else dpth[x] = dpth[p] + 1;\\n    has0[x] = cs[x];\\n    has1[x] = false;\\n    has2[x] = false;\\n    for (auto v: adj[x]) {\\n        if (v == p) continue;\\n        dfsinit(v, x);\\n        has1[x] = has0[v] || has1[v] || has1[x];\\n        has2[x] = has1[v] || has2[v] || has2[x];\\n        dp[x] += dp[v];\\n        if (has2[v] || dp[v]) {\\n            dp[x] ++;\\n        }\\n    }\\n}\\n```\n```cpp\\nvector<int> cs;\\n\\nvector<int> adj[30005];\\n\\nint dp[30005];\\nbool has0[30005];\\nbool has1[30005];\\nbool has2[30005];\\nint pa[30005];\\nint dpth[30005];\\n\\nvoid dfsinit(int x, int p) {\\n    dp[x] = 0;\\n    pa[x] = p;\\n    if (p == -1) dpth[x] = 0;\\n    else dpth[x] = dpth[p] + 1;\\n    has0[x] = cs[x];\\n    has1[x] = false;\\n    has2[x] = false;\\n    for (auto v: adj[x]) {\\n        if (v == p) continue;\\n        dfsinit(v, x);\\n        has1[x] = has0[v] || has1[v] || has1[x];\\n        has2[x] = has1[v] || has2[v] || has2[x];\\n        dp[x] += dp[v];\\n        if (has2[v] || dp[v]) {\\n            dp[x] ++;\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        cs = coins;\\n        int N = coins.size();\\n        for (int i = 0; i < N; i ++) {\\n            adj[i].clear();\\n            has0[i] = false;\\n            has1[i] = false;\\n            has2[i] = false;\\n            dp[i] = 0;\\n        }\\n        for (auto &v: edges) {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        \\n        dfsinit(0, -1);\\n        int tot = 0;\\n        int mxdpt = 0, mxidx = -1;\\n        \\n        for (int i = 0; i < N; i ++) {\\n            if (cs[i] && mxdpt < dpth[i]) {\\n                mxdpt = dpth[i];\\n                mxidx = i;\\n            }\\n        }\\n        \\n        if (mxidx == -1 || pa[mxidx] == -1 || pa[pa[mxidx]] == -1 || pa[pa[pa[mxidx]]] == -1) {\\n            return 0;\\n        }\\n        \\n        int now = pa[pa[mxidx]];\\n        \\n        dfsinit(now, -1);\\n        \\n        return dp[now] * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342306,
                "title": "tree-dp-seems-unncessary",
                "content": "# Intuition\\n1. We can delete the leaf nodes without coin since we\\'ll never go there.\\n2. Now all the leafs have coins.  It\\'s never optimal to take any leafs as the start node.\\n3. To collect a coin at a leaf, starting at any other nodes with distance longer than 2 with it is the same as starting at the nodes with distance exactly 2. (The grand son node).\\n4. To be simpler we can take a node as the root. So we only need to consider start nodes at its descendant and grand son node.\\n5. Let dp[x] be the minimal number of edges to start from node x and collect all the coins in the subtree rooted at x and go back to x (note since each leafs have a coin, we need to \"go down\" from x).\\ndp[x] = sum(dp[y] + 2) (we have to go down more than 2 edges from its descendant y)\\n6. Since root is a leaf, as 4 mentioned we should consider the answer of dp[x] and dp[y] where x is its descendant and y is root\\'s grand son which is x\\'s descendant.\\n7. To consider starting from x, the answer is just dp[x] since x can cover root with out extra cost.\\n8. Starting from y is better than x only when we don\\'t need to go x (and its other descendant) from y, meaning without the y-branch the x\\'s other branches (if any) should only be single nodes so that y can cover them. In other words, all x\\'s branches other than y should be single nodes, this can be checked by keeping the maximum and 2nd maximum \"go down\". distance.\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(int x, int f, const vector<unordered_set<int>> &con, int d, vector<int> &dp, vector<int> &dep) {\\n        dep[x] = d;\\n        for (int y : con[x]) {\\n            if (y != f) {\\n                dfs(y, x, con, d + 1, dp, dep);\\n                dep[x] = max(dep[x], dep[y]);\\n                if (dep[y] > d + 2) {\\n                    dp[x] += dp[y] + 2;\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int sum = 0;\\n        for (int x : coins) {\\n            sum += x;\\n        }\\n        if (sum < 2) {\\n            return 0;\\n        }\\n        const int n = coins.size();\\n        vector<unordered_set<int>> con(n);\\n        for (const auto& e : edges) {\\n            con[e[0]].insert(e[1]);\\n            con[e[1]].insert(e[0]);\\n        }\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            if (con[i].size() == 1) {\\n                q.push(i);\\n            }\\n        }\\n        while (!q.empty()) {\\n            const int x = q.front();\\n            q.pop();\\n            if (coins[x] == 0) {\\n                const int y = *con[x].begin();\\n                con[x].clear();\\n                con[y].erase(x);\\n                if (con[y].size() == 1) {\\n                    q.push(y);\\n                }\\n            }  \\n        }\\n        int root = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (con[i].size() == 1) {\\n                root = i;\\n                break;\\n            }\\n        }\\n        vector<int> dp(n), dep(n);\\n        dfs(root, -1, con, 0, dp, dep);\\n        const int x = *con[root].begin();\\n        int r = dp[x];\\n        int max1 = -1, max2 = -1;\\n        for (int y : con[x]) {\\n            if (y != root) {\\n                if (dep[y] > max1) {\\n                    max2 = max1;\\n                    max1 = dep[y];\\n                } else if (dep[y] > max2) {\\n                    max2 = dep[y];\\n                }\\n            }\\n        }\\n        if (max2 > 2) {\\n            return r;\\n        }\\n        for (int y : con[x]) {\\n            if ((y != root) && (dep[y] == max1 ? max2 : max1) <= 2) {\\n                r = min(r, dp[y]);\\n            }\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int x, int f, const vector<unordered_set<int>> &con, int d, vector<int> &dp, vector<int> &dep) {\\n        dep[x] = d;\\n        for (int y : con[x]) {\\n            if (y != f) {\\n                dfs(y, x, con, d + 1, dp, dep);\\n                dep[x] = max(dep[x], dep[y]);\\n                if (dep[y] > d + 2) {\\n                    dp[x] += dp[y] + 2;\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int sum = 0;\\n        for (int x : coins) {\\n            sum += x;\\n        }\\n        if (sum < 2) {\\n            return 0;\\n        }\\n        const int n = coins.size();\\n        vector<unordered_set<int>> con(n);\\n        for (const auto& e : edges) {\\n            con[e[0]].insert(e[1]);\\n            con[e[1]].insert(e[0]);\\n        }\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            if (con[i].size() == 1) {\\n                q.push(i);\\n            }\\n        }\\n        while (!q.empty()) {\\n            const int x = q.front();\\n            q.pop();\\n            if (coins[x] == 0) {\\n                const int y = *con[x].begin();\\n                con[x].clear();\\n                con[y].erase(x);\\n                if (con[y].size() == 1) {\\n                    q.push(y);\\n                }\\n            }  \\n        }\\n        int root = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (con[i].size() == 1) {\\n                root = i;\\n                break;\\n            }\\n        }\\n        vector<int> dp(n), dep(n);\\n        dfs(root, -1, con, 0, dp, dep);\\n        const int x = *con[root].begin();\\n        int r = dp[x];\\n        int max1 = -1, max2 = -1;\\n        for (int y : con[x]) {\\n            if (y != root) {\\n                if (dep[y] > max1) {\\n                    max2 = max1;\\n                    max1 = dep[y];\\n                } else if (dep[y] > max2) {\\n                    max2 = dep[y];\\n                }\\n            }\\n        }\\n        if (max2 > 2) {\\n            return r;\\n        }\\n        for (int y : con[x]) {\\n            if ((y != root) && (dep[y] == max1 ? max2 : max1) <= 2) {\\n                r = min(r, dp[y]);\\n            }\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342216,
                "title": "interesting-solution-without-trimming-doesn-t-work-on-last-test-case",
                "content": "NOTE: unfortunately, this solution doesn\\'t work because of test case 4981/4982 specifically made to break this solution. It is a star shape with 30000 nodes, which breaks all caching.\\n\\nStill sharing the solution here because I think it\\'s pretty interesting :).\\n\\n# Intuition\\nWe can do bottom up dfs to solve this problem, with caching. \\n\\n\\n# Approach\\nThink of each node as having debt which needs to be paid off before you start counting nodes. This debt starts at infinite but is set to -2 when there is a coin.\\n\\nEvery time you come back up from a child, the debt (or cost if positive) incremented by 1 to indicate having to travel towards the child.\\nWe return cost if it is positive, indicating debt is completely paid, else we return the debt.\\n\\nIn the end, we find the minimum cost and double it\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ average case, $$O(n^2)$$ worst case when it\\'s a star or whenever one node has most of the edges.\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\\n        n = len(coins)\\n        adj = [[] for _ in range(n)]\\n        for i, j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n\\n        @cache\\n        def dfs(curr, prev):\\n            debt = -2 if coins[curr] else -float(\\'inf\\')\\n            cost = 0\\n            for nxt in adj[curr]:\\n                if nxt != prev:\\n                    childcost = dfs(nxt, curr)\\n                    debt = max(debt, childcost + 1)\\n                    cost += max(childcost + 1, 0)\\n            return cost if cost > 0 else debt\\n        res = min((dfs(i, -1) for i in range(n)))\\n        return max(2*res, 0)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```python\\nclass Solution:\\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\\n        n = len(coins)\\n        adj = [[] for _ in range(n)]\\n        for i, j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n\\n        @cache\\n        def dfs(curr, prev):\\n            debt = -2 if coins[curr] else -float(\\'inf\\')\\n            cost = 0\\n            for nxt in adj[curr]:\\n                if nxt != prev:\\n                    childcost = dfs(nxt, curr)\\n                    debt = max(debt, childcost + 1)\\n                    cost += max(childcost + 1, 0)\\n            return cost if cost > 0 else debt\\n        res = min((dfs(i, -1) for i in range(n)))\\n        return max(2*res, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086966,
                "title": "c-dfs-bfs-readable-well-commented-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSImplify the tree by marking all the nodes that don\\'t need to be visited. Traverse (BFS) the subtree of all must-visit nodes with the limit of passing each edge only once per direection and count # of steps.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Four types of nodes don\\'t need to be visited at all:\\n- Leaf Node: connected with only one edge. We can grab their coins distantly.\\n- Dead Node: consecutive coinless nodes starting from a coinless leaf. We also call the coinless sequnce a dead branch.\\n- New Leaf Node: dead branches can be trimmed/disabled. They can be treated as invisibile/non-existent. After trimming, we will generate new leaf nodes.\\n- Palm Node: non-leaf nodes that has only one non-leaf neighbors and all the rest neighbors are leaf nodes. Their coins can also be grabbed distantly.\\n2. Do DFS from each coinless leaf to disable all dead nodes of these dead branches. Mark all the nodes that become new leaf nodes. Then we can find and mark all palm nodes.\\n3. Start BFS from any qualified vertice to traverse the subtree consisting of non-leaf/palm/dead nodes and count the # of steps. Each edge should only be  passed once per direction for optimal result. We set up a count-down counter for each edge. The initial value is 1. After all counters are depleted to 0, the BFS should be back to the start vertice again and we conclude the BFS.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nstruct Node{\\n    vector<vector<int>> nb; \\n     //nb[i][0] is nb index and nb[i][1] is the # of times allowed for \\n     //jumping from i to nb[i][0], we call it a jump counter\\n     //nb[i][0] is set to 1 at the begning, that means each edge can be used only twice \\n     //(one for a driection, the other for the oppositie direction)\\n     // During BFS when all the jump counters of all necessary nodes(all nodes minus untouchable nodes like leaf,palm, dead branch nodes)\\n     //are depleted, that means the end of the BFS\\n     //and the BFS should be back to the starting vertice\\n    bool leaf=false; //whether it is a leaf node   \\n    //we don\\'t need to visit leaf nodes cuz we can grab coins distantly\\n    bool palm =false; //palm node means n-1 of n nb nodes are leaf nodes\\n    //it should not be visited cuz we can grab coins two steps ahead.\\n    bool disabled=false;// true if the node is on  a dead branch\\n};\\n\\nclass Solution {\\npublic:\\n    int currSum=0;\\n    int start=-1; //could be any non-disabled non-leaf/palm node\\n    //such a node doesn\\'t exist that means it is a tiny tree and we don\\'t need to move at all\\n    deque<int> q; //waiting list for nodes to be processed\\n    set<int> v;// all visited nodes\\n    bool MC=false;// Mission completed. Signal to start return trip\\n    //for DFS_DB that trim(disable) nodes on dead branches\\n    set<int> vl;// list of visited  nodes\\n    void DFS_DB(vector<Node>& N,vector<int>& coins,int i){ //disable all nodes on a dead branch \\n        if(vl.find(i)!=vl.end()){return;} //already visited\\n        int c=0; //count active nb nodes\\n        int next=0;//next node index\\n        // a new leaf?\\n        for(auto x:N[i].nb){\\n            if(!N[x[0]].disabled){c++;next=x[0];}\\n        }\\n        //if atmost one neighbor is not dead node, this node can be seen as a new leaf after trimming dead branches \\n        // cout<<\"Enter Node: \"<<i<<endl;\\n\\n        if(c==1){N[i].leaf=true;} \\n        //Only proceed the DFS when the current node is a new dead coinless leaf \\n        //That means it has only one available active neighbor as the next\\n        //And the next node must be unvisited so far        \\n        if(coins[i]==0){\\n            if(N[i].leaf){\\n                if((!N[next].disabled)){\\n                    N[i].disabled=true;\\n                    vl.insert(i); //Only register nodes that succesfully jump to next\\n                    //Cuz some intersection nodes need to be visited multiple times\\n                    //before we realize whether it is a new dead leaf or not\\n                    if(vl.find(next)==vl.end()){\\n                        DFS_DB(N,coins,next);\\n                    }\\n                }\\n            }\\n        }\\n \\n     }\\n    void trim_DB(vector<Node>& N,vector<int>& coins){ //detect and trim dead branches        \\n        for(int x=0;x<N.size();x++){\\n            if((N[x].leaf)&&(!N[x].disabled)){\\n                //detect unvsisted coinless leaf\\n                //they are the start points of dead branches\\n                if(coins[x]==0){ \\n                    N[x].disabled=true;\\n                    DFS_DB(N,coins,x);\\n                }\\n            }\\n        }\\n        //update palm nodes as many nodes are seen as leaf nodes after trimming the tree branches\\n        for(int x=0;x<N.size();x++){\\n            int ns=N[x].nb.size();\\n            int c=0; //leaf nb counter\\n            if(ns>1){ //palm node has 2 edges at least\\n                for(auto y:N[x].nb){\\n                    if(N[y[0]].leaf){c++;}\\n                } \\n                if(c>=ns-1){N[x].palm=true;cout<<\"New Palm:\"<<x<<endl;}  \\n            }       \\n        }\\n        //decide starting vertex\\n        for(int i=0;i<N.size();i++){ \\n            if(N[i].palm||N[i].disabled||N[i].leaf){}\\n            else{ \\n                start=i;break;\\n            }  \\n        }\\n    }\\n    void setLeaf(vector<Node>& N){\\n        for(int x=0;x<N.size();x++){\\n            int ns=N[x].nb.size();\\n            if(ns==1){N[x].leaf=true;}         \\n        }\\n    }\\n    void BFS(vector<Node>& N,vector<int>& coins,int i,int prev){\\n        q.pop_front();\\n        v.insert(i);\\n\\n        int nn= -1; //next node to go\\n        int currMax=-1; // max coin gain we can get if moving to a neighbor\\n        bool is_p= false; //is going back to the previous node an available backup option\\n        bool chosen=false; // a prefered node has been chosen as next, no need to replace it\\n        for(auto x:N[i].nb){\\n            if((x[1]>0)&&(!N[x[0]].disabled)){ //unused edge (for the particular direction ) and not dead\\n                if((!N[x[0]].leaf)&&(!N[x[0]].palm)){ //Don\\'t move to leaf or palm\\n                    if(x[0]!=prev){ \\n                        nn=x[0];\\n                        if(v.find(x[0])==v.end()){break;} //prefer unvisited path at crossroad\\n                    }else{is_p=true;}   // previous node is an available back up option for the next step             \\n                }\\n            }            \\n        }\\n        if((nn==-1)&&is_p){nn=prev;} //no other choice, have to turn back \\n        for(int y=0; y<N[i].nb.size();y++){    \\n            if(N[i].nb[y][0]==nn){\\n                N[i].nb[y][1]--;// update jump counter\\n            } \\n        }\\n        if(nn>=0){q.push_front(nn);}\\n    }\\n\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int s=coins.size();\\n        vector<Node> N(s) ;\\n        //Initialize nodes\\' neighbor lists\\n        for(auto x:edges){\\n            N[x[0]].nb.push_back({x[1],1});\\n            N[x[1]].nb.push_back({x[0],1});\\n        }\\n        //set leaf nodes\\n        setLeaf(N);\\n        //Run DFS from coinless leaf nodes to detect dead branches and disable dead nodes\\n        //disabled nodes can be seen as trimmed/removded/non-exisitent\\n        //therefore anyone connected to these disbaled nodes can be new leaf nodes\\n        //after we figure out all the leaf nodes and the disabled nodes\\n        //we can begin to set palm nodes(with >=2 edges) whose N-1 of all N nb nodes are leaf nodes\\n        trim_DB(N,coins);\\n        if(start==-1){return 0;}//tiny tree\\n        \\n        //After trim_DB(), we got a subtree of all must-visit nodes\\n        //We will do BFS across the subtree from the start vertice\\n        //until all the jump counters of the subtree nodes are depleted\\n        //That also means we finsih the jon and is back to the start vectice.\\n        //Cuz each edge can only be used once per direction, with the constraint of  jump counter.\\n        int ans=0;\\n        int currMin=INT_MAX; //min path length\\n        int len=0; //# of steps of current BFS\\n        int i= start;   \\n        q.push_front(i);\\n        int prev=i;\\n        while(!q.empty()){        \\n            for(auto x:q){\\n                // cout<<endl<<\"enter node \"<<x;\\n                BFS(N,coins,x,prev);\\n                len++;\\n                prev=x;\\n            }\\n        }\\n        len --; //cuz visiting the start node shoudn\\'t count distance                    \\n        currMin= min(len,currMin);\\n        if(len==currMin){ans=len;}//shortest path so far     \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nstruct Node{\\n    vector<vector<int>> nb; \\n     //nb[i][0] is nb index and nb[i][1] is the # of times allowed for \\n     //jumping from i to nb[i][0], we call it a jump counter\\n     //nb[i][0] is set to 1 at the begning, that means each edge can be used only twice \\n     //(one for a driection, the other for the oppositie direction)\\n     // During BFS when all the jump counters of all necessary nodes(all nodes minus untouchable nodes like leaf,palm, dead branch nodes)\\n     //are depleted, that means the end of the BFS\\n     //and the BFS should be back to the starting vertice\\n    bool leaf=false; //whether it is a leaf node   \\n    //we don\\'t need to visit leaf nodes cuz we can grab coins distantly\\n    bool palm =false; //palm node means n-1 of n nb nodes are leaf nodes\\n    //it should not be visited cuz we can grab coins two steps ahead.\\n    bool disabled=false;// true if the node is on  a dead branch\\n};\\n\\nclass Solution {\\npublic:\\n    int currSum=0;\\n    int start=-1; //could be any non-disabled non-leaf/palm node\\n    //such a node doesn\\'t exist that means it is a tiny tree and we don\\'t need to move at all\\n    deque<int> q; //waiting list for nodes to be processed\\n    set<int> v;// all visited nodes\\n    bool MC=false;// Mission completed. Signal to start return trip\\n    //for DFS_DB that trim(disable) nodes on dead branches\\n    set<int> vl;// list of visited  nodes\\n    void DFS_DB(vector<Node>& N,vector<int>& coins,int i){ //disable all nodes on a dead branch \\n        if(vl.find(i)!=vl.end()){return;} //already visited\\n        int c=0; //count active nb nodes\\n        int next=0;//next node index\\n        // a new leaf?\\n        for(auto x:N[i].nb){\\n            if(!N[x[0]].disabled){c++;next=x[0];}\\n        }\\n        //if atmost one neighbor is not dead node, this node can be seen as a new leaf after trimming dead branches \\n        // cout<<\"Enter Node: \"<<i<<endl;\\n\\n        if(c==1){N[i].leaf=true;} \\n        //Only proceed the DFS when the current node is a new dead coinless leaf \\n        //That means it has only one available active neighbor as the next\\n        //And the next node must be unvisited so far        \\n        if(coins[i]==0){\\n            if(N[i].leaf){\\n                if((!N[next].disabled)){\\n                    N[i].disabled=true;\\n                    vl.insert(i); //Only register nodes that succesfully jump to next\\n                    //Cuz some intersection nodes need to be visited multiple times\\n                    //before we realize whether it is a new dead leaf or not\\n                    if(vl.find(next)==vl.end()){\\n                        DFS_DB(N,coins,next);\\n                    }\\n                }\\n            }\\n        }\\n \\n     }\\n    void trim_DB(vector<Node>& N,vector<int>& coins){ //detect and trim dead branches        \\n        for(int x=0;x<N.size();x++){\\n            if((N[x].leaf)&&(!N[x].disabled)){\\n                //detect unvsisted coinless leaf\\n                //they are the start points of dead branches\\n                if(coins[x]==0){ \\n                    N[x].disabled=true;\\n                    DFS_DB(N,coins,x);\\n                }\\n            }\\n        }\\n        //update palm nodes as many nodes are seen as leaf nodes after trimming the tree branches\\n        for(int x=0;x<N.size();x++){\\n            int ns=N[x].nb.size();\\n            int c=0; //leaf nb counter\\n            if(ns>1){ //palm node has 2 edges at least\\n                for(auto y:N[x].nb){\\n                    if(N[y[0]].leaf){c++;}\\n                } \\n                if(c>=ns-1){N[x].palm=true;cout<<\"New Palm:\"<<x<<endl;}  \\n            }       \\n        }\\n        //decide starting vertex\\n        for(int i=0;i<N.size();i++){ \\n            if(N[i].palm||N[i].disabled||N[i].leaf){}\\n            else{ \\n                start=i;break;\\n            }  \\n        }\\n    }\\n    void setLeaf(vector<Node>& N){\\n        for(int x=0;x<N.size();x++){\\n            int ns=N[x].nb.size();\\n            if(ns==1){N[x].leaf=true;}         \\n        }\\n    }\\n    void BFS(vector<Node>& N,vector<int>& coins,int i,int prev){\\n        q.pop_front();\\n        v.insert(i);\\n\\n        int nn= -1; //next node to go\\n        int currMax=-1; // max coin gain we can get if moving to a neighbor\\n        bool is_p= false; //is going back to the previous node an available backup option\\n        bool chosen=false; // a prefered node has been chosen as next, no need to replace it\\n        for(auto x:N[i].nb){\\n            if((x[1]>0)&&(!N[x[0]].disabled)){ //unused edge (for the particular direction ) and not dead\\n                if((!N[x[0]].leaf)&&(!N[x[0]].palm)){ //Don\\'t move to leaf or palm\\n                    if(x[0]!=prev){ \\n                        nn=x[0];\\n                        if(v.find(x[0])==v.end()){break;} //prefer unvisited path at crossroad\\n                    }else{is_p=true;}   // previous node is an available back up option for the next step             \\n                }\\n            }            \\n        }\\n        if((nn==-1)&&is_p){nn=prev;} //no other choice, have to turn back \\n        for(int y=0; y<N[i].nb.size();y++){    \\n            if(N[i].nb[y][0]==nn){\\n                N[i].nb[y][1]--;// update jump counter\\n            } \\n        }\\n        if(nn>=0){q.push_front(nn);}\\n    }\\n\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int s=coins.size();\\n        vector<Node> N(s) ;\\n        //Initialize nodes\\' neighbor lists\\n        for(auto x:edges){\\n            N[x[0]].nb.push_back({x[1],1});\\n            N[x[1]].nb.push_back({x[0],1});\\n        }\\n        //set leaf nodes\\n        setLeaf(N);\\n        //Run DFS from coinless leaf nodes to detect dead branches and disable dead nodes\\n        //disabled nodes can be seen as trimmed/removded/non-exisitent\\n        //therefore anyone connected to these disbaled nodes can be new leaf nodes\\n        //after we figure out all the leaf nodes and the disabled nodes\\n        //we can begin to set palm nodes(with >=2 edges) whose N-1 of all N nb nodes are leaf nodes\\n        trim_DB(N,coins);\\n        if(start==-1){return 0;}//tiny tree\\n        \\n        //After trim_DB(), we got a subtree of all must-visit nodes\\n        //We will do BFS across the subtree from the start vertice\\n        //until all the jump counters of the subtree nodes are depleted\\n        //That also means we finsih the jon and is back to the start vectice.\\n        //Cuz each edge can only be used once per direction, with the constraint of  jump counter.\\n        int ans=0;\\n        int currMin=INT_MAX; //min path length\\n        int len=0; //# of steps of current BFS\\n        int i= start;   \\n        q.push_front(i);\\n        int prev=i;\\n        while(!q.empty()){        \\n            for(auto x:q){\\n                // cout<<endl<<\"enter node \"<<x;\\n                BFS(N,coins,x,prev);\\n                len++;\\n                prev=x;\\n            }\\n        }\\n        len --; //cuz visiting the start node shoudn\\'t count distance                    \\n        currMin= min(len,currMin);\\n        if(len==currMin){ans=len;}//shortest path so far     \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4000766,
                "title": "c-two-time-bfs-trimming-down-the-tree",
                "content": "LOGIC:\\nThe logic is that we will ignoring the leaf nodes which do not have coins\\nSo we remove those nodes \\nInitially rem = n (num of nodes)\\nAfter removing one node\\n\\nrem--\\n\\n\\nNow , we again store the leaf nodes which have indegree as 1 and \\nalso contains coins \\n\\nWe will now run a for loop two times\\nand run a multisource BFS for the nodes stored in queue\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n = coins.size();\\n        vector<vector<int>> adj(n);\\n        vector<int> ind(n , 0);\\n        if(edges.size() == 0) return 0;\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n            ind[it[1]]++;\\n            ind[it[0]]++;\\n        }\\n        queue<int> q;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(adj[i].size()== 1 and coins[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        int rem = n;\\n        while(q.size()){\\n            //trim down the tree\\n            int node = q.front();\\n            q.pop();\\n            for(auto it : adj[node]){\\n                //it will have the node \\n                if(ind[it]>=1){\\n                    ind[it]--;\\n                    if(ind[it]==1 and coins[it] == 0){\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            ind[node] = 0;//removed the node from the graph\\n            rem--;\\n\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(ind[i] == 1 and coins[i]==1){\\n                q.push(i);\\n            }\\n        }\\n        //now remove 2 more nodes from the leaf nodes\\n\\n        for(int i = 0;i<2;i++)\\n        {\\n            //run two times multusource BFS\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node]){\\n                        if(ind[it]>=1){\\n                            ind[it]--;\\n                            if(ind[it] == 1){\\n                                q.push(it);\\n                            }\\n                        }\\n                    }\\n                    rem--;\\n                    //\\n                    ind[node] = 0;\\n            }\\n\\n        }\\n        //if there are n node (n-1) edges then (2*(n-1)) remain \\n        if(rem-1 < 0) return 0;\\n        return (2*(rem-1));\\n\\n\\n        //after deleting all those nodes we are left with rem node\\n        //Hence we have rem-1 edges\\n        //we need to come back to the edges\\n        //so 2*(rem-1) moves are required \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n = coins.size();\\n        vector<vector<int>> adj(n);\\n        vector<int> ind(n , 0);\\n        if(edges.size() == 0) return 0;\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n            ind[it[1]]++;\\n            ind[it[0]]++;\\n        }\\n        queue<int> q;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(adj[i].size()== 1 and coins[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        int rem = n;\\n        while(q.size()){\\n            //trim down the tree\\n            int node = q.front();\\n            q.pop();\\n            for(auto it : adj[node]){\\n                //it will have the node \\n                if(ind[it]>=1){\\n                    ind[it]--;\\n                    if(ind[it]==1 and coins[it] == 0){\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            ind[node] = 0;//removed the node from the graph\\n            rem--;\\n\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(ind[i] == 1 and coins[i]==1){\\n                q.push(i);\\n            }\\n        }\\n        //now remove 2 more nodes from the leaf nodes\\n\\n        for(int i = 0;i<2;i++)\\n        {\\n            //run two times multusource BFS\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto it : adj[node]){\\n                        if(ind[it]>=1){\\n                            ind[it]--;\\n                            if(ind[it] == 1){\\n                                q.push(it);\\n                            }\\n                        }\\n                    }\\n                    rem--;\\n                    //\\n                    ind[node] = 0;\\n            }\\n\\n        }\\n        //if there are n node (n-1) edges then (2*(n-1)) remain \\n        if(rem-1 < 0) return 0;\\n        return (2*(rem-1));\\n\\n\\n        //after deleting all those nodes we are left with rem node\\n        //Hence we have rem-1 edges\\n        //we need to come back to the edges\\n        //so 2*(rem-1) moves are required \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956564,
                "title": "java-clean-code-easy",
                "content": "1. Create graph \\n2. Remove indegree 1 node (non-coin)\\n3. Remove their subtree \\n4. Handle coin node \\n5. Remove child and parent nodes\\n\\n![image](https://assets.leetcode.com/users/images/571ede75-737e-4aa4-9a17-0ab4ad7448c6_1692929403.563342.png)\\n\\n\\n```\\npublic int collectTheCoins(int[] coins, int[][] edges) {\\n        \\n        int n = edges.length;\\n        ArrayList<HashSet<Integer>> g = new ArrayList<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        int totalEdges = 2*n;\\n        int deletedEdges = 0;\\n        \\n        //Part I: Create Graph\\n        for(int i=0;i<=n;i++){\\n            g.add(new HashSet<Integer>());\\n        }\\n        for(int i=0;i<n;i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            g.get(a).add(b);\\n            g.get(b).add(a);\\n        }\\n        \\n        //Part II: Find Element whose indegree is 1 and not a coin\\n        for(int i=0;i<=n;i++){\\n            if(g.get(i).size() == 1 && coins[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        // Remove subtree which is not required\\n        while(!q.isEmpty()){\\n            int curr = q.remove();\\n            if(g.get(curr).size() == 0){\\n                continue;\\n            }\\n            int p = g.get(curr).iterator().next(); // set will have only 1 element \\n            g.get(curr).remove(p);\\n            g.get(p).remove(curr);\\n            if(g.get(p).size() == 1 && coins[p] == 0){\\n                q.add(p);\\n            }\\n            deletedEdges += 2;\\n        }\\n        \\n        // Part III: Include all leaf nodes (with coins)\\n        for(int i=0;i<=n;i++){\\n            if(g.get(i).size() == 1){\\n                q.add(i);\\n            }\\n        }\\n        // remove coin node and it\\'s parent basis on their indegree\\n        int size = 2; // for removing child then parent edges\\n        while(size>0){\\n            size--;\\n            int qSize = q.size();\\n            while(qSize>0){\\n                qSize--;\\n                \\n                int curr = q.remove();\\n                if(g.get(curr).size() == 0){\\n                    continue;\\n                }\\n                \\n                int p = g.get(curr).iterator().next();\\n                g.get(curr).remove(p);\\n                g.get(p).remove(curr);\\n                \\n                if(g.get(p).size() == 1){\\n                    q.add(p);\\n                }\\n                deletedEdges += 2;\\n            }\\n        }\\n        \\n        \\n        return totalEdges - deletedEdges;\\n        \\n    }\\n```\\n\\nTime Complexity:\\n\\nCreating the graph: O(n), where n is the number of edges.\\nFirst loop (Part II) to find elements with indegree 1 and not a coin: O(n)\\nSecond loop (Part II) to remove unnecessary edges and nodes: O(n)\\nThird loop (Part III) to include leaf nodes with coins and remove nodes: O(n)\\nInner loops inside Part III: O(n) (In the worst case, all nodes can be added to the queue and then processed, but the number of iterations decreases with each step)\\nOverall, the time complexity is O(n).\\n\\nSpace Complexity:\\n\\ng ArrayList of HashSets: O(n) - This stores the adjacency list representation of the graph.\\nq Queue: O(n) - In the worst case, all nodes might be added to the queue.\\nOther integer variables: O(1) - These occupy constant space.",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\npublic int collectTheCoins(int[] coins, int[][] edges) {\\n        \\n        int n = edges.length;\\n        ArrayList<HashSet<Integer>> g = new ArrayList<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        int totalEdges = 2*n;\\n        int deletedEdges = 0;\\n        \\n        //Part I: Create Graph\\n        for(int i=0;i<=n;i++){\\n            g.add(new HashSet<Integer>());\\n        }\\n        for(int i=0;i<n;i++){\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            g.get(a).add(b);\\n            g.get(b).add(a);\\n        }\\n        \\n        //Part II: Find Element whose indegree is 1 and not a coin\\n        for(int i=0;i<=n;i++){\\n            if(g.get(i).size() == 1 && coins[i] == 0){\\n                q.add(i);\\n            }\\n        }\\n        \\n        // Remove subtree which is not required\\n        while(!q.isEmpty()){\\n            int curr = q.remove();\\n            if(g.get(curr).size() == 0){\\n                continue;\\n            }\\n            int p = g.get(curr).iterator().next(); // set will have only 1 element \\n            g.get(curr).remove(p);\\n            g.get(p).remove(curr);\\n            if(g.get(p).size() == 1 && coins[p] == 0){\\n                q.add(p);\\n            }\\n            deletedEdges += 2;\\n        }\\n        \\n        // Part III: Include all leaf nodes (with coins)\\n        for(int i=0;i<=n;i++){\\n            if(g.get(i).size() == 1){\\n                q.add(i);\\n            }\\n        }\\n        // remove coin node and it\\'s parent basis on their indegree\\n        int size = 2; // for removing child then parent edges\\n        while(size>0){\\n            size--;\\n            int qSize = q.size();\\n            while(qSize>0){\\n                qSize--;\\n                \\n                int curr = q.remove();\\n                if(g.get(curr).size() == 0){\\n                    continue;\\n                }\\n                \\n                int p = g.get(curr).iterator().next();\\n                g.get(curr).remove(p);\\n                g.get(p).remove(curr);\\n                \\n                if(g.get(p).size() == 1){\\n                    q.add(p);\\n                }\\n                deletedEdges += 2;\\n            }\\n        }\\n        \\n        \\n        return totalEdges - deletedEdges;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3883289,
                "title": "c-intuitive",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n=coins.size();\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n,0);\\n        int number=edges.size();\\n        for(auto edge:edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n            indegree[edge[0]]++;\\n            indegree[edge[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==1 && !coins[i]){\\n                q.push(i);\\n                indegree[i]=0;\\n            }\\n        }\\n        while(!q.empty()){\\n            auto curr=q.front();\\n            q.pop();\\n            number--;\\n            for(auto x:graph[curr]){\\n                indegree[x]--;\\n                if(indegree[x]==1 && !coins[x]){\\n                    q.push(x);\\n                    indegree[x]=0;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==1)q.push(i);\\n        }\\n        int a=0;\\n        while(a<2){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                auto curr=q.front();\\n                q.pop();\\n                number--;\\n                for(auto x:graph[curr]){\\n                    indegree[x]--;\\n                    if(indegree[x]==1)q.push(x);\\n                }\\n            }\\n            a++;\\n        }\\n        return max(0,number*2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n=coins.size();\\n        vector<vector<int>> graph(n);\\n        vector<int> indegree(n,0);\\n        int number=edges.size();\\n        for(auto edge:edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n            indegree[edge[0]]++;\\n            indegree[edge[1]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==1 && !coins[i]){\\n                q.push(i);\\n                indegree[i]=0;\\n            }\\n        }\\n        while(!q.empty()){\\n            auto curr=q.front();\\n            q.pop();\\n            number--;\\n            for(auto x:graph[curr]){\\n                indegree[x]--;\\n                if(indegree[x]==1 && !coins[x]){\\n                    q.push(x);\\n                    indegree[x]=0;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(indegree[i]==1)q.push(i);\\n        }\\n        int a=0;\\n        while(a<2){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                auto curr=q.front();\\n                q.pop();\\n                number--;\\n                for(auto x:graph[curr]){\\n                    indegree[x]--;\\n                    if(indegree[x]==1)q.push(x);\\n                }\\n            }\\n            a++;\\n        }\\n        return max(0,number*2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784232,
                "title": "delete-the-invalid-coins-leaf-node-topological-sort-bfs-graph-tc-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N+E) - size of nodes+edges\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N+E) =  queue O(n)+ indegree O(n) + adj**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n=coins.size();\\n        queue<int>q;\\n        vector<int>adj[n],indG(n,0);\\n        for(auto it:edges)\\n       {\\n           adj[it[0]].push_back(it[1]);\\n           adj[it[1]].push_back(it[0]);\\n           indG[it[0]]++;\\n           indG[it[1]]++;\\n       }\\n    // delete the leaf node with \\'o\\' coin //\\n\\n     for(int i=0;i<n;++i)\\n     {\\n         if(indG[i]==1 && coins[i]==0)\\n         {\\n             q.push(i);\\n         }\\n     }\\n     while(!q.empty())\\n     {\\n         int sz=q.size();\\n         while(sz--)\\n         {\\n             int curN=q.front();\\n             q.pop();\\n             for(auto it:adj[curN])\\n             {   \\n                 if(indG[it]>=1)\\n                 {\\n                 indG[it]--;\\n                 if(indG[it]==1 && coins[it]==0)\\n                 {\\n                     q.push(it);\\n                 }\\n                 }\\n             }\\n             indG[curN]=0;\\n         }\\n\\n     }\\n\\n     // leaf node deleted without having coins //\\n     \\n     /// add those leaf node having coins \\n     for(int i=0;i<n;++i)\\n     {\\n         if(indG[i]==1 && coins[i]==1)\\n         q.push(i);\\n     }\\n     while(!q.empty())\\n     {\\n         int sz=q.size();\\n         while(sz--)\\n         {\\n             int cur=q.front();\\n             q.pop();\\n             for(auto it:adj[cur])\\n             {\\n             \\n                \\n                      indG[it]--;\\n                  \\n                  if(indG[it]==1)\\n                  {\\n                      indG[it]=0;\\n                  }\\n                \\n             }\\n             indG[cur]=0;\\n         }\\n     }\\n     for(auto it:indG)\\n     {\\n         cout<<it<<\" \";\\n     }\\n     int cnt=0;\\n     for(auto it:edges)\\n     {\\n         if(indG[it[0]]>=1 && indG[it[1]]>=1)\\n         {\\n             cnt++;\\n         }\\n     }\\n      return 2*cnt;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n=coins.size();\\n        queue<int>q;\\n        vector<int>adj[n],indG(n,0);\\n        for(auto it:edges)\\n       {\\n           adj[it[0]].push_back(it[1]);\\n           adj[it[1]].push_back(it[0]);\\n           indG[it[0]]++;\\n           indG[it[1]]++;\\n       }\\n    // delete the leaf node with \\'o\\' coin //\\n\\n     for(int i=0;i<n;++i)\\n     {\\n         if(indG[i]==1 && coins[i]==0)\\n         {\\n             q.push(i);\\n         }\\n     }\\n     while(!q.empty())\\n     {\\n         int sz=q.size();\\n         while(sz--)\\n         {\\n             int curN=q.front();\\n             q.pop();\\n             for(auto it:adj[curN])\\n             {   \\n                 if(indG[it]>=1)\\n                 {\\n                 indG[it]--;\\n                 if(indG[it]==1 && coins[it]==0)\\n                 {\\n                     q.push(it);\\n                 }\\n                 }\\n             }\\n             indG[curN]=0;\\n         }\\n\\n     }\\n\\n     // leaf node deleted without having coins //\\n     \\n     /// add those leaf node having coins \\n     for(int i=0;i<n;++i)\\n     {\\n         if(indG[i]==1 && coins[i]==1)\\n         q.push(i);\\n     }\\n     while(!q.empty())\\n     {\\n         int sz=q.size();\\n         while(sz--)\\n         {\\n             int cur=q.front();\\n             q.pop();\\n             for(auto it:adj[cur])\\n             {\\n             \\n                \\n                      indG[it]--;\\n                  \\n                  if(indG[it]==1)\\n                  {\\n                      indG[it]=0;\\n                  }\\n                \\n             }\\n             indG[cur]=0;\\n         }\\n     }\\n     for(auto it:indG)\\n     {\\n         cout<<it<<\" \";\\n     }\\n     int cnt=0;\\n     for(auto it:edges)\\n     {\\n         if(indG[it[0]]>=1 && indG[it[1]]>=1)\\n         {\\n             cnt++;\\n         }\\n     }\\n      return 2*cnt;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3698046,
                "title": "easy-c-code-without-deleting-edges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& c, vector<vector<int>>& e) {\\n        queue<int>q;\\n        int n=c.size();\\n        vector<int>adj[n];\\n        vector<int>indeg(n,0);\\n        for(auto &it:e){\\n          int u=it[0],v=it[1];\\n          indeg[u]++;\\n          indeg[v]++;\\n          adj[u].push_back(v);\\n          adj[v].push_back(u);\\n        }\\n        vector<bool>trim(n,0);\\n        for(int i=0;i<n;i++){\\n          if(indeg[i]==1  and !c[i]) trim[i]=1,q.push(i);\\n        }\\n        while(!q.empty()){\\n          int sz=q.size();\\n          while(sz--){\\n            int node=q.front();q.pop();\\n            for(auto &next:adj[node]){\\n              indeg[next]--;\\n              if(indeg[next]==1 and !c[next])  trim[next]=1,q.push(next);\\n            }\\n          }\\n        }\\n        for(int i=0;i<n;i++){\\n          if(indeg[i]==1  and !trim[i]) trim[i]=1,q.push(i);\\n        }\\n        int sz=q.size();\\n          while(sz--){\\n            int node=q.front();q.pop();\\n            for(auto &next:adj[node]){\\n              indeg[next]--;\\n              if(indeg[next]==1)  trim[next]=1;\\n            }\\n          }\\n          int cnt=0;\\n            for(int i=0;i<n;i++) cnt+=trim[i]==0;\\n            return cnt==0?0:(cnt-1)*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& c, vector<vector<int>>& e) {\\n        queue<int>q;\\n        int n=c.size();\\n        vector<int>adj[n];\\n        vector<int>indeg(n,0);\\n        for(auto &it:e){\\n          int u=it[0],v=it[1];\\n          indeg[u]++;\\n          indeg[v]++;\\n          adj[u].push_back(v);\\n          adj[v].push_back(u);\\n        }\\n        vector<bool>trim(n,0);\\n        for(int i=0;i<n;i++){\\n          if(indeg[i]==1  and !c[i]) trim[i]=1,q.push(i);\\n        }\\n        while(!q.empty()){\\n          int sz=q.size();\\n          while(sz--){\\n            int node=q.front();q.pop();\\n            for(auto &next:adj[node]){\\n              indeg[next]--;\\n              if(indeg[next]==1 and !c[next])  trim[next]=1,q.push(next);\\n            }\\n          }\\n        }\\n        for(int i=0;i<n;i++){\\n          if(indeg[i]==1  and !trim[i]) trim[i]=1,q.push(i);\\n        }\\n        int sz=q.size();\\n          while(sz--){\\n            int node=q.front();q.pop();\\n            for(auto &next:adj[node]){\\n              indeg[next]--;\\n              if(indeg[next]==1)  trim[next]=1;\\n            }\\n          }\\n          int cnt=0;\\n            for(int i=0;i<n;i++) cnt+=trim[i]==0;\\n            return cnt==0?0:(cnt-1)*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509576,
                "title": "clean-concise-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n$$NOTE$$: deleting leaf creates new leaf as we go.\\n\\n$$Approach$$: Trim leaves. \\nWe have the following cases:\\n1. **Leafs don\\'t have any coin** : keep on deleting leafs and don\\'t count operation\\n2. **Leafs have coin** : find the neighbour of the leaf. Pass the coin in the leaf to the neighbour. Also count operation on neighbour\\n3. **Leafs that don\\'t have coin lead to a node with coin through a path** : combination of point 1 and 2. Until a leaf is encountered countinue with point 1. If a leaf with coin is encountered then from that point we continue with point 2.\\n\\n\\nWe can continue these operations only until we have atmost 2 operations on a node(leaf).\\nWhen no more operation can be performed, in that case the we need to traverse the tree from a leaf node to all leaf nodes and come back to initial leaf node from where we started. This is equivalent to ```2*(NumberOfNodesInTree-1)```. This is due to the fact that we traverse each node twice and tree has ```n-1``` number of edges where ```n``` is the number of nodes in the tree.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges ){\\n        int n = coins.size();\\n        vector<set<int>> adj(n);\\n        for( auto& e : edges )\\n            adj[ e[0] ].insert( e[1] ),\\n            adj[ e[1] ].insert( e[0] );\\n        \\n        vector<int> operations(n,0);\\n        queue<int> leafs;\\n\\n        for( int node = 0; node < n; ++node )\\n            if( adj[node].size() == 1 )\\n                leafs.push( node );\\n        \\n        while( !leafs.empty() ){\\n            int cur = leafs.front();    leafs.pop();\\n            \\n            if( operations[cur] < 2 ){\\n                \\n                auto nei = *adj[cur].begin();\\n\\n                if( coins[cur] != 0 )\\n                    operations[nei] = max( operations[nei], operations[cur]+1 );\\n                \\n                coins[nei] += coins[cur];\\n\\n                adj[cur].clear();\\n                adj[nei].erase(cur);\\n\\n                if( adj[nei].size() == 1 )\\n                    leafs.push(nei);\\n            }\\n        }\\n\\n        int nodesLeft = 0;\\n        for( int node = 0; node < n; ++node )\\n            nodesLeft += adj[node].size() != 0;\\n        return nodesLeft != 0 ? 2*(nodesLeft-1):nodesLeft;\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```2*(NumberOfNodesInTree-1)```\n```n-1```\n```n```\n```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges ){\\n        int n = coins.size();\\n        vector<set<int>> adj(n);\\n        for( auto& e : edges )\\n            adj[ e[0] ].insert( e[1] ),\\n            adj[ e[1] ].insert( e[0] );\\n        \\n        vector<int> operations(n,0);\\n        queue<int> leafs;\\n\\n        for( int node = 0; node < n; ++node )\\n            if( adj[node].size() == 1 )\\n                leafs.push( node );\\n        \\n        while( !leafs.empty() ){\\n            int cur = leafs.front();    leafs.pop();\\n            \\n            if( operations[cur] < 2 ){\\n                \\n                auto nei = *adj[cur].begin();\\n\\n                if( coins[cur] != 0 )\\n                    operations[nei] = max( operations[nei], operations[cur]+1 );\\n                \\n                coins[nei] += coins[cur];\\n\\n                adj[cur].clear();\\n                adj[nei].erase(cur);\\n\\n                if( adj[nei].size() == 1 )\\n                    leafs.push(nei);\\n            }\\n        }\\n\\n        int nodesLeft = 0;\\n        for( int node = 0; node < n; ++node )\\n            nodesLeft += adj[node].size() != 0;\\n        return nodesLeft != 0 ? 2*(nodesLeft-1):nodesLeft;\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488329,
                "title": "not-that-fast-but-readable-and-concise",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD83E\\uDEE1: https://leetcode.com/problems/collect-coins-in-a-tree/solutions/3345266/trim-leaves/\\n\\uD83E\\uDEE1: https://leetcode.com/problems/collect-coins-in-a-tree/solutions/3343497/easy-bfs-intuition-explained-o-n-tc-and-sc-trim-c-java/\\n\\n# Complexity\\n- Time complexity: $O(N)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(N)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        for (auto& c : coins) { c *= 3; }\\n\\n        unordered_map<int, unordered_set<int>> graph;\\n        for (auto& e : edges) {\\n            graph[e[0]].insert(e[1]);\\n            graph[e[1]].insert(e[0]);\\n        }\\n\\n        stack<int> populate;\\n        for (auto& n : graph) {\\n            if (n.second.size() == 1) {\\n                populate.push(n.first);\\n            }\\n        }\\n\\n        while (!populate.empty()) {\\n            int idx = populate.top(); populate.pop();\\n            if (coins[idx] == 1 || !graph[idx].size()) {\\n                continue;\\n            }\\n\\n            // node removal\\n            int adj = *(graph[idx].begin()), populatedCoin = max(coins[idx] - 1, 0);\\n            graph[adj].erase(idx);\\n            graph.erase(idx);\\n            coins[adj] = populatedCoin && coins[adj] ? min(populatedCoin, coins[adj]) : (populatedCoin ? populatedCoin : coins[adj]);\\n\\n            if (graph[adj].size() == 1) {\\n                populate.push(adj);\\n            }\\n        }\\n\\n        return max(0, (int)graph.size() - 1) * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        for (auto& c : coins) { c *= 3; }\\n\\n        unordered_map<int, unordered_set<int>> graph;\\n        for (auto& e : edges) {\\n            graph[e[0]].insert(e[1]);\\n            graph[e[1]].insert(e[0]);\\n        }\\n\\n        stack<int> populate;\\n        for (auto& n : graph) {\\n            if (n.second.size() == 1) {\\n                populate.push(n.first);\\n            }\\n        }\\n\\n        while (!populate.empty()) {\\n            int idx = populate.top(); populate.pop();\\n            if (coins[idx] == 1 || !graph[idx].size()) {\\n                continue;\\n            }\\n\\n            // node removal\\n            int adj = *(graph[idx].begin()), populatedCoin = max(coins[idx] - 1, 0);\\n            graph[adj].erase(idx);\\n            graph.erase(idx);\\n            coins[adj] = populatedCoin && coins[adj] ? min(populatedCoin, coins[adj]) : (populatedCoin ? populatedCoin : coins[adj]);\\n\\n            if (graph[adj].size() == 1) {\\n                populate.push(adj);\\n            }\\n        }\\n\\n        return max(0, (int)graph.size() - 1) * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413361,
                "title": "antarnab-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dis2;//antarnab solution\\n    vector<int> sub;\\n    vector<int> dis1;\\n    vector<int> subans;\\n    vector<vector<int>> es;//antarnab solution\\n    vector<int> vs;\\n    int sum = 0;\\n    int n;\\n    int rank = INT_MAX;\\n    int count1(int i, int p) {\\n        int cur = vs[i];\\n        for (auto e : es[i]) {\\n            if (e == p) continue;\\n            cur += vs[e];\\n        }\\n        return cur;//antarnab solution\\n    }\\n    \\n    int count2(int i, int p) {\\n        int cur = vs[i];\\n        int s = cur;\\n        for (auto e : es[i]) {\\n            if (e == p) continue;\\n            cur += count1(e, i);\\n            s += count2(e, i);\\n        }\\n        dis2[i] = cur;\\n        sub[i] = s;\\n        return s;\\n    }\\n    int dfs1(int i, int p) {\\n        int cur = vs[i];\\n        int ans = 0;\\n        for (auto e : es[i]) {\\n            if (e == p) continue;\\n            int v = dfs1(e, i);\\n            if (dis1[e] - cur < sub[e]) {\\n                ans += v + 2;\\n            }\\n        }\\n        subans[i] = ans;\\n        return ans;      \\n    }\\n    \\n    void dfs(int i, int p, int other, int ansp) {\\n        int remain = sum - other;\\n        int base = 0;\\n        int cur = vs[i];\\n        if (p != -1) {\\n            int x = dis1[p] - vs[i];\\n            if (x >= other) {\\n                // no need to search\\n            } else {\\n                base += 2 + ansp;\\n            }\\n        }\\n        int ans = subans[i] + base;\\n        for (auto e : es[i]) {\\n            if (e == p) continue;\\n            int ap = ans;\\n            if (dis1[e] - cur < sub[e]) {\\n                ap -= subans[e] + 2;\\n            }\\n            dfs(e, i, sum - sub[e], ap);\\n        }\\n        rank = min(ans, rank);\\n        return;\\n    } \\n    \\n    int collectTheCoins(vector<int>& cs, vector<vector<int>>& edges) {\\n        vs = cs;\\n        n = cs.size();\\n        es.resize(n);\\n        dis1.resize(n);\\n        sub.resize(n);\\n        dis2.resize(n);\\n        subans.resize(n);\\n        for (auto e : edges) {\\n            int x = e[0];\\n            int y = e[1];\\n            es[x].push_back(y);\\n            es[y].push_back(x);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int cnt = cs[i];\\n            for (auto e : es[i]) cnt += cs[e];\\n            dis1[i] = cnt;\\n        }\\n        for (auto c : cs) sum += c;\\n        count2(0, -1);\\n        dfs1(0, -1);\\n        dfs(0, -1, 0, 0);\\n        return rank;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dis2;//antarnab solution\\n    vector<int> sub;\\n    vector<int> dis1;\\n    vector<int> subans;\\n    vector<vector<int>> es;//antarnab solution\\n    vector<int> vs;\\n    int sum = 0;\\n    int n;\\n    int rank = INT_MAX;\\n    int count1(int i, int p) {\\n        int cur = vs[i];\\n        for (auto e : es[i]) {\\n            if (e == p) continue;\\n            cur += vs[e];\\n        }\\n        return cur;//antarnab solution\\n    }\\n    \\n    int count2(int i, int p) {\\n        int cur = vs[i];\\n        int s = cur;\\n        for (auto e : es[i]) {\\n            if (e == p) continue;\\n            cur += count1(e, i);\\n            s += count2(e, i);\\n        }\\n        dis2[i] = cur;\\n        sub[i] = s;\\n        return s;\\n    }\\n    int dfs1(int i, int p) {\\n        int cur = vs[i];\\n        int ans = 0;\\n        for (auto e : es[i]) {\\n            if (e == p) continue;\\n            int v = dfs1(e, i);\\n            if (dis1[e] - cur < sub[e]) {\\n                ans += v + 2;\\n            }\\n        }\\n        subans[i] = ans;\\n        return ans;      \\n    }\\n    \\n    void dfs(int i, int p, int other, int ansp) {\\n        int remain = sum - other;\\n        int base = 0;\\n        int cur = vs[i];\\n        if (p != -1) {\\n            int x = dis1[p] - vs[i];\\n            if (x >= other) {\\n                // no need to search\\n            } else {\\n                base += 2 + ansp;\\n            }\\n        }\\n        int ans = subans[i] + base;\\n        for (auto e : es[i]) {\\n            if (e == p) continue;\\n            int ap = ans;\\n            if (dis1[e] - cur < sub[e]) {\\n                ap -= subans[e] + 2;\\n            }\\n            dfs(e, i, sum - sub[e], ap);\\n        }\\n        rank = min(ans, rank);\\n        return;\\n    } \\n    \\n    int collectTheCoins(vector<int>& cs, vector<vector<int>>& edges) {\\n        vs = cs;\\n        n = cs.size();\\n        es.resize(n);\\n        dis1.resize(n);\\n        sub.resize(n);\\n        dis2.resize(n);\\n        subans.resize(n);\\n        for (auto e : edges) {\\n            int x = e[0];\\n            int y = e[1];\\n            es[x].push_back(y);\\n            es[y].push_back(x);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int cnt = cs[i];\\n            for (auto e : es[i]) cnt += cs[e];\\n            dis1[i] = cnt;\\n        }\\n        for (auto c : cs) sum += c;\\n        count2(0, -1);\\n        dfs1(0, -1);\\n        dfs(0, -1, 0, 0);\\n        return rank;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392074,
                "title": "a-few-solutions",
                "content": "2-pass BFS prune the tree:\\n\\n1. On the *first* pass we continually prune leaf nodes with value 0 (ie. nodes *without* coins)\\n2. On the *second* pass we prune leaf nodes twice (ie. 2 depths)\\n\\nReturn 2 times the remaining edge count, ie. to return to an arbitrary origin node, we must traverse each remaining edge twice.\\n\\n* Note: the remaining edge count is the remaining node count minus 1, and the remaining node count is the total node count `N` minus the leaf nodes `pruned`\\n\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun collectTheCoins(A: IntArray, E: Array<IntArray>): Int {\\n        var (N, pruned) = Pair(A.size, 0)\\n        var adj = mutableMapOf<Int, MutableSet<Int>>(); for (i in 0 until N) adj[i] = mutableSetOf<Int>()\\n        for ((u, v) in E) {\\n            adj[u]!!.add(v)\\n            adj[v]!!.add(u)\\n        }\\n        fun prune(first: Boolean) {\\n            var q: Queue<Int> = LinkedList<Int>((0 until N).filter{ adj[it]!!.size == 1 }.toList())\\n            var depth = if (first) 123456789 else 2\\n            while (0 < q.size && 0 < depth--) {\\n                var k = q.size\\n                while (0 < k--) {\\n                    var u = q.poll()\\n                    if (first && 0 < A[u])\\n                        continue\\n                    for (v in adj[u]!!) {\\n                        adj[v]!!.remove(u)\\n                        if (adj[v]!!.size == 1)\\n                            q.add(v)\\n                    }\\n                    adj[u]!!.clear(); ++pruned\\n                }\\n            }\\n        }\\n        prune(true)\\n        prune(false)\\n        return 2 * Math.max(0, N - pruned - 1)\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet collectTheCoins = (A, E, N = A.length, pruned = 0) => {\\n    let adj = [...Array(N)].map(_ => new Set());\\n    for (let [u, v] of E) {\\n        adj[u].add(v);\\n        adj[v].add(u);\\n    }\\n    let prune = first => {\\n        let q = [...Array(N).keys()].filter(i => adj[i].size == 1);\\n        let depth = first ? 123456789 : 2;\\n        while (q.length && depth--) {\\n            let k = q.length;\\n            while (k--) {\\n                let u = q.shift();\\n                if (first && A[u])\\n                    continue;\\n                for (let v of adj[u]) {\\n                    adj[v].delete(u);\\n                    if (adj[v].size == 1)\\n                        q.push(v);\\n                }\\n                adj[u].clear(), ++pruned;\\n            }\\n        }\\n    };\\n    prune(true);\\n    prune(false);\\n    return 2 * Math.max(0, N - pruned - 1);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def collectTheCoins(self, A: List[int], E: List[List[int]], pruned = 0) -> int:\\n        N = len(A)\\n        adj = [set() for _ in range(N)]\\n        for u, v in E:\\n            adj[u].add(v)\\n            adj[v].add(u)\\n        def prune(first):\\n            nonlocal pruned\\n            q = deque([i for i in range(N) if len(adj[i]) == 1])\\n            depth = 123456789 if first else 2\\n            while q and depth:\\n                k = len(q)\\n                for _ in range(k):\\n                    u = q.popleft()\\n                    if first and A[u]:\\n                        continue\\n                    for v in adj[u]:\\n                        adj[v].remove(u)\\n                        if len(adj[v]) == 1:\\n                            q.append(v)\\n                    adj[u].clear(); pruned += 1\\n                depth -= 1\\n        prune(True)\\n        prune(False)\\n        return 2 * max(0, N - pruned - 1)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Queue = queue<int>;\\n    using Set = unordered_set<int>;\\n    using Map = unordered_map<int, Set>;\\n    int collectTheCoins(VI& A, VVI& E, Map adj = {}, Queue q = {}, int pruned = 0) {\\n        int N = A.size();\\n        for (auto& edge: E) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n        auto prune = [&](auto first) {\\n            Queue q; for_each(A.begin(), A.end(), [i = -1, &adj, &q](auto& _) mutable { ++i; if (adj[i].size() == 1) q.push(i); });\\n            auto depth = first ? 123456789 : 2;\\n            while (q.size() && depth--) {\\n                int k = q.size();\\n                while (k--) {\\n                    auto u = q.front(); q.pop();\\n                    if (first && A[u])\\n                        continue;\\n                    for (auto v: adj[u]) {\\n                        adj[v].erase(u);\\n                        if (adj[v].size() == 1)\\n                            q.push(v);\\n                    }\\n                    adj[u].clear(), ++pruned;\\n                }\\n            }\\n        };\\n        prune(true);\\n        prune(false);\\n        return 2 * max(0, N - pruned - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun collectTheCoins(A: IntArray, E: Array<IntArray>): Int {\\n        var (N, pruned) = Pair(A.size, 0)\\n        var adj = mutableMapOf<Int, MutableSet<Int>>(); for (i in 0 until N) adj[i] = mutableSetOf<Int>()\\n        for ((u, v) in E) {\\n            adj[u]!!.add(v)\\n            adj[v]!!.add(u)\\n        }\\n        fun prune(first: Boolean) {\\n            var q: Queue<Int> = LinkedList<Int>((0 until N).filter{ adj[it]!!.size == 1 }.toList())\\n            var depth = if (first) 123456789 else 2\\n            while (0 < q.size && 0 < depth--) {\\n                var k = q.size\\n                while (0 < k--) {\\n                    var u = q.poll()\\n                    if (first && 0 < A[u])\\n                        continue\\n                    for (v in adj[u]!!) {\\n                        adj[v]!!.remove(u)\\n                        if (adj[v]!!.size == 1)\\n                            q.add(v)\\n                    }\\n                    adj[u]!!.clear(); ++pruned\\n                }\\n            }\\n        }\\n        prune(true)\\n        prune(false)\\n        return 2 * Math.max(0, N - pruned - 1)\\n    }\\n}\\n```\n```\\nlet collectTheCoins = (A, E, N = A.length, pruned = 0) => {\\n    let adj = [...Array(N)].map(_ => new Set());\\n    for (let [u, v] of E) {\\n        adj[u].add(v);\\n        adj[v].add(u);\\n    }\\n    let prune = first => {\\n        let q = [...Array(N).keys()].filter(i => adj[i].size == 1);\\n        let depth = first ? 123456789 : 2;\\n        while (q.length && depth--) {\\n            let k = q.length;\\n            while (k--) {\\n                let u = q.shift();\\n                if (first && A[u])\\n                    continue;\\n                for (let v of adj[u]) {\\n                    adj[v].delete(u);\\n                    if (adj[v].size == 1)\\n                        q.push(v);\\n                }\\n                adj[u].clear(), ++pruned;\\n            }\\n        }\\n    };\\n    prune(true);\\n    prune(false);\\n    return 2 * Math.max(0, N - pruned - 1);\\n};\\n```\n```\\nclass Solution:\\n    def collectTheCoins(self, A: List[int], E: List[List[int]], pruned = 0) -> int:\\n        N = len(A)\\n        adj = [set() for _ in range(N)]\\n        for u, v in E:\\n            adj[u].add(v)\\n            adj[v].add(u)\\n        def prune(first):\\n            nonlocal pruned\\n            q = deque([i for i in range(N) if len(adj[i]) == 1])\\n            depth = 123456789 if first else 2\\n            while q and depth:\\n                k = len(q)\\n                for _ in range(k):\\n                    u = q.popleft()\\n                    if first and A[u]:\\n                        continue\\n                    for v in adj[u]:\\n                        adj[v].remove(u)\\n                        if len(adj[v]) == 1:\\n                            q.append(v)\\n                    adj[u].clear(); pruned += 1\\n                depth -= 1\\n        prune(True)\\n        prune(False)\\n        return 2 * max(0, N - pruned - 1)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Queue = queue<int>;\\n    using Set = unordered_set<int>;\\n    using Map = unordered_map<int, Set>;\\n    int collectTheCoins(VI& A, VVI& E, Map adj = {}, Queue q = {}, int pruned = 0) {\\n        int N = A.size();\\n        for (auto& edge: E) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            adj[u].insert(v);\\n            adj[v].insert(u);\\n        }\\n        auto prune = [&](auto first) {\\n            Queue q; for_each(A.begin(), A.end(), [i = -1, &adj, &q](auto& _) mutable { ++i; if (adj[i].size() == 1) q.push(i); });\\n            auto depth = first ? 123456789 : 2;\\n            while (q.size() && depth--) {\\n                int k = q.size();\\n                while (k--) {\\n                    auto u = q.front(); q.pop();\\n                    if (first && A[u])\\n                        continue;\\n                    for (auto v: adj[u]) {\\n                        adj[v].erase(u);\\n                        if (adj[v].size() == 1)\\n                            q.push(v);\\n                    }\\n                    adj[u].clear(), ++pruned;\\n                }\\n            }\\n        };\\n        prune(true);\\n        prune(false);\\n        return 2 * max(0, N - pruned - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379617,
                "title": "javascript-bfs-solution-with-comments",
                "content": "# Intuition\\nRefer to @i_pranav solution.\\nWe only need to care about the leaf with coin since those other nodes with coin between roof and leaf will also be passed through.\\n\\nstep 1: remove all leaf without coin and also delete the edge\\nstep 2: remove two node from each leaf with coin(currently, all of the leaf should have coin), because the question say we can get the coin ahead from two node.\\nthen the remain edges is the answer.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} coins\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar collectTheCoins = function(coins, edges) {\\n    const adj = getAdj(edges)\\n    let totalEdges = edges.length * 2 // multiply 2 because we need to go back to the root\\n\\n    const noCoinLeave = []\\n    \\n    for(let i = 0; i < coins.length; i++) {\\n        if(!adj[i]) continue\\n        if(!coins[i] && adj[i].size === 1) {\\n            noCoinLeave.push(i)\\n        }\\n    }\\n    \\n    // step 1\\n    while(noCoinLeave.length) {\\n        const size = noCoinLeave.length\\n        \\n        for(let i = 0; i < size; i++) {\\n            const node = noCoinLeave.shift()\\n            \\n            for(let neighbor of adj[node]) {\\n                adj[node].delete(neighbor)\\n                adj[neighbor].delete(node)\\n                \\n                totalEdges -= 2 // same reason as multiply 2\\n                \\n                // if the next node(neighbor) become leaf after we remove the no coin leaf, and also don\\'t have coin, then add it to noCoinLeave so that we can remove it\\n                if(!coins[neighbor] && adj[neighbor].size === 1) {\\n                    noCoinLeave.push(neighbor)\\n                }\\n            }\\n        }\\n    }\\n    \\n    const withCoinLeave = []\\n    \\n    for(let i = 0; i < coins.length; i++) {\\n        if(!adj[i]) continue\\n        if(coins[i] && adj[i].size === 1) {\\n            withCoinLeave.push(i)\\n        }\\n    }\\n\\n    // step 2\\n    for(let i = 0; i < 2; i++) {\\n        const size = withCoinLeave.length\\n        \\n        for(let j = 0; j < size; j++) {\\n            const node = withCoinLeave.shift()\\n            \\n            for(let neighbor of adj[node]) {\\n                adj[node].delete(neighbor)\\n                adj[neighbor].delete(node)\\n                \\n                totalEdges -= 2\\n                \\n                // if the next node become a leaf, that means it is the parent of the current node. so we can remove it safely\\n                if(adj[neighbor].size === 1) {\\n                    withCoinLeave.push(neighbor)\\n                }\\n            }\\n        }\\n    }\\n    \\n    return totalEdges\\n};\\n\\nconst getAdj = (edges) => {\\n    const map = []\\n    \\n    for(let [e1, e2] of edges) {\\n        //easy to delete property with Set\\n        map[e1] ||= new Set()\\n        map[e1].add(e2)\\n        map[e2] ||= new Set()\\n        map[e2].add(e1)\\n    }\\n    \\n    return map\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} coins\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar collectTheCoins = function(coins, edges) {\\n    const adj = getAdj(edges)\\n    let totalEdges = edges.length * 2 // multiply 2 because we need to go back to the root\\n\\n    const noCoinLeave = []\\n    \\n    for(let i = 0; i < coins.length; i++) {\\n        if(!adj[i]) continue\\n        if(!coins[i] && adj[i].size === 1) {\\n            noCoinLeave.push(i)\\n        }\\n    }\\n    \\n    // step 1\\n    while(noCoinLeave.length) {\\n        const size = noCoinLeave.length\\n        \\n        for(let i = 0; i < size; i++) {\\n            const node = noCoinLeave.shift()\\n            \\n            for(let neighbor of adj[node]) {\\n                adj[node].delete(neighbor)\\n                adj[neighbor].delete(node)\\n                \\n                totalEdges -= 2 // same reason as multiply 2\\n                \\n                // if the next node(neighbor) become leaf after we remove the no coin leaf, and also don\\'t have coin, then add it to noCoinLeave so that we can remove it\\n                if(!coins[neighbor] && adj[neighbor].size === 1) {\\n                    noCoinLeave.push(neighbor)\\n                }\\n            }\\n        }\\n    }\\n    \\n    const withCoinLeave = []\\n    \\n    for(let i = 0; i < coins.length; i++) {\\n        if(!adj[i]) continue\\n        if(coins[i] && adj[i].size === 1) {\\n            withCoinLeave.push(i)\\n        }\\n    }\\n\\n    // step 2\\n    for(let i = 0; i < 2; i++) {\\n        const size = withCoinLeave.length\\n        \\n        for(let j = 0; j < size; j++) {\\n            const node = withCoinLeave.shift()\\n            \\n            for(let neighbor of adj[node]) {\\n                adj[node].delete(neighbor)\\n                adj[neighbor].delete(node)\\n                \\n                totalEdges -= 2\\n                \\n                // if the next node become a leaf, that means it is the parent of the current node. so we can remove it safely\\n                if(adj[neighbor].size === 1) {\\n                    withCoinLeave.push(neighbor)\\n                }\\n            }\\n        }\\n    }\\n    \\n    return totalEdges\\n};\\n\\nconst getAdj = (edges) => {\\n    const map = []\\n    \\n    for(let [e1, e2] of edges) {\\n        //easy to delete property with Set\\n        map[e1] ||= new Set()\\n        map[e1].add(e2)\\n        map[e2] ||= new Set()\\n        map[e2].add(e1)\\n    }\\n    \\n    return map\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3376977,
                "title": "c-bfs",
                "content": "# Intuition\\nThis problem can be solved by applying 2 steps of transformation:\\n* `Step 1`: Keep on seperating only those `leaf nodes which don\\'t contain coin`.\\n* The tree that reamins has all leaf nodes containing coin. \\n* `Step 2`: Delete every leaf node of this tree. Now, the node connected to leaf node may or may not become a new leaf node. Delete the connected node `if it becomes a leaf node`.\\n\\n# Approach\\n![image.png](https://assets.leetcode.com/users/images/a8f28ed7-416e-40bc-a627-b71acb0baf30_1680578320.843756.png)\\n\\nWe\\'ll use bfs to separate leaf nodes in each step.\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#define pii pair<int, int>\\n\\nclass Solution {\\npublic:\\n    void deleteNode(int i,vector<set<int>> &edges){\\n        for(auto it:edges[i]){\\n            edges[it].erase(i);\\n        }\\n    }\\n\\n    void v1Transformation(vector<int> &coins,vector<set<int>> &edges,unordered_set<int> &deletedNodes){\\n        queue<int> q;\\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i].size()==1) q.push(i);\\n        }\\n        while (q.size()){\\n            int cur=q.front();\\n            q.pop();\\n            if(!coins[cur]){\\n                deleteNode(cur,edges);\\n                deletedNodes.insert(cur);\\n                int nextNode= *edges[cur].begin();\\n                if(edges[nextNode].size()==1){\\n                    q.push(nextNode);\\n                }\\n            }\\n        }\\n    }\\n\\n    void v2Transformation(vector<int> &coins,vector<set<int>> &edges,unordered_set<int> &deletedNodes){\\n        queue<pii> q;\\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i].size()==1) q.push({i,0});\\n        }\\n        while (q.size()){\\n            pii cur=q.front();\\n            q.pop();\\n            deleteNode(cur.first,edges);\\n            deletedNodes.insert(cur.first);\\n            if(!cur.second){\\n                int nextNode= *edges[cur.first].begin();\\n                if(edges[nextNode].size()==1){\\n                    q.push({nextNode,cur.second+1});\\n                }\\n            }\\n        }\\n    }\\n\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& ar) {\\n        vector<set<int>> edges(coins.size());\\n        for(auto it:ar){\\n            edges[it[0]].insert(it[1]);\\n            edges[it[1]].insert(it[0]);\\n        }\\n        unordered_set<int> deletedNodes;\\n        v1Transformation(coins,edges,deletedNodes);\\n        v2Transformation(coins,edges,deletedNodes);\\n        return max(0,2*((int)coins.size()-(int)deletedNodes.size()-1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#define pii pair<int, int>\\n\\nclass Solution {\\npublic:\\n    void deleteNode(int i,vector<set<int>> &edges){\\n        for(auto it:edges[i]){\\n            edges[it].erase(i);\\n        }\\n    }\\n\\n    void v1Transformation(vector<int> &coins,vector<set<int>> &edges,unordered_set<int> &deletedNodes){\\n        queue<int> q;\\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i].size()==1) q.push(i);\\n        }\\n        while (q.size()){\\n            int cur=q.front();\\n            q.pop();\\n            if(!coins[cur]){\\n                deleteNode(cur,edges);\\n                deletedNodes.insert(cur);\\n                int nextNode= *edges[cur].begin();\\n                if(edges[nextNode].size()==1){\\n                    q.push(nextNode);\\n                }\\n            }\\n        }\\n    }\\n\\n    void v2Transformation(vector<int> &coins,vector<set<int>> &edges,unordered_set<int> &deletedNodes){\\n        queue<pii> q;\\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i].size()==1) q.push({i,0});\\n        }\\n        while (q.size()){\\n            pii cur=q.front();\\n            q.pop();\\n            deleteNode(cur.first,edges);\\n            deletedNodes.insert(cur.first);\\n            if(!cur.second){\\n                int nextNode= *edges[cur.first].begin();\\n                if(edges[nextNode].size()==1){\\n                    q.push({nextNode,cur.second+1});\\n                }\\n            }\\n        }\\n    }\\n\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& ar) {\\n        vector<set<int>> edges(coins.size());\\n        for(auto it:ar){\\n            edges[it[0]].insert(it[1]);\\n            edges[it[1]].insert(it[0]);\\n        }\\n        unordered_set<int> deletedNodes;\\n        v1Transformation(coins,edges,deletedNodes);\\n        v2Transformation(coins,edges,deletedNodes);\\n        return max(0,2*((int)coins.size()-(int)deletedNodes.size()-1));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3375984,
                "title": "calculating-steps-for-each-starting-node-with-memoization",
                "content": "# Approach\\nThis approach is very different from the tree trimming method commonly used in other solutions. This is because I didn\\'t follow the official hint and solved the problem on my own. I also used this approach for the problem *2538. Difference Between Maximum and Minimum Price Sum*.\\n\\nIt directly calculates the steps required to collect all coins starting from each node. To help this, it memoizes the number of steps in each branch, where the first move is being made, if needed, along the given edge into the root of this branch. The edges are directed here, 2 for each edge in input. To avoid going into a lengthy cycle many times for star-like trees and degrade to a quadratic performance, some memoization should also be done in nodes. I hope the details are clear from the code below. If not, please let me know in comments.\\n\\nAlso, please **upvote** this to make it stand out from the numerous similar \"trimming/pruning\" solutions.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\tprivate static class Node {\\n\\t\\tfinal boolean hasCoin;\\n\\t\\tfinal List<Edge> edges = new ArrayList<>(); // outgoing\\n\\t\\tint stepSum;\\n\\t\\tEdge mdd1; // outgoing direction containing the most distant coin\\n\\t\\tEdge mdd2; // second most distant outgoing direction\\n\\t\\tEdge excluded;\\n\\t\\tstatic final Edge FINAL_STATE_MARKER = new Edge(null, null);\\n\\n\\t\\tNode(boolean hasCoin) {\\n\\t\\t\\tthis.hasCoin = hasCoin;\\n\\t\\t}\\n\\n\\t\\t// The minimal number of steps required to collect all coins starting from this node\\n\\t\\tint getSteps() {\\n\\t\\t\\tint result = 0;\\n\\t\\t\\tfor (Edge e : edges)\\n\\t\\t\\t\\tresult += e.getSteps();\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tvoid include(Edge outgoing) {\\n\\t\\t\\tstepSum += outgoing.getSteps();\\n\\t\\t\\tint distance;\\n\\t\\t\\tif ((distance = outgoing.distance) < 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif (mdd1 == null || distance > mdd1.distance) {\\n\\t\\t\\t\\tmdd2 = mdd1;\\n\\t\\t\\t\\tmdd1 = outgoing;\\n\\t\\t\\t} else if (mdd2 == null || distance > mdd2.distance)\\n\\t\\t\\t\\tmdd2 = outgoing;\\n\\t\\t}\\n\\n\\t\\tvoid process(Edge incoming) {\\n\\t\\t\\tif (excluded == null) { // initial state\\n\\t\\t\\t\\texcluded = incoming.reverse;\\n\\t\\t\\t\\tfor (Edge e : edges)\\n\\t\\t\\t\\t\\tif (e != excluded)\\n\\t\\t\\t\\t\\t\\tinclude(e);\\n\\t\\t\\t\\tincoming.assign(mdd1, stepSum);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (excluded != FINAL_STATE_MARKER) { // intermediate state\\n\\t\\t\\t\\t\\tinclude(excluded);\\n\\t\\t\\t\\t\\texcluded = FINAL_STATE_MARKER;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// final state\\n\\t\\t\\t\\tEdge reverse = incoming.reverse;\\n\\t\\t\\t\\tincoming.assign(mdd1 != reverse ? mdd1 : mdd2, stepSum - reverse.steps);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static class Edge { // directed\\n\\t\\tfinal Node from;\\n\\t\\tfinal Node to;\\n\\t\\tEdge reverse;\\n\\t\\tint distance; // distance from <from> to most distant coin or -1 if no coins at branch\\n\\t\\tint steps = -1; // see getSteps() description below; always >= 0 when assigned\\n\\n\\t\\tEdge(Node from, Node to) {\\n\\t\\t\\tthis.from = from;\\n\\t\\t\\tthis.to = to;\\n\\t\\t}\\n\\n\\t\\t// The minimal number of steps required to collect all coins in the branch pointed\\n\\t\\t// by this edge, starting from the <from> node and moving to the <to> node if needed\\n\\t\\tint getSteps() {\\n\\t\\t\\tif (steps < 0) // not calculated yet\\n\\t\\t\\t\\tto.process(this);\\n\\t\\t\\treturn steps;\\n\\t\\t}\\n\\n\\t\\tvoid assign(Edge mdd, int stepSum) {\\n\\t\\t\\tdistance = mdd == null ? (to.hasCoin ? 1 : from.hasCoin ? 0 : -1) : mdd.distance + 1;\\n\\t\\t\\tsteps = distance <= 2 ? 0 : stepSum + 2;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int collectTheCoins(int[] coins, int[][] edges) {\\n\\t\\tint n = coins.length;\\n\\t\\tNode[] nodes = new Node[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tnodes[i] = new Node(coins[i] != 0);\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tNode a = nodes[edge[0]];\\n\\t\\t\\tNode b = nodes[edge[1]];\\n\\t\\t\\tEdge ab = new Edge(a, b);\\n\\t\\t\\tEdge ba = new Edge(b, a);\\n\\t\\t\\ta.edges.add(ab);\\n\\t\\t\\tb.edges.add(ba);\\n\\t\\t\\tab.reverse = ba;\\n\\t\\t\\tba.reverse = ab;\\n\\t\\t}\\n\\t\\tint result = Integer.MAX_VALUE;\\n\\t\\tfor (Node node : nodes)\\n\\t\\t\\tresult = Math.min(result, node.getSteps());\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\tprivate static class Node {\\n\\t\\tfinal boolean hasCoin;\\n\\t\\tfinal List<Edge> edges = new ArrayList<>(); // outgoing\\n\\t\\tint stepSum;\\n\\t\\tEdge mdd1; // outgoing direction containing the most distant coin\\n\\t\\tEdge mdd2; // second most distant outgoing direction\\n\\t\\tEdge excluded;\\n\\t\\tstatic final Edge FINAL_STATE_MARKER = new Edge(null, null);\\n\\n\\t\\tNode(boolean hasCoin) {\\n\\t\\t\\tthis.hasCoin = hasCoin;\\n\\t\\t}\\n\\n\\t\\t// The minimal number of steps required to collect all coins starting from this node\\n\\t\\tint getSteps() {\\n\\t\\t\\tint result = 0;\\n\\t\\t\\tfor (Edge e : edges)\\n\\t\\t\\t\\tresult += e.getSteps();\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tvoid include(Edge outgoing) {\\n\\t\\t\\tstepSum += outgoing.getSteps();\\n\\t\\t\\tint distance;\\n\\t\\t\\tif ((distance = outgoing.distance) < 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif (mdd1 == null || distance > mdd1.distance) {\\n\\t\\t\\t\\tmdd2 = mdd1;\\n\\t\\t\\t\\tmdd1 = outgoing;\\n\\t\\t\\t} else if (mdd2 == null || distance > mdd2.distance)\\n\\t\\t\\t\\tmdd2 = outgoing;\\n\\t\\t}\\n\\n\\t\\tvoid process(Edge incoming) {\\n\\t\\t\\tif (excluded == null) { // initial state\\n\\t\\t\\t\\texcluded = incoming.reverse;\\n\\t\\t\\t\\tfor (Edge e : edges)\\n\\t\\t\\t\\t\\tif (e != excluded)\\n\\t\\t\\t\\t\\t\\tinclude(e);\\n\\t\\t\\t\\tincoming.assign(mdd1, stepSum);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (excluded != FINAL_STATE_MARKER) { // intermediate state\\n\\t\\t\\t\\t\\tinclude(excluded);\\n\\t\\t\\t\\t\\texcluded = FINAL_STATE_MARKER;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// final state\\n\\t\\t\\t\\tEdge reverse = incoming.reverse;\\n\\t\\t\\t\\tincoming.assign(mdd1 != reverse ? mdd1 : mdd2, stepSum - reverse.steps);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static class Edge { // directed\\n\\t\\tfinal Node from;\\n\\t\\tfinal Node to;\\n\\t\\tEdge reverse;\\n\\t\\tint distance; // distance from <from> to most distant coin or -1 if no coins at branch\\n\\t\\tint steps = -1; // see getSteps() description below; always >= 0 when assigned\\n\\n\\t\\tEdge(Node from, Node to) {\\n\\t\\t\\tthis.from = from;\\n\\t\\t\\tthis.to = to;\\n\\t\\t}\\n\\n\\t\\t// The minimal number of steps required to collect all coins in the branch pointed\\n\\t\\t// by this edge, starting from the <from> node and moving to the <to> node if needed\\n\\t\\tint getSteps() {\\n\\t\\t\\tif (steps < 0) // not calculated yet\\n\\t\\t\\t\\tto.process(this);\\n\\t\\t\\treturn steps;\\n\\t\\t}\\n\\n\\t\\tvoid assign(Edge mdd, int stepSum) {\\n\\t\\t\\tdistance = mdd == null ? (to.hasCoin ? 1 : from.hasCoin ? 0 : -1) : mdd.distance + 1;\\n\\t\\t\\tsteps = distance <= 2 ? 0 : stepSum + 2;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int collectTheCoins(int[] coins, int[][] edges) {\\n\\t\\tint n = coins.length;\\n\\t\\tNode[] nodes = new Node[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tnodes[i] = new Node(coins[i] != 0);\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\tNode a = nodes[edge[0]];\\n\\t\\t\\tNode b = nodes[edge[1]];\\n\\t\\t\\tEdge ab = new Edge(a, b);\\n\\t\\t\\tEdge ba = new Edge(b, a);\\n\\t\\t\\ta.edges.add(ab);\\n\\t\\t\\tb.edges.add(ba);\\n\\t\\t\\tab.reverse = ba;\\n\\t\\t\\tba.reverse = ab;\\n\\t\\t}\\n\\t\\tint result = Integer.MAX_VALUE;\\n\\t\\tfor (Node node : nodes)\\n\\t\\t\\tresult = Math.min(result, node.getSteps());\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367537,
                "title": "collect-coins-in-a-tree-bfs-trim-tree-graph-as-tree-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n=coins.length;\\n        List<Set<Integer>> adj=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++){\\n            adj.add(new HashSet<>());\\n        }\\n\\n        for(int []e:edges){\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n\\n        Queue<Integer> q=new LinkedList<>();\\n\\n        for(int i=0;i<n;i++){\\n            int u=i;\\n            while(adj.get(u).size()==1 && coins[u]==0){\\n                int v=adj.get(u).iterator().next();\\n                adj.get(u).remove(v);\\n                adj.get(v).remove(u);\\n                u=v;\\n            }\\n\\n            if(adj.get(u).size()==1){\\n                q.add(u);\\n            }\\n        }\\n        \\n\\n        for(int i=0;i<2;i++){\\n            List<Integer> temp=new ArrayList<>();\\n\\n            while(!q.isEmpty()){\\n                int u=q.remove();\\n\\n                if(adj.get(u).size()==1){\\n                    int v=adj.get(u).iterator().next();\\n                    adj.get(u).remove(v);\\n                    adj.get(v).remove(u);\\n\\n                    if(adj.get(v).size()==1){\\n                        temp.add(v);\\n                    }\\n                }\\n            }\\n\\n            q.addAll(temp);\\n        }\\n\\n        int ans=0;\\n\\n        for(Set<Integer> hs:adj){\\n            ans+=hs.size();\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n=coins.length;\\n        List<Set<Integer>> adj=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++){\\n            adj.add(new HashSet<>());\\n        }\\n\\n        for(int []e:edges){\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n\\n        Queue<Integer> q=new LinkedList<>();\\n\\n        for(int i=0;i<n;i++){\\n            int u=i;\\n            while(adj.get(u).size()==1 && coins[u]==0){\\n                int v=adj.get(u).iterator().next();\\n                adj.get(u).remove(v);\\n                adj.get(v).remove(u);\\n                u=v;\\n            }\\n\\n            if(adj.get(u).size()==1){\\n                q.add(u);\\n            }\\n        }\\n        \\n\\n        for(int i=0;i<2;i++){\\n            List<Integer> temp=new ArrayList<>();\\n\\n            while(!q.isEmpty()){\\n                int u=q.remove();\\n\\n                if(adj.get(u).size()==1){\\n                    int v=adj.get(u).iterator().next();\\n                    adj.get(u).remove(v);\\n                    adj.get(v).remove(u);\\n\\n                    if(adj.get(v).size()==1){\\n                        temp.add(v);\\n                    }\\n                }\\n            }\\n\\n            q.addAll(temp);\\n        }\\n\\n        int ans=0;\\n\\n        for(Set<Integer> hs:adj){\\n            ans+=hs.size();\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356202,
                "title": "easy-trimming-single-pass-o-n",
                "content": "# Intuition\\nTrim leaf nodes if there are no coins 2 levels below them.\\n\\n# Approach\\nConsider a leaf node v. We can trim node v if there are no coins 2 levels below v. Function shouldDelete(v,p) in the code checks this condition. If we trim v, we remove v from the neighbour set of its parent node p. If node p becomes a leaf (i.e. if its neighbour set size becomes 1), we add it to the queue.\\n\\nWe keep track of the total nodes removed. \\nAnswer = (RemainingNodes - 1)*2 = (n-nodesRemoved-1)*2\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    List<List<Integer>> t;\\n    List<Set<Integer>> tset;\\n    int[] coins;\\n    boolean shouldDelete(int v, int p){\\n        for(int c1:t.get(v)){\\n            if(c1!=p){\\n                for(int c2:t.get(c1)){\\n                    if(c2!=v){\\n                        if(coins[c2]==1) return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        this.coins = coins;\\n        int n = coins.length;\\n        if(n<=3) return 0;\\n        t = new ArrayList<>();\\n        tset = new ArrayList<>();\\n        for(int i=0;i<coins.length;i++){\\n            t.add(new ArrayList<>());\\n            tset.add(new HashSet<>());\\n        }\\n        for(int[] e:edges){\\n            t.get(e[0]).add(e[1]);\\n            t.get(e[1]).add(e[0]);\\n            tset.get(e[0]).add(e[1]);\\n            tset.get(e[1]).add(e[0]);\\n        }\\n        Queue<Integer> q = new ArrayDeque<>();\\n        for(int i=0;i<n;i++){\\n            if(tset.get(i).size()==1){\\n                q.add(i);\\n            }\\n        }\\n        int nodesRemoved = 0;\\n        while(!q.isEmpty()){\\n            int v = q.poll();\\n            if(tset.get(v).size()==0) break; //last node in tree\\n            int p = tset.get(v).iterator().next();\\n            if(shouldDelete(v, p)){\\n                nodesRemoved++;\\n                tset.get(p).remove(v);\\n                if(tset.get(p).size()==1){\\n                    q.add(p);\\n                }\\n            }\\n        }\\n        return (n-nodesRemoved-1)*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> t;\\n    List<Set<Integer>> tset;\\n    int[] coins;\\n    boolean shouldDelete(int v, int p){\\n        for(int c1:t.get(v)){\\n            if(c1!=p){\\n                for(int c2:t.get(c1)){\\n                    if(c2!=v){\\n                        if(coins[c2]==1) return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        this.coins = coins;\\n        int n = coins.length;\\n        if(n<=3) return 0;\\n        t = new ArrayList<>();\\n        tset = new ArrayList<>();\\n        for(int i=0;i<coins.length;i++){\\n            t.add(new ArrayList<>());\\n            tset.add(new HashSet<>());\\n        }\\n        for(int[] e:edges){\\n            t.get(e[0]).add(e[1]);\\n            t.get(e[1]).add(e[0]);\\n            tset.get(e[0]).add(e[1]);\\n            tset.get(e[1]).add(e[0]);\\n        }\\n        Queue<Integer> q = new ArrayDeque<>();\\n        for(int i=0;i<n;i++){\\n            if(tset.get(i).size()==1){\\n                q.add(i);\\n            }\\n        }\\n        int nodesRemoved = 0;\\n        while(!q.isEmpty()){\\n            int v = q.poll();\\n            if(tset.get(v).size()==0) break; //last node in tree\\n            int p = tset.get(v).iterator().next();\\n            if(shouldDelete(v, p)){\\n                nodesRemoved++;\\n                tset.get(p).remove(v);\\n                if(tset.get(p).size()==1){\\n                    q.add(p);\\n                }\\n            }\\n        }\\n        return (n-nodesRemoved-1)*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353942,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn collect_the_coins(coins: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\\n        let mut sz = coins.len();\\n        let mut al = vec![vec![]; sz];\\n        for e in edges.iter() {\\n            al[e[0] as usize].push(e[1]);\\n            al[e[1] as usize].push(e[0]);\\n        }\\n        let mut cnt = vec![0; sz];\\n        let mut steps = vec![30000; sz];\\n        let mut q = vec![];\\n        for i in 0..sz {\\n            cnt[i] = al[i].len() as i32;\\n            if cnt[i] == 1 {\\n                q.push(i as i32);\\n            }\\n        }\\n        while !q.is_empty() {\\n            let i = q.pop().unwrap() as usize;\\n            steps[i] -= 1;\\n            if steps[i] > 0 {\\n                sz -= 1;\\n                for &j in al[i].iter() {\\n                    let j = j as usize;\\n                    steps[j] = steps[j].min(steps[i].min(if coins[i] == 1 { 2 } else { 30000 }));\\n                    cnt[j] -= 1;\\n                    if cnt[j] == 1 {\\n                        q.push(j as i32);\\n                    }\\n                }\\n            }\\n        }\\n        2 * 0.max(sz as i32 - 1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn collect_the_coins(coins: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\\n        let mut sz = coins.len();\\n        let mut al = vec![vec![]; sz];\\n        for e in edges.iter() {\\n            al[e[0] as usize].push(e[1]);\\n            al[e[1] as usize].push(e[0]);\\n        }\\n        let mut cnt = vec![0; sz];\\n        let mut steps = vec![30000; sz];\\n        let mut q = vec![];\\n        for i in 0..sz {\\n            cnt[i] = al[i].len() as i32;\\n            if cnt[i] == 1 {\\n                q.push(i as i32);\\n            }\\n        }\\n        while !q.is_empty() {\\n            let i = q.pop().unwrap() as usize;\\n            steps[i] -= 1;\\n            if steps[i] > 0 {\\n                sz -= 1;\\n                for &j in al[i].iter() {\\n                    let j = j as usize;\\n                    steps[j] = steps[j].min(steps[i].min(if coins[i] == 1 { 2 } else { 30000 }));\\n                    cnt[j] -= 1;\\n                    if cnt[j] == 1 {\\n                        q.push(j as i32);\\n                    }\\n                }\\n            }\\n        }\\n        2 * 0.max(sz as i32 - 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3352397,
                "title": "java-35ms",
                "content": "```\\nclass Solution {\\n    int[] coins;\\n    int n;\\n    ArrayList<Integer>[] graph;\\n    int sum;\\n    int ret;\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        n=coins.length;\\n        this.coins=coins;\\n        graph=new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i]=new ArrayList<>();\\n        }\\n        for(int[] edge:edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        for(int coin:coins){\\n            sum+=coin;\\n        }\\n        dfs(0,-1);\\n        return Math.max(2*(ret-1),0);\\n    }\\n    int dfs(int node,int pre){\\n        int cnt=0;\\n        int s=0;\\n        for(int nn:graph[node]){\\n            if(nn!=pre){\\n                int r=dfs(nn,node);\\n                if(r-coins[nn]>0)cnt++;\\n                s+=r;\\n            }\\n        }\\n        if(pre!=-1){\\n            if(sum-s-coins[node]-coins[pre]>0){\\n                cnt++;\\n            }\\n        }\\n        if(cnt>=2){\\n            ret++;\\n        }\\n        return s+coins[node];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] coins;\\n    int n;\\n    ArrayList<Integer>[] graph;\\n    int sum;\\n    int ret;\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        n=coins.length;\\n        this.coins=coins;\\n        graph=new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            graph[i]=new ArrayList<>();\\n        }\\n        for(int[] edge:edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        for(int coin:coins){\\n            sum+=coin;\\n        }\\n        dfs(0,-1);\\n        return Math.max(2*(ret-1),0);\\n    }\\n    int dfs(int node,int pre){\\n        int cnt=0;\\n        int s=0;\\n        for(int nn:graph[node]){\\n            if(nn!=pre){\\n                int r=dfs(nn,node);\\n                if(r-coins[nn]>0)cnt++;\\n                s+=r;\\n            }\\n        }\\n        if(pre!=-1){\\n            if(sum-s-coins[node]-coins[pre]>0){\\n                cnt++;\\n            }\\n        }\\n        if(cnt>=2){\\n            ret++;\\n        }\\n        return s+coins[node];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351233,
                "title": "o-n-onion-peeling-approach-based-on-topological-sort-with-comments",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$ for BFS|Topological sort\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for graph\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction collectTheCoins(coins: number[], edges: number[][]): number {\\n    const n = coins.length;\\n    let edgeCount = edges.length * 2;\\n\\n    const graph = [...new Array<Set<number>>(n)].map(_ => new Set<number>());\\n    for (const [from, to] of edges) {\\n        graph[from].add(to);\\n        graph[to].add(from);\\n    }\\n\\n    // 1. Remove non-coin leaves and non-coin branches \\n    let coinsCount = 0;\\n    let leaves: number[] = [];\\n    for (let i = 0; i < n; i++) {\\n        if (coins[i]) {\\n          coinsCount++;  \\n        }\\n        if (!coins[i] && graph[i].size === 1) {\\n            leaves.push(i);\\n        }\\n    }\\n\\n    // Tweak for the empty coins case\\n    if (!coinsCount) {\\n        return 0;\\n    }\\n\\n    while (leaves.length) {\\n        const leavesSize = leaves.length;\\n        for (let i = 0; i < leavesSize; i++) {\\n            const node = leaves.shift();\\n            for (const neighbor of graph[node]) {\\n                graph[node].delete(neighbor);\\n                graph[neighbor].delete(node);\\n                edgeCount -=2;\\n                if (!coins[neighbor] && graph[neighbor].size === 1) {\\n                    leaves.push(neighbor);\\n                }\\n            }\\n        }\\n    }\\n\\n    // 2. We make two step of onion peeling (topological sorting) from the coin leaves\\n    let leafCoins: number[] = [];\\n    for (let i = 0; i < n; i++) {\\n        if (coins[i] && graph[i].size === 1) {\\n              leafCoins.push(i);\\n        }\\n    }\\n\\n    for (let i = 0; i < 2; i++) {\\n        const leavesSize = leafCoins.length;\\n        for (let i = 0; i < leavesSize; i++) {\\n            const node = leafCoins.shift();\\n            for (const neighbor of graph[node]) {\\n                graph[node].delete(neighbor);\\n                graph[neighbor].delete(node);\\n                edgeCount -=2;\\n                if (graph[neighbor].size === 1) {\\n                    leafCoins.push(neighbor);\\n                }\\n            }\\n        }\\n    }\\n\\n    return edgeCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Tree",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nfunction collectTheCoins(coins: number[], edges: number[][]): number {\\n    const n = coins.length;\\n    let edgeCount = edges.length * 2;\\n\\n    const graph = [...new Array<Set<number>>(n)].map(_ => new Set<number>());\\n    for (const [from, to] of edges) {\\n        graph[from].add(to);\\n        graph[to].add(from);\\n    }\\n\\n    // 1. Remove non-coin leaves and non-coin branches \\n    let coinsCount = 0;\\n    let leaves: number[] = [];\\n    for (let i = 0; i < n; i++) {\\n        if (coins[i]) {\\n          coinsCount++;  \\n        }\\n        if (!coins[i] && graph[i].size === 1) {\\n            leaves.push(i);\\n        }\\n    }\\n\\n    // Tweak for the empty coins case\\n    if (!coinsCount) {\\n        return 0;\\n    }\\n\\n    while (leaves.length) {\\n        const leavesSize = leaves.length;\\n        for (let i = 0; i < leavesSize; i++) {\\n            const node = leaves.shift();\\n            for (const neighbor of graph[node]) {\\n                graph[node].delete(neighbor);\\n                graph[neighbor].delete(node);\\n                edgeCount -=2;\\n                if (!coins[neighbor] && graph[neighbor].size === 1) {\\n                    leaves.push(neighbor);\\n                }\\n            }\\n        }\\n    }\\n\\n    // 2. We make two step of onion peeling (topological sorting) from the coin leaves\\n    let leafCoins: number[] = [];\\n    for (let i = 0; i < n; i++) {\\n        if (coins[i] && graph[i].size === 1) {\\n              leafCoins.push(i);\\n        }\\n    }\\n\\n    for (let i = 0; i < 2; i++) {\\n        const leavesSize = leafCoins.length;\\n        for (let i = 0; i < leavesSize; i++) {\\n            const node = leafCoins.shift();\\n            for (const neighbor of graph[node]) {\\n                graph[node].delete(neighbor);\\n                graph[neighbor].delete(node);\\n                edgeCount -=2;\\n                if (graph[neighbor].size === 1) {\\n                    leafCoins.push(neighbor);\\n                }\\n            }\\n        }\\n    }\\n\\n    return edgeCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3347936,
                "title": "2603-collect-coins-in-a-tree-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTrimming the tree\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n=coins.length;\\n        HashSet<Integer>[] graph=new HashSet[n];\\n        for(int i=0;i<n;i++)graph[i]=new HashSet<>();\\n        for(int[] e:edges){\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            int u=i;\\n            while(graph[u].size()==1&&coins[u]==0){\\n                int v=graph[u].iterator().next();\\n                graph[u].remove(v);\\n                graph[v].remove(u);\\n                u=v;\\n            }\\n            if(graph[u].size()==1){\\n                q.add(u);\\n            }\\n        }\\n\\n        int level=0;\\n        while(level<2){\\n            level++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                int u=q.poll();\\n                if (graph[u].size() == 1) {\\n                    int v = graph[u].iterator().next(); \\n                    graph[u].remove(v); \\n                    graph[v].remove(u); \\n                    if (graph[v].size() == 1) q.add(v); \\n                } \\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=graph[i].size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n=coins.length;\\n        HashSet<Integer>[] graph=new HashSet[n];\\n        for(int i=0;i<n;i++)graph[i]=new HashSet<>();\\n        for(int[] e:edges){\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            int u=i;\\n            while(graph[u].size()==1&&coins[u]==0){\\n                int v=graph[u].iterator().next();\\n                graph[u].remove(v);\\n                graph[v].remove(u);\\n                u=v;\\n            }\\n            if(graph[u].size()==1){\\n                q.add(u);\\n            }\\n        }\\n\\n        int level=0;\\n        while(level<2){\\n            level++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                int u=q.poll();\\n                if (graph[u].size() == 1) {\\n                    int v = graph[u].iterator().next(); \\n                    graph[u].remove(v); \\n                    graph[v].remove(u); \\n                    if (graph[v].size() == 1) q.add(v); \\n                } \\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=graph[i].size();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346810,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int V = coins.length;\\n        int rem = V;\\n        ArrayList<HashSet<Integer>> adj = new ArrayList<>();\\n        for(int i = 0 ; i < V ; i++){\\n            adj.add(new HashSet<>());\\n        }\\n        for(int i = 0 ; i < edges.length ; i++){\\n            int s = edges[i][0];\\n            int e = edges[i][1];\\n            adj.get(s).add(e);\\n            adj.get(e).add(s);\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0 ; i < V ; i++){\\n            if(adj.get(i).size() == 1 && coins[i] == 0){\\n                queue.offer(i);\\n            }\\n        }\\n        while(!queue.isEmpty()){\\n            int curNode = queue.poll();\\n            rem--;\\n            for(int ele : adj.get(curNode)){\\n                adj.get(ele).remove(curNode);\\n                adj.get(curNode).remove(ele);\\n                if(adj.get(ele).size() == 1 && coins[ele] == 0){\\n                    queue.offer(ele);\\n                }\\n            }\\n        }\\n        for(int i = 0 ; i < V ; i++){\\n            if(adj.get(i).size() == 1 && coins[i] == 1){\\n                queue.offer(i);\\n            }\\n        }\\n        for(int trim = 0 ; trim < 2 ; trim++){\\n            int size = queue.size();\\n            for(int i = 0 ; i < size ; i++){\\n                int curNode = queue.poll();\\n                rem--;\\n                for(int ele : adj.get(curNode)){\\n                    adj.get(ele).remove(curNode);\\n                    adj.get(curNode).remove(ele);\\n                    if(adj.get(ele).size() == 1){\\n                        queue.offer(ele);\\n                    }\\n                }\\n            }\\n        }\\n        return Math.max(0, (rem - 1) *2);\\n    }\\n}\\n```\\n**Please UpVote, if found useful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int V = coins.length;\\n        int rem = V;\\n        ArrayList<HashSet<Integer>> adj = new ArrayList<>();\\n        for(int i = 0 ; i < V ; i++){\\n            adj.add(new HashSet<>());\\n        }\\n        for(int i = 0 ; i < edges.length ; i++){\\n            int s = edges[i][0];\\n            int e = edges[i][1];\\n            adj.get(s).add(e);\\n            adj.get(e).add(s);\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0 ; i < V ; i++){\\n            if(adj.get(i).size() == 1 && coins[i] == 0){\\n                queue.offer(i);\\n            }\\n        }\\n        while(!queue.isEmpty()){\\n            int curNode = queue.poll();\\n            rem--;\\n            for(int ele : adj.get(curNode)){\\n                adj.get(ele).remove(curNode);\\n                adj.get(curNode).remove(ele);\\n                if(adj.get(ele).size() == 1 && coins[ele] == 0){\\n                    queue.offer(ele);\\n                }\\n            }\\n        }\\n        for(int i = 0 ; i < V ; i++){\\n            if(adj.get(i).size() == 1 && coins[i] == 1){\\n                queue.offer(i);\\n            }\\n        }\\n        for(int trim = 0 ; trim < 2 ; trim++){\\n            int size = queue.size();\\n            for(int i = 0 ; i < size ; i++){\\n                int curNode = queue.poll();\\n                rem--;\\n                for(int ele : adj.get(curNode)){\\n                    adj.get(ele).remove(curNode);\\n                    adj.get(curNode).remove(ele);\\n                    if(adj.get(ele).size() == 1){\\n                        queue.offer(ele);\\n                    }\\n                }\\n            }\\n        }\\n        return Math.max(0, (rem - 1) *2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346640,
                "title": "a-very-simple-solution-beats-100-time-complexity",
                "content": "# Code\\n```\\nclass Solution {\\npublic:    \\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n = coins.size();\\n        if(n<=5) return 0;\\n        \\n        vector<vector<int> > g(n);\\n        vector<int> deg(n,0);\\n        vector<int> mask(n,1);\\n        vector<int> dist(n,0);\\n        vector<int> tot = coins;\\n        \\n        for(auto &uv : edges) {\\n            int u = uv[0];\\n            int v = uv[1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n            deg[u]++;\\n            deg[v]++;\\n        }\\n        \\n        queue<int> que;\\n        for(int i = 0; i < n; i++) {\\n            if(deg[i]>1) continue;\\n            // u w dist\\n            que.push(i);\\n            mask[i] = 0;\\n        }\\n        \\n        for(;que.empty()==false;) {\\n            int u,w,d;\\n            u = que.front(); que.pop();\\n            w = tot[u];\\n            d = dist[u];\\n            \\n            for(int v : g[u]) {\\n                if(mask[v]==0) continue;\\n                tot[v] += w;\\n                \\n                if(w>0) dist[v] = max(dist[v],d+1);\\n                \\n                deg[v]--;\\n                if(deg[v]==1) {\\n                    if(tot[v]==0) {\\n                        mask[v] = 0;\\n                        que.push(v);\\n                    } \\n                    else {\\n                        if(dist[v] < 2) {\\n                            mask[v] = 0;\\n                            que.push(v);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < n; i++) if(mask[i]) res++;\\n        return max(0,(res-1)*2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n = coins.size();\\n        if(n<=5) return 0;\\n        \\n        vector<vector<int> > g(n);\\n        vector<int> deg(n,0);\\n        vector<int> mask(n,1);\\n        vector<int> dist(n,0);\\n        vector<int> tot = coins;\\n        \\n        for(auto &uv : edges) {\\n            int u = uv[0];\\n            int v = uv[1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n            deg[u]++;\\n            deg[v]++;\\n        }\\n        \\n        queue<int> que;\\n        for(int i = 0; i < n; i++) {\\n            if(deg[i]>1) continue;\\n            // u w dist\\n            que.push(i);\\n            mask[i] = 0;\\n        }\\n        \\n        for(;que.empty()==false;) {\\n            int u,w,d;\\n            u = que.front(); que.pop();\\n            w = tot[u];\\n            d = dist[u];\\n            \\n            for(int v : g[u]) {\\n                if(mask[v]==0) continue;\\n                tot[v] += w;\\n                \\n                if(w>0) dist[v] = max(dist[v],d+1);\\n                \\n                deg[v]--;\\n                if(deg[v]==1) {\\n                    if(tot[v]==0) {\\n                        mask[v] = 0;\\n                        que.push(v);\\n                    } \\n                    else {\\n                        if(dist[v] < 2) {\\n                            mask[v] = 0;\\n                            que.push(v);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < n; i++) if(mask[i]) res++;\\n        return max(0,(res-1)*2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346557,
                "title": "2-dfs",
                "content": "# Intuition\\nWe can inspect all paths between all coins and if the length of the path is >= 3 - add the node(s) in the middle to the final set. After this step is completed we just need to multiply the number of the nodes minus one by two. We can start gathering coins from any node in this set, and we will have to visit all other nodes from the set, and return back to the original node. This means that we will have to go  twice along each edge - and the answer to the question will be (n-1)*2.\\n\\n# Approach\\nAfter some inspection we can realize that we don\\'t need to inspect all paths, but just all paths between some \"leaf\" coin and all other coins. This \"leaf\" coin can be a little tricky to find, because it can be not just a simple leaf node, but also some node in the middle after which there\\'s no other nodes with coins. Some use \"trimming\" of such nodes, I will use a DFS. To do this I will select a random coin node, and find the furthest coin node from the selected node. The furthest coin node is guaranteed to be a \"leaf\" coin.\\nThe 2nd DFS will inspect each path from my leaf coin node to all other coins. Along the DFS I will calculate the length of the current path (going forward in the recursion), and the length of the deepest coin from the current coin on the current path (going back from the recursion). If both of these numbers greater than 1 - we **must** add the current node into the final set.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    fun collectTheCoins(coins: IntArray, edges: Array<IntArray>): Int {\\n        if (coins.size < 5) return 0 // no need to process this tree\\n        // creating adj. list\\n        val graph = HashMap<Int, MutableList<Int>>()\\n        edges.forEach {\\n            graph.computeIfAbsent(it[0]) {LinkedList<Int>()}.add(it[1])\\n            graph.computeIfAbsent(it[1]) {LinkedList<Int>() }.add(it[0])\\n        }\\n        val i = coins.indexOfFirst { it == 1 }\\n        if (i == -1) return 0 // endge case - there\\'s no coins in the tree\\n        // just some constant to save some space\\n        val NONE = intArrayOf(-1, -1)\\n\\n        // find the furthest vertex\\n        val visited = HashSet<Int>()\\n        // we return an array of 2 elements - the \"leaf coin\" node, and the depth to it\\n        fun dfs1(v: Int, len: Int): IntArray {\\n            visited.add(v)\\n            var maxToCoin = NONE\\n            for (v2 in graph[v]!!) {\\n                if (!visited.contains(v2)) {\\n                    val nextPath = dfs1(v2, len+1)\\n                    if (nextPath[1] > maxToCoin[1]) maxToCoin = nextPath\\n                }\\n            }\\n            // maxToCoin[0] == -1 means there\\'s no coins going deeper from the current node\\n            if (maxToCoin[0] == -1) {\\n                if (coins[v] == 1) return intArrayOf(v, len)\\n                graph.remove(v) // no need to keep this vertex for the 2nd step\\n            }\\n            return maxToCoin\\n        }\\n        val start = dfs1(i, 0)\\n        if (start[0] == -1) return 0\\n\\n        visited.clear()\\n        val trimmed = HashSet<Int>()\\n        // 2nd DFS - calculating the final set of nodes\\n        // It\\'s very similar to the 1st DFS\\n        fun dfs(v: Int, len: Int): Int {\\n            visited.add(v)\\n            val edges = graph[v] ?: return -1\\n            var maxToCoin = -1\\n            for (v2 in edges) {\\n                if (!visited.contains(v2)) {\\n                    maxToCoin = maxOf(dfs(v2, len+1), maxToCoin)\\n                }\\n            }\\n            if (maxToCoin == -1) return if (coins[v] == 1) 1 else -1\\n            if (maxToCoin > 1 && len > 1 ) trimmed.add(v)\\n            return maxToCoin + 1\\n        }\\n        dfs(start[0], 0)\\n        if (trimmed.size == 0) return 0\\n        return (trimmed.size - 1) * 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun collectTheCoins(coins: IntArray, edges: Array<IntArray>): Int {\\n        if (coins.size < 5) return 0 // no need to process this tree\\n        // creating adj. list\\n        val graph = HashMap<Int, MutableList<Int>>()\\n        edges.forEach {\\n            graph.computeIfAbsent(it[0]) {LinkedList<Int>()}.add(it[1])\\n            graph.computeIfAbsent(it[1]) {LinkedList<Int>() }.add(it[0])\\n        }\\n        val i = coins.indexOfFirst { it == 1 }\\n        if (i == -1) return 0 // endge case - there\\'s no coins in the tree\\n        // just some constant to save some space\\n        val NONE = intArrayOf(-1, -1)\\n\\n        // find the furthest vertex\\n        val visited = HashSet<Int>()\\n        // we return an array of 2 elements - the \"leaf coin\" node, and the depth to it\\n        fun dfs1(v: Int, len: Int): IntArray {\\n            visited.add(v)\\n            var maxToCoin = NONE\\n            for (v2 in graph[v]!!) {\\n                if (!visited.contains(v2)) {\\n                    val nextPath = dfs1(v2, len+1)\\n                    if (nextPath[1] > maxToCoin[1]) maxToCoin = nextPath\\n                }\\n            }\\n            // maxToCoin[0] == -1 means there\\'s no coins going deeper from the current node\\n            if (maxToCoin[0] == -1) {\\n                if (coins[v] == 1) return intArrayOf(v, len)\\n                graph.remove(v) // no need to keep this vertex for the 2nd step\\n            }\\n            return maxToCoin\\n        }\\n        val start = dfs1(i, 0)\\n        if (start[0] == -1) return 0\\n\\n        visited.clear()\\n        val trimmed = HashSet<Int>()\\n        // 2nd DFS - calculating the final set of nodes\\n        // It\\'s very similar to the 1st DFS\\n        fun dfs(v: Int, len: Int): Int {\\n            visited.add(v)\\n            val edges = graph[v] ?: return -1\\n            var maxToCoin = -1\\n            for (v2 in edges) {\\n                if (!visited.contains(v2)) {\\n                    maxToCoin = maxOf(dfs(v2, len+1), maxToCoin)\\n                }\\n            }\\n            if (maxToCoin == -1) return if (coins[v] == 1) 1 else -1\\n            if (maxToCoin > 1 && len > 1 ) trimmed.add(v)\\n            return maxToCoin + 1\\n        }\\n        dfs(start[0], 0)\\n        if (trimmed.size == 0) return 0\\n        return (trimmed.size - 1) * 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346062,
                "title": "javascript-o-n-dfs-trim-leaves",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} coins\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar collectTheCoins = function(coins, edges) {\\n  function dfs(idx, pVal) {\\n    // if value is 3, we maybe able to trim this node direclty\\n    //if value is 2 or 1, we need to update step(at most 2 distance \\'pVal-1\\'), \\n    value[idx] = Math.min(value[idx], pVal === 3 ? pVal : pVal - 1);\\n    if (map[idx].size > 1 || value[idx] === 0) {\\n      return;\\n    }\\n\\n    if (map[idx].size === 1) {\\n      countEdges--;\\n      for (let next of map[idx]) {\\n        map[idx].delete(next);\\n        map[next].delete(idx);\\n        dfs(next, value[idx]);\\n      }\\n    }\\n  }\\n\\n  const len = coins.length;\\n  const map = new Array(len).fill().map((_) => new Set());\\n  const value = new Array(len).fill();\\n  for (let i = 0; i < len; ++i) {\\n    // 2 means it is a coin, 3 means it is not a coin.\\n    value[i] = coins[i] === 1 ? 2 : 3;\\n  }\\n  for (let [a, b] of edges) {\\n    map[a].add(b);\\n    map[b].add(a);\\n  }\\n  // q to store all the leave nodes\\n  const q = [];\\n  for (let i = 0; i < map.length; ++i) {\\n    if (map[i].size === 1) {\\n      q.push(i);\\n    }\\n  }\\n\\n  let countEdges = len-1;\\n  for (let c of q) {\\n    dfs(c, 3);\\n  }\\n\\n  return 2 * countEdges;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} coins\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar collectTheCoins = function(coins, edges) {\\n  function dfs(idx, pVal) {\\n    // if value is 3, we maybe able to trim this node direclty\\n    //if value is 2 or 1, we need to update step(at most 2 distance \\'pVal-1\\'), \\n    value[idx] = Math.min(value[idx], pVal === 3 ? pVal : pVal - 1);\\n    if (map[idx].size > 1 || value[idx] === 0) {\\n      return;\\n    }\\n\\n    if (map[idx].size === 1) {\\n      countEdges--;\\n      for (let next of map[idx]) {\\n        map[idx].delete(next);\\n        map[next].delete(idx);\\n        dfs(next, value[idx]);\\n      }\\n    }\\n  }\\n\\n  const len = coins.length;\\n  const map = new Array(len).fill().map((_) => new Set());\\n  const value = new Array(len).fill();\\n  for (let i = 0; i < len; ++i) {\\n    // 2 means it is a coin, 3 means it is not a coin.\\n    value[i] = coins[i] === 1 ? 2 : 3;\\n  }\\n  for (let [a, b] of edges) {\\n    map[a].add(b);\\n    map[b].add(a);\\n  }\\n  // q to store all the leave nodes\\n  const q = [];\\n  for (let i = 0; i < map.length; ++i) {\\n    if (map[i].size === 1) {\\n      q.push(i);\\n    }\\n  }\\n\\n  let countEdges = len-1;\\n  for (let c of q) {\\n    dfs(c, 3);\\n  }\\n\\n  return 2 * countEdges;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3345598,
                "title": "java-two-time-bfs-trim-work-from-leaves",
                "content": "```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n = coins.length;\\n        int unvisitedCnt = n;\\n        if (n < 6) return 0;\\n        int[] degrees = new int[n];\\n        Map<Integer, List<Integer>> tree = buildTree(edges, degrees);\\n        pruneTree(tree, degrees, coins);\\n        return minMoves(tree, degrees);\\n    }\\n    \\n    private int minMoves(Map<Integer, List<Integer>> tree, int[] degrees) {\\n        Queue<Integer> que = new ArrayDeque<>();\\n        int[] deepestLeafStep = new int[degrees.length];\\n        int[] moves = new int[degrees.length];\\n        int unvisitedCnt = 0;\\n        for (int node = 0; node < degrees.length; node++) {\\n            if (degrees[node] > 0) unvisitedCnt++; \\n            if (degrees[node] == 1) {\\n                que.offer(node);\\n            }\\n        }\\n        while (unvisitedCnt > 2) {\\n            int size = que.size();\\n            for (int i = 0; i < size; i++) {\\n                int curNode = que.poll();\\n                unvisitedCnt--;\\n                for (int nextNode : tree.getOrDefault(curNode, Collections.emptyList())) {\\n                    degrees[nextNode]--;\\n                    if (degrees[nextNode] < 0) continue;\\n                    if (degrees[nextNode] == 1) {\\n                        que.offer(nextNode);\\n                    }\\n                    deepestLeafStep[nextNode] = Math.max(deepestLeafStep[nextNode], deepestLeafStep[curNode] + 1);\\n                    moves[nextNode] += (deepestLeafStep[curNode] >= 2 ? moves[curNode] + 2 : 0);\\n                }\\n            }\\n        }\\n        \\n        int minMoves = unvisitedCnt == 2 ? 2 : 0;\\n        while (!que.isEmpty()) {\\n            int curNode = que.poll();\\n            if (deepestLeafStep[curNode] < 2 && unvisitedCnt == 2) minMoves--; \\n            minMoves += moves[curNode];\\n        }\\n        return minMoves;\\n    }\\n    \\n    private void pruneTree(Map<Integer, List<Integer>> tree, int[] degrees, int[] coins) {\\n        Queue<Integer> que = new ArrayDeque<>();\\n        for (int node = 0; node < degrees.length; node++) {\\n            if (degrees[node] == 1 && coins[node] == 0) {\\n                degrees[node] = 0;\\n                que.offer(node);\\n            }\\n        }\\n        while (!que.isEmpty()) {\\n            int curNode = que.poll();\\n            for (int nextNode : tree.getOrDefault(curNode, Collections.emptyList())) {\\n                degrees[nextNode]--;\\n                if (degrees[nextNode] == 1 && coins[nextNode] == 0) {\\n                    degrees[nextNode] = 0;\\n                    que.offer(nextNode);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private Map<Integer, List<Integer>> buildTree(int[][] edges, int[] degrees) {\\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        for (int[] e : edges) {\\n            int from = e[0];\\n            int to = e[1];\\n            tree.computeIfAbsent(from, k->new ArrayList<>()).add(to);\\n            tree.computeIfAbsent(to, k->new ArrayList<>()).add(from);\\n            degrees[from]++;\\n            degrees[to]++;\\n        }\\n        return tree;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n = coins.length;\\n        int unvisitedCnt = n;\\n        if (n < 6) return 0;\\n        int[] degrees = new int[n];\\n        Map<Integer, List<Integer>> tree = buildTree(edges, degrees);\\n        pruneTree(tree, degrees, coins);\\n        return minMoves(tree, degrees);\\n    }\\n    \\n    private int minMoves(Map<Integer, List<Integer>> tree, int[] degrees) {\\n        Queue<Integer> que = new ArrayDeque<>();\\n        int[] deepestLeafStep = new int[degrees.length];\\n        int[] moves = new int[degrees.length];\\n        int unvisitedCnt = 0;\\n        for (int node = 0; node < degrees.length; node++) {\\n            if (degrees[node] > 0) unvisitedCnt++; \\n            if (degrees[node] == 1) {\\n                que.offer(node);\\n            }\\n        }\\n        while (unvisitedCnt > 2) {\\n            int size = que.size();\\n            for (int i = 0; i < size; i++) {\\n                int curNode = que.poll();\\n                unvisitedCnt--;\\n                for (int nextNode : tree.getOrDefault(curNode, Collections.emptyList())) {\\n                    degrees[nextNode]--;\\n                    if (degrees[nextNode] < 0) continue;\\n                    if (degrees[nextNode] == 1) {\\n                        que.offer(nextNode);\\n                    }\\n                    deepestLeafStep[nextNode] = Math.max(deepestLeafStep[nextNode], deepestLeafStep[curNode] + 1);\\n                    moves[nextNode] += (deepestLeafStep[curNode] >= 2 ? moves[curNode] + 2 : 0);\\n                }\\n            }\\n        }\\n        \\n        int minMoves = unvisitedCnt == 2 ? 2 : 0;\\n        while (!que.isEmpty()) {\\n            int curNode = que.poll();\\n            if (deepestLeafStep[curNode] < 2 && unvisitedCnt == 2) minMoves--; \\n            minMoves += moves[curNode];\\n        }\\n        return minMoves;\\n    }\\n    \\n    private void pruneTree(Map<Integer, List<Integer>> tree, int[] degrees, int[] coins) {\\n        Queue<Integer> que = new ArrayDeque<>();\\n        for (int node = 0; node < degrees.length; node++) {\\n            if (degrees[node] == 1 && coins[node] == 0) {\\n                degrees[node] = 0;\\n                que.offer(node);\\n            }\\n        }\\n        while (!que.isEmpty()) {\\n            int curNode = que.poll();\\n            for (int nextNode : tree.getOrDefault(curNode, Collections.emptyList())) {\\n                degrees[nextNode]--;\\n                if (degrees[nextNode] == 1 && coins[nextNode] == 0) {\\n                    degrees[nextNode] = 0;\\n                    que.offer(nextNode);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private Map<Integer, List<Integer>> buildTree(int[][] edges, int[] degrees) {\\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        for (int[] e : edges) {\\n            int from = e[0];\\n            int to = e[1];\\n            tree.computeIfAbsent(from, k->new ArrayList<>()).add(to);\\n            tree.computeIfAbsent(to, k->new ArrayList<>()).add(from);\\n            degrees[from]++;\\n            degrees[to]++;\\n        }\\n        return tree;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345485,
                "title": "trim-from-leaf-then-count-the-edges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CollectTheCoins(int[] coins, int[][] edges) {\\n        int n = coins.Length;\\n        if(n<2) return 0;\\n        if(coins.Sum()==0) return 0;\\n        \\n        \\n        List<int>[] inDegrees = new List<int>[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            inDegrees[i] = new List<int>();\\n        }\\n        int[] accumulatedOneStepCoins = new int[n];\\n        int[] accumulatedTwoStepCoins = new int[n];\\n        \\n        foreach(var edge in edges)\\n        {\\n            inDegrees[edge[0]].Add(edge[1]);\\n            inDegrees[edge[1]].Add(edge[0]); \\n        }\\n        \\n        Queue<int> leaf = new Queue<int>();\\n        \\n        for(int i=0; i<n ;i++)\\n        {\\n            accumulatedOneStepCoins[i] = 0;\\n            accumulatedTwoStepCoins[i] = 0;\\n            \\n            if(inDegrees[i].Count==1)\\n                leaf.Enqueue(i);\\n        }\\n        \\n        while(leaf.Count>0)\\n        {\\n            int node = leaf.Dequeue();\\n            \\n            if(accumulatedTwoStepCoins[node] ==0 && inDegrees[node].Count>0)\\n            {\\n                int N = inDegrees[node][0]; \\n                if(coins[node]==1)\\n                { \\n                  accumulatedOneStepCoins[N] += 1;\\n                }\\n                if(accumulatedOneStepCoins[node]!=0)\\n                {\\n                    accumulatedTwoStepCoins[N] += accumulatedOneStepCoins[node];\\n                }\\n                inDegrees[N].Remove(node);\\n                \\n                inDegrees[node].Clear();\\n                \\n                if(inDegrees[N].Count==1 && accumulatedTwoStepCoins[N]==0)\\n                    leaf.Enqueue(N);\\n            }\\n        }\\n        \\n        int remainings = inDegrees.Count(n=>n.Count>0);\\n        return remainings==0?0:2*(remainings-1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CollectTheCoins(int[] coins, int[][] edges) {\\n        int n = coins.Length;\\n        if(n<2) return 0;\\n        if(coins.Sum()==0) return 0;\\n        \\n        \\n        List<int>[] inDegrees = new List<int>[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            inDegrees[i] = new List<int>();\\n        }\\n        int[] accumulatedOneStepCoins = new int[n];\\n        int[] accumulatedTwoStepCoins = new int[n];\\n        \\n        foreach(var edge in edges)\\n        {\\n            inDegrees[edge[0]].Add(edge[1]);\\n            inDegrees[edge[1]].Add(edge[0]); \\n        }\\n        \\n        Queue<int> leaf = new Queue<int>();\\n        \\n        for(int i=0; i<n ;i++)\\n        {\\n            accumulatedOneStepCoins[i] = 0;\\n            accumulatedTwoStepCoins[i] = 0;\\n            \\n            if(inDegrees[i].Count==1)\\n                leaf.Enqueue(i);\\n        }\\n        \\n        while(leaf.Count>0)\\n        {\\n            int node = leaf.Dequeue();\\n            \\n            if(accumulatedTwoStepCoins[node] ==0 && inDegrees[node].Count>0)\\n            {\\n                int N = inDegrees[node][0]; \\n                if(coins[node]==1)\\n                { \\n                  accumulatedOneStepCoins[N] += 1;\\n                }\\n                if(accumulatedOneStepCoins[node]!=0)\\n                {\\n                    accumulatedTwoStepCoins[N] += accumulatedOneStepCoins[node];\\n                }\\n                inDegrees[N].Remove(node);\\n                \\n                inDegrees[node].Clear();\\n                \\n                if(inDegrees[N].Count==1 && accumulatedTwoStepCoins[N]==0)\\n                    leaf.Enqueue(N);\\n            }\\n        }\\n        \\n        int remainings = inDegrees.Count(n=>n.Count>0);\\n        return remainings==0?0:2*(remainings-1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345434,
                "title": "c-trim-3-times",
                "content": "# Intuition\\nstep 1: bfs trim all no coin vetex from leaf\\nstep 2: trim all leaf\\nstep 3: trim all leaf\\nreturn numEdges * 2\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        const int n = coins.size();\\n        vector<set<int>> g(n);\\n        for(auto& e:edges){\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);           \\n        }\\n        bfsTrim(g, coins);\\n        trimOnce(g);\\n        trimOnce(g);\\n        return max<int>(0, 2* count_if(g.begin(), g.end(), [](auto& st){return !st.empty();}) - 2);    \\n    }\\n\\n    void bfsTrim(vector<set<int>>& g, const vector<int>& coin){\\n        auto isLeaf = [&](int i){return g[i].size() == 1 && coin[i] == 0;};\\n        queue<int> q;\\n        for(int i=0;i<g.size();i++) if (isLeaf(i)) q.push(i);\\n        while(!q.empty()){\\n            auto i = q.front(); q.pop();\\n            for(auto j:g[i]){\\n                g[j].erase(i);\\n                if(isLeaf(j)) q.push(j);\\n            }\\n            g[i].clear();\\n        }\\n    }\\n\\n    void trimOnce(vector<set<int>>& g){\\n        vector<int> toTrim;\\n        for(int i=0;i<g.size();i++) if(g[i].size() == 1) toTrim.push_back(i);\\n        for(auto i : toTrim){\\n            for(auto j:g[i]) g[j].erase(i);\\n            g[i].clear();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        const int n = coins.size();\\n        vector<set<int>> g(n);\\n        for(auto& e:edges){\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);           \\n        }\\n        bfsTrim(g, coins);\\n        trimOnce(g);\\n        trimOnce(g);\\n        return max<int>(0, 2* count_if(g.begin(), g.end(), [](auto& st){return !st.empty();}) - 2);    \\n    }\\n\\n    void bfsTrim(vector<set<int>>& g, const vector<int>& coin){\\n        auto isLeaf = [&](int i){return g[i].size() == 1 && coin[i] == 0;};\\n        queue<int> q;\\n        for(int i=0;i<g.size();i++) if (isLeaf(i)) q.push(i);\\n        while(!q.empty()){\\n            auto i = q.front(); q.pop();\\n            for(auto j:g[i]){\\n                g[j].erase(i);\\n                if(isLeaf(j)) q.push(j);\\n            }\\n            g[i].clear();\\n        }\\n    }\\n\\n    void trimOnce(vector<set<int>>& g){\\n        vector<int> toTrim;\\n        for(int i=0;i<g.size();i++) if(g[i].size() == 1) toTrim.push_back(i);\\n        for(auto i : toTrim){\\n            for(auto j:g[i]) g[j].erase(i);\\n            g[i].clear();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345339,
                "title": "trim-leaves-c",
                "content": "For Intuition visit [this solution](https://leetcode.com/problems/collect-coins-in-a-tree/post-solution/#:~:text=https%3A//leetcode.com/problems/collect%2Dcoins%2Din%2Da%2Dtree/solutions/3342149/clear%2Dexplanation%2Do%2Dn%2Dc%2Dcode/%3ForderBy%3Dmost_votes). Trim the leaves method.\\nHere is a shorter code.\\n\\n# Code\\n```\\nclass Solution {\\n    void rem(vector<vector<int>> &adj, int u, int v){  // Remove the edge u-v\\n        int nodePair[] = {u, v};\\n        for(int i=0; i<=1; i++){\\n            for(auto it = adj[nodePair[i]].begin(); it != adj[nodePair[i]].end(); it++){\\n                if(*it == nodePair[i^1]){\\n                    adj[nodePair[i]].erase(it);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        if(accumulate(coins.begin(), coins.end(), 0) <= 1)    return 0;\\n\\n        int n = coins.size(), ans = edges.size();\\n        vector<vector<int>> adj(n);\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        // Round 0 -> Remove leaves with no coins.  Round 1 & 2 (Leaves with coins are remaining only) -> Transfer coin to parents and remove the leaves\\n        for(int round=0; round<3; round++){ \\n            vector<int> leaves;\\n\\n            for(int i=0; i<n; i++){\\n                if(adj[i].size() == 1){  // Leaf node\\n                    if(round == 0 && coins[i] > 0)    continue;\\n                    leaves.push_back(i);\\n                }\\n            }\\n\\n            for(auto node : leaves){\\n                do{\\n                    int parent = adj[node][0];\\n                    rem(adj, parent, node);\\n                    ans--;  // 1 edge removed\\n\\n                    if(round >= 1)    coins[parent] = 1;  // Coin transfered to parent\\n\\n                    node = parent;  // Only for Round-0 : if the parent becomes leaf node (need to remove it).\\n                }\\n                while(coins[node] == 0 && adj[node].size() == 1);  // Leaf node with no coin\\n            }\\n            // For Round 1 & 2 the while loop runs only once\\n        }\\n\\n        return max(0, ans*2);  // ans -> Remaining edges (and every edge will be traversed twice)\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void rem(vector<vector<int>> &adj, int u, int v){  // Remove the edge u-v\\n        int nodePair[] = {u, v};\\n        for(int i=0; i<=1; i++){\\n            for(auto it = adj[nodePair[i]].begin(); it != adj[nodePair[i]].end(); it++){\\n                if(*it == nodePair[i^1]){\\n                    adj[nodePair[i]].erase(it);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        if(accumulate(coins.begin(), coins.end(), 0) <= 1)    return 0;\\n\\n        int n = coins.size(), ans = edges.size();\\n        vector<vector<int>> adj(n);\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        // Round 0 -> Remove leaves with no coins.  Round 1 & 2 (Leaves with coins are remaining only) -> Transfer coin to parents and remove the leaves\\n        for(int round=0; round<3; round++){ \\n            vector<int> leaves;\\n\\n            for(int i=0; i<n; i++){\\n                if(adj[i].size() == 1){  // Leaf node\\n                    if(round == 0 && coins[i] > 0)    continue;\\n                    leaves.push_back(i);\\n                }\\n            }\\n\\n            for(auto node : leaves){\\n                do{\\n                    int parent = adj[node][0];\\n                    rem(adj, parent, node);\\n                    ans--;  // 1 edge removed\\n\\n                    if(round >= 1)    coins[parent] = 1;  // Coin transfered to parent\\n\\n                    node = parent;  // Only for Round-0 : if the parent becomes leaf node (need to remove it).\\n                }\\n                while(coins[node] == 0 && adj[node].size() == 1);  // Leaf node with no coin\\n            }\\n            // For Round 1 & 2 the while loop runs only once\\n        }\\n\\n        return max(0, ans*2);  // ans -> Remaining edges (and every edge will be traversed twice)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345301,
                "title": "c-trimming-the-tree-clean-code-easy-to-understand",
                "content": "# Approach\\nWe need to delete some nodes of the tree and keep a count of the deleted nodes.\\n- We firstly remove all the leaf nodes that do not have coins as these nodes are of no use to us.\\n- Now, there might be some leaf nodes that have coin. Since we can collect coins at a distance of 2 from the current node, so we can delete 2 nodes including the leaf node and transfer the coin from the leaf node to it\\'s neighbour. Doing this won\\'t affect our answer.\\n- Now, similar to the previous step, we remove the unecessary nodes in the tree keeping in mind that we can delete at max 2 nodes at once.\\n- Answer to the problem will be `2 * remaining nodes`. We are multiplying by 2 as we have to come back to the initial node as described in the question. So, `ans = 2 * (n - cnt - 1)`, where `ans = answer, n = total number of nodes, cnt = number of nodes deleted`.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void remove(vector<int> &edge, int v) {\\n        int n = edge.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(edge[i] == v)\\n            {\\n                edge.erase(edge.begin()+i);\\n                return;\\n            }\\n        }\\n    }\\n\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n = coins.size();\\n        int cnt = 0;\\n        \\n        vector<vector<int>> adj(n,vector<int>());\\n        for(auto it : edges)\\n        {\\n            int u = it[0], v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int j = i;\\n            while(coins[j]==0 && adj[j].size()==1)\\n            {\\n                int nbr = adj[j][0];\\n                remove(adj[j],nbr);\\n                remove(adj[nbr],j);\\n                cnt++;\\n                j = nbr;\\n            }\\n        }\\n\\n        vector<bool> vis(n,false);\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i] && coins[i]==1 && adj[i].size()==1)\\n            {\\n                int nbr = adj[i][0];\\n                remove(adj[i],nbr);\\n                remove(adj[nbr],i);\\n                cnt++;\\n                coins[nbr] = 1;\\n                vis[nbr] = true;\\n            }\\n        }\\n\\n        vis.clear();\\n        vis.resize(n,false);\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i] && coins[i]==1 && adj[i].size()==1)\\n            {\\n                int nbr = adj[i][0];\\n                remove(adj[i],nbr);\\n                remove(adj[nbr],i);\\n                cnt++;\\n                vis[nbr] = true;\\n            }\\n        }\\n\\n        int ans = n - cnt - 1;\\n        ans *= 2;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void remove(vector<int> &edge, int v) {\\n        int n = edge.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(edge[i] == v)\\n            {\\n                edge.erase(edge.begin()+i);\\n                return;\\n            }\\n        }\\n    }\\n\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n = coins.size();\\n        int cnt = 0;\\n        \\n        vector<vector<int>> adj(n,vector<int>());\\n        for(auto it : edges)\\n        {\\n            int u = it[0], v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int j = i;\\n            while(coins[j]==0 && adj[j].size()==1)\\n            {\\n                int nbr = adj[j][0];\\n                remove(adj[j],nbr);\\n                remove(adj[nbr],j);\\n                cnt++;\\n                j = nbr;\\n            }\\n        }\\n\\n        vector<bool> vis(n,false);\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i] && coins[i]==1 && adj[i].size()==1)\\n            {\\n                int nbr = adj[i][0];\\n                remove(adj[i],nbr);\\n                remove(adj[nbr],i);\\n                cnt++;\\n                coins[nbr] = 1;\\n                vis[nbr] = true;\\n            }\\n        }\\n\\n        vis.clear();\\n        vis.resize(n,false);\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i] && coins[i]==1 && adj[i].size()==1)\\n            {\\n                int nbr = adj[i][0];\\n                remove(adj[i],nbr);\\n                remove(adj[nbr],i);\\n                cnt++;\\n                vis[nbr] = true;\\n            }\\n        }\\n\\n        int ans = n - cnt - 1;\\n        ans *= 2;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345261,
                "title": "java-code-with-explanation-tree-trimming-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n = coins.length;\\n        ArrayList<Integer> al[] = new ArrayList[coins.length];\\n        for(int i=0;i<n;i++){\\n            al[i] = new ArrayList<>();\\n        }\\n         int deg[] = new int[n];\\n        for(int i=0;i<edges.length;i++){\\n            al[edges[i][0]].add(edges[i][1]);\\n            al[edges[i][1]].add(edges[i][0]);\\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(al[i].size()==1 && coins[i]==0){\\n                q.add(i);\\n                deg[i]=0;\\n            }\\n        }\\n       \\n        while(q.size()>0){\\n            int v = q.remove();\\n            for(int vv:al[v]){\\n               deg[vv]--;\\n                if(deg[vv]==1 && coins[vv]==0){\\n                    q.add(vv);\\n                    deg[vv]=0;\\n                }\\n            }\\n        }\\n        \\n        int dis[] = new int[n];\\n        q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(coins[i]==1 && deg[i]==1){\\n              //  al[i] = new ArrayList<>();\\n                q.add(i);\\n                deg[i]=0;\\n            }\\n        }\\n        \\n        while(q.size()>0){\\n            int p = q.remove();\\n            for(int vv:al[p]){\\n                if(deg[vv]>0){\\n                dis[vv] = Math.max(dis[p]+1,dis[vv]);\\n                deg[vv]--;\\n                if(deg[vv]==1){\\n                    q.add(vv);\\n                    deg[vv]=0;\\n                }\\n            }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(dis[i]>=2) ans += 2;\\n        }\\n        return Math.max(ans-2,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n = coins.length;\\n        ArrayList<Integer> al[] = new ArrayList[coins.length];\\n        for(int i=0;i<n;i++){\\n            al[i] = new ArrayList<>();\\n        }\\n         int deg[] = new int[n];\\n        for(int i=0;i<edges.length;i++){\\n            al[edges[i][0]].add(edges[i][1]);\\n            al[edges[i][1]].add(edges[i][0]);\\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(al[i].size()==1 && coins[i]==0){\\n                q.add(i);\\n                deg[i]=0;\\n            }\\n        }\\n       \\n        while(q.size()>0){\\n            int v = q.remove();\\n            for(int vv:al[v]){\\n               deg[vv]--;\\n                if(deg[vv]==1 && coins[vv]==0){\\n                    q.add(vv);\\n                    deg[vv]=0;\\n                }\\n            }\\n        }\\n        \\n        int dis[] = new int[n];\\n        q = new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            if(coins[i]==1 && deg[i]==1){\\n              //  al[i] = new ArrayList<>();\\n                q.add(i);\\n                deg[i]=0;\\n            }\\n        }\\n        \\n        while(q.size()>0){\\n            int p = q.remove();\\n            for(int vv:al[p]){\\n                if(deg[vv]>0){\\n                dis[vv] = Math.max(dis[p]+1,dis[vv]);\\n                deg[vv]--;\\n                if(deg[vv]==1){\\n                    q.add(vv);\\n                    deg[vv]=0;\\n                }\\n            }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(dis[i]>=2) ans += 2;\\n        }\\n        return Math.max(ans-2,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344899,
                "title": "golang-solution",
                "content": "```\\nfunc collectTheCoins(coins []int, edges [][]int) int {\\n\\tn := len(coins)\\n\\tgraph := make([][]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tgraph[i] = make([]int, 0)\\n\\t}\\n\\tfor _, edge := range edges {\\n\\t\\tgraph[edge[0]] = append(graph[edge[0]], edge[1])\\n\\t\\tgraph[edge[1]] = append(graph[edge[1]], edge[0])\\n\\t}\\n\\n\\tleaf := make([]int, 0)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tu := i\\n\\t\\tfor len(graph[u]) == 1 && coins[u] == 0 {\\n\\t\\t\\tv := graph[u][0]\\n\\t\\t\\tgraph[u] = graph[u][1:]\\n\\t\\t\\tgraph[v] = removeElement(graph[v], u)\\n\\t\\t\\tu = v\\n\\t\\t}\\n\\t\\tif len(graph[u]) == 1 {\\n\\t\\t\\tleaf = append(leaf, u)\\n\\t\\t}\\n\\t}\\n\\n\\tfor k := 2; k > 0; k-- {\\n\\t\\tfor l := len(leaf); l > 0; l-- {\\n\\t\\t\\tu := leaf[0]\\n\\t\\t\\tleaf = leaf[1:]\\n\\t\\t\\tif len(graph[u]) != 0 {\\n\\t\\t\\t\\tv := graph[u][0]\\n\\t\\t\\t\\tgraph[u] = graph[u][1:]\\n\\t\\t\\t\\tgraph[v] = removeElement(graph[v], u)\\n\\t\\t\\t\\tif len(graph[v]) == 1 {\\n\\t\\t\\t\\t\\tleaf = append(leaf, v)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tsum := 0\\n\\tfor _, list := range graph {\\n\\t\\tsum += len(list)\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc removeElement(slice []int, element int) []int {\\n\\tindex := -1\\n\\tfor i, e := range slice {\\n\\t\\tif e == element {\\n\\t\\t\\tindex = i\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\tif index == -1 {\\n\\t\\treturn slice\\n\\t}\\n\\treturn append(slice[:index], slice[index+1:]...)\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc collectTheCoins(coins []int, edges [][]int) int {\\n\\tn := len(coins)\\n\\tgraph := make([][]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tgraph[i] = make([]int, 0)\\n\\t}\\n\\tfor _, edge := range edges {\\n\\t\\tgraph[edge[0]] = append(graph[edge[0]], edge[1])\\n\\t\\tgraph[edge[1]] = append(graph[edge[1]], edge[0])\\n\\t}\\n\\n\\tleaf := make([]int, 0)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tu := i\\n\\t\\tfor len(graph[u]) == 1 && coins[u] == 0 {\\n\\t\\t\\tv := graph[u][0]\\n\\t\\t\\tgraph[u] = graph[u][1:]\\n\\t\\t\\tgraph[v] = removeElement(graph[v], u)\\n\\t\\t\\tu = v\\n\\t\\t}\\n\\t\\tif len(graph[u]) == 1 {\\n\\t\\t\\tleaf = append(leaf, u)\\n\\t\\t}\\n\\t}\\n\\n\\tfor k := 2; k > 0; k-- {\\n\\t\\tfor l := len(leaf); l > 0; l-- {\\n\\t\\t\\tu := leaf[0]\\n\\t\\t\\tleaf = leaf[1:]\\n\\t\\t\\tif len(graph[u]) != 0 {\\n\\t\\t\\t\\tv := graph[u][0]\\n\\t\\t\\t\\tgraph[u] = graph[u][1:]\\n\\t\\t\\t\\tgraph[v] = removeElement(graph[v], u)\\n\\t\\t\\t\\tif len(graph[v]) == 1 {\\n\\t\\t\\t\\t\\tleaf = append(leaf, v)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tsum := 0\\n\\tfor _, list := range graph {\\n\\t\\tsum += len(list)\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc removeElement(slice []int, element int) []int {\\n\\tindex := -1\\n\\tfor i, e := range slice {\\n\\t\\tif e == element {\\n\\t\\t\\tindex = i\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\tif index == -1 {\\n\\t\\treturn slice\\n\\t}\\n\\treturn append(slice[:index], slice[index+1:]...)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3344747,
                "title": "c-easy-bfs-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n = coins.size(), totEdg = 2 * edges.size(), del = 0;\\n        set<int> adj[n];\\n        queue<int> q;\\n        for(auto &e : edges) adj[e[0]].insert(e[1]), adj[e[1]].insert(e[0]);\\n        for(int i = 0; i<n; ++i) if(adj[i].size() == 1 && !coins[i]) q.push(i);\\n        while(q.size()){\\n            int nn = q.front(); q.pop();\\n            if(!adj[nn].size()) continue;\\n            int par = *adj[nn].begin();\\n            adj[par].erase(adj[par].find(nn));\\n            del++;\\n            adj[nn].erase(adj[nn].find(par));\\n            del++;\\n            if(adj[par].size() == 1 && !coins[par]) q.push(par);\\n        }\\n        for(int i = 0; i < n; ++i) if(adj[i].size() == 1) q.push(i);\\n        for(int i = 0; i< 2; ++i){\\n            int sz = q.size();\\n            while(sz--){\\n                int nn = q.front(); q.pop();\\n                if(!adj[nn].size()) continue;\\n                int par = *adj[nn].begin();\\n                adj[par].erase(adj[par].find(nn));\\n                del++;\\n                adj[nn].erase(adj[nn].find(par));\\n                del++;\\n                if(adj[par].size() == 1) q.push(par);\\n            }\\n        }\\n        return totEdg - del;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        int n = coins.size(), totEdg = 2 * edges.size(), del = 0;\\n        set<int> adj[n];\\n        queue<int> q;\\n        for(auto &e : edges) adj[e[0]].insert(e[1]), adj[e[1]].insert(e[0]);\\n        for(int i = 0; i<n; ++i) if(adj[i].size() == 1 && !coins[i]) q.push(i);\\n        while(q.size()){\\n            int nn = q.front(); q.pop();\\n            if(!adj[nn].size()) continue;\\n            int par = *adj[nn].begin();\\n            adj[par].erase(adj[par].find(nn));\\n            del++;\\n            adj[nn].erase(adj[nn].find(par));\\n            del++;\\n            if(adj[par].size() == 1 && !coins[par]) q.push(par);\\n        }\\n        for(int i = 0; i < n; ++i) if(adj[i].size() == 1) q.push(i);\\n        for(int i = 0; i< 2; ++i){\\n            int sz = q.size();\\n            while(sz--){\\n                int nn = q.front(); q.pop();\\n                if(!adj[nn].size()) continue;\\n                int par = *adj[nn].begin();\\n                adj[par].erase(adj[par].find(nn));\\n                del++;\\n                adj[nn].erase(adj[nn].find(par));\\n                del++;\\n                if(adj[par].size() == 1) q.push(par);\\n            }\\n        }\\n        return totEdg - del;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344603,
                "title": "java-49ms-tree-trimming-and-ranking",
                "content": "# Intuition & Approach\\nThe intuition and the approach are essentially same as https://leetcode.com/problems/collect-coins-in-a-tree/solutions/3342476/java-trim-empty-leaves-then-trim-remaining-leaves-twice-to-shrink-the-radius-to-0/?languageTags=java\\nThis solution leverages degree of each node and rank (the distance to the farthest leaf with coin) to optimize the actual performance.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n = coins.length, output = -2;\\n        ArrayList<Integer>[] adjacencies = new ArrayList[n];\\n        int[] degrees = new int[n], ranks = new int[n];\\n        LinkedList<Integer> queue = new LinkedList<>();\\n\\n        // Build adjacencies matrix and compute degrees\\n        for (int i = 0; i < n; i++) adjacencies[i] = new ArrayList<>();\\n        for (int[] e : edges) for (int i = 0; i < 2; i++) {\\n            adjacencies[e[i]].add(e[1 - i]);\\n            degrees[e[i]]++;\\n        }\\n\\n        // Trim branches with no coins\\n        for (int i = 0; i < n; i++) if (coins[i] == 0 && degrees[i] == 1) {\\n            degrees[i] = 0;\\n            queue.add(i);\\n        }\\n        while (!queue.isEmpty()) for (int next : adjacencies[queue.removeFirst()]) if (degrees[next] > 0 && --degrees[next] == 1 && coins[next] == 0) {\\n            degrees[next] = 0;\\n            queue.add(next);\\n        }\\n\\n        // Rank each remaining node with the longest distance to a leaf\\n        // Note a leaf now always has a coin\\n        for (int i = 0; i < n; i++) if (coins[i] == 1 && degrees[i] == 1) {\\n            degrees[i] = 0;\\n            queue.add(i);\\n        }\\n        while (!queue.isEmpty()) {\\n            int t = queue.removeFirst();\\n            for (int next : adjacencies[t]) if (degrees[next] > 0) {\\n                ranks[next] = Math.max(ranks[next], ranks[t] + 1);\\n                if (--degrees[next] == 1) {\\n                    degrees[next] = 0;\\n                    queue.add(next);\\n                }\\n            }\\n        }\\n\\n        // We only need to visit nodes ranked 2 or more.\\n        // This is equivalent to the \"trimming trees twice\" idea in other threads.\\n        for (int i = 0; i < n; i++) if (ranks[i] > 1) output += 2;\\n        return Math.max(output, 0);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int collectTheCoins(int[] coins, int[][] edges) {\\n        int n = coins.length, output = -2;\\n        ArrayList<Integer>[] adjacencies = new ArrayList[n];\\n        int[] degrees = new int[n], ranks = new int[n];\\n        LinkedList<Integer> queue = new LinkedList<>();\\n\\n        // Build adjacencies matrix and compute degrees\\n        for (int i = 0; i < n; i++) adjacencies[i] = new ArrayList<>();\\n        for (int[] e : edges) for (int i = 0; i < 2; i++) {\\n            adjacencies[e[i]].add(e[1 - i]);\\n            degrees[e[i]]++;\\n        }\\n\\n        // Trim branches with no coins\\n        for (int i = 0; i < n; i++) if (coins[i] == 0 && degrees[i] == 1) {\\n            degrees[i] = 0;\\n            queue.add(i);\\n        }\\n        while (!queue.isEmpty()) for (int next : adjacencies[queue.removeFirst()]) if (degrees[next] > 0 && --degrees[next] == 1 && coins[next] == 0) {\\n            degrees[next] = 0;\\n            queue.add(next);\\n        }\\n\\n        // Rank each remaining node with the longest distance to a leaf\\n        // Note a leaf now always has a coin\\n        for (int i = 0; i < n; i++) if (coins[i] == 1 && degrees[i] == 1) {\\n            degrees[i] = 0;\\n            queue.add(i);\\n        }\\n        while (!queue.isEmpty()) {\\n            int t = queue.removeFirst();\\n            for (int next : adjacencies[t]) if (degrees[next] > 0) {\\n                ranks[next] = Math.max(ranks[next], ranks[t] + 1);\\n                if (--degrees[next] == 1) {\\n                    degrees[next] = 0;\\n                    queue.add(next);\\n                }\\n            }\\n        }\\n\\n        // We only need to visit nodes ranked 2 or more.\\n        // This is equivalent to the \"trimming trees twice\" idea in other threads.\\n        for (int i = 0; i < n; i++) if (ranks[i] > 1) output += 2;\\n        return Math.max(output, 0);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344527,
                "title": "100-space-fastest-simple-to-understand-beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs per question we need atmost edges awaay from wher we can collect the coins thats it we wil remove the leaf vertex without coins than with coins left graph is our solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple remove the leaf vertex those whose dont have coin untill you left with vertex having two or more vertexs.\\nthen we will remove the leaf vertex having coins but Note we have minimize the vertex needed to travel and we need at most 2 vertexs away so we assign that coin to its neighbour vertex,\\nits final to remove the all vertex with coins \\nWith removing the vertex decrease the no of edges.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(number of vertex)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(number of vertex)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void trim(vector<int> &arr,int k){\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==k){\\n                arr.erase(arr.begin()+i);return;\\n            }\\n        }\\n    }\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        vector<vector<int>> grp(coins.size());\\n        int ans=edges.size();// total number of edges\\n        for(int i=0;i<edges.size();i++){// construction of graph\\n            grp[edges[i][0]].push_back(edges[i][1]);\\n            grp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<coins.size();i++){// removing the leaf vertex with no coins\\n            int x=i;\\n            while(coins[x]==0&&grp[x].size()==1){\\n                int p=grp[x][0];\\n                trim(grp[x],p);\\n                trim(grp[p],x);\\n                ans--;\\n                x=p;\\n            }\\n        }\\n        vector<bool>visit(coins.size(),false);// to avoid revisiting ones visited vertex\\n         for(int i=0;i<coins.size();i++){// removing the leaf vertex with coin and assining its coin to next one\\n            if(visit[i]==false&&coins[i]==1&&grp[i].size()==1){\\n                int p=grp[i][0];\\n                trim(grp[i],p);\\n                trim(grp[p],i);\\n                ans--;\\n                coins[p]=1;\\n                visit[p]=true;\\n            }\\n        }\\n        fill(visit.begin(),visit.end(),false);\\n         for(int i=0;i<coins.size();i++){/// removing the all vertex to meet atmost 2 vertex distance\\n            if(visit[i]==false&&coins[i]==1&&grp[i].size()==1){\\n                int p=grp[i][0];\\n                trim(grp[i],p);\\n                trim(grp[p],i);\\n                ans--;\\n                visit[p]=true;\\n            }\\n        }\\n        ans*=2;// as we are traveling back and fro a single edge\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Rejection Sampling"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void trim(vector<int> &arr,int k){\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==k){\\n                arr.erase(arr.begin()+i);return;\\n            }\\n        }\\n    }\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        vector<vector<int>> grp(coins.size());\\n        int ans=edges.size();// total number of edges\\n        for(int i=0;i<edges.size();i++){// construction of graph\\n            grp[edges[i][0]].push_back(edges[i][1]);\\n            grp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<coins.size();i++){// removing the leaf vertex with no coins\\n            int x=i;\\n            while(coins[x]==0&&grp[x].size()==1){\\n                int p=grp[x][0];\\n                trim(grp[x],p);\\n                trim(grp[p],x);\\n                ans--;\\n                x=p;\\n            }\\n        }\\n        vector<bool>visit(coins.size(),false);// to avoid revisiting ones visited vertex\\n         for(int i=0;i<coins.size();i++){// removing the leaf vertex with coin and assining its coin to next one\\n            if(visit[i]==false&&coins[i]==1&&grp[i].size()==1){\\n                int p=grp[i][0];\\n                trim(grp[i],p);\\n                trim(grp[p],i);\\n                ans--;\\n                coins[p]=1;\\n                visit[p]=true;\\n            }\\n        }\\n        fill(visit.begin(),visit.end(),false);\\n         for(int i=0;i<coins.size();i++){/// removing the all vertex to meet atmost 2 vertex distance\\n            if(visit[i]==false&&coins[i]==1&&grp[i].size()==1){\\n                int p=grp[i][0];\\n                trim(grp[i],p);\\n                trim(grp[p],i);\\n                ans--;\\n                visit[p]=true;\\n            }\\n        }\\n        ans*=2;// as we are traveling back and fro a single edge\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344387,
                "title": "racket-tree-trimming-solution",
                "content": "# Intuition\\n\\nBrute force\\n\\n# Approach\\n\\n1. Find the minimum spanning tree of the coin nodes in the given tree\\n2. remove all edge nodes twice\\n\\n# Complexity\\n\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\nwhere $n$ is the number of nodes.\\n\\n# Code\\n\\nThe last line states the logic.\\n\\n```\\n(define (collect-the-coins coins edges)\\n  (define has-coin?\\n    (let ([coin-set (mutable-set)])\\n      (for ([c coins]\\n            [i (in-naturals 0)])\\n        (when (= 1 c)\\n          (set-add! coin-set i)))\\n      (\\u03BB (i) (set-member? coin-set i))))\\n\\n  (define (adj-of tree i)\\n    (hash-ref (first tree) i \\'()))\\n\\n  (define (build-tree edges)\\n    (define adj-list (make-hash))\\n    (for ([e edges])\\n      (hash-update! adj-list (first e) (\\u03BB (old) (cons (second e) old)) \\'())\\n      (hash-update! adj-list (second e) (\\u03BB (old) (cons (first e) old)) \\'()))\\n    (list adj-list edges))\\n\\n  (define (remove-edge-nodes tree)\\n    (match-define (list adjs edges) tree)\\n    (define edge-nodes\\n      (for/set ([(k v) adjs]\\n                #:when (= 1 (length v)))\\n        k))\\n    (define new-edges\\n      (filter-not (\\u03BB (e) (or (set-member? edge-nodes (first e))\\n                             (set-member? edge-nodes (second e))))\\n                  edges))\\n    (build-tree new-edges))\\n\\n  (define (count-edges tree)\\n    (length (second tree)))\\n\\n  (define (build-min-tree edges)\\n    (define min-tree-edges \\'())\\n\\n    (define (gen-min-edges tree root from)\\n      (define has-coin-tree? (has-coin? root))\\n      (for ([adj (adj-of tree root)]\\n            #:when (not (= adj from)))\\n        (define has-coin-subtree? (gen-min-edges tree adj root))\\n        (when has-coin-subtree?\\n          (set! min-tree-edges (cons (list root adj) min-tree-edges)))\\n        (set! has-coin-tree? (or has-coin-tree? has-coin-subtree?)))\\n      has-coin-tree?)\\n\\n    (define tree (build-tree edges))\\n    (for/first ([i (length coins)]\\n                #:when (has-coin? i))\\n      (gen-min-edges tree i -1))\\n\\n    (build-tree min-tree-edges))\\n\\n  (* 2 (count-edges (remove-edge-nodes (remove-edge-nodes (build-min-tree edges))))))\\n\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```\\n(define (collect-the-coins coins edges)\\n  (define has-coin?\\n    (let ([coin-set (mutable-set)])\\n      (for ([c coins]\\n            [i (in-naturals 0)])\\n        (when (= 1 c)\\n          (set-add! coin-set i)))\\n      (\\u03BB (i) (set-member? coin-set i))))\\n\\n  (define (adj-of tree i)\\n    (hash-ref (first tree) i \\'()))\\n\\n  (define (build-tree edges)\\n    (define adj-list (make-hash))\\n    (for ([e edges])\\n      (hash-update! adj-list (first e) (\\u03BB (old) (cons (second e) old)) \\'())\\n      (hash-update! adj-list (second e) (\\u03BB (old) (cons (first e) old)) \\'()))\\n    (list adj-list edges))\\n\\n  (define (remove-edge-nodes tree)\\n    (match-define (list adjs edges) tree)\\n    (define edge-nodes\\n      (for/set ([(k v) adjs]\\n                #:when (= 1 (length v)))\\n        k))\\n    (define new-edges\\n      (filter-not (\\u03BB (e) (or (set-member? edge-nodes (first e))\\n                             (set-member? edge-nodes (second e))))\\n                  edges))\\n    (build-tree new-edges))\\n\\n  (define (count-edges tree)\\n    (length (second tree)))\\n\\n  (define (build-min-tree edges)\\n    (define min-tree-edges \\'())\\n\\n    (define (gen-min-edges tree root from)\\n      (define has-coin-tree? (has-coin? root))\\n      (for ([adj (adj-of tree root)]\\n            #:when (not (= adj from)))\\n        (define has-coin-subtree? (gen-min-edges tree adj root))\\n        (when has-coin-subtree?\\n          (set! min-tree-edges (cons (list root adj) min-tree-edges)))\\n        (set! has-coin-tree? (or has-coin-tree? has-coin-subtree?)))\\n      has-coin-tree?)\\n\\n    (define tree (build-tree edges))\\n    (for/first ([i (length coins)]\\n                #:when (has-coin? i))\\n      (gen-min-edges tree i -1))\\n\\n    (build-tree min-tree-edges))\\n\\n  (* 2 (count-edges (remove-edge-nodes (remove-edge-nodes (build-min-tree edges))))))\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3344304,
                "title": "python-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def collectTheCoins(self, C, E):\\n        n = len(E) + 1\\n        if n == 1: return 0\\n        graph = [[] for _ in range(n)]\\n        in_degree = [0] * n\\n        A = deque()\\n        B = deque()\\n        vis = [False] * n\\n        ans = 0\\n        for a, b in E:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            in_degree[a] += 1\\n            in_degree[b] += 1\\n        for i in range(n):\\n            if in_degree[i] == 1:\\n                vis[i] = True\\n                if C[i] == 0:\\n                    A.append(i)\\n                else:\\n                    B.append(i)\\n        while A:\\n            k = A.popleft()\\n            for i in graph[k]:\\n                in_degree[i] -= 1\\n                if vis[i] == False and in_degree[i] == 1:\\n                    vis[i] = True\\n                    if C[i] == 0:\\n                        A.append(i)\\n                    else:\\n                        B.append(i)\\n        for _ in range(len(B)): \\n            u = B.popleft()\\n            for i in graph[u]:\\n                in_degree[i] -= 1\\n                if vis[i] == False and in_degree[i] == 1:\\n                    vis[i] = True\\n                    B.append(i)\\n        for i in range(n):\\n            if vis[i] == False: ans += 1\\n        return max(0, 2 * ans - 2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def collectTheCoins(self, C, E):\\n        n = len(E) + 1\\n        if n == 1: return 0\\n        graph = [[] for _ in range(n)]\\n        in_degree = [0] * n\\n        A = deque()\\n        B = deque()\\n        vis = [False] * n\\n        ans = 0\\n        for a, b in E:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            in_degree[a] += 1\\n            in_degree[b] += 1\\n        for i in range(n):\\n            if in_degree[i] == 1:\\n                vis[i] = True\\n                if C[i] == 0:\\n                    A.append(i)\\n                else:\\n                    B.append(i)\\n        while A:\\n            k = A.popleft()\\n            for i in graph[k]:\\n                in_degree[i] -= 1\\n                if vis[i] == False and in_degree[i] == 1:\\n                    vis[i] = True\\n                    if C[i] == 0:\\n                        A.append(i)\\n                    else:\\n                        B.append(i)\\n        for _ in range(len(B)): \\n            u = B.popleft()\\n            for i in graph[u]:\\n                in_degree[i] -= 1\\n                if vis[i] == False and in_degree[i] == 1:\\n                    vis[i] = True\\n                    B.append(i)\\n        for i in range(n):\\n            if vis[i] == False: ans += 1\\n        return max(0, 2 * ans - 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343924,
                "title": "c-trim-the-tree",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        vector< set <int> > ed(edges.size() + 1); \\n        int del_leave;\\n        set<int>::iterator parent; \\n        vector<int> del; \\n        int edgesCnt=edges.size()*2, delCnt=0;\\n        \\n        for (auto edge : edges){\\n            ed[edge[0]].insert(edge[1]);\\n            ed[edge[1]].insert(edge[0]);\\n        }\\n\\n        auto deleteNodes = [&] (auto self, int firstStep) -> void {\\n            while (del.size()) {\\n                del_leave = del[del.size() - 1]; \\n                parent = ed[del_leave].begin(); \\n                ed[*parent].erase(del_leave); \\n                del.pop_back(); \\n                if (firstStep && ed[*parent].size() == 1 && coins[*parent] == 0) { // parent has become a leaf?\\n                    del.push_back(*parent); \\n                    coins[*parent] = -1; \\n                }\\n                ed[del_leave].clear();                 \\n                delCnt += 2; \\n            }\\n        }; \\n\\n        for (int k = 0; k < 3; k++) { //  k = 0 removing leaves with no coins, k = 1 and k = 2 removing leaves twice \\n            for (int i = 0; i < ed.size(); i++) \\n                if (ed[i].size() == 1 && (k> 0 || coins[i] == 0)) {del.push_back(i);  coins[i] = -1;}\\n                deleteNodes(deleteNodes, k == 0);\\n        }    \\n        \\n        return max(0,edgesCnt - delCnt); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\\n        vector< set <int> > ed(edges.size() + 1); \\n        int del_leave;\\n        set<int>::iterator parent; \\n        vector<int> del; \\n        int edgesCnt=edges.size()*2, delCnt=0;\\n        \\n        for (auto edge : edges){\\n            ed[edge[0]].insert(edge[1]);\\n            ed[edge[1]].insert(edge[0]);\\n        }\\n\\n        auto deleteNodes = [&] (auto self, int firstStep) -> void {\\n            while (del.size()) {\\n                del_leave = del[del.size() - 1]; \\n                parent = ed[del_leave].begin(); \\n                ed[*parent].erase(del_leave); \\n                del.pop_back(); \\n                if (firstStep && ed[*parent].size() == 1 && coins[*parent] == 0) { // parent has become a leaf?\\n                    del.push_back(*parent); \\n                    coins[*parent] = -1; \\n                }\\n                ed[del_leave].clear();                 \\n                delCnt += 2; \\n            }\\n        }; \\n\\n        for (int k = 0; k < 3; k++) { //  k = 0 removing leaves with no coins, k = 1 and k = 2 removing leaves twice \\n            for (int i = 0; i < ed.size(); i++) \\n                if (ed[i].size() == 1 && (k> 0 || coins[i] == 0)) {del.push_back(i);  coins[i] = -1;}\\n                deleteNodes(deleteNodes, k == 0);\\n        }    \\n        \\n        return max(0,edgesCnt - delCnt); \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2069186,
                "content": [
                    {
                        "username": "bitnpc",
                        "content": "What if we don\\'t need to go back to the initial vertex?"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can we solve this by dsu?"
                    }
                ]
            },
            {
                "id": 1843889,
                "content": [
                    {
                        "username": "bitnpc",
                        "content": "What if we don\\'t need to go back to the initial vertex?"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can we solve this by dsu?"
                    }
                ]
            }
        ]
    }
]