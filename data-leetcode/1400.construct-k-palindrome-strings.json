[
    {
        "title": "Construct K Palindrome Strings",
        "question_content": "Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise.\n&nbsp;\nExample 1:\n\nInput: s = \"annabelle\", k = 2\nOutput: true\nExplanation: You can construct two palindromes using all characters in s.\nSome possible constructions \"anna\" + \"elble\", \"anbna\" + \"elle\", \"anellena\" + \"b\"\n\nExample 2:\n\nInput: s = \"leetcode\", k = 3\nOutput: false\nExplanation: It is impossible to construct 3 palindromes using all the characters of s.\n\nExample 3:\n\nInput: s = \"true\", k = 4\nOutput: true\nExplanation: The only possible solution is to put each character in a separate string.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts consists of lowercase English letters.\n\t1 <= k <= 105",
        "solutions": [
            {
                "id": 563379,
                "title": "java-c-python-straight-forward",
                "content": "# **Intuition**\\nCondition 1. `odd characters <= k`\\nCount the occurrences of all characters.\\nIf one character has odd times occurrences,\\nthere must be at least one palindrome,\\nwith odd length and this character in the middle.\\nSo we count the characters that appear odd times,\\nthe number of odd character should not be bigger than `k`.\\n\\nCondition 2. `k <= s.length()`\\nAlso, if we have one character in each palindrome,\\nwe will have at most `s.length()`  palindromes,\\nso we need `k <= s.length()`.\\n\\nThe above two condition are necessary and sufficient conditions for this problem.\\nSo we return `odd <= k <= n`\\n<br>\\n\\n# **Construction**\\n@spjparmar immediately got a question like why this works always for all strings.\\nHe gave the some following dry runs. :)\\nFor any string with 0 odd character count , we can form k no. of palindrome strings for sure with k<=n\\n(This is why k<=n)\\n\\n**eg**\\naabb, k=1| abba\\naabb, k=2 | aa, bb\\naabb, k=3 | a, a, bb\\naabb, k=4 | a, a, b, b\\n\\nFor any string with odd character count <=k , we can always form k palindrome string for sure with k<=n\\n**eg2**\\naabbc, k=1 | aacbb\\naabbc, k=2 | aca, bb\\naabbc, k=3 | a,a, bcb\\naabbc, k=4 | a, a, c ,bb\\naabbc, k=5 | a, a, c, b, b\\n\\n**eg3**\\naabc, k=1 | N/A\\naabc, k=2 | aba, c\\naabc, k=3 | aa, b, c\\naabc, k=4 | a, a, b, c\\n\\nHope this helps somebody.\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0, n = s.length(), count[] = new int[26];\\n        for (int i = 0; i < n; ++i) {\\n            count[s.charAt(i) - \\'a\\'] ^= 1;\\n            odd += count[s.charAt(i) - \\'a\\'] > 0 ? 1 : -1;\\n        }\\n        return odd <= k && k <= n;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    bool canConstruct(string s, int k) {\\n        bitset<26> odd;\\n        for (char& c : s)\\n            odd.flip(c - \\'a\\');\\n        return odd.count() <= k && k <= s.length();\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def canConstruct(self, s, k):\\n        return sum(i & 1 for i in collections.Counter(s).values()) <= k <= len(s)\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0, n = s.length(), count[] = new int[26];\\n        for (int i = 0; i < n; ++i) {\\n            count[s.charAt(i) - \\'a\\'] ^= 1;\\n            odd += count[s.charAt(i) - \\'a\\'] > 0 ? 1 : -1;\\n        }\\n        return odd <= k && k <= n;\\n    }\\n```\n```cpp\\n    bool canConstruct(string s, int k) {\\n        bitset<26> odd;\\n        for (char& c : s)\\n            odd.flip(c - \\'a\\');\\n        return odd.count() <= k && k <= s.length();\\n    }\\n```\n```py\\n    def canConstruct(self, s, k):\\n        return sum(i & 1 for i in collections.Counter(s).values()) <= k <= len(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 563298,
                "title": "java-python-3-count-odd-occurrences-2-codes-w-brief-explanation-and-analysis",
                "content": "**Explanation of the method** - credit to **@lionkingeatapple**\\nIf we need to construct `k` palindromes, and each palindrome at most has`1` character with odd times of occurrence. The oddest times of occurrence we can have is `1 * k = k`. Therefore, `oddNum <= k`. And it is impossible to construct `k` palindromes when the input string s\\'s length is less than `k`. So we can conclude that in order to construct `k` palindromes it must satisfy the condition `oddNum <= k` && `k <= s.length()`.\\n\\n----\\n\\n1. Each palindrome at most has one character with odd times of occurrence;\\n2. `Non-empty` means each  palindrome at least has one character, hence `k <= s.length()`.\\n\\n**Method 1:**\\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++count[s.charAt(i) - \\'a\\'];\\n        }\\n        int oddNum = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            oddNum += count[i] % 2;\\n        }\\n        return oddNum <= k && k <= s.length();\\n    }\\n```\\nOr make the above 2 for loops as 1:\\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int[] count = new int[26];\\n        int oddNum = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            oddNum += ++count[s.charAt(i) - \\'a\\'] % 2 == 0 ? -1 : 1;\\n        }\\n        return oddNum <= k && k <= s.length();\\n    }\\n```\\n```python\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return sum(v % 2 for v in collections.Counter(s).values()) <= k <= len(s)\\n```\\n\\n----\\n\\n**Method 2:**\\nOr use bit manipulation:\\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            odd ^= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        return Integer.bitCount(odd) <= k && k <= s.length();\\n    }\\n```\\n```python\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        odd = 0\\n        for c in s:\\n            odd ^= 1 << (ord(c) - ord(\\'a\\'))\\n        return bin(odd).count(\\'1\\') <= k <= len(s)\\n```\\n\\n**Analysis:**\\nTime: O(n), space: O(1), where n = s.length().",
                "solutionTags": [],
                "code": "```java\\n    public boolean canConstruct(String s, int k) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++count[s.charAt(i) - \\'a\\'];\\n        }\\n        int oddNum = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            oddNum += count[i] % 2;\\n        }\\n        return oddNum <= k && k <= s.length();\\n    }\\n```\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int[] count = new int[26];\\n        int oddNum = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            oddNum += ++count[s.charAt(i) - \\'a\\'] % 2 == 0 ? -1 : 1;\\n        }\\n        return oddNum <= k && k <= s.length();\\n    }\\n```\n```python\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return sum(v % 2 for v in collections.Counter(s).values()) <= k <= len(s)\\n```\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            odd ^= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        return Integer.bitCount(odd) <= k && k <= s.length();\\n    }\\n```\n```python\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        odd = 0\\n        for c in s:\\n            odd ^= 1 << (ord(c) - ord(\\'a\\'))\\n        return bin(odd).count(\\'1\\') <= k <= len(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 809033,
                "title": "clear-python-3-solution-faster-than-91-with-explanation",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k > len(s):\\n            return False\\n        h = Counter(s)\\n        countOdd = 0\\n        for value in h.values():\\n            if value % 2:\\n                countOdd += 1\\n        if countOdd > k:\\n            return False\\n        return True\\n```\\nThe solution is based on the understanding that a string can be a palindrome only if it has **at most 1 character** whose frequency is odd. So if the number of characters having an odd frequency is greater than the number of palindromes we need to form, then naturally it\\'s impossible to do so.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k > len(s):\\n            return False\\n        h = Counter(s)\\n        countOdd = 0\\n        for value in h.values():\\n            if value % 2:\\n                countOdd += 1\\n        if countOdd > k:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337643,
                "title": "c-super-simple-solution-only-6-short-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (s.size() < k) return false;\\n        \\n        vector<int> freq(26);\\n        for (auto ch : s) freq[ch - \\'a\\']++;\\n        \\n        int odd = 0;\\n        for (auto f : freq) odd += (f % 2);\\n        \\n        return odd <= k;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (s.size() < k) return false;\\n        \\n        vector<int> freq(26);\\n        for (auto ch : s) freq[ch - \\'a\\']++;\\n        \\n        int odd = 0;\\n        for (auto f : freq) odd += (f % 2);\\n        \\n        return odd <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564236,
                "title": "java-counting-simple-explained",
                "content": "Idea is following: count of chars can be even or odd. Those that are even - they can be used in one of substrings to form the palindrome, so we don\\'t care about those.\\nIf character has odd frequency - it can be inserted only 1 or 3 or 5... etc. to form the palindrome. However number of such characters cannot be more than number of strings, in other words - only one such char is allowed per substring. \\nThis leads to solution - count all frequencies, count those that are odd. If number of such chars > then k - it\\'s not possible to balance it to form all palindromes.\\n\\nO(n) time - iterate over every char in string to count freq.\\nO(1) space - use fixed size array to count freq.\\n\\n```\\n  public boolean canConstruct(String s, int k) {\\n    if (s == null || s.isEmpty() || s.length() < k)\\n      return false;\\n    \\n    int[] count = new int[26];\\n    //count freq of every character\\n    for (char ch : s.toCharArray()) ++count[ch - \\'a\\'];\\n    //count chars that has odd freq\\n    int countOfOdd = 0;\\n    for (int i = 0; i < 26; i++) \\n      if (count[i] % 2 == 1)\\n        ++countOfOdd;\\n    return countOfOdd <= k;\\n  }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n  public boolean canConstruct(String s, int k) {\\n    if (s == null || s.isEmpty() || s.length() < k)\\n      return false;\\n    \\n    int[] count = new int[26];\\n    //count freq of every character\\n    for (char ch : s.toCharArray()) ++count[ch - \\'a\\'];\\n    //count chars that has odd freq\\n    int countOfOdd = 0;\\n    for (int i = 0; i < 26; i++) \\n      if (count[i] % 2 == 1)\\n        ++countOfOdd;\\n    return countOfOdd <= k;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563647,
                "title": "java-o-n-time-and-o-1-space-beats-100",
                "content": "We can just simply use a 26 bit integer to store the set bits and then use XOR to flip the bits. \\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            odd ^= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        \\n        return Integer.bitCount(odd) <= k && k <= s.length(); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            odd ^= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        \\n        return Integer.bitCount(odd) <= k && k <= s.length(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563311,
                "title": "c-number-of-odd-frequency-character",
                "content": "If `k` is more than `n` then palindromes are never possible.\\nOtherwise, if the odd frequency character count is less than `k`, you can always make `k` palindromes.\\n\\nFor example : `s = Leetcode` and `k = 5`\\n\\nWe have odd freq characters : `{L, e, t, c, o, d}` , we can create 5 palindromes, but then atleast one of the characters from these odd frequency ones, will be left, Hence false.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(k > n)\\n            return 0;\\n        if(k == n)\\n            return 1;\\n        vector<int> f(26);\\n        for(int i = 0; i < n; i++)\\n            f[s[i] - \\'a\\']++;\\n        \\n        int c = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            if(f[i] % 2 == 1)\\n                c++;\\n        }\\n        return c <= k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(k > n)\\n            return 0;\\n        if(k == n)\\n            return 1;\\n        vector<int> f(26);\\n        for(int i = 0; i < n; i++)\\n            f[s[i] - \\'a\\']++;\\n        \\n        int c = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            if(f[i] % 2 == 1)\\n                c++;\\n        }\\n        return c <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911162,
                "title": "c-easy-t-c-o-n-and-s-c-o-1-beats-98-4-in-t-c-and-95-in-s-c",
                "content": "# Intuition: \\nCount for the number of charachters having odd number of occurences\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\nIf the number of odd occurences of charachters are less than k, we can partition the string in k no.of palndromes.We are counting for odd occurences because eve occurences can be arranged in any order around the \\'centre\\' of the palindrome.And we need to check additionally, if the k is less than the length of the string to be partiotined, then we don\\'t have any way do partition it.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n\\n        int a[26];  // to store the count of charachters\\n        memset(a,0,sizeof(a));\\n        int n=s.length();\\n        if(k>n)return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            a[s[i]-\\'a\\']++;\\n        }\\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            // if count is odd, then increment the resultant\\n            if(a[i]%2)res++;\\n        }\\n        return res<=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n\\n        int a[26];  // to store the count of charachters\\n        memset(a,0,sizeof(a));\\n        int n=s.length();\\n        if(k>n)return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            a[s[i]-\\'a\\']++;\\n        }\\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            // if count is odd, then increment the resultant\\n            if(a[i]%2)res++;\\n        }\\n        return res<=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382658,
                "title": "easy-c-explaination-o-n-using-map",
                "content": "class Solution {\\npublic:\\n\\n//         we can have only odd number of a particular char only one time in a pallindrome\\n   ```\\n bool canConstruct(string s, int k) \\n{\\n\\t\\t if(s.size()<k)\\n\\t\\t\\t\\treturn false;\\n       unordered_map<char,int> frq;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                    frq[s[i]]++;\\n            }\\n            int cnt=0;\\n            for(auto x: frq)\\n                    \\n            {\\n                    if(x.second%2==1)\\n                            cnt++;\\n            }\\n            if(cnt>k)\\n                    return false;\\n           else\\n            return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n//         we can have only odd number of a particular char only one time in a pallindrome\\n   ```\\n bool canConstruct(string s, int k) \\n{\\n\\t\\t if(s.size()<k)\\n\\t\\t\\t\\treturn false;\\n       unordered_map<char,int> frq;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                    frq[s[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1351209,
                "title": "simple-java-solution",
                "content": "-Count all odd number of characters in string and check whether they are less or equal to k\\n```\\npublic boolean canConstruct(String s, int k) {\\n\\t\\tif(s.length()<k) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character,Integer> map=new HashMap<>();\\n\\t\\tfor(char c:s.toCharArray()) {\\n\\t\\t\\tmap.put(c,map.getOrDefault(c, 0)+1);\\n\\t\\t}\\n\\t\\tint odd=0;\\n\\t\\tfor(int count:map.values()) {\\n\\t\\t\\tif(count%2==1) {\\n\\t\\t\\t\\todd++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn odd<=k;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canConstruct(String s, int k) {\\n\\t\\tif(s.length()<k) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character,Integer> map=new HashMap<>();\\n\\t\\tfor(char c:s.toCharArray()) {\\n\\t\\t\\tmap.put(c,map.getOrDefault(c, 0)+1);\\n\\t\\t}\\n\\t\\tint odd=0;\\n\\t\\tfor(int count:map.values()) {\\n\\t\\t\\tif(count%2==1) {\\n\\t\\t\\t\\todd++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn odd<=k;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563330,
                "title": "python-count-odd",
                "content": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s) < k:\\n            return False\\n        \\n        dic = {}\\n        for x in s:\\n            if x not in dic:\\n                dic[x] = 1\\n            else:\\n                dic[x] += 1\\n        \\n        odd = 0\\n        for key,val in dic.items():        \\n            odd += val % 2\\n        even = len(dic) - odd\\n        \\n        \\n        return True if odd <= k else False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s) < k:\\n            return False\\n        \\n        dic = {}\\n        for x in s:\\n            if x not in dic:\\n                dic[x] = 1\\n            else:\\n                dic[x] += 1\\n        \\n        odd = 0\\n        for key,val in dic.items():        \\n            odd += val % 2\\n        even = len(dic) - odd\\n        \\n        \\n        return True if odd <= k else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566998,
                "title": "java-solution",
                "content": "class Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\t\\n        int n = s.length();\\n        \\n        if(n<k)\\n        {\\n            return false;\\n        }\\n        \\n        HashMap<Character,Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c = s.charAt(i);\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        \\n        int ans = 0; \\n        \\n        for(Map.Entry<Character,Integer> e:map.entrySet())\\n        {\\n            int v = e.getValue();\\n            \\n            if(v%2!=0)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans<=k;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\t\\n        int n = s.length();\\n        \\n        if(n<k)\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1674075,
                "title": "beginner-friendly-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int>mp;\\n        int counte=0,counto=0;\\n        for(auto ch:s){\\n            mp[ch]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2==0){\\n                counte++;\\n            }else{\\n                counto++;\\n            }\\n        }\\n        if(k>=counto&&s.length()>=k){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int>mp;\\n        int counte=0,counto=0;\\n        for(auto ch:s){\\n            mp[ch]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2==0){\\n                counte++;\\n            }else{\\n                counto++;\\n            }\\n        }\\n        if(k>=counto&&s.length()>=k){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419950,
                "title": "js-o-n-solution-with-comments",
                "content": "```\\nvar canConstruct = function(s, k) {\\n\\t// if string length is less than k, we cannot form k palindromes from the string, so return false\\n    if(k > s.length) {\\n        return false;\\n    }\\n\\t// created a map to keep count of each letter in the string\\n    const map = new Map();    // O(26)\\n    for(let i = 0; i < s.length; ++i) {    // O(n)\\n        map.set(s[i], map.has(s[i]) ? map.get(s[i]) + 1 : 1);\\n    }\\n\\t// check how many letters have odd count\\n    let oddCount = 0;\\n    map.forEach((value, key) => {    // O(26)\\n        if(value % 2 !== 0) {\\n            ++oddCount;\\n        }\\n    })\\n\\t// if letters with odd count are greater than k, that means more than k palindromes need to be formed to\\n\\t// make palindromes from the string where all the letters are utilised, so return false\\n\\t// palindrome can be of 2 form: `aaaaa` and `aabaa`, one letter can have odd and even occurences, but \\n\\t// there will be at least x palindromes if x letters are there with odd number of frequency\\n    if(oddCount > k) {\\n        return false;\\n    }\\n\\t// since the previous conditions do not hold, we can make k palindromes from the string, so return true\\n    return true;\\n};\\n```\\nTime Complexity = O(n)\\nSpace Complexity = O(26) ~ O(1)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConstruct = function(s, k) {\\n\\t// if string length is less than k, we cannot form k palindromes from the string, so return false\\n    if(k > s.length) {\\n        return false;\\n    }\\n\\t// created a map to keep count of each letter in the string\\n    const map = new Map();    // O(26)\\n    for(let i = 0; i < s.length; ++i) {    // O(n)\\n        map.set(s[i], map.has(s[i]) ? map.get(s[i]) + 1 : 1);\\n    }\\n\\t// check how many letters have odd count\\n    let oddCount = 0;\\n    map.forEach((value, key) => {    // O(26)\\n        if(value % 2 !== 0) {\\n            ++oddCount;\\n        }\\n    })\\n\\t// if letters with odd count are greater than k, that means more than k palindromes need to be formed to\\n\\t// make palindromes from the string where all the letters are utilised, so return false\\n\\t// palindrome can be of 2 form: `aaaaa` and `aabaa`, one letter can have odd and even occurences, but \\n\\t// there will be at least x palindromes if x letters are there with odd number of frequency\\n    if(oddCount > k) {\\n        return false;\\n    }\\n\\t// since the previous conditions do not hold, we can make k palindromes from the string, so return true\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 724516,
                "title": "c-solution-based-on-pidgeonhole-principle",
                "content": "If we have more odd frequency characters than palindromes, then at least 2 odd frequency characters must be in the same palindrome. Since this is not possible, we return true if we have fewer or equal to k odd frequency characters.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (s.size() < k) return false;\\n        \\n        vector<int> count(26, 0);\\n        for (char c: s)\\n            count[c-\\'a\\']++;\\n        \\n        int countOdd = count_if(count.begin(), count.end(), [](int i) {\\n            return i % 2;\\n        });\\n        \\n        // Pidgeonhole, 2 odd freq chars must be in a palindrome, which is impossible        \\n        return countOdd <= k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (s.size() < k) return false;\\n        \\n        vector<int> count(26, 0);\\n        for (char c: s)\\n            count[c-\\'a\\']++;\\n        \\n        int countOdd = count_if(count.begin(), count.end(), [](int i) {\\n            return i % 2;\\n        });\\n        \\n        // Pidgeonhole, 2 odd freq chars must be in a palindrome, which is impossible        \\n        return countOdd <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692722,
                "title": "o-1-most-detailed-explanation",
                "content": "The problem is quite simple and interesting as well. Lets start from very basic:\\n\\n**Q.** Suppose we are given a string ```str```, and we are free to jumble the characters, and we need to tell that wheather ```str``` can be palindrome after jumbling.\\n* So, we will keep a track of frequency of each character appeared in ```str``` (with the help of hashmap or array of size 26)\\n*  **Now how to check**: \\uD83D\\uDC49 Even occurances of any character ```c``` is allowed. But there must be either 0 or 1 character with odd occurances\\n*  For example: \"abba\" is palindrome and there are no character with odd frequency. Similarly, \"abcba\" or \"abcccba\" is also a palindrome but there is 1 character with odd frequency.\\n\\nKeeping this in mind: \\n* We will store the frequency of each character in input string using hashmap (or array of size 26).\\n* We have no issue with even frequency character. As they will always from palindrome.\\n* We are concerned with odd freq character. Count that how many character has odd frequency. [say cnt]\\n* In order to split input string into \\'k\\' palindromic string, number of odd freq character must be less than equal to k [or cnt<=k], \\n* This is because then only we can distribute each of the odd frequency character in one of the \\'k\\' strings.\\n* Simple! We are done! We are just required to check this condition only.\\n\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k){ return false; } // obvious edge case\\n        \\n        unordered_map<char, int> m; // {char, freq}\\n        for(int i=0; i<s.size(); i++){  m[s[i]]++;  }\\n\\t\\t\\n        int cnt=0; // to count odd freq character\\n        for(auto& it: m){\\n            if(it.second%2==1){ cnt++; }\\n        }\\n        return (cnt<=k);\\n    }\\n};\\n```\\nTime Complexity: O(26) ~ O(1)  ||  Space Complexity: O(26) ~ O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```str```\n```str```\n```str```\n```c```\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k){ return false; } // obvious edge case\\n        \\n        unordered_map<char, int> m; // {char, freq}\\n        for(int i=0; i<s.size(); i++){  m[s[i]]++;  }\\n\\t\\t\\n        int cnt=0; // to count odd freq character\\n        for(auto& it: m){\\n            if(it.second%2==1){ cnt++; }\\n        }\\n        return (cnt<=k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814817,
                "title": "c-python3-solution-xor",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Python3\\n```\\nclass Solution:\\n    def canConstruct(self, S, K):\\n        return bin(reduce(operator.xor, map(lambda x: 1 << (ord(x) - 97), S))).count(\\'1\\') <= K <= len(S)\\n```\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int val = 0;\\n        for(char c: s) val ^= (1 << (c - \\'a\\'));\\n        return k <= s.length() && __builtin_popcount(val) <= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, S, K):\\n        return bin(reduce(operator.xor, map(lambda x: 1 << (ord(x) - 97), S))).count(\\'1\\') <= K <= len(S)\\n```\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int val = 0;\\n        for(char c: s) val ^= (1 << (c - \\'a\\'));\\n        return k <= s.length() && __builtin_popcount(val) <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105478,
                "title": "python-beats-97-with-reasoning",
                "content": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\'\\'\\'\\n        For a palindrome, its odd-count character has to be less than or eqaul to one. \\n        Then in order to get k many palindromic substrings, the number of odd-count chracters in s has to be less than\\n        or equal to k \\'\\'\\'\\n        \\n        if len(s) < k:\\n            return False\\n        freq = Counter(s)\\n        return sum(1 for val in freq.values() if val % 2 != 0) <= k\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\'\\'\\'\\n        For a palindrome, its odd-count character has to be less than or eqaul to one. \\n        Then in order to get k many palindromic substrings, the number of odd-count chracters in s has to be less than\\n        or equal to k \\'\\'\\'\\n        \\n        if len(s) < k:\\n            return False\\n        freq = Counter(s)\\n        return sum(1 for val in freq.values() if val % 2 != 0) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070676,
                "title": "math-javascript",
                "content": "Code is self explantory.\\nBasically we will follow the below steps:\\n1. Calculate frequency of all the characters\\n2. Those characters whose frequency is odd, see if they are greater than 2. if > 2 then increment `evens` counts along\\n    with incrementing `odds`.\\n3. We **assume** \\tthat we will make palindromic string of size **1** only out of `odds` . \\n4. `k - odds` palindromic strings are required to be made out of `s.length - odds` characters. Which is possible as \\n    `k - odds < s.length - odds` which is resulted in (`odds` getting cancelled from both the side), `k < s.length` (which we are checking earlier in first line) \\n5. We can make `k - odds` strings out of `evens` which consitutes `s.length - odds` characters. \\n\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        /*\\n        * s = \\'cr\\', k = 7\\n        * Can not make 7 palindromic strings out of string length of 2\\n        *\\n        * In short, atleast k characters are required in the string.\\n        */\\n        return false;\\n    }\\n    \\n    if (s.length === k) {\\n        /*\\n        * s = \"true\", k = 4\\n        * Four palindromic strings of length 1 can be made out of s.\\n        */\\n        return true;\\n    }\\n    \\n    const hash = {};\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        hash[s[i]] || (hash[s[i]] = 0);\\n        hash[s[i]]++;\\n    }\\n    \\n    let odds = 0;\\n    let evens = 0;\\n    let key;\\n    \\n    const keys = Object.keys(hash);\\n    for(let i = 0; i < keys.length; i++) {\\n        key = keys[i];\\n        \\n        if (hash[key] % 2 === 0) {\\n            evens++;\\n        } else {\\n            if (Math.floor(hash[key] / 2) > 0) {\\n                /*\\n                * s = \"annabellebb\", b is 3 times, which is 2 + 1 => meaning, \\n                * there is only 1 b left hanging without getting paired. Which needs \\n                * chars around it to form palidromic sequence\\n                */\\n                evens++;\\n            }\\n            odds++;\\n        }\\n    }\\n    \\n    if (odds > k) {\\n        /*\\n        * s = \"leetcode\", k = 3\\n        * There are 5 chars with frequence 1. They can\\'t be clubbed together to form palindromic strings\\n        *\\n        * Return false if k > number of odds in `s`\\n        */\\n        return false;\\n    }\\n    \\n    /*\\n    * In any other cases where odds < k, we can fit all other evens as per requirement\\n    * For e.g. s = \"annabellebb\", k = 3.  \\n    * \\n    * evens => a, b, e, l, n.  odds => b\\n    * odds < k => 1 < 3. \\n    * We can make (k - odds) palindromic sequnce with given `evens`. \\n    * a = 2, b = 2, e = 2, l = 2, n = 2 => Total 10 characters except 1 loose `b`.\\n    * They can make (k - odds) => 5 - 1 => 4 palindromic strings easily. \\n    *\\n    * So, basically s.length - odds => 11 - 1 => 10 can be easily made by all evens together. s.length < k is already taken care of in start\\n    */\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        /*\\n        * s = \\'cr\\', k = 7\\n        * Can not make 7 palindromic strings out of string length of 2\\n        *\\n        * In short, atleast k characters are required in the string.\\n        */\\n        return false;\\n    }\\n    \\n    if (s.length === k) {\\n        /*\\n        * s = \"true\", k = 4\\n        * Four palindromic strings of length 1 can be made out of s.\\n        */\\n        return true;\\n    }\\n    \\n    const hash = {};\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        hash[s[i]] || (hash[s[i]] = 0);\\n        hash[s[i]]++;\\n    }\\n    \\n    let odds = 0;\\n    let evens = 0;\\n    let key;\\n    \\n    const keys = Object.keys(hash);\\n    for(let i = 0; i < keys.length; i++) {\\n        key = keys[i];\\n        \\n        if (hash[key] % 2 === 0) {\\n            evens++;\\n        } else {\\n            if (Math.floor(hash[key] / 2) > 0) {\\n                /*\\n                * s = \"annabellebb\", b is 3 times, which is 2 + 1 => meaning, \\n                * there is only 1 b left hanging without getting paired. Which needs \\n                * chars around it to form palidromic sequence\\n                */\\n                evens++;\\n            }\\n            odds++;\\n        }\\n    }\\n    \\n    if (odds > k) {\\n        /*\\n        * s = \"leetcode\", k = 3\\n        * There are 5 chars with frequence 1. They can\\'t be clubbed together to form palindromic strings\\n        *\\n        * Return false if k > number of odds in `s`\\n        */\\n        return false;\\n    }\\n    \\n    /*\\n    * In any other cases where odds < k, we can fit all other evens as per requirement\\n    * For e.g. s = \"annabellebb\", k = 3.  \\n    * \\n    * evens => a, b, e, l, n.  odds => b\\n    * odds < k => 1 < 3. \\n    * We can make (k - odds) palindromic sequnce with given `evens`. \\n    * a = 2, b = 2, e = 2, l = 2, n = 2 => Total 10 characters except 1 loose `b`.\\n    * They can make (k - odds) => 5 - 1 => 4 palindromic strings easily. \\n    *\\n    * So, basically s.length - odds => 11 - 1 => 10 can be easily made by all evens together. s.length < k is already taken care of in start\\n    */\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1797109,
                "title": "simple-c-java-python-solutions",
                "content": "### C++ Solution\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        vector<int> mapp(26, 0);\\n        for(char c : s) mapp[c-\\'a\\']++;\\n        \\n        int sum=0;\\n        for(int i=0; i<26; i++) sum+=(mapp[i]%2);\\n        \\n        return sum<=k;\\n    }\\n};\\n```\\n\\n### Java Solution\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length() < k) return false;\\n        int mapp[] = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            mapp[c-\\'a\\']++;\\n        }\\n        int sum=0;\\n        for(int i=0; i<26; i++) sum+=(mapp[i]%2);\\n        \\n        return sum<=k;\\n    }\\n}\\n```\\n\\n### Python Solution\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        mapp = [0]*26\\n        for c in s:\\n            mapp[ord(c) - ord(\\'a\\')]+=1\\n        \\n        summ = 0\\n        for i in range(26):\\n            summ += mapp[i]%2\\n        \\n        return summ<=k\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        vector<int> mapp(26, 0);\\n        for(char c : s) mapp[c-\\'a\\']++;\\n        \\n        int sum=0;\\n        for(int i=0; i<26; i++) sum+=(mapp[i]%2);\\n        \\n        return sum<=k;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length() < k) return false;\\n        int mapp[] = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            mapp[c-\\'a\\']++;\\n        }\\n        int sum=0;\\n        for(int i=0; i<26; i++) sum+=(mapp[i]%2);\\n        \\n        return sum<=k;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        mapp = [0]*26\\n        for c in s:\\n            mapp[ord(c) - ord(\\'a\\')]+=1\\n        \\n        summ = 0\\n        for i in range(26):\\n            summ += mapp[i]%2\\n        \\n        return summ<=k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737785,
                "title": "c-simple-with-intution",
                "content": "# you just need to check if the character that are present odd number of times are greater than k or not \\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.length();\\n        vector<int>A(26,0);\\n        int odd = 0;\\n        int even = 0;\\n        if(n < k)\\n            return false;\\n        for(char c : s)\\n            A[c - \\'a\\']++;\\n        for(int a : A)\\n        {\\n            if(a == 0)\\n                continue;\\n            if(a % 2 == 1)\\n                odd++;\\n            else\\n                even++;\\n        }\\n        if(odd > k)\\n            return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.length();\\n        vector<int>A(26,0);\\n        int odd = 0;\\n        int even = 0;\\n        if(n < k)\\n            return false;\\n        for(char c : s)\\n            A[c - \\'a\\']++;\\n        for(int a : A)\\n        {\\n            if(a == 0)\\n                continue;\\n            if(a % 2 == 1)\\n                odd++;\\n            else\\n                even++;\\n        }\\n        if(odd > k)\\n            return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617060,
                "title": "java-simple-code-with-detailed-explanation",
                "content": "## Explanation\\n\\nThe idea is quite simple, the core concept is separating the characters in 2 categories:\\n* The ones that have an even amount of occurrences \\n* The ones that have an odd amount of ocurrences.\\n\\n### Even characters\\nThe characters that appear an even number of times are not a problem at all. Why? Because we can add them at the beginning and end of the palindrome without breaking the palindrome condition.\\n\\nLet\\'s see an example where **A** appears an odd number of times:\\n\\n- **A**???**A**\\n- **AA**???**AA**\\n- **AAA**???**AAA**\\n\\nWe don\\'t care what\\'s inside of the sandwich where **A** is the bread.\\n\\n## Odd characters\\nThis is the limiting factor while forming palindromes. Odd characters **MUST** be in the middle of the palindrome , if not it wouldn\\'t be a palindrome.\\n\\n- ???**A**???\\n- ???**AAA**???\\n- ???**AAAAA**???\\n\\nAlso this kind of arrangement are valid but it changes nothing for us:\\n- **A**???**A**???**A**\\n\\nThe problem is that there can be **only middle section** (where we can use our odd characters) per palindrome. So everything gets reduced to counting the amount of odd characters and checking if we have less odd characters than the amount of palindromes __k__.\\n\\n\\n## Code\\nCode is very basic once you understand the idea.\\n\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (s == null || s.isEmpty() || s.length() < k) return false;\\n        int[] count = new int[26];\\n        int odd = 0;\\n\\n        // Count ocurrences\\n        for(char c : s.toCharArray()){\\n            count[c - \\'a\\']++;\\n        }\\n        \\n        // Count characters with odd number of occurrences\\n        for (int i = 0; i < 26 ; i++) {\\n            if (count[i] % 2 != 0) odd++;\\n        }\\n        \\n        return odd <= k;\\n    }\\n}\\n```\\n\\nHope you liked the post, and now some shameless self-promotion: My blog where I also post explanations to LeetCode challenges https://pablomusumeci.com/categories/#leetcode",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (s == null || s.isEmpty() || s.length() < k) return false;\\n        int[] count = new int[26];\\n        int odd = 0;\\n\\n        // Count ocurrences\\n        for(char c : s.toCharArray()){\\n            count[c - \\'a\\']++;\\n        }\\n        \\n        // Count characters with odd number of occurrences\\n        for (int i = 0; i < 26 ; i++) {\\n            if (count[i] % 2 != 0) odd++;\\n        }\\n        \\n        return odd <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442930,
                "title": "python-for-beginners",
                "content": "\\tclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        from collections import Counter\\n        if len(s)<k:\\n            return False\\n        v2=[v for v,b in Counter(s).items() if b%2==1]\\n        if len(v2)>k:\\n            return False    \\n        return True",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        from collections import Counter\\n        if len(s)<k:\\n            return False\\n        v2=[v for v,b in Counter(s).items() if b%2==1]\\n        if len(v2)>k:\\n            return False    \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1079757,
                "title": "javascript-solution-with-comments",
                "content": "```\\n    // return false if length of string is less than k\\n    if(s.length<k) {\\n        return false;\\n    }\\n    // compute frequency of each char in string\\n    let map = new Map();\\n    for(let letter of s) {\\n        map.set(letter,(map.get(letter)||0)+1);\\n    }\\n\\t// return true is size of map is equal to k\\n    if(map.size === k) {\\n        return true;\\n    }\\n\\t// return true or false based on if the odd char count is less than K, or greater than or equal to K.\\n    let count = 0;\\n    for(let key of map.keys()) {\\n        count += map.get(key)%2\\n    }\\n    return count<=k;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    // return false if length of string is less than k\\n    if(s.length<k) {\\n        return false;\\n    }\\n    // compute frequency of each char in string\\n    let map = new Map();\\n    for(let letter of s) {\\n        map.set(letter,(map.get(letter)||0)+1);\\n    }\\n\\t// return true is size of map is equal to k\\n    if(map.size === k) {\\n        return true;\\n    }\\n\\t// return true or false based on if the odd char count is less than K, or greater than or equal to K.\\n    let count = 0;\\n    for(let key of map.keys()) {\\n        count += map.get(key)%2\\n    }\\n    return count<=k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1029137,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar canConstruct = function(s, k) {\\n    if(k === s.length) return true;\\n    if(k > s.length) return false;\\n    \\n    const freq = Array(26).fill(0);\\n    \\n    for(let c of s) {\\n        const idx = c.charCodeAt() - \\'a\\'.charCodeAt();\\n        freq[idx]++;\\n    }\\n    const odds = freq.filter(x => x%2).length;\\n    return odds <= k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar canConstruct = function(s, k) {\\n    if(k === s.length) return true;\\n    if(k > s.length) return false;\\n    \\n    const freq = Array(26).fill(0);\\n    \\n    for(let c of s) {\\n        const idx = c.charCodeAt() - \\'a\\'.charCodeAt();\\n        freq[idx]++;\\n    }\\n    const odds = freq.filter(x => x%2).length;\\n    return odds <= k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016580,
                "title": "python-counting-solution",
                "content": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        counter = collections.Counter(s)\\n        odd = sum([1 for val in counter.values() if val % 2])\\n        return odd <= k and len(s) >= k",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        counter = collections.Counter(s)\\n        odd = sum([1 for val in counter.values() if val % 2])\\n        return odd <= k and len(s) >= k",
                "codeTag": "Java"
            },
            {
                "id": 679084,
                "title": "java-count-num-of-odds",
                "content": "False if either:\\n1, s.length() < k;\\nor \\n2, number of odd count chars > k;  (at most k char can be in the center)\\n```\\n    public boolean canConstruct(String s, int k) {\\n        if (s == null || s.length() < k) return false;\\n        int odds = 0, cnt[] = new int[26];\\n        for (char c : s.toCharArray()) cnt[c - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) odds += cnt[i] % 2;\\n        return odds <= k;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canConstruct(String s, int k) {\\n        if (s == null || s.length() < k) return false;\\n        int odds = 0, cnt[] = new int[26];\\n        for (char c : s.toCharArray()) cnt[c - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) odds += cnt[i] % 2;\\n        return odds <= k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 647852,
                "title": "faster-and-simpler",
                "content": "\\t\\tk>len(s):\\n            return False\\n        \\n        \\n        dc=collections.Counter(s)\\n        \\n        cnt=0\\n        for key,v in dc.items():\\n            if  v&1:\\n                cnt+=1\\n        if cnt > k:\\n            return False\\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t\\tk>len(s):\\n            return False\\n        \\n        \\n        dc=collections.Counter(s)\\n        \\n        cnt=0\\n        for key,v in dc.items():\\n            if  v&1:\\n                cnt+=1\\n        if cnt > k:\\n            return False\\n        return True",
                "codeTag": "Unknown"
            },
            {
                "id": 598638,
                "title": "super-easy-python-solution-with-explanation",
                "content": "\\n```\\n# The approach of the problem is that -\\n# 1) even length palindromes will have even no. of characters\\n# 2) odd length palindromes will have odd no. of characters\\n# 3) we can have only one letter in odd length palindrome which has odd occurence. \\n\\n# For eg:\\n#     s=\"aabbcccdd\" Here, a->2     k=4\\n#                         b->2  \\n#                         c->3\\n#                         d->2\\n                \\n#     now, \"aa\", \"bb\", \"cc\", \"dcd\", So, each odd occurence character can be adjusted in only one string to make it an odd plaindrome string. So, if we have no. of odd occurence characters greater than k, then we cannot have k palindrome strings.           \\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s)==k:\\n            return True\\n        if len(set(s))==k:\\n            return True\\n        \\n        if len(s)<k:\\n            return False\\n        \\n        count=0\\n        d=collections.Counter(s)\\n        print(d)\\n        l=list(d.keys())\\n        for i in range(len(l)):\\n            if d[l[i]]%2==1:\\n                count+=1\\n        return count<=k        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The approach of the problem is that -\\n# 1) even length palindromes will have even no. of characters\\n# 2) odd length palindromes will have odd no. of characters\\n# 3) we can have only one letter in odd length palindrome which has odd occurence. \\n\\n# For eg:\\n#     s=\"aabbcccdd\" Here, a->2     k=4\\n#                         b->2  \\n#                         c->3\\n#                         d->2\\n                \\n#     now, \"aa\", \"bb\", \"cc\", \"dcd\", So, each odd occurence character can be adjusted in only one string to make it an odd plaindrome string. So, if we have no. of odd occurence characters greater than k, then we cannot have k palindrome strings.           \\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s)==k:\\n            return True\\n        if len(set(s))==k:\\n            return True\\n        \\n        if len(s)<k:\\n            return False\\n        \\n        count=0\\n        d=collections.Counter(s)\\n        print(d)\\n        l=list(d.keys())\\n        for i in range(len(l)):\\n            if d[l[i]]%2==1:\\n                count+=1\\n        return count<=k        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 570939,
                "title": "c-solution-using-the-concept-that-atmost-k-odd-frequency-character-are-possisble",
                "content": "If u think in a broad way then what we can say is in  a given palindromic string atmost only one character can have  odd frequency and that element would be the position about which that string would be palindrome \\nso for K palindromic strings atmost K elements can have odd freq\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k)\\n            return false;\\n        \\n        vector<int> freq(256,0);\\n        \\n        for(auto ele : s)\\n            freq[ele]++;\\n        \\n        for(auto ele : freq){\\n            if(ele&1)\\n                k--;\\n            if(k < 0)\\n                return false;\\n        }        \\n        return true;        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k)\\n            return false;\\n        \\n        vector<int> freq(256,0);\\n        \\n        for(auto ele : s)\\n            freq[ele]++;\\n        \\n        for(auto ele : freq){\\n            if(ele&1)\\n                k--;\\n            if(k < 0)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 565262,
                "title": "c-3-lines",
                "content": "# the key is \"the number of odd char\" should be less than k\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> count(26,0);\\n        for(char c : s) count[c-\\'a\\']++;\\n        return (s.length() < k)?false:(k >= count_if(count.begin(),count.end(),[](int i) {return i%2==1;}));        \\n    }\\n};\\n```\\n\\nanother version:\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> cnt(26);\\n        for(char c : s) cnt[c-\\'a\\'] ^= 1;\\n        return (s.length() < k)?false:(k >= count(cnt.begin(),cnt.end(),1));        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> count(26,0);\\n        for(char c : s) count[c-\\'a\\']++;\\n        return (s.length() < k)?false:(k >= count_if(count.begin(),count.end(),[](int i) {return i%2==1;}));        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> cnt(26);\\n        for(char c : s) cnt[c-\\'a\\'] ^= 1;\\n        return (s.length() < k)?false:(k >= count(cnt.begin(),cnt.end(),1));        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563375,
                "title": "python-1line",
                "content": "```\\nreturn len(s) >= k and sum(i % 2 for i in Counter(s).values()) <= k\\n```",
                "solutionTags": [],
                "code": "```\\nreturn len(s) >= k and sum(i % 2 for i in Counter(s).values()) <= k\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3487709,
                "title": "simplest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        unordered_map<char,int> m ; \\n        if(s.size()<k)\\n        return false; \\n        for(auto x:s)\\n        m[x]++; \\n\\n        int count = 0; \\n        for(auto x:m)\\n        if(x.second%2==1)\\n        count++; \\n\\n        return count<=k;\\n\\n\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        unordered_map<char,int> m ; \\n        if(s.size()<k)\\n        return false; \\n        for(auto x:s)\\n        m[x]++; \\n\\n        int count = 0; \\n        for(auto x:m)\\n        if(x.second%2==1)\\n        count++; \\n\\n        return count<=k;\\n\\n\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235832,
                "title": "simple-solution-using-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k) return true;\\n    if(s.size()<k) return false;\\n    unordered_map<char,int>mp;\\n    for(auto x:s) mp[x]++;\\n    int odd_count=0;\\n    for(auto x:mp){\\n        if(x.second%2!=0){\\n            odd_count++;\\n        }\\n    }\\n    return odd_count<=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k) return true;\\n    if(s.size()<k) return false;\\n    unordered_map<char,int>mp;\\n    for(auto x:s) mp[x]++;\\n    int odd_count=0;\\n    for(auto x:mp){\\n        if(x.second%2!=0){\\n            odd_count++;\\n        }\\n    }\\n    return odd_count<=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845875,
                "title": "this-is-how-it-works",
                "content": "lets talk about the case when k<s.size() // coz it is confusing lol\\n\\nit means we have to do k partitions\\n\\nsuppose no of odd occuring characters be : o\\nassuming o<=k\\n\\n----- ----- ----- ----- ----- ----  -----\\nsuppose these are k partitions, of different lengths ( might be of same length too)\\ni am represeting them by ----  ----  ----- -----  , where a character is present at \\' - \\' \\n\\nnow there are 2 subcases , either all of the k partitions contain one odd character\\n\\nhere q->denotes any character with odd freq \\n---q1---  ---q2---  --q3--  --q4--  --q5-- \\n\\n---q1--- is one partition , while ---q2--- is another and so on\\n\\nsuppose character a and b have odd frequeny, so q1 can be a or b\\nand q2 can be b or a respectively\\n\\nso after eliminating \"odd frequency of odd occuring characters\"\\nWE KNOW know every character has even freq.\\n\\nnow we can fill remaining spaces with elements .\\n\\n---q1--- | ---q2--- | ---q3---| ---q4---\\n\\nthese are the partitions and we are left with characters having even freqency,\\nand the remaining length to be filled in all the partitions is s.size()-[q1+q2...(odd frequency)]\\nif any position of any partition is filled with any character,\\nwe know that characters have even freq , so corresponding palindromic [reverse right to left]\\nposition can be filled with same character.\\nand we have used 2 characters of same type, so we still have all the characters with even freq.\\n\\nthis is how we can fill all partitions.\\n\\nnow same ideology can be extended when o<k\\n\\n\\nsuppose we put one odd character in each partition\\nso new partitions formed = o\\n partitions we need to create =k-o\\nremaining characters left=s.size()-o\\n\\nnow the ques is can we form k-o palindromic paritions given that\\nwe are left with all even freqency characters\\n\\nnow there are further 2 subcases\\nwhen k-o is even\\nwe are left with s.size()-o characters where (size()-o>k-o)\\nwe know all the size()-o character has its sibling ( it occurs even number of time)\\n\\nwe need to create k-o ( even no. of partitions)\\nso what we can do, choose one character and its sibling, and you can create two new partitions\\nnow in last steps, you will be left with characters , having even freq.\\nand you can put it anywhere. [ in any partition]\\n\\n\\n\\nwhat if k-o is odd?\\n\\nwe know k-o-1 is even so first fill at the remaining k-o-1 places .\\nnow we want to create one new partition right?\\nplace all the remaining characters in that partition.\\n\\n\\nIT CAN BE SHOWED THAT WE CAN ALWAYS CONSTRUCT K-PALINDROMS!\\n;) THIS IS INDEPTH PROOF OF THE SOLUTION :D\\n\\ni\\'ve not considered the trivial cases when s.size()<k || s.size()==k ;) they are self explanatory!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "lets talk about the case when k<s.size() // coz it is confusing lol\\n\\nit means we have to do k partitions\\n\\nsuppose no of odd occuring characters be : o\\nassuming o<=k\\n\\n----- ----- ----- ----- ----- ----  -----\\nsuppose these are k partitions, of different lengths ( might be of same length too)\\ni am represeting them by ----  ----  ----- -----  , where a character is present at \\' - \\' \\n\\nnow there are 2 subcases , either all of the k partitions contain one odd character\\n\\nhere q->denotes any character with odd freq \\n---q1---  ---q2---  --q3--  --q4--  --q5-- \\n\\n---q1--- is one partition , while ---q2--- is another and so on\\n\\nsuppose character a and b have odd frequeny, so q1 can be a or b\\nand q2 can be b or a respectively\\n\\nso after eliminating \"odd frequency of odd occuring characters\"\\nWE KNOW know every character has even freq.\\n\\nnow we can fill remaining spaces with elements .\\n\\n---q1--- | ---q2--- | ---q3---| ---q4---\\n\\nthese are the partitions and we are left with characters having even freqency,\\nand the remaining length to be filled in all the partitions is s.size()-[q1+q2...(odd frequency)]\\nif any position of any partition is filled with any character,\\nwe know that characters have even freq , so corresponding palindromic [reverse right to left]\\nposition can be filled with same character.\\nand we have used 2 characters of same type, so we still have all the characters with even freq.\\n\\nthis is how we can fill all partitions.\\n\\nnow same ideology can be extended when o<k\\n\\n\\nsuppose we put one odd character in each partition\\nso new partitions formed = o\\n partitions we need to create =k-o\\nremaining characters left=s.size()-o\\n\\nnow the ques is can we form k-o palindromic paritions given that\\nwe are left with all even freqency characters\\n\\nnow there are further 2 subcases\\nwhen k-o is even\\nwe are left with s.size()-o characters where (size()-o>k-o)\\nwe know all the size()-o character has its sibling ( it occurs even number of time)\\n\\nwe need to create k-o ( even no. of partitions)\\nso what we can do, choose one character and its sibling, and you can create two new partitions\\nnow in last steps, you will be left with characters , having even freq.\\nand you can put it anywhere. [ in any partition]\\n\\n\\n\\nwhat if k-o is odd?\\n\\nwe know k-o-1 is even so first fill at the remaining k-o-1 places .\\nnow we want to create one new partition right?\\nplace all the remaining characters in that partition.\\n\\n\\nIT CAN BE SHOWED THAT WE CAN ALWAYS CONSTRUCT K-PALINDROMS!\\n;) THIS IS INDEPTH PROOF OF THE SOLUTION :D\\n\\ni\\'ve not considered the trivial cases when s.size()<k || s.size()==k ;) they are self explanatory!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2780659,
                "title": "cpp-solution-using-hashmap-and-counting",
                "content": "# Intuition\\nCount the Number of occurence of characters in the string then find the number of odd number of ocurrence of characters.\\n\\n# Approach\\n-> If String is \\'S\\' and if the size of the string is equal to k(integer) then our answer is \"true\" because we can break them into different characters\\n\\n-> If String\\'s size is less than the k then it is not possible to break then into k palindrome strings\\n\\n-> Now, Use a Hashmap to store the number of occurence of the characters of the string\\n\\n-> If the number of characters that have odd counts is > k then the minimum number of palindrome strings we can construct is > k and answer is false, Otherwise you can construct exactly k palindrome strings and answer is true \\n\\n> Why?...... Because if we take all even count character along with one single odd count character in a single string they can form a palindromic string\\n\\n>For Example- S= \"annnabellee\" and k=3 then, possible construction will be \"anlebelna\" ,\"b\" ,\"e\" (you can arrange them for more permutations), If k=2 then answer would be false.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k)\\n        return true;\\n        if(s.size()<k)\\n        return false;\\n        \\n        map<char,int> mp;\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n\\n        int cnt=0;\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            if(itr->second%2!=0)\\n              cnt++;\\n        }\\n        if(cnt>k)\\n         return false;\\n\\n\\n   return true; }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k)\\n        return true;\\n        if(s.size()<k)\\n        return false;\\n        \\n        map<char,int> mp;\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n\\n        int cnt=0;\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            if(itr->second%2!=0)\\n              cnt++;\\n        }\\n        if(cnt>k)\\n         return false;\\n\\n\\n   return true; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608282,
                "title": "c-80-faster-than-all-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n       \\n        int n = s.size(), map[26];\\n        memset(map, 0, sizeof(map));\\n        for (char c : s) map[c - \\'a\\']++;\\n        \\n        int count = 0;\\n        for (int i = 0; i < 26; i++) if (map[i] % 2) count++;\\n        \\n        k -= count;\\n        \\n        int pairs = (n - count) / 2;\\n        while (k > pairs) {\\n            pairs--;\\n            k -= 2;\\n        }\\n        return k >= 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n       \\n        int n = s.size(), map[26];\\n        memset(map, 0, sizeof(map));\\n        for (char c : s) map[c - \\'a\\']++;\\n        \\n        int count = 0;\\n        for (int i = 0; i < 26; i++) if (map[i] % 2) count++;\\n        \\n        k -= count;\\n        \\n        int pairs = (n - count) / 2;\\n        while (k > pairs) {\\n            pairs--;\\n            k -= 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2557672,
                "title": "count-odd-occurances",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.length();\\n        if(k>n)\\n            return false;\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        int cnt=0;\\n        for(auto i: mp)\\n        {\\n            if(i.second%2)\\n                cnt++;\\n        }\\n        \\n        if(cnt>k)\\n            return false;\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.length();\\n        if(k>n)\\n            return false;\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        int cnt=0;\\n        for(auto i: mp)\\n        {\\n            if(i.second%2)\\n                cnt++;\\n        }\\n        \\n        if(cnt>k)\\n            return false;\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527806,
                "title": "java-explained-logic-of-odd-chars-in-detail-tc-sc",
                "content": "// Understanding Palindorme: A palindromic string is a string, which when read from left to right or right to left spells same\\n\\n// So some observations from above definition\\n// 1. Even Length String\\n// 1.1 An even length string NEEDS to have ALL the characters in PAIR (meaning the freq of each char is even)\\n// 1.2 If a string of even length has ANY character with ODD freq, it CANNOT be a palindrome\\n// 2. Odd Length String\\n// 2.1 An odd length string can ATMOST have 1 character with ODD freq\\n// 2.2 If an odd length string has MORE THAN 1 charcter with ODD freq, it cannot be a Palindorme\\n\\n// Conclusion from above : ANY string can have ATMOST 1 charcter with ODD freq to make it eligible to be a PALINDROME\\n\\n// k = num of palindromes we need to form\\n// So, if the num of CHARS with ODD freq are GREATER THAN \\'k\\', then we CANNOT make \\'k\\' palindromes\\n// WHY ? Because of the established facts above that a string can have ATMOST 1 CHAR with ODD freq to become palindorme and so if we have MORE chars with ODD freq than \\'k\\', then this means in some string MORE THAN 1 char with ODD freq needs to adjust and hence we cannot make \\'k\\' palindromes\\n\\n// TC : O(M + 26); M = s.length()\\n// SC : O(26)\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {     \\n        if(k > s.length()) return false;\\n        \\n        int numOddFreqChars = 0;\\n        int len = s.length();\\n        int[] charFreq = new int[26];\\n        \\n        for(int i = 0; i < len; i++) {\\n            charFreq[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(charFreq[i] % 2 == 1) {\\n                numOddFreqChars++;\\n            }\\n        }\\n        \\n        return numOddFreqChars <= k;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {     \\n        if(k > s.length()) return false;\\n        \\n        int numOddFreqChars = 0;\\n        int len = s.length();\\n        int[] charFreq = new int[26];\\n        \\n        for(int i = 0; i < len; i++) {\\n            charFreq[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(charFreq[i] % 2 == 1) {\\n                numOddFreqChars++;\\n            }\\n        }\\n        \\n        return numOddFreqChars <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463838,
                "title": "c-space-98-beats-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string &s, int &k) {\\n        if(s.length()<k)return false;\\n        if(s.length()==k)return true;\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto &i: v){\\n            if(i%2)k--;\\n        }\\n        return k<0?false:true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string &s, int &k) {\\n        if(s.length()<k)return false;\\n        if(s.length()==k)return true;\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto &i: v){\\n            if(i%2)k--;\\n        }\\n        return k<0?false:true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453837,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-dictionary",
                "content": "```C#\\npublic class Solution {\\n    public bool CanConstruct(string s, int k) {\\n        if (s.Length < k) return false;\\n        \\n        Dictionary<char, int> d = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            if (!d.ContainsKey(s[i])) d[s[i]] = 0;\\n            d[s[i]]++;\\n        }\\n        \\n        int singles = 0;\\n        foreach (var (_, count) in d) {\\n            singles += count % 2;\\n        }\\n        \\n        if (singles > k) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public bool CanConstruct(string s, int k) {\\n        if (s.Length < k) return false;\\n        \\n        Dictionary<char, int> d = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            if (!d.ContainsKey(s[i])) d[s[i]] = 0;\\n            d[s[i]]++;\\n        }\\n        \\n        int singles = 0;\\n        foreach (var (_, count) in d) {\\n            singles += count % 2;\\n        }\\n        \\n        if (singles > k) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131445,
                "title": "very-easy-java-solution-no-bitwise-no-complex-logic",
                "content": "```\\npublic boolean canConstruct(String s, int k) {\\n        int[] hashTable = new int[26];\\n        if(s.length() < k)  return false;\\n        \\n        for(char ch : s.toCharArray())\\n            hashTable[ch-\\'a\\']++;\\n        \\n        int distinctCharCount=0;\\n        for(int i=0;i<26;i++){\\n            if(hashTable[i] !=0 && hashTable[i] % 2 != 0){\\n                distinctCharCount++;\\n                if(distinctCharCount > k)   return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canConstruct(String s, int k) {\\n        int[] hashTable = new int[26];\\n        if(s.length() < k)  return false;\\n        \\n        for(char ch : s.toCharArray())\\n            hashTable[ch-\\'a\\']++;\\n        \\n        int distinctCharCount=0;\\n        for(int i=0;i<26;i++){\\n            if(hashTable[i] !=0 && hashTable[i] % 2 != 0){\\n                distinctCharCount++;\\n                if(distinctCharCount > k)   return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024069,
                "title": "java-easy-to-understand-hashset",
                "content": "class Solution {\\n   \\n    public boolean canConstruct(String s, int k) {\\n         if(k>s.length()) return false;\\n        Set<Character> set = new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            if(set.contains(c))set.remove(c);\\n            else set.add(c);\\n        }\\n        return set.size()<=k;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n   \\n    public boolean canConstruct(String s, int k) {\\n         if(k>s.length()) return false;\\n        Set<Character> set = new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            if(set.contains(c))set.remove(c);\\n            else set.add(c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2004975,
                "title": "fully-commented-java-code",
                "content": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        \\n        int n = s.length();\\n        \\n        //Only two cases are possible for contruction of k palindrome to be false\\n        // 1) We dont have enough characters\\n        // 2) We are exceeding the max limit\\n        \\n        //We can only contruct atmost n palindrome for a n length string\\n        if(k>n){\\n            return false;\\n        }\\n        \\n        // Now that we are sure we can contruct a string\\n        // We can be sure we are not exceeding the limit while forming palindrome\\n        // If k is 1 and the string is eeaabb we can still form a string and\\n        // make sure it doesn\\'t exceed limit\\n        // but problem comes with odd number where we have to make sure\\n        // it is not more than the count\\n        \\n        int numOdd = 0;\\n        \\n        int[] count = new int[26];\\n        \\n        for(char c: s.toCharArray()){\\n            count[c-\\'a\\']++;\\n        }\\n        \\n        \\n        \\n        for(int i=0; i<26; i++){\\n            if(count[i] % 2 != 0){\\n                numOdd++;\\n            }\\n        }\\n        \\n        return (numOdd <= k) ? true : false;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        \\n        int n = s.length();\\n        \\n        //Only two cases are possible for contruction of k palindrome to be false\\n        // 1) We dont have enough characters\\n        // 2) We are exceeding the max limit\\n        \\n        //We can only contruct atmost n palindrome for a n length string\\n        if(k>n){\\n            return false;\\n        }\\n        \\n        // Now that we are sure we can contruct a string\\n        // We can be sure we are not exceeding the limit while forming palindrome\\n        // If k is 1 and the string is eeaabb we can still form a string and\\n        // make sure it doesn\\'t exceed limit\\n        // but problem comes with odd number where we have to make sure\\n        // it is not more than the count\\n        \\n        int numOdd = 0;\\n        \\n        int[] count = new int[26];\\n        \\n        for(char c: s.toCharArray()){\\n            count[c-\\'a\\']++;\\n        }\\n        \\n        \\n        \\n        for(int i=0; i<26; i++){\\n            if(count[i] % 2 != 0){\\n                numOdd++;\\n            }\\n        }\\n        \\n        return (numOdd <= k) ? true : false;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974120,
                "title": "java-easy-to-understand-90-beat",
                "content": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(k > s.length()) {\\n            return false;\\n        }\\n        if(k == s.length()) {\\n            return true;\\n        }\\n        int[] freqCount = new int[26];\\n        for(char letter: s.toCharArray()) {\\n            freqCount[letter - \\'a\\']++;\\n        }\\n        int count = 0;\\n        for(int x: freqCount) {\\n            if(x % 2 == 1) {\\n                count++;\\n            }\\n        }\\n        return count <= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(k > s.length()) {\\n            return false;\\n        }\\n        if(k == s.length()) {\\n            return true;\\n        }\\n        int[] freqCount = new int[26];\\n        for(char letter: s.toCharArray()) {\\n            freqCount[letter - \\'a\\']++;\\n        }\\n        int count = 0;\\n        for(int x: freqCount) {\\n            if(x % 2 == 1) {\\n                count++;\\n            }\\n        }\\n        return count <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958062,
                "title": "java-solution-using-hashmap-clean-code-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (k > s.length()) return false; \\n        HashMap<Character, Integer> hash = new HashMap<>(); \\n        for (int i = 0; i < s.length(); i++){\\n            hash.put(s.charAt(i), hash.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        List<Integer> list = new ArrayList<Integer>(hash.values()); \\n        int tbt = 0; \\n        for (int i = 0; i < list.size(); i++){\\n            tbt += (list.get(i) % 2); \\n        }\\n        if (tbt <= k) return true; \\n        return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (k > s.length()) return false; \\n        HashMap<Character, Integer> hash = new HashMap<>(); \\n        for (int i = 0; i < s.length(); i++){\\n            hash.put(s.charAt(i), hash.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        List<Integer> list = new ArrayList<Integer>(hash.values()); \\n        int tbt = 0; \\n        for (int i = 0; i < list.size(); i++){\\n            tbt += (list.get(i) % 2); \\n        }\\n        if (tbt <= k) return true; \\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885494,
                "title": "c-leetcode-1400-count-number-of-odd-frequency-letters",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if((int)s.size()<k)return false;\\n        if((int)s.size()==k)return true;\\n        int odds = 0;\\n        map<char,int> m;\\n        for(char c : s)\\n            m[c]++;\\n        for(auto x : m){\\n            if(x.second%2)\\n                odds++;\\n        }\\n        if(odds<=k)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if((int)s.size()<k)return false;\\n        if((int)s.size()==k)return true;\\n        int odds = 0;\\n        map<char,int> m;\\n        for(char c : s)\\n            m[c]++;\\n        for(auto x : m){\\n            if(x.second%2)\\n                odds++;\\n        }\\n        if(odds<=k)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806250,
                "title": "python-solution",
                "content": "To construct a palindrome string, every character must have an even number of total count in the string. Only the character in the middle can have a total count of 1. eg: \\'abbcbba\\'. So, to construct k palindrome sub-strings from a single string (s), there should only be k or less than k number of characters having an odd total count in the string (s).\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k > len(s):\\n            return False\\n        dic = {}\\n        \\n        for i in s:\\n            if i not in dic:\\n                dic[i] = 1\\n            else:\\n                dic[i] += 1\\n        c = 0        \\n        for i in dic.values():\\n            if i % 2 == 1:\\n                c += 1\\n        \\n        if c > k:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k > len(s):\\n            return False\\n        dic = {}\\n        \\n        for i in s:\\n            if i not in dic:\\n                dic[i] = 1\\n            else:\\n                dic[i] += 1\\n        c = 0        \\n        for i in dic.values():\\n            if i % 2 == 1:\\n                c += 1\\n        \\n        if c > k:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672032,
                "title": "c-easy-to-understand-simple-solution-with-explaination",
                "content": "**The trick is to understand that the characters which occur for the odd number of times will form a separate palindromic string each time consisting either a sinle character or being present at the mid of a string. So, if the count of odd characters happens to be more than k , we return a false and likewise follows**\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> freq;\\n        for(char ch:s)\\n        {\\n            freq[ch]++;\\n        }\\n        int oddCount=0;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second%2)\\n            {\\n                oddCount++;\\n            }\\n        }\\n        return oddCount<=k&&k<=s.length();\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> freq;\\n        for(char ch:s)\\n        {\\n            freq[ch]++;\\n        }\\n        int oddCount=0;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second%2)\\n            {\\n                oddCount++;\\n            }\\n        }\\n        return oddCount<=k&&k<=s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667062,
                "title": "easy-c-hashmap-solution",
                "content": "Here in the below code, oddCount is: No.of characters whose frequency is odd.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        int n = s.size();\\n        if(k > n)return false;\\n        \\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)m[s[i]]++;\\n        \\n        int oddCount = 0;\\n        for(auto i:m)\\n        {\\n            if((i.second)%2 != 0)oddCount++;\\n        }\\n        \\n        if(oddCount <= k)return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        int n = s.size();\\n        if(k > n)return false;\\n        \\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)m[s[i]]++;\\n        \\n        int oddCount = 0;\\n        for(auto i:m)\\n        {\\n            if((i.second)%2 != 0)oddCount++;\\n        }\\n        \\n        if(oddCount <= k)return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656887,
                "title": "simple-python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        ocr = Counter(s)\\n        od = 0\\n        ev = 0\\n        \\n        for i in ocr:\\n            if ocr[i] % 2 == 0:\\n                ev += 1\\n            else:\\n                od += 1\\n                \\n        if od == k:\\n            return True\\n        \\n        if k < od:\\n            return False\\n        \\n        if k > len(s):\\n            return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        ocr = Counter(s)\\n        od = 0\\n        ev = 0\\n        \\n        for i in ocr:\\n            if ocr[i] % 2 == 0:\\n                ev += 1\\n            else:\\n                od += 1\\n                \\n        if od == k:\\n            return True\\n        \\n        if k < od:\\n            return False\\n        \\n        if k > len(s):\\n            return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607563,
                "title": "lessons-learned",
                "content": "**Tricky problem**:\\n* One would only think in terms of **backtracking / dp** approach unless he knows the **greediness** involved in the definition of pallindrome:\\n\\t1.  **A word can be a pallindrome if it has atmost 1 odd count of chars**\\n\\t2.  A word is a pallindrome if \\'#1 is satisfied\\' and \\'chars are arranged in the pallindromic manner (read charAt(i++) == charAt(--j) until i and j meet)\\'.\\n#2 is well known. Whereas greediness is in #1. I never realized this hidden definition of pallindrome.\\n* So for 2 words to be both pallindromes, we can have atmost 1 oddCount from word1 and atmost1 oddCount from word2, totalling to atmost 2 oddCount from words 1 and 2. \\n**Generallizing, for k words to be pallindromes, validate the criteria of atmost k oddCount.**\\n\\n**Code**:\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int n = s.length();\\n        if (n == k) return true;\\n        if (k > n) return false;\\n        \\n        int[] charCountMap = new int[26];\\n        for (char c : s.toCharArray()) {\\n            ++charCountMap[c - \\'a\\'];\\n        }\\n        \\n        int oddCount = 0;\\n        for (int val : charCountMap) {\\n            if (val % 2 == 1) {\\n                ++oddCount;\\n                if (oddCount > k) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n/*\\n\\nif (s.length == k) return true;\\na, 1\\nab, 2\\n\\nabacdc, 2\\nabcdac, 2    - a:2, b:1, c:2, d:1\\nabbacddc, 2  - a:2, b:2, c:2, d:2\\n\\nabcabcabc, 3 - a:3, b:3, c:3\\nannabelle, 2 - a:2, n:2, b:1, e:2, l:2 \\n\\n\\nleetcode, 3 - l:1, t:1, c:1, o:1, d:1, e:3\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int n = s.length();\\n        if (n == k) return true;\\n        if (k > n) return false;\\n        \\n        int[] charCountMap = new int[26];\\n        for (char c : s.toCharArray()) {\\n            ++charCountMap[c - \\'a\\'];\\n        }\\n        \\n        int oddCount = 0;\\n        for (int val : charCountMap) {\\n            if (val % 2 == 1) {\\n                ++oddCount;\\n                if (oddCount > k) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n/*\\n\\nif (s.length == k) return true;\\na, 1\\nab, 2\\n\\nabacdc, 2\\nabcdac, 2    - a:2, b:1, c:2, d:1\\nabbacddc, 2  - a:2, b:2, c:2, d:2\\n\\nabcabcabc, 3 - a:3, b:3, c:3\\nannabelle, 2 - a:2, n:2, b:1, e:2, l:2 \\n\\n\\nleetcode, 3 - l:1, t:1, c:1, o:1, d:1, e:3\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530496,
                "title": "swift-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        var dict = [Character : Int]()\\n        for c in s {\\n            if dict[c] != nil {\\n                dict[c]! += 1\\n            } else {\\n                dict[c] = 1\\n            }\\n        }\\n        var numOdd = 0\\n        for val in dict.values {\\n            if val % 2 != 0 {\\n                numOdd += 1\\n            }\\n        }\\n        return k <= s.count && numOdd <= k\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        var dict = [Character : Int]()\\n        for c in s {\\n            if dict[c] != nil {\\n                dict[c]! += 1\\n            } else {\\n                dict[c] = 1\\n            }\\n        }\\n        var numOdd = 0\\n        for val in dict.values {\\n            if val % 2 != 0 {\\n                numOdd += 1\\n            }\\n        }\\n        return k <= s.count && numOdd <= k\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410197,
                "title": "short-java-solution",
                "content": "Just check number of characters with odd count. You need to create at least as many palindromic strings, since you can put at most 1 non-repeating character in a a palindromic string.\\n``` \\npublic boolean canConstruct(String s, int k) {\\n        int[] map = new int[26];\\n        for (int i = 0; i < s.length(); i++)\\n            map[s.charAt(i)-\\'a\\']++;\\n        int odd = 0;\\n        for (int i = 0; i < 26;i++)\\n            if (map[i]%2 == 1)\\n                odd++;\\n        \\n        return s.length() >= k && odd <= k;\\n    }\\n```\\n\\nOne pass solution\\n```\\npublic boolean canConstruct(String s, int k) {\\n        int[] map = new int[26];\\n         int odd = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            map[s.charAt(i)-\\'a\\']++;\\n            if (map[s.charAt(i)-\\'a\\']%2 == 1)\\n                odd++;\\n            else\\n                odd--;\\n        }\\n        return s.length() >= k && odd <= k;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\npublic boolean canConstruct(String s, int k) {\\n        int[] map = new int[26];\\n        for (int i = 0; i < s.length(); i++)\\n            map[s.charAt(i)-\\'a\\']++;\\n        int odd = 0;\\n        for (int i = 0; i < 26;i++)\\n            if (map[i]%2 == 1)\\n                odd++;\\n        \\n        return s.length() >= k && odd <= k;\\n    }\\n```\n```\\npublic boolean canConstruct(String s, int k) {\\n        int[] map = new int[26];\\n         int odd = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            map[s.charAt(i)-\\'a\\']++;\\n            if (map[s.charAt(i)-\\'a\\']%2 == 1)\\n                odd++;\\n            else\\n                odd--;\\n        }\\n        return s.length() >= k && odd <= k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1379866,
                "title": "97-53-time-efficient-simple-java-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k) return false;\\n        if(s.length()==k) return true;\\n        int[] f = new int[26];\\n        for(char ch : s.toCharArray())\\n            f[ch-\\'a\\']++;\\n        int oddCount=0, evenCount=0;\\n        for(int i=0; i<26; i++){\\n            if(f[i]%2!=0)\\n                oddCount++;\\n            else\\n                evenCount++;\\n        }\\n        return (evenCount != 0) && (oddCount<=k);\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k) return false;\\n        if(s.length()==k) return true;\\n        int[] f = new int[26];\\n        for(char ch : s.toCharArray())\\n            f[ch-\\'a\\']++;\\n        int oddCount=0, evenCount=0;\\n        for(int i=0; i<26; i++){\\n            if(f[i]%2!=0)\\n                oddCount++;\\n            else\\n                evenCount++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1347512,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return 0;\\n        map<int,int> freq;\\n        for(char i:s) freq[i]++;\\n        \\n        int singles=0,pairs=0;\\n        \\n        for(auto i:freq){\\n            if(i.second&1) {\\n                singles++;\\n                pairs=pairs+i.second/2;\\n            }\\n            else{\\n                pairs=pairs+i.second/2;\\n            }\\n        }\\n        \\n        if(singles>k) return 0;\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return 0;\\n        map<int,int> freq;\\n        for(char i:s) freq[i]++;\\n        \\n        int singles=0,pairs=0;\\n        \\n        for(auto i:freq){\\n            if(i.second&1) {\\n                singles++;\\n                pairs=pairs+i.second/2;\\n            }\\n            else{\\n                pairs=pairs+i.second/2;\\n            }\\n        }\\n        \\n        if(singles>k) return 0;\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277729,
                "title": "java-5-lines-of-code",
                "content": "Get char with odd count and if it greter then k return false else return true\\n\\n```\\npublic boolean canConstruct(String s, int k) {\\n      if(s.length() < k) return false;\\n      int[] arr = new int[26];\\n      for(int i = 0 ; i < s.length(); i++) arr[s.charAt(i) - \\'a\\']++;\\n      for(int i = 0 ; i < arr.length; i++) if(arr[i] % 2 != 0 && --k < 0) return false;\\n      return true; \\n    } \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canConstruct(String s, int k) {\\n      if(s.length() < k) return false;\\n      int[] arr = new int[26];\\n      for(int i = 0 ; i < s.length(); i++) arr[s.charAt(i) - \\'a\\']++;\\n      for(int i = 0 ; i < arr.length; i++) if(arr[i] % 2 != 0 && --k < 0) return false;\\n      return true; \\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1272281,
                "title": "java",
                "content": "class Solution {\\n\\n    public boolean canConstruct(String s, int k) {\\n        if(k>s.length())\\n            return false;\\n        if(k==s.length())\\n            return true;\\n        Map<Character,Integer> map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        for(Map.Entry<Character,Integer> entry:map.entrySet()){\\n            if(entry.getValue() %2 !=0)\\n                count++;\\n        }\\n        if(count >k)\\n            return false;\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean canConstruct(String s, int k) {\\n        if(k>s.length())\\n            return false;\\n        if(k==s.length())\\n            return true;\\n        Map<Character,Integer> map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        for(Map.Entry<Character,Integer> entry:map.entrySet()){\\n            if(entry.getValue() %2 !=0)\\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1259128,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        int i,j,c,n;\\n        n=s.length();\\n        if(k>n)\\n            return false;\\n        int a[26]={0};\\n        for(i=0;i<n;++i)\\n        {\\n            j=s[i]-\\'a\\';\\n            ++a[j];\\n        }\\n        for(i=0;i<26;++i)\\n        {\\n            if(a[i]%2==1)\\n            {\\n                --k;\\n            }\\n        }\\n        return (k>=0);\\n    }\\n};\\n```\\n\\nA palidrome can have a maximum of one odd character.\\nSo we check the number of odd frequency alphabets\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        int i,j,c,n;\\n        n=s.length();\\n        if(k>n)\\n            return false;\\n        int a[26]={0};\\n        for(i=0;i<n;++i)\\n        {\\n            j=s[i]-\\'a\\';\\n            ++a[j];\\n        }\\n        for(i=0;i<26;++i)\\n        {\\n            if(a[i]%2==1)\\n            {\\n                --k;\\n            }\\n        }\\n        return (k>=0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248762,
                "title": "c-solution-100-faster-o-n-simple-with-explanation",
                "content": "Whether we can construct \"k\" palindrome strings or not depends on how many \"pairs\" of letters the orignal string have.\\nThe least of \"pairs\" is required, when there\\'re most of \"odd\" length of palindrome strings.\\n\\nExtremely, the first \"k-1\" palindrome strings have only \"one\" (odd) letter each, in total used \"k-1\" letters.\\nThe last palindrome string has \"n - (k - 1)\" letters, need at least \"(n - (k - 1)) / 2\" pairs of letters.\\n\\n```\\nbool canConstruct (char *s, int k) {\\n  int  n, pairs = 0;\\n  char map[128] = {0};\\n\\n  for (n = 0; s[n]; n++) {\\n    if (map[s[n]]) {\\n      pairs++;\\n      map[s[n]] = 0;\\n    } else {\\n      map[s[n]] = 1;\\n    }\\n  }\\n\\n  return (k >= n) && (pairs >= (n - k + 1) / 2);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConstruct (char *s, int k) {\\n  int  n, pairs = 0;\\n  char map[128] = {0};\\n\\n  for (n = 0; s[n]; n++) {\\n    if (map[s[n]]) {\\n      pairs++;\\n      map[s[n]] = 0;\\n    } else {\\n      map[s[n]] = 1;\\n    }\\n  }\\n\\n  return (k >= n) && (pairs >= (n - k + 1) / 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240733,
                "title": "c-simple-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        if(s.length() == k) return true;\\n        vector<int> alphabets(26,0);\\n        for(int i=0; i < s.length(); i++) alphabets[(int)s[i] - (int)\\'a\\']++;\\n        int oddCount = 0;\\n        for(int i=0; i<26; i++) if(alphabets[i]%2) oddCount++;\\n        if(oddCount > k) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        if(s.length() == k) return true;\\n        vector<int> alphabets(26,0);\\n        for(int i=0; i < s.length(); i++) alphabets[(int)s[i] - (int)\\'a\\']++;\\n        int oddCount = 0;\\n        for(int i=0; i<26; i++) if(alphabets[i]%2) oddCount++;\\n        if(oddCount > k) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206607,
                "title": "construct-k-palindrome-strings-explaination-with-diagram-comment-if-you-need-any-help",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length()<k)\\n            return false;\\n        int even{},odd{};\\n        map<char,int> m;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        if(m.size()==k)\\n            return true;\\n        for(auto x: m)\\n        {\\n            if(x.second%2==0)\\n                even++;\\n            else\\n                odd++;\\n        }\\n        if(odd>k)\\n            return false;\\n        return true;\\n       \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/850d9814-b390-458d-8277-2131dae16a10_1620923888.732838.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length()<k)\\n            return false;\\n        int even{},odd{};\\n        map<char,int> m;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        if(m.size()==k)\\n            return true;\\n        for(auto x: m)\\n        {\\n            if(x.second%2==0)\\n                even++;\\n            else\\n                odd++;\\n        }\\n        if(odd>k)\\n            return false;\\n        return true;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117334,
                "title": "python-1-liner",
                "content": "```py\\nfrom collections import Counter\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return len(s) >= k and sum([x%2 for x in Counter(s).values()]) <= k\\n```",
                "solutionTags": [],
                "code": "```py\\nfrom collections import Counter\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return len(s) >= k and sum([x%2 for x in Counter(s).values()]) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111910,
                "title": "c-super-duper-simple-elegant-short-concise-easy-to-understand",
                "content": "C++ SUPER DUPER SIMPLE ELEGANT SHORT CONCISE EASY to UNDERSTAND \\n\\n```\\nclass Solution {\\n    \\npublic:\\n    bool canConstruct(string s, int k) {\\n        \\n        unordered_map<char,int> countMap;\\n        \\n        for(auto c : s)\\n            countMap[c]++;\\n        \\n        if(s.length() < k)\\n            return false;\\n        \\n        for(auto pr : countMap){\\n            k -= pr.second % 2==1 ? 1 : 0;\\n            if(k<0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    bool canConstruct(string s, int k) {\\n        \\n        unordered_map<char,int> countMap;\\n        \\n        for(auto c : s)\\n            countMap[c]++;\\n        \\n        if(s.length() < k)\\n            return false;\\n        \\n        for(auto pr : countMap){\\n            k -= pr.second % 2==1 ? 1 : 0;\\n            if(k<0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079932,
                "title": "python3-freq-table",
                "content": "**Algo**\\nCompute the frequency table of `s` and check if the count of odd occurrence `<= k`. Ofc, we need `k <= len(s)` as a prerequisite. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        freq = {}\\n        for c in s: \\n\\t\\t    freq[c] = 1 + freq.get(c, 0)\\n        return sum(freq[c]&1 for c in freq) <= k <= len(s)\\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        freq = {}\\n        for c in s: \\n\\t\\t    freq[c] = 1 + freq.get(c, 0)\\n        return sum(freq[c]&1 for c in freq) <= k <= len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078374,
                "title": "js-count-odd-occurrences-o-n-time-o-1-space-w-comments",
                "content": "The palindrome can be formed in a few ways:\\n1. One character at the middle and the same sequences but mirrored by both sides (abcda). There is only one odd character occurrence. Other cahracter occurrences are even.\\n2. Two same characters at the middle and the same but mirrored sequences by both sides (abccba). All characters occurrences are even.\\n\\nThat means that in worst case it\\'s still possible to form k palindromes if the number of odd character occurrences  are <= k.\\nThe idea is to count the number of occurrances for each character and compare it with k.\\nTime complexity is O(n).\\nSpace complexity is O(1).\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        // it\\'s not possible construct k non-empty palindromes if the number of characters in string is less than k\\n        return false;\\n    }\\n    // code of the first character in english alphabet\\n    const aCode = \\'a\\'.charCodeAt(0);\\n    // reserve and array for each possible character (26 in english alphabet)\\n    const counts = (new Array(26)).fill(0);\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        // substract the code of the first letter in the alpahbet from the code of current letter to make it fit in range of 0 - 25\\n        const code = s.charCodeAt(i) - aCode;\\n        // increment the character occurance\\n        counts[code]++;\\n    }\\n    let oddsCount = 0;\\n    for (let count of counts) {\\n        if (count % 2 === 1) {\\n            // count the number of odd characters\\n            oddsCount++;\\n        }\\n    }\\n    return oddsCount <= k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        // it\\'s not possible construct k non-empty palindromes if the number of characters in string is less than k\\n        return false;\\n    }\\n    // code of the first character in english alphabet\\n    const aCode = \\'a\\'.charCodeAt(0);\\n    // reserve and array for each possible character (26 in english alphabet)\\n    const counts = (new Array(26)).fill(0);\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        // substract the code of the first letter in the alpahbet from the code of current letter to make it fit in range of 0 - 25\\n        const code = s.charCodeAt(i) - aCode;\\n        // increment the character occurance\\n        counts[code]++;\\n    }\\n    let oddsCount = 0;\\n    for (let count of counts) {\\n        if (count % 2 === 1) {\\n            // count the number of odd characters\\n            oddsCount++;\\n        }\\n    }\\n    return oddsCount <= k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1031277,
                "title": "c-check-odd-count-of-characters",
                "content": "A palindrome can be built in two ways:\\n1. Count of all characters is even, i.e. \"aabccbaa\" a->4, b->2, c->2\\n2. Only 1 character have odd count, i.e. \"aabcfcbaa\" a->4, b->2, c->2, f->1\\n\\nWe can check if at max we have k odd counts in the string if yes then we have the answer.\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k > s.size()) return false;\\n        unordered_map<char, int> mp;\\n        for(auto ch:s) {\\n            mp[ch]++;\\n        }\\n        int count = 0;\\n        for(auto m:mp) {\\n            if(m.second % 2 == 1) count++;\\n            if(count > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k > s.size()) return false;\\n        unordered_map<char, int> mp;\\n        for(auto ch:s) {\\n            mp[ch]++;\\n        }\\n        int count = 0;\\n        for(auto m:mp) {\\n            if(m.second % 2 == 1) count++;\\n            if(count > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968226,
                "title": "c-solution-beats-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string& s, int k) {\\n        ios_base::sync_with_stdio(0); cin.tie(0);\\n        if(s.size() < k)\\n            return false;\\n        \\n        int mask = 0;\\n        for(char c : s)\\n            mask ^= (1 << (c-\\'a\\'));\\n        \\n        return (__builtin_popcount(mask) <= k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string& s, int k) {\\n        ios_base::sync_with_stdio(0); cin.tie(0);\\n        if(s.size() < k)\\n            return false;\\n        \\n        int mask = 0;\\n        for(char c : s)\\n            mask ^= (1 << (c-\\'a\\'));\\n        \\n        return (__builtin_popcount(mask) <= k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956557,
                "title": "super-concise-and-clear-python-code-with-explanation",
                "content": "If there are not enough characters in s to make k palindromes, result = False. Edge case\\nFor all other cases:\\nFind the count of the each  letter in s. We now focus on letters that are odd in count. The letters with even count can form a new palidrome or wrap around an exisiting palindrome placing 2 at a time. \\nSo, the number of letters with odd count is what defines how many palindromes can be made.\\nAs long as the number of letters with odd count are less than or equal to k we can form k palindromes.\\n\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        count = collections.Counter(s)\\n        oddCount = sum(x%2 for x in count.values())\\n        return oddCount <= k\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        count = collections.Counter(s)\\n        oddCount = sum(x%2 for x in count.values())\\n        return oddCount <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931230,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k) return false;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char ch : s.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        for (Character ch: map.keySet()) {\\n            if (map.get(ch) % 2 != 0) {\\n                k--;\\n            }\\n        }\\n        \\n        return k >= 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k) return false;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char ch : s.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        for (Character ch: map.keySet()) {\\n            if (map.get(ch) % 2 != 0) {\\n                k--;\\n            }\\n        }\\n        \\n        return k >= 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926801,
                "title": "c-solution-o-n-simple",
                "content": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int ar[26]={0};\\n        for(char c:s)\\n            ar[c-\\'a\\']++;\\n        int k1=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            k1+=ar[i]%2;\\n        }\\n        return (k>=k1 &&k<=s.size());\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int ar[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 913705,
                "title": "python-easy-to-understand",
                "content": "The logic being, to construct k palindrome strings, the number of letters with odd (or 1) counts need to be less than or equal to k (cause one palindrome string can only have 1 odd count letter in it) and length of s has to be greater than or equal to k.\\n\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        count=collections.Counter(list(s))\\n        c=0\\n        for v in count.values():\\n            if v%2!=0:\\n                c+=1\\n        if c<=k and len(s)>=k:\\n            return True\\n        else:\\n            return False",
                "solutionTags": [],
                "code": "The logic being, to construct k palindrome strings, the number of letters with odd (or 1) counts need to be less than or equal to k (cause one palindrome string can only have 1 odd count letter in it) and length of s has to be greater than or equal to k.\\n\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        count=collections.Counter(list(s))\\n        c=0\\n        for v in count.values():\\n            if v%2!=0:\\n                c+=1\\n        if c<=k and len(s)>=k:\\n            return True\\n        else:\\n            return False",
                "codeTag": "Python3"
            },
            {
                "id": 898912,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    //annabelle a=2 n=2 b=1 e=2 l=2 k=2 odd_char=1 true\\n    \\n    bool canConstruct(string s, int k) {\\n        if (k>s.size()) return false;\\n        unordered_map<char, int> char_map;\\n        for (auto x:s) {\\n            char_map[x]++;\\n        }\\n        int odd_char=0;\\n        for (auto y=char_map.begin(); y!=char_map.end(); y++) {\\n            if (y->second%2==1) {\\n                odd_char++;\\n                if (odd_char>k)\\n                    return false;\\n            }\\n        }\\n        return true;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //annabelle a=2 n=2 b=1 e=2 l=2 k=2 odd_char=1 true\\n    \\n    bool canConstruct(string s, int k) {\\n        if (k>s.size()) return false;\\n        unordered_map<char, int> char_map;\\n        for (auto x:s) {\\n            char_map[x]++;\\n        }\\n        int odd_char=0;\\n        for (auto y=char_map.begin(); y!=char_map.end(); y++) {\\n            if (y->second%2==1) {\\n                odd_char++;\\n                if (odd_char>k)\\n                    return false;\\n            }\\n        }\\n        return true;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878018,
                "title": "easy-o-n-java",
                "content": "```\\npublic boolean canConstruct(String s, int k) {\\n        if (k == s.length()) return true;\\n        if (s.length() < k) return false;\\n        int[] count = new int[26];\\n        for (char c : s.toCharArray()) count[c-\\'a\\']++;\\n        \\n        int countExceptions = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] % 2 == 1) { countExceptions++; }\\n            if (countExceptions > k) return false;\\n        }\\n        \\n        return true;\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "```\\npublic boolean canConstruct(String s, int k) {\\n        if (k == s.length()) return true;\\n        if (s.length() < k) return false;\\n        int[] count = new int[26];\\n        for (char c : s.toCharArray()) count[c-\\'a\\']++;\\n        \\n        int countExceptions = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] % 2 == 1) { countExceptions++; }\\n            if (countExceptions > k) return false;\\n        }\\n        \\n        return true;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 865794,
                "title": "consise-o-1-faster-than-100-c",
                "content": "You need to create seperate strings for odd count of characters only, also note that you can at most have 26 odd characters, so if 26<k<=s.size() doesn\\'t matter what characters you have in s you can always use all characters and create required palindromes.\\n```\\nclass Solution {\\n    int cnt[26];\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k>s.size())return 0;\\n        if(k>26)return 1;\\n        for(auto it:s)cnt[it-\\'a\\']++;\\n        int ans=0;\\n        for(auto it:cnt)if(it&1)ans++;\\n        return ans<=k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int cnt[26];\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k>s.size())return 0;\\n        if(k>26)return 1;\\n        for(auto it:s)cnt[it-\\'a\\']++;\\n        int ans=0;\\n        for(auto it:cnt)if(it&1)ans++;\\n        return ans<=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814496,
                "title": "very-very-simple-c-code-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k>s.length()){\\n            return false;\\n        }\\n        vector<int>count(26,0);\\n        for(int i=0;i<s.length();i++){\\n            count[s[i]-\\'a\\']++;\\n        }\\n        int odd=0;\\n        for(int i=0;i<26;i++){\\n            if(count[i]%2==1){\\n                odd++;\\n            }\\n        }\\n        if(odd>k){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k>s.length()){\\n            return false;\\n        }\\n        vector<int>count(26,0);\\n        for(int i=0;i<s.length();i++){\\n            count[s[i]-\\'a\\']++;\\n        }\\n        int odd=0;\\n        for(int i=0;i<26;i++){\\n            if(count[i]%2==1){\\n                odd++;\\n            }\\n        }\\n        if(odd>k){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784545,
                "title": "minimal-c-using-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (k > s.size())\\n            return false;\\n        \\n        uint mask = 0;\\n        for (auto c : s)\\n            mask ^= 1 << (c - \\'a\\');\\n        \\n        return (__builtin_popcount(mask) <= k);  // C++20 has std::popcount()\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (k > s.size())\\n            return false;\\n        \\n        uint mask = 0;\\n        for (auto c : s)\\n            mask ^= 1 << (c - \\'a\\');\\n        \\n        return (__builtin_popcount(mask) <= k);  // C++20 has std::popcount()\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752927,
                "title": "python-simple-soln",
                "content": "```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        \"\"\"\\n        For string to be pallindrome, it can either have 0 or 1 number of odd count characters.\\n        For string to have k pallindomes, it can have 0 - k number of odd count characters. \\n        \"\"\"\\n        if k > len(s):\\n            return False\\n        \\n        hashmap = collections.defaultdict(int)\\n        \\n        for ch in s:\\n            hashmap[ch] += 1\\n        \\n        odd_character_count = 0\\n        for key in hashmap:\\n            odd_character_count += 1 if hashmap[key] % 2 == 1 else 0\\n            \\n        if odd_character_count > k:\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        \"\"\"\\n        For string to be pallindrome, it can either have 0 or 1 number of odd count characters.\\n        For string to have k pallindomes, it can have 0 - k number of odd count characters. \\n        \"\"\"\\n        if k > len(s):\\n            return False\\n        \\n        hashmap = collections.defaultdict(int)\\n        \\n        for ch in s:\\n            hashmap[ch] += 1\\n        \\n        odd_character_count = 0\\n        for key in hashmap:\\n            odd_character_count += 1 if hashmap[key] % 2 == 1 else 0\\n            \\n        if odd_character_count > k:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723185,
                "title": "c-solution",
                "content": "```\\n    public bool CanConstruct(string s, int k) {\\n        if(s.Length<2)\\n            return k>0;\\n        int[] map=new int[26];\\n        foreach(var ch in s)\\n            map[ch-\\'a\\']++;\\n        int odd=0;\\n        foreach(var ch in map)\\n        {\\n            if(ch!=0&&ch%2!=0)\\n                odd++;\\n        }\\n        return odd<=k&&k<=s.Length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public bool CanConstruct(string s, int k) {\\n        if(s.Length<2)\\n            return k>0;\\n        int[] map=new int[26];\\n        foreach(var ch in s)\\n            map[ch-\\'a\\']++;\\n        int odd=0;\\n        foreach(var ch in map)\\n        {\\n            if(ch!=0&&ch%2!=0)\\n                odd++;\\n        }\\n        return odd<=k&&k<=s.Length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 653134,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k)\\n            return false;\\n        \\n        vector<int> freq(256,0);\\n        \\n        for(auto ele : s)\\n            freq[ele]++;\\n        \\n        for(auto ele : freq){\\n            if(ele&1)\\n                k--;\\n            if(k < 0)\\n                return false;\\n        }        \\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k)\\n            return false;\\n        \\n        vector<int> freq(256,0);\\n        \\n        for(auto ele : s)\\n            freq[ele]++;\\n        \\n        for(auto ele : freq){\\n            if(ele&1)\\n                k--;\\n            if(k < 0)\\n                return false;\\n        }        \\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629545,
                "title": "java-faster-than-99-01-and-less-than-100-00-using-bucket-sort",
                "content": "```\\npublic class Solution {\\n    public boolean canConstruct(String s, int k) {\\n     \\n    \\tif (k > s.length()) {\\n    \\t\\treturn false;\\n    \\t}\\n    \\tint[] count = new int[26];\\n    \\tfor (char c : s.toCharArray()) {\\n    \\t\\tcount[c - \\'a\\']++;\\n    \\t}\\n    \\t\\n    \\tint ones = 0;\\n    \\tfor (int i : count) {\\n    \\t\\tif ((i & 1) == 1) {\\n    \\t\\t\\tones++;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\treturn ones <= k;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean canConstruct(String s, int k) {\\n     \\n    \\tif (k > s.length()) {\\n    \\t\\treturn false;\\n    \\t}\\n    \\tint[] count = new int[26];\\n    \\tfor (char c : s.toCharArray()) {\\n    \\t\\tcount[c - \\'a\\']++;\\n    \\t}\\n    \\t\\n    \\tint ones = 0;\\n    \\tfor (int i : count) {\\n    \\t\\tif ((i & 1) == 1) {\\n    \\t\\t\\tones++;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\treturn ones <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597239,
                "title": "javascript-bitwise-beats-100-100-w-comments",
                "content": "```\\nfunction canConstruct(s, k) {\\n    // base case (s is less than k in length)\\n    if (s.length < k)\\n        return false;\\n\\t\\t\\n    // our 26 bit number to representing all 26 lowercase characters (each bit)\\n    let x = 0;\\n\\t\\n    // iterate thru string\\n    for (let i = 0; i < s.length; i++) {\\n        // flip bit corresponding to this lowercase char\\n        x ^= 1 << (s.charCodeAt(i) - 97);\\n    }\\n\\t\\n    // count set bits\\n    let c = 0;\\n    while (x > 0) {\\n        // inc c if rightmost bit is 1\\n        c += x & 1;\\n        // right shift\\n        x >>= 1;\\n    }\\n\\t\\n    // check if number of odds is less or equal to k\\n    return c <= k;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction canConstruct(s, k) {\\n    // base case (s is less than k in length)\\n    if (s.length < k)\\n        return false;\\n\\t\\t\\n    // our 26 bit number to representing all 26 lowercase characters (each bit)\\n    let x = 0;\\n\\t\\n    // iterate thru string\\n    for (let i = 0; i < s.length; i++) {\\n        // flip bit corresponding to this lowercase char\\n        x ^= 1 << (s.charCodeAt(i) - 97);\\n    }\\n\\t\\n    // count set bits\\n    let c = 0;\\n    while (x > 0) {\\n        // inc c if rightmost bit is 1\\n        c += x & 1;\\n        // right shift\\n        x >>= 1;\\n    }\\n\\t\\n    // check if number of odds is less or equal to k\\n    return c <= k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575664,
                "title": "best-and-efficient-solution-with-explanation-c",
                "content": "Explanation: If you think about the pallindrome, you\\'ll eventually come at the conclusion that a pallindrome can hold atmost single, odd-occurrence alphabet. So, k pallindrome can hold at most k odd-occurrence alphabet and if the count of odd-occurrence alphabet will be more than k then it\\'s impossible to create k pallindrome.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        // corner case\\n        if (s.length() < k)\\n            return false;\\n        // to keep the occurrence of alphabets.\\n        int _hash = 0;\\n        \\n        // flip bit at position c - \\'a\\' \\n        for (char c : s)\\n            _hash ^= 1 << (c - \\'a\\');\\n        \\n        // count the number of set bit\\n        while(_hash != 0)\\n        {\\n            k--;\\n            _hash &= _hash - 1;\\n        }\\n        \\n        if (k < 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        // corner case\\n        if (s.length() < k)\\n            return false;\\n        // to keep the occurrence of alphabets.\\n        int _hash = 0;\\n        \\n        // flip bit at position c - \\'a\\' \\n        for (char c : s)\\n            _hash ^= 1 << (c - \\'a\\');\\n        \\n        // count the number of set bit\\n        while(_hash != 0)\\n        {\\n            k--;\\n            _hash &= _hash - 1;\\n        }\\n        \\n        if (k < 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571843,
                "title": "java-68-using-frequency-count",
                "content": "```\\n  public boolean canConstruct(String s, int k) {\\n     if(s.length()<k) return false;\\n     int count[]=new int[26];int totalOddCount=0; \\n     for(int i=0;i<s.length();i++) count[s.charAt(i)-\\'a\\']++;   \\n     for(int i=0;i<count.length;i++)\\n         if(count[i]%2!=0)\\n             totalOddCount++;\\n        \\n     return totalOddCount<=k;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public boolean canConstruct(String s, int k) {\\n     if(s.length()<k) return false;\\n     int count[]=new int[26];int totalOddCount=0; \\n     for(int i=0;i<s.length();i++) count[s.charAt(i)-\\'a\\']++;   \\n     for(int i=0;i<count.length;i++)\\n         if(count[i]%2!=0)\\n             totalOddCount++;\\n        \\n     return totalOddCount<=k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 568881,
                "title": "most-detailed-java-explanation-for-beginners",
                "content": "```\\n public boolean canConstruct(String s, int k) {\\n        int n= s.length();\\n        \\n        //K has to be less than N becase\\n        //At max, we can make N palindromes from a String of length N\\n        //e.g. If all characters represent one palindrome, then we would have N palindromes\\n        //since in all others scenarios, atleast one of the palindromes can have more than 1 character\\n        //Hence maximum limit to number of palindromes generated in this case is N\\n        if(k>n){\\n            return false;\\n        }\\n        \\n        //We need to count odd numbered characters. Why?\\n        //Since any palindrome can contain at max 1 odd numbered character, that too in the center\\n        //If there are more odd nunmbered characters(O=K+C) then the number of palindromes \\n        //the given string can be broken into(K)\\n        //Then those extra odd numbered characters cannot be accomdated into those K palindroms\\n        //Hence we will not be able to makebreak the given String into K palindromes \\n\\t\\t//in case O=K+C; C>=1\\n        \\n        int oddNumberedCharacters=0;\\n        int[] count = new int[26];\\n        \\n        for(int i=0;i<s.length();i++){\\n           count[(s.charAt(i)-\\'a\\']++;    \\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            oddNumberedCharacters+=count[i]%2;\\n        }\\n        \\n        return  oddNumberedCharacters<=k;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public boolean canConstruct(String s, int k) {\\n        int n= s.length();\\n        \\n        //K has to be less than N becase\\n        //At max, we can make N palindromes from a String of length N\\n        //e.g. If all characters represent one palindrome, then we would have N palindromes\\n        //since in all others scenarios, atleast one of the palindromes can have more than 1 character\\n        //Hence maximum limit to number of palindromes generated in this case is N\\n        if(k>n){\\n            return false;\\n        }\\n        \\n        //We need to count odd numbered characters. Why?\\n        //Since any palindrome can contain at max 1 odd numbered character, that too in the center\\n        //If there are more odd nunmbered characters(O=K+C) then the number of palindromes \\n        //the given string can be broken into(K)\\n        //Then those extra odd numbered characters cannot be accomdated into those K palindroms\\n        //Hence we will not be able to makebreak the given String into K palindromes \\n\\t\\t//in case O=K+C; C>=1\\n        \\n        int oddNumberedCharacters=0;\\n        int[] count = new int[26];\\n        \\n        for(int i=0;i<s.length();i++){\\n           count[(s.charAt(i)-\\'a\\']++;    \\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            oddNumberedCharacters+=count[i]%2;\\n        }\\n        \\n        return  oddNumberedCharacters<=k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 565472,
                "title": "c-3-lines-using-128-bits-register",
                "content": "```\\nclass Solution {\\npublic:    \\n    bool canConstruct(string s, int k) {\\n         __int128 ret = 0;\\n        for (char c : s) ret ^= ( __int128)1 << c;\\n        \\n        return __builtin_popcount(ret >> 96) <= k && (s.size() >= k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    bool canConstruct(string s, int k) {\\n         __int128 ret = 0;\\n        for (char c : s) ret ^= ( __int128)1 << c;\\n        \\n        return __builtin_popcount(ret >> 96) <= k && (s.size() >= k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564240,
                "title": "c-100-100-one-pass-hashset",
                "content": "Explanation\\n-\\nIf we\\'ve seen a letter an even number of times, we can put it anywhere. We only care about the odd leftovers. Each one needs to be the middle letter of a palindrome. If we have more odds than ```k```, we can\\'t do it. We also need to check if there are actually enough letters in the string.\\n\\nAlgorithm\\n-\\n```\\npublic bool CanConstruct(string s, int k) {\\n\\tif (s.Length < k) return false;\\n\\tvar unpaired = new HashSet<char>();\\n\\tforeach (var letter in s)\\n\\t\\tif (unpaired.Contains(letter))\\n\\t\\t\\tunpaired.Remove(letter);\\n\\t\\telse\\n\\t\\t\\tunpaired.Add(letter);\\n\\treturn unpaired.Count <= k;\\n}\\n```\\n\\nProof\\n-\\n![image](https://assets.leetcode.com/users/laprade/image_1586058531.png)\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```k```\n```\\npublic bool CanConstruct(string s, int k) {\\n\\tif (s.Length < k) return false;\\n\\tvar unpaired = new HashSet<char>();\\n\\tforeach (var letter in s)\\n\\t\\tif (unpaired.Contains(letter))\\n\\t\\t\\tunpaired.Remove(letter);\\n\\t\\telse\\n\\t\\t\\tunpaired.Add(letter);\\n\\treturn unpaired.Count <= k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564194,
                "title": "with-explanation",
                "content": "Firstly if size < k then we must obviously return false.\\nIf size >= k and singles = 0. This means all are pairs. In this case:\\n\\t1: k == size, then we can create k palindrome, each palindrome will have single letter. e.g.: k = 4, s = \\'aabb\\' we can create 4 palindromes as: a, a, b, b.\\n\\t2: k > size: Since all characters are in pair (or even count) we can distribute first k characters as shown above and then remaining are all pairs, which can also be distributed. e.g.: k = 4, s= \\'aaaaaabb\\', palindromes can be constructed in steps as follows:  a, a, a, a => aaabb, a, a, a.\\n\\nIf size >= k and singles > 0. (note, when I say singles I mean number of odd chars, for example if s = \\'aaa\\', single = 1  == last \\'a\\' in \\'aa**a**\\'). Here there can be 2 cases:\\n\\t1: singles < k. In this case we can distribute singles among our palindromes. \\n\\te.g: k = 3, singles = 1 = \\'a\\' =>   --a, --, --. \\n\\tor   k=3, singles = 2 = \\'ab\\' => --a, --b, --.   \\n\\tOr k= 3, singles = 3 = \\'abd\\' => --a, --b, --d.\\n\\t2: singles > k. Continuing from above example, it is easy to see that after adding k singles into k palindromes, we have no place to put the k+1th single, so we must return false. \\n\\nThe c++ code for this is given below:\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if((int)s.size() < k )\\n            return 0;\\n        vector<int> cnt(26);\\n        for(char c: s)\\n            cnt[c-\\'a\\']++;\\n\\n        int singles = 0;\\n        for(int e: cnt)\\n           if(e %2 != 0)\\n               singles++;\\n\\n        return singles <= k;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if((int)s.size() < k )\\n            return 0;\\n        vector<int> cnt(26);\\n        for(char c: s)\\n            cnt[c-\\'a\\']++;\\n\\n        int singles = 0;\\n        for(int e: cnt)\\n           if(e %2 != 0)\\n               singles++;\\n\\n        return singles <= k;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563752,
                "title": "python",
                "content": "If you have X characters with odd counts, then you need at least X palindromes to accomodate them; so, other than making sure that s isn\\'t shorter than k, we only need to check that X <= K\\n\\n```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        if len(s) < k:\\n            return False\\n        \\n        char_counts = dict()\\n        \\n        for char in s:\\n            if char in char_counts:\\n                char_counts[char] += 1\\n            else:\\n                char_counts[char] = 1\\n        \\n        odd_counts = 0\\n        \\n        for char in char_counts:\\n            if char_counts[char] % 2 == 1:\\n                odd_counts += 1\\n        \\n        return odd_counts <= k",
                "solutionTags": [],
                "code": "If you have X characters with odd counts, then you need at least X palindromes to accomodate them; so, other than making sure that s isn\\'t shorter than k, we only need to check that X <= K\\n\\n```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        if len(s) < k:\\n            return False\\n        \\n        char_counts = dict()\\n        \\n        for char in s:\\n            if char in char_counts:\\n                char_counts[char] += 1\\n            else:\\n                char_counts[char] = 1\\n        \\n        odd_counts = 0\\n        \\n        for char in char_counts:\\n            if char_counts[char] % 2 == 1:\\n                odd_counts += 1\\n        \\n        return odd_counts <= k",
                "codeTag": "Java"
            },
            {
                "id": 563615,
                "title": "count-odd-numbers-javascript-solution-68-ms",
                "content": "```\\nvar canConstruct = function(s, k) {\\n    if (s.length / k < 1) {\\n        return false;\\n    }\\n    \\n    let counts = new Array(26).fill(0);\\n    const aCode = \"a\".charCodeAt();\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        counts[s.charCodeAt(i) - aCode]++;\\n    }\\n    \\n    let oddCount = 0;\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] % 2 === 1) {\\n            oddCount++;\\n        }\\n    }\\n    \\n    return oddCount <= k;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canConstruct = function(s, k) {\\n    if (s.length / k < 1) {\\n        return false;\\n    }\\n    \\n    let counts = new Array(26).fill(0);\\n    const aCode = \"a\".charCodeAt();\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        counts[s.charCodeAt(i) - aCode]++;\\n    }\\n    \\n    let oddCount = 0;\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] % 2 === 1) {\\n            oddCount++;\\n        }\\n    }\\n    \\n    return oddCount <= k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563474,
                "title": "cpp-fastest-easiest",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k){\\n            return true;\\n        }\\n        if(s.size()<k)return false;\\n        int arr[26]={0};\\n        for(int i=0;i<s.size();i++){\\n            arr[s[i]-\\'a\\']++;\\n        }\\n        int no=0,ne=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr[i]%2==0)ne++;\\n            else no++;\\n        }\\n        \\n        if(k<no){\\n            return false;\\n        }\\n        else return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k){\\n            return true;\\n        }\\n        if(s.size()<k)return false;\\n        int arr[26]={0};\\n        for(int i=0;i<s.size();i++){\\n            arr[s[i]-\\'a\\']++;\\n        }\\n        int no=0,ne=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr[i]%2==0)ne++;\\n            else no++;\\n        }\\n        \\n        if(k<no){\\n            return false;\\n        }\\n        else return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563440,
                "title": "python-one-liner",
                "content": "The first condition is easy: The input string needs to be least k characters long to form k palindromes.\\nThen we need to count the occurences of each character: If a character is included an even number of times we can create a new palindrome with it or use a pair of it as padding on an existing palindrome without increasing the total palindrome count (XXX -> aXXXa). We only need to watch out for odd character counts as each of those will create a new center. If there are more than k centers we can\\'t construct k palindromes.\\n\\nTime and space complexity: ```O(n)```\\n```python\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return len(s) >= k and sum(count % 2 for count in collections.Counter(s).values()) <= k\\n```",
                "solutionTags": [],
                "code": "```O(n)```\n```python\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return len(s) >= k and sum(count % 2 for count in collections.Counter(s).values()) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090307,
                "title": "python3-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, x: int) -> bool:\\n        \\n        \\n        freq=Counter(s)\\n        odd=0\\n        \\n        for k,v in freq.items():\\n            if v%2:\\n                odd+=1\\n                \\n        if odd>x:\\n            return False\\n        \\n        return len(s)>=x\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, x: int) -> bool:\\n        \\n        \\n        freq=Counter(s)\\n        odd=0\\n        \\n        for k,v in freq.items():\\n            if v%2:\\n                odd+=1\\n                \\n        if odd>x:\\n            return False\\n        \\n        return len(s)>=x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069749,
                "title": "c-solution-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char, int> mp;\\n        if(k==s.length()){\\n            return true;\\n        }\\n        else if(k>s.length()) return false;\\n\\n        else{\\n            int odd=0;\\n\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        for(auto i:mp){\\n            if(i.second%2 != 0) odd++;\\n        }\\n\\n        if(odd<=k){\\n            return true;\\n        }\\n        else return false;\\n\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char, int> mp;\\n        if(k==s.length()){\\n            return true;\\n        }\\n        else if(k>s.length()) return false;\\n\\n        else{\\n            int odd=0;\\n\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        for(auto i:mp){\\n            if(i.second%2 != 0) odd++;\\n        }\\n\\n        if(odd<=k){\\n            return true;\\n        }\\n        else return false;\\n\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022713,
                "title": "unordered-map-easy-solution-self-explanatory",
                "content": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        //leetcode - here how can we split leetcode into 3 palindromic strings\\n        //odd freq char we have  l,t,c,o,d\\n        //ete eoe so odd freq is more than the k we cannot construct k palindromic strings from this\\n        //true          here all 4 having odd frequency\\n        //we can successfully divide into 4 single palindromic strings\\n        int n=s.size();\\n        if(n<k) return false;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++) \\n            mp[s[i]]++;\\n          int t=0;\\n        for(auto x: mp) {\\n            if(x.second&1) {\\n                t++;\\n            }\\n        }\\n        return t<=k;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        //leetcode - here how can we split leetcode into 3 palindromic strings\\n        //odd freq char we have  l,t,c,o,d\\n        //ete eoe so odd freq is more than the k we cannot construct k palindromic strings from this\\n        //true          here all 4 having odd frequency\\n        //we can successfully divide into 4 single palindromic strings\\n        int n=s.size();\\n        if(n<k) return false;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++) \\n            mp[s[i]]++;\\n          int t=0;\\n        for(auto x: mp) {\\n            if(x.second&1) {\\n                t++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4003095,
                "title": "using-hashmap-o-n",
                "content": "# Approach\\nThe basic idea is to use a frequency map and counting\\nWe have to form \"k\" palindromes of ANY size\\nThat said \\n - each palindrome must have an EVEN number of letters\\n   example: aaaa, abaaba\\n - each palindrome can have an extra 1 letter\\n   example: aaBaa, abaEaba \\n\\nIt means we can for palindromes IF extra letters do not exceed \"k\"\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar canConstruct = function(s, k) {\\n    const fmap=new Map();\\n    if(s.length===k) return true;\\n    if(k>s.length) return false;\\n\\n    // build a map  \\n    for(let c of s) fmap.set(c,fmap.has(c)?fmap.get(c)+1:1);\\n    \\n    let lettersLeft=false;\\n    for(let [c,count] of fmap.entries()){\\n        if(count>1)\\n            // count extra letters, e.g aaaa=0,aa=0,aa=0 nothing left we can use all a\\'s\\n            // But yzyzy=1, we have extra \\'y\\' we can should use in this or other polindrome\\n            lettersLeft+=count%2; \\n        else\\n            lettersLeft+=count; // if we got here we have some extra letters we need to spread across all palindromes, rememner each palindrome can take only 1 extra letter  \\n        if(lettersLeft>k) // if there are too much extras we return false\\n            return false;\\n    }  \\n    return true;\\n  };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConstruct = function(s, k) {\\n    const fmap=new Map();\\n    if(s.length===k) return true;\\n    if(k>s.length) return false;\\n\\n    // build a map  \\n    for(let c of s) fmap.set(c,fmap.has(c)?fmap.get(c)+1:1);\\n    \\n    let lettersLeft=false;\\n    for(let [c,count] of fmap.entries()){\\n        if(count>1)\\n            // count extra letters, e.g aaaa=0,aa=0,aa=0 nothing left we can use all a\\'s\\n            // But yzyzy=1, we have extra \\'y\\' we can should use in this or other polindrome\\n            lettersLeft+=count%2; \\n        else\\n            lettersLeft+=count; // if we got here we have some extra letters we need to spread across all palindromes, rememner each palindrome can take only 1 extra letter  \\n        if(lettersLeft>k) // if there are too much extras we return false\\n            return false;\\n    }  \\n    return true;\\n  };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949898,
                "title": "c-explained-easy-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        unordered_map<char,int>map;\\n        for(int i=0;i<s.size();i++){\\n            map[s[i]]++;\\n        }\\n        int odd =0;\\n        for(auto x:map){\\n            if(x.second % 2 != 0) odd++;\\n        }\\n        //means remember 1--> one odd could be only used in one string\\n        // 2--> That implies that if we have more odds and less string some odd will not be used\\n        if(odd > k) return false;\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        unordered_map<char,int>map;\\n        for(int i=0;i<s.size();i++){\\n            map[s[i]]++;\\n        }\\n        int odd =0;\\n        for(auto x:map){\\n            if(x.second % 2 != 0) odd++;\\n        }\\n        //means remember 1--> one odd could be only used in one string\\n        // 2--> That implies that if we have more odds and less string some odd will not be used\\n        if(odd > k) return false;\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947438,
                "title": "c-counting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        int freq[26] = {0};\\n        int odd = 0;\\n        for(char ch: s) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++) odd += freq[i] % 2;\\n        return odd <= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        int freq[26] = {0};\\n        int odd = 0;\\n        for(char ch: s) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++) odd += freq[i] % 2;\\n        return odd <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928949,
                "title": "counting-sort-beats-100",
                "content": "# Complexity\\n- Time complexity:\\nO(s.count)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    private static let aAscii = Character(\"a\").asciiValue!\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        let count = s.count\\n        if count < k { return false }\\n        var occurencies = Array(repeating: 0, count: 26)\\n        \\n        for char in s {\\n            occurencies[Int(char.asciiValue! - Self.aAscii)] += 1\\n        }\\n\\n        let numberOfOdds = occurencies.filter { $0 % 2 == 1 }.count\\n\\n        return numberOfOdds <= k\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    private static let aAscii = Character(\"a\").asciiValue!\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        let count = s.count\\n        if count < k { return false }\\n        var occurencies = Array(repeating: 0, count: 26)\\n        \\n        for char in s {\\n            occurencies[Int(char.asciiValue! - Self.aAscii)] += 1\\n        }\\n\\n        let numberOfOdds = occurencies.filter { $0 % 2 == 1 }.count\\n\\n        return numberOfOdds <= k\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928017,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nif a string has more than one letter whose frequency is odd then that string cannot form palindrome, hence keeping this in mind, we keep track of each letters frequency, if it is odd we increment num by 1 for every odd frequency. If num is Less than k value then we return true.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k >len(s):\\n            return False\\n        num = 0\\n        p = Counter(s).values()\\n        for i in p:\\n            if i % 2 == 1:\\n                num = num+1\\n        if num <= k:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k >len(s):\\n            return False\\n        num = 0\\n        p = Counter(s).values()\\n        for i in p:\\n            if i % 2 == 1:\\n                num = num+1\\n        if num <= k:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897365,
                "title": "greedy-solution-odd-frequency-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(k > n) return 0;\\n        int cnt[26] = {};\\n        for(int i=0;i<n;i++){\\n            cnt[s[i]-\\'a\\']++;\\n        }\\n        int odd_frequency = 0;\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]%2)odd_frequency++;\\n        }\\n        if(k < odd_frequency) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(k > n) return 0;\\n        int cnt[26] = {};\\n        for(int i=0;i<n;i++){\\n            cnt[s[i]-\\'a\\']++;\\n        }\\n        int odd_frequency = 0;\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]%2)odd_frequency++;\\n        }\\n        if(k < odd_frequency) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894914,
                "title": "optimized-approach-in-c-time-o-n-space-o-1",
                "content": "# Approach\\nUse hashing to count number of occcurences specifically to get odd occuring alphabets in string.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(26) ~ O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        bool ans;\\n        if(k==s.length()){\\n            ans=true;\\n        }\\n        else if(k>s.length()){\\n            ans=false;\\n        }\\n        else{\\n            vector<int> count(26,0);\\n            for(auto i:s){\\n                count[i-\\'a\\']++;\\n            }\\n            int odd_count=0;\\n            for(auto i:count){\\n                if(i%2!=0){\\n                    odd_count++;\\n                }\\n            }\\n            if(odd_count>k){\\n                ans=false;\\n            }\\n            else{\\n                ans=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        bool ans;\\n        if(k==s.length()){\\n            ans=true;\\n        }\\n        else if(k>s.length()){\\n            ans=false;\\n        }\\n        else{\\n            vector<int> count(26,0);\\n            for(auto i:s){\\n                count[i-\\'a\\']++;\\n            }\\n            int odd_count=0;\\n            for(auto i:count){\\n                if(i%2!=0){\\n                    odd_count++;\\n                }\\n            }\\n            if(odd_count>k){\\n                ans=false;\\n            }\\n            else{\\n                ans=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865494,
                "title": "easy-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        \\n        unordered_map<char,int> mp;\\n\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n\\n        int count=0;\\n        for(auto num:mp)\\n        {\\n            if(num.second%2==1)count++;\\n        }\\n\\n\\n        return count>k || s.size()<k?false:true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        \\n        unordered_map<char,int> mp;\\n\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n\\n        int count=0;\\n        for(auto num:mp)\\n        {\\n            if(num.second%2==1)count++;\\n        }\\n\\n\\n        return count>k || s.size()<k?false:true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847816,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int n = s.length();\\n        if(k>n) return false;\\n        if(k==n) return true;\\n\\n        HashMap<Character,Integer> hp = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(hp.containsKey(ch)) hp.put(ch,hp.get(ch)+1);\\n            else hp.put(ch,1);\\n        }\\n\\n        int odd = 0;\\n\\n        for(var a : hp.values()){\\n            if(a%2!=0) odd ++;\\n        }\\n\\n        if(odd>k) return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int n = s.length();\\n        if(k>n) return false;\\n        if(k==n) return true;\\n\\n        HashMap<Character,Integer> hp = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(hp.containsKey(ch)) hp.put(ch,hp.get(ch)+1);\\n            else hp.put(ch,1);\\n        }\\n\\n        int odd = 0;\\n\\n        for(var a : hp.values()){\\n            if(a%2!=0) odd ++;\\n        }\\n\\n        if(odd>k) return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837757,
                "title": "1400-construct-k-palindrome-strings-java",
                "content": "# Intuition\\nAs a palindrome string can be of even length and odd length.\\nNow for even length it won\\'t be a problem but for odd length we need to keep one chracter in middle of the string so all the character with odd occurences is what will make a diffrence.\\n\\n# Approach\\nCount all the occurnces of the chracters in string and then count no of chracters with odd occurences if the occurnce is gretaer than k then we can not opartition the string.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: constant\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int l = s.length();\\n        if(k>l)\\n        return false;\\n        int[] arr = new int[26];\\n//count all characters occurence\\n        for(int i=0; i<l; i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }\\n\\n        int nOdd = 0;\\n\\n// count all Odd occurences because odd occurences are all that will make difference \\n        for(int i=0; i<26; i++) { \\n            if(arr[i]%2!=0)\\n                  nOdd++;\\n        }\\n\\n        if(nOdd>k)\\n        return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int l = s.length();\\n        if(k>l)\\n        return false;\\n        int[] arr = new int[26];\\n//count all characters occurence\\n        for(int i=0; i<l; i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }\\n\\n        int nOdd = 0;\\n\\n// count all Odd occurences because odd occurences are all that will make difference \\n        for(int i=0; i<26; i++) { \\n            if(arr[i]%2!=0)\\n                  nOdd++;\\n        }\\n\\n        if(nOdd>k)\\n        return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823470,
                "title": "java-easy-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThinking a bit we can see that a pair of odd letters suppose \"abc\" , in such a case there are 3 odd letters and if k=1 or k=2 output shall be **false** but if k=3 output will be **true**.\\nSo what we can observe is:\\nA pair of even letters \"aa\" can make either 1 or 2 palindrome but a pair of odd letters \"ab\" can only make 2, it cannot make 1.\\nSo we just tracked odd nos, **if TotalOddNos<=k then ans will be true** , but **if there are more odd than k then ans will be****false**.(Try to dry run as many testcases possible for better understanding).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a set we can have count of freq of odd nos;\\nif set already contains an char remove the char and continue , cause this char is now even.\\nIn the end set.size() will be total odd chars.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n) (in worst case it will have to store all chars , eg: \"abcde\")\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k)\\n        return false;\\n        if(s.length()==k) return true;\\n        HashSet<Character> set=new HashSet<>();\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(set.contains(s.charAt(i)))\\n            {\\n                set.remove(s.charAt(i));\\n               continue;\\n            }\\n            else\\n            set.add(s.charAt(i));\\n        }\\n        if(set.size()<=k)\\n        return true;\\n        else\\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k)\\n        return false;\\n        if(s.length()==k) return true;\\n        HashSet<Character> set=new HashSet<>();\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(set.contains(s.charAt(i)))\\n            {\\n                set.remove(s.charAt(i));\\n               continue;\\n            }\\n            else\\n            set.add(s.charAt(i));\\n        }\\n        if(set.size()<=k)\\n        return true;\\n        else\\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821414,
                "title": "c-easy-to-understand-straightforward-approach",
                "content": "# Intuition\\nwe need to ensure that each palindrome can have at most one character with an odd frequency, as all other characters with odd frequencies can be paired up to form palindromes. If the number of characters with odd frequencies exceeds `k`, it will not be possible to construct `k` palindromes.\\n\\n# Approach\\n1. If the length of the string `s` is less than `k`, it is not possible to construct `k` palindromes using all characters. Return false in this case.\\n2. Create an unordered map `mp` to store the frequency of each character in the string `s`.\\n3. Count the number of characters with odd frequencies (i.e., frequency % 2 == 1) in the `mp` map and store it in the variable `oddcnt`.\\n4. If `oddcnt` is greater than `k`, it is not possible to construct `k` palindromes using all characters. Return false in this case.\\n5. Otherwise, it is possible to construct `k` palindromes. Return true.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is O(n), where n is the length of the string `s`, as we need to iterate through the string to count the character frequencies.\\n- Space complexity: The space complexity is O(n), where n is the length of the string `s`, due to the unordered map `mp` storing character frequencies.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        \\n        int oddcnt = 0;\\n        unordered_map<char,int> mp;\\n\\n        for(auto each: s)\\n            mp[each]++;\\n\\n        for(auto each: mp){\\n            if(each.second % 2)\\n                oddcnt++;\\n        }\\n\\n        if(oddcnt > k) \\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        \\n        int oddcnt = 0;\\n        unordered_map<char,int> mp;\\n\\n        for(auto each: s)\\n            mp[each]++;\\n\\n        for(auto each: mp){\\n            if(each.second % 2)\\n                oddcnt++;\\n        }\\n\\n        if(oddcnt > k) \\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805888,
                "title": "c-99-simple-logic",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        int odds = 0;\\n        vector<int> char_map(26, 0);\\n\\n        for(auto &c : s) \\n            char_map[c - \\'a\\']++;\\n\\n        for(auto &i : char_map)\\n            if(i % 2 != 0) \\n                odds++;\\n\\n        return odds <= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        int odds = 0;\\n        vector<int> char_map(26, 0);\\n\\n        for(auto &c : s) \\n            char_map[c - \\'a\\']++;\\n\\n        for(auto &i : char_map)\\n            if(i % 2 != 0) \\n                odds++;\\n\\n        return odds <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771005,
                "title": "3-lines-c",
                "content": "```\\nbool canConstruct(string s, int k) {\\n  int mask = 0;\\n  for(auto c: s) { mask ^= (1U << (c-\\'a\\')); }        \\n  return (s.size()>=k) && (__builtin_popcount(mask)<=k);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConstruct(string s, int k) {\\n  int mask = 0;\\n  for(auto c: s) { mask ^= (1U << (c-\\'a\\')); }        \\n  return (s.size()>=k) && (__builtin_popcount(mask)<=k);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766097,
                "title": "simple-java-solution-o-n-tc-explained-intuition",
                "content": "# Intuition\\nHere we dont have to create pallindrome we just need to check if it is possible or not so i followed some simple rules.\\n1. if all the elements are distinct that means \\'a\\' \\'b\\' \\'c\\' are all pallindrome so we can return true.\\n2. if size of string is less that no of required pallindrome then its obviously not possible so false.\\n3. at max the odd appearing character can be equal to k, coz in a pallindrome a odd appearing number has to \\'appear\\' in the middle else it can be a pallindrome so i check for odd occurruing elements \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        HashMap<Character, Integer> count = new HashMap<>();\\n        for(char c : s.toCharArray()) {\\n            count.put(c, count.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        if(count.size() == k) return true;\\n        if(s.length() < k) return false;\\n        \\n        int j = 0;\\n        for(char c : count.keySet()) {\\n            if(count.get(c) % 2 != 0) j++;\\n        }\\n        \\n        return j <= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        HashMap<Character, Integer> count = new HashMap<>();\\n        for(char c : s.toCharArray()) {\\n            count.put(c, count.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        if(count.size() == k) return true;\\n        if(s.length() < k) return false;\\n        \\n        int j = 0;\\n        for(char c : count.keySet()) {\\n            if(count.get(c) % 2 != 0) j++;\\n        }\\n        \\n        return j <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764709,
                "title": "super-simple-just-count-odd-count-character-less-or-eq-to-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s)<k: return False\\n        o=0\\n        for i in Counter(s).values():\\n            if i%2: o+=1\\n         \\n        return o<=k  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s)<k: return False\\n        o=0\\n        for i in Counter(s).values():\\n            if i%2: o+=1\\n         \\n        return o<=k  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733181,
                "title": "easy-way-no",
                "content": "# Easy way (no)\\n![image.png](https://assets.leetcode.com/users/images/73e9e1d6-77d5-4d4d-8609-71c5f5bc3a06_1688749631.1845062.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 45\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 97\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        d = {}\\n        for i in s:\\n            d[i] = d.get(i, 0) + 1\\n        odd_count = sum((1 for i in d if d[i] % 2 == 1))\\n        return odd_count <= k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        d = {}\\n        for i in s:\\n            d[i] = d.get(i, 0) + 1\\n        odd_count = sum((1 for i in d if d[i] % 2 == 1))\\n        return odd_count <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713758,
                "title": "python3-9-lines-t-s-o-n-o-1-t-100",
                "content": "# Intuition\\n\\nWe can first take ALL pairs of the same letter, and these pairs can go into any palindrome.\\n\\nAfter which, we will be left with one of each letter with odd count in `s`. These letters cannot belong to the same palindrome (since each palindrome can only have at most one odd-numbered letter; its center).\\n\\nHence, if `k` is greater than or equal to the number of odd-numbered letters, return `True`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nwhere `n` is the length of `s`\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n# Time: O(n)\\n# Space: O(1)\\n\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n\\n        # if there aren\\'t enough letters to make k palindromes\\n        if k > len(s): return False\\n\\n        # pigeonhole principle, since there are at most 26 alphabets,\\n        # there can be at most 26 odd-numbered letters\\n        if k >= 26: return True\\n\\n        # initialise bit-shift for each letter\\n        letters = {}\\n        for i, c in enumerate(\\'aquickbrownfoxjumpsoverthelazydog\\'):\\n            letters[c] = i\\n\\n        # use bit-string to represent if letter count is even/odd\\n        bs = 0\\n        for c in s:\\n            bs ^= 1 << letters[c]\\n\\n        return bs.bit_count() <= k\\n\\n```\\n\\nhttps://leetcode.com/problems/construct-k-palindrome-strings/submissions/985452122/",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Bitmask"
                ],
                "code": "```\\n# Time: O(n)\\n# Space: O(1)\\n\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n\\n        # if there aren\\'t enough letters to make k palindromes\\n        if k > len(s): return False\\n\\n        # pigeonhole principle, since there are at most 26 alphabets,\\n        # there can be at most 26 odd-numbered letters\\n        if k >= 26: return True\\n\\n        # initialise bit-shift for each letter\\n        letters = {}\\n        for i, c in enumerate(\\'aquickbrownfoxjumpsoverthelazydog\\'):\\n            letters[c] = i\\n\\n        # use bit-string to represent if letter count is even/odd\\n        bs = 0\\n        for c in s:\\n            bs ^= 1 << letters[c]\\n\\n        return bs.bit_count() <= k\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704019,
                "title": "hashmap-easy-c-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLets store no of occurrences of each alphabet.\\n\\nObservation I :\\n\\nIf any alphabet has odd occurence one of its letter should be the middle character in one of the pallindromes.\\n\\nObservation II :\\nIf the number of remaining letters is greater than or equal to the remaining k value there is a possibility.\\nWe can choose to break up pairs or not greedily.\\n\\n# Complexity\\n- Time complexity:\\n$$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$ O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> cnt(26,0);\\n        for(auto x : s){\\n            cnt[x-\\'a\\']++;\\n        }\\n        int summ=0;\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]%2==1){\\n                k--;\\n                cnt[i]--;\\n            }\\n            summ+=cnt[i];\\n        }\\n        return (summ>=k && k>=0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> cnt(26,0);\\n        for(auto x : s){\\n            cnt[x-\\'a\\']++;\\n        }\\n        int summ=0;\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]%2==1){\\n                k--;\\n                cnt[i]--;\\n            }\\n            summ+=cnt[i];\\n        }\\n        return (summ>=k && k>=0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678667,
                "title": "c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for(char c : s) {\\n            m[c]++;\\n        }\\n        int ones = 0;\\n        for(auto x : m) {\\n            if(x.second %2 ==1) {\\n                ones++;\\n            }\\n        }\\n        int n = s.size();\\n        return ones <= k && n>=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for(char c : s) {\\n            m[c]++;\\n        }\\n        int ones = 0;\\n        for(auto x : m) {\\n            if(x.second %2 ==1) {\\n                ones++;\\n            }\\n        }\\n        int n = s.size();\\n        return ones <= k && n>=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677544,
                "title": "python-solution-time-complexity-o-n",
                "content": "Here is my solution.\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        counts, minimum, maximum = {}, 0, 0\\n\\n        for char in s:\\n            if counts.get(char) is not None:\\n                counts[char] += 1\\n            else:\\n                counts[char] = 1\\n\\n        for char, count in counts.items():\\n            if count % 2 == 0:\\n                maximum += count\\n            elif count % 2 == 1:\\n                minimum += 1\\n                maximum += count\\n\\n        return max(1, minimum) <= k <= maximum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        counts, minimum, maximum = {}, 0, 0\\n\\n        for char in s:\\n            if counts.get(char) is not None:\\n                counts[char] += 1\\n            else:\\n                counts[char] = 1\\n\\n        for char, count in counts.items():\\n            if count % 2 == 0:\\n                maximum += count\\n            elif count % 2 == 1:\\n                minimum += 1\\n                maximum += count\\n\\n        return max(1, minimum) <= k <= maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667991,
                "title": "hashmap-beginner-friendly",
                "content": "# Intuition\\njust count odd freq element as we know that even freq elements can make palindrome easily so ignore even freq element. A palindrome can contain at most one odd freq element, so if odd freq characters are greater than k its clear that we cant divide all characters of the string to form k palondrome as we will be left with some odd freq elements.....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        if(s.size() == k)\\n            return true;\\n\\n        if(s.size() < k)\\n            return false;\\n        \\n        map<char, int> m;\\n\\n        for(int i=0; i<s.size(); i++)\\n            m[s[i]]++;\\n\\n        int cnt=0;\\n\\n        for(auto it=m.begin(); it!=m.end(); it++)\\n        {\\n            if(it->second%2 != 0)\\n                cnt++;\\n        }\\n\\n        if(cnt > k)\\n        {\\n            return false;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        if(s.size() == k)\\n            return true;\\n\\n        if(s.size() < k)\\n            return false;\\n        \\n        map<char, int> m;\\n\\n        for(int i=0; i<s.size(); i++)\\n            m[s[i]]++;\\n\\n        int cnt=0;\\n\\n        for(auto it=m.begin(); it!=m.end(); it++)\\n        {\\n            if(it->second%2 != 0)\\n                cnt++;\\n        }\\n\\n        if(cnt > k)\\n        {\\n            return false;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630491,
                "title": "java-simple-using-alphabet-array",
                "content": "# Intuition\\nIf the number of odd frequencies is more than k, then return false.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (s.length() == k) return true;\\n        if (s.length() < k) return false;\\n        int alph[] = new int[26], countOdd = 0;\\n        for (int i = 0; i < s.length(); i++) alph[s.charAt(i) - \\'a\\']++;\\n        for (int i = 0; i < alph.length; i++) if (alph[i] % 2 == 1) countOdd++;\\n        return countOdd <= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (s.length() == k) return true;\\n        if (s.length() < k) return false;\\n        int alph[] = new int[26], countOdd = 0;\\n        for (int i = 0; i < s.length(); i++) alph[s.charAt(i) - \\'a\\']++;\\n        for (int i = 0; i < alph.length; i++) if (alph[i] % 2 == 1) countOdd++;\\n        return countOdd <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600834,
                "title": "easy-to-understand-with-simple-approach",
                "content": "# Intuition\\nLook into characters with odd frequency\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach-\\n1)If the size of string is less than k,return false.\\n2)Store the frequency of each character in a map\\n3)Count the number of elements having odd frequencies.\\n4)If the count<= k return true else false\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        unordered_map<char,int> mp;\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int numOfodd=0;\\n        for(auto i:mp){\\n           if(i.second%2!=0)\\n              numOfodd++;\\n        }\\n        return (numOfodd<=k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        unordered_map<char,int> mp;\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int numOfodd=0;\\n        for(auto i:mp){\\n           if(i.second%2!=0)\\n              numOfodd++;\\n        }\\n        return (numOfodd<=k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593302,
                "title": "easy-trick-with-code",
                "content": "\\n# Approach\\n Easy Trick:\\n Edge case: if( length of s<k) return false;\\n1. Count the frequency of every character.\\n2. Count the number of character whose frequency is odd.\\n3. If no. of odd frequency character > k return false, else return true;\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int n=s.length();\\n        if(n==k)return true;\\n        if(k>n)return false;\\n\\n        int[] arr=new int[26];\\n\\n        for(char c:s.toCharArray())arr[c-\\'a\\']++;\\n        \\n        int count=0;\\n        for(int i=0;i<26;i++){\\n            if(arr[i]%2!=0)count++;\\n        }\\n        if(count>k)return false;\\n        return true;\\n    }\\n}\\n```\\nPlease upvote if you understood the solution",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int n=s.length();\\n        if(n==k)return true;\\n        if(k>n)return false;\\n\\n        int[] arr=new int[26];\\n\\n        for(char c:s.toCharArray())arr[c-\\'a\\']++;\\n        \\n        int count=0;\\n        for(int i=0;i<26;i++){\\n            if(arr[i]%2!=0)count++;\\n        }\\n        if(count>k)return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516950,
                "title": "count-frequencies-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k){\\n        \\n    if(s.length()<k)return false;\\n\\n    int[]freqarr=new int[26];\\n\\n    int even=0;\\n\\n    int odd=0;\\n\\n    for(int i=0;i<s.length();i++){\\n        freqarr[s.charAt(i)-\\'a\\']++;\\n    }\\n\\n    for(int i=0;i<26;i++){\\n        if(freqarr[i]%2==0){\\n            even++;\\n        }\\n        else{\\n            odd++;\\n        }\\n    }\\n\\n    if(odd>k)return false;\\n\\n    return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k){\\n        \\n    if(s.length()<k)return false;\\n\\n    int[]freqarr=new int[26];\\n\\n    int even=0;\\n\\n    int odd=0;\\n\\n    for(int i=0;i<s.length();i++){\\n        freqarr[s.charAt(i)-\\'a\\']++;\\n    }\\n\\n    for(int i=0;i<26;i++){\\n        if(freqarr[i]%2==0){\\n            even++;\\n        }\\n        else{\\n            odd++;\\n        }\\n    }\\n\\n    if(odd>k)return false;\\n\\n    return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508841,
                "title": "very-easy-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) \\n    {\\n        int count=0;\\n        if(k>s.length())return false;\\n    if(s.length()==k)return true;\\n    HashMap<Character,Integer> map=new HashMap<>();\\n    for(int i=0; i<s.length(); i++)\\n    {\\n        map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n    }\\n    for(Map.Entry<Character,Integer> entry:map.entrySet())\\n    {\\n        if(entry.getValue()%2!=0)\\n        {\\n         count++;\\n        }\\n    }\\n    if(count>k)return false;\\n\\n\\n    return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) \\n    {\\n        int count=0;\\n        if(k>s.length())return false;\\n    if(s.length()==k)return true;\\n    HashMap<Character,Integer> map=new HashMap<>();\\n    for(int i=0; i<s.length(); i++)\\n    {\\n        map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n    }\\n    for(Map.Entry<Character,Integer> entry:map.entrySet())\\n    {\\n        if(entry.getValue()%2!=0)\\n        {\\n         count++;\\n        }\\n    }\\n    if(count>k)return false;\\n\\n\\n    return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480371,
                "title": "python-greedy-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n\\n        hash = defaultdict(int)\\n\\n        for ch in s:\\n            hash[ch] += 1\\n                    \\n        count = 0\\n        \\n        for num in hash.values():\\n            if num % 2 != 0:\\n                count += 1\\n                \\n        return count <= k\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n\\n        hash = defaultdict(int)\\n\\n        for ch in s:\\n            hash[ch] += 1\\n                    \\n        count = 0\\n        \\n        for num in hash.values():\\n            if num % 2 != 0:\\n                count += 1\\n                \\n        return count <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477466,
                "title": "construct-k-palindrome-strings",
                "content": "----------------- Easy C++ Solution -------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        if(s.size() == k) return true;\\n        vector<int> count(26);\\n        for(char c : s){\\n            count[c-\\'a\\']++;\\n        }\\n        int odd = 0;\\n        for(int i = 0; i < 26; i++){\\n            if(count[i] % 2 == 1){\\n                odd++;\\n            }\\n        }\\n        return odd <= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        if(s.size() == k) return true;\\n        vector<int> count(26);\\n        for(char c : s){\\n            count[c-\\'a\\']++;\\n        }\\n        int odd = 0;\\n        for(int i = 0; i < 26; i++){\\n            if(count[i] % 2 == 1){\\n                odd++;\\n            }\\n        }\\n        return odd <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444963,
                "title": "java-bitset-solution-with-detailed-comments",
                "content": "# Code\\n```\\n// Class definition for the solution\\nclass Solution {\\n    // Method to check if a given string \\'s\\' can be partitioned into \\'k\\' non-empty palindrome strings\\n    public boolean canConstruct(String s, int k) {\\n        // Create a BitSet of size 26 to represent each lowercase English letter\\n        BitSet chars = new BitSet(26);\\n\\n        // Iterate through the given string \\'s\\'\\n        for (int i = 0; i < s.length(); ++i) {\\n            // Toggle the bit at the index corresponding to the current character,\\n            // effectively counting the occurrences of each character with odd parity\\n            chars.flip(s.charAt(i) - \\'a\\');\\n        }\\n\\n        // If the number of characters with odd occurrences (cardinality of BitSet) is less than or equal to \\'k\\'\\n        // and \\'k\\' is less than or equal to the length of the string \\'s\\', return true\\n        // (meaning the string can be partitioned into \\'k\\' palindrome strings)\\n        return chars.cardinality() <= k && k <= s.length(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Class definition for the solution\\nclass Solution {\\n    // Method to check if a given string \\'s\\' can be partitioned into \\'k\\' non-empty palindrome strings\\n    public boolean canConstruct(String s, int k) {\\n        // Create a BitSet of size 26 to represent each lowercase English letter\\n        BitSet chars = new BitSet(26);\\n\\n        // Iterate through the given string \\'s\\'\\n        for (int i = 0; i < s.length(); ++i) {\\n            // Toggle the bit at the index corresponding to the current character,\\n            // effectively counting the occurrences of each character with odd parity\\n            chars.flip(s.charAt(i) - \\'a\\');\\n        }\\n\\n        // If the number of characters with odd occurrences (cardinality of BitSet) is less than or equal to \\'k\\'\\n        // and \\'k\\' is less than or equal to the length of the string \\'s\\', return true\\n        // (meaning the string can be partitioned into \\'k\\' palindrome strings)\\n        return chars.cardinality() <= k && k <= s.length(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430766,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (k>s.length()) return false;\\n        boolean isOdd[] = new boolean[26];\\n        for (char c:s.toCharArray()) isOdd[c-\\'a\\']=!isOdd[c-\\'a\\'];\\n        for (boolean b:isOdd) if (b)k--;\\n        return (k>=0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (k>s.length()) return false;\\n        boolean isOdd[] = new boolean[26];\\n        for (char c:s.toCharArray()) isOdd[c-\\'a\\']=!isOdd[c-\\'a\\'];\\n        for (boolean b:isOdd) if (b)k--;\\n        return (k>=0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425546,
                "title": "easy-c-solution-intuitive-using-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhave to check for the characters having odd frequency as they have to be present at different strings.\\nif no of characters having odd frequency is less than equal to k then we return true else false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstoring frequency in unordered_map for each character\\ntraversing map to check for odd frequency character\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(s.length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(s.length)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for(auto x:s)\\n        {\\n            m[x]++;\\n        }\\n\\n        if(k>s.length())\\n        {\\n            return false;\\n        }\\n\\n        int no = 0;\\n        for(auto x:m)\\n        {\\n            if(x.second%2!=0)\\n            {\\n                no++;\\n            }\\n        }\\n\\n        if(no<=k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for(auto x:s)\\n        {\\n            m[x]++;\\n        }\\n\\n        if(k>s.length())\\n        {\\n            return false;\\n        }\\n\\n        int no = 0;\\n        for(auto x:m)\\n        {\\n            if(x.second%2!=0)\\n            {\\n                no++;\\n            }\\n        }\\n\\n        if(no<=k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410448,
                "title": "c-short-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (k > s.size()) return false;\\n        int freq[26];\\n        memset(freq, 0, sizeof(freq));\\n        for (char c : s) ++ freq[c - \\'a\\'];\\n        for (int i = 0; i < 26; ++ i) {\\n            if (freq[i] & 1) {\\n                -- k;\\n                if (k < 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (k > s.size()) return false;\\n        int freq[26];\\n        memset(freq, 0, sizeof(freq));\\n        for (char c : s) ++ freq[c - \\'a\\'];\\n        for (int i = 0; i < 26; ++ i) {\\n            if (freq[i] & 1) {\\n                -- k;\\n                if (k < 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398509,
                "title": "c-greedy-counting-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCounting & Greedy Combinatrics. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will count the number of occurenece of each alphabet in the string and store in count vector.\\n2. Then, we will count the number of maximum total even pairs possible AND the left out odd values.\\n3. This is because we can merge 1 odd value to pair(s) of even value .\\n4. Then we will evaluate the minimum number of palindromic substrings that we will be able to make by the givven formula =>\\n`if(odds<=evens)  \\n  val += odds;`\\n`else \\n  val += evens + (odds - evens);`\\n5. If the val is <= k : true ELSE false\\n6. Taking care of base case :-\\n` if(n==k)    return true;`\\n`if(n<k)     return false;`\\n\\n![download (1).jfif](https://assets.leetcode.com/users/images/56c84a2f-1553-4523-bfd1-adee7f233903_1681070502.749976.jpeg)\\n\\n\\n# Complexity\\n- Time complexity : O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity  : O(26) ~= O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        //base cases\\n        int n = s.size();\\n        if(n==k)    return true;\\n        if(n<k)     return false;\\n\\n        //counting occurences\\n        vector<int> count (26,0);\\n        for(auto i : s) \\n            count[i-\\'a\\']++;\\n\\n        //counting possible_even_pairs AND left out Odds\\n        int odds = 0, evens = 0;\\n        for(auto i : count)     {        \\n            evens += i/2;\\n            odds += i%2;\\n        }\\n\\n        //evaluating val using above explained formula\\n        int val=0;\\n        if(odds<=evens)  \\n            val += odds;\\n        else \\n            val += evens + (odds - evens);\\n\\n        return val <= k ? 1 : 0;\\n    }\\n};\\n```\\n\\n![download (2).jfif](https://assets.leetcode.com/users/images/21ec2357-1a51-48c5-8aee-698351e9c16a_1681070518.8362906.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        //base cases\\n        int n = s.size();\\n        if(n==k)    return true;\\n        if(n<k)     return false;\\n\\n        //counting occurences\\n        vector<int> count (26,0);\\n        for(auto i : s) \\n            count[i-\\'a\\']++;\\n\\n        //counting possible_even_pairs AND left out Odds\\n        int odds = 0, evens = 0;\\n        for(auto i : count)     {        \\n            evens += i/2;\\n            odds += i%2;\\n        }\\n\\n        //evaluating val using above explained formula\\n        int val=0;\\n        if(odds<=evens)  \\n            val += odds;\\n        else \\n            val += evens + (odds - evens);\\n\\n        return val <= k ? 1 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395252,
                "title": "return-true-for-k-26",
                "content": "# Intuition\\nIf both k and s.length() is greater or equal to 26, we can return solution as true because there can only be 26 bucket in worst case and you will always have enough characters available to expand k. \\n\\n# Complexity\\n- Time complexity:\\nO(1) when k>=26, O(n) otherwise.\\n\\n- Space complexity:\\nO(26)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(k>s.length()){\\n            return false;\\n        }else if(k==s.length()){\\n            return true;\\n        }else if(k>=26){\\n            return true;\\n        }\\n        int map[]=new int[26];\\n        for(int i=0;i<s.length();i++){\\n            map[s.charAt(i)-\\'a\\']++;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<26;i++){\\n            cnt+=map[i]%2;\\n        }\\n        return cnt<=k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(k>s.length()){\\n            return false;\\n        }else if(k==s.length()){\\n            return true;\\n        }else if(k>=26){\\n            return true;\\n        }\\n        int map[]=new int[26];\\n        for(int i=0;i<s.length();i++){\\n            map[s.charAt(i)-\\'a\\']++;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<26;i++){\\n            cnt+=map[i]%2;\\n        }\\n        return cnt<=k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386350,
                "title": "python-even-odd-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        dic = Counter(s)\\n        even, odd = 0,0\\n        for i in dic.keys():\\n            if dic[i]%2!=0:\\n                odd+=1\\n                dic[i]-=1\\n            even+=dic[i]\\n\\n        if odd > k or odd+even<k:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        dic = Counter(s)\\n        even, odd = 0,0\\n        for i in dic.keys():\\n            if dic[i]%2!=0:\\n                odd+=1\\n                dic[i]-=1\\n            even+=dic[i]\\n\\n        if odd > k or odd+even<k:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381403,
                "title": "construct-k-palindrome-strings",
                "content": "# Intuition\\nCondition 1. odd characters <= k\\nCount the occurrences of all characters.\\nIf one character has odd times occurrences,\\nthere must be at least one palindrome,\\nwith odd length and this character in the middle.\\nSo we count the characters that appear odd times,\\nthe number of odd character should not be bigger than k.\\n\\nCondition 2. k <= s.length()\\nAlso, if we have one character in each palindrome,\\nwe will have at most s.length() palindromes,\\nso we need k <= s.length().\\n\\nThe above two condition are necessary and sufficient conditions for this problem.\\nSo we return odd <= k <= n\\n\\n\\nConstruction\\n@spjparmar immediately got a question like why this works always for all strings.\\nHe gave the some following dry runs. :)\\nFor any string with 0 odd character count , we can form k no. of palindrome strings for sure with k<=n\\n(This is why k<=n)\\n\\neg\\naabb, k=1| abba\\naabb, k=2 | aa, bb\\naabb, k=3 | a, a, bb\\naabb, k=4 | a, a, b, b\\n\\nFor any string with odd character count <=k , we can always form k palindrome string for sure with k<=n\\neg2\\naabbc, k=1 | aacbb\\naabbc, k=2 | aca, bb\\naabbc, k=3 | a,a, bcb\\naabbc, k=4 | a, a, c ,bb\\naabbc, k=5 | a, a, c, b, b\\n\\neg3\\naabc, k=1 | N/A\\naabc, k=2 | aba, c\\naabc, k=3 | aa, b, c\\naabc, k=4 | a, a, b, c\\n\\nHope this helps somebody.\\n\\n\\n\\n# Complexity\\n- Time complexity: 0(n)\\n\\n\\n- Space complexity:0(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        bitset<26> odd;\\n        for (char& c : s)\\n            odd.flip(c - \\'a\\');\\n        return odd.count() <= k && k <= s.length();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        bitset<26> odd;\\n        for (char& c : s)\\n            odd.flip(c - \\'a\\');\\n        return odd.count() <= k && k <= s.length();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375694,
                "title": "easy-solution-cpp",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k > s.length()) return false;\\n        if(k == s.length()) return true;\\n        unordered_map<char,int> mp;\\n\\n        for(int i =0; i<s.length(); i++){\\n            mp[s[i]]++;\\n        }\\n        int cnt =0;\\n        for(auto it : mp){\\n            if(it.second % 2 !=0) {cnt++;}\\n        }\\n        if(cnt > k) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k > s.length()) return false;\\n        if(k == s.length()) return true;\\n        unordered_map<char,int> mp;\\n\\n        for(int i =0; i<s.length(); i++){\\n            mp[s[i]]++;\\n        }\\n        int cnt =0;\\n        for(auto it : mp){\\n            if(it.second % 2 !=0) {cnt++;}\\n        }\\n        if(cnt > k) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347696,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nbool canConstruct(string s, int k) {\\n    int n = s.length();\\n    if (k>n)\\n        return false;\\n    int wasted = 0;\\n    vector<int> freq(26,0);\\n    for (int i{};i<n;i++)\\n        freq[s[i]-\\'a\\']++;\\n    for (int i{};i<26;i++){\\n        if (freq[i]%2!=0)\\n            wasted++;\\n    }\\n    return wasted<=k;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool canConstruct(string s, int k) {\\n    int n = s.length();\\n    if (k>n)\\n        return false;\\n    int wasted = 0;\\n    vector<int> freq(26,0);\\n    for (int i{};i<n;i++)\\n        freq[s[i]-\\'a\\']++;\\n    for (int i{};i<26;i++){\\n        if (freq[i]%2!=0)\\n            wasted++;\\n    }\\n    return wasted<=k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337670,
                "title": "100-python",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        if len(s) < k:\\n            return False\\n        freq = defaultdict(int)\\n        for i in s:\\n            freq[i] += 1\\n        for i in freq.values():\\n            if i % 2:\\n                k -= 1\\n                if k == -1:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        if len(s) < k:\\n            return False\\n        freq = defaultdict(int)\\n        for i in s:\\n            freq[i] += 1\\n        for i in freq.values():\\n            if i % 2:\\n                k -= 1\\n                if k == -1:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337245,
                "title": "explaination-let-s-take-it-one-by-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIdea is to first try if the simple logic works. Let me put every thought pointwise.\\n\\n1. S will have some odd occurance as well as some even occurances of characters, sounds obivious?.\\n2. First of all, if odd occurances(Let\\'s call O) are more than K i.e O>K, then it\\'s not possible to build just k palindroms using O occurances.  why? Ok, have you seen a palindrom which contains 2 or more odd occurances? There can be atmost one odd occurance and that too in the center.\\n3. It\\'s easy till this point, Now let\\'s take just one character from all the Os and create first O palindroms. So we already have O palndroms out of the K palindroms that we wanted to create.\\n4. Now, we will have to create K-O palindromes out of S-O characters. Remember that all (S-O) remaing characters are even occurances. So another simple condition that comes to mind is (S-O)>=(K-O) or S>K.\\n5. But is it a sufficient condition? let\\'s think in this way. We will build palindromes incremently from 1 till S-O. After step 3 we have (S-O) chars left. Can we create just one palindrom using all the even occurances? Yes, simply put everything there.\\n6. Can we create 2 palindroms? Yes, just take out 1 pair from the first palindrom and split it into two character. Keep 1 charecter in the center of first one and put 1 character in the second palindrom. We have 2 palindroms.\\n7. Can we create 3? Yes, just take out the center one(which we just put)from first palindrom and put it on 3rd palindrom.\\n8. Can we create 4? Yes, just take another pair from the first palindrom. Keep one character at the center of first palindrom and put the remaining character on 4th palindrom. \\n\\nJust keep repeating and you can create all 1 to S-O palindroms. So be it any K<=S, the answer is true.\\n\\nPost it in the comments and we can discuss any point again if needed.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int []count = new int[26];\\n        Arrays.fill(count,0);\\n        for(int i=0; i<s.length();i++)\\n            count[s.charAt(i)-\\'a\\']++;\\n        int odd = 0;\\n        for(int i=0;i<26;i++){\\n            if(count[i]%2!=0){\\n                odd++;\\n            }\\n        }\\n        if(odd>k)\\n            return false;\\n        if(s.length()<k)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int []count = new int[26];\\n        Arrays.fill(count,0);\\n        for(int i=0; i<s.length();i++)\\n            count[s.charAt(i)-\\'a\\']++;\\n        int odd = 0;\\n        for(int i=0;i<26;i++){\\n            if(count[i]%2!=0){\\n                odd++;\\n            }\\n        }\\n        if(odd>k)\\n            return false;\\n        if(s.length()<k)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275773,
                "title": "intuitive-and-beginner-o-n-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k)return true;\\n        if(s.size()<k)return false;\\n        unordered_map<char,int> mp;\\n\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int count=0;\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                count++;\\n            }\\n        }\\n    return count<=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k)return true;\\n        if(s.size()<k)return false;\\n        unordered_map<char,int> mp;\\n\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int count=0;\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                count++;\\n            }\\n        }\\n    return count<=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274302,
                "title": "c-map-and-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for (auto& c : s) ++m[c];\\n        int oddCount = 0, evenSum = 0;\\n        for (auto& [f,s] : m){\\n            if (s % 2 == 1) ++oddCount;\\n            evenSum += s - (s % 2 == 1);\\n        }\\n        if (oddCount > k) return false;\\n        return (k -= evenSum + oddCount) <= 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for (auto& c : s) ++m[c];\\n        int oddCount = 0, evenSum = 0;\\n        for (auto& [f,s] : m){\\n            if (s % 2 == 1) ++oddCount;\\n            evenSum += s - (s % 2 == 1);\\n        }\\n        if (oddCount > k) return false;\\n        return (k -= evenSum + oddCount) <= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260751,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n\\n\\n- Space complexity: 0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(n<k) return false;\\n        unordered_map<char,int>m1;\\n        for(int i=0;i<n;i++){\\n            m1[s[i]]++;\\n        }\\n        int oddcount=0;\\n        for(auto x : m1){\\n            if(x.second%2!=0) oddcount++;\\n        }\\n\\n        if(oddcount>k) return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(n<k) return false;\\n        unordered_map<char,int>m1;\\n        for(int i=0;i<n;i++){\\n            m1[s[i]]++;\\n        }\\n        int oddcount=0;\\n        for(auto x : m1){\\n            if(x.second%2!=0) oddcount++;\\n        }\\n\\n        if(oddcount>k) return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260420,
                "title": "easiest-way-to-construct-k-palindrome-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n if(s.length<k){\\n     return false\\n }  \\nlet freq={};\\n\\nfor(let i=0;i<s.length;i++){\\n    let curr=s[i];\\n    if(freq[curr]){\\n        freq[curr]++\\n    }else{\\n        freq[curr]=1\\n    }\\n}\\nlet count=0\\nlet x=Object.keys(freq);\\nfor(let i=0;i<x.length;i++){\\n    let curr=x[i]\\nif(freq[curr]%2!=0){\\n    count++\\n}\\n}\\nif(count>k){\\n    return false\\n}\\nreturn true\\n \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n if(s.length<k){\\n     return false\\n }  \\nlet freq={};\\n\\nfor(let i=0;i<s.length;i++){\\n    let curr=s[i];\\n    if(freq[curr]){\\n        freq[curr]++\\n    }else{\\n        freq[curr]=1\\n    }\\n}\\nlet count=0\\nlet x=Object.keys(freq);\\nfor(let i=0;i<x.length;i++){\\n    let curr=x[i]\\nif(freq[curr]%2!=0){\\n    count++\\n}\\n}\\nif(count>k){\\n    return false\\n}\\nreturn true\\n \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3251439,
                "title": "c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n=s.size(),arr[26];\\n        for(int i=0;i<26;i++)\\n        {\\n            arr[i]=0;\\n        }\\n        if(n<k)\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[s[i]-\\'a\\']++;\\n        }\\n        int count=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if((arr[i]&1)!=0)\\n            {\\n                count++;\\n            }\\n        }\\n        cout<<count<<\" \";\\n        if(k<count)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n=s.size(),arr[26];\\n        for(int i=0;i<26;i++)\\n        {\\n            arr[i]=0;\\n        }\\n        if(n<k)\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[s[i]-\\'a\\']++;\\n        }\\n        int count=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if((arr[i]&1)!=0)\\n            {\\n                count++;\\n            }\\n        }\\n        cout<<count<<\" \";\\n        if(k<count)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3242990,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        s.count >= k && s\\n            .reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\\n            .filter { $0.value % 2 == 1 }\\n            .count <= k\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        s.count >= k && s\\n            .reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\\n            .filter { $0.value % 2 == 1 }\\n            .count <= k\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242367,
                "title": "69ms-python",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        if len(s) < k:\\n            return False\\n        freq = defaultdict(int)\\n        r = k\\n        for i in s: \\n            freq[i] += 1\\n        for i in freq.values():\\n            if i % 2:\\n                r -= 1\\n                if r == -1:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        if len(s) < k:\\n            return False\\n        freq = defaultdict(int)\\n        r = k\\n        for i in s: \\n            freq[i] += 1\\n        for i in freq.values():\\n            if i % 2:\\n                r -= 1\\n                if r == -1:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240141,
                "title": "greedy-very-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n          if(k > s.length())\\n          return false;\\n          \\n          int evencount=0;\\n          int oddcount = 0;\\n          //we will take the mapping of all the character in the string\\n          unordered_map<char,int>mp;\\n          for(int i=0;i<s.length();i++)\\n          {\\n               mp[s[i]]++;\\n          }    \\n\\n          //counting the even frequncy and odd frequency\\n          for(auto it = mp.begin() ; it!=mp.end() ; it++)\\n          {\\n              if((it->second%2) == 0)\\n              evencount++;\\n              else\\n              oddcount++;\\n          }\\n\\n          if(oddcount > k) return false;\\n          return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n          if(k > s.length())\\n          return false;\\n          \\n          int evencount=0;\\n          int oddcount = 0;\\n          //we will take the mapping of all the character in the string\\n          unordered_map<char,int>mp;\\n          for(int i=0;i<s.length();i++)\\n          {\\n               mp[s[i]]++;\\n          }    \\n\\n          //counting the even frequncy and odd frequency\\n          for(auto it = mp.begin() ; it!=mp.end() ; it++)\\n          {\\n              if((it->second%2) == 0)\\n              evencount++;\\n              else\\n              oddcount++;\\n          }\\n\\n          if(oddcount > k) return false;\\n          return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229777,
                "title": "python-easy-solution-using-dict",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s)<k:\\n            return False\\n        \\n        dict=Counter(s)\\n        odd=0\\n        for v in dict:\\n            if dict[v]%2==1:\\n                odd+=1\\n        \\n        return odd<=k\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s)<k:\\n            return False\\n        \\n        dict=Counter(s)\\n        odd=0\\n        for v in dict:\\n            if dict[v]%2==1:\\n                odd+=1\\n        \\n        return odd<=k\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228762,
                "title": "follow-this-one-simple-to-solve-intuition-explained",
                "content": "# Intuition\\n**You just need to keep one rule in mind:-**\\n*If the count of the odd frequencies in the string is greater than k, then it\\'s impossible to form k possible palindromes on that string.*\\n\\n# Approach\\nInsert every char inside hashmap. Now iterate again and count the no.of odd frequencies. Now follow the above rule. \\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        // Handling edge cases\\n        if(s.size()==k) return true;\\n        if(k > s.size()) return false;\\n        // Insert every char inside hashmap\\n        unordered_map<char,int> map;\\n        for(char c : s) map[c]++;\\n        // Now count the chars with odd frequency\\n        int freq=0;\\n        for(auto it : map){\\n            if(it.second%2 != 0) \\n                freq++;\\n        }\\n        // Apply the rule for k possible palindromes\\n        if(freq > k) return false;\\n        return true;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        // Handling edge cases\\n        if(s.size()==k) return true;\\n        if(k > s.size()) return false;\\n        // Insert every char inside hashmap\\n        unordered_map<char,int> map;\\n        for(char c : s) map[c]++;\\n        // Now count the chars with odd frequency\\n        int freq=0;\\n        for(auto it : map){\\n            if(it.second%2 != 0) \\n                freq++;\\n        }\\n        // Apply the rule for k possible palindromes\\n        if(freq > k) return false;\\n        return true;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219092,
                "title": "odd-palindrome-concept-o-n-character-freq-count",
                "content": "-> There is either an odd palindrome or an even palindrome\\n-> In an even palindrome there are no characters with count as odd\\n-> In an odd palindrome, there is only one character with count as odd\\n-> So, just calculate the count for each character in the substring and find the count of the number of odd-count characters \\n-> if the count of odd count characters is greater than the k then we cannot construct k palindromes from these characters\\n\\nT.C -> O(n + c )     S.C-> O(c),  where c is the number of characters and n is the length of the string\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length() < k) return false;\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++)\\n        {\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        int odd = 0;\\n        for(Character key: map.keySet())\\n        {\\n            if(map.get(key) % 2 == 1) odd++;\\n        }\\n        if(odd <= k) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length() < k) return false;\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++)\\n        {\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        int odd = 0;\\n        for(Character key: map.keySet())\\n        {\\n            if(map.get(key) % 2 == 1) odd++;\\n        }\\n        if(odd <= k) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213857,
                "title": "c-concise-hashmap-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k)return 0;\\n        if(s.size()==k)return 1;\\n        map<char, int> mp; \\n        for(char x: s)\\n        {\\n            mp[x]++;\\n        }\\n        for(auto &[x,y]: mp)\\n        {\\n            if(y&1) k--;\\n        }\\n        return k>=0?1:0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k)return 0;\\n        if(s.size()==k)return 1;\\n        map<char, int> mp; \\n        for(char x: s)\\n        {\\n            mp[x]++;\\n        }\\n        for(auto &[x,y]: mp)\\n        {\\n            if(y&1) k--;\\n        }\\n        return k>=0?1:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189311,
                "title": "c-short-and-concise-solution-with-explanation-o-n-time-complexity",
                "content": "# Approach\\n1) If size of the s is less than k it obviously cant be divided into k non empty strings so we return false.\\n2) We then make a map of char,int mp.\\n3) We then count the frequencies of letters in the map\\n4) Now we make a integer variable count and initialize them to 0.\\n5) Now we make a for loop in map and for any alphabet if frequency is odd we add it to count\\n6) If the count is lesser than or equal to k we return true (as we can adjust one alphabet in middle of every palindromic subsets that we make)\\n7) Else we return false.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        map<char,int> mp;\\n        for(auto x: s){\\n            mp[x]++;\\n        }\\n        int count=0;\\n        for(auto x: mp){\\n            if(x.second%2) count+=1;\\n        }\\n        if(count<=k) return true;\\n        else return false;\\n    }\\n};\\n//   PLEASE UPVOTE IF THE ANSWER WAS HELPFUL...THANK YOU\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        map<char,int> mp;\\n        for(auto x: s){\\n            mp[x]++;\\n        }\\n        int count=0;\\n        for(auto x: mp){\\n            if(x.second%2) count+=1;\\n        }\\n        if(count<=k) return true;\\n        else return false;\\n    }\\n};\\n//   PLEASE UPVOTE IF THE ANSWER WAS HELPFUL...THANK YOU\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188394,
                "title": "javascript-using-intuition-short",
                "content": "Base cases:\\n- If K > the length of the string, then we definitely can\\'t split it up into smaller pieces (\"ABC\" can\\'t be split into 4 palindromes)\\n- If K === the length of the string, then we can make each character its own palindrome\\n- We are restricted by the amount of odd numbered characters there are, if there are 3 Cs for example (\"AABBCCC\"), then we will either need to make \"C\" it\\'s own palindrome or something like \"ACA\", \"BCB\", \"CCC\".\\n- So first, we create a hashmap of all of the letters and their number of occurences. `AABBCCC` would come out to be `{ A: 2, B: 2, C: 3 }`\\n- Therefore, we can count of the number of odds occurrences there are, because we need at least 1 palindrome K for every odd occurence.\\n- In the above example, we have 1 odd number, so we can do K >= 1 (`ABCCCBA` as an example)\\n- In an example like this: `ABBCCC` we have two odd numbers (`A`, and `C`), therefore we need at least 2 palidromic sequences (`A` + `BCCCB` works. Or `BAB` + `C` + `CC` if K were 3)\\n\\nHope this helps.\\n\\n```\\nvar canConstruct = function(s, k) {\\n    if (k > s.length) return false\\n    if (k === s.length) return true\\n    const letterCount = s.split(\\'\\').reduce((acc,el) => {\\n        if (!acc[el]) acc[el] = 0\\n        acc[el] += 1\\n        return acc\\n    }, {})\\n    const numOdds = Object.values(letterCount).reduce((acc, el) => { if (el % 2 !== 0) return acc + 1; return acc}, 0)\\n    if (k < numOdds) return false\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConstruct = function(s, k) {\\n    if (k > s.length) return false\\n    if (k === s.length) return true\\n    const letterCount = s.split(\\'\\').reduce((acc,el) => {\\n        if (!acc[el]) acc[el] = 0\\n        acc[el] += 1\\n        return acc\\n    }, {})\\n    const numOdds = Object.values(letterCount).reduce((acc, el) => { if (el % 2 !== 0) return acc + 1; return acc}, 0)\\n    if (k < numOdds) return false\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1915408,
                "content": [
                    {
                        "username": "aftab0711",
                        "content": "Easy Trick:\\nEdge case: if( length of s<k) return false;\\n1. Count the frequency of every character.\\n2. Count the number of character whose frequency is odd.\\n3. If no. of odd frequency character > k return false, else return true;"
                    },
                    {
                        "username": "arheops",
                        "content": "Not true. Let say you have string AAAA and need make >4."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why the answer of \"leetcode\" if false why not true and the output could be \"l\"+ \"eee\" + \"t\" + \"c\" + \"o\" + \"d\"? the length of output clearly more than k=3 "
                    },
                    {
                        "username": "Lewis0511",
                        "content": "You need to make exactly k palindromes using all the characters. "
                    }
                ]
            },
            {
                "id": 1934761,
                "content": [
                    {
                        "username": "aftab0711",
                        "content": "Easy Trick:\\nEdge case: if( length of s<k) return false;\\n1. Count the frequency of every character.\\n2. Count the number of character whose frequency is odd.\\n3. If no. of odd frequency character > k return false, else return true;"
                    },
                    {
                        "username": "arheops",
                        "content": "Not true. Let say you have string AAAA and need make >4."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why the answer of \"leetcode\" if false why not true and the output could be \"l\"+ \"eee\" + \"t\" + \"c\" + \"o\" + \"d\"? the length of output clearly more than k=3 "
                    },
                    {
                        "username": "Lewis0511",
                        "content": "You need to make exactly k palindromes using all the characters. "
                    }
                ]
            }
        ]
    }
]