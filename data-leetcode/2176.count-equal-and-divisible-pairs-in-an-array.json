[
    {
        "title": "Count Equal and Divisible Pairs in an Array",
        "question_content": "Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 <= i < j < n, such that nums[i] == nums[j] and (i * j) is divisible by k.\n&nbsp;\nExample 1:\n\nInput: nums = [3,1,2,2,2,1,3], k = 2\nOutput: 4\nExplanation:\nThere are 4 pairs that meet all the requirements:\n- nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.\n- nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.\n- nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.\n- nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.\n\nExample 2:\n\nInput: nums = [1,2,3,4], k = 1\nOutput: 0\nExplanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 100\n\t1 <= nums[i], k <= 100",
        "solutions": [
            {
                "id": 1784521,
                "title": "o-n-sqrt-n",
                "content": "Can we do better than brute-force? We will need it to solve a follow up problem (check this post for intuition): [2183. Count Array Pairs Divisible by K](https://leetcode.com/problems/count-array-pairs-divisible-by-k/discuss/1784721/Count-GCDs).\\n\\n1. For each number, collect indexes in the increasing order.\\n2. For a number, go through its indexes:\\n\\t- Track count of each `gcd(j, k)` we encountered so far in a map. \\n\\t- For each index `i`, check its `gcd(i, k)` agains GCDs for previous indices.\\n\\t\\t- Add count to the result if `gcd(i, k) * gcd(j, k) % k == 0`.\\n\\n**C++**\\n```cpp\\nint countPairs(vector<int>& nums, int k) {\\n    int res = 0;\\n    unordered_map<int, vector<int>> m;\\n    for (int i = 0;  i < nums.size(); ++i)\\n        m[nums[i]].push_back(i);\\n    for (auto &[n, ids] : m) {\\n        unordered_map<int, int> gcds;\\n        for (auto i : ids) {\\n            auto gcd_i = gcd(i, k);\\n            for (auto &[gcd_j, cnt] : gcds)\\n                res += gcd_i * gcd_j % k ? 0 : cnt;\\n            ++gcds[gcd_i];\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint countPairs(vector<int>& nums, int k) {\\n    int res = 0;\\n    unordered_map<int, vector<int>> m;\\n    for (int i = 0;  i < nums.size(); ++i)\\n        m[nums[i]].push_back(i);\\n    for (auto &[n, ids] : m) {\\n        unordered_map<int, int> gcds;\\n        for (auto i : ids) {\\n            auto gcd_i = gcd(i, k);\\n            for (auto &[gcd_j, cnt] : gcds)\\n                res += gcd_i * gcd_j % k ? 0 : cnt;\\n            ++gcds[gcd_i];\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783416,
                "title": "java-python-3-traverse-indices-with-same-values",
                "content": "```java\\n    public int countPairs(int[] nums, int k) {\\n        Map<Integer, List<Integer>> indices = new HashMap<>();\\n        for (int i = 0; i < nums.length; ++i) {\\n            indices.computeIfAbsent(nums[i], l -> new ArrayList<>()).add(i);\\n        } \\n        int cnt = 0;\\n        for (List<Integer> ind : indices.values()) {\\n            for (int i = 0; i < ind.size(); ++i) {\\n                for (int j = 0; j < i; ++j) {\\n                    if (ind.get(i) * ind.get(j) % k == 0) {\\n                        ++cnt;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        cnt, d = 0, defaultdict(list)\\n        for i, n in enumerate(nums):\\n            d[n].append(i)\\n        for indices in d.values():    \\n            for i, a in enumerate(indices):\\n                for b in indices[: i]:\\n                    if a * b % k == 0:\\n                        cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int countPairs(int[] nums, int k) {\\n        Map<Integer, List<Integer>> indices = new HashMap<>();\\n        for (int i = 0; i < nums.length; ++i) {\\n            indices.computeIfAbsent(nums[i], l -> new ArrayList<>()).add(i);\\n        } \\n        int cnt = 0;\\n        for (List<Integer> ind : indices.values()) {\\n            for (int i = 0; i < ind.size(); ++i) {\\n                for (int j = 0; j < i; ++j) {\\n                    if (ind.get(i) * ind.get(j) % k == 0) {\\n                        ++cnt;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        cnt, d = 0, defaultdict(list)\\n        for i, n in enumerate(nums):\\n            d[n].append(i)\\n        for indices in d.values():    \\n            for i, a in enumerate(indices):\\n                for b in indices[: i]:\\n                    if a * b % k == 0:\\n                        cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1801808,
                "title": "c-hashing-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,vector<int>> umap;\\n        int count = 0;\\n        for(int i = 0; i < nums.size(); i++) \\n        {\\n            if(umap.find(nums[i]) != umap.end()) \\n            {\\n                for(auto x : umap[nums[i]]) \\n                    if((i * x) % k == 0)\\n                        count++;\\n            }\\n            \\n            umap[nums[i]].push_back(i);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,vector<int>> umap;\\n        int count = 0;\\n        for(int i = 0; i < nums.size(); i++) \\n        {\\n            if(umap.find(nums[i]) != umap.end()) \\n            {\\n                for(auto x : umap[nums[i]]) \\n                    if((i * x) % k == 0)\\n                        count++;\\n            }\\n            \\n            umap[nums[i]].push_back(i);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041940,
                "title": "c-hashmap-and-brute-force-easy-solutions",
                "content": "Hey all..\\nI have solved this in cpp using 2 methods:- Hashmap and brute force.\\nIf you have any doubts be free to ask..\\nand please upvote if you understood or found it useful :)\\n\\nThank you..\\n\\n```\\n  Method 1:- Using Hashmap\\n  TC = O( N^2) But more efficient than brute force\\n  SC = O(N)\\n  \\n  \\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        // Map of int and vector<int> to store the frequency and the indices of frequencies.\\n        unordered_map<int,vector<int>> m;\\n       \\n        int cnt=0,n=nums.size();\\n        \\n\\t\\t// Traversing the vector to insert or find in the map\\n        for(int i=0;i<n;i++){\\n\\t\\t    // If the element is already in the map\\n            if(m.find(nums[i])!=m.end()){\\n\\t\\t\\t\\t// For all indices of the element discovered\\n                for(auto a:m[nums[i]]){\\n\\t\\t\\t\\t\\t// If products remainder is zero\\n                    if((a*i)%k==0){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            // Inserting into the map to multiply for next found same elements.\\n            m[nums[i]].push_back(i);\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n\\nMethod 2:- Brute force\\nTC = O(N^2)\\nSC=  O(1)\\n\\n\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n  \\n        int cnt=0,n=nums.size();\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t     for(int j=i+1;j<n;j++){\\n\\t\\t\\t\\t if(nums[i] == nums[j] and (i*j)%k==0){\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  Method 1:- Using Hashmap\\n  TC = O( N^2) But more efficient than brute force\\n  SC = O(N)\\n  \\n  \\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        // Map of int and vector<int> to store the frequency and the indices of frequencies.\\n        unordered_map<int,vector<int>> m;\\n       \\n        int cnt=0,n=nums.size();\\n        \\n\\t\\t// Traversing the vector to insert or find in the map\\n        for(int i=0;i<n;i++){\\n\\t\\t    // If the element is already in the map\\n            if(m.find(nums[i])!=m.end()){\\n\\t\\t\\t\\t// For all indices of the element discovered\\n                for(auto a:m[nums[i]]){\\n\\t\\t\\t\\t\\t// If products remainder is zero\\n                    if((a*i)%k==0){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            // Inserting into the map to multiply for next found same elements.\\n            m[nums[i]].push_back(i);\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n\\nMethod 2:- Brute force\\nTC = O(N^2)\\nSC=  O(1)\\n\\n\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n  \\n        int cnt=0,n=nums.size();\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t     for(int j=i+1;j<n;j++){\\n\\t\\t\\t\\t if(nums[i] == nums[j] and (i*j)%k==0){\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783688,
                "title": "java-optimised-solution-hashmap-arraylist",
                "content": "A variation of : https://leetcode.com/problems/number-of-good-pairs/\\n\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n      HashMap<Integer,List<Integer>> hMap = new HashMap<>();\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(!hMap.containsKey(nums[i])){\\n                List<Integer> l = new ArrayList<>();\\n                l.add(i);\\n                hMap.put(nums[i],l);\\n            }else{\\n                List<Integer> v = hMap.get(nums[i]);\\n                for(Integer j : v){\\n                    if((i*j)%k == 0) count++;\\n                }\\n                v.add(i);\\n                hMap.put(nums[i],v);                \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n      HashMap<Integer,List<Integer>> hMap = new HashMap<>();\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(!hMap.containsKey(nums[i])){\\n                List<Integer> l = new ArrayList<>();\\n                l.add(i);\\n                hMap.put(nums[i],l);\\n            }else{\\n                List<Integer> v = hMap.get(nums[i]);\\n                for(Integer j : v){\\n                    if((i*j)%k == 0) count++;\\n                }\\n                v.add(i);\\n                hMap.put(nums[i],v);                \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264819,
                "title": "best-easiest-4-lines-of-code-in-java-beast-99-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && i*j % k==0) count++;\\n            }\\n        } return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && i*j % k==0) count++;\\n            }\\n        } return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783403,
                "title": "python3-bruteforce-oneline",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        return sum(nums[i]==nums[j] and (i*j)%k==0 for i in range(len(nums)) for j in range(i+1,len(nums)))\\n```\\nWe are taking all possible pairs from array and checking if they are good.\\nExplanation in Python:\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        answ=0\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i]==nums[j] and (i*j)%k==0:\\n                    answ+=1\\n        return answ\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        return sum(nums[i]==nums[j] and (i*j)%k==0 for i in range(len(nums)) for j in range(i+1,len(nums)))\\n```\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        answ=0\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i]==nums[j] and (i*j)%k==0:\\n                    answ+=1\\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133880,
                "title": "go-o-n-2-solution",
                "content": "```\\nfunc countPairs(nums []int, k int) int {\\n    var res int\\n    \\n    for i := 0; i < len(nums); i++ {\\n        for j := i + 1; j < len(nums); j++ {\\n            if nums[i]  == nums[j] && (i*j) % k == 0 {\\n                res++\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countPairs(nums []int, k int) int {\\n    var res int\\n    \\n    for i := 0; i < len(nums); i++ {\\n        for j := i + 1; j < len(nums); j++ {\\n            if nums[i]  == nums[j] && (i*j) % k == 0 {\\n                res++\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783447,
                "title": "python3-solution-fastest",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        c=0\\n        for i in range(0,n):\\n            for j in range(i+1,n):\\n                if nums[i]==nums[j] and ((i*j)%k==0):\\n                    c+=1\\n        return c   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        c=0\\n        for i in range(0,n):\\n            for j in range(i+1,n):\\n                if nums[i]==nums[j] and ((i*j)%k==0):\\n                    c+=1\\n        return c   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786025,
                "title": "brute-force-and-easy-understandable",
                "content": "```\\nclass Solution {\\n\\tpublic  static int countPairs(int[] arr, int k) {\\n\\t\\tint n = arr.length;\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < n; j++) {\\n\\t\\t\\t\\tif ((arr[i] == arr[j]) && ((i * j) % k == 0)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic  static int countPairs(int[] arr, int k) {\\n\\t\\tint n = arr.length;\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tfor (int j = i + 1; j < n; j++) {\\n\\t\\t\\t\\tif ((arr[i] == arr[j]) && ((i * j) % k == 0)) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783595,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if ((nums[i] == nums[j]) && ((i * j) % k == 0)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if ((nums[i] == nums[j]) && ((i * j) % k == 0)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766886,
                "title": "java-easy-solution-arrays",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i =0 ; i < nums.length; i++)\\n            for(int j = i+1; j < nums.length; j++)\\n                if(nums[i] == nums[j] && i*j%k == 0)\\n                    count++;\\n        \\n        return count;\\n    }\\n}\\n```\\n***UP-VOTE IF HELPFUL***",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i =0 ; i < nums.length; i++)\\n            for(int j = i+1; j < nums.length; j++)\\n                if(nums[i] == nums[j] && i*j%k == 0)\\n                    count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982665,
                "title": "javascript-solution-faster-than-97-07-of-javascript-online-submissions",
                "content": "```\\nvar countPairs = function(nums, k) {\\n  let counter = 0\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = i + 1; j < nums.length; j++) {\\n      nums[i] == nums[j] && ((i * j) % k) === 0 ? counter++ : null\\n    }\\n  }\\n  \\n  return counter\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPairs = function(nums, k) {\\n  let counter = 0\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = i + 1; j < nums.length; j++) {\\n      nums[i] == nums[j] && ((i * j) % k) === 0 ? counter++ : null\\n    }\\n  }\\n  \\n  return counter\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864522,
                "title": "c-brute-force-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n                if(nums[i]==nums[j] && i*j%k==0)\\n                {\\n                    count++;\\n                }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n                if(nums[i]==nums[j] && i*j%k==0)\\n                {\\n                    count++;\\n                }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789094,
                "title": "python-runtime-100-memory-100",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        counter = {}\\n        for i in range(len(nums)):\\n            if nums[i] in counter:\\n                counter[nums[i]].append(i)\\n            else:\\n                counter[nums[i]]= [i]\\n\\n        ans = 0\\n        for key, val in counter.items():\\n            length = len(val)\\n            for i in range(length-1):\\n                for j in range(i+1, length):\\n                    if val[i] * val[j] % k == 0:\\n                        ans += 1\\n        return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        counter = {}",
                "codeTag": "Java"
            },
            {
                "id": 1783476,
                "title": "python-3-80ms-easy-brute-force-n-2-approach",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        c=0\\n        for i in range(0,n):\\n            for j in range(i+1,n):\\n                if nums[i]==nums[j] and ((i*j)%k==0):\\n                    c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        c=0\\n        for i in range(0,n):\\n            for j in range(i+1,n):\\n                if nums[i]==nums[j] and ((i*j)%k==0):\\n                    c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882684,
                "title": "pyhton3-solution-using-dictionary-beats-99-7",
                "content": "# stats\\n![Screenshot 2023-08-08 at 10.04.55 PM.png](https://assets.leetcode.com/users/images/50204932-e423-445f-a363-604c06a10146_1691512534.2270777.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have a dictionary to store the indices in a array by looping through the array   \\n    We have function make which tries all combinations in the indices and checks if their product id dicvisible by k returning c\\nif length of indices is 1 we can skip the iteration\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N) due to make function\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) due to dictionary\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        d={}\\n        for i,v in enumerate(nums):\\n            if v in d:\\n                d[v].append(i)\\n            else:\\n                d|={v:[i]}\\n        s=0\\n        def make(a,n):\\n            c=0\\n            for i in range(n-1):\\n                for j in range(i+1,n):\\n                    if a[i]*a[j]%k==0:\\n                        c+=1\\n            return c\\n        for i in d:\\n            if len(d[i])==1:\\n                continue\\n            s+=make(d[i],len(d[i]))\\n        return s\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        d={}\\n        for i,v in enumerate(nums):\\n            if v in d:\\n                d[v].append(i)\\n            else:\\n                d|={v:[i]}\\n        s=0\\n        def make(a,n):\\n            c=0\\n            for i in range(n-1):\\n                for j in range(i+1,n):\\n                    if a[i]*a[j]%k==0:\\n                        c+=1\\n            return c\\n        for i in d:\\n            if len(d[i])==1:\\n                continue\\n            s+=make(d[i],len(d[i]))\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454922,
                "title": "simple-solution-beats-98-3ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n\\n                if(nums[i]==nums[j] && (i*j)%k==0)\\n                    c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n\\n                if(nums[i]==nums[j] && (i*j)%k==0)\\n                    c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766884,
                "title": "easy-java-solution-using-two-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count=0;\\n        \\n     for(int i=0 ; i<nums.length ; i++){\\n         for(int j=i+1;j<nums.length ; j++){\\n             if(nums[i] == nums[j] && i*j % k == 0){\\n                count++;\\n             }\\n         }\\n     }   \\n     return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count=0;\\n        \\n     for(int i=0 ; i<nums.length ; i++){\\n         for(int j=i+1;j<nums.length ; j++){\\n             if(nums[i] == nums[j] && i*j % k == 0){\\n                count++;\\n             }\\n         }\\n     }   \\n     return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762232,
                "title": "java-brute-and-optimised-solution",
                "content": "```\\n1. Brute Force\\n```class Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0; i<nums.length-1; i++)\\n        {\\n            for(int j=i+1; j<nums.length; j++)\\n            {\\n                if(nums[i]==nums[j] && (i*j)%k==0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n2. Optimised Solution\\n\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        HashMap<Integer, List<Integer>> map= new HashMap();\\n        int count=0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(!map.containsKey(nums[i]))\\n            {\\n                List<Integer> list= new ArrayList<>();\\n                list.add(i);\\n                map.put(nums[i], list);\\n            }\\n            else\\n            {\\n                List<Integer> list= map.get(nums[i]);\\n                for(int j: list)\\n                {\\n                    if((i * j)%k==0)\\n                        count++;\\n                }\\n                list.add(i);\\n                map.put(nums[i], list);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n1. Brute Force\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2627784,
                "title": "java-solution-brute-force-easy-understandable",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countPairs(int[] nums, int k) {\\n\\t\\t\\tint count =0;     \\n\\t\\t\\tfor(int i = 0; i < nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j = nums.length-1; j > i;j--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[i] == nums[j] && (i * j) % k == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t count++;   \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}   \\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\t\\tpublic int countPairs(int[] nums, int k) {\\n\\t\\t\\tint count =0;     \\n\\t\\t\\tfor(int i = 0; i < nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j = nums.length-1; j > i;j--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[i] == nums[j] && (i * j) % k == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t count++;   \\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2612589,
                "title": "easy-to-understand-o-n2-simple-python",
                "content": "```\\ndef countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]==nums[j] and (i*j)%k==0:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]==nums[j] and (i*j)%k==0:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2572251,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count=0;\\n  for(int i=0;i<nums.length;i++) {\\n      for(int j=i+1;j<nums.length;j++){\\n          if(nums[i]==nums[j] && (i*j)%k==0) count++;\\n      \\n      }\\n  }     \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count=0;\\n  for(int i=0;i<nums.length;i++) {\\n      for(int j=i+1;j<nums.length;j++){\\n          if(nums[i]==nums[j] && (i*j)%k==0) count++;\\n      \\n      }\\n  }     \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552105,
                "title": "simple-python-solution",
                "content": "Time complexcity O(N^2)\\nSpace Complexcity O(1)\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count=0\\n        #nums.sort()\\n        n=len(nums)\\n        for i in range(n-1):\\n            for j in range(i+1,n):\\n                if nums[i]==nums[j] and (i*j)%k==0:\\n                    count+=1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count=0\\n        #nums.sort()\\n        n=len(nums)\\n        for i in range(n-1):\\n            for j in range(i+1,n):\\n                if nums[i]==nums[j] and (i*j)%k==0:\\n                    count+=1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291829,
                "title": "python-3-easy-2-for-loops-low-memory",
                "content": "Runtime: **109 ms, faster than 81.87%** of Python3 online submissions for Count Equal and Divisible Pairs in an Array.\\nMemory Usage: **13.8 MB, less than 98.09%** of Python3 online submissions for Count Equal and Divisible Pairs in an Array.\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:  \\n\\n        c = 0 \\n        for i in range(len(nums)): \\n            for e in range(i+1, len(nums)): \\n                if nums[i] == nums[e] and i*e % k == 0:\\n                    c += 1\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: **109 ms, faster than 81.87%** of Python3 online submissions for Count Equal and Divisible Pairs in an Array.\\nMemory Usage: **13.8 MB, less than 98.09%** of Python3 online submissions for Count Equal and Divisible Pairs in an Array.\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:  \\n\\n        c = 0 \\n        for i in range(len(nums)): \\n            for e in range(i+1, len(nums)): \\n                if nums[i] == nums[e] and i*e % k == 0:\\n                    c += 1\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 2162119,
                "title": "fastest-python-solution-using-defaultdict",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        seen=defaultdict(int)\\n        pairs=[]\\n        count=0\\n        for i in range(len(nums)):\\n            if nums[i] not in seen:\\n                seen[nums[i]]=[]\\n                seen[nums[i]].append(i)\\n            else:\\n                for j in seen[nums[i]]:\\n                    pairs.append((i,j))\\n                seen[nums[i]].append(i)\\n        for (i,j) in pairs:\\n            if (i*j)%k == 0:\\n                count+=1\\n        return count\\n```\\n **Thought Processes **\\n \\nWhen confronted with an algorithm challenge, we should immediately rule out the use of brute force. If we keep track of the numbers we\\xA0see when looping over the list, we\\xA0can quickly see if there are any pairs. \\n\\nFirst we loop through the list to make a dictionary, which\\xA0storing\\xA0each encourntered\\xA0num as the key and a list of its indices\\xA0as the value using defaultdict.\\xA0\\n{\\nnum1: [idx1 of num1, idx2 of num1],\\nnum2: [idx1 of num2, idx2 of num2, idx3 of num2],\\n...\\n}\\nThe way we make this dictionary is by checking if the newly encountered num is already present in the dictionary.\\xA0\\nIf no,\\xA0we add the num and its index into the dictionary:\\xA0\\nseen[num]=[]\\nseen[num].append[idx of num]\\nif yes, we first loop through all the indices of num to generate (i, j) pairs.\\xA0\\nthen we append the\\xA0index of the num\\xA0to the dict.\\xA0\\nseen[num].append[idx of num] \\n\\ni is the current index we are in, j is the index among seen[num]\\nhere is what happens when we loop through the list: \\n3:[0]\\xA0\\n1:[1]\\xA0\\n2:[2]\\xA0\\n2:[2,3] => (3,2)\\n2:[2,3,4] =>(4,2) (4.3)\\n1:[1,5] =>(5,1)\\n3[0,6] =>(6,0)\\n\\nHaving all the i, j pairs ready, we can check if they are divisible by k or not.\\xA0\\n\\nIf you have simpler solutions, let me know!\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        seen=defaultdict(int)\\n        pairs=[]\\n        count=0\\n        for i in range(len(nums)):\\n            if nums[i] not in seen:\\n                seen[nums[i]]=[]\\n                seen[nums[i]].append(i)\\n            else:\\n                for j in seen[nums[i]]:\\n                    pairs.append((i,j))\\n                seen[nums[i]].append(i)\\n        for (i,j) in pairs:\\n            if (i*j)%k == 0:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123123,
                "title": "easy-understanding-python-dictionary-solution",
                "content": "```\\n        count = 0\\n        seen = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            if num in seen:\\n                for idx in seen[num]:\\n                    if idx * i % k == 0:\\n                        count += 1                \\n            \\n            seen[num].append(i)\\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n        count = 0\\n        seen = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            if num in seen:\\n                for idx in seen[num]:\\n                    if idx * i % k == 0:\\n                        count += 1                \\n            \\n            seen[num].append(i)\\n            \\n        return count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1983564,
                "title": "simple-python-code",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if(nums[i] == nums[j] and (i*j)%k==0):\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if(nums[i] == nums[j] and (i*j)%k==0):\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823539,
                "title": "beginner-friendly-javascript-solution",
                "content": "**Time Complexity : O(n^2)**\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countPairs = function(nums, k) {\\n    var count = 0;\\n    for(let i=0; i<nums.length; i++){\\n        for(let j=i+1; j<nums.length; j++){\\n            if(nums[i] == nums[j] && (i * j) % k == 0){\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countPairs = function(nums, k) {\\n    var count = 0;\\n    for(let i=0; i<nums.length; i++){\\n        for(let j=i+1; j<nums.length; j++){\\n            if(nums[i] == nums[j] && (i * j) % k == 0){\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1788946,
                "title": "a-few-solutions",
                "content": "Use a map `m` to create \"buckets\" index for each same value `x`, then consider each `i`,`j` index pair as a candidate for which we increment the count `cnt` per the problem statement.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countPairs(A: IntArray, K: Int): Int {\\n        var m = mutableMapOf<Int, MutableList<Int>>()\\n        for ((i, x) in A.withIndex()) {\\n            if (!m.contains(x))\\n                m[x] = mutableListOf<Int>()\\n            m[x]!!.add(i)\\n        }\\n        var cnt = 0\\n        for ((_, index) in m)\\n            for (i in index)\\n                for (j in index)\\n                    cnt += if (i < j && (i * j) % K == 0) 1 else 0\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countPairs = (A, K, m = new Map(), cnt = 0) => {\\n    for (let i = 0; i < A.length; ++i) {\\n        if (!m.has(A[i]))\\n            m.set(A[i], []);\\n        m.get(A[i]).push(i);\\n    }\\n    for (let [_, index] of m)\\n        for (let i of index)\\n            for (let j of index)\\n                cnt += Number(i < j && (i * j) % K == 0);\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countPairs(self, A: List[int], K: int, cnt = 0) -> int:\\n        m = defaultdict(list)\\n        for i, x in enumerate(A):\\n            m[x].append(i)\\n        for index in m.values():\\n            for i in index:\\n                for j in index:\\n                    cnt += int(i < j and (i * j) % K == 0)\\n        return cnt\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashMap;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn count_pairs(A: VI, K: i32) -> i32 {\\n        let mut cnt = 0;\\n        let mut m = HashMap::new();\\n        for (i, x) in A.iter().enumerate() {\\n            let mut entry = m.entry(x).or_insert(vec![]);\\n            entry.push(i);\\n        }\\n        for (x, index) in &m {\\n            for i in index {\\n                for j in index {\\n                    if i < j && (i * j) % K as usize == 0 { cnt += 1 }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, VI>;\\n    int countPairs(VI& A, int K, Map m = {}, int cnt = 0) {\\n        for (auto i{ 0 }; i < A.size(); ++i)\\n            m[A[i]].push_back(i);\\n        for (auto [x, index]: m)\\n            for (auto i: index)\\n                for (auto j: index)\\n                    cnt += i < j && (i * j) % K == 0;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countPairs(A: IntArray, K: Int): Int {\\n        var m = mutableMapOf<Int, MutableList<Int>>()\\n        for ((i, x) in A.withIndex()) {\\n            if (!m.contains(x))\\n                m[x] = mutableListOf<Int>()\\n            m[x]!!.add(i)\\n        }\\n        var cnt = 0\\n        for ((_, index) in m)\\n            for (i in index)\\n                for (j in index)\\n                    cnt += if (i < j && (i * j) % K == 0) 1 else 0\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countPairs = (A, K, m = new Map(), cnt = 0) => {\\n    for (let i = 0; i < A.length; ++i) {\\n        if (!m.has(A[i]))\\n            m.set(A[i], []);\\n        m.get(A[i]).push(i);\\n    }\\n    for (let [_, index] of m)\\n        for (let i of index)\\n            for (let j of index)\\n                cnt += Number(i < j && (i * j) % K == 0);\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def countPairs(self, A: List[int], K: int, cnt = 0) -> int:\\n        m = defaultdict(list)\\n        for i, x in enumerate(A):\\n            m[x].append(i)\\n        for index in m.values():\\n            for i in index:\\n                for j in index:\\n                    cnt += int(i < j and (i * j) % K == 0)\\n        return cnt\\n```\n```\\nuse std::collections::HashMap;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn count_pairs(A: VI, K: i32) -> i32 {\\n        let mut cnt = 0;\\n        let mut m = HashMap::new();\\n        for (i, x) in A.iter().enumerate() {\\n            let mut entry = m.entry(x).or_insert(vec![]);\\n            entry.push(i);\\n        }\\n        for (x, index) in &m {\\n            for i in index {\\n                for j in index {\\n                    if i < j && (i * j) % K as usize == 0 { cnt += 1 }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, VI>;\\n    int countPairs(VI& A, int K, Map m = {}, int cnt = 0) {\\n        for (auto i{ 0 }; i < A.size(); ++i)\\n            m[A[i]].push_back(i);\\n        for (auto [x, index]: m)\\n            for (auto i: index)\\n                for (auto j: index)\\n                    cnt += i < j && (i * j) % K == 0;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784671,
                "title": "simple-brute-force-solution-as-the-contrainsts-are-not-big",
                "content": "```\\nint countPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j] && (i*j)%k==0){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint countPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j] && (i*j)%k==0){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783422,
                "title": "python3-brute-force",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/97dff55b43563450a33c98f2a216954117100dfe) for solutions of weekly 72. \\n\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        ans = 0 \\n        for i in range(len(nums)): \\n            for j in range(i+1, len(nums)): \\n                if nums[i] == nums[j] and i*j % k == 0: ans += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        ans = 0 \\n        for i in range(len(nums)): \\n            for j in range(i+1, len(nums)): \\n                if nums[i] == nums[j] and i*j % k == 0: ans += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783368,
                "title": "easy-solution-python-5-liner",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]==nums[j] and (i*j)%k==0: count+=1\\n        return count\\n```\\n\\nDo upvote and comment..!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]==nums[j] and (i*j)%k==0: count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783274,
                "title": "accepted-c-solution",
                "content": "class Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]   &&  (i*j)%k==0){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]   &&  (i*j)%k==0){\\n                    ans++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3858268,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a direct question. The brute force approach itself is the fastest solution.\\n\\nWe just need to pick up every possible pair of numbers and try the conditions mentioned in the question.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing two for loops as shown in the code below, every pair of numbers can be picked from the array. The conditions are checked and if they are met, then a count variable is incremented.\\n\\nThis count variable is then returned as the required result.\\n\\n# Complexity\\n- Time complexity: O(n<sup>2</sup>)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis is because we are using two nested for loops to traverse through the array.\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nOnly a single variable is used to keep track of count, thus using constant space, regardless of input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[i] == nums[j] && (i*j)%k == 0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[i] == nums[j] && (i*j)%k == 0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685695,
                "title": "2176-count-equal-and-divisible-pairs-in-an-array-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        \\n        int count =0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    int x = i*j;\\n                    if(x%k==0){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        \\n        int count =0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    int x = i*j;\\n                    if(x%k==0){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677181,
                "title": "beats-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && (i * j) % k == 0){ \\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && (i * j) % k == 0){ \\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633167,
                "title": "easy-solution-java",
                "content": "The approach is very simple and understandable .\\nBy using for loop twice and if condition.a\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i] == nums[j] &&( (i*j)%k==0)){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i] == nums[j] &&( (i*j)%k==0)){\\n                    x++;\\n                }\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590296,
                "title": "easy-java-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) \\n    {\\n        int count=0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            for(int j=i+1; j<nums.length; j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    if((i*j)%k==0)\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) \\n    {\\n        int count=0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            for(int j=i+1; j<nums.length; j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    if((i*j)%k==0)\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499375,
                "title": "simple-java-solution-for-beginners-3ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i + 1; j < nums.length; j++) {\\n                if((nums[i] == nums[j]) && ((i * j) % k == 0)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i + 1; j < nums.length; j++) {\\n                if((nums[i] == nums[j]) && ((i * j) % k == 0)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493966,
                "title": "c-brute-force",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        for (int i=0; i<nums.size(); i++){\\n            for (int j=i+1; j<nums.size(); j++){\\n                if (nums[i]==nums[j] && (i*j)%k==0)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        for (int i=0; i<nums.size(); i++){\\n            for (int j=i+1; j<nums.size(); j++){\\n                if (nums[i]==nums[j] && (i*j)%k==0)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411572,
                "title": "fastest-way-with-java-beats-99-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int a = 0; a < nums.length-1; a++){\\n            for(int b = a+1; b < nums.length; b++){\\n                if(nums[a]==nums[b]){\\n                    if((a*b)%k==0){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int a = 0; a < nums.length-1; a++){\\n            for(int b = a+1; b < nums.length; b++){\\n                if(nums[a]==nums[b]){\\n                    if((a*b)%k==0){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402216,
                "title": "hashmap-solution-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI applied what I learned in `Two Sum` by using a Hashmap and mapping each value to a list of indexes within the given list. I knew I\\'d have to check each index within that list so thats why there is a `for loop` that loops through each of the indexes within `d[n]` which is storing all the indexes for a number `n`. \\n\\nThis was the first time I solved a Hashmap related question with no assistance!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n\\n        # PYTHON3 Hashmap Approach\\n\\n        # default dict hashmap\\n        d = defaultdict(list)\\n\\n        count = 0\\n\\n        # enumerate each number into index and value\\n        for i, n in enumerate(nums):\\n\\n            # we check if the number is a key to our dictionary\\n            if n in d:\\n\\n                # if it is, loop through each index that is associated\\n                # to that number and check if the product of the current\\n                # index and the index associated to the number is divisible\\n                # by k\\n                for index in d[n]:\\n                    if index * i % k == 0:\\n\\n                        # if it is divisible, increment count\\n                        count += 1\\n\\n            # after checking the hashmap, append the index to the key of the\\n            # current number\\n            d[n].append(i)\\n        \\n        # return the total count\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n\\n        # PYTHON3 Hashmap Approach\\n\\n        # default dict hashmap\\n        d = defaultdict(list)\\n\\n        count = 0\\n\\n        # enumerate each number into index and value\\n        for i, n in enumerate(nums):\\n\\n            # we check if the number is a key to our dictionary\\n            if n in d:\\n\\n                # if it is, loop through each index that is associated\\n                # to that number and check if the product of the current\\n                # index and the index associated to the number is divisible\\n                # by k\\n                for index in d[n]:\\n                    if index * i % k == 0:\\n\\n                        # if it is divisible, increment count\\n                        count += 1\\n\\n            # after checking the hashmap, append the index to the key of the\\n            # current number\\n            d[n].append(i)\\n        \\n        # return the total count\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332372,
                "title": "5-line-super-easy-java-solution-99-63-faster",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++)\\n                if (nums[i] == nums[j] && i * j % k == 0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++)\\n                if (nums[i] == nums[j] && i * j % k == 0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252937,
                "title": "count-equal-and-divisible-pairs-in-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int i, j, count=0;\\n        for(i=0 ; i<nums.size()-1 ; i++)\\n        {\\n            for(j=i+1 ; j<nums.size() ; j++)\\n            {\\n                if(nums[i]==nums[j] && (i*j)%k==0)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int i, j, count=0;\\n        for(i=0 ; i<nums.size()-1 ; i++)\\n        {\\n            for(j=i+1 ; j<nums.size() ; j++)\\n            {\\n                if(nums[i]==nums[j] && (i*j)%k==0)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152790,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n\\n    int n=nums.size();\\n    int count = 0;\\n    for (int i = 0; i < n - 1; i++)\\n    {\\n        for (int j = i + 1; j < n; j++)\\n        {\\n            if (nums[i] == nums[j] && (i * j) % k == 0)\\n            {\\n                count++;\\n            }\\n        }\\n    }\\nreturn count;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n\\n    int n=nums.size();\\n    int count = 0;\\n    for (int i = 0; i < n - 1; i++)\\n    {\\n        for (int j = i + 1; j < n; j++)\\n        {\\n            if (nums[i] == nums[j] && (i * j) % k == 0)\\n            {\\n                count++;\\n            }\\n        }\\n    }\\nreturn count;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114594,
                "title": "beats-65-34-count-equal-and-divisible-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i<j and nums[i]==nums[j] and (i*j)%k==0:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i<j and nums[i]==nums[j] and (i*j)%k==0:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767134,
                "title": "count-equal-and-divisible-pairs-in-an-array",
                "content": "class Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n                if(nums[i]==nums[j] && i*j%k==0)\\n                {\\n                    count++;\\n                }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n                if(nums[i]==nums[j] && i*j%k==0)\\n                {\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2744003,
                "title": "c-easy-to-understand-solution-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                if(nums[i] == nums[j]){\\n                    if((i*j)%k == 0)cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                if(nums[i] == nums[j]){\\n                    if((i*j)%k == 0)cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724568,
                "title": "c-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int res = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            for(int j=i+1; j<nums.size(); j++) {\\n                if(nums[i] == nums[j] && ((i*j) % k == 0)) {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int res = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            for(int j=i+1; j<nums.size(); j++) {\\n                if(nums[i] == nums[j] && ((i*j) % k == 0)) {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715857,
                "title": "python-simple-solution-in-5-lines",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        c,n=0,len(nums)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i]==nums[j] and (i*j)%k==0: c+=1\\n        return c\\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        c,n=0,len(nums)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i]==nums[j] and (i*j)%k==0: c+=1\\n        return c\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2614688,
                "title": "swift-easy-clean-solution",
                "content": "```\\nclass Solution {\\n    func countPairs(_ nums: [Int], _ k: Int) -> Int {\\n        guard !nums.isEmpty else {return 0}\\n        var numIndexDict : [Int : [Int]] = [:]\\n        var count = 0\\n        for (i,num) in nums.enumerated(){\\n            var eArray = numIndexDict[num,default:[]]\\n            eArray.forEach{ \\n                count = ($0 * i % k == 0) ? count + 1 : count\\n            }\\n            eArray.append(i)\\n            numIndexDict[num] = eArray\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countPairs(_ nums: [Int], _ k: Int) -> Int {\\n        guard !nums.isEmpty else {return 0}\\n        var numIndexDict : [Int : [Int]] = [:]\\n        var count = 0\\n        for (i,num) in nums.enumerated(){\\n            var eArray = numIndexDict[num,default:[]]\\n            eArray.forEach{ \\n                count = ($0 * i % k == 0) ? count + 1 : count\\n            }\\n            eArray.append(i)\\n            numIndexDict[num] = eArray\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491951,
                "title": "java-brute-force",
                "content": "**//Dev Bhayani**\\n\\nclass Solution {\\n    public int countPairs(int[] a, int k) {\\n        int n=a.length;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(a[i]==a[j] &&(i*j%k==0))\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int countPairs(int[] a, int k) {\\n        int n=a.length;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(a[i]==a[j] &&(i*j%k==0))\\n                {\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2457373,
                "title": "java-solution-easy-for-loop-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] arr, int k) {\\n        int cnt = 0;\\n\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            for (int j = i+1; j < arr.length; j++) {\\n                if (arr[i] == arr[j]) {\\n                    if ((i*j) % k == 0) cnt++;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] arr, int k) {\\n        int cnt = 0;\\n\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            for (int j = i+1; j < arr.length; j++) {\\n                if (arr[i] == arr[j]) {\\n                    if ((i*j) % k == 0) cnt++;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428833,
                "title": "easy-java-solution-o-n-2-but-easy-and-clean-code",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int res = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j] && (i*j)%k == 0)\\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int res = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j] && (i*j)%k == 0)\\n                    res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407441,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countPairs(vector<int>& nums, int k) {\\n\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\tfor(int i=0 ; i<nums.size() ; i++){\\n\\t\\t\\t\\tfor(int j=i+1 ; j<nums.size() ; j++){\\n\\t\\t\\t\\t\\tif(nums[i] == nums[j] && (i * j)%k == 0){\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countPairs(vector<int>& nums, int k) {\\n\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\tfor(int i=0 ; i<nums.size() ; i++){\\n\\t\\t\\t\\tfor(int j=i+1 ; j<nums.size() ; j++){\\n\\t\\t\\t\\t\\tif(nums[i] == nums[j] && (i * j)%k == 0){\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2395649,
                "title": "count-equal-and-divisible-pairs-in-an-array",
                "content": "python 3 :\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count= 0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if (nums[i]==nums[j]) and (i*j)%k==0:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count= 0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if (nums[i]==nums[j]) and (i*j)%k==0:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395646,
                "title": "count-equal-and-divisible-pairs-in-an-array-java",
                "content": "```\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j] && (i*j)%k == 0){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j] && (i*j)%k == 0){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2393017,
                "title": "go-simple-solution",
                "content": "```go\\nfunc countPairs(nums []int, k int) (count int) {\\n    n := len(nums)\\n    for i := 0; i < n-1; i++ {\\n        for j := i+1; j < n; j++ {\\n            if nums[i] != nums[j] {\\n                continue\\n            }\\n            if (i * j) % k > 0 {\\n                continue\\n            } \\n            count++\\n        }\\n    }\\n    \\n    return \\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc countPairs(nums []int, k int) (count int) {\\n    n := len(nums)\\n    for i := 0; i < n-1; i++ {\\n        for j := i+1; j < n; j++ {\\n            if nums[i] != nums[j] {\\n                continue\\n            }\\n            if (i * j) % k > 0 {\\n                continue\\n            } \\n            count++\\n        }\\n    }\\n    \\n    return \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2365125,
                "title": "ruby-one-liner",
                "content": "```\\ndef count_pairs(nums, k)\\n    nums.each_with_index.to_a.combination(2).count { |(x,i), (y, j)| x==y && i*j % k == 0 }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef count_pairs(nums, k)\\n    nums.each_with_index.to_a.combination(2).count { |(x,i), (y, j)| x==y && i*j % k == 0 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2336296,
                "title": "with-explanation-comments-time-13-ms-76-88-space-11-9-mb-30-30",
                "content": "**Like it? ->Upvote please!**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        \\n        //initialize a counter variable\\n        int counter=0;\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size()-1;i++){\\n            //loop again over them to compare\\n            for(int j=i+1;j<nums.size();j++){\\n                //condition 1: j is always smaller than i\\n                if(i>=j)\\n                    continue;\\n                \\n                //condition 2: the two numbers are equal\\n                if(nums[i]==nums[j])\\n                    //condition 3: (i*j) is divisible by the given number k\\n                    if ((i*j)%k==0)\\n                        //all conditions are passed-> add the counter by one\\n                        counter++;\\n            }\\n        }\\n        \\n        //return the counter value\\n        return counter;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "class Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        \\n        //initialize a counter variable\\n        int counter=0;\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size()-1;i++){\\n            //loop again over them to compare\\n            for(int j=i+1;j<nums.size();j++){\\n                //condition 1: j is always smaller than i\\n                if(i>=j)\\n                    continue;\\n                \\n                //condition 2: the two numbers are equal\\n                if(nums[i]==nums[j])\\n                    //condition 3: (i*j) is divisible by the given number k\\n                    if ((i*j)%k==0)\\n                        //all conditions are passed-> add the counter by one\\n                        counter++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2300518,
                "title": "c-o-n-n-time-and-o-n-space-unordered-map-easily-understandable-solution-with-explanation",
                "content": "* **We can easily design brute force using two for loops and checking any pair satisfying given conditions but** *Time Complexity : O(N2)* for brute force Approach!!\\n* **Thus to optimize our approach, we can use hash maps and especially unordered map as we just need to store all elements along with their further occurences in order.**\\n* **Unordered map is used here to map first occurence of particular element with all of it\\'s occureneces(indices) stored in a vector(list).**\\n###  **Time Complexity: O(N * N))**\\n\\n```\\nint countPairs(vector<int>& nums, int k) {\\n\\tunordered_map<int, vector<int>> mp;\\n\\tint n = nums.size();\\n\\n\\t// count variable used to track number of possible combinations satisfying given conditions in the question\\n\\n\\tint count = 0;\\n\\n\\tfor(int i=0;i<n;i++){\\n\\t\\t// We use find() method of maps to check any further occurence of our current element in given vector \\n\\t\\tif(mp.find(nums[i]) != mp.end()){\\n\\t\\t\\t// Now we can simply iterate over indices of each element stored in vector mapped according to first occurence of each element accordingly stored in our unordered map\\n\\t\\t\\tfor(auto x : mp[nums[i]])\\n\\t\\t\\t\\t// Here, we test each pair of i and x(all next occurences) for conditions given in the Question\\n\\t\\t\\t\\tif((i * x) % k == 0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\n\\t\\t// We push all other occurences after 1st occurence of any element into a seperate vector stored for each element in unordered map mp\\n\\t\\tmp[nums[i]].push_back(i);\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint countPairs(vector<int>& nums, int k) {\\n\\tunordered_map<int, vector<int>> mp;\\n\\tint n = nums.size();\\n\\n\\t// count variable used to track number of possible combinations satisfying given conditions in the question\\n\\n\\tint count = 0;\\n\\n\\tfor(int i=0;i<n;i++){\\n\\t\\t// We use find() method of maps to check any further occurence of our current element in given vector \\n\\t\\tif(mp.find(nums[i]) != mp.end()){\\n\\t\\t\\t// Now we can simply iterate over indices of each element stored in vector mapped according to first occurence of each element accordingly stored in our unordered map\\n\\t\\t\\tfor(auto x : mp[nums[i]])\\n\\t\\t\\t\\t// Here, we test each pair of i and x(all next occurences) for conditions given in the Question\\n\\t\\t\\t\\tif((i * x) % k == 0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\n\\t\\t// We push all other occurences after 1st occurence of any element into a seperate vector stored for each element in unordered map mp\\n\\t\\tmp[nums[i]].push_back(i);\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2232429,
                "title": "most-efficient-o-n-2-pointer-approach-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& v, int k) {\\n        int i = 0 ;\\n        int j = v.size() - 1 ;\\n        int n = 0 ;\\n        while ( i < j ) {\\n            if( v[i] == v[j] and (i*j)%k == 0 ) n++ ;\\n            if ( j == i+1 ) {\\n                i++ ;\\n                j = v.size() - 1 ;\\n            }\\n            else j-- ;\\n        }\\n        return n ;\\n    }\\n};\\n```\\n**Upvote**.\\n*Thank You.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& v, int k) {\\n        int i = 0 ;\\n        int j = v.size() - 1 ;\\n        int n = 0 ;\\n        while ( i < j ) {\\n            if( v[i] == v[j] and (i*j)%k == 0 ) n++ ;\\n            if ( j == i+1 ) {\\n                i++ ;\\n                j = v.size() - 1 ;\\n            }\\n            else j-- ;\\n        }\\n        return n ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131050,
                "title": "cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) \\n    {\\n        \\n       int count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j]&&(i*j)%k==0)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) \\n    {\\n        \\n       int count=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j]&&(i*j)%k==0)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043440,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i,_ in enumerate(nums):\\n            for j,_ in enumerate(nums):\\n                if i < j < len(nums) and nums[i] == nums[j]:\\n                    if (i * j) % k == 0:\\n                        count += 1\\n                            \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i,_ in enumerate(nums):\\n            for j,_ in enumerate(nums):\\n                if i < j < len(nums) and nums[i] == nums[j]:\\n                    if (i * j) % k == 0:\\n                        count += 1\\n                            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993328,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        dic = defaultdict(list)\\n        for i, n in enumerate(nums):\\n            dic[n].append(i)\\n        \\n        res = 0\\n        for v in dic.values():\\n            if len(v) > 1:\\n                res += len([ 1 for x, y in itertools.combinations(v, 2) if x * y % k == 0])\\n        \\n        return res\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        dic = defaultdict(list)\\n        for i, n in enumerate(nums):\\n            dic[n].append(i)\\n        \\n        res = 0\\n        for v in dic.values():\\n            if len(v) > 1:\\n                res += len([ 1 for x, y in itertools.combinations(v, 2) if x * y % k == 0])\\n        \\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1936078,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        return sum([1 for i in range(len(nums)) for j in range(i + 1, len(nums)) if nums[i] == nums[j] and not i * j % k])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        return sum([1 for i in range(len(nums)) for j in range(i + 1, len(nums)) if nums[i] == nums[j] and not i * j % k])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915313,
                "title": "python-3-easy-solution",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]==nums[j]:\\n                    if (i*j)%k==0:\\n                        count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]==nums[j]:\\n                    if (i*j)%k==0:\\n                        count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900319,
                "title": "python-code-very-easy-to-understand",
                "content": "class Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        \\n        c = 0\\n        n = len(nums)\\n        for i in range (n-1):\\n            for j in range (i+1,n):\\n                if((nums[i] == nums[j]) and ((i*j)%k == 0)):\\n                    c+=1\\n        return c\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        \\n        c = 0\\n        n = len(nums)\\n        for i in range (n-1):\\n            for j in range (i+1,n):\\n                if((nums[i] == nums[j]) and ((i*j)%k == 0)):\\n                    c+=1\\n        return c\\n",
                "codeTag": "Java"
            },
            {
                "id": 1843006,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]==nums[j]:\\n                    if i*j%k==0:\\n                        c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i]==nums[j]:\\n                    if i*j%k==0:\\n                        c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828272,
                "title": "easiest-and-simple-c-solution-clear-code",
                "content": "```\\nint countPairs(int* nums, int numsSize, int k){\\n    int count = 0;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n         for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]==nums[j])\\n            {\\n                if((i*j)%k==0)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nint countPairs(int* nums, int numsSize, int k){\\n    int count = 0;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n         for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[i]==nums[j])\\n            {\\n                if((i*j)%k==0)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802062,
                "title": "simple-java-solution-using-hashmap-o-n-time",
                "content": "class Solution {\\n    public int countPairs(int[] nums, int k) {\\n        HashMap<Integer,List<Integer>> map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(!map.containsKey(nums[i])){\\n                List<Integer> newList=new ArrayList<>();\\n                newList.add(i);\\n                map.put(nums[i],newList);\\n            }\\n            else{\\n                List<Integer> newList=map.get(nums[i]);\\n                for(int j:newList){\\n                    if(j*i % k ==0) count++;\\n                }\\n                newList.add(i);\\n                map.put(nums[i],newList);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countPairs(int[] nums, int k) {\\n        HashMap<Integer,List<Integer>> map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(!map.containsKey(nums[i])){\\n                List<Integer> newList=new ArrayList<>();\\n                newList.add(i);\\n                map.put(nums[i],newList);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1801942,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int arrLength = nums.length;\\n        int count=0;\\n        for(int i=1;i<arrLength;i++){\\n            for(int j=0;j<i;j++){\\n                if((i*j) % k ==0){\\n                    if(nums[i] ==nums[j]) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int arrLength = nums.length;\\n        int count=0;\\n        for(int i=1;i<arrLength;i++){\\n            for(int j=0;j<i;j++){\\n                if((i*j) % k ==0){\\n                    if(nums[i] ==nums[j]) count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1795465,
                "title": "java-3-ms",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        \\n        int len=nums.length ;\\n        int count=0;\\n\\t\\t\\n        for(int i=1;i<len;i++){\\n\\t\\t// j to check the elements to the left of index i , j<i (so that  j ,i will point to different elemnts always\\n         for(int j=0;j<i;j++){\\n\\t\\t\\t\\t\\t\\tif((i*j)%k==0){\\n\\t\\t\\t\\t\\t\\t\\tif(nums[i]==nums[j]){\\n\\t\\t\\t\\t\\t\\t\\t   count++;     \\n\\t\\t\\t\\t\\t\\t\\t}\\n            } \\n   }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        \\n        int len=nums.length ;\\n        int count=0;\\n\\t\\t\\n        for(int i=1;i<len;i++){\\n\\t\\t// j to check the elements to the left of index i , j<i (so that  j ,i will point to different elemnts always\\n         for(int j=0;j<i;j++){\\n\\t\\t\\t\\t\\t\\tif((i*j)%k==0){\\n\\t\\t\\t\\t\\t\\t\\tif(nums[i]==nums[j]){\\n\\t\\t\\t\\t\\t\\t\\t   count++;     \\n\\t\\t\\t\\t\\t\\t\\t}\\n            } \\n   }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793973,
                "title": "my-python-solution",
                "content": "class Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n\\t\\n        count = 0\\n        for i in range(len(nums) - 1):\\n            for j in range(i + 1, len(nums)):\\n                if nums[i] == nums[j] and ((i * j) % k) == 0:\\n                    count += 1\\n                    \\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n\\t\\n        count = 0\\n        for i in range(len(nums) - 1):\\n            for j in range(i + 1, len(nums)):\\n                if nums[i] == nums[j] and ((i * j) % k) == 0:\\n                    count += 1\\n                    \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1788353,
                "title": "loop-all-pairs",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i + 1; j < nums.length; j++) {\\n                if(i * j % k == 0 && nums[i] == nums[j]) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i + 1; j < nums.length; j++) {\\n                if(i * j % k == 0 && nums[i] == nums[j]) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786613,
                "title": "runtime-68-ms-faster-than-100-00-of-javascript-for-count-equal-and-divisible-pairs-in-an-array",
                "content": "Runtime: 68 ms, faster than 100.00% of JavaScript online submissions for Count Equal and Divisible Pairs in an Array.\\nMemory Usage: 42.4 MB, less than 100.00% of JavaScript online submissions for Count Equal and Divisible Pairs in an Array.\\n\\n\\n```\\nvar countPairs = function (nums, k) {\\n  let count = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = i + 1; j < nums.length; j++) {\\n      if (nums[i] === nums[j] && (i * j) % k === 0) {\\n        count++;\\n      }\\n    }\\n  }\\n  return count;\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/4338128c-b0a9-49dc-bfc6-6759cb0db76f_1645369596.1461732.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPairs = function (nums, k) {\\n  let count = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = i + 1; j < nums.length; j++) {\\n      if (nums[i] === nums[j] && (i * j) % k === 0) {\\n        count++;\\n      }\\n    }\\n  }\\n  return count;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785781,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn count_pairs(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut res = 0;\\n        let mut nums_ind = nums.iter().cloned().zip(0..).collect::<Vec<_>>();\\n        nums_ind.sort_unstable_by_key(|(x, _)| *x);\\n\\n        for (ind, &(x, i)) in nums_ind.iter().enumerate() {\\n            for &(y, j) in nums_ind[ind + 1..].iter() {\\n                match y > x {\\n                    true => break,\\n                    false if i * j % k == 0 => res += 1,\\n                    _ => (),\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_pairs(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut res = 0;\\n        let mut nums_ind = nums.iter().cloned().zip(0..).collect::<Vec<_>>();\\n        nums_ind.sort_unstable_by_key(|(x, _)| *x);\\n\\n        for (ind, &(x, i)) in nums_ind.iter().enumerate() {\\n            for &(y, j) in nums_ind[ind + 1..].iter() {\\n                match y > x {\\n                    true => break,\\n                    false if i * j % k == 0 => res += 1,\\n                    _ => (),\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785552,
                "title": "100-faster-than-others-3ms-java-solution",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0, i = 0;\\n        while(i<nums.length) {\\n            int j = i+1;\\n            while(j<nums.length) {\\n                if(nums[i]==nums[j] && (i*j)%k==0)\\n                    count++;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nAt first I initialized int count and i as 0. \\'i\\' is our initial index to iterate through\\nNow we check if i is less than the size of the array, if yes then we proceed\\nI initialized a new integer \\'j\\' that is 1 step ahead of \\'i\\'\\nAgain same thing, we check if j is less than array length\\nif yes then we put the conditions as provided in the question. To check if it is divisible we use mod operator.\\n\\nEverytime we increment counter when it passes the condition check.\\nand after while loops we increment the integers accordingly to iterate.\\n\\nlastly we return the counter value\\n\\n\\n**If my solution was help\\nPlease Upvote**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0, i = 0;\\n        while(i<nums.length) {\\n            int j = i+1;\\n            while(j<nums.length) {\\n                if(nums[i]==nums[j] && (i*j)%k==0)\\n                    count++;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783907,
                "title": "java-singlepass-solution-using-map",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        // Maps num to its index\\n        Map<Integer, List<Integer>> numIndicesMap = new HashMap<>();\\n        int numPairs = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            List<Integer> indices = numIndicesMap.computeIfAbsent(nums[i], n -> new ArrayList<>());\\n            \\n             // If num already exists in map, we loop through each index it was seen earlier and verify divisibility\\n            for (int index : indices) {\\n                if ((index * i) % k == 0) {\\n                    numPairs++;\\n                }\\n            }\\n            \\n            indices.add(i);\\n        }\\n        \\n        return numPairs;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        // Maps num to its index\\n        Map<Integer, List<Integer>> numIndicesMap = new HashMap<>();\\n        int numPairs = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            List<Integer> indices = numIndicesMap.computeIfAbsent(nums[i], n -> new ArrayList<>());\\n            \\n             // If num already exists in map, we loop through each index it was seen earlier and verify divisibility\\n            for (int index : indices) {\\n                if ((index * i) % k == 0) {\\n                    numPairs++;\\n                }\\n            }\\n            \\n            indices.add(i);\\n        }\\n        \\n        return numPairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783583,
                "title": "100-faster-using-map",
                "content": "```\\nint countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,vector<int>> freqp;\\n        int i, n=nums.size();\\n        for(i=0;i<n;i++) { // push all the indices of unique numbers\\n            freqp[nums[i]].push_back(i);\\n        }\\n        int count=0; // store the result\\n        int size, j;\\n        for(auto val: freqp) {\\n            size=val.second.size();\\n            if(size==1) // if the number occures only once\\n                continue;\\n            for(i=0;i<size;i++) { \\n                for(j=i+1;j<size;j++) {\\n                    if(val.second[i]*val.second[j]%k==0)\\n                        count++; // find the pair that satisfies the condition\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint countPairs(vector<int>& nums, int k) {\\n        unordered_map<int,vector<int>> freqp;\\n        int i, n=nums.size();\\n        for(i=0;i<n;i++) { // push all the indices of unique numbers\\n            freqp[nums[i]].push_back(i);\\n        }\\n        int count=0; // store the result\\n        int size, j;\\n        for(auto val: freqp) {\\n            size=val.second.size();\\n            if(size==1) // if the number occures only once\\n                continue;\\n            for(i=0;i<size;i++) { \\n                for(j=i+1;j<size;j++) {\\n                    if(val.second[i]*val.second[j]%k==0)\\n                        count++; // find the pair that satisfies the condition\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783508,
                "title": "c-easy-understanding",
                "content": "**Simply take a nested for loop and whenever we find nums[i]==nums[j] check the condition given in the question ie. (i+j%k==0) if condition is satisfied increment the answer.**\\n```\\nint countPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                    if((i*j)%k==0){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "**Simply take a nested for loop and whenever we find nums[i]==nums[j] check the condition given in the question ie. (i+j%k==0) if condition is satisfied increment the answer.**\\n```\\nint countPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                    if((i*j)%k==0){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1783385,
                "title": "c-brute-force-solution-beginner-friendly",
                "content": "```\\n    int countPairs(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j] &&i*j%k==0)\\n                    res++;\\n                }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int countPairs(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j] &&i*j%k==0)\\n                    res++;\\n                }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783343,
                "title": "simple-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        \\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i+1;j<n; j++){\\n                ans+=(nums[i]==nums[j] and (i*j)%k==0)?1:0;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        \\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i+1;j<n; j++){\\n                ans+=(nums[i]==nums[j] and (i*j)%k==0)?1:0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1783258,
                "title": "easy-js-javascript",
                "content": "```\\nvar countPairs = function(nums, k) {\\n    let pairs = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i + 1; j < nums.length; j++) {\\n            if (nums[i] === nums[j]) {\\n                if (i * j % k === 0) pairs++;\\n            }\\n        }\\n    }\\n    \\n    return pairs;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPairs = function(nums, k) {\\n    let pairs = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i + 1; j < nums.length; j++) {\\n            if (nums[i] === nums[j]) {\\n                if (i * j % k === 0) pairs++;\\n            }\\n        }\\n    }\\n    \\n    return pairs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783209,
                "title": "python-3-solution-this-one-is-harder-than-medium",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        pairs = 0\\n        numHash = {}\\n        for idx, num in enumerate(nums):\\n            if num in numHash:\\n                for i in numHash[num]:\\n                    if (i * idx) % k == 0:\\n                        pairs += 1\\n                numHash[num].append(idx)\\n            else:\\n                numHash[num] = [idx]\\n        return pairs\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        pairs = 0\\n        numHash = {}\\n        for idx, num in enumerate(nums):\\n            if num in numHash:\\n                for i in numHash[num]:\\n                    if (i * idx) % k == 0:\\n                        pairs += 1\\n                numHash[num].append(idx)\\n            else:\\n                numHash[num] = [idx]\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783192,
                "title": "easy-cpp-solution",
                "content": "\\nWe will use the brute force which will give the time complexity O(N*(N-1)) i.e O(N^2) where  N is length of array\\n```\\n int countPairs(vector<int>& nums, int k) {\\n        int n = nums.size() , pairs = 0;\\n\\t\\t\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            {\\n                if(nums[i] == nums[j] && (i*j) % k  ==  0)\\n                    pairs++;\\n            }\\n        }\\n        return pairs;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n int countPairs(vector<int>& nums, int k) {\\n        int n = nums.size() , pairs = 0;\\n\\t\\t\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            {\\n                if(nums[i] == nums[j] && (i*j) % k  ==  0)\\n                    pairs++;\\n            }\\n        }\\n        return pairs;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083221,
                "title": "php-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function countPairs($nums, $k) {\\n      $result = 0;\\n      $count =count($nums);\\n        for($i = 0; $i < $count; $i++){\\n          for($j = $i+1;$j < $count ; $j++){\\n            if($nums[$i]==$nums[$j] && ($i * $j) % $k == 0){\\n              $result+=1;\\n            }\\n          }\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function countPairs($nums, $k) {\\n      $result = 0;\\n      $count =count($nums);\\n        for($i = 0; $i < $count; $i++){\\n          for($j = $i+1;$j < $count ; $j++){\\n            if($nums[$i]==$nums[$j] && ($i * $j) % $k == 0){\\n              $result+=1;\\n            }\\n          }\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073181,
                "title": "python-ez",
                "content": "Don\\'t overcpmplicate stuff that is simple\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countPairs(self, nums, k):\\n        \\n        count=0\\n\\n        for i in range(0, len(nums)-1):\\n            for j in range(i+1, len(nums)):\\n                \\n                if nums[i]==nums[j] and (i*j)%k==0:\\n                    count=count+1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPairs(self, nums, k):\\n        \\n        count=0\\n\\n        for i in range(0, len(nums)-1):\\n            for j in range(i+1, len(nums)):\\n                \\n                if nums[i]==nums[j] and (i*j)%k==0:\\n                    count=count+1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069958,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int numpair =0;\\n        for(int i = 0;i<nums.size();i++){\\n            for(int j = i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j] && (i*j)%k==0){\\n                    numpair++;\\n                }\\n            }\\n            \\n        }\\n        return numpair;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int numpair =0;\\n        for(int i = 0;i<nums.size();i++){\\n            for(int j = i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j] && (i*j)%k==0){\\n                    numpair++;\\n                }\\n            }\\n            \\n        }\\n        return numpair;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068149,
                "title": "four-line-solution-using-a-dictionary",
                "content": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        dic = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            dic[num].append(i)\\n        return sum(sum(not a*b%k for a, b in combinations(list_i, 2)) for list_i in dic.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        dic = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            dic[num].append(i)\\n        return sum(sum(not a*b%k for a, b in combinations(list_i, 2)) for list_i in dic.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064849,
                "title": "understandable-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j] and i*j%k == 0:\\n                    count +=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j] and i*j%k == 0:\\n                    count +=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063543,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        ans=0\\n        n=len(nums)\\n        for i in range(0,n):\\n            for j in range(i+1,n):\\n                if nums[i]==nums[j] and (i*j)%k==0:\\n                    ans+=1\\n        return ans            \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        ans=0\\n        n=len(nums)\\n        for i in range(0,n):\\n            for j in range(i+1,n):\\n                if nums[i]==nums[j] and (i*j)%k==0:\\n                    ans+=1\\n        return ans            \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060996,
                "title": "java-brute-force-o-n-2-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int pairs = 0;\\n        for(int i=0; i<nums.length; i++) {\\n          for(int j=i+1; j<nums.length; j++) {\\n            if(nums[i] == nums[j]) {\\n              if(i * j % k == 0) {\\n                pairs += 1;\\n              }\\n            }\\n          }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int pairs = 0;\\n        for(int i=0; i<nums.length; i++) {\\n          for(int j=i+1; j<nums.length; j++) {\\n            if(nums[i] == nums[j]) {\\n              if(i * j % k == 0) {\\n                pairs += 1;\\n              }\\n            }\\n          }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058744,
                "title": "beats-100-00-of-users-with-java",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i+1; j < n; j++) {\\n                if(nums[i] == nums[j]) {\\n                    if((i * j) % k == 0) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i+1; j < n; j++) {\\n                if(nums[i] == nums[j]) {\\n                    if((i * j) % k == 0) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053304,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[i] == nums[j] && (i*j)%k == 0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                if(nums[i] == nums[j] && (i*j)%k == 0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050112,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          for(int j=i+1;j<nums.size();j++)\\n          {\\n            if(nums[i]==nums[j] && (i*j)%k==0)\\n            {\\n              count++;\\n            }\\n          }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          for(int j=i+1;j<nums.size();j++)\\n          {\\n            if(nums[i]==nums[j] && (i*j)%k==0)\\n            {\\n              count++;\\n            }\\n          }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047900,
                "title": "simple-code-with-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        i=0\\n        j=1\\n        count=0\\n        while i<len(nums)-1:\\n            if nums[i]==nums[j]:\\n                if i*j%k==0:\\n                    count+=1\\n            if j<len(nums)-1:\\n                j+=1\\n            else:\\n                i+=1\\n                j=i+1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        i=0\\n        j=1\\n        count=0\\n        while i<len(nums)-1:\\n            if nums[i]==nums[j]:\\n                if i*j%k==0:\\n                    count+=1\\n            if j<len(nums)-1:\\n                j+=1\\n            else:\\n                i+=1\\n                j=i+1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040300,
                "title": "python-optimized-one-pass-solution-simple-and-clean",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust build the dictionary when loop `nums`.\\nAnd as long as `i` is divisible by `k`, so are all the multiples of `i` so we can simply do `ans += len(dt[n])`.\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        dt = defaultdict(list)\\n        ans = 0\\n        for i, n in enumerate(nums):\\n            if i % k == 0:\\n                ans += len(dt[n])\\n            else:\\n                for idx in dt[n]:\\n                    if idx*i % k == 0:\\n                        ans += 1\\n            dt[n].append(i)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        dt = defaultdict(list)\\n        ans = 0\\n        for i, n in enumerate(nums):\\n            if i % k == 0:\\n                ans += len(dt[n])\\n            else:\\n                for idx in dt[n]:\\n                    if idx*i % k == 0:\\n                        ans += 1\\n            dt[n].append(i)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039458,
                "title": "easy-to-understand-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func countPairs(_ nums: [Int], _ k: Int) -> Int {\\n    guard nums.count > 1 else {return 0}\\n    var sum = 0\\n    \\n    for i in 0...nums.count - 2 {\\n        for j in i + 1..<nums.count {\\n            if nums[i] == nums[j] && i * j % k == 0  {\\n                sum += 1\\n            }\\n        }\\n    }\\n    \\n    return sum\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countPairs(_ nums: [Int], _ k: Int) -> Int {\\n    guard nums.count > 1 else {return 0}\\n    var sum = 0\\n    \\n    for i in 0...nums.count - 2 {\\n        for j in i + 1..<nums.count {\\n            if nums[i] == nums[j] && i * j % k == 0  {\\n                sum += 1\\n            }\\n        }\\n    }\\n    \\n    return sum\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038884,
                "title": "for-begineers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] == nums[j] && (i * j) % k == 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] == nums[j] && (i * j) % k == 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029614,
                "title": "simple-yet-efficient-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountPairs(int[] a, int k) {\\n        int n=a.Length;\\n         int count = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if (a[i] == a[j] && i<j && ((i*j)%k==0) )\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountPairs(int[] a, int k) {\\n        int n=a.Length;\\n         int count = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if (a[i] == a[j] && i<j && ((i*j)%k==0) )\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029288,
                "title": "easiest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int countPairs(int[] nums, int k) \\n    {\\n        int c = 0;\\n        for(int i = 0; i<nums.length; i++)\\n        {\\n            for(int j = 0; j<i; j++)\\n            {\\n                if(nums[i] == nums[j])\\n                {\\n                    int x = i*j;\\n                    if(x%k == 0)\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int countPairs(int[] nums, int k) \\n    {\\n        int c = 0;\\n        for(int i = 0; i<nums.length; i++)\\n        {\\n            for(int j = 0; j<i; j++)\\n            {\\n                if(nums[i] == nums[j])\\n                {\\n                    int x = i*j;\\n                    if(x%k == 0)\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026032,
                "title": "very-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if(i < j and nums[i] == nums[j] and (i*j) % k == 0):\\n                    count = count + 1\\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if(i < j and nums[i] == nums[j] and (i*j) % k == 0):\\n                    count = count + 1\\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019236,
                "title": "basic-cpp-aproach",
                "content": "# Intuition\\nUse for loop for compare and check condition where pair is divisible by k or not\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst for loop to travel n - 1 elements and second is to check the same element and to check the condition that is i < j if true increment the counter and return it.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   -> O(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n-> O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int count = 0;\\n        for(int i = 0; i < n - 1; i++){\\n            for(int j = i + 1; j < n; j++){\\n                if(nums[i] == nums[j] && (i*j)%k==0){\\n                    count ++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int count = 0;\\n        for(int i = 0; i < n - 1; i++){\\n            for(int j = i + 1; j < n; j++){\\n                if(nums[i] == nums[j] && (i*j)%k==0){\\n                    count ++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017889,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j] && (i*j)%k==0){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j] && (i*j)%k==0){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017004,
                "title": "beast-87-easy-js-solution",
                "content": "# Code\\n```\\nvar countPairs = function(nums, k) {\\n    let count = 0;\\n    for(let i = 0; i < nums.length; i++) {\\n        for(let j = i + 1; j < nums.length; j++) {\\n            if(nums[i] === nums[j] && i * j % k === 0) {\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPairs = function(nums, k) {\\n    let count = 0;\\n    for(let i = 0; i < nums.length; i++) {\\n        for(let j = i + 1; j < nums.length; j++) {\\n            if(nums[i] === nums[j] && i * j % k === 0) {\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003965,
                "title": "beats-95",
                "content": "# Intuition\\n<!-- here, we have to store the element which appear more than once and their index no. that\\'s why we need a map with int and an array which can save the elements appearing index. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int check(vector<int>& v, int k)\\n    {\\n        int count=0;\\n        for(int i=0; i<v.size()-1; i++)\\n        {\\n            int j=i+1;\\n            while(j<v.size())\\n            {\\n                if((v[i]*v[j])%k==0)\\n                    count++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int countPairs(vector<int>& nums, int k) \\n    {\\n\\n        map<int, vector<int>> m;\\n        map<int, int> v;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            m[nums[i]].insert(m[nums[i]].begin(), i);\\n            v[nums[i]]=1;\\n        }\\n        int count=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(v[nums[i]]==1 && m[nums[i]].size()>1)\\n            {\\n                v[nums[i]]=0;\\n                count += check(m[nums[i]], k);\\n            }\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int check(vector<int>& v, int k)\\n    {\\n        int count=0;\\n        for(int i=0; i<v.size()-1; i++)\\n        {\\n            int j=i+1;\\n            while(j<v.size())\\n            {\\n                if((v[i]*v[j])%k==0)\\n                    count++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int countPairs(vector<int>& nums, int k) \\n    {\\n\\n        map<int, vector<int>> m;\\n        map<int, int> v;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            m[nums[i]].insert(m[nums[i]].begin(), i);\\n            v[nums[i]]=1;\\n        }\\n        int count=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(v[nums[i]]==1 && m[nums[i]].size()>1)\\n            {\\n                v[nums[i]]=0;\\n                count += check(m[nums[i]], k);\\n            }\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998552,
                "title": "click-to-see-how-to-beat-99-by-time",
                "content": "# Intuition\\nLet\\'s append indexes to hash map. Moreover, let\\'s skip i * j % k operation if i already can be divided on k.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        ids = {}\\n        r = 0\\n        for i, n in enumerate(nums):\\n            if n in ids:\\n                if i % k == 0:\\n                    r += len(ids[n])\\n                else:        \\n                    for ind in ids[n]:\\n                        if (ind * i) % k == 0:\\n                            r += 1\\n\\n                ids[n].append(i)\\n            else:\\n                ids[n] = [i]\\n        \\n        return r\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        ids = {}\\n        r = 0\\n        for i, n in enumerate(nums):\\n            if n in ids:\\n                if i % k == 0:\\n                    r += len(ids[n])\\n                else:        \\n                    for ind in ids[n]:\\n                        if (ind * i) % k == 0:\\n                            r += 1\\n\\n                ids[n].append(i)\\n            else:\\n                ids[n] = [i]\\n        \\n        return r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993161,
                "title": "use-of-2-loops-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countPairs = function(nums, k) {\\n    let count=0;\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(nums[i]===nums[j] && Math.abs(i*j) % k == 0)\\n                count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countPairs = function(nums, k) {\\n    let count=0;\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(nums[i]===nums[j] && Math.abs(i*j) % k == 0)\\n                count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982439,
                "title": "java-simple",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDirect approach\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n\\n        int count = 0;\\n\\n        for(int i=0; i<nums.length-1; i++){\\n\\n            for(int j=i+1; j<nums.length; j++){\\n\\n                if( nums[i] == nums[j] && (i*j)%k == 0){\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n\\n        int count = 0;\\n\\n        for(int i=0; i<nums.length-1; i++){\\n\\n            for(int j=i+1; j<nums.length; j++){\\n\\n                if( nums[i] == nums[j] && (i*j)%k == 0){\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979107,
                "title": "beginners-100-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countPairs = function(nums, k) {\\n    let count = 0;\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=0;j<nums.length;j++){\\n            if(i<j && (nums[i] == nums[j]) && Math.abs(i*j) % k == 0){\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countPairs = function(nums, k) {\\n    let count = 0;\\n    for(let i=0;i<nums.length;i++){\\n        for(let j=0;j<nums.length;j++){\\n            if(i<j && (nums[i] == nums[j]) && Math.abs(i*j) % k == 0){\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977929,
                "title": "faster-than-99-python-solution-with-dictionary-d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can keep track of occurences to avoid iterating through the whole list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe store the indexes $$i$$ where each number $$n$$ has already appeared in a dictionary, where the keys of the dictonary are the distinct values of $$n$$, and the values a list of $$i$$\\'s.\\n\\nIf $$n$$ is already a key in the dictonary, we can check whether $$j \\\\times i = k$$ for every $$i$$ where $$n$$ has appeared.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$ in the worst case. Imagine a long list populated with the same value. For each $$j$$ we would do a for loop from 0 to $$j$$.\\n\\nHowever, on average it would be faster to do this than the brute force approach.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n:D\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        hash_table = {}\\n        total = 0\\n        for j, n in enumerate(nums):\\n            if n in hash_table:\\n                occurrences = hash_table[n]\\n                for i in occurrences:\\n                    if (i * j) % k == 0:\\n                        total += 1\\n                hash_table[n].append(j)\\n\\n            else:\\n                hash_table[n] = [j]\\n        return total\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        hash_table = {}\\n        total = 0\\n        for j, n in enumerate(nums):\\n            if n in hash_table:\\n                occurrences = hash_table[n]\\n                for i in occurrences:\\n                    if (i * j) % k == 0:\\n                        total += 1\\n                hash_table[n].append(j)\\n\\n            else:\\n                hash_table[n] = [j]\\n        return total\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971354,
                "title": "faster-than-99-begineer-friendly-simple-solution",
                "content": "```\\n\\tpublic int countPairs(int[] nums, int k) {\\n        int len = nums.length;\\n        int counter = 0; \\n        for(int i = 0; i < len; i++) {\\n            for(int j = i + 1; j < len; j++) {\\n                if(nums[i] == nums[j] && (i * j) % k == 0) {\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\tpublic int countPairs(int[] nums, int k) {\\n        int len = nums.length;\\n        int counter = 0; \\n        for(int i = 0; i < len; i++) {\\n            for(int j = i + 1; j < len; j++) {\\n                if(nums[i] == nums[j] && (i * j) % k == 0) {\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3964588,
                "title": "fast-python-simple-solution-bruteforce",
                "content": "\\n# Complexity\\n- Time Complexity: O(n^2)\\n- Space Complexity: O(1)\\n\\n![image.png](https://assets.leetcode.com/users/images/3ed8def6-fbb2-4d6a-ab39-fb9ea4780feb_1693086892.150843.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i] == nums[j] and (i * j) % k == 0:\\n                    count += 1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                if nums[i] == nums[j] and (i * j) % k == 0:\\n                    count += 1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957478,
                "title": "beats-99-63-in-time-98-in-space",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    if((i*j)%k==0){\\n                        count++;\\n                    }\\n\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    if((i*j)%k==0){\\n                        count++;\\n                    }\\n\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954396,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                int x = i*j;\\n                if(nums[i]==nums[j] && x%k==0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                int x = i*j;\\n                if(nums[i]==nums[j] && x%k==0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954295,
                "title": "c-solution-easy-using-count-var-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]  && (i*j)%k==0){\\n                    count+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]  && (i*j)%k==0){\\n                    count+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950945,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int pairs = 0;\\n        for(int i = 0 ; i < nums.length - 1; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && (i * j) % k == 0) pairs++;\\n            }\\n        }\\n\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int pairs = 0;\\n        for(int i = 0 ; i < nums.length - 1; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                if(nums[i] == nums[j] && (i * j) % k == 0) pairs++;\\n            }\\n        }\\n\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950051,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        \\n    int count =0;\\n    \\n    for(int i=0;i<nums.length;i++)\\n    for(int j=i+1;j<nums.length;j++){\\n        if(nums[i]==nums[j]&& (i*j)%k ==0){\\n            count++;\\n        }\\n    }\\n\\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        \\n    int count =0;\\n    \\n    for(int i=0;i<nums.length;i++)\\n    for(int j=i+1;j<nums.length;j++){\\n        if(nums[i]==nums[j]&& (i*j)%k ==0){\\n            count++;\\n        }\\n    }\\n\\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947143,
                "title": "easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(arr[i]==arr[j]&&(i*j)%k==0){\\n                    ans++;\\n\\n                }\\n            }\\n        }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(arr[i]==arr[j]&&(i*j)%k==0){\\n                    ans++;\\n\\n                }\\n            }\\n        }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944775,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int n=nums.size();int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]==nums[j] and (i*j)%k==0)\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int n=nums.size();int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]==nums[j] and (i*j)%k==0)\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944430,
                "title": "easy-js-solution-faster-than-100-of-submissions",
                "content": "```\\nvar countPairs = function (nums, k) {\\n  let count = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = i + 1; j < nums.length; j++) {\\n      if (nums[i] === nums[j] && (i * j) % k == 0) count++;\\n    }\\n  }\\n  return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar countPairs = function (nums, k) {\\n  let count = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = i + 1; j < nums.length; j++) {\\n      if (nums[i] === nums[j] && (i * j) % k == 0) count++;\\n    }\\n  }\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942064,
                "title": "easy-approach-in-java-beats-99-72-of-users-in-runtime",
                "content": "# Intuition\\nFirst of all my thought is to iterate over the array elements using a nested loop and simulataneously checking for those conditions \\n\\n# Approach\\nFirst create variable count to return the number of pairs of numbers follow up the conditions .                     \\nIterate over the array elements using nested loop to compare each element in the array with other elements ,check if the array elements equals one another in the iterations and check if the multiple of their index values are divisible by variable K given and if divisiable increament count variable \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<=(nums.length)-1;j++){\\n                    if(nums[i]==nums[j]){\\n                        if((i*j)%k==0){\\n                            count++;\\n                        }\\n                    }\\n            }\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<=(nums.length)-1;j++){\\n                    if(nums[i]==nums[j]){\\n                        if((i*j)%k==0){\\n                            count++;\\n                        }\\n                    }\\n            }\\n\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927004,
                "title": "an-easy-solution-for-count-equal-and-divisible-pairs-in-an-array-using-c-for-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int mul=0,c=0;\\n        for(int i=0;i<n;i++){\\n        for(int j=i+1;j<n;j++){\\n            if(nums[i]==nums[j]){\\n                mul=i*j;\\n                if(mul%k==0){\\n                    c++;\\n                }\\n            }\\n        }    \\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int mul=0,c=0;\\n        for(int i=0;i<n;i++){\\n        for(int j=i+1;j<n;j++){\\n            if(nums[i]==nums[j]){\\n                mul=i*j;\\n                if(mul%k==0){\\n                    c++;\\n                }\\n            }\\n        }    \\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923105,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int c=0;\\n\\n        for(int i=0; i< nums.length; i++)\\n        {\\n            for(int j=i+1; j<nums.length; j++)\\n            {\\n                if(i<j && nums[i]==nums[j] && (i*j)%k==0)\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int c=0;\\n\\n        for(int i=0; i< nums.length; i++)\\n        {\\n            for(int j=i+1; j<nums.length; j++)\\n            {\\n                if(i<j && nums[i]==nums[j] && (i*j)%k==0)\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921085,
                "title": "simplest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == nums[j] && (i*j)%k==0){\\n                    count++;\\n                }\\n            }\\n        }\\n    return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == nums[j] && (i*j)%k==0){\\n                    count++;\\n                }\\n            }\\n        }\\n    return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911186,
                "title": "brute-force",
                "content": "\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j] && (i*j)%k == 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j] && (i*j)%k == 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909530,
                "title": "brute-force-c-easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        for (int i=0; i<nums.size(); i++){\\n            for (int j=i+1; j<nums.size(); j++){\\n                if (nums[i]==nums[j] && (i*j)%k==0){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        for (int i=0; i<nums.size(); i++){\\n            for (int j=i+1; j<nums.size(); j++){\\n                if (nums[i]==nums[j] && (i*j)%k==0){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909480,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int count = 0;\\n        for(int i=0;i<nums.size()-1;i++) {\\n            for(int j=i+1;j<nums.size();j++) {\\n                if(nums[i]==nums[j] && (i*j)%k==0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int count = 0;\\n        for(int i=0;i<nums.size()-1;i++) {\\n            for(int j=i+1;j<nums.size();j++) {\\n                if(nums[i]==nums[j] && (i*j)%k==0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907023,
                "title": "count-numbers-of-pair-satisfied-the-given-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int cp=0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && (i*j)%k==0){\\n                    cp++;\\n                }\\n            }\\n        }\\n        return cp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int cp=0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i]==nums[j] && (i*j)%k==0){\\n                    cp++;\\n                }\\n            }\\n        }\\n        return cp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905812,
                "title": "c-simplest-way-anybody-can-do",
                "content": "# Intuition\\npick an element, find another which is equal, check whether divisible with given k or not, if divisible increase count by 1, return final count.\\n\\n# Approach\\nBrute Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ < T < $$O(n*n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=i+1; j<nums.size(); j++){\\n                if(nums[i]==nums[j] && (i*j)%k==0){\\n                    ans+=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=i+1; j<nums.size(); j++){\\n                if(nums[i]==nums[j] && (i*j)%k==0){\\n                    ans+=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904395,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size()-1; ++i){\\n            for(int j = i+1; j < nums.size(); ++j){\\n                if((nums[i] == nums[j]) && !((i*j)%k)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size()-1; ++i){\\n            for(int j = i+1; j < nums.size(); ++j){\\n                if((nums[i] == nums[j]) && !((i*j)%k)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903512,
                "title": "easy-bruteforce-method",
                "content": "class Solution:\\n\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count=0\\n        for i in range(0,len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if(i<j and nums[i]==nums[j] and (i*j)%k==0):\\n                    count+=1\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count=0\\n        for i in range(0,len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if(i<j and nums[i]==nums[j] and (i*j)%k==0):\\n                    count+=1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 3886635,
                "title": "python-1-super-fast-method-with-hashmap",
                "content": "# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        hashmap = {}\\n        c = 0\\n        for i in range(len(nums)):\\n            if nums[i] in hashmap:\\n                for j in hashmap[nums[i]]:\\n                    if j*i%k == 0: c += 1\\n                hashmap[nums[i]].append(i)\\n            else:\\n                hashmap[nums[i]] = [i]\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        hashmap = {}\\n        c = 0\\n        for i in range(len(nums)):\\n            if nums[i] in hashmap:\\n                for j in hashmap[nums[i]]:\\n                    if j*i%k == 0: c += 1\\n                hashmap[nums[i]].append(i)\\n            else:\\n                hashmap[nums[i]] = [i]\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875859,
                "title": "beats-99-80-of-users-with-java-count-equal-and-divisible-pairs-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j] && (i*j)%k==0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j] && (i*j)%k==0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865703,
                "title": "easy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n       int c1=0;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           for(int j=i+1;j<nums.size();j++)\\n           {\\n            if(nums[i]==nums[j])\\n            {\\n                int c=i*j;\\n                if(c%k==0)\\n                {\\n                    c1++;\\n                }\\n\\n            }          }\\n       } \\n       return c1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n       int c1=0;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           for(int j=i+1;j<nums.size();j++)\\n           {\\n            if(nums[i]==nums[j])\\n            {\\n                int c=i*j;\\n                if(c%k==0)\\n                {\\n                    c1++;\\n                }\\n\\n            }          }\\n       } \\n       return c1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865040,
                "title": "count-pairs-in-an-array-that-add-up-diff-upto-product-upto-or-divide-upto-a-certain-number-2176",
                "content": "Run time : 3ms\\nMemory : 5MB\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Code up initial checks for contraint-not-met returns first. This is so that we do not waste time and memory in computations if constraits are not met.\\n2. Looking at the dependency between i anj we do not want to run both the loops to run over the entire array. One can be restricted by the other index.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSame as intuition.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn worst case, first loop will run for entire length of the array:\\nO(numsSize)\\nIn the worst case, second loop runs till secondlast element:\\nO(numsSize - 1)\\nTherefore, time complexity will be : O(numSize^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. Allocate memory for counters and indices only if all constraints are met and there is no early return.\\n2. sizeof(int) * (numsSize + 5)  [5= i,j,k, ctr, numsSize]\\nTherefore, O(numsSize)\\n\\n# Code\\n```\\nint countPairs(int* nums, int numsSize, int k){\\n    if(!(numsSize >= 1 && numsSize <= 100))\\n    {\\n        return 0;\\n    }\\n    if(k > 100)\\n    {\\n        return 0;\\n    }\\n    int i, j, ctr = 0;\\n    for(j=0; j < numsSize; j++)\\n    {\\n        for(i=0; i < j; i++)\\n        {\\n            if(nums[i] >= 1 && nums[i] == nums[j] && ((i*j)%k == 0))\\n            {\\n                ctr = ctr + 1;\\n            }\\n        }\\n    }\\n    return ctr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countPairs(int* nums, int numsSize, int k){\\n    if(!(numsSize >= 1 && numsSize <= 100))\\n    {\\n        return 0;\\n    }\\n    if(k > 100)\\n    {\\n        return 0;\\n    }\\n    int i, j, ctr = 0;\\n    for(j=0; j < numsSize; j++)\\n    {\\n        for(i=0; i < j; i++)\\n        {\\n            if(nums[i] >= 1 && nums[i] == nums[j] && ((i*j)%k == 0))\\n            {\\n                ctr = ctr + 1;\\n            }\\n        }\\n    }\\n    return ctr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3859721,
                "title": "very-basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]&&(i*j)%k==0)\\n                    c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]&&(i*j)%k==0)\\n                    c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856839,
                "title": "easy-solution-in-c-beats-99",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]  && (i*j)%k==0)\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]==nums[j]  && (i*j)%k==0)\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852677,
                "title": "simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int n=nums.length,c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i] == nums[j] && i*j%k==0){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int n=nums.length,c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i] == nums[j] && i*j%k==0){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852242,
                "title": "python-dictionary-solution-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        dict_num = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in dict_num:\\n                dict_num[nums[i]] = [i]\\n            else:\\n                dict_num[nums[i]].append(i)\\n        \\n        ans = 0\\n        for i in dict_num:\\n            index_arr = dict_num[i]\\n            if len(index_arr) < 2:\\n                continue\\n            else:\\n                for i in range(len(index_arr)):\\n                    for j in range(i+1, len(index_arr)):\\n                        if (index_arr[i] * index_arr[j]) % k == 0:\\n                            ans += 1 \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        dict_num = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in dict_num:\\n                dict_num[nums[i]] = [i]\\n            else:\\n                dict_num[nums[i]].append(i)\\n        \\n        ans = 0\\n        for i in dict_num:\\n            index_arr = dict_num[i]\\n            if len(index_arr) < 2:\\n                continue\\n            else:\\n                for i in range(len(index_arr)):\\n                    for j in range(i+1, len(index_arr)):\\n                        if (index_arr[i] * index_arr[j]) % k == 0:\\n                            ans += 1 \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846721,
                "title": "java-brute-force-100-faster-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n\\n        int n = nums.length;\\n        int pairs = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = i + 1; j < n; j++) {\\n                if(nums[i] != nums[j]) continue;\\n                pairs += (i * j) % k == 0 ? 1 : 0;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n\\n        int n = nums.length;\\n        int pairs = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = i + 1; j < n; j++) {\\n                if(nums[i] != nums[j]) continue;\\n                pairs += (i * j) % k == 0 ? 1 : 0;\\n            }\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845392,
                "title": "python-beats-83-61-simple-solution",
                "content": "# Intuition\\nIf there is no duplicte numbers in the list then the output will be zero.\\n\\n# Approach\\n* First we will check if there is any duplicate values present or not. I any duplicates are not there then the output will be 0 without checking anything else\\n* Else, we will loop through the pair of values & check for conditions. If both conditions will satisfy then the out counter will increase by 1. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        out = 0\\n        n = len(nums)\\n        if len(set(nums)) == n:\\n            return out\\n        else:\\n            for i in range(n):\\n                for j in range(i+1,n):\\n                    if nums[i] == nums[j] and (j*i) % k == 0:\\n                        out += 1\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        out = 0\\n        n = len(nums)\\n        if len(set(nums)) == n:\\n            return out\\n        else:\\n            for i in range(n):\\n                for j in range(i+1,n):\\n                    if nums[i] == nums[j] and (j*i) % k == 0:\\n                        out += 1\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827372,
                "title": "java-solution-easy-and-use-of-simple-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if((nums[i]==nums[j])&&((i*j)%k==0)){\\n                    ans++;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if((nums[i]==nums[j])&&((i*j)%k==0)){\\n                    ans++;\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822700,
                "title": "python-solution-looped-twice",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLooped twice \\n\\n# Complexity\\n- Time complexity: 77ms Beats 29.60%of users with Python\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: 13.44mb Beats 10.40%of users with Python\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        temp = 0\\n\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j] and (i*j)%k == 0:\\n                    temp += 1\\n\\n        return temp\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        temp = 0\\n\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j] and (i*j)%k == 0:\\n                    temp += 1\\n\\n        return temp\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819654,
                "title": "sreeja-s-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(0,len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j] and (i * j) % k == 0:\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(0,len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if nums[i] == nums[j] and (i * j) % k == 0:\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816258,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) \\n    {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           for(int j=0;j<i;j++)\\n           {\\n               if(((i*j)%k==0)&&(nums[i]==nums[j]))\\n               {\\n                   count++;\\n               }\\n           }\\n        }\\n        return(count);    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) \\n    {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           for(int j=0;j<i;j++)\\n           {\\n               if(((i*j)%k==0)&&(nums[i]==nums[j]))\\n               {\\n                   count++;\\n               }\\n           }\\n        }\\n        return(count);    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811215,
                "title": "java-beginner-friendly-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] arr, int k) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                if(arr[i]==arr[j]){\\n                    if((i*j)%k==0){\\n                        count++;\\n                    }\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] arr, int k) {\\n        int count=0;\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                if(arr[i]==arr[j]){\\n                    if((i*j)%k==0){\\n                        count++;\\n                    }\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810060,
                "title": "easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]&&(i*j)%k==0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPairs(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]&&(i*j)%k==0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1786977,
                "content": [
                    {
                        "username": "mdjordhan",
                        "content": "Can it solve by a linear loop?"
                    },
                    {
                        "username": "XJMX4605",
                        "content": "![image](https://assets.leetcode.com/users/images/e63a59b2-f704-496d-9fc9-20f03f9e4340_1647774432.298709.png)\\n"
                    },
                    {
                        "username": "islombek_rakhmonov",
                        "content": "Make i and j loop, and compare them with checking if the multiplication of i and j divides by k"
                    },
                    {
                        "username": "rajarshiban13",
                        "content": "Here's my python one liner\n ```python\nreturn sum(1 if (nums[i]==nums[j] and (i*j)%k==0) else 0 for i in range(len(nums)) for j in range(i+1,len(nums)))\n\n```"
                    }
                ]
            },
            {
                "id": 1576525,
                "content": [
                    {
                        "username": "mdjordhan",
                        "content": "Can it solve by a linear loop?"
                    },
                    {
                        "username": "XJMX4605",
                        "content": "![image](https://assets.leetcode.com/users/images/e63a59b2-f704-496d-9fc9-20f03f9e4340_1647774432.298709.png)\\n"
                    },
                    {
                        "username": "islombek_rakhmonov",
                        "content": "Make i and j loop, and compare them with checking if the multiplication of i and j divides by k"
                    },
                    {
                        "username": "rajarshiban13",
                        "content": "Here's my python one liner\n ```python\nreturn sum(1 if (nums[i]==nums[j] and (i*j)%k==0) else 0 for i in range(len(nums)) for j in range(i+1,len(nums)))\n\n```"
                    }
                ]
            },
            {
                "id": 1907850,
                "content": [
                    {
                        "username": "mdjordhan",
                        "content": "Can it solve by a linear loop?"
                    },
                    {
                        "username": "XJMX4605",
                        "content": "![image](https://assets.leetcode.com/users/images/e63a59b2-f704-496d-9fc9-20f03f9e4340_1647774432.298709.png)\\n"
                    },
                    {
                        "username": "islombek_rakhmonov",
                        "content": "Make i and j loop, and compare them with checking if the multiplication of i and j divides by k"
                    },
                    {
                        "username": "rajarshiban13",
                        "content": "Here's my python one liner\n ```python\nreturn sum(1 if (nums[i]==nums[j] and (i*j)%k==0) else 0 for i in range(len(nums)) for j in range(i+1,len(nums)))\n\n```"
                    }
                ]
            },
            {
                "id": 1775393,
                "content": [
                    {
                        "username": "mdjordhan",
                        "content": "Can it solve by a linear loop?"
                    },
                    {
                        "username": "XJMX4605",
                        "content": "![image](https://assets.leetcode.com/users/images/e63a59b2-f704-496d-9fc9-20f03f9e4340_1647774432.298709.png)\\n"
                    },
                    {
                        "username": "islombek_rakhmonov",
                        "content": "Make i and j loop, and compare them with checking if the multiplication of i and j divides by k"
                    },
                    {
                        "username": "rajarshiban13",
                        "content": "Here's my python one liner\n ```python\nreturn sum(1 if (nums[i]==nums[j] and (i*j)%k==0) else 0 for i in range(len(nums)) for j in range(i+1,len(nums)))\n\n```"
                    }
                ]
            }
        ]
    }
]